<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>47xxx EERam Devices</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_eeram_device.html" title="EERAM ( Device )"><link rel="prev" href="_eeram_device.html" title="EERAM ( Device )"><link rel="next" href="_sram_device.html" title="SRAM ( Device )"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_47xxx_eeram_devices"></a>47xxx EERam Devices</h5></div></div></div><p>This section covers the 47xxx EERam devices.</p><p>The 47xxx EERam device is a memory device is organized as 512 x 8 bits or 2,048 x 8 bits of memory and utilizes the I2C serial interface.</p><p>The 47xxx provides infinite read and write cycles to the SRAM while EEPROM cells provide
high-endurance nonvolatile storage of data with more than one million store cycles to EEPROM &amp; a Data retention of &gt; 200 years.</p><p>With an external capacitor (~10uF), SRAM data is automatically transferred to the EEPROM upon loss of power, giving the advantages of NVRAM whilst eliminating the need for backup batteries.</p><p>Data can also be backed up manually by using either the Hardware Store pin (HS) or software control.</p><p>On power-up, the EEPROM data is automatically recalled to the SRAM.   EEPROM data Recall can also be initiated through software control.</p><p>Connectivity is shown below:</p><pre class="screen">            __ __
    Vcap--&gt;|  U  |&lt;-- Vcc
     A1 --&gt;|     |&lt;-- HS
     A2 --&gt;|     |&lt;-&gt; SCL
    Vss --&gt;|_____|&lt;-&gt; SDA</pre><p><span class="strong"><strong>Modes of Operation</strong></span></p><p>The SRAM allows for fast reads and writes and unlimited
endurance. As long as power is present, the data
stored in the SRAM can be updated as often as
desired.</p><p>To preserve the SRAM image, the AutoStore function
copies the entire SRAM image to an EEPROM array
whenever it detects that the voltage drops below a predetermined
level. The power for the AutoStore process
is provided by the externally connected VCAP capacitor.
Upon power-up, the entire memory contents are
restored by copying the EEPROM image to the SRAM.
This automatic restore operation is completed in milliseconds
after power-up, at the same time as when
other devices would be initializing.</p><p>There is no latency in writing to the SRAM. The SRAM
can be written to starting at any random address, and
can be written continuously throughout the array, wrapping
back to the beginning after the end is reached.
There is a small delay, specified as TWC in the data
sheet, when writing to the nonvolatile configuration bits
of the STATUS Register (SR).</p><p>Besides the AutoStore function, there are two other
methods to store the SRAM data to EEPROM:</p><p>&#8226; One method is the Hardware Store, initiated by a
rising edge on the HS pin.</p><p>&#8226; The other method is the Software Store, initiated
by writing the correct instruction to the
command register via I2C.</p><p><sub>The_paragraph_above_is_copyright_Microchip:_AN2047</sub><br></p><p><span class="strong"><strong>Explanation</strong></span></p><p>The GCBASIC constants and commands shown below control the configuration of the 47xxx EE-RAM device. &nbsp;&nbsp;&nbsp;GCBASIC supports I2C hardware and software connectivity  - this is shown in the tables below.</p><p>To use the 47xxx driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">    #include &lt;47xxx_EERAM.H&gt;

    ; ----- Define Hardware settings for EERAM Module
    #define I2C_Adr_EERAM 0x30 		; EERAM base Address
    #define EERAM_HS PortB.1   		; Optional hardware Store Pin

    Dir EERAM_HS Out           		; Rising edge initiates Backup

    EERAM_AutoStore(ON) 			; Enable Automatic Storage on power loss


    'EERAM_AutoStore(OFF) 			; Disable Automatic Storage on power loss</pre><p>The device parameters for the device are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"><col class="col_5"><col class="col_6"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Part Number</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Density (bits)</strong></span></th><th align="left" valign="top"><span class="strong"><strong>VCC Range</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Max. I2C Frequency</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Tstore Delay</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Trecall Delay</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>47L04</p></td><td align="left" valign="top"><p>4K</p></td><td align="left" valign="top"><p>2.7-3.6V</p></td><td align="left" valign="top"><p>1 MHz</p></td><td align="left" valign="top"><p>8ms</p></td><td align="left" valign="top"><p>25ms</p></td></tr><tr><td align="left" valign="top"><p>47C04</p></td><td align="left" valign="top"><p>4K</p></td><td align="left" valign="top"><p>4.5-5.5V</p></td><td align="left" valign="top"><p>1 MHz</p></td><td align="left" valign="top"><p>8ms</p></td><td align="left" valign="top"><p>2ms</p></td></tr><tr><td align="left" valign="top"><p>47L16</p></td><td align="left" valign="top"><p>16K</p></td><td align="left" valign="top"><p>2.7-3.6V</p></td><td align="left" valign="top"><p>1 MHz</p></td><td align="left" valign="top"><p>25ms</p></td><td align="left" valign="top"><p>5ms</p></td></tr><tr><td align="left" valign="top"><p>47C16</p></td><td align="left" valign="top"><p>16K</p></td><td align="left" valign="top"><p>4.5-5.5V</p></td><td align="left" valign="top"><p>1 MHz</p></td><td align="left" valign="top"><p>25ms</p></td><td align="left" valign="top"><p>5ms</p></td></tr></tbody></table></div><p>The GCBASIC constants for control of the device are:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Context</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>EERAM_I2C_Adr</p></td><td align="left" valign="top"><p>8-bit I2C Address of device</p></td><td align="left" valign="top"><p>#define I2C_Adr_EERAM 0x30</p></td><td align="left" valign="top"><p>Default is 0x30. This is mandated</p></td></tr><tr><td align="left" valign="top"><p>EERAM_HS</p></td><td align="left" valign="top"><p>Optional hardware Store Pin</p></td><td align="left" valign="top"><p>#define EERAM_HS portb.1</p></td><td align="left" valign="top"><p>No default - this is not mandated</p></td></tr><tr><td align="left" valign="top"><p>EERAM_Tstore</p></td><td align="left" valign="top"><p>Delay period for write to device</p></td><td align="left" valign="top"><p>#define EERAM_Tstore 25</p></td><td align="left" valign="top"><p>25 (ms)</p></td></tr><tr><td align="left" valign="top"><p>EERAM_Trecall</p></td><td align="left" valign="top"><p>Delay period to read from device</p></td><td align="left" valign="top"><p>#define EERAM_Trecall  5</p></td><td align="left" valign="top"><p>5 (ms)</p></td></tr></tbody></table></div><p>The GCBASIC commands for control of the device are:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Context</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>EERAM_AutoStore</p></td><td align="left" valign="top"><p>Enable Automatic Storage on power loss or Disable Automatic Storage on power loss</p></td><td align="left" valign="top"><p>EERAM_AutoStore(ON), or EERAM_AutoStore(OFF)</p></td></tr><tr><td align="left" valign="top"><p>EERAM_Status</p></td><td align="left" valign="top"><p>Read the Status Register</p></td><td align="left" valign="top"><p>User_byte_variable = EERAM_Status()</p></td></tr><tr><td align="left" valign="top"><p>EERAM_Backup</p></td><td align="left" valign="top"><p>Backup / Store Now</p></td><td align="left" valign="top"><p>EERAM_Backup()</p></td></tr><tr><td align="left" valign="top"><p>EERAM_Recall</p></td><td align="left" valign="top"><p>Restore Now</p></td><td align="left" valign="top"><p>EERAM_Recall()</p></td></tr><tr><td align="left" valign="top"><p>EERAM_HWStore</p></td><td align="left" valign="top"><p>Force Backup with HS Pin</p></td><td align="left" valign="top"><p>EERAM_HWStore()</p></td></tr><tr><td align="left" valign="top"><p>EERAM_Write</p></td><td align="left" valign="top"><p>Write a Byte of Data to address at the specified address.  The address must be a word value and the data is byte value.</p></td><td align="left" valign="top"><p>ERAM_Write( EERAM_Address_word, EERAM_Data_byte)</p></td></tr><tr><td align="left" valign="top"><p>EERAM_Read</p></td><td align="left" valign="top"><p>Read a Byte of Data from address.  The address must be a word value and returned data is byte value.</p></td><td align="left" valign="top"><p>User_byte_variable = EERAM_Read(EERAM_Address_word)</p></td></tr></tbody></table></div><p>This example shows how to use the device.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #CHIP 16F18855,32
    #OPTION EXPLICIT

    #INCLUDE &lt;47XXX_EERAM.H&gt;

    #startup InitPPS, 85

    Sub InitPPS
          'PPS is explicit to a specific chip.  Use PPSTool to ensure the PPS settings are correct.

          'Module: EUSART
              RC0PPS = 0x0010 'TX &gt; RC0
              TXPPS  = 0x0008 'RC0 &gt; TX (bi-directional)
          'Module: MSSP1
              SSP1DATPPS = 0x0013 'RC3 &gt; SDA1
              RC3PPS = 0x0015 'SDA1 &gt; RC3 (bi-directional)
              RC4PPS = 0x0014 'SCL1 &gt; RC4
              SSP1CLKPPS = 0x0014 'RC4 &gt; SCL1 (bi-directional)

        End Sub

    ; ----- Define Hardware Serial Print

    #DEFINE USART_BAUD_RATE 115200
    #DEFINE USART_TX_BLOCKING

    ; ----- Define Hardware settings for hwi2c

    #DEFINE HI2C_BAUD_RATE 400
    #DEFINE HI2C_DATA  PORTC.3
    #DEFINE HI2C_CLOCK PORTC.4

    'I2C pins need to be input for legacy I2C modules
    DIR HI2C_DATA  IN
    DIR HI2C_CLOCK IN

    'Initialise I2C Master
    hi2cMode Master

    ; ----- Define Hardware settings for EERAM Module

    #define EERAM_I2C_Adr 0x30      ; EERAM base Address
    #define EERAM_HS PortB.1        ; Optional hardware Store Pin

    Dir EERAM_HS Out                ; Rising edge initiates Backup

    'Library function
    EERAM_AutoStore(ON)             ; Enable Automatic Storage on power loss

    ; ----- Main body of program commences here.

    dim Idx as Byte

    HserPrintCRLF 2

    HserPrint "Hardware I2C EERAM Read Test at I2C Adr 0x"
    HserPrint  Hex(EERAM_I2C_Adr)
    HserPrint  " Reading RAM addresses 0x0 to 0xF" : HserPrintCRLF 2

    for Idx = 0x0 to 0xF

      HserPrint hex(Idx) + " = " : HserPrint Hex(EERAM_Read(Idx))
      If Idx = 7 or Idx = 0xf then
        HserPrintCRLF
      Else
        HserPrint " : "
      End if

    next

    HserPrintCRLF : HserPrint "Control Byte = " Hex(EERAM_Status()) : HserPrintCRLF 2

    wait 100 ms                     ; time for serial operations to complete
    end</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_i2c_overview.html" title="I2C Overview">Software I2C</a> or <a class="link" href="_hi2c_overview.html" title="HI2C Overview">Hardware I2C</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="47xxx_eeram_devices"></span>47xxx EERam Devices

</div>

</div>

</div>

This section covers the 47xxx EERam devices.

The 47xxx EERam device is a memory device is organized as 512 x 8 bits
or 2,048 x 8 bits of memory and utilizes the I2C serial interface.

The 47xxx provides infinite read and write cycles to the SRAM while
EEPROM cells provide high-endurance nonvolatile storage of data with
more than one million store cycles to EEPROM & a Data retention of &gt;
200 years.

With an external capacitor (\~10uF), SRAM data is automatically
transferred to the EEPROM upon loss of power, giving the advantages of
NVRAM whilst eliminating the need for backup batteries.

Data can also be backed up manually by using either the Hardware Store
pin (HS) or software control.

On power-up, the EEPROM data is automatically recalled to the SRAM.
EEPROM data Recall can also be initiated through software control.

Connectivity is shown below:

``` screen
            __ __
    Vcap-->|  U  |<-- Vcc
     A1 -->|     |<-- HS
     A2 -->|     |<-> SCL
    Vss -->|_____|<-> SDA
```

<span class="strong">**Modes of Operation**</span>

The SRAM allows for fast reads and writes and unlimited endurance. As
long as power is present, the data stored in the SRAM can be updated as
often as desired.

To preserve the SRAM image, the AutoStore function copies the entire
SRAM image to an EEPROM array whenever it detects that the voltage drops
below a predetermined level. The power for the AutoStore process is
provided by the externally connected VCAP capacitor. Upon power-up, the
entire memory contents are restored by copying the EEPROM image to the
SRAM. This automatic restore operation is completed in milliseconds
after power-up, at the same time as when other devices would be
initializing.

There is no latency in writing to the SRAM. The SRAM can be written to
starting at any random address, and can be written continuously
throughout the array, wrapping back to the beginning after the end is
reached. There is a small delay, specified as TWC in the data sheet,
when writing to the nonvolatile configuration bits of the STATUS
Register (SR).

Besides the AutoStore function, there are two other methods to store the
SRAM data to EEPROM:

• One method is the Hardware Store, initiated by a rising edge on the HS
pin.

• The other method is the Software Store, initiated by writing the
correct instruction to the command register via I2C.

<sub>The\_paragraph\_above\_is\_copyright\_Microchip:\_AN2047</sub>  

<span class="strong">**Explanation**</span>

The GCBASIC constants and commands shown below control the configuration
of the 47xxx EE-RAM device.    GCBASIC supports I2C hardware and
software connectivity - this is shown in the tables below.

To use the 47xxx driver simply include the following in your user code.
This will initialise the driver.

``` screen
    #include <47xxx_EERAM.H>

    ; ----- Define Hardware settings for EERAM Module
    #define I2C_Adr_EERAM 0x30      ; EERAM base Address
    #define EERAM_HS PortB.1        ; Optional hardware Store Pin

    Dir EERAM_HS Out                ; Rising edge initiates Backup

    EERAM_AutoStore(ON)             ; Enable Automatic Storage on power loss


    'EERAM_AutoStore(OFF)           ; Disable Automatic Storage on power loss
```

The device parameters for the device are shown in the table below.

<div class="informaltable">

| <span class="strong">**Part Number**</span> | <span class="strong">**Density (bits)**</span> | <span class="strong">**VCC Range**</span> | <span class="strong">**Max. I2C Frequency**</span> | <span class="strong">**Tstore Delay**</span> | <span class="strong">**Trecall Delay**</span> |
|:--------------------------------------------|:-----------------------------------------------|:------------------------------------------|:---------------------------------------------------|:---------------------------------------------|:----------------------------------------------|
| 47L04                                       | 4K                                             | 2.7-3.6V                                  | 1 MHz                                              | 8ms                                          | 25ms                                          |
| 47C04                                       | 4K                                             | 4.5-5.5V                                  | 1 MHz                                              | 8ms                                          | 2ms                                           |
| 47L16                                       | 16K                                            | 2.7-3.6V                                  | 1 MHz                                              | 25ms                                         | 5ms                                           |
| 47C16                                       | 16K                                            | 4.5-5.5V                                  | 1 MHz                                              | 25ms                                         | 5ms                                           |

</div>

The GCBASIC constants for control of the device are:

<div class="informaltable">

| <span class="strong">**Constant**</span> | <span class="strong">**Context**</span> | <span class="strong">**Example**</span> | <span class="strong">**Default**</span> |
|:-----------------------------------------|:----------------------------------------|:----------------------------------------|:----------------------------------------|
| EERAM\_I2C\_Adr                          | 8-bit I2C Address of device             | \#define I2C\_Adr\_EERAM 0x30           | Default is 0x30. This is mandated       |
| EERAM\_HS                                | Optional hardware Store Pin             | \#define EERAM\_HS portb.1              | No default - this is not mandated       |
| EERAM\_Tstore                            | Delay period for write to device        | \#define EERAM\_Tstore 25               | 25 (ms)                                 |
| EERAM\_Trecall                           | Delay period to read from device        | \#define EERAM\_Trecall 5               | 5 (ms)                                  |

</div>

The GCBASIC commands for control of the device are:

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**Context**</span>                                                                                | <span class="strong">**Example**</span>                  |
|:----------------------------------------|:-----------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------|
| EERAM\_AutoStore                        | Enable Automatic Storage on power loss or Disable Automatic Storage on power loss                                      | EERAM\_AutoStore(ON), or EERAM\_AutoStore(OFF)           |
| EERAM\_Status                           | Read the Status Register                                                                                               | User\_byte\_variable = EERAM\_Status()                   |
| EERAM\_Backup                           | Backup / Store Now                                                                                                     | EERAM\_Backup()                                          |
| EERAM\_Recall                           | Restore Now                                                                                                            | EERAM\_Recall()                                          |
| EERAM\_HWStore                          | Force Backup with HS Pin                                                                                               | EERAM\_HWStore()                                         |
| EERAM\_Write                            | Write a Byte of Data to address at the specified address. The address must be a word value and the data is byte value. | ERAM\_Write( EERAM\_Address\_word, EERAM\_Data\_byte)    |
| EERAM\_Read                             | Read a Byte of Data from address. The address must be a word value and returned data is byte value.                    | User\_byte\_variable = EERAM\_Read(EERAM\_Address\_word) |

</div>

This example shows how to use the device.

<span class="strong">**Example:**</span>

``` screen
    #CHIP 16F18855,32
    #OPTION EXPLICIT

    #INCLUDE <47XXX_EERAM.H>

    #startup InitPPS, 85

    Sub InitPPS
          'PPS is explicit to a specific chip.  Use PPSTool to ensure the PPS settings are correct.

          'Module: EUSART
              RC0PPS = 0x0010 'TX > RC0
              TXPPS  = 0x0008 'RC0 > TX (bi-directional)
          'Module: MSSP1
              SSP1DATPPS = 0x0013 'RC3 > SDA1
              RC3PPS = 0x0015 'SDA1 > RC3 (bi-directional)
              RC4PPS = 0x0014 'SCL1 > RC4
              SSP1CLKPPS = 0x0014 'RC4 > SCL1 (bi-directional)

        End Sub

    ; ----- Define Hardware Serial Print

    #DEFINE USART_BAUD_RATE 115200
    #DEFINE USART_TX_BLOCKING

    ; ----- Define Hardware settings for hwi2c

    #DEFINE HI2C_BAUD_RATE 400
    #DEFINE HI2C_DATA  PORTC.3
    #DEFINE HI2C_CLOCK PORTC.4

    'I2C pins need to be input for legacy I2C modules
    DIR HI2C_DATA  IN
    DIR HI2C_CLOCK IN

    'Initialise I2C Master
    hi2cMode Master

    ; ----- Define Hardware settings for EERAM Module

    #define EERAM_I2C_Adr 0x30      ; EERAM base Address
    #define EERAM_HS PortB.1        ; Optional hardware Store Pin

    Dir EERAM_HS Out                ; Rising edge initiates Backup

    'Library function
    EERAM_AutoStore(ON)             ; Enable Automatic Storage on power loss

    ; ----- Main body of program commences here.

    dim Idx as Byte

    HserPrintCRLF 2

    HserPrint "Hardware I2C EERAM Read Test at I2C Adr 0x"
    HserPrint  Hex(EERAM_I2C_Adr)
    HserPrint  " Reading RAM addresses 0x0 to 0xF" : HserPrintCRLF 2

    for Idx = 0x0 to 0xF

      HserPrint hex(Idx) + " = " : HserPrint Hex(EERAM_Read(Idx))
      If Idx = 7 or Idx = 0xf then
        HserPrintCRLF
      Else
        HserPrint " : "
      End if

    next

    HserPrintCRLF : HserPrint "Control Byte = " Hex(EERAM_Status()) : HserPrintCRLF 2

    wait 100 ms                     ; time for serial operations to complete
    end
```

<span class="strong">**For more help, see**</span>
<a href="i2c_overview" class="link" title="I2C Overview">Software I2C</a>
or
<a href="hi2c_overview" class="link" title="HI2C Overview">Hardware I2C</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>7-Segment Displays</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_randomize.html" title="Randomize"><link rel="next" href="_7_segment_displays_overview.html" title="7 Segment Displays Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_7_segment_displays"></a>7-Segment Displays</h3></div></div></div><p>This is the 7-Segment Displays section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="7_segment_displays"></span>7-Segment Displays

</div>

</div>

</div>

This is the 7-Segment Displays section of the Help file. Please refer
the sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>7 Segment Displays - Legacy</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_overview.html" title="7 Segment Displays Overview"><link rel="prev" href="_7_segment_displays_overview.html" title="7 Segment Displays Overview"><link rel="next" href="_common_cathode.html" title="Common Cathode"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_7_segment_displays_legacy"></a>7 Segment Displays - Legacy</h5></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>The GCBASIC 7 segment display methods make it easier for GCBASIC programs to display numbers and letters on 7 segment LED displays.</p><p>The GCBASIC methods support up to four digit 7 segment display devices, common anode/cathode and inversion of the port logic to support driving the device(s) via a transistor.</p><p>There are three ways that the 7 segment display routines can be set up.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Method</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>1</p></td><td align="left" valign="top"><p>Connect the microcontroller to the 7 segment display (via suitable resistors) using  any eight output bits.
</p><p>Use <code class="literal">DISP_SEG_x</code> and <code class="literal">DISP_SEL_x</code> constants to specify the outpout ports and the select port(s) to be used.</p></td></tr><tr><td align="left" valign="top"><p>2</p></td><td align="left" valign="top"><p>Connect the microcontroller to the 7 segment display (via suitable resistors) using whole port (8 bits) of the microcontroller.
</p><p>This implies the connections are consectutive in terms of the 8 output bits of the port.
</p><p>Use the <code class="literal">DISPLAYPORTn</code> and <code class="literal">DISPSELECTn</code> constants to specify the whole port and the select port(s) to be used.
</p><p>This method will generate the most efficient code.</p></td></tr><tr><td align="left" valign="top"><p>3</p></td><td align="left" valign="top"><p>Connect the microcontroller to the 7 segment display (via suitable resistors) using whole port (8 bits) of the microcontroller.
</p><p>This implies the connections are consectutive in terms of the 8 output bits of the port.
</p><p>Use the <code class="literal">DISPLAYPORTn</code> and <code class="literal">DISP_SEL_n</code> constants to specify the whole port and the select port(s) to be used.</p></td></tr></tbody></table></div><p>The GCBASIC methods  assume the 7 segment display(s) is to be connected to a common
parallel bus with a Common Cathode.   See the sections
<a class="link" href="_common_cathode.html" title="Common Cathode">Common Cathode</a> and
<a class="link" href="_common_anode.html" title="Common Anode">Common Anode</a> for examples of using GCBASIC code to
control these different configurations</p><p>Shown below are the differing constants that must be set for the three connectivity options.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"><col class="col_5"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Index</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Method</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Description</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>1</p></td><td align="left" valign="top"><p><code class="literal">DISP_SEG_x</code> &amp; <code class="literal">DISP_SEL_x</code></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">DISP_SEG_x</code></p></td><td align="left" valign="top"><p>Specifies the output pin (output bit) used to control a specific segment of the 7 segment display.
</p><p>There are seven constants that must be specified.
</p><p><code class="literal">DISP_SEG_A</code> through <code class="literal">DISP_SEG_G</code>. One
must be set for each segment.
</p><p>Typical commands are:
</p><p><code class="literal">#define DISP_SEG_A portA.0</code>
</p><p><code class="literal">#define DISP_SEG_B portA.1</code>
</p><p><code class="literal">#define DISP_SEG_C portA.2</code>
</p><p><code class="literal">#define DISP_SEG_D portA.3</code>
</p><p><code class="literal">#define DISP_SEG_E portA.4</code>
</p><p><code class="literal">#define DISP_SEG_F portA.5</code>
</p><p><code class="literal">#define DISP_SEG_G portA.6</code></p></td><td align="left" valign="top"><p>Must be specified to use this connectivity option.</p></td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">DISP_SEG_DOT</code></p></td><td align="left" valign="top"><p>Specifies the output pin (output bit) used to control the decimal point on the
7 segment display.
</p><p>Typical commands are:
</p><p><code class="literal">#define DISP_SEG_DOT portA.7</code></p></td><td align="left" valign="top"><p>Optional.</p></td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">DISP_SEL_x</code></p></td><td align="left" valign="top"><p>Specifies the output pin (output bit) used to control a specific 7 segment display.
</p><p>These constants are used to control the specific 7 segment display being addresses.
</p><p>Typical commands are:
</p><p><code class="literal">#define DISP_SEL_1 portA.0</code>
</p><p><code class="literal">#define DISP_SEL_2 portA.1</code></p></td><td align="left" valign="top"><p>A valid output pin (output bit) must be specified.  Must be specified to use this connectivity option.</p></td></tr><tr><td align="left" valign="top"><p>2</p></td><td align="left" valign="top"><p><code class="literal">DISPLAYPORTn</code> &amp; <code class="literal">DISPSELECTn</code></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">DISPLAYPORTn</code></p></td><td align="left" valign="top"><p>Specifies the output port used to control the 7 segment display.
</p><p>Port.bit &gt;&gt; Segment
</p><p>port.0      &gt;&gt;   A
</p><p>port.1     &gt;&gt;   B
</p><p>port.2     &gt;&gt;   C
</p><p>port.3     &gt;&gt;   D
</p><p>port.4     &gt;&gt;   E
</p><p>port.5     &gt;&gt;   F
</p><p>port.6     &gt;&gt;   G</p></td><td align="left" valign="top"><p>Can be <code class="literal">DISPLAYPORTA</code> and/or <code class="literal">DISPLAYPORTB</code> and/or <code class="literal">DISPLAYPORTC</code> and/or <code class="literal">DISPLAYPORTD</code>
</p><p>Where <code class="literal">DISPLAYPORTn</code> can be A, B, C or D which corresponding to displays 1, 2, 3 and 4, respectively.
</p><p>Must be specified to use this connectivity option.</p></td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">DISPSELECTn</code></p></td><td align="left" valign="top"><p>Specifies the output command used to <span class="strong"><strong>select</strong></span> a specific 7 segment display addressed by <code class="literal">DISPLAYPORT_n</code>.
</p><p>Used to control output pin (output bit) when several displays are multiplexed.
</p><p>Typical commands are:
    <code class="literal">#define DispSelectA Set portA.0 on</code>
</p><p>    <code class="literal">#define DispSelectB Set portA.1 on</code></p></td><td align="left" valign="top"><p>Can be <code class="literal">DISPSELECTA</code> and/or <code class="literal">DISPSELECTB</code> and/or <code class="literal">DISPSELECTC</code> and/or <code class="literal">DISPSELECTD</code>
</p><p>Must be specified to use this connectivity option.</p></td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">DISPDESELECTn</code></p></td><td align="left" valign="top"><p>An optional command to specify the output command used to <span class="strong"><strong>deselect</strong></span> a specific 7 segment display addressed by <code class="literal">DISPLAYPORT_n</code>.
</p><p>Used to control output pin (output bit) when several displays are multiplexed.
</p><p>Typical commands are:
</p><p>    <code class="literal">#define DispDeSelectA Set portA.0 off</code>
</p><p>    <code class="literal">#define DispDeSelectB Set portA.1 off</code></p></td><td align="left" valign="top"><p>Can be <code class="literal">DISPDESELECTA</code> and/or <code class="literal">DISPDESELECTB</code> and/or <code class="literal">DISPDESELECTC</code> and/or <code class="literal">DISPDESELECTD</code></p></td></tr><tr><td align="left" valign="top"><p>3</p></td><td align="left" valign="top"><p><code class="literal">DISPLAYPORTn</code> &amp; <code class="literal">DISP_SEL_n</code></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">DISPLAYPORTn</code></p></td><td align="left" valign="top"><p>Specifies the output port used to control the 7 segment display.
</p><p>Port.bit &gt;&gt; Segment
</p><p>port.0      &gt;&gt;   A
</p><p>port.1     &gt;&gt;   B
</p><p>port.2     &gt;&gt;   C
</p><p>port.3     &gt;&gt;   D
</p><p>port.4     &gt;&gt;   E
</p><p>port.5     &gt;&gt;   F
</p><p>port.6     &gt;&gt;   G</p></td><td align="left" valign="top"><p>Can be <code class="literal">DISPLAYPORTA</code> and/or <code class="literal">DISPLAYPORTB</code> and/or <code class="literal">DISPLAYPORTC</code> and/or <code class="literal">DISPLAYPORTD</code>
</p><p>Where <code class="literal">DISPLAYPORTn</code> can be A, B, C or D which corresponding to displays 1, 2, 3 and 4, respectively.
</p><p>Must be specified to use this connectivity option.</p></td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">DISP_SEL_n</code></p></td><td align="left" valign="top"><p>Specifies the output command used to select a specific 7 segment display addressed by <code class="literal">DISPLAYPORTn</code>.
</p><p>Typical commands are:
</p><p>    <code class="literal">#define DISP_SEL_1 portA.0</code>
</p><p>    <code class="literal">#define DISP_SEL_2 portA.1</code></p></td><td align="left" valign="top"><p>Must be specified to use this connectivity option.
</p><p>Can be specified as <code class="literal">DISP_SEL_1</code> and/or <code class="literal">DISP_SEL_2</code> and/or <code class="literal">DISP_SEL_3</code> and/or <code class="literal">DISP_SEL_4</code></p></td></tr></tbody></table></div><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">        'A Common Cathode 7 Segment display  2 digit example
        #chip 16F886, 8

        'support for Common Anode
        '#DEFINE 7SEG_COMMONANODE

        'support for pfet or pnp high side drivers
        '#DEFINE 7SEG_HIGHSIDE

        ' ----- Constants
        'You need to specify the port settings
        'by one of the following three methods
        'The Directions of the ports are automaically set according to the defines

        'METHOD 1
        'Define individual port pins for segments and selects

        #DEFINE DISP_SEG_A PORTB.0
        #DEFINE DISP_SEG_B PORTB.1
        #DEFINE DISP_SEG_C PORTB.2
        #DEFINE DISP_SEG_D PORTB.3
        #DEFINE DISP_SEG_E PORTB.4
        #DEFINE DISP_SEG_F PORTB.5
        #DEFINE DISP_SEG_G PORTB.6
        #DEFINE DISP_SEG_DOT PORTB.7 '' available on some displays as dp or colon

        #DEFINE DISP_SEL_1 PORTC.5
        #DEFINE DISP_SEL_2 PORTC.4

        'METHOD 2  Define DISPLAYPORTA (B,C,D) for up to 4 digit display segments
        'Define DISPSELECTA (B,C,D) for up to 4 digit display selects

        '#DEFINE DISPLAYPORTA PORTB   ' same port name can be assigned
        '#DEFINE DISPLAYPORTB PORTB

        '#DEFINE DispSelectA Set portC.5 off
        '#DEFINE DispSelectB Set portC.4 off
        '#DEFINE DispDeSelectA Set portC.5 on
        '#DEFINE DispDeSelectB Set portC.4 on

        'METHOD 3  Define DISPLAYPORTA (B,C,D) for up to 4 digit display segments
        'Define port pins for the digit display  selects

        '#DEFINE DISPLAYPORTA PORTB
        '#DEFINE DISPLAYPORTB PORTB

        '#DEFINE DISP_SEL_1 PORTC.5
        '#DEFINE DISP_SEL_2 PORTC.4



        Dim Message As String
        Message = " HAPPY HOLIDAYS  "
        Do
            For Counter = 1 to len(Message)-1
            Repeat 50
                Displaychar 1, Message(Counter)
                wait 3 ms
                DisplayChar 2, Message(Counter+1)
                wait 3 ms

            End Repeat
            Wait 100 ms
            Next
        Loop</pre><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/CC_4dig_7seg_16F886_Schem.jpg" align="middle" alt="graphic"></div></div><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/CA_2Dig_7seg_16F886_schem.jpg" align="middle" alt="graphic"></div></div><p><span class="strong"><strong>Also, see</strong></span> <a class="link" href="_displaychar.html" title="DisplayChar">DisplayChar</a>,
<a class="link" href="_displayvalue.html" title="DisplayValue">DisplayValue</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="7_segment_displays_legacy"></span>7 Segment Displays - Legacy

</div>

</div>

</div>

<span class="strong">**Introduction**</span>

The GCBASIC 7 segment display methods make it easier for GCBASIC
programs to display numbers and letters on 7 segment LED displays.

The GCBASIC methods support up to four digit 7 segment display devices,
common anode/cathode and inversion of the port logic to support driving
the device(s) via a transistor.

There are three ways that the 7 segment display routines can be set up.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Method</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Description</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"><p>Connect the microcontroller to the 7 segment display (via suitable resistors) using any eight output bits.</p>
<p>Use <code class="literal">DISP_SEG_x</code> and <code class="literal">DISP_SEL_x</code> constants to specify the outpout ports and the select port(s) to be used.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>2</p></td>
<td style="text-align: left;"><p>Connect the microcontroller to the 7 segment display (via suitable resistors) using whole port (8 bits) of the microcontroller.</p>
<p>This implies the connections are consectutive in terms of the 8 output bits of the port.</p>
<p>Use the <code class="literal">DISPLAYPORTn</code> and <code class="literal">DISPSELECTn</code> constants to specify the whole port and the select port(s) to be used.</p>
<p>This method will generate the most efficient code.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>3</p></td>
<td style="text-align: left;"><p>Connect the microcontroller to the 7 segment display (via suitable resistors) using whole port (8 bits) of the microcontroller.</p>
<p>This implies the connections are consectutive in terms of the 8 output bits of the port.</p>
<p>Use the <code class="literal">DISPLAYPORTn</code> and <code class="literal">DISP_SEL_n</code> constants to specify the whole port and the select port(s) to be used.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC methods assume the 7 segment display(s) is to be connected
to a common parallel bus with a Common Cathode. See the sections
<a href="common_cathode" class="link" title="Common Cathode">Common Cathode</a>
and
<a href="common_anode" class="link" title="Common Anode">Common Anode</a>
for examples of using GCBASIC code to control these different
configurations

Shown below are the differing constants that must be set for the three
connectivity options.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Index</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Method</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Description</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Default Value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"><p><code class="literal">DISP_SEG_x</code> &amp; <code class="literal">DISP_SEL_x</code></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><p><code class="literal">DISP_SEG_x</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin (output bit) used to control a specific segment of the 7 segment display.</p>
<p>There are seven constants that must be specified.</p>
<p><code class="literal">DISP_SEG_A</code> through <code class="literal">DISP_SEG_G</code>. One must be set for each segment.</p>
<p>Typical commands are:</p>
<p><code class="literal">#define DISP_SEG_A portA.0</code></p>
<p><code class="literal">#define DISP_SEG_B portA.1</code></p>
<p><code class="literal">#define DISP_SEG_C portA.2</code></p>
<p><code class="literal">#define DISP_SEG_D portA.3</code></p>
<p><code class="literal">#define DISP_SEG_E portA.4</code></p>
<p><code class="literal">#define DISP_SEG_F portA.5</code></p>
<p><code class="literal">#define DISP_SEG_G portA.6</code></p></td>
<td style="text-align: left;"><p>Must be specified to use this connectivity option.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><p><code class="literal">DISP_SEG_DOT</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin (output bit) used to control the decimal point on the 7 segment display.</p>
<p>Typical commands are:</p>
<p><code class="literal">#define DISP_SEG_DOT portA.7</code></p></td>
<td style="text-align: left;"><p>Optional.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><p><code class="literal">DISP_SEL_x</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin (output bit) used to control a specific 7 segment display.</p>
<p>These constants are used to control the specific 7 segment display being addresses.</p>
<p>Typical commands are:</p>
<p><code class="literal">#define DISP_SEL_1 portA.0</code></p>
<p><code class="literal">#define DISP_SEL_2 portA.1</code></p></td>
<td style="text-align: left;"><p>A valid output pin (output bit) must be specified. Must be specified to use this connectivity option.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>2</p></td>
<td style="text-align: left;"><p><code class="literal">DISPLAYPORTn</code> &amp; <code class="literal">DISPSELECTn</code></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><p><code class="literal">DISPLAYPORTn</code></p></td>
<td style="text-align: left;"><p>Specifies the output port used to control the 7 segment display.</p>
<p>Port.bit &gt;&gt; Segment</p>
<p>port.0 &gt;&gt; A</p>
<p>port.1 &gt;&gt; B</p>
<p>port.2 &gt;&gt; C</p>
<p>port.3 &gt;&gt; D</p>
<p>port.4 &gt;&gt; E</p>
<p>port.5 &gt;&gt; F</p>
<p>port.6 &gt;&gt; G</p></td>
<td style="text-align: left;"><p>Can be <code class="literal">DISPLAYPORTA</code> and/or <code class="literal">DISPLAYPORTB</code> and/or <code class="literal">DISPLAYPORTC</code> and/or <code class="literal">DISPLAYPORTD</code></p>
<p>Where <code class="literal">DISPLAYPORTn</code> can be A, B, C or D which corresponding to displays 1, 2, 3 and 4, respectively.</p>
<p>Must be specified to use this connectivity option.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><p><code class="literal">DISPSELECTn</code></p></td>
<td style="text-align: left;"><p>Specifies the output command used to <span class="strong"><strong>select</strong></span> a specific 7 segment display addressed by <code class="literal">DISPLAYPORT_n</code>.</p>
<p>Used to control output pin (output bit) when several displays are multiplexed.</p>
<p>Typical commands are: <code class="literal">#define DispSelectA Set portA.0 on</code></p>
<p><code class="literal">#define DispSelectB Set portA.1 on</code></p></td>
<td style="text-align: left;"><p>Can be <code class="literal">DISPSELECTA</code> and/or <code class="literal">DISPSELECTB</code> and/or <code class="literal">DISPSELECTC</code> and/or <code class="literal">DISPSELECTD</code></p>
<p>Must be specified to use this connectivity option.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><p><code class="literal">DISPDESELECTn</code></p></td>
<td style="text-align: left;"><p>An optional command to specify the output command used to <span class="strong"><strong>deselect</strong></span> a specific 7 segment display addressed by <code class="literal">DISPLAYPORT_n</code>.</p>
<p>Used to control output pin (output bit) when several displays are multiplexed.</p>
<p>Typical commands are:</p>
<p><code class="literal">#define DispDeSelectA Set portA.0 off</code></p>
<p><code class="literal">#define DispDeSelectB Set portA.1 off</code></p></td>
<td style="text-align: left;"><p>Can be <code class="literal">DISPDESELECTA</code> and/or <code class="literal">DISPDESELECTB</code> and/or <code class="literal">DISPDESELECTC</code> and/or <code class="literal">DISPDESELECTD</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>3</p></td>
<td style="text-align: left;"><p><code class="literal">DISPLAYPORTn</code> &amp; <code class="literal">DISP_SEL_n</code></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><p><code class="literal">DISPLAYPORTn</code></p></td>
<td style="text-align: left;"><p>Specifies the output port used to control the 7 segment display.</p>
<p>Port.bit &gt;&gt; Segment</p>
<p>port.0 &gt;&gt; A</p>
<p>port.1 &gt;&gt; B</p>
<p>port.2 &gt;&gt; C</p>
<p>port.3 &gt;&gt; D</p>
<p>port.4 &gt;&gt; E</p>
<p>port.5 &gt;&gt; F</p>
<p>port.6 &gt;&gt; G</p></td>
<td style="text-align: left;"><p>Can be <code class="literal">DISPLAYPORTA</code> and/or <code class="literal">DISPLAYPORTB</code> and/or <code class="literal">DISPLAYPORTC</code> and/or <code class="literal">DISPLAYPORTD</code></p>
<p>Where <code class="literal">DISPLAYPORTn</code> can be A, B, C or D which corresponding to displays 1, 2, 3 and 4, respectively.</p>
<p>Must be specified to use this connectivity option.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><p><code class="literal">DISP_SEL_n</code></p></td>
<td style="text-align: left;"><p>Specifies the output command used to select a specific 7 segment display addressed by <code class="literal">DISPLAYPORTn</code>.</p>
<p>Typical commands are:</p>
<p><code class="literal">#define DISP_SEL_1 portA.0</code></p>
<p><code class="literal">#define DISP_SEL_2 portA.1</code></p></td>
<td style="text-align: left;"><p>Must be specified to use this connectivity option.</p>
<p>Can be specified as <code class="literal">DISP_SEL_1</code> and/or <code class="literal">DISP_SEL_2</code> and/or <code class="literal">DISP_SEL_3</code> and/or <code class="literal">DISP_SEL_4</code></p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Example 1:**</span>

``` screen
        'A Common Cathode 7 Segment display  2 digit example
        #chip 16F886, 8

        'support for Common Anode
        '#DEFINE 7SEG_COMMONANODE

        'support for pfet or pnp high side drivers
        '#DEFINE 7SEG_HIGHSIDE

        ' ----- Constants
        'You need to specify the port settings
        'by one of the following three methods
        'The Directions of the ports are automaically set according to the defines

        'METHOD 1
        'Define individual port pins for segments and selects

        #DEFINE DISP_SEG_A PORTB.0
        #DEFINE DISP_SEG_B PORTB.1
        #DEFINE DISP_SEG_C PORTB.2
        #DEFINE DISP_SEG_D PORTB.3
        #DEFINE DISP_SEG_E PORTB.4
        #DEFINE DISP_SEG_F PORTB.5
        #DEFINE DISP_SEG_G PORTB.6
        #DEFINE DISP_SEG_DOT PORTB.7 '' available on some displays as dp or colon

        #DEFINE DISP_SEL_1 PORTC.5
        #DEFINE DISP_SEL_2 PORTC.4

        'METHOD 2  Define DISPLAYPORTA (B,C,D) for up to 4 digit display segments
        'Define DISPSELECTA (B,C,D) for up to 4 digit display selects

        '#DEFINE DISPLAYPORTA PORTB   ' same port name can be assigned
        '#DEFINE DISPLAYPORTB PORTB

        '#DEFINE DispSelectA Set portC.5 off
        '#DEFINE DispSelectB Set portC.4 off
        '#DEFINE DispDeSelectA Set portC.5 on
        '#DEFINE DispDeSelectB Set portC.4 on

        'METHOD 3  Define DISPLAYPORTA (B,C,D) for up to 4 digit display segments
        'Define port pins for the digit display  selects

        '#DEFINE DISPLAYPORTA PORTB
        '#DEFINE DISPLAYPORTB PORTB

        '#DEFINE DISP_SEL_1 PORTC.5
        '#DEFINE DISP_SEL_2 PORTC.4



        Dim Message As String
        Message = " HAPPY HOLIDAYS  "
        Do
            For Counter = 1 to len(Message)-1
            Repeat 50
                Displaychar 1, Message(Counter)
                wait 3 ms
                DisplayChar 2, Message(Counter+1)
                wait 3 ms

            End Repeat
            Wait 100 ms
            Next
        Loop
```

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/CC_4dig_7seg_16F886_Schem.jpg)

</div>

</div>

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/CA_2Dig_7seg_16F886_schem.jpg)

</div>

</div>

<span class="strong">**Also, see**</span>
<a href="displaychar" class="link" title="DisplayChar">DisplayChar</a>,
<a href="displayvalue" class="link" title="DisplayValue">DisplayValue</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>7 Segment Displays Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays.html" title="7-Segment Displays"><link rel="prev" href="_7_segment_displays.html" title="7-Segment Displays"><link rel="next" href="_7_segment_displays_legacy.html" title="7 Segment Displays - Legacy"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_7_segment_displays_overview"></a>7 Segment Displays Overview</h4></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>The 7 Segment Displays module provide a cheap red, green, blue or white bright LED Display.&nbsp;&nbsp;
The Ebay modules can be had for $1 to $4 per piece, somtimes less.&nbsp;&nbsp;
They only need 2 pins to control: CLK and DIO for control 4 digit 7 segment LED Display.&nbsp;&nbsp;
They often have a  colon LED&nbsp;&nbsp;</p><p>The GCBASIC 7 segment display methods make it easier for GCBASIC programs to display numbers and letters on 7 segment LED displays.</p><p>There are two ways that the 7 segment display routines can be set up.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">A pre 2020 method <a class="link" href="_7_segment_displays_legacy.html" title="7 Segment Displays - Legacy">7 segment legacy method</a></li><li class="listitem">A revised method for <a class="link" href="_7_segment_displays_tm1637_4_digits.html" title="7 Segment Displays - TM1637 4 Digits">TM1637 4 LEDs</a>, or, <a class="link" href="_7_segment_displays_tm1637_6_digits.html" title="7 Segment Displays - TM1637 6 Digits">TM1637 6 LEDs</a></li></ul></div><p><br>
<br>
<br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="7_segment_displays_overview"></span>7 Segment Displays Overview

</div>

</div>

</div>

<span class="strong">**Introduction**</span>

The 7 Segment Displays module provide a cheap red, green, blue or white
bright LED Display.   The Ebay modules can be had for $1 to $4 per
piece, somtimes less.   They only need 2 pins to control: CLK and DIO
for control 4 digit 7 segment LED Display.   They often have a colon
LED  

The GCBASIC 7 segment display methods make it easier for GCBASIC
programs to display numbers and letters on 7 segment LED displays.

There are two ways that the 7 segment display routines can be set up.

<div class="itemizedlist">

-   A pre 2020 method
    <a href="7_segment_displays_legacy" class="link" title="7 Segment Displays - Legacy">7 segment legacy method</a>
-   A revised method for
    <a href="7_segment_displays_tm1637_4_digits" class="link" title="7 Segment Displays - TM1637 4 Digits">TM1637 4 LEDs</a>,
    or,
    <a href="7_segment_displays_tm1637_6_digits" class="link" title="7 Segment Displays - TM1637 6 Digits">TM1637 6 LEDs</a>

</div>

  
  
  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>7 Segment Displays - TM1637 4 Digits</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_overview.html" title="7 Segment Displays Overview"><link rel="prev" href="_displaysegment.html" title="DisplaySegment"><link rel="next" href="_tmwrite4dig.html" title="TMWrite4Dig"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_7_segment_displays_tm1637_4_digits"></a>7 Segment Displays - TM1637 4 Digits</h5></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>The TM1637 disaplay module is used for displaying numbers on a keyboard matrix.&nbsp;&nbsp;
The matrix of LEDs consists of four 7- segment displays working together.&nbsp;&nbsp;</p><p>The TM1637 specification is</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Two wire interface</li><li class="listitem">Eight adjustable luminance levels</li><li class="listitem">3.3V/5V interface</li><li class="listitem">Supports Four alpha-numeric digits</li><li class="listitem">Operating current consumption: 80mA
<br>
<br></li></ul></div><p><span class="strong"><strong>Why to use TM1637 Display Module?</strong></span></p><p>The TM1637 can be interfaced to any system using only two ports.&nbsp;&nbsp;
This is the main reason the module is preferred over other module.</p><p>Another reason TM1637 display is preferred is because of its low cost. &nbsp;&nbsp;
Although there are other display modules present in the market they cost more.</p><p>The module design is robust so it can sustain in tough environments and still can perform its function for a long time.&nbsp;&nbsp;
The module consumes low power and can be installed in mobile applications.&nbsp;&nbsp;</p><p><br>
<br></p><p><span class="strong"><strong>How to use TM1637 Display Module?</strong></span></p><p>As mentioned earlier the module communication can only be done using the two pins DIO and CLK respectively.&nbsp;&nbsp;
The data is sent to the module or received from the module though these two pins.&nbsp;&nbsp;
So the characters to be displayed are sent in the form of serial data through this interface.
A typical circuit diagram of display module interface to a controller is shown below.</p><p><br>
<br></p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/Display-Module-Interface-with-Controller.png" align="middle" height="252" alt="graphic"></div></div><p><br>
<br></p><p>The module can work on +5V regulated power and any higher voltage may lead to permanent damage.&nbsp;&nbsp;
The interface is established as shown in figure above.&nbsp;&nbsp;
All you need to do is connect DIO and CLK to any of GPIO (General Purpose Input Output) pins of controller and establish serial data exchange through programming.
<br>
<br></p><p><span class="strong"><strong>GCBASIC Support</strong></span></p><p>The GCBASIC 7 segment display methods make it easier for GCBASIC programs to display numbers and letters on 7 segment LED displays.</p><p>The GCBASIC methods support up to four digit 7 segment display devices, common anode/cathode and inversion of the port logic to support driving the device(s) via a transistor.</p><p>Brightness can be set: 8 is display on minimum bright , 15 is display on max bright. Less than 8  is display off.</p><p>The TM1637 chip supports the reading of the keyboard matrix however that is not supported in the library.</p><p><span class="strong"><strong>DataSheets</strong></span></p><p>The datasheets can found here:</p><p>English -  <a class="link" href="http://gcbasic.sourceforge.net/library/TM1637/TM1637_V2.4_EN.pdf" target="_top">here</a>.</p><p>Chinese - <a class="link" href="http://gcbasic.sourceforge.net/library/TM1637/TM1637_V2.4.pdf" target="_top">here</a>.</p><p><span class="strong"><strong>Usage</strong></span></p><p>The following will set the display.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>TM1637_CLK</p></td><td align="left" valign="top"><p>Must be a bi-directional port.&nbsp;&nbsp;
The direction/port setting is managed by the library.</p></td></tr><tr><td align="left" valign="top"><p>TM1637_DIO</p></td><td align="left" valign="top"><p>Must be a bi-directional port.&nbsp;&nbsp;
The direction/port setting is managed by the library.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example program</strong></span></p><pre class="screen">  #chip mega328p,16
  #include &lt;TM1637a.h&gt;

  #define TM1637_CLK PortD.2      ' Arduino Digital_2
  #define TM1637_DIO PortD.3      ' Arduino Digital_3

  '---- main program --------

    TMWrite4Dig (17, 16, 17, 16, 0) 'clear display
      wait 2 s
    TMWrite4Dig (17, 16, 17, 16, 10,0) '- -
      wait 2 s
    TMchar_Bright = 10</pre><p><br>
<br>
<br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="7_segment_displays_tm1637_4_digits"></span>7 Segment Displays - TM1637 4 Digits

</div>

</div>

</div>

<span class="strong">**Introduction**</span>

The TM1637 disaplay module is used for displaying numbers on a keyboard
matrix.   The matrix of LEDs consists of four 7- segment displays
working together.  

The TM1637 specification is

<div class="itemizedlist">

-   Two wire interface
-   Eight adjustable luminance levels
-   3.3V/5V interface
-   Supports Four alpha-numeric digits
-   Operating current consumption: 80mA  
      

</div>

<span class="strong">**Why to use TM1637 Display Module?**</span>

The TM1637 can be interfaced to any system using only two ports.   This
is the main reason the module is preferred over other module.

Another reason TM1637 display is preferred is because of its low cost.
   Although there are other display modules present in the market they
cost more.

The module design is robust so it can sustain in tough environments and
still can perform its function for a long time.   The module consumes
low power and can be installed in mobile applications.  

  
  

<span class="strong">**How to use TM1637 Display Module?**</span>

As mentioned earlier the module communication can only be done using the
two pins DIO and CLK respectively.   The data is sent to the module or
received from the module though these two pins.   So the characters to
be displayed are sent in the form of serial data through this interface.
A typical circuit diagram of display module interface to a controller is
shown below.

  
  

<div class="informalfigure">

<div class="mediaobject" align="center">

<img src="./images/Display-Module-Interface-with-Controller.png" height="252" alt="graphic" />

</div>

</div>

  
  

The module can work on +5V regulated power and any higher voltage may
lead to permanent damage.   The interface is established as shown in
figure above.   All you need to do is connect DIO and CLK to any of GPIO
(General Purpose Input Output) pins of controller and establish serial
data exchange through programming.  
  

<span class="strong">**GCBASIC Support**</span>

The GCBASIC 7 segment display methods make it easier for GCBASIC
programs to display numbers and letters on 7 segment LED displays.

The GCBASIC methods support up to four digit 7 segment display devices,
common anode/cathode and inversion of the port logic to support driving
the device(s) via a transistor.

Brightness can be set: 8 is display on minimum bright , 15 is display on
max bright. Less than 8 is display off.

The TM1637 chip supports the reading of the keyboard matrix however that
is not supported in the library.

<span class="strong">**DataSheets**</span>

The datasheets can found here:

English -
<a href="http://gcbasic.sourceforge.net/library/TM1637/TM1637_V2.4_EN.pdf" class="link">here</a>.

Chinese -
<a href="http://gcbasic.sourceforge.net/library/TM1637/TM1637_V2.4.pdf" class="link">here</a>.

<span class="strong">**Usage**</span>

The following will set the display.

<div class="informaltable">

| <span class="strong">**Constant**</span> | <span class="strong">**Description**</span>                                            |
|:-----------------------------------------|:---------------------------------------------------------------------------------------|
| TM1637\_CLK                              | Must be a bi-directional port.   The direction/port setting is managed by the library. |
| TM1637\_DIO                              | Must be a bi-directional port.   The direction/port setting is managed by the library. |

</div>

<span class="strong">**Example program**</span>

``` screen
  #chip mega328p,16
  #include <TM1637a.h>

  #define TM1637_CLK PortD.2      ' Arduino Digital_2
  #define TM1637_DIO PortD.3      ' Arduino Digital_3

  '---- main program --------

    TMWrite4Dig (17, 16, 17, 16, 0) 'clear display
      wait 2 s
    TMWrite4Dig (17, 16, 17, 16, 10,0) '- -
      wait 2 s
    TMchar_Bright = 10
```

  
  
  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>7 Segment Displays - TM1637 6 Digits</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_overview.html" title="7 Segment Displays Overview"><link rel="prev" href="_tmwritechar.html" title="TMWriteChar"><link rel="next" href="_tmwrite6dig.html" title="TMWrite6Dig"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_7_segment_displays_tm1637_6_digits"></a>7 Segment Displays - TM1637 6 Digits</h5></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>The TM1637 display module is used for displaying numbers on a keyboard matrix.&nbsp;&nbsp;
The matrix of LEDs consists of six 7- segment displays working together.&nbsp;&nbsp;</p><p>The TM1637 specification is</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Two wire interface</li><li class="listitem">Eight adjustable luminance levels</li><li class="listitem">3.3V/5V interface</li><li class="listitem">Supports six alpha-numeric digits</li><li class="listitem">Operating current consumption: 80mA
<br>
<br></li></ul></div><p><span class="strong"><strong>Using the TM1637 Display Module</strong></span></p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/TM1637_6d.gif" align="middle" height="144" alt="graphic"></div></div><p><span class="strong"><strong>Why to use TM1637 Display Module?</strong></span></p><p>The TM1637 can be interfaced to any system using only two ports.&nbsp;&nbsp;
This is the main reason the module is preferred over other module.</p><p>Another reason TM1637 display is preferred is because of its low cost. &nbsp;&nbsp;
Although there are other display modules present in the market they cost more.</p><p>The module design is robust so it can sustain in tough environments and still can perform its function for a long time.&nbsp;&nbsp;
The module consumes low power and can be installed in mobile applications.&nbsp;&nbsp;</p><p><br>
<br></p><p><span class="strong"><strong>How to use TM1637 Display Module?</strong></span></p><p>As mentioned earlier the module communication can only be done using the two pins DIO and CLK respectively.&nbsp;&nbsp;
The data is sent to the module or received from the module though these two pins.&nbsp;&nbsp;
So the characters to be displayed are sent in the form of serial data through this interface.
A typical circuit diagram of display module interface to a controller is shown below.</p><p><br>
<br></p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/Display-Module-Interface-with-Controller.png" align="middle" height="252" alt="graphic"></div></div><p><br>
<br></p><p>The module can work on +5V regulated power and any higher voltage may lead to permanent damage.&nbsp;&nbsp;
The interface is established as shown in figure above.&nbsp;&nbsp;
All you need to do is connect DIO and CLK to any of GPIO (General Purpose Input Output) pins of controller and establish serial data exchange through programming.
<br>
<br></p><p><span class="strong"><strong>GCBASIC Support</strong></span></p><p>The GCBASIC 7 segment display methods make it easier for GCBASIC programs to display numbers and letters on 7 segment LED displays.</p><p>The GCBASIC methods supports six 7 segment display devices, common anode/cathode and inversion of the port logic to support driving the device(s) via a transistor.</p><p>Brightness can be set: 8 is display on minimum bright , 15 is display on max bright. Less than 8  is display off.</p><p>The TM1637 chip supports the reading of the keyboard matrix however that is not supported in the library.</p><p><span class="strong"><strong>DataSheets</strong></span></p><p>The datasheets can found here:</p><p>English -  <a class="link" href="http://gcbasic.sourceforge.net/library/TM1637/TM1637_V2.4_EN.pdf" target="_top">here</a>.</p><p>Chinese - <a class="link" href="http://gcbasic.sourceforge.net/library/TM1637/TM1637_V2.4.pdf" target="_top">here</a>.</p><p><span class="strong"><strong>Usage</strong></span></p><p>The following will set the display.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>TM1637_CLK</p></td><td align="left" valign="top"><p>Must be a bi-directional port.&nbsp;&nbsp;
The direction/port setting is managed by the library.</p></td></tr><tr><td align="left" valign="top"><p>TM1637_DIO</p></td><td align="left" valign="top"><p>Must be a bi-directional port.&nbsp;&nbsp;
The direction/port setting is managed by the library.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example program</strong></span></p><pre class="screen">  #chip mega328p,16
  #include &lt;TM1637a.h&gt;

  #define TM1637_CLK PortD.2      ' Arduino Digital_2
  #define TM1637_DIO PortD.3      ' Arduino Digital_3

  '---- main program --------

    TMWrite6Dig (17, 16, 17, 16, 0) 'clear display
      wait 2 s
    TMWrite6Dig (17, 16, 17, 16, 10,0) '- -
      wait 2 s
    TMchar_Bright = 10</pre><p><br>
<br>
<br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="7_segment_displays_tm1637_6_digits"></span>7 Segment Displays - TM1637 6 Digits

</div>

</div>

</div>

<span class="strong">**Introduction**</span>

The TM1637 display module is used for displaying numbers on a keyboard
matrix.   The matrix of LEDs consists of six 7- segment displays working
together.  

The TM1637 specification is

<div class="itemizedlist">

-   Two wire interface
-   Eight adjustable luminance levels
-   3.3V/5V interface
-   Supports six alpha-numeric digits
-   Operating current consumption: 80mA  
      

</div>

<span class="strong">**Using the TM1637 Display Module**</span>

<div class="informalfigure">

<div class="mediaobject" align="center">

<img src="./images/TM1637_6d.gif" height="144" alt="graphic" />

</div>

</div>

<span class="strong">**Why to use TM1637 Display Module?**</span>

The TM1637 can be interfaced to any system using only two ports.   This
is the main reason the module is preferred over other module.

Another reason TM1637 display is preferred is because of its low cost.
   Although there are other display modules present in the market they
cost more.

The module design is robust so it can sustain in tough environments and
still can perform its function for a long time.   The module consumes
low power and can be installed in mobile applications.  

  
  

<span class="strong">**How to use TM1637 Display Module?**</span>

As mentioned earlier the module communication can only be done using the
two pins DIO and CLK respectively.   The data is sent to the module or
received from the module though these two pins.   So the characters to
be displayed are sent in the form of serial data through this interface.
A typical circuit diagram of display module interface to a controller is
shown below.

  
  

<div class="informalfigure">

<div class="mediaobject" align="center">

<img src="./images/Display-Module-Interface-with-Controller.png" height="252" alt="graphic" />

</div>

</div>

  
  

The module can work on +5V regulated power and any higher voltage may
lead to permanent damage.   The interface is established as shown in
figure above.   All you need to do is connect DIO and CLK to any of GPIO
(General Purpose Input Output) pins of controller and establish serial
data exchange through programming.  
  

<span class="strong">**GCBASIC Support**</span>

The GCBASIC 7 segment display methods make it easier for GCBASIC
programs to display numbers and letters on 7 segment LED displays.

The GCBASIC methods supports six 7 segment display devices, common
anode/cathode and inversion of the port logic to support driving the
device(s) via a transistor.

Brightness can be set: 8 is display on minimum bright , 15 is display on
max bright. Less than 8 is display off.

The TM1637 chip supports the reading of the keyboard matrix however that
is not supported in the library.

<span class="strong">**DataSheets**</span>

The datasheets can found here:

English -
<a href="http://gcbasic.sourceforge.net/library/TM1637/TM1637_V2.4_EN.pdf" class="link">here</a>.

Chinese -
<a href="http://gcbasic.sourceforge.net/library/TM1637/TM1637_V2.4.pdf" class="link">here</a>.

<span class="strong">**Usage**</span>

The following will set the display.

<div class="informaltable">

| <span class="strong">**Constant**</span> | <span class="strong">**Description**</span>                                            |
|:-----------------------------------------|:---------------------------------------------------------------------------------------|
| TM1637\_CLK                              | Must be a bi-directional port.   The direction/port setting is managed by the library. |
| TM1637\_DIO                              | Must be a bi-directional port.   The direction/port setting is managed by the library. |

</div>

<span class="strong">**Example program**</span>

``` screen
  #chip mega328p,16
  #include <TM1637a.h>

  #define TM1637_CLK PortD.2      ' Arduino Digital_2
  #define TM1637_DIO PortD.3      ' Arduino Digital_3

  '---- main program --------

    TMWrite6Dig (17, 16, 17, 16, 0) 'clear display
      wait 2 s
    TMWrite6Dig (17, 16, 17, 16, 10,0) '- -
      wait 2 s
    TMchar_Bright = 10
```

  
  
  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Abs</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_maths.html" title="Maths"><link rel="prev" href="_maths.html" title="Maths"><link rel="next" href="_average.html" title="Average"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_abs"></a>Abs</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    integer_variable = Abs( integer_variable )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Abs</code> function will compute the absolute value of a integer number therefore in the range of &#8722;32767 to +32767.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    absolute_value = Abs( -127 )  ' Will return 127
    absolute_value = Abs( 127 )   ' Will return 127 also. :-)</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="abs"></span>Abs

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    integer_variable = Abs( integer_variable )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Abs` function will compute the absolute value of a integer number
therefore in the range of −32767 to +32767.

<span class="strong">**Example:**</span>

``` screen
    absolute_value = Abs( -127 )  ' Will return 127
    absolute_value = Abs( 127 )   ' Will return 127 also. :-)
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Acknowledgements</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_libraries_overview.html" title="Libraries Overview"><link rel="next" href="_tricks_and_tips.html" title="Tricks and Tips"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_acknowledgements"></a>Acknowledgements</h2></div></div></div><p><span class="strong"><strong>Developers and Contributors:</strong></span></p><p>Hugh Considine - Main developer of GCBASIC</p><p>Stefano Bonomi - Two-wire LCD subroutines</p><p>Geordie Millar - Swap and Swap4 subroutines</p><p>Jacques Nilo - HEFM and help file conversion to asciidoc</p><p>Finn Stokes - 8-bit multiply routine, program memory access code</p><p>Evan Venn - Utilities, revised I2C routines, this help file and generally everything else!</p><p><span class="strong"><strong>Translation Contributors:</strong></span></p><p>Stefano Delfiore - Italian</p><p>Pablo Curvelo - Spanish</p><p>Murat Inceer - Turkish</p><p><span class="strong"><strong>Other Contributors:</strong></span></p><p>Russ Hensel - GCBASIC Notes.</p><p>Chuck Hellebuyck - His documentation for the GLCD and other pieces, see <a class="link" href="http://www.elproducts.com" target="_top">http://www.elproducts.com</a>.</p><p>Frank Steinberg - GCB@SYN IDE for GCBASIC.</p><p>Alexy T. - SynWrite IDE used for GCB IDE, see <a class="link" href="http://www.uvviewsoft.com/synwrite" target="_top">http://www.uvviewsoft.com/synwrite</a></p><p>Thomas Henry for the Select Case and the Sine Table examples.</p><p>William Roth for the LCD code and supporting diagrams.</p><p>Theo Loermans for the revised LCD sections and the serial library.</p><p>Chris Roper for the bitwise methods including the library including FnEquBit, FnNotBit, FnlslBit, FnlsrBit, SetWith and 47xxx.</p><p>Angel Mier for the USB driver installation</p><p><span class="strong"><strong>Conversion of asciidoctor documentation files</strong></span>:</p><p>See the <a class="link" href="http://asciidoctor.org/" target="_top">asciidoctor Web site</a> and the <a class="link" href="http://discuss.asciidoctor.org/" target="_top">support forum</a>.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="acknowledgements"></span>Acknowledgements
----------------------------------------------------

</div>

</div>

</div>

<span class="strong">**Developers and Contributors:**</span>

Hugh Considine - Main developer of GCBASIC

Stefano Bonomi - Two-wire LCD subroutines

Geordie Millar - Swap and Swap4 subroutines

Jacques Nilo - HEFM and help file conversion to asciidoc

Finn Stokes - 8-bit multiply routine, program memory access code

Evan Venn - Utilities, revised I2C routines, this help file and
generally everything else!

<span class="strong">**Translation Contributors:**</span>

Stefano Delfiore - Italian

Pablo Curvelo - Spanish

Murat Inceer - Turkish

<span class="strong">**Other Contributors:**</span>

Russ Hensel - GCBASIC Notes.

Chuck Hellebuyck - His documentation for the GLCD and other pieces, see
<http://www.elproducts.com>.

Frank Steinberg - GCB@SYN IDE for GCBASIC.

Alexy T. - SynWrite IDE used for GCB IDE, see
<http://www.uvviewsoft.com/synwrite>

Thomas Henry for the Select Case and the Sine Table examples.

William Roth for the LCD code and supporting diagrams.

Theo Loermans for the revised LCD sections and the serial library.

Chris Roper for the bitwise methods including the library including
FnEquBit, FnNotBit, FnlslBit, FnlsrBit, SetWith and 47xxx.

Angel Mier for the USB driver installation

<span class="strong">**Conversion of asciidoctor documentation
files**</span>:

See the
<a href="http://asciidoctor.org/" class="link">asciidoctor Web site</a>
and the
<a href="http://discuss.asciidoctor.org/" class="link">support forum</a>.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ADFormat (Deprecated - Do not use)</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_analog_digital_conversion.html" title="Analog/Digital conversion"><link rel="prev" href="_analog_digital_conversion_overview.html" title="Analog/Digital Conversion Overview"><link rel="next" href="_adoff.html" title="ADOff"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_adformat_deprecated_do_not_use"></a>ADFormat (Deprecated - Do not use)</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">ADFormat ( Format_Left | Format_Right )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available only on Microchip PIC microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Left justified means 8 bits in the high byte, 2 in the low. Right
justified means 2 in the high byte, and the remaining 8 in the low byte.
It&#8217;s only supported on Microchip PIC microcontrollers.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="adformat_deprecated_do_not_use"></span>ADFormat (Deprecated - Do not use)

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
ADFormat ( Format_Left | Format_Right )
```

<span class="strong">**Command Availability:**</span>

Available only on Microchip PIC microcontrollers.

<span class="strong">**Explanation:**</span>

Left justified means 8 bits in the high byte, 2 in the low. Right
justified means 2 in the high byte, and the remaining 8 in the low byte.
It’s only supported on Microchip PIC microcontrollers.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ADOff</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_analog_digital_conversion.html" title="Analog/Digital conversion"><link rel="prev" href="_adformat_deprecated_do_not_use.html" title="ADFormat (Deprecated - Do not use)"><link rel="next" href="_readad.html" title="ReadAD"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_adoff"></a>ADOff</h4></div></div></div><p><span class="strong"><strong>This command is obsolete</strong></span>. There should be no need to call it. GCBASIC
will automatically disable the A/D converter and set all pins to digital
mode when starting the program, and after every use of the ReadAD
function.</p><p>It is recommended that this command be removed from all programs.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="adoff"></span>ADOff

</div>

</div>

</div>

<span class="strong">**This command is obsolete**</span>. There should
be no need to call it. GCBASIC will automatically disable the A/D
converter and set all pins to digital mode when starting the program,
and after every use of the ReadAD function.

It is recommended that this command be removed from all programs.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ADS 7843 Serial Driver</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_touch_screen.html" title="Touch Screen"><link rel="prev" href="_touch_screen.html" title="Touch Screen"><link rel="next" href="_liquid_crystal_display.html" title="Liquid Crystal Display"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_ads_7843_serial_driver"></a>ADS 7843 Serial Driver</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ADS7843_Init

    ADS7843_GetXY

    ADS7843_SetPrecision</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers. Requires the inclusion of the following:</p><pre class="screen">    #include &lt;ADS7843.h&gt;</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>The ADS7843 device is a 12-bit sampling Analog-to-Digital Converter (ADC) with a synchronous serial interface and low on resistance switches for driving touch screens.</p><p>The GCBASIC driver is integrated with the SDD1289 GLCD driver.  To use the ADS7843 driver the following is required to added to the GCBASIC source file.</p><p><code class="literal">ADS7843_Init</code> is required to initialise the touch screen. This is mandated.</p><p><code class="literal">ADS7843_GetXY</code> this sub-routine returns the X and Y coordinates of touched point.</p><p><code class="literal">ADS7843_SetPrecision</code> this sub-routine sets the level of precision of the touch screen.</p><p><span class="strong"><strong>Required Constants:</strong></span></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls/Direction</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>ADS7843_DOUT (IN)</p></td><td align="left" valign="top"><p>The chip output pin</p></td><td align="left" valign="top"><p>Mandated</p></td></tr><tr><td align="left" valign="top"><p>ADS7843_IRQ (IN)</p></td><td align="left" valign="top"><p>The interrupt pin</p></td><td align="left" valign="top"><p>Mandated</p></td></tr><tr><td align="left" valign="top"><p>ADS7843_CS (OUT)</p></td><td align="left" valign="top"><p>The chip select pin</p></td><td align="left" valign="top"><p>Mandated</p></td></tr><tr><td align="left" valign="top"><p>ADS7843_CLK (OUT)</p></td><td align="left" valign="top"><p>The clock pin</p></td><td align="left" valign="top"><p>Mandated</p></td></tr><tr><td align="left" valign="top"><p>ADS7843_DIN (OUT)</p></td><td align="left" valign="top"><p>The chip input pin</p></td><td align="left" valign="top"><p>Mandated</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this chip are:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>ADS7843_Init</p></td><td align="left" valign="top"><p>Initialise the device.</p></td><td align="left" valign="top"><p>ADS7843_Init [Optional precision = PREC_EXTREME]</p></td></tr><tr><td align="left" valign="top"><p>ADS7843_GetXY</p></td><td align="left" valign="top"><p>Returns the X and Y coordinates of touched point.</p></td><td align="left" valign="top"><p>ADS7843_GetXY (TP_X, TP_Y )</p></td></tr><tr><td align="left" valign="top"><p>ADS7843_SetPrecision</p></td><td align="left" valign="top"><p>Set the precision of the conversion result.</p></td><td align="left" valign="top"><p>ADS7843_SetPrecision(precision)<br>
(with PREC_EXTREME the conversion error is less than 3%)</p></td></tr></tbody></table></div><p>Precision can be set to four values as shown in the table below.
Passing a parameter of ADS7843_SetPrecision changes the precision controls.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Defined  Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">#define PREC_LOW</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">#define PREC_MEDIUM</code></p></td><td align="left" valign="top"><p><code class="literal">2</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">#define PREC_HI</code></p></td><td align="left" valign="top"><p><code class="literal">3</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">#define  PREC_EXTREME</code></p></td><td align="left" valign="top"><p><code class="literal">4</code></p></td><td align="left" valign="top"><p>Default Value</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example:</strong></span></p><p>For more information see <a class="link" href="http://www.ti.com/product/ads7843" target="_top">http://www.ti.com/product/ads7843</a>.</p><p>This example shows how to drive a SDD1289 based Graphic LCD module with ADS7843 touch controller.</p><pre class="screen">    'Chip Settings
    #chip mega2560, 16

    'Include for GLCD
    #include &lt;glcd.h&gt;

    'Include for ADS7843
    #include  &lt;ADS7843.h&gt;

    'GLCD Device Selection
    #DEFINE GLCD_TYPE GLCD_TYPE_SSD1289
    'Define ports for the SSD1289 display - ALL are required
    #DEFINE GLCD_WR   PORTG.2
    #DEFINE GLCD_CS   PORTG.1
    #DEFINE GLCD_RS   PORTD.7
    #DEFINE GLCD_RST  PORTG.0

    #DEFINE GLCD_DB0  PORTC.0
    #DEFINE GLCD_DB1  PORTC.1
    #DEFINE GLCD_DB2  PORTC.2
    #DEFINE GLCD_DB3  PORTC.3
    #DEFINE GLCD_DB4  PORTC.4
    #DEFINE GLCD_DB5  PORTC.5
    #DEFINE GLCD_DB6  PORTC.6
    #DEFINE GLCD_DB7  PORTC.7
    #DEFINE GLCD_DB8  PORTA.0
    #DEFINE GLCD_DB9  PORTA.1
    #DEFINE GLCD_DB10 PORTA.2
    #DEFINE GLCD_DB11 PORTA.3
    #DEFINE GLCD_DB12 PORTA.4
    #DEFINE GLCD_DB13 PORTA.5
    #DEFINE GLCD_DB14 PORTA.6
    #DEFINE GLCD_DB15 PORTA.7

    'GLCD font control
    #DEFINE GLCD_EXTENDEDFONTSET1

    'Define ports for ADS7843
    #define ADS7843_DOUT   PORTE.5  ' Arduino Mega D3
    #define ADS7843_IRQ    PORTE.4  ' Arduino Mega D2
    #define ADS7843_CS     PORTE.3  ' Arduino Mega D5
    #define ADS7843_CLK    PORTH.3  ' Arduino Mega D6
    #define ADS7843_DIN    PORTG.5  ' Arduino Mega D4
    #define ADS7843_BUSY   PORTH.4  ' Arduino Mega D7

    Wait 100 ms
    num=0
    Do Forever

      'Library function
      if ADS7843_IRQ=0 then

         num++
         GLCDPrint  10, 15,  str(num),SSD1289_YELLOW, 2

         'Libary sub routine - returns two variables
         ADS7843_GetXY ( TP_X , TP_Y )

         if TP_X&gt;=100 then GLCDPrint  100, 50, Str(TP_X),SSD1289_YELLOW, 2
         if TP_X&gt;=10 and TP_X&lt;100 then GLCDPrint  100, 50, Str(TP_X)+" ",SSD1289_YELLOW, 2
         if TP_X&lt;10 then GLCDPrint  100, 50,  Str(TP_X)+" ",SSD1289_YELLOW, 2
         if TP_Y&gt;=100 then GLCDPrint  100, 70, Str(TP_Y),SSD1289_YELLOW, 2
         if TP_Y&gt;=10 and TP_Y&lt;100 then GLCDPrint  100, 70, Str(TP_Y)+" ", SSD1289_YELLOW, 2
         if TP_Y&lt;10 then GLCDPrint  100, 70,  Str(TP_Y)+" ",SSD1289_YELLOW, 2

         'Set the pixel to yellow using the GLCD PSET sub routine
         Pset TP_X,  TP_Y, SSD1289_YELLOW

      end if
      Wait 1 ms

    Loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="ads_7843_serial_driver"></span>ADS 7843 Serial Driver

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ADS7843_Init

    ADS7843_GetXY

    ADS7843_SetPrecision
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers. Requires the inclusion of the
following:

``` screen
    #include <ADS7843.h>
```

<span class="strong">**Explanation:**</span>

The ADS7843 device is a 12-bit sampling Analog-to-Digital Converter
(ADC) with a synchronous serial interface and low on resistance switches
for driving touch screens.

The GCBASIC driver is integrated with the SDD1289 GLCD driver. To use
the ADS7843 driver the following is required to added to the GCBASIC
source file.

`ADS7843_Init` is required to initialise the touch screen. This is
mandated.

`ADS7843_GetXY` this sub-routine returns the X and Y coordinates of
touched point.

`ADS7843_SetPrecision` this sub-routine sets the level of precision of
the touch screen.

<span class="strong">**Required Constants:**</span>

<div class="informaltable">

| <span class="strong">**Constants**</span> | <span class="strong">**Controls/Direction**</span> | <span class="strong">**Default Value**</span> |
|:------------------------------------------|:---------------------------------------------------|:----------------------------------------------|
| ADS7843\_DOUT (IN)                        | The chip output pin                                | Mandated                                      |
| ADS7843\_IRQ (IN)                         | The interrupt pin                                  | Mandated                                      |
| ADS7843\_CS (OUT)                         | The chip select pin                                | Mandated                                      |
| ADS7843\_CLK (OUT)                        | The clock pin                                      | Mandated                                      |
| ADS7843\_DIN (OUT)                        | The chip input pin                                 | Mandated                                      |

</div>

The GCBASIC commands supported for this chip are:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Command</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Purpose</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Example</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>ADS7843_Init</p></td>
<td style="text-align: left;"><p>Initialise the device.</p></td>
<td style="text-align: left;"><p>ADS7843_Init [Optional precision = PREC_EXTREME]</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>ADS7843_GetXY</p></td>
<td style="text-align: left;"><p>Returns the X and Y coordinates of touched point.</p></td>
<td style="text-align: left;"><p>ADS7843_GetXY (TP_X, TP_Y )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>ADS7843_SetPrecision</p></td>
<td style="text-align: left;"><p>Set the precision of the conversion result.</p></td>
<td style="text-align: left;"><p>ADS7843_SetPrecision(precision)<br />
(with PREC_EXTREME the conversion error is less than 3%)</p></td>
</tr>
</tbody>
</table>

</div>

Precision can be set to four values as shown in the table below. Passing
a parameter of ADS7843\_SetPrecision changes the precision controls.

<div class="informaltable">

| <span class="strong">**Constants**</span> | <span class="strong">**Defined Value**</span> | <span class="strong">**Default Value**</span> |
|:------------------------------------------|:----------------------------------------------|:----------------------------------------------|
| `#define PREC_LOW`                        | `1`                                           |                                               |
| `#define PREC_MEDIUM`                     | `2`                                           |                                               |
| `#define PREC_HI`                         | `3`                                           |                                               |
| `#define  PREC_EXTREME`                   | `4`                                           | Default Value                                 |

</div>

<span class="strong">**Example:**</span>

For more information see <http://www.ti.com/product/ads7843>.

This example shows how to drive a SDD1289 based Graphic LCD module with
ADS7843 touch controller.

``` screen
    'Chip Settings
    #chip mega2560, 16

    'Include for GLCD
    #include <glcd.h>

    'Include for ADS7843
    #include  <ADS7843.h>

    'GLCD Device Selection
    #DEFINE GLCD_TYPE GLCD_TYPE_SSD1289
    'Define ports for the SSD1289 display - ALL are required
    #DEFINE GLCD_WR   PORTG.2
    #DEFINE GLCD_CS   PORTG.1
    #DEFINE GLCD_RS   PORTD.7
    #DEFINE GLCD_RST  PORTG.0

    #DEFINE GLCD_DB0  PORTC.0
    #DEFINE GLCD_DB1  PORTC.1
    #DEFINE GLCD_DB2  PORTC.2
    #DEFINE GLCD_DB3  PORTC.3
    #DEFINE GLCD_DB4  PORTC.4
    #DEFINE GLCD_DB5  PORTC.5
    #DEFINE GLCD_DB6  PORTC.6
    #DEFINE GLCD_DB7  PORTC.7
    #DEFINE GLCD_DB8  PORTA.0
    #DEFINE GLCD_DB9  PORTA.1
    #DEFINE GLCD_DB10 PORTA.2
    #DEFINE GLCD_DB11 PORTA.3
    #DEFINE GLCD_DB12 PORTA.4
    #DEFINE GLCD_DB13 PORTA.5
    #DEFINE GLCD_DB14 PORTA.6
    #DEFINE GLCD_DB15 PORTA.7

    'GLCD font control
    #DEFINE GLCD_EXTENDEDFONTSET1

    'Define ports for ADS7843
    #define ADS7843_DOUT   PORTE.5  ' Arduino Mega D3
    #define ADS7843_IRQ    PORTE.4  ' Arduino Mega D2
    #define ADS7843_CS     PORTE.3  ' Arduino Mega D5
    #define ADS7843_CLK    PORTH.3  ' Arduino Mega D6
    #define ADS7843_DIN    PORTG.5  ' Arduino Mega D4
    #define ADS7843_BUSY   PORTH.4  ' Arduino Mega D7

    Wait 100 ms
    num=0
    Do Forever

      'Library function
      if ADS7843_IRQ=0 then

         num++
         GLCDPrint  10, 15,  str(num),SSD1289_YELLOW, 2

         'Libary sub routine - returns two variables
         ADS7843_GetXY ( TP_X , TP_Y )

         if TP_X>=100 then GLCDPrint  100, 50, Str(TP_X),SSD1289_YELLOW, 2
         if TP_X>=10 and TP_X<100 then GLCDPrint  100, 50, Str(TP_X)+" ",SSD1289_YELLOW, 2
         if TP_X<10 then GLCDPrint  100, 50,  Str(TP_X)+" ",SSD1289_YELLOW, 2
         if TP_Y>=100 then GLCDPrint  100, 70, Str(TP_Y),SSD1289_YELLOW, 2
         if TP_Y>=10 and TP_Y<100 then GLCDPrint  100, 70, Str(TP_Y)+" ", SSD1289_YELLOW, 2
         if TP_Y<10 then GLCDPrint  100, 70,  Str(TP_Y)+" ",SSD1289_YELLOW, 2

         'Set the pixel to yellow using the GLCD PSET sub routine
         Pset TP_X,  TP_Y, SSD1289_YELLOW

      end if
      Wait 1 ms

    Loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Alloc</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_dim.html" title="Dim"><link rel="next" href="_bcdtodec_gcb.html" title="BcdToDec_GCB"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_alloc"></a>Alloc</h4></div></div></div><p><span class="strong"><strong>About Alloc</strong></span></p><p>Alloc creates a special type of variable - an array variant. &nbsp;&nbsp;This array variant can store values.&nbsp;&nbsp;  The values stored in this array variant must be of the same type.</p><p>Essentially, ALLOCate will reserve a memory range as described by the given layout that can be used as a RAM buffer or as an array variant.</p><p>Layout:</p><pre class="screen">  Dim variable_name as ALLOC * memory_size at memory_location</pre><p>The allocated block of memory will not be initialized.</p><p>Example Usage:</p><pre class="screen">  Dim my256bytebuffer as alloc * 256 at 0x2400</pre><p>There is a pointer to allocated memory.  Use @variable_name.</p><p>Example Pointer</p><pre class="screen">    HSerPrint @my256bytebuffer</pre><p><span class="strong"><strong>Extents</strong></span></p><p>This method can be unsafe because undefined behaviour can result if the caller does not ensure that buffer extents are not maintained. &nbsp;&nbsp; Buffer extents are 0 (zero) to the memory_size - 1</p><p>Example Extents:</p><pre class="screen">    my256bytebuffer(0)    = some_variable.  Will address location 0x2400
    my256bytebuffer(255)  = some_variable.  Will address location 0x24FF ' the 256th byte of the allocated memory</pre><p>Implementers of ALLOC must ensure memory constraints remain true.</p><p><span class="strong"><strong>Safety</strong></span></p><p>This method is unsafe because undefined behaviour can result if the caller does not ensure that buffer extents are not maintained. &nbsp;&nbsp;   If buffer extents are exceeded the program may address areas of memory that have adverse impact on the operation of the microcontroller.</p><p>Examples of unsafe usage:</p><pre class="screen">    my256bytebuffer(256) = some_variable.  Will address location 0x2500  ' this is the first byte of BUFFER RAM on the 18FxxQ43 chips... bad things may happen
    my256bytebuffer(65535) = some_variable.  Will address location 0x123FF  ' this is the beyond the memory limit and the operation will write an SFR.</pre><p><span class="strong"><strong>Example Program</strong></span></p><p>The following example program shows the ALLOCation of a 256 byte buffer at a specific address.&nbsp;&nbsp;
The array variant is then populated with data and then shown on a serial terminal.</p><pre class="screen">        ' Chip Settings and preamble
        #CHIP  18F27Q43
        #OPTION EXPLICIT


        'Generated by PIC PPS Tool for GCBASIC - this explicit to a specific chip
        #startup InitPPS, 85
        #define PPSToolPart 18f27q43

        Sub InitPPS

                'Module: UART pin directions
                Dir PORTC.6 Out    ' Make TX1 pin an output
                'Module: UART1
                RC6PPS = 0x0020    'TX1 &gt; RC6

        End Sub
        'Template comment at the end of the config file

        ' USART settings for USART1
        #DEFINE USART_BAUD_RATE 9600
        #DEFINE USART_TX_BLOCKING
        #DEFINE USART_DELAY 0

        '---------------------------
        ' Main Program

        #DEFINE BUFFERSIZE 256  ' gives range of 0 to 255

        'DIMension an ArrayVariant using ALLOC to create an ArrayVariant with the size of BUFFERSIZE.
        'This array is created at memory location 0x2400.
        'This memory location is specific to this chip ( you must ensure other microcontrollers address are valid).

        Dim mybuffer1 as ALLOC * BUFFERSIZE at 0x2400

        'A data table
        Table myDataTable
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
        End Table

        Dim iLoop, tableDataValue, memoryDataValue as byte

        'These varaibles are ONLY used to demonstrate the showing of the allocated memory address
        Dim mybuffer1startaddress, mybuffer1endaddress as word

        mybuffer1startaddress = @mybuffer1
        mybuffer1endaddress = mybuffer1startaddress + BUFFERSIZE - 1


        HSerPrintCRLF 2
        HSerPrint "Buffer test - 256 bytes "
        HSerPrint " at address: 0x"
        HSerPrint hex( mybuffer1startaddress_h )
        HSerPrint hex( mybuffer1startaddress )
        HSerPrint " to 0x"
        HSerPrint hex( mybuffer1endaddress_h )
        HSerPrint hex( mybuffer1endaddress )
        HSerPrintCRLF 2

        'Load buffer with table data
        for iLoop = 0 to 255
            ReadTable myDataTable, [word]iLoop+1, tableDataValue
            mybuffer1( iLoop ) = tableDataValue
        next

        wait 100 ms

        HserPrint "Print dataDump array to serial terminal"
        HSerPrintCRLF
        for iLoop = 0 to 255
            HSerPrint leftpad(str( myBuffer1(iLoop)),3)
            If iLoop % 16 = 15 Then HSerPrintCRLF
        next

        Wait 100 ms
        HSerPrintCRLF
        HserPrint "Print memory to serial terminal using PEEK to get the memory location byte value"
        HSerPrintCRLF
        for iLoop = 0 to 255
            memoryDataValue = PEEK ( @myBuffer1+iLoop )
            HSerPrint leftpad(str( memoryDataValue ) ,3)
            If iLoop % 16 = 15 Then HSerPrintCRLF
        next
        HSerPrintCRLF
        Wait 100 ms</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_dim.html" title="Dim">Declaring arrays with DIM</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="alloc"></span>Alloc

</div>

</div>

</div>

<span class="strong">**About Alloc**</span>

Alloc creates a special type of variable - an array variant.   This
array variant can store values.   The values stored in this array
variant must be of the same type.

Essentially, ALLOCate will reserve a memory range as described by the
given layout that can be used as a RAM buffer or as an array variant.

Layout:

``` screen
  Dim variable_name as ALLOC * memory_size at memory_location
```

The allocated block of memory will not be initialized.

Example Usage:

``` screen
  Dim my256bytebuffer as alloc * 256 at 0x2400
```

There is a pointer to allocated memory. Use @variable\_name.

Example Pointer

``` screen
    HSerPrint @my256bytebuffer
```

<span class="strong">**Extents**</span>

This method can be unsafe because undefined behaviour can result if the
caller does not ensure that buffer extents are not maintained.    Buffer
extents are 0 (zero) to the memory\_size - 1

Example Extents:

``` screen
    my256bytebuffer(0)    = some_variable.  Will address location 0x2400
    my256bytebuffer(255)  = some_variable.  Will address location 0x24FF ' the 256th byte of the allocated memory
```

Implementers of ALLOC must ensure memory constraints remain true.

<span class="strong">**Safety**</span>

This method is unsafe because undefined behaviour can result if the
caller does not ensure that buffer extents are not maintained.    If
buffer extents are exceeded the program may address areas of memory that
have adverse impact on the operation of the microcontroller.

Examples of unsafe usage:

``` screen
    my256bytebuffer(256) = some_variable.  Will address location 0x2500  ' this is the first byte of BUFFER RAM on the 18FxxQ43 chips... bad things may happen
    my256bytebuffer(65535) = some_variable.  Will address location 0x123FF  ' this is the beyond the memory limit and the operation will write an SFR.
```

<span class="strong">**Example Program**</span>

The following example program shows the ALLOCation of a 256 byte buffer
at a specific address.   The array variant is then populated with data
and then shown on a serial terminal.

``` screen
        ' Chip Settings and preamble
        #CHIP  18F27Q43
        #OPTION EXPLICIT


        'Generated by PIC PPS Tool for GCBASIC - this explicit to a specific chip
        #startup InitPPS, 85
        #define PPSToolPart 18f27q43

        Sub InitPPS

                'Module: UART pin directions
                Dir PORTC.6 Out    ' Make TX1 pin an output
                'Module: UART1
                RC6PPS = 0x0020    'TX1 > RC6

        End Sub
        'Template comment at the end of the config file

        ' USART settings for USART1
        #DEFINE USART_BAUD_RATE 9600
        #DEFINE USART_TX_BLOCKING
        #DEFINE USART_DELAY 0

        '---------------------------
        ' Main Program

        #DEFINE BUFFERSIZE 256  ' gives range of 0 to 255

        'DIMension an ArrayVariant using ALLOC to create an ArrayVariant with the size of BUFFERSIZE.
        'This array is created at memory location 0x2400.
        'This memory location is specific to this chip ( you must ensure other microcontrollers address are valid).

        Dim mybuffer1 as ALLOC * BUFFERSIZE at 0x2400

        'A data table
        Table myDataTable
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
        End Table

        Dim iLoop, tableDataValue, memoryDataValue as byte

        'These varaibles are ONLY used to demonstrate the showing of the allocated memory address
        Dim mybuffer1startaddress, mybuffer1endaddress as word

        mybuffer1startaddress = @mybuffer1
        mybuffer1endaddress = mybuffer1startaddress + BUFFERSIZE - 1


        HSerPrintCRLF 2
        HSerPrint "Buffer test - 256 bytes "
        HSerPrint " at address: 0x"
        HSerPrint hex( mybuffer1startaddress_h )
        HSerPrint hex( mybuffer1startaddress )
        HSerPrint " to 0x"
        HSerPrint hex( mybuffer1endaddress_h )
        HSerPrint hex( mybuffer1endaddress )
        HSerPrintCRLF 2

        'Load buffer with table data
        for iLoop = 0 to 255
            ReadTable myDataTable, [word]iLoop+1, tableDataValue
            mybuffer1( iLoop ) = tableDataValue
        next

        wait 100 ms

        HserPrint "Print dataDump array to serial terminal"
        HSerPrintCRLF
        for iLoop = 0 to 255
            HSerPrint leftpad(str( myBuffer1(iLoop)),3)
            If iLoop % 16 = 15 Then HSerPrintCRLF
        next

        Wait 100 ms
        HSerPrintCRLF
        HserPrint "Print memory to serial terminal using PEEK to get the memory location byte value"
        HSerPrintCRLF
        for iLoop = 0 to 255
            memoryDataValue = PEEK ( @myBuffer1+iLoop )
            HSerPrint leftpad(str( memoryDataValue ) ,3)
            If iLoop % 16 = 15 Then HSerPrintCRLF
        next
        HSerPrintCRLF
        Wait 100 ms
```

<span class="strong">**For more help, see**</span>
<a href="dim" class="link" title="Dim">Declaring arrays with DIM</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Analog/Digital conversion</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_command_references.html" title="Command References"><link rel="next" href="_analog_digital_conversion_overview.html" title="Analog/Digital Conversion Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_analog_digital_conversion"></a>Analog/Digital conversion</h3></div></div></div><p>This is the Analog/Digital conversion section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="analog_digital_conversion"></span>Analog/Digital conversion

</div>

</div>

</div>

This is the Analog/Digital conversion section of the Help file. Please
refer the sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Analog/Digital Conversion Code Optimisation</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_analog_digital_conversion.html" title="Analog/Digital conversion"><link rel="prev" href="_readad12.html" title="ReadAD12"><link rel="next" href="_bitwise.html" title="Bitwise"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_analog_digital_conversion_code_optimisation"></a>Analog/Digital Conversion Code Optimisation</h4></div></div></div><p><span class="strong"><strong>About Analog/Digital Conversion Code Optimisation</strong></span></p><p>The analog to digital converter (ADC or A/D) module support is implemented by GCBASIC to provide 8-bit, 10-bit and 12-bit Single channel measurement mode and Differential Channel Measurement with support up to 34 channels.  For compatibility all channels are supported.</p><p>There are two methods to optimise the code.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">To mimise the code, use the contstants to disable support for a specfic channels</li><li class="listitem">To adapt the ADC configuration by inserting specfic commands to set registers or register bits.</li></ol></div><p><span class="strong"><strong>1. Minimise the code</strong></span></p><p>The example below would disable support for ADC port 0 (AD0).</p><pre class="screen">    #define USE_AD0 FALSE</pre><p>The following tables show the #defines that can be used to reduce the code size - these are the defines for the standard microcontrollers.
For 16f1688x and similar microcontrollers please see the second table.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Channel</th><th align="left" valign="top">Optimisation Value</th><th align="left" valign="top">Default Value</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">USE_AD0</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD1</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD2</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD3</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD4</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD5</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD6</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD7</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD8</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD9</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD10</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD11</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD12</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD13</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD14</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD15</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD16</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD17</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD18</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD19</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD20</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD21</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD22</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD23</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD24</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD25</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD26</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD27</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD28</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD29</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD30</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD31</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD32</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD33</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_AD34</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr></tbody></table></div><p>For 16f1688x devices see the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Channel</th><th align="left" valign="top">Optimisation Value</th><th align="left" valign="top">Default Value</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">USE_ADA0</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADA1</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADA2</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADA3</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADA4</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADA5</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADA6</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADA7</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADC0</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADC1</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADC2</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADC3</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADC4</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADC5</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADC6</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADC7</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADD0</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADD1</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADD2</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADD3</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADD4</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADD5</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADD6</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADD7</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADE0</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADE1</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USE_ADE2</code></p></td><td align="left" valign="top"><p><code class="literal">FALSE</code></p></td><td align="left" valign="top"><p><code class="literal">TRUE</code></p></td></tr></tbody></table></div><p>This is a example - disables every channel except the specified channel by defining every channel except USE_AD0 as FALSE.</p><p>This will save 146 bytes of program memory.</p><pre class="screen">    #chip 16F1939

    'USART settings
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    'Set the input pin direction
    Dir PORTA.0 In

    'Print 255 reading
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        HSerPrint str(ReadAD10(AN0))

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next

    #define USE_AD0 TRUE
    #define USE_AD1 FALSE
    #define USE_AD2 FALSE
    #define USE_AD2 FALSE
    #define USE_AD3 FALSE
    #define USE_AD4 FALSE
    #define USE_AD5 FALSE
    #define USE_AD6 FALSE
    #define USE_AD7 FALSE
    #define USE_AD8 FALSE
    #define USE_AD9 FALSE
    #define USE_AD10 FALSE
    #define USE_AD11 FALSE
    #define USE_AD12 FALSE
    #define USE_AD13 FALSE
    #define USE_AD14 FALSE
    #define USE_AD15 FALSE
    #define USE_AD16 FALSE
    #define USE_AD17 FALSE
    #define USE_AD18 FALSE
    #define USE_AD19 FALSE
    #define USE_AD20 FALSE
    #define USE_AD21 FALSE
    #define USE_AD22 FALSE
    #define USE_AD23 FALSE
    #define USE_AD24 FALSE
    #define USE_AD25 FALSE
    #define USE_AD26 FALSE
    #define USE_AD27 FALSE
    #define USE_AD28 FALSE
    #define USE_AD29 FALSE
    #define USE_AD30 FALSE
    #define USE_AD31 FALSE
    #define USE_AD32 FALSE
    #define USE_AD33 FALSE
    #define USE_AD34 FALSE</pre><p>For 16f18855 family of microcontrollers this is a example.  This will save 149 bytes of program memory.</p><pre class="screen">    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCB@SYN
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: 13.3.2021
    '''


        'Chip Settings.
        #CHIP 16F18855,32
        #CONFIG MCLRE_ON
        #OPTION EXPLICIT

        '' -------------------LATA-----------------
        '' Bit#:  -7---6---5---4---3---2---1---0---
        '' LED:   ---------------|D5 |D4 |D3 |D1 |-
        ''-----------------------------------------
        ''

        #define USART_BAUD_RATE 19200
        #define USART_TX_BLOCKING

        #define LEDD2 PORTA.0
        #define LEDD3 PORTA.1
        #define LEDD4 PORTA.2
        #define LEDD5 PORTA.3
        Dir     LEDD2 OUT
        Dir     LEDD3 OUT
        Dir     LEDD4 OUT
        Dir     LEDD5 OUT

        #define SWITCH_DOWN         0
        #define SWITCH_UP           1

        #define SWITCH              PORTA.5


        'Setup an Interrupt event when porta.5 goes negative.
        IOCAN5 = 1
        On Interrupt PORTABChange  Call InterruptHandler

        do

         'Read the value from the EEPROM from register Zero in the EEPROM
          EPRead ( 0, OutValue )

          'Leave the Top Bytes alone and set the lower four bits
          PortA = ( PortA &amp; 0XF0 ) OR ( OutValue / 16 )
          Sleep

        loop


    sub InterruptHandler

        if IOCAF5 = 1 then                         'S2 was just pressed
            IOCAN5 = 0                             'Prevent the event from reentering the InterruptHandler routine
            IOCAF5 = 0                             'We must clear the flag in software

            wait 5 ms                              'debounce by waiting and seeing if still held down
            if ( SWITCH = SWITCH_DOWN ) then
                'Read the ADC
                adc_value = readad ( AN4 )
                'Write the value to register Zero in the EEPROM
                EPWrite ( 0, adc_value )
            end if
            IOCAN5 = 1                              'ReEnable the InterruptHandler routine

        end if

    end sub

    #define USE_ADA0 FALSE
    #define USE_ADA1 FALSE
    #define USE_ADA2 FALSE
    #define USE_ADA3 FALSE
    #define USE_ADA4 TRUE
    #define USE_ADA5 FALSE
    #define USE_ADA6 FALSE
    #define USE_ADA7 FALSE
    #define USE_ADB0 FALSE
    #define USE_ADB1 FALSE
    #define USE_ADB2 FALSE
    #define USE_ADB3 FALSE
    #define USE_ADB4 FALSE
    #define USE_ADB5 FALSE
    #define USE_ADB6 FALSE
    #define USE_ADB7 FALSE
    #define USE_ADC0 FALSE
    #define USE_ADC1 FALSE
    #define USE_ADC2 FALSE
    #define USE_ADC3 FALSE
    #define USE_ADC4 FALSE
    #define USE_ADC5 FALSE
    #define USE_ADC6 FALSE
    #define USE_ADC7 FALSE
    #define USE_ADD0 FALSE
    #define USE_ADD1 FALSE
    #define USE_ADD2 FALSE
    #define USE_ADD3 FALSE
    #define USE_ADD4 FALSE
    #define USE_ADD5 FALSE
    #define USE_ADD6 FALSE
    #define USE_ADD7 FALSE
    #define USE_ADE0 FALSE
    #define USE_ADE1 FALSE
    #define USE_ADE2 FALSE</pre><p><span class="strong"><strong>2. Adapt the ADC configuration</strong></span></p><p>Example 1:</p><p>The following example will set the specific register bits.  The instruction will be added to the compiled code.</p><pre class="screen">    #define ADReadPreReadCommand  ADCON.2=0:ANSELA.0=1</pre><p>The constant <span class="strong"><strong>ADReadPreReadCommand</strong></span> can be used to adapt the ADC methods. The constant can enable registers or register bit(s) that are required to managed for a specfic solution.</p><p>In the example above the following ASM will be added to your code.  This WILL be added just before the ADC is enabled and the setting of the acquisition delay.</p><pre class="screen">  ;ADReadPreReadCommand
  banksel ADCON
  bcf ADCON,2
  banksel ANSELA
  bsf ANSELA,0</pre><p>Example 2:</p><p>The following example can be used to change the ADMUX to support a sensor on ADC4.</p><p>This supports reading the internal temperature sensor on the ATTINY85.&nbsp; &nbsp;
This method will work on other similar chips.&nbsp; &nbsp;
Please refer the chip specific datasheet.</p><p>This will call a macro to change the ADMUX to read the ATTINY85 internal temperature sensor, set the reference voltage to 1v1 and then wait 100 ms.</p><pre class="screen">    #define ADREADPREREADCOMMAND ATTINY85ReadInternalTemperatureSensor

    Macro ATTINY85ReadInternalTemperatureSensor
    /*
    17.12 of the datasheet
    The temperature measurement is based on an on-chip temperature sensor that is coupled to a single ended ADC4
    channel. Selecting the ADC4 channel by writing the MUX[3:0] bits in ADMUX register to &#147;1111&#148; enables the temperature sensor. The internal 1.1V reference must also be selected for the ADC reference source in the
    temperature sensor measurement. When the temperature sensor is enabled, the ADC converter can be used in
    single conversion mode to measure the voltage over the temperature sensor.
    The measured voltage has a linear relationship to the temperature as described in Table 17-2 The sensitivity is
    approximately 1 LSB / ?C and the accuracy depends on the method of user calibration. Typically, the measurement
    accuracy after a single temperature calibration is &plusmn;10?C, assuming calibration at room temperature. Better
    accuracies are achieved by using two temperature points for calibration.
    */
      IF ADReadPort=4 then
          ADMUX = ( ADMUX and 0X20 ) or 0X8F
          wait 100 ms
      End if

    End Macro</pre><p>This will generate the following ASM.</p><pre class="screen">    ;ADREADPREREADCOMMAND  'adds user code below
      lds SysCalcTempA,ADREADPORT
      cpi SysCalcTempA,4
      brne  ENDIF2
      ldi SysTemp2,32
      in  SysTemp3,ADMUX
      and SysTemp3,SysTemp2
      mov SysTemp1,SysTemp3
      ldi SysTemp2,143
      or  SysTemp1,SysTemp2
      out ADMUX,SysTemp1
      ldi SysWaitTempMS,100
      ldi SysWaitTempMS_H,0
      rcall Delay_MS
    ENDIF2:</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="analog_digital_conversion_code_optimisation"></span>Analog/Digital Conversion Code Optimisation

</div>

</div>

</div>

<span class="strong">**About Analog/Digital Conversion Code
Optimisation**</span>

The analog to digital converter (ADC or A/D) module support is
implemented by GCBASIC to provide 8-bit, 10-bit and 12-bit Single
channel measurement mode and Differential Channel Measurement with
support up to 34 channels. For compatibility all channels are supported.

There are two methods to optimise the code.

<div class="orderedlist">

1.  To mimise the code, use the contstants to disable support for a
    specfic channels
2.  To adapt the ADC configuration by inserting specfic commands to set
    registers or register bits.

</div>

<span class="strong">**1. Minimise the code**</span>

The example below would disable support for ADC port 0 (AD0).

``` screen
    #define USE_AD0 FALSE
```

The following tables show the \#defines that can be used to reduce the
code size - these are the defines for the standard microcontrollers. For
16f1688x and similar microcontrollers please see the second table.

<div class="informaltable">

| Channel    | Optimisation Value | Default Value |
|:-----------|:-------------------|:--------------|
| `USE_AD0`  | `FALSE`            | `TRUE`        |
| `USE_AD1`  | `FALSE`            | `TRUE`        |
| `USE_AD2`  | `FALSE`            | `TRUE`        |
| `USE_AD3`  | `FALSE`            | `TRUE`        |
| `USE_AD4`  | `FALSE`            | `TRUE`        |
| `USE_AD5`  | `FALSE`            | `TRUE`        |
| `USE_AD6`  | `FALSE`            | `TRUE`        |
| `USE_AD7`  | `FALSE`            | `TRUE`        |
| `USE_AD8`  | `FALSE`            | `TRUE`        |
| `USE_AD9`  | `FALSE`            | `TRUE`        |
| `USE_AD10` | `FALSE`            | `TRUE`        |
| `USE_AD11` | `FALSE`            | `TRUE`        |
| `USE_AD12` | `FALSE`            | `TRUE`        |
| `USE_AD13` | `FALSE`            | `TRUE`        |
| `USE_AD14` | `FALSE`            | `TRUE`        |
| `USE_AD15` | `FALSE`            | `TRUE`        |
| `USE_AD16` | `FALSE`            | `TRUE`        |
| `USE_AD17` | `FALSE`            | `TRUE`        |
| `USE_AD18` | `FALSE`            | `TRUE`        |
| `USE_AD19` | `FALSE`            | `TRUE`        |
| `USE_AD20` | `FALSE`            | `TRUE`        |
| `USE_AD21` | `FALSE`            | `TRUE`        |
| `USE_AD22` | `FALSE`            | `TRUE`        |
| `USE_AD23` | `FALSE`            | `TRUE`        |
| `USE_AD24` | `FALSE`            | `TRUE`        |
| `USE_AD25` | `FALSE`            | `TRUE`        |
| `USE_AD26` | `FALSE`            | `TRUE`        |
| `USE_AD27` | `FALSE`            | `TRUE`        |
| `USE_AD28` | `FALSE`            | `TRUE`        |
| `USE_AD29` | `FALSE`            | `TRUE`        |
| `USE_AD30` | `FALSE`            | `TRUE`        |
| `USE_AD31` | `FALSE`            | `TRUE`        |
| `USE_AD32` | `FALSE`            | `TRUE`        |
| `USE_AD33` | `FALSE`            | `TRUE`        |
| `USE_AD34` | `FALSE`            | `TRUE`        |

</div>

For 16f1688x devices see the table below.

<div class="informaltable">

| Channel    | Optimisation Value | Default Value |
|:-----------|:-------------------|:--------------|
| `USE_ADA0` | `FALSE`            | `TRUE`        |
| `USE_ADA1` | `FALSE`            | `TRUE`        |
| `USE_ADA2` | `FALSE`            | `TRUE`        |
| `USE_ADA3` | `FALSE`            | `TRUE`        |
| `USE_ADA4` | `FALSE`            | `TRUE`        |
| `USE_ADA5` | `FALSE`            | `TRUE`        |
| `USE_ADA6` | `FALSE`            | `TRUE`        |
| `USE_ADA7` | `FALSE`            | `TRUE`        |
| `USE_ADC0` | `FALSE`            | `TRUE`        |
| `USE_ADC1` | `FALSE`            | `TRUE`        |
| `USE_ADC2` | `FALSE`            | `TRUE`        |
| `USE_ADC3` | `FALSE`            | `TRUE`        |
| `USE_ADC4` | `FALSE`            | `TRUE`        |
| `USE_ADC5` | `FALSE`            | `TRUE`        |
| `USE_ADC6` | `FALSE`            | `TRUE`        |
| `USE_ADC7` | `FALSE`            | `TRUE`        |
| `USE_ADD0` | `FALSE`            | `TRUE`        |
| `USE_ADD1` | `FALSE`            | `TRUE`        |
| `USE_ADD2` | `FALSE`            | `TRUE`        |
| `USE_ADD3` | `FALSE`            | `TRUE`        |
| `USE_ADD4` | `FALSE`            | `TRUE`        |
| `USE_ADD5` | `FALSE`            | `TRUE`        |
| `USE_ADD6` | `FALSE`            | `TRUE`        |
| `USE_ADD7` | `FALSE`            | `TRUE`        |
| `USE_ADE0` | `FALSE`            | `TRUE`        |
| `USE_ADE1` | `FALSE`            | `TRUE`        |
| `USE_ADE2` | `FALSE`            | `TRUE`        |

</div>

This is a example - disables every channel except the specified channel
by defining every channel except USE\_AD0 as FALSE.

This will save 146 bytes of program memory.

``` screen
    #chip 16F1939

    'USART settings
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    'Set the input pin direction
    Dir PORTA.0 In

    'Print 255 reading
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        HSerPrint str(ReadAD10(AN0))

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next

    #define USE_AD0 TRUE
    #define USE_AD1 FALSE
    #define USE_AD2 FALSE
    #define USE_AD2 FALSE
    #define USE_AD3 FALSE
    #define USE_AD4 FALSE
    #define USE_AD5 FALSE
    #define USE_AD6 FALSE
    #define USE_AD7 FALSE
    #define USE_AD8 FALSE
    #define USE_AD9 FALSE
    #define USE_AD10 FALSE
    #define USE_AD11 FALSE
    #define USE_AD12 FALSE
    #define USE_AD13 FALSE
    #define USE_AD14 FALSE
    #define USE_AD15 FALSE
    #define USE_AD16 FALSE
    #define USE_AD17 FALSE
    #define USE_AD18 FALSE
    #define USE_AD19 FALSE
    #define USE_AD20 FALSE
    #define USE_AD21 FALSE
    #define USE_AD22 FALSE
    #define USE_AD23 FALSE
    #define USE_AD24 FALSE
    #define USE_AD25 FALSE
    #define USE_AD26 FALSE
    #define USE_AD27 FALSE
    #define USE_AD28 FALSE
    #define USE_AD29 FALSE
    #define USE_AD30 FALSE
    #define USE_AD31 FALSE
    #define USE_AD32 FALSE
    #define USE_AD33 FALSE
    #define USE_AD34 FALSE
```

For 16f18855 family of microcontrollers this is a example. This will
save 149 bytes of program memory.

``` screen
    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCB@SYN
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: 13.3.2021
    '''


        'Chip Settings.
        #CHIP 16F18855,32
        #CONFIG MCLRE_ON
        #OPTION EXPLICIT

        '' -------------------LATA-----------------
        '' Bit#:  -7---6---5---4---3---2---1---0---
        '' LED:   ---------------|D5 |D4 |D3 |D1 |-
        ''-----------------------------------------
        ''

        #define USART_BAUD_RATE 19200
        #define USART_TX_BLOCKING

        #define LEDD2 PORTA.0
        #define LEDD3 PORTA.1
        #define LEDD4 PORTA.2
        #define LEDD5 PORTA.3
        Dir     LEDD2 OUT
        Dir     LEDD3 OUT
        Dir     LEDD4 OUT
        Dir     LEDD5 OUT

        #define SWITCH_DOWN         0
        #define SWITCH_UP           1

        #define SWITCH              PORTA.5


        'Setup an Interrupt event when porta.5 goes negative.
        IOCAN5 = 1
        On Interrupt PORTABChange  Call InterruptHandler

        do

         'Read the value from the EEPROM from register Zero in the EEPROM
          EPRead ( 0, OutValue )

          'Leave the Top Bytes alone and set the lower four bits
          PortA = ( PortA & 0XF0 ) OR ( OutValue / 16 )
          Sleep

        loop


    sub InterruptHandler

        if IOCAF5 = 1 then                         'S2 was just pressed
            IOCAN5 = 0                             'Prevent the event from reentering the InterruptHandler routine
            IOCAF5 = 0                             'We must clear the flag in software

            wait 5 ms                              'debounce by waiting and seeing if still held down
            if ( SWITCH = SWITCH_DOWN ) then
                'Read the ADC
                adc_value = readad ( AN4 )
                'Write the value to register Zero in the EEPROM
                EPWrite ( 0, adc_value )
            end if
            IOCAN5 = 1                              'ReEnable the InterruptHandler routine

        end if

    end sub

    #define USE_ADA0 FALSE
    #define USE_ADA1 FALSE
    #define USE_ADA2 FALSE
    #define USE_ADA3 FALSE
    #define USE_ADA4 TRUE
    #define USE_ADA5 FALSE
    #define USE_ADA6 FALSE
    #define USE_ADA7 FALSE
    #define USE_ADB0 FALSE
    #define USE_ADB1 FALSE
    #define USE_ADB2 FALSE
    #define USE_ADB3 FALSE
    #define USE_ADB4 FALSE
    #define USE_ADB5 FALSE
    #define USE_ADB6 FALSE
    #define USE_ADB7 FALSE
    #define USE_ADC0 FALSE
    #define USE_ADC1 FALSE
    #define USE_ADC2 FALSE
    #define USE_ADC3 FALSE
    #define USE_ADC4 FALSE
    #define USE_ADC5 FALSE
    #define USE_ADC6 FALSE
    #define USE_ADC7 FALSE
    #define USE_ADD0 FALSE
    #define USE_ADD1 FALSE
    #define USE_ADD2 FALSE
    #define USE_ADD3 FALSE
    #define USE_ADD4 FALSE
    #define USE_ADD5 FALSE
    #define USE_ADD6 FALSE
    #define USE_ADD7 FALSE
    #define USE_ADE0 FALSE
    #define USE_ADE1 FALSE
    #define USE_ADE2 FALSE
```

<span class="strong">**2. Adapt the ADC configuration**</span>

Example 1:

The following example will set the specific register bits. The
instruction will be added to the compiled code.

``` screen
    #define ADReadPreReadCommand  ADCON.2=0:ANSELA.0=1
```

The constant <span class="strong">**ADReadPreReadCommand**</span> can be
used to adapt the ADC methods. The constant can enable registers or
register bit(s) that are required to managed for a specfic solution.

In the example above the following ASM will be added to your code. This
WILL be added just before the ADC is enabled and the setting of the
acquisition delay.

``` screen
  ;ADReadPreReadCommand
  banksel ADCON
  bcf ADCON,2
  banksel ANSELA
  bsf ANSELA,0
```

Example 2:

The following example can be used to change the ADMUX to support a
sensor on ADC4.

This supports reading the internal temperature sensor on the ATTINY85. 
  This method will work on other similar chips.    Please refer the chip
specific datasheet.

This will call a macro to change the ADMUX to read the ATTINY85 internal
temperature sensor, set the reference voltage to 1v1 and then wait 100
ms.

``` screen
    #define ADREADPREREADCOMMAND ATTINY85ReadInternalTemperatureSensor

    Macro ATTINY85ReadInternalTemperatureSensor
    /*
    17.12 of the datasheet
    The temperature measurement is based on an on-chip temperature sensor that is coupled to a single ended ADC4
    channel. Selecting the ADC4 channel by writing the MUX[3:0] bits in ADMUX register to 1111 enables the temperature sensor. The internal 1.1V reference must also be selected for the ADC reference source in the
    temperature sensor measurement. When the temperature sensor is enabled, the ADC converter can be used in
    single conversion mode to measure the voltage over the temperature sensor.
    The measured voltage has a linear relationship to the temperature as described in Table 17-2 The sensitivity is
    approximately 1 LSB / ?C and the accuracy depends on the method of user calibration. Typically, the measurement
    accuracy after a single temperature calibration is ±10?C, assuming calibration at room temperature. Better
    accuracies are achieved by using two temperature points for calibration.
    */
      IF ADReadPort=4 then
          ADMUX = ( ADMUX and 0X20 ) or 0X8F
          wait 100 ms
      End if

    End Macro
```

This will generate the following ASM.

``` screen
    ;ADREADPREREADCOMMAND  'adds user code below
      lds SysCalcTempA,ADREADPORT
      cpi SysCalcTempA,4
      brne  ENDIF2
      ldi SysTemp2,32
      in  SysTemp3,ADMUX
      and SysTemp3,SysTemp2
      mov SysTemp1,SysTemp3
      ldi SysTemp2,143
      or  SysTemp1,SysTemp2
      out ADMUX,SysTemp1
      ldi SysWaitTempMS,100
      ldi SysWaitTempMS_H,0
      rcall Delay_MS
    ENDIF2:
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Analog/Digital Conversion Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_analog_digital_conversion.html" title="Analog/Digital conversion"><link rel="prev" href="_analog_digital_conversion.html" title="Analog/Digital conversion"><link rel="next" href="_adformat_deprecated_do_not_use.html" title="ADFormat (Deprecated - Do not use)"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_analog_digital_conversion_overview"></a>Analog/Digital Conversion Overview</h4></div></div></div><p><span class="strong"><strong>About Analog to Digital Conversion</strong></span></p><p>The analog to digital converter (ADC or A/D) module support is implemented by GCBASIC to provide 8-bit, 10-bit and 12-bit Single channel measurement mode and Differential Channel Measurement mode.</p><p>GCBASIC configures the analog to digital converter clock source, the programmed acquisition time and justification of the response byte, word or integer (as defined in the GCBASIC method).</p><p><span class="strong"><strong>Normal or Single channel measurement mode</strong></span></p><p>The Single channel measurement mode is the default method for reading the ADC port.  The positive input is attached to suitable device (a light sensor or adjustable resistor) and the command ReadADC, ReadADC10, ReadADC12 with return a byte, word or word value respectively.</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/adcoverviewb1.PNG" align="middle" alt="graphic"></div></div><p>The A/D module on most microcontrollers only supports single-ended mode. Single channel mode uses a single A/D port and the returned Value represents the difference between the voltage on the analog pin and a fixed negative reference which is usually ground or Vss.</p><p>The syntax for single-ended A/D is Returned_Value = ReadAD(Port)</p><p>Example</p><pre class="screen">  Print ReadAD10(AN3)</pre><p><span class="strong"><strong>Differential channel measurement mode</strong></span></p><p>Some of the in the Microchip PIC family of devices also support differential analog to digital conversion. With differential conversion, the differential voltage between two channels is measured and converted to a digital value.  The returned value can be either positive or negative (therefore an integer value).</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/adcoverviewb2.PNG" align="middle" alt="graphic"></div></div><p>When configured to differential channel measurement mode, the positive channel is connected to the defined positive analog pin (ANx), and the negative channel is connected to the defined negative analog pin. These two pins are internally connected (within the microcontroller) to a unity gain differential amplifier and once the amplifier has completed the comparison the result is returned as an integer.</p><p>The positive channel Input is selected using the CHSx bits and the negative channel input is selected using the CHSNx bits.  These bits are managed by GCBASIC.  The programmer only needs to supply the correct analog pin designators in the ReadADx commands.</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/adcoverviewb3.PNG" align="middle" alt="graphic"></div></div><p>The 12-bit returned result is available on the ADRESH and ADRESL registers which is returned by the GCBASIC methods as an integer variable.</p><p>Some Microchip PIC microcontrollers have differential A/D modules and support differential Mode as well as 12-Bit A/D. With DIfferential mode the returned value can be either a positive or negative number that represents the voltage differential between the two A/D ports.</p><p>The syntax for differential A/D is ReadAD( PositiveANPort , NegativeANPort ).  Note: if "negative port" is omitted readAd() will perform a single-ended read on the positive AN port.</p><p>Example</p><pre class="screen">  Print ReadAD12( AN3, An4 )</pre><p><span class="strong"><strong>Using Voltage Reference</strong></span></p><p>Voltage references come in many forms and offer different features across the PICs, AVR and LGTs microcontrollers.&nbsp;&nbsp;
But, in the end, accuracy and stability are a voltage reference&#8217;s most important features, as the main purpose of the reference is to provide a known output voltage.&nbsp;&nbsp;
Variation from this known value is an error.&nbsp;&nbsp;
Therefore, it is useful to use the internal voltage reference provided within the microcontroller.</p><p>To use a voltage reference source for ADC operation sett the <code class="literal">AD_REF_SOURCE</code> constant to your chosen source.&nbsp;&nbsp;
The defaults to the VCC pin, and there for the constant is set by default to <code class="literal">AD_REF_AVCC</code>.&nbsp;&nbsp;
The voltage reference is specific to the microcontroller but the options are as follows:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>AD_REF_SOURCEConstant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Reference Voltage</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>AD_REF_AVCC</p></td><td align="left" valign="top"><p>VCC supplied Voltage</p></td></tr><tr><td align="left" valign="top"><p>AD_REF_1024</p></td><td align="left" valign="top"><p>1.024v internal reference source</p></td></tr><tr><td align="left" valign="top"><p>AD_REF_2048</p></td><td align="left" valign="top"><p>2.048v internal reference source</p></td></tr><tr><td align="left" valign="top"><p>AD_REF_4096</p></td><td align="left" valign="top"><p>4.096v internal reference source</p></td></tr><tr><td align="left" valign="top"><p>AD_REF_AREF</p></td><td align="left" valign="top"><p>Extenal voltage reference source</p></td></tr><tr><td align="left" valign="top"><p>AD_REF_256</p></td><td align="left" valign="top"><p>AD_REF_256 for ATMegas</p></td></tr></tbody></table></div><p><span class="strong"><strong>Optimising GCBASIC Code</strong></span></p><p>GCBASIC supports a wide range of A/D modules and the supporting library addresses up to 34 channels.
To reduce the size of the code produced you can define which channels are specifically supported.  See <a class="link" href="_analog_digital_conversion_code_optimisation.html" title="Analog/Digital Conversion Code Optimisation">Optimising ADC code</a> for more details.</p><p>See also <a class="link" href="_readad.html" title="ReadAD">ReadAD</a>, <a class="link" href="_readad10.html" title="ReadAD10">ReadAD10</a> and <a class="link" href="_readad12.html" title="ReadAD12">ReadAD12</a></p><p>For the latest Microchip PIC microcontrollers that support Differential and 12-bit A/D please refer to Microchip MAPS or the microcontrollers datasheet.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="analog_digital_conversion_overview"></span>Analog/Digital Conversion Overview

</div>

</div>

</div>

<span class="strong">**About Analog to Digital Conversion**</span>

The analog to digital converter (ADC or A/D) module support is
implemented by GCBASIC to provide 8-bit, 10-bit and 12-bit Single
channel measurement mode and Differential Channel Measurement mode.

GCBASIC configures the analog to digital converter clock source, the
programmed acquisition time and justification of the response byte, word
or integer (as defined in the GCBASIC method).

<span class="strong">**Normal or Single channel measurement
mode**</span>

The Single channel measurement mode is the default method for reading
the ADC port. The positive input is attached to suitable device (a light
sensor or adjustable resistor) and the command ReadADC, ReadADC10,
ReadADC12 with return a byte, word or word value respectively.

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/adcoverviewb1.PNG)

</div>

</div>

The A/D module on most microcontrollers only supports single-ended mode.
Single channel mode uses a single A/D port and the returned Value
represents the difference between the voltage on the analog pin and a
fixed negative reference which is usually ground or Vss.

The syntax for single-ended A/D is Returned\_Value = ReadAD(Port)

Example

``` screen
  Print ReadAD10(AN3)
```

<span class="strong">**Differential channel measurement mode**</span>

Some of the in the Microchip PIC family of devices also support
differential analog to digital conversion. With differential conversion,
the differential voltage between two channels is measured and converted
to a digital value. The returned value can be either positive or
negative (therefore an integer value).

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/adcoverviewb2.PNG)

</div>

</div>

When configured to differential channel measurement mode, the positive
channel is connected to the defined positive analog pin (ANx), and the
negative channel is connected to the defined negative analog pin. These
two pins are internally connected (within the microcontroller) to a
unity gain differential amplifier and once the amplifier has completed
the comparison the result is returned as an integer.

The positive channel Input is selected using the CHSx bits and the
negative channel input is selected using the CHSNx bits. These bits are
managed by GCBASIC. The programmer only needs to supply the correct
analog pin designators in the ReadADx commands.

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/adcoverviewb3.PNG)

</div>

</div>

The 12-bit returned result is available on the ADRESH and ADRESL
registers which is returned by the GCBASIC methods as an integer
variable.

Some Microchip PIC microcontrollers have differential A/D modules and
support differential Mode as well as 12-Bit A/D. With DIfferential mode
the returned value can be either a positive or negative number that
represents the voltage differential between the two A/D ports.

The syntax for differential A/D is ReadAD( PositiveANPort ,
NegativeANPort ). Note: if "negative port" is omitted readAd() will
perform a single-ended read on the positive AN port.

Example

``` screen
  Print ReadAD12( AN3, An4 )
```

<span class="strong">**Using Voltage Reference**</span>

Voltage references come in many forms and offer different features
across the PICs, AVR and LGTs microcontrollers.   But, in the end,
accuracy and stability are a voltage reference’s most important
features, as the main purpose of the reference is to provide a known
output voltage.   Variation from this known value is an error.  
Therefore, it is useful to use the internal voltage reference provided
within the microcontroller.

To use a voltage reference source for ADC operation sett the
`AD_REF_SOURCE` constant to your chosen source.   The defaults to the
VCC pin, and there for the constant is set by default to
`AD_REF_AVCC`.   The voltage reference is specific to the
microcontroller but the options are as follows:

<div class="informaltable">

| <span class="strong">**AD\_REF\_SOURCEConstant**</span> | <span class="strong">**Reference Voltage**</span> |
|:--------------------------------------------------------|:--------------------------------------------------|
| AD\_REF\_AVCC                                           | VCC supplied Voltage                              |
| AD\_REF\_1024                                           | 1.024v internal reference source                  |
| AD\_REF\_2048                                           | 2.048v internal reference source                  |
| AD\_REF\_4096                                           | 4.096v internal reference source                  |
| AD\_REF\_AREF                                           | Extenal voltage reference source                  |
| AD\_REF\_256                                            | AD\_REF\_256 for ATMegas                          |

</div>

<span class="strong">**Optimising GCBASIC Code**</span>

GCBASIC supports a wide range of A/D modules and the supporting library
addresses up to 34 channels. To reduce the size of the code produced you
can define which channels are specifically supported. See
<a href="analog_digital_conversion_code_optimisation" class="link" title="Analog/Digital Conversion Code Optimisation">Optimising ADC code</a>
for more details.

See also <a href="readad" class="link" title="ReadAD">ReadAD</a>,
<a href="readad10" class="link" title="ReadAD10">ReadAD10</a> and
<a href="readad12" class="link" title="ReadAD12">ReadAD12</a>

For the latest Microchip PIC microcontrollers that support Differential
and 12-bit A/D please refer to Microchip MAPS or the microcontrollers
datasheet.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Arrays</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_syntax.html" title="Syntax"><link rel="next" href="_comments.html" title="Comments"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_arrays"></a>Arrays</h3></div></div></div><p><span class="strong"><strong>About Arrays</strong></span></p><p>An array is a special type of variable - one which can store several values at once.&nbsp;&nbsp;It is essentially a list of numbers in which each one can be addressed individually through the use of an "index".</p><p>The numbers can be bytes (the default), longs, integers, or words.  &nbsp;&nbsp;The index is a value in brackets immediately after the name of the array.</p><p>All the numbers stored in an array must be of the same type.  &nbsp;&nbsp;For instance, you cannot store bytes and words in the same array.</p><p>Array are are 1-based. &nbsp;&nbsp;The first element is element zero.</p><p>Examples of array names are:</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Array/Index</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Meaning</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">Fish(10)</code></p></td><td align="left" valign="top"><p>Definition of an array containing bytes with 10 elements called <code class="literal">Fish</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">x(5) As Word</code></p></td><td align="left" valign="top"><p>Definition of an array containing words with 5 elements called <code class="literal">x</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">DataLog(2)</code></p></td><td align="left" valign="top"><p>The second element in an array named <code class="literal">DataLog</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ButtonList(Temp)</code></p></td><td align="left" valign="top"><p>An element in the array <code class="literal">ButtonList</code> that is selected according to the
value in the variable <code class="literal">Temp</code></p></td></tr></tbody></table></div><p><span class="strong"><strong>Defining an array</strong></span></p><p>Use the DIM command to define an array.</p><pre class="screen">    DIM array_title ( number_of_elements ) [As _type_]</pre><p>The number of elements can be number or a constant - not a variable.</p><p>The value for the number elements in an array must be a number or constant.
The compiler allocates RAM for arrays at compile time, and therefore you cannot use a variable because during compilation the value of a variable cannot be determined.</p><p><span class="strong"><strong>Assigning values to an array</strong></span></p><p>It is possible to set several elements of a byte array with a single line of code. This short example shows how:</p><pre class="screen">    Dim TestVar(10)
    TestVar = 1, 2, 3, 4, 5, 6, 7, 8, 9</pre><p>When using this method above element 0 of the array TestVar will be set to the number of items in the list, which in this case is 9. &nbsp;&nbsp;Each element of the array will then be loaded with the corresponding value in the list - so in the example, TestVar(1) will be set to 1, TestVar(2) to 2, and so on.  &nbsp;&nbsp;Element 0 will only be set to number of items in the array when using this method.   &nbsp;&nbsp;For microcontrollers with less than 2048 bytes of RAM the limit is 250 elements or the array cannot exceed the microcontrollers RAM size.  &nbsp;&nbsp;For microcontrollers with more than 2048 bytes of RAM the limit is 255 elements.</p><p>This only works for <span class="strong"><strong>byte</strong></span> arrays, however.  For arrays of type <code class="literal">integer</code>, <code class="literal">word</code>, or <code class="literal">long</code>, each element must be set separately:</p><pre class="screen">    Dim TestVar(5) As Word
    TestVar(1) = 20
    TestVar(2) = 50
    TestVar(3) = 60
    TestVar(4) = 80
    TestVar(5) = 100</pre><p>If each element has the same value, this can be shortened using a loop:</p><pre class="screen">    Dim TestVar(5) As Word
    For i = 1 to 5
        TestVar(i) = 0
    Next</pre><p><span class="strong"><strong>Array Length</strong></span></p><p>Element 0 should not be used to obtain the length of the array.&nbsp;&nbsp; Element 0 will only be a consistent with respect to the length of the array when the array is set as shown above.</p><p>The correct method is to use a constant to set the array size and use the constant within your code to obtain the array length.</p><pre class="screen">    #Define ArraySizeConstant 500
    Dim TestVar( ArraySizeConstant )

    SerPrint ArraySizeConstant     'or, other usage</pre><p><span class="strong"><strong>Using Arrays</strong></span></p><p>To use an array, its name is specified, then the index. Arrays can be used everywhere that a normal variable can be used.</p><p><span class="strong"><strong>Maximum Array Size</strong></span></p><p>The limit on the array size is dependent on the chip type, the amount of RAM, and the number of other variable you use in your program.</p><p>Use the following simple program to determine the maximum array size. Set <code class="literal">CHIP</code> to your device, <code class="literal">MAXSCOPE</code> to a value which is less the total RAM, and the data type of <code class="literal">test_array</code> to the data type to be stored in the array.</p><p>The data type of <code class="literal">imaxscope</code> must be set to match the size of the constant <code class="literal">MAXSCOPE</code>.  If <code class="literal">MAXSCOPE</code> &#8656; 255, <code class="literal">imaxscope</code> should be a byte.&nbsp;&nbsp;  If <code class="literal">MAXSCOPE</code> &gt; 255, <code class="literal">imaxscope</code> should be a word.</p><p>If the array is too large to fit, the compiler will issue an error message.  &nbsp;&nbsp;Reduce MAXSCOPE until the error message is not issued.  &nbsp;&nbsp;The largest <code class="literal">MAXSCOPE</code> value without an error message is the largest useable array of this type for this chip.</p><pre class="screen">    #CHIP   12f1571
    #OPTION Explicit

    #DEFINE MAXSCOPE  111
    DIM     imaxscope As Byte
    DIM     test_array( MAXSCOPE ) As Byte


    For imaxscope = 0 to MAXSCOPE
      test_array( imaxscope ) = imaxscope
    Next</pre><p>For the Atmel AVR, LGT 328p or an 18F array sizes are limited to 10,000 elements.</p><p>If a memory limit is reached, the compiler will issue an error message.</p><p><span class="strong"><strong>Get the most from the available memory</strong></span></p><p>Array RAM usage is determined by the architecture of the chip type. &nbsp;&nbsp;Getting most out of the available memory is determined by the allocation of the array within the available banks of memory.</p><p>An example is an array of 6 or 7 bytes when there is only 24 bytes of RAM  and the 24 bytes is split across multiple memory banks.  &nbsp;&nbsp;Assume in this example that 18 bytes have allocated to other variables and there is 29 bytes total available.  &nbsp;&nbsp;An array of 6 bytes will fit into the free space in one bank, but the array of 7 will not.</p><p>GCBASIC currently cannot split an array over banks, so if there are 6 bytes free in one bank and 5 in another, you cannot have an array of 7 bytes. &nbsp;&nbsp; This would be very hard to do efficiently on 12F/16F as there would be a series of special function registers in the middle of the array when using a 12F or 16F.   &nbsp;&nbsp;This constraint is not the case on 16F1/18F as linear addressing makes it easy to span banks because the SFRs are not making the problem (as with 12F/16F).</p><p><span class="strong"><strong>Using Tables as an alternative.</strong></span></p><p>If there are many items in the array, it may be better to use a Lookup Table to store the items, and then copy some of the data items into a smaller array as needed.</p><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_dim.html" title="Dim">Declaring arrays with DIM</a>,<a class="link" href="_alloc.html" title="Alloc">Declaring memory with ALLOC</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="arrays"></span>Arrays

</div>

</div>

</div>

<span class="strong">**About Arrays**</span>

An array is a special type of variable - one which can store several
values at once.  It is essentially a list of numbers in which each one
can be addressed individually through the use of an "index".

The numbers can be bytes (the default), longs, integers, or words.   The
index is a value in brackets immediately after the name of the array.

All the numbers stored in an array must be of the same type.   For
instance, you cannot store bytes and words in the same array.

Array are are 1-based.   The first element is element zero.

Examples of array names are:

<div class="informaltable">

| <span class="strong">**Array/Index**</span> | <span class="strong">**Meaning**</span>                                                             |
|:--------------------------------------------|:----------------------------------------------------------------------------------------------------|
| `Fish(10)`                                  | Definition of an array containing bytes with 10 elements called `Fish`                              |
| `x(5) As Word`                              | Definition of an array containing words with 5 elements called `x`                                  |
| `DataLog(2)`                                | The second element in an array named `DataLog`                                                      |
| `ButtonList(Temp)`                          | An element in the array `ButtonList` that is selected according to the value in the variable `Temp` |

</div>

<span class="strong">**Defining an array**</span>

Use the DIM command to define an array.

``` screen
    DIM array_title ( number_of_elements ) [As _type_]
```

The number of elements can be number or a constant - not a variable.

The value for the number elements in an array must be a number or
constant. The compiler allocates RAM for arrays at compile time, and
therefore you cannot use a variable because during compilation the value
of a variable cannot be determined.

<span class="strong">**Assigning values to an array**</span>

It is possible to set several elements of a byte array with a single
line of code. This short example shows how:

``` screen
    Dim TestVar(10)
    TestVar = 1, 2, 3, 4, 5, 6, 7, 8, 9
```

When using this method above element 0 of the array TestVar will be set
to the number of items in the list, which in this case is 9.   Each
element of the array will then be loaded with the corresponding value in
the list - so in the example, TestVar(1) will be set to 1, TestVar(2) to
2, and so on.   Element 0 will only be set to number of items in the
array when using this method.   For microcontrollers with less than 2048
bytes of RAM the limit is 250 elements or the array cannot exceed the
microcontrollers RAM size.   For microcontrollers with more than 2048
bytes of RAM the limit is 255 elements.

This only works for <span class="strong">**byte**</span> arrays,
however. For arrays of type `integer`, `word`, or `long`, each element
must be set separately:

``` screen
    Dim TestVar(5) As Word
    TestVar(1) = 20
    TestVar(2) = 50
    TestVar(3) = 60
    TestVar(4) = 80
    TestVar(5) = 100
```

If each element has the same value, this can be shortened using a loop:

``` screen
    Dim TestVar(5) As Word
    For i = 1 to 5
        TestVar(i) = 0
    Next
```

<span class="strong">**Array Length**</span>

Element 0 should not be used to obtain the length of the array.  
Element 0 will only be a consistent with respect to the length of the
array when the array is set as shown above.

The correct method is to use a constant to set the array size and use
the constant within your code to obtain the array length.

``` screen
    #Define ArraySizeConstant 500
    Dim TestVar( ArraySizeConstant )

    SerPrint ArraySizeConstant     'or, other usage
```

<span class="strong">**Using Arrays**</span>

To use an array, its name is specified, then the index. Arrays can be
used everywhere that a normal variable can be used.

<span class="strong">**Maximum Array Size**</span>

The limit on the array size is dependent on the chip type, the amount of
RAM, and the number of other variable you use in your program.

Use the following simple program to determine the maximum array size.
Set `CHIP` to your device, `MAXSCOPE` to a value which is less the total
RAM, and the data type of `test_array` to the data type to be stored in
the array.

The data type of `imaxscope` must be set to match the size of the
constant `MAXSCOPE`. If `MAXSCOPE` ⇐ 255, `imaxscope` should be a
byte.   If `MAXSCOPE` &gt; 255, `imaxscope` should be a word.

If the array is too large to fit, the compiler will issue an error
message.   Reduce MAXSCOPE until the error message is not issued.   The
largest `MAXSCOPE` value without an error message is the largest useable
array of this type for this chip.

``` screen
    #CHIP   12f1571
    #OPTION Explicit

    #DEFINE MAXSCOPE  111
    DIM     imaxscope As Byte
    DIM     test_array( MAXSCOPE ) As Byte


    For imaxscope = 0 to MAXSCOPE
      test_array( imaxscope ) = imaxscope
    Next
```

For the Atmel AVR, LGT 328p or an 18F array sizes are limited to 10,000
elements.

If a memory limit is reached, the compiler will issue an error message.

<span class="strong">**Get the most from the available memory**</span>

Array RAM usage is determined by the architecture of the chip type.
  Getting most out of the available memory is determined by the
allocation of the array within the available banks of memory.

An example is an array of 6 or 7 bytes when there is only 24 bytes of
RAM and the 24 bytes is split across multiple memory banks.   Assume in
this example that 18 bytes have allocated to other variables and there
is 29 bytes total available.   An array of 6 bytes will fit into the
free space in one bank, but the array of 7 will not.

GCBASIC currently cannot split an array over banks, so if there are 6
bytes free in one bank and 5 in another, you cannot have an array of 7
bytes.    This would be very hard to do efficiently on 12F/16F as there
would be a series of special function registers in the middle of the
array when using a 12F or 16F.   This constraint is not the case on
16F1/18F as linear addressing makes it easy to span banks because the
SFRs are not making the problem (as with 12F/16F).

<span class="strong">**Using Tables as an alternative.**</span>

If there are many items in the array, it may be better to use a Lookup
Table to store the items, and then copy some of the data items into a
smaller array as needed.

<span class="strong">**For more help, see**</span>
<a href="dim" class="link" title="Dim">Declaring arrays with DIM</a>,<a href="alloc" class="link" title="Alloc">Declaring memory with ALLOC</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Asc</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_string_manipulation.html" title="String Manipulation"><link rel="next" href="_bytetobin.html" title="ByteToBin"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_asc"></a>Asc</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    byte<span class="emphasis"><em>var</em></span>= ASC(string, [position] )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Returns the character code of the character at the specified position in a string.</p><p><code class="literal">ASC</code> returns the character code of a particular character in the string.  If the string is an ANSI string, the returned value will be in the range of 0 to 255. This function DOES NOT support UNICODE.</p><p>The optional position parameter determines which character is to be checked. The first character is one, the second two, etc. If the position parameter is missing, the first character is presumed.</p><p><code class="literal">CHR</code> is the natural complement of <code class="literal">ASC</code>. <code class="literal">CHR</code> produces a one-character string corresponding to its ASCII.</p><p><span class="strong"><strong>Note:</strong></span></p><p>If the string passed is null (zero-length) or the position is zero or greater than the length of the string the returned value will be 0.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    charpos = ASC( "ABCD" )     ' Returns 65

    charpos = ASC( "ABCD", 2 )  ' Returns 66</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_chr.html" title="Chr">Chr</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="asc"></span>Asc

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    bytevar= ASC(string, [position] )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

Returns the character code of the character at the specified position in
a string.

`ASC` returns the character code of a particular character in the
string. If the string is an ANSI string, the returned value will be in
the range of 0 to 255. This function DOES NOT support UNICODE.

The optional position parameter determines which character is to be
checked. The first character is one, the second two, etc. If the
position parameter is missing, the first character is presumed.

`CHR` is the natural complement of `ASC`. `CHR` produces a one-character
string corresponding to its ASCII.

<span class="strong">**Note:**</span>

If the string passed is null (zero-length) or the position is zero or
greater than the length of the string the returned value will be 0.

<span class="strong">**Example:**</span>

``` screen
    charpos = ASC( "ABCD" )     ' Returns 65

    charpos = ASC( "ABCD", 2 )  ' Returns 66
```

<span class="strong">**For more help, see**</span>
<a href="chr" class="link" title="Chr">Chr</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Assembler Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_using_assembler.html" title="Using Assembler"><link rel="prev" href="_using_assembler.html" title="Using Assembler"><link rel="next" href="_macros.html" title="Macros"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_assembler_overview"></a>Assembler Overview</h3></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>You can use microcontroller assembler code within your GCBASIC code.</p><p>You can put the assembler code inline in with your source code. The assembler code will be passed through to the assembly file associated with your project.</p><p>GCBASIC should recognise all of the commands in the microcontroller datasheet.</p><p>The commands should be in lower case, this is good practice, and have a space or tab in front of the command.</p><p>Even if the mnemonics are not being formatted properly, <code class="literal">gputils/MPASM</code> should still be capable of assembling the source code.</p><p>Format commands as follows:</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  btfsc STATUS,Z
  bsf PORTB,1</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="assembler_overview"></span>Assembler Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

You can use microcontroller assembler code within your GCBASIC code.

You can put the assembler code inline in with your source code. The
assembler code will be passed through to the assembly file associated
with your project.

GCBASIC should recognise all of the commands in the microcontroller
datasheet.

The commands should be in lower case, this is good practice, and have a
space or tab in front of the command.

Even if the mnemonics are not being formatted properly, `gputils/MPASM`
should still be capable of assembling the source code.

Format commands as follows:

<span class="strong">**Example:**</span>

``` screen
  btfsc STATUS,Z
  bsf PORTB,1
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ATMEL AVR PWM Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_pulse_width_modulation.html" title="Pulse width modulation"><link rel="prev" href="_hardware_pwm_code_optimisation.html" title="Hardware PWM Code Optimisation"><link rel="next" href="_hpwm_avr_ocrnx.html" title="HPWM AVR OCRnx"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_atmel_avr_pwm_overview"></a>ATMEL AVR PWM Overview</h4></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>The methods described in this section allow the generation of Pulse
Width Modulation (PWM) signals. PWM signals enables the microcontroller to control
items like the speed of a motor, or the brightness of a LED or lamp.<br></p><p>The methods can also be used to generate the appropriate frequency signal to drive an
infrared LED for remote control applications.<br></p><p>GCBASIC support the methods described in this section.</p><p><span class="strong"><strong>Hardware PWM using a Timer/Counter with a OCRnx module</strong></span></p><p>The AVR devices use a Timer/Counter and OCRnx module that has a variable period register.  The
Hardware PWM is available through the OCnx pin.</p><p>The method uses three parameters to setup the HPWM.</p><pre class="literallayout">'HPWM channel, frequency, duty cycle
HPWM  2, 100, 50</pre><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>A number of constants are used to control settings for PWM hardware module of the microcontroller.
To set them, place a line in the main program file that uses #define to assign a value to the particular constant.</p><p>&nbsp;<br>
&nbsp;<br>
&nbsp;<br></p><p><span class="strong"><strong>See</strong></span> <a class="link" href="_hpwm_avr_ocrnx.html" title="HPWM AVR OCRnx">HPWM AVR OCRnx</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="atmel_avr_pwm_overview"></span>ATMEL AVR PWM Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

The methods described in this section allow the generation of Pulse
Width Modulation (PWM) signals. PWM signals enables the microcontroller
to control items like the speed of a motor, or the brightness of a LED
or lamp.  

The methods can also be used to generate the appropriate frequency
signal to drive an infrared LED for remote control applications.  

GCBASIC support the methods described in this section.

<span class="strong">**Hardware PWM using a Timer/Counter with a OCRnx
module**</span>

The AVR devices use a Timer/Counter and OCRnx module that has a variable
period register. The Hardware PWM is available through the OCnx pin.

The method uses three parameters to setup the HPWM.

``` literallayout
'HPWM channel, frequency, duty cycle
HPWM  2, 100, 50
```

<span class="strong">**Relevant Constants:**</span>

A number of constants are used to control settings for PWM hardware
module of the microcontroller. To set them, place a line in the main
program file that uses \#define to assign a value to the particular
constant.

   
   
   

<span class="strong">**See**</span>
<a href="hpwm_avr_ocrnx" class="link" title="HPWM AVR OCRnx">HPWM AVR OCRnx</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Average</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_maths.html" title="Maths"><link rel="prev" href="_abs.html" title="Abs"><link rel="next" href="_difference.html" title="Difference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_average"></a>Average</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    integer_variable = Average(<span class="emphasis"><em>byte_variable1</em></span> , <span class="emphasis"><em>byte_variable2</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>A function that returns the average of two numbers. This only supports byte variables.</p><p>Provides a very fast way to calculate the average of two 8 bit numbers.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen"> average_value = Average(8,4)   ' Will return 6</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="average"></span>Average

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    integer_variable = Average(byte_variable1 , byte_variable2)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

A function that returns the average of two numbers. This only supports
byte variables.

Provides a very fast way to calculate the average of two 8 bit numbers.

<span class="strong">**Example:**</span>

``` screen
 average_value = Average(8,4)   ' Will return 6
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>A Glossary</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_frequent_errors.html" title="Frequent errors"><link rel="next" href="_frequently_asked_questions.html" title="Frequently Asked Questions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_a_glossary"></a>A Glossary</h2></div></div></div><p><span class="red">ADC:</span> analogue digital converter.</p><p><span class="red">Negative power supply:</span> reference to the common point of the circuit power supply, called circuit ground.</p><p><span class="red">Alias:</span> alternative name assigned to a pre-existing entity.</p><p><span class="red">Array:</span> variable able to handle numbers from 0 to 255.</p><p><span class="red">ASCII:</span> acronym for the American Standard Code for information interchange. ASCII is a code for the representation of English characters as numbers.</p><p><span class="red">Assembler:</span> PC software application that converts assembly language into machine language.</p><p><span class="red">Binary:</span> numeric system with base 2, in which there are only two possible values for each digit#0 and 1.</p><p><span class="red">Bit:</span> the smallest element of computer memory. It is a single digit in a binary number (0 or 1). Bit is also a type of variable in GCBASIC.</p><p><span class="red">Bitwise:</span> dealing with bits and binary states instead of numbers or logic.</p><p><span class="red">Byte:</span> 8-bit variable, value from 0 to 255 (2^ 8-1). Is also a type of variable in GCBASIC.</p><p><span class="red">Boolean:</span> related to a combinatorial system designed by George Boole, which combines propositions with the logical operators AND, OR and IF THEN, except NOT.</p><p><span class="red">CC:</span> direct current.</p><p><span class="red">Machine cycle:</span> oscillator frequency / 4, for PIC (do not forget the PLL where present).</p><p><span class="red">Code:</span> the memory area in a PIC MCU or AVR that contains the program code.</p><p><span class="red">Comment:</span> reminder notes placed in the program.</p><p><span class="red">Compiler:</span> PC software application, which converts a high level language like BASIC into assembly language. In this guide "Compiler" refers to GCBASIC.</p><p><span class="red">Compile-Time:</span> acts during compilation, and is not executed as a command when the program is running on the microcontroller.</p><p><span class="red">Constant:</span> a name that stands for a value defined in the program. The value is replaced instead of the name when the program is compiled and assembled. It is not stored in RAM and cannot be changed during program execution.</p><p><span class="red">D:</span> Digital.</p><p><span class="red">Data Space:</span> is a memory space in a PIC or AVR that is intended for the storage of values &#8203;&#8203;(EEPROM memory on chip). Data is accessible in GCBASIC using the EpRead and EpWrite commands for reading and writing.</p><p><span class="red">Dw:</span> referring to a button or actions for the variation of any value, is intended as "decrease".</p><p><span class="red">Debug:</span> used to locate errors, to solve problems encountered when the program is run.</p><p><span class="red">Decimal:</span> numerical system with base 10, composed of 10 numbers from 0 to 9 inclusive. The "point" in a number with base 10 separates the whole part from the bottom to 1.</p><p><span class="red">Device programmer:</span> it is a tool that "writes" the code in machine language in the PIC or AVR microcontroller.</p><p><span class="red">Directive:</span> instruction intended for the compiler or assembler. It is not a command or a compiler statement.</p><p><span class="red">Emdedded System:</span> device controlled by a program, able to independently perform even complex functions, communicate with other similar devices and different architecture, with the personal computer, with a local network and directly via the web.</p><p><span class="red">EPROM:</span> erasable programmable read only memory.</p><p><span class="red">EEPROM:</span> a type of memory that stores data even in the absence of voltage, can be deleted and rewritten about 100,000 times.</p><p><span class="red">Expression:</span> a variable, constant, or combination that represents a stored or calculated value.</p><p><span class="red">Firmware:</span> program compiled and assembled, suitable to be loaded into the program memory, of a programmable device.</p><p><span class="red">Fosc:</span> oscillator frequency.</p><p><span class="red">f.s.:</span> full scale.</p><p><span class="red">Hex:</span> extension of the assembled file.</p><p><span class="red">IDE:</span> integrated development environment, software environment that acts as a code editor, and controls the various programming tools to implement software development.</p><p><span class="red">Set:</span> write in a register or variable, the condition required by the function to be performed.</p><p><span class="red">I / O:</span> input / output.</p><p><span class="red">Integer:</span> 32-bit variable, whose value varies from -32768 to 32767. Is also a type of variable in GCBASIC.</p><p><span class="red">Interrupt:</span> the use of a predefined signal or condition that interrupts normal execution, in favor of a special procedure with high priority.</p><p><span class="red">Kbit / s:</span> one thousand bits per second.</p><p><span class="red">Keywords:</span> keywords for GCBASIC.</p><p><span class="red">Label:</span> word that marks a position in a program.</p><p><span class="red">Least-significant:</span> in reference to binary numbers, a bit or groups of bits that include the "proper" bit. The rightmost bit or bit group, when a number is written in binary.</p><p><span class="red">Assembly language:</span> the programming language that corresponds more closely with machine language codes.</p><p><span class="red">Voltage levels:</span> in this guide we refer to TTL levels, so about 0 Volts for the low level and about 5 Volts or the Vcc of the microcontroller for the high level.</p><p><span class="red">Level 0:</span> equivalent to the low level.</p><p><span class="red">Level 1:</span> equivalent to the high level.</p><p><span class="red">High level:</span> presence of voltage, referring to the particular one is talking about.</p><p><span class="red">Low level:</span> no voltage, voltage close to zero.</p><p><span class="red">Long:</span> numeric entity composed of 32 binary bits, value from 0 to 4294967295 (2^32-1).Is also a type of variable in GCBASIC.</p><p><span class="red">FLASH MEMORY:</span> non-volatile memory, electrically rewritable numerous times, also called flash / rom.</p><p><span class="red">Microchip:</span> company that produces PIC microcontrollers, now also AVR</p><p><span class="red">Mips:</span> Mega instructions per second.</p><p><span class="red">ms:</span> milliseconds.</p><p><span class="red">Modifier:</span> keyword that somehow changes the interpretation or behavior associated with a command or variable that is written before or after the modifier.</p><p><span class="red">Most-significant:</span> in reference to binary numbers, the bit or group of bits that include the bit that indicates the maximum power of two. The leftmost bit or group of bits when a number is written in binary.</p><p><span class="red">Nibble:</span> a 4-bit binary quantity, can often be used to refer to the 4 most significant or least significant bits of 8-bit bytes. A single hexadecimal digit represents a binary nibble. It is not a variable type in GCBASIC.</p><p><span class="red">ns:</span> nanoseconds.</p><p><span class="red">NC:</span> not connected or, normally closed (depending on the context).</p><p><span class="red">Overflow:</span> the event that occurs when a value in a variable is increased beyond the capacity of the variable type, resulting in an incorrect result.</p><p><span class="red">PC or pc:</span> program counter.</p><p><span class="red">Port:</span> microcontroller port</p><p><span class="red">Porta:</span> Port a.</p><p><span class="red">Portb:</span> Port b.</p><p><span class="red">Portc:</span> Port c.</p><p><span class="red">Portd:</span> Port d.</p><p><span class="red">Porte:</span> Port e.</p><p><span class="red">Pos or pos:</span> postscaler.</p><p><span class="red">Ps or ps:</span> Prescaler</p><p><span class="red">Programmer:</span> you. The person who writes the program.</p><p><span class="red">RAM:</span> the memory area in a PIC MCU that is used to contain the variables. Access to RAM is faster than other memory areas, RAM values &#8203;are lost when the power is turned off.</p><p><span class="red">Register:</span> an 8-bit memory location that performs a special function in a microcontroller. Registers that (Microchip calls SFR) are integrated in the microcontroller and their functions are described in the technical data sheet published for the device.</p><p><span class="red">ROM:</span> Read Only Memory (read-only memory, can only be written once).</p><p><span class="red">Run-time:</span> executed by the microcontroller when the program is executed (when it is running).</p><p><span class="red">Save to context:</span> save and restore in the context of the interrupt, important variables in the SFR registers.</p><p><span class="red">SFR:</span> registers with special function. Able to represent or process negative and positive numbers.</p><p><span class="red">String:</span> able to deal with number, letters and symbols. Is also a type of variable in GCBASIC.</p><p><span class="red">TMR or tmr:</span> timer.</p><p><span class="red">TWI:</span> I&sup2;C Bus.</p><p><span class="red">Two&#8217;complement:</span> (complement of 2) a system that allows negative numbers to be represented in binary.</p><p><span class="red">Typecasting:</span> specify a type of variable for the compiler.</p><p><span class="red">Tp:</span> test point.</p><p><span class="red">Up:</span> referred to a button or actions to change any value, it is intended as "increase".</p><p><span class="red">Underflow:</span> the event that occurs when a value in an unsigned variable decreases below zero (negative number), or when a variable is decreased below the limit value in a negative sense, resulting in an incorrect result.</p><p><span class="red">Unsigned:</span> only able to represent or transform positive numbers. Negative numbers are not valid in integer variables.</p><p><span class="red">Variable:</span> a name that is a synonym of a value that is stored in RAM and can be read and modified during program execution.</p><p><span class="red">Word:</span> a numeric entity composed of 16 binary bits. Value from 0 to 65535 (2^16-1)</p><p><span class="red">V / I:</span> voltage / current.</p><p><span class="red">&micro;s or us:</span> microseconds.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="a_glossary"></span>A Glossary
----------------------------------------

</div>

</div>

</div>

<span class="red">ADC:</span> analogue digital converter.

<span class="red">Negative power supply:</span> reference to the common
point of the circuit power supply, called circuit ground.

<span class="red">Alias:</span> alternative name assigned to a
pre-existing entity.

<span class="red">Array:</span> variable able to handle numbers from 0
to 255.

<span class="red">ASCII:</span> acronym for the American Standard Code
for information interchange. ASCII is a code for the representation of
English characters as numbers.

<span class="red">Assembler:</span> PC software application that
converts assembly language into machine language.

<span class="red">Binary:</span> numeric system with base 2, in which
there are only two possible values for each digit\#0 and 1.

<span class="red">Bit:</span> the smallest element of computer memory.
It is a single digit in a binary number (0 or 1). Bit is also a type of
variable in GCBASIC.

<span class="red">Bitwise:</span> dealing with bits and binary states
instead of numbers or logic.

<span class="red">Byte:</span> 8-bit variable, value from 0 to 255 (2^
8-1). Is also a type of variable in GCBASIC.

<span class="red">Boolean:</span> related to a combinatorial system
designed by George Boole, which combines propositions with the logical
operators AND, OR and IF THEN, except NOT.

<span class="red">CC:</span> direct current.

<span class="red">Machine cycle:</span> oscillator frequency / 4, for
PIC (do not forget the PLL where present).

<span class="red">Code:</span> the memory area in a PIC MCU or AVR that
contains the program code.

<span class="red">Comment:</span> reminder notes placed in the program.

<span class="red">Compiler:</span> PC software application, which
converts a high level language like BASIC into assembly language. In
this guide "Compiler" refers to GCBASIC.

<span class="red">Compile-Time:</span> acts during compilation, and is
not executed as a command when the program is running on the
microcontroller.

<span class="red">Constant:</span> a name that stands for a value
defined in the program. The value is replaced instead of the name when
the program is compiled and assembled. It is not stored in RAM and
cannot be changed during program execution.

<span class="red">D:</span> Digital.

<span class="red">Data Space:</span> is a memory space in a PIC or AVR
that is intended for the storage of values ​​(EEPROM memory on chip).
Data is accessible in GCBASIC using the EpRead and EpWrite commands for
reading and writing.

<span class="red">Dw:</span> referring to a button or actions for the
variation of any value, is intended as "decrease".

<span class="red">Debug:</span> used to locate errors, to solve problems
encountered when the program is run.

<span class="red">Decimal:</span> numerical system with base 10,
composed of 10 numbers from 0 to 9 inclusive. The "point" in a number
with base 10 separates the whole part from the bottom to 1.

<span class="red">Device programmer:</span> it is a tool that "writes"
the code in machine language in the PIC or AVR microcontroller.

<span class="red">Directive:</span> instruction intended for the
compiler or assembler. It is not a command or a compiler statement.

<span class="red">Emdedded System:</span> device controlled by a
program, able to independently perform even complex functions,
communicate with other similar devices and different architecture, with
the personal computer, with a local network and directly via the web.

<span class="red">EPROM:</span> erasable programmable read only memory.

<span class="red">EEPROM:</span> a type of memory that stores data even
in the absence of voltage, can be deleted and rewritten about 100,000
times.

<span class="red">Expression:</span> a variable, constant, or
combination that represents a stored or calculated value.

<span class="red">Firmware:</span> program compiled and assembled,
suitable to be loaded into the program memory, of a programmable device.

<span class="red">Fosc:</span> oscillator frequency.

<span class="red">f.s.:</span> full scale.

<span class="red">Hex:</span> extension of the assembled file.

<span class="red">IDE:</span> integrated development environment,
software environment that acts as a code editor, and controls the
various programming tools to implement software development.

<span class="red">Set:</span> write in a register or variable, the
condition required by the function to be performed.

<span class="red">I / O:</span> input / output.

<span class="red">Integer:</span> 32-bit variable, whose value varies
from -32768 to 32767. Is also a type of variable in GCBASIC.

<span class="red">Interrupt:</span> the use of a predefined signal or
condition that interrupts normal execution, in favor of a special
procedure with high priority.

<span class="red">Kbit / s:</span> one thousand bits per second.

<span class="red">Keywords:</span> keywords for GCBASIC.

<span class="red">Label:</span> word that marks a position in a program.

<span class="red">Least-significant:</span> in reference to binary
numbers, a bit or groups of bits that include the "proper" bit. The
rightmost bit or bit group, when a number is written in binary.

<span class="red">Assembly language:</span> the programming language
that corresponds more closely with machine language codes.

<span class="red">Voltage levels:</span> in this guide we refer to TTL
levels, so about 0 Volts for the low level and about 5 Volts or the Vcc
of the microcontroller for the high level.

<span class="red">Level 0:</span> equivalent to the low level.

<span class="red">Level 1:</span> equivalent to the high level.

<span class="red">High level:</span> presence of voltage, referring to
the particular one is talking about.

<span class="red">Low level:</span> no voltage, voltage close to zero.

<span class="red">Long:</span> numeric entity composed of 32 binary
bits, value from 0 to 4294967295 (2^32-1).Is also a type of variable in
GCBASIC.

<span class="red">FLASH MEMORY:</span> non-volatile memory, electrically
rewritable numerous times, also called flash / rom.

<span class="red">Microchip:</span> company that produces PIC
microcontrollers, now also AVR

<span class="red">Mips:</span> Mega instructions per second.

<span class="red">ms:</span> milliseconds.

<span class="red">Modifier:</span> keyword that somehow changes the
interpretation or behavior associated with a command or variable that is
written before or after the modifier.

<span class="red">Most-significant:</span> in reference to binary
numbers, the bit or group of bits that include the bit that indicates
the maximum power of two. The leftmost bit or group of bits when a
number is written in binary.

<span class="red">Nibble:</span> a 4-bit binary quantity, can often be
used to refer to the 4 most significant or least significant bits of
8-bit bytes. A single hexadecimal digit represents a binary nibble. It
is not a variable type in GCBASIC.

<span class="red">ns:</span> nanoseconds.

<span class="red">NC:</span> not connected or, normally closed
(depending on the context).

<span class="red">Overflow:</span> the event that occurs when a value in
a variable is increased beyond the capacity of the variable type,
resulting in an incorrect result.

<span class="red">PC or pc:</span> program counter.

<span class="red">Port:</span> microcontroller port

<span class="red">Porta:</span> Port a.

<span class="red">Portb:</span> Port b.

<span class="red">Portc:</span> Port c.

<span class="red">Portd:</span> Port d.

<span class="red">Porte:</span> Port e.

<span class="red">Pos or pos:</span> postscaler.

<span class="red">Ps or ps:</span> Prescaler

<span class="red">Programmer:</span> you. The person who writes the
program.

<span class="red">RAM:</span> the memory area in a PIC MCU that is used
to contain the variables. Access to RAM is faster than other memory
areas, RAM values ​are lost when the power is turned off.

<span class="red">Register:</span> an 8-bit memory location that
performs a special function in a microcontroller. Registers that
(Microchip calls SFR) are integrated in the microcontroller and their
functions are described in the technical data sheet published for the
device.

<span class="red">ROM:</span> Read Only Memory (read-only memory, can
only be written once).

<span class="red">Run-time:</span> executed by the microcontroller when
the program is executed (when it is running).

<span class="red">Save to context:</span> save and restore in the
context of the interrupt, important variables in the SFR registers.

<span class="red">SFR:</span> registers with special function. Able to
represent or process negative and positive numbers.

<span class="red">String:</span> able to deal with number, letters and
symbols. Is also a type of variable in GCBASIC.

<span class="red">TMR or tmr:</span> timer.

<span class="red">TWI:</span> I²C Bus.

<span class="red">Two’complement:</span> (complement of 2) a system that
allows negative numbers to be represented in binary.

<span class="red">Typecasting:</span> specify a type of variable for the
compiler.

<span class="red">Tp:</span> test point.

<span class="red">Up:</span> referred to a button or actions to change
any value, it is intended as "increase".

<span class="red">Underflow:</span> the event that occurs when a value
in an unsigned variable decreases below zero (negative number), or when
a variable is decreased below the limit value in a negative sense,
resulting in an incorrect result.

<span class="red">Unsigned:</span> only able to represent or transform
positive numbers. Negative numbers are not valid in integer variables.

<span class="red">Variable:</span> a name that is a synonym of a value
that is stored in RAM and can be read and modified during program
execution.

<span class="red">Word:</span> a numeric entity composed of 16 binary
bits. Value from 0 to 65535 (2^16-1)

<span class="red">V / I:</span> voltage / current.

<span class="red">µs or us:</span> microseconds.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>BcdToDec_GCB</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_alloc.html" title="Alloc"><link rel="next" href="_dectobcd_gcb.html" title="DecToBcd_GCB"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_bcdtodec_gcb"></a>BcdToDec_GCB</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    BcdToDec_GCB ( ByteVariable )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p>Support Bytes only.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Converts numbers from Binary Coded Decimal format to decimal.</p><p>You can add this function. Just add this to your GCBASIC program and then call it when you need it.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    Function BcdToDec(va) as byte
        BcdToDec=(va/16)*10+va%16
    End Function</pre><p><span class="strong"><strong>Also see</strong></span> <a class="link" href="_dectobcd_gcb.html" title="DecToBcd_GCB">DecToBcd_GCB</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="bcdtodec_gcb"></span>BcdToDec\_GCB

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    BcdToDec_GCB ( ByteVariable )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

Support Bytes only.

<span class="strong">**Explanation:**</span>

Converts numbers from Binary Coded Decimal format to decimal.

You can add this function. Just add this to your GCBASIC program and
then call it when you need it.

<span class="strong">**Example:**</span>

``` screen
    Function BcdToDec(va) as byte
        BcdToDec=(va/16)*10+va%16
    End Function
```

<span class="strong">**Also see**</span>
<a href="dectobcd_gcb" class="link" title="DecToBcd_GCB">DecToBcd_GCB</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Bitwise</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_analog_digital_conversion_code_optimisation.html" title="Analog/Digital Conversion Code Optimisation"><link rel="next" href="_bitwise_operations_overview.html" title="Bitwise Operations Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_bitwise"></a>Bitwise</h3></div></div></div><p>This is the Bitwise section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="bitwise"></span>Bitwise

</div>

</div>

</div>

This is the Bitwise section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Bitwise Operations Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_bitwise.html" title="Bitwise"><link rel="prev" href="_bitwise.html" title="Bitwise"><link rel="next" href="_fnlsl.html" title="FnLSL"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_bitwise_operations_overview"></a>Bitwise Operations Overview</h4></div></div></div><p><span class="strong"><strong>About Bitwise Operations</strong></span></p><p>GCBASIC (as with most other microcontroller programming languages) supports bitwise operations.</p><p>Bitwise operations are performed on one or more bit patterns at the level of their individual bits.</p><p>GCBASIC supports the following methods.</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Method</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Meaning</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>Set</p></td><td align="left" valign="top"><p>Assigns a Bit value of On or Off</p></td></tr><tr><td align="left" valign="top"><p>SetWith</p></td><td align="left" valign="top"><p>Evaluates an expression and assigns the result</p></td></tr><tr><td align="left" valign="top"><p>FnLSL</p></td><td align="left" valign="top"><p>Performs a Bitwise LEFT shift</p></td></tr><tr><td align="left" valign="top"><p>FnLSR</p></td><td align="left" valign="top"><p>Performs a Bitwise RIGHT shift</p></td></tr><tr><td align="left" valign="top"><p>Rotate</p></td><td align="left" valign="top"><p>Performs a rotation of a variable of one bit in a specified direction</p></td></tr></tbody></table></div><p><span class="strong"><strong>For more help, see: <a class="link" href="_set.html" title="Set">Set</a>, <a class="link" href="_setwith.html" title="SetWith">SetWith</a>, <a class="link" href="_fnlsl.html" title="FnLSL">FnLSL</a>, <a class="link" href="_fnlsr.html" title="FnLSR">FnLSR</a> and <a class="link" href="_rotate.html" title="Rotate">Rotate</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="bitwise_operations_overview"></span>Bitwise Operations Overview

</div>

</div>

</div>

<span class="strong">**About Bitwise Operations**</span>

GCBASIC (as with most other microcontroller programming languages)
supports bitwise operations.

Bitwise operations are performed on one or more bit patterns at the
level of their individual bits.

GCBASIC supports the following methods.

<div class="informaltable">

| <span class="strong">**Method**</span> | <span class="strong">**Meaning**</span>                               |
|:---------------------------------------|:----------------------------------------------------------------------|
| Set                                    | Assigns a Bit value of On or Off                                      |
| SetWith                                | Evaluates an expression and assigns the result                        |
| FnLSL                                  | Performs a Bitwise LEFT shift                                         |
| FnLSR                                  | Performs a Bitwise RIGHT shift                                        |
| Rotate                                 | Performs a rotation of a variable of one bit in a specified direction |

</div>

<span class="strong">**For more help, see:
<a href="set" class="link" title="Set">Set</a>,
<a href="setwith" class="link" title="SetWith">SetWith</a>,
<a href="fnlsl" class="link" title="FnLSL">FnLSL</a>,
<a href="fnlsr" class="link" title="FnLSR">FnLSR</a> and
<a href="rotate" class="link" title="Rotate">Rotate</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Box</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_uc1601_controllers.html" title="UC1601 Controllers"><link rel="next" href="_circle.html" title="Circle"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_box"></a>Box</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Box(LineX1,LineY1, LineX2, LineY2 [, LineColour ] )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Draws a box on a graphic LCD from the upper corner of pixel position X1, Y1 location to
pixel position X2,Y2 location.</p><p><code class="literal">LineColour</code> can be specified.  Typical the value is 0 or 1 for GLCDForeGround and GLCDBackGround respectively.</p><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_filledbox.html" title="FilledBox">FilledBox</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="box"></span>Box

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Box(LineX1,LineY1, LineX2, LineY2 [, LineColour ] )
```

<span class="strong">**Explanation:**</span>

Draws a box on a graphic LCD from the upper corner of pixel position X1,
Y1 location to pixel position X2,Y2 location.

`LineColour` can be specified. Typical the value is 0 or 1 for
GLCDForeGround and GLCDBackGround respectively.

<span class="strong">**See also**</span>
<a href="filledbox" class="link" title="FilledBox">FilledBox</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ByteToBin</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_asc.html" title="Asc"><link rel="next" href="_chr.html" title="Chr"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_bytetobin"></a>ByteToBin</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>stringvar</em></span> = ByteToBin(<span class="emphasis"><em>bytevar</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">ByteToBin</code> function creates a string of a ANSI (8-byte) characters.
The function converts a number to a string consisting of ones and zeros that represents the binary value.</p><p><span class="strong"><strong>Note:</strong></span>
Supports BYTE variables only.  For WORD variables use <code class="literal">WordToBin</code></p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    string = ByteToBin( 1 )   ' Returns "00000001"

    string = ByteToBin( 254 ) ' Returns "11111110"</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_wordtobin.html" title="WordToBin">WordToBin</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="bytetobin"></span>ByteToBin

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    stringvar = ByteToBin(bytevar)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `ByteToBin` function creates a string of a ANSI (8-byte) characters.
The function converts a number to a string consisting of ones and zeros
that represents the binary value.

<span class="strong">**Note:**</span> Supports BYTE variables only. For
WORD variables use `WordToBin`

<span class="strong">**Example:**</span>

``` screen
    string = ByteToBin( 1 )   ' Returns "00000001"

    string = ByteToBin( 254 ) ' Returns "11111110"
```

<span class="strong">**For more help, see**</span>
<a href="wordtobin" class="link" title="WordToBin">WordToBin</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Changes</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_pic_users_and_beginners_start_here.html" title="PIC users and Beginners: Start Here"><link rel="next" href="_command_line_parameters.html" title="Command Line Parameters"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_changes"></a>Changes</h2></div></div></div><p><span class="strong"><strong>Formal Release of GCBASIC Compiler v1.xx.xx</strong></span></p><p><br></p><div class="informaltable"><table border="1" width="60%"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Reference</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Time Stamp</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>ASCIIDOCs rendered</p></td><td align="center" valign="top"><p>2024-01-25<br>
09:11:02 GMT Standard Time</p></td></tr><tr><td align="center" valign="top"><p>Master ToC information</p></td><td align="center" valign="top"><p>2023-12-28<br>
11:44:57 GMT Standard Time</p></td></tr></tbody></table></div><p><br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="changes"></span>Changes
----------------------------------

</div>

</div>

</div>

<span class="strong">**Formal Release of GCBASIC Compiler
v1.xx.xx**</span>

  

<div class="informaltable">

<table data-border="1" width="60%">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Reference</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Time Stamp</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>ASCIIDOCs rendered</p></td>
<td style="text-align: center;"><p>2024-01-25<br />
09:11:02 GMT Standard Time</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>Master ToC information</p></td>
<td style="text-align: center;"><p>2023-12-28<br />
11:44:57 GMT Standard Time</p></td>
</tr>
</tbody>
</table>

</div>

  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chr</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_bytetobin.html" title="ByteToBin"><link rel="next" href="_fill.html" title="Fill"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_chr"></a>Chr</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>stringvar</em></span> = CHR(<span class="emphasis"><em>bytevar</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">CHR</code> function creates a string of a ANSI (1-byte) character.</p><p><code class="literal">ASC</code> is the natural complement of <code class="literal">CHR</code>.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    <span class="emphasis"><em>string</em></span> = CHR( 65 )   ' Returns "A"

    <span class="emphasis"><em>string</em></span> = CHR( 66 )   ' Returns "B"</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_asc.html" title="Asc">Asc</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="chr"></span>Chr

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    stringvar = CHR(bytevar)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `CHR` function creates a string of a ANSI (1-byte) character.

`ASC` is the natural complement of `CHR`.

<span class="strong">**Example:**</span>

``` screen
    string = CHR( 65 )   ' Returns "A"

    string = CHR( 66 )   ' Returns "B"
```

<span class="strong">**For more help, see**</span>
<a href="asc" class="link" title="Asc">Asc</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Circle</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_box.html" title="Box"><link rel="next" href="_ellipse.html" title="Ellipse"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_circle"></a>Circle</h4></div></div></div><p><span class="strong"><strong>Circle:</strong></span></p><pre class="screen">    Circle(XPixelPosition, YPixelPosition, Radius [ [,Optional LineColour] [,Optional Rounding] ] )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Draws a circle on a GLCD at <code class="literal">XPixelPosition</code>, <code class="literal">YPixelPosition</code> with a specific <code class="literal">Radius</code>.</p><p>The constant <code class="literal">GLCD_PROTECTOVERRUN</code> can be added to prevent circles from
re-drawing at the screen edges. Ensure the <code class="literal">GLCD_Width</code> and <code class="literal">GLCD_HEIGHT</code>
constants are set correctly when using this additional constant.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #include &lt;glcd.h&gt;

    circle(10,10,10)  ;upper left
    circle(117,10,10) ;upper right
    circle(63,31,10)  ;center
    circle(63,31,20)  ;center
    circle(10,53,10)  ;lower left
    circle(117,53,10) ;lower right</pre><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/circleb1.PNG" align="middle" alt="graphic"></div></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="circle"></span>Circle

</div>

</div>

</div>

<span class="strong">**Circle:**</span>

``` screen
    Circle(XPixelPosition, YPixelPosition, Radius [ [,Optional LineColour] [,Optional Rounding] ] )
```

<span class="strong">**Explanation:**</span>

Draws a circle on a GLCD at `XPixelPosition`, `YPixelPosition` with a
specific `Radius`.

The constant `GLCD_PROTECTOVERRUN` can be added to prevent circles from
re-drawing at the screen edges. Ensure the `GLCD_Width` and
`GLCD_HEIGHT` constants are set correctly when using this additional
constant.

<span class="strong">**Example:**</span>

``` screen
    #include <glcd.h>

    circle(10,10,10)  ;upper left
    circle(117,10,10) ;upper right
    circle(63,31,10)  ;center
    circle(63,31,20)  ;center
    circle(10,53,10)  ;lower left
    circle(117,53,10) ;lower right
```

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/circleb1.PNG)

</div>

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ClearTimer</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_timer_overview.html" title="Timer Overview"><link rel="next" href="_inittimer0.html" title="InitTimer0"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_cleartimer"></a>ClearTimer</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ClearTimer <span class="emphasis"><em>TimerNo</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip PIC and Atmel AVR microcontrollers with built in timer modules.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">ClearTimer</code> is used to clear the specified timer to a value of 0.</p><p><code class="literal">Cleartimer</code> can be used on-the-fly if desired, so there is no requirement to
stop the timer first.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    .....
    'Clear timer 1
    ClearTimer 1
    .....</pre><p><span class="strong"><strong>See also, <a class="link" href="_inittimer1.html" title="InitTimer1">InitTimer1</a></strong></span> article for an example.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="cleartimer"></span>ClearTimer

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ClearTimer TimerNo
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip PIC and Atmel AVR microcontrollers with built
in timer modules.

<span class="strong">**Explanation:**</span>

`ClearTimer` is used to clear the specified timer to a value of 0.

`Cleartimer` can be used on-the-fly if desired, so there is no
requirement to stop the timer first.

<span class="strong">**Example:**</span>

``` screen
    .....
    'Clear timer 1
    ClearTimer 1
    .....
```

<span class="strong">**See also,
<a href="inittimer1" class="link" title="InitTimer1">InitTimer1</a>**</span>
article for an example.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>CLS</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_lcd_width.html" title="LCD_WIDTH"><link rel="next" href="_get.html" title="Get"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_cls"></a>CLS</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    CLS</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">CLS</code> command clears the contents of the LCD, and returns the cursor
to the top left corner of the screen</p><p><span class="strong"><strong>Example :</strong></span></p><pre class="screen">        'A Flashing text "Hello World" program for GCBASIC

        'General hardware configuration
        #chip 16F877A, 20

        'LCD connection settings
        #define LCD_IO 8
        #define LCD_DATA_PORT PORTC
        #define LCD_RS PORTD.0
        #define LCD_RW PORTD.1
        #define LCD_Enable PORTD.2
        #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width


        'Main routine
        Do
            Print "Hello World"
            Wait 1 sec
            CLS
            Wait 1 sec
        Loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_lcd_overview.html" title="LCD Overview">LCD Overview</a></p><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="cls"></span>CLS

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    CLS
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `CLS` command clears the contents of the LCD, and returns the cursor
to the top left corner of the screen

<span class="strong">**Example :**</span>

``` screen
        'A Flashing text "Hello World" program for GCBASIC

        'General hardware configuration
        #chip 16F877A, 20

        'LCD connection settings
        #define LCD_IO 8
        #define LCD_DATA_PORT PORTC
        #define LCD_RS PORTD.0
        #define LCD_RW PORTD.1
        #define LCD_Enable PORTD.2
        #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width


        'Main routine
        Do
            Print "Hello World"
            Wait 1 sec
            CLS
            Wait 1 sec
        Loop
```

<span class="strong">**For more help, see**</span>
<a href="lcd_overview" class="link" title="LCD Overview">LCD Overview</a>

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Code Documentation</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_gcbasic.html" title="Graphical GCBASIC"><link rel="prev" href="_graphical_gcbasic.html" title="Graphical GCBASIC"><link rel="next" href="_windows_net_support.html" title="Windows .NET Support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_code_documentation"></a>Code Documentation</h3></div></div></div><p>Documenting GCBASIC is key for ease of use. This section is intended for developers only.</p><p>Documenting is the ability to read some extra information from comments in libraries.</p><p>Some comments that start with ''' have a special meaning, and will be displayed as tooltips or as information to the user. These tooltips helps inexperienced users to use extra libraries.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">GCBASIC uses ; (a semicolon) to show comments that it has placed automatically, and // or ' to indicate ones that the user has placed.  When loading a program, it will not load any that start with a ; (semi-colon).  The use of comments do not impact the users  but it worthy of note.</li><li class="listitem">As for code documentation comments, GCBASIC will load information about subroutines/functions and any hardware settings that need to be set.</li><li class="listitem">For subroutines, a line before the Sub or Function line that starts with ''' will be used as a tooltip when the user hovers over the icon. A line that starts with '''@ will be interpreted differently, depending on what comes after the @. '''@param ParamName Parameter Description will add a description for the parameter. For a subroutine, this will show in the Icon Settings panel under the parameter when the user has selected that icon.</li><li class="listitem">For functions, it will show at the appropriate time in the Parameter Editor wizard. '''@return Returned value applies to functions only. It will be displayed in the Parameter Editor wizard when the user is asked to choose a function.  An example of all this is given in srf04.h:</li></ol></div><pre class="screen">    '''Read the distance to the nearest object
    '''@param US_Sensor Sensor to read (1 to 4)
    '''@return Distance in cm
    Function USDistance(US_Sensor) As Word</pre><div class="orderedlist"><ol class="orderedlist" start="5" type="1"><li class="listitem">If a subroutine or command is used internally in the library, but GCBASIC users should not see it, it can be hidden by placing '''@hide before the Sub or Function line. Another example from srf04.h:</li></ol></div><pre class="screen">    '''@hide
    Sub InitUSSensor</pre><p>These should hopefully be pretty easy to add. It is also possible to add Hardware Settings. A particular setting can be defined anywhere in the file, using this syntax:</p><pre class="screen">    '''@hardware condition, display name, constant, value type</pre><p>These comments informs GCBASIC when to show the setting. Normally, this is All, but sometimes it can include a constant, a space and then a comma separated list of values. display name is a friendly name for the setting to display. constant is the constant that must be set, and valuetype is the type that will be accepted for that constant&#8217;s value. To allow for multiple value types, enter a list of types with a | between them.</p><div class="orderedlist"><ol class="orderedlist" start="6" type="1"><li class="listitem">Allowed types are:</li></ol></div><pre class="screen">    free - Allows anything
    label - Allows any label
    condition - Allows a condition
    table - Allows a data table
    bit - Allows any bit from variable, or bit variable
    io_pin - Allows an IO pin
    io_port - Allows an entire IO port
    number - Allows any fixed number or variable
    rangex:y - Allows any number between x and y
    var - Allows any variable
    var_byte - Allows any byte variable
    var_word - Allows any word variable
    var_integer - Allows any integer variable
    var_string - Allows any string variable
    const - Allows any fixed number
    const_byte - Allows any byte sized fixed number
    const_word - Allows any word sized fixed number
    const_integer - Allows any integer sized fixed number
    const_string - Allows any fixed string
    byte - Allows any byte (fixed number or variable)
    word - Allows any word
    integer - Allows any integer
    string - Allows any string
    array - Allows any array</pre><div class="orderedlist"><ol class="orderedlist" start="7" type="1"><li class="listitem">When the library is added the program, GCBASIC will show a new device with the name of the library file on the Hardware Settings window. The user can then set the relevant constants without necessarily needing to see any code.  Adding a GCBASIC library to GCBASIC will not result in any changes to the library. GCBASIC uses the information it reads to help edit the user&#8217;s program, but then the user&#8217;s program is passed to the compiler along with the unchanged library.</li><li class="listitem">Hardware Settings are a bit more involved to add, but hopefully the bit of extra documentation for subroutines will be straight forward.</li></ol></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="code_documentation"></span>Code Documentation

</div>

</div>

</div>

Documenting GCBASIC is key for ease of use. This section is intended for
developers only.

Documenting is the ability to read some extra information from comments
in libraries.

Some comments that start with ''' have a special meaning, and will be
displayed as tooltips or as information to the user. These tooltips
helps inexperienced users to use extra libraries.

<div class="orderedlist">

1.  GCBASIC uses ; (a semicolon) to show comments that it has placed
    automatically, and // or ' to indicate ones that the user has
    placed. When loading a program, it will not load any that start with
    a ; (semi-colon). The use of comments do not impact the users but it
    worthy of note.
2.  As for code documentation comments, GCBASIC will load information
    about subroutines/functions and any hardware settings that need to
    be set.
3.  For subroutines, a line before the Sub or Function line that starts
    with ''' will be used as a tooltip when the user hovers over the
    icon. A line that starts with '''@ will be interpreted differently,
    depending on what comes after the @. '''@param ParamName Parameter
    Description will add a description for the parameter. For a
    subroutine, this will show in the Icon Settings panel under the
    parameter when the user has selected that icon.
4.  For functions, it will show at the appropriate time in the Parameter
    Editor wizard. '''@return Returned value applies to functions only.
    It will be displayed in the Parameter Editor wizard when the user is
    asked to choose a function. An example of all this is given in
    srf04.h:

</div>

``` screen
    '''Read the distance to the nearest object
    '''@param US_Sensor Sensor to read (1 to 4)
    '''@return Distance in cm
    Function USDistance(US_Sensor) As Word
```

<div class="orderedlist">

1.  If a subroutine or command is used internally in the library, but
    GCBASIC users should not see it, it can be hidden by placing
    '''@hide before the Sub or Function line. Another example from
    srf04.h:

</div>

``` screen
    '''@hide
    Sub InitUSSensor
```

These should hopefully be pretty easy to add. It is also possible to add
Hardware Settings. A particular setting can be defined anywhere in the
file, using this syntax:

``` screen
    '''@hardware condition, display name, constant, value type
```

These comments informs GCBASIC when to show the setting. Normally, this
is All, but sometimes it can include a constant, a space and then a
comma separated list of values. display name is a friendly name for the
setting to display. constant is the constant that must be set, and
valuetype is the type that will be accepted for that constant’s value.
To allow for multiple value types, enter a list of types with a \|
between them.

<div class="orderedlist">

1.  Allowed types are:

</div>

``` screen
    free - Allows anything
    label - Allows any label
    condition - Allows a condition
    table - Allows a data table
    bit - Allows any bit from variable, or bit variable
    io_pin - Allows an IO pin
    io_port - Allows an entire IO port
    number - Allows any fixed number or variable
    rangex:y - Allows any number between x and y
    var - Allows any variable
    var_byte - Allows any byte variable
    var_word - Allows any word variable
    var_integer - Allows any integer variable
    var_string - Allows any string variable
    const - Allows any fixed number
    const_byte - Allows any byte sized fixed number
    const_word - Allows any word sized fixed number
    const_integer - Allows any integer sized fixed number
    const_string - Allows any fixed string
    byte - Allows any byte (fixed number or variable)
    word - Allows any word
    integer - Allows any integer
    string - Allows any string
    array - Allows any array
```

<div class="orderedlist">

1.  When the library is added the program, GCBASIC will show a new
    device with the name of the library file on the Hardware Settings
    window. The user can then set the relevant constants without
    necessarily needing to see any code. Adding a GCBASIC library to
    GCBASIC will not result in any changes to the library. GCBASIC uses
    the information it reads to help edit the user’s program, but then
    the user’s program is passed to the compiler along with the
    unchanged library.
2.  Hardware Settings are a bit more involved to add, but hopefully the
    bit of extra documentation for subroutines will be straight forward.

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Command Line Parameters</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_changes.html" title="Changes"><link rel="next" href="_frequent_errors.html" title="Frequent errors"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_command_line_parameters"></a>Command Line Parameters</h2></div></div></div><p><span class="strong"><strong>About the Command Line Parameters</strong></span></p><pre class="screen">    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/H:[Y/1 | N/0]] [/V] [/L] [/NP] [/M:[Y/1 | N/0]]  <span class="emphasis"><em>filename</em></span>

    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/H:[Y/1 | N/0]] [/V] [/L] [/WX] [/M:[Y/1 | N/0]] [/NP] <span class="emphasis"><em>filename</em></span>

    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/H:[Y/1 | N/0]] [/V] [/L] [/WX] [/M:[Y/1 | N/0]] [/S:Use.ini] [/NP] <span class="emphasis"><em>filename</em></span>

    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/H:[Y/1 | N/0]] [/V] [/L] [/WX] [/M:[Y/1 | N/0]]  [/S:Use.ini] [/F[O]] [/NP] <span class="emphasis"><em>filename</em></span>

    GCBASIC /version</pre><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Switch</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Description</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">/O:<span class="emphasis"><em>filename</em></span></code></p></td><td align="left" valign="top"><p>Sets the name of the assembly file generated to <code class="literal"><span class="emphasis"><em>filename</em></span></code>.</p></td><td align="left" valign="top"><p>Same name as the input file, but with a <code class="literal">.asm</code> extension.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">/A:assembler</code></p></td><td align="left" valign="top"><p>Batch file used to call assembler<sup>(1)</sup>. If <code class="literal">/A:GCASM</code> is given, GCBASIC will use its internal assembler.</p></td><td align="left" valign="top"><p>The program will not be assembled</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">/CP</code></p></td><td align="left" valign="top"><p>Exports the config bits automatically selected by the compiler to an output file called <code class="literal">source_filename.config</code>.  The output file is the source filename with the extension of config.</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">/H:[Y/1 | N/0]</code></p></td><td align="left" valign="top"><p>Set the production, or not, of the hex output file.  /H:1 is the default.  To prevent production of the hex output file - use /H:0</p></td><td align="left" valign="top"><p>The default is to produce the hex output file</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">/M:[Y/1 | N/0]</code></p></td><td align="left" valign="top"><p>Mute the banner messages, or not.  /M:1 is the default.  To prevent banner messages - use /M:0</p></td><td align="left" valign="top"><p>The default is to output banner messages</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">/P:programmer</code></p></td><td align="left" valign="top"><p>Batch file used to call programmer<sup>(1)</sup>. This parameter is ignored if the program is not assembled.</p></td><td align="left" valign="top"><p>The program will not be downloaded.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">/K:[C|A]</code></p></td><td align="left" valign="top"><p>Keep original code in assembly output. <code class="literal">/K:C</code> will save comments, <code class="literal">/K:A</code> will preserve all input code.</p></td><td align="left" valign="top"><p>No original code left in output.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">/V[:[0|F][1|T]</code></p></td><td align="left" valign="top"><p>Verbose mode - compiler gives more detailed information about its activities.
/Vx will overide any configuration in the user ini file.</p></td><td align="left" valign="top"><p>-</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">/L</code></p></td><td align="left" valign="top"><p>Show license and exit.</p></td><td align="left" valign="top"><p>-</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">/NP</code></p></td><td align="left" valign="top"><p>Do not pause on errors. Use with IDEs.</p></td><td align="left" valign="top"><p>Pause when an error occurs, and wait for the user to press a key.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">/WX</code></p></td><td align="left" valign="top"><p>Force compiler to ensure all include files are valid.</p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">/version</code></p></td><td align="left" valign="top"><p>Shown build date and version of the compiler.</p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">/S:fsp</code></p></td><td align="left" valign="top"><p>Load the settings from a specified file, rather than use the defaults.</p></td><td align="left" valign="top"><p>/S:use.ini</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">/F[:[0|F][1|T]</code></p></td><td align="left" valign="top"><p>Used to bypass compilation when not needed, compiler will verify that config settings in the already compiled file match those required for the programmer. If not, a recompilation will be forced.
 Skip compilation if the hex file is up to date and has correct config.
/F:x ( F or 0) to force a fresh compile regardless of what ini specifies.</p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">/FO</code></p></td><td align="left" valign="top"><p>Used to bypass compilation and program only.  Compiler will verify that config settings in the already compiled file match those required for the programmer. If not, a recompilation will be forced.</p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">filename</code></p></td><td align="left" valign="top"><p>The file to compile.</p></td><td align="left" valign="top"><p>-</p></td></tr></tbody></table></div><p><span class="small"><sup>(1)</sup> For the <code class="literal">/A:</code> and <code class="literal">/P:</code> switches, there are special options available. If
<code class="literal">%FILENAME%</code> is present, it will be replaced by the name of the <code class="literal">.asm</code> file.
<code class="literal">%FN_NOEXT%</code> will be replaced by the name of the <code class="literal">.asm</code> file but without an
extension, and <code class="literal">%CHIPMODEL%</code> will be replaced with the name of the chip.
The name of the chip will be the same as that on the chip data file.</span></p><p>A batch file to load the <code class="literal">ASM</code> from GCBASIC into <code class="literal">MPASM</code>. Command line should be like this:</p><pre class="screen">    C:\progra~1\microc~1\mpasms~1\MPASMWIN /c- /o- /q+ /l- /x- /w1 %code%.asm</pre><p>A batch file to compile in GCBASIC then load the <code class="literal">ASM</code> from GCBASIC into <code class="literal">GPASM</code>. Command line should be like this:</p><pre class="screen">    gcbasic.exe %1 /NP /K:A /A:"..\gputils\bin\gpasm.exe %~d1%~p1%~n1.asm"</pre><p>To instruct MAKEHEX.BAT to use <code class="literal">GPASM</code>.   You have GPUTILS installed.  The batch file should be edited as follows:</p><pre class="screen">    REM Create the ASM
    gcbasic.exe /NP /K:A %1
    REM Use GPASM piping to the GCB error log
    gpasm.exe "%~d1%~p1%~n1.asm" -k -i -w1 &gt;&gt; errors.txt</pre><p>To summarise, you can use any of the following:</p><pre class="screen">    gcbasic.exe filetocompile.gcb /A:GCASM /P:"icprog -L%FILENAME%" /V /O:compiled.asm</pre><p>GCBASIC will compile the file, then assemble the program, and run this command:</p><pre class="screen">    `icprog -Lcompiled.hex`</pre><p>You can also create/edit the gcbasic.ini file :</p><pre class="screen">    'Assembler settings
    Assembler = C:\Program Files\Microchip\MPASM Suite\mpasmwin
    AssemblerParams = /c- /o- /q+ /l+ /x- /w1 "%FileName%"

    'Programmer settings
    Programmer = C:\Program Files\WinPic\Winpic.exe
    ProgrammerParams = /device=PIC%ChipModel% /p "%FileName%"</pre><p>This example will use MPASM to assemble the program. It will run the program specified in the assembler = line, and give it these parameters:</p><pre class="screen">    `/c- /o- /q+ /l+ /x- /w1 "compiled.asm"`</pre><p>Then, it will run the programmer, and give it these parameters when it calls it:</p><pre class="screen">    `/device=PIC16F88 /p "compiled.hex"`</pre><p><code class="literal">%ChipModel%</code> will get replaced with the chip you are using, so this the chip GCBASIC will pass to WinPIC.</p><p><span class="strong"><strong>Errors.txt</strong></span></p><p>The compiler only produces the file errors.txt if there is an error. The creation of the errors.txt file makes it easier for IDEs to detect if the program compiled successfully - if the file was not produced then the IDE would be unalbe to present the error message to the user.</p><p>The file error.txt is always produced in the same folder as the compiler.  Typically: C:\GCStudio\GCBASIC\Errors.txt</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="command_line_parameters"></span>Command Line Parameters
------------------------------------------------------------------

</div>

</div>

</div>

<span class="strong">**About the Command Line Parameters**</span>

``` screen
    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/H:[Y/1 | N/0]] [/V] [/L] [/NP] [/M:[Y/1 | N/0]]  filename

    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/H:[Y/1 | N/0]] [/V] [/L] [/WX] [/M:[Y/1 | N/0]] [/NP] filename

    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/H:[Y/1 | N/0]] [/V] [/L] [/WX] [/M:[Y/1 | N/0]] [/S:Use.ini] [/NP] filename

    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/H:[Y/1 | N/0]] [/V] [/L] [/WX] [/M:[Y/1 | N/0]]  [/S:Use.ini] [/F[O]] [/NP] filename

    GCBASIC /version
```

<div class="informaltable">

| <span class="strong">**Switch**</span> | <span class="strong">**Description**</span>                                                                                                                                                                                                                                                                                                          | <span class="strong">**Default**</span>                           |
|:---------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------|
| `/O:filename`                          | Sets the name of the assembly file generated to `filename`.                                                                                                                                                                                                                                                                                          | Same name as the input file, but with a `.asm` extension.         |
| `/A:assembler`                         | Batch file used to call assembler<sup>(1)</sup>. If `/A:GCASM` is given, GCBASIC will use its internal assembler.                                                                                                                                                                                                                                    | The program will not be assembled                                 |
| `/CP`                                  | Exports the config bits automatically selected by the compiler to an output file called `source_filename.config`. The output file is the source filename with the extension of config.                                                                                                                                                               | None                                                              |
| `/H:[Y/1 | N/0]`                       | Set the production, or not, of the hex output file. /H:1 is the default. To prevent production of the hex output file - use /H:0                                                                                                                                                                                                                     | The default is to produce the hex output file                     |
| `/M:[Y/1 | N/0]`                       | Mute the banner messages, or not. /M:1 is the default. To prevent banner messages - use /M:0                                                                                                                                                                                                                                                         | The default is to output banner messages                          |
| `/P:programmer`                        | Batch file used to call programmer<sup>(1)</sup>. This parameter is ignored if the program is not assembled.                                                                                                                                                                                                                                         | The program will not be downloaded.                               |
| `/K:[C|A]`                             | Keep original code in assembly output. `/K:C` will save comments, `/K:A` will preserve all input code.                                                                                                                                                                                                                                               | No original code left in output.                                  |
| `/V[:[0|F][1|T]`                       | Verbose mode - compiler gives more detailed information about its activities. /Vx will overide any configuration in the user ini file.                                                                                                                                                                                                               | \-                                                                |
| `/L`                                   | Show license and exit.                                                                                                                                                                                                                                                                                                                               | \-                                                                |
| `/NP`                                  | Do not pause on errors. Use with IDEs.                                                                                                                                                                                                                                                                                                               | Pause when an error occurs, and wait for the user to press a key. |
| `/WX`                                  | Force compiler to ensure all include files are valid.                                                                                                                                                                                                                                                                                                |                                                                   |
| `/version`                             | Shown build date and version of the compiler.                                                                                                                                                                                                                                                                                                        |                                                                   |
| `/S:fsp`                               | Load the settings from a specified file, rather than use the defaults.                                                                                                                                                                                                                                                                               | /S:use.ini                                                        |
| `/F[:[0|F][1|T]`                       | Used to bypass compilation when not needed, compiler will verify that config settings in the already compiled file match those required for the programmer. If not, a recompilation will be forced. Skip compilation if the hex file is up to date and has correct config. /F:x ( F or 0) to force a fresh compile regardless of what ini specifies. |                                                                   |
| `/FO`                                  | Used to bypass compilation and program only. Compiler will verify that config settings in the already compiled file match those required for the programmer. If not, a recompilation will be forced.                                                                                                                                                 |                                                                   |
| `filename`                             | The file to compile.                                                                                                                                                                                                                                                                                                                                 | \-                                                                |

</div>

<span class="small"><sup>(1)</sup> For the `/A:` and `/P:` switches,
there are special options available. If `%FILENAME%` is present, it will
be replaced by the name of the `.asm` file. `%FN_NOEXT%` will be
replaced by the name of the `.asm` file but without an extension, and
`%CHIPMODEL%` will be replaced with the name of the chip. The name of
the chip will be the same as that on the chip data file.</span>

A batch file to load the `ASM` from GCBASIC into `MPASM`. Command line
should be like this:

``` screen
    C:\progra~1\microc~1\mpasms~1\MPASMWIN /c- /o- /q+ /l- /x- /w1 %code%.asm
```

A batch file to compile in GCBASIC then load the `ASM` from GCBASIC into
`GPASM`. Command line should be like this:

``` screen
    gcbasic.exe %1 /NP /K:A /A:"..\gputils\bin\gpasm.exe %~d1%~p1%~n1.asm"
```

To instruct MAKEHEX.BAT to use `GPASM`. You have GPUTILS installed. The
batch file should be edited as follows:

``` screen
    REM Create the ASM
    gcbasic.exe /NP /K:A %1
    REM Use GPASM piping to the GCB error log
    gpasm.exe "%~d1%~p1%~n1.asm" -k -i -w1 >> errors.txt
```

To summarise, you can use any of the following:

``` screen
    gcbasic.exe filetocompile.gcb /A:GCASM /P:"icprog -L%FILENAME%" /V /O:compiled.asm
```

GCBASIC will compile the file, then assemble the program, and run this
command:

``` screen
    `icprog -Lcompiled.hex`
```

You can also create/edit the gcbasic.ini file :

``` screen
    'Assembler settings
    Assembler = C:\Program Files\Microchip\MPASM Suite\mpasmwin
    AssemblerParams = /c- /o- /q+ /l+ /x- /w1 "%FileName%"

    'Programmer settings
    Programmer = C:\Program Files\WinPic\Winpic.exe
    ProgrammerParams = /device=PIC%ChipModel% /p "%FileName%"
```

This example will use MPASM to assemble the program. It will run the
program specified in the assembler = line, and give it these parameters:

``` screen
    `/c- /o- /q+ /l+ /x- /w1 "compiled.asm"`
```

Then, it will run the programmer, and give it these parameters when it
calls it:

``` screen
    `/device=PIC16F88 /p "compiled.hex"`
```

`%ChipModel%` will get replaced with the chip you are using, so this the
chip GCBASIC will pass to WinPIC.

<span class="strong">**Errors.txt**</span>

The compiler only produces the file errors.txt if there is an error. The
creation of the errors.txt file makes it easier for IDEs to detect if
the program compiled successfully - if the file was not produced then
the IDE would be unalbe to present the error message to the user.

The file error.txt is always produced in the same folder as the
compiler. Typically: C:\\GCStudio\\GCBASIC\\Errors.txt

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Command References</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_converters.html" title="Converters"><link rel="next" href="_analog_digital_conversion.html" title="Analog/Digital conversion"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_command_references"></a>Command References</h2></div></div></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="command_references"></span>Command References
--------------------------------------------------------

</div>

</div>

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Comments</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_arrays.html" title="Arrays"><link rel="next" href="_line_continuation.html" title="Line Continuation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_comments"></a>Comments</h3></div></div></div><p><span class="strong"><strong>About Comments</strong></span></p><p>Adding comments to your GCBASIC program can be done using a number of methods. &nbsp;&nbsp;
Explanatory notes embedded within the code.&nbsp;&nbsp;
Comments are used to remind yourself and to inform others about the function of your program.&nbsp;&nbsp;
Comments are ignored by the compiler</p><p>You can comment out sections of code if you want just by placing an apostrophe at
the beginning of each line. The GCBASIC IDE has a feature to do this automatically.
<br>
<br>
You can also use a REM (for REMark statement), a semi-colon or two forward slashes.
<br>
<br>
Multiline comments are support for large text descriptions of code or to comment out chunks of code while debugging applications.</p><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    /*
      block comment
    */</pre><p>Warning: Graphical GCBASIC uses semi-colons to mark comments that it has
inserted automatically. It does not read these comments when opening a file, so any
comments in a GCBASIC program starting with a semi-colon will be deleted if the
program is opened using Graphical GCBASIC.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    ' The number of pins to flash
    #define FlashPins 2

    REM You can create a header using an apostrophe before each line
    REM This is a great way to describe your program
    REM You can also use it to describe the hardware connections.

    ' You can place comments above the command or on the same line
    Dir PORTB Out ' Initialise PORTB to all Outputs

    ; The Main loop
    do
    PORTB = 0 ' All Pins off
    Wait 1 S ' Delay 1 second
    PORTB = 0xFF ' All pins on
    Wait 1 s ' Delay 1 second
    Loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="comments"></span>Comments

</div>

</div>

</div>

<span class="strong">**About Comments**</span>

Adding comments to your GCBASIC program can be done using a number of
methods.    Explanatory notes embedded within the code.   Comments are
used to remind yourself and to inform others about the function of your
program.   Comments are ignored by the compiler

You can comment out sections of code if you want just by placing an
apostrophe at the beginning of each line. The GCBASIC IDE has a feature
to do this automatically.  
  
You can also use a REM (for REMark statement), a semi-colon or two
forward slashes.  
  
Multiline comments are support for large text descriptions of code or to
comment out chunks of code while debugging applications.

<span class="strong">**Syntax:**</span>

``` screen
    /*
      block comment
    */
```

Warning: Graphical GCBASIC uses semi-colons to mark comments that it has
inserted automatically. It does not read these comments when opening a
file, so any comments in a GCBASIC program starting with a semi-colon
will be deleted if the program is opened using Graphical GCBASIC.

<span class="strong">**Example:**</span>

``` screen
    ' The number of pins to flash
    #define FlashPins 2

    REM You can create a header using an apostrophe before each line
    REM This is a great way to describe your program
    REM You can also use it to describe the hardware connections.

    ' You can place comments above the command or on the same line
    Dir PORTB Out ' Initialise PORTB to all Outputs

    ; The Main loop
    do
    PORTB = 0 ' All Pins off
    Wait 1 S ' Delay 1 second
    PORTB = 0xFF ' All pins on
    Wait 1 s ' Delay 1 second
    Loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Common Anode</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_legacy.html" title="7 Segment Displays - Legacy"><link rel="prev" href="_common_cathode.html" title="Common Cathode"><link rel="next" href="_displayvalue.html" title="DisplayValue"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_common_anode"></a>Common Anode</h6></div></div></div><p>This is a Common Anode 7 Segment display example.</p><p>Additional configuration is required when using Common Anode.</p><p>When setting up the 7 segment Common Anode display you <span class="strong"><strong>MUST</strong></span> use the
<code class="literal">7Seg_CommonAnode</code> constant. You can optionally use the <code class="literal">7Seg_HighSide</code>
constant to support PFET or PNP high side driving of the Common Anode
displays as follows:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Comment</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">7Seg_CommonAnode</code></p></td><td align="left" valign="top"><p>Inverts controls for Common Anode displays</p></td><td align="left" valign="top"><p>Required for Common Cathode displays</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">7Seg_HighSide</code></p></td><td align="left" valign="top"><p>Support PFET or PNP high side driving of the display</p></td><td align="left" valign="top"><p>Inverts Common Cathode addressing pin logic for multiplexed displays</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'A Common Anode 7 Segment display example using bs250p pfets
    'Chip model
    #chip 16f1783,8

    'support for Common Cathode
    #define 7Seg_CommonAnode

    'support for pfet or pnp high side drivers
    #define 7Seg_HighSide

    #define DISP_SEG_A PORTC.0
    #define DISP_SEG_B PORTC.1
    #define DISP_SEG_C PORTC.2
    #define DISP_SEG_D PORTC.3
    #define DISP_SEG_E PORTC.4
    #define DISP_SEG_F PORTC.5
    #define DISP_SEG_G PORTC.6
	#define DISP_SEG_DOT PORTC.7

    #define Disp_Sel_1 PortA.1
    #define Disp_Sel_2 PortA.2
    #define Disp_Sel_3 PortA.3

    dim count as word
    dim number as word

    Do Forever
      For count = 0 to 999
          number = count
          Num2 = 0
          Num3 = 0
          If number &gt;= 100 Then
            Num3 = number / 100
            'SysCalcTempX is the remainder after a division has been completed
            number = SysCalcTempX
          End if
          If number &gt;= 10 Then
            Num2 = number / 10
            number = SysCalcTempX
          end if
          Num1 = number
          Repeat 10
            DisplayValue 1, Num1, 1 'Optional third parameter turns on the dp on that digit
            wait 5 ms
            DisplayValue 2, Num2
            wait 5 ms
            DisplayValue 3, Num3
            wait 5 ms
           end Repeat
      Next
    Loop</pre><p><span class="strong"><strong>Also, see</strong></span>
<a class="link" href="_7_segment_displays_overview.html" title="7 Segment Displays Overview">7 Degment Display Overview</a>,
<a class="link" href="_displaychar.html" title="DisplayChar">DisplayChar</a>, <a class="link" href="_displayvalue.html" title="DisplayValue">DisplayValue</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="common_anode"></span>Common Anode

</div>

</div>

</div>

This is a Common Anode 7 Segment display example.

Additional configuration is required when using Common Anode.

When setting up the 7 segment Common Anode display you <span
class="strong">**MUST**</span> use the `7Seg_CommonAnode` constant. You
can optionally use the `7Seg_HighSide` constant to support PFET or PNP
high side driving of the Common Anode displays as follows:

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span>             | <span class="strong">**Comment**</span>                              |
|:----------------------------------------------|:-----------------------------------------------------|:---------------------------------------------------------------------|
| `7Seg_CommonAnode`                            | Inverts controls for Common Anode displays           | Required for Common Cathode displays                                 |
| `7Seg_HighSide`                               | Support PFET or PNP high side driving of the display | Inverts Common Cathode addressing pin logic for multiplexed displays |

</div>

<span class="strong">**Example:**</span>

``` screen
    'A Common Anode 7 Segment display example using bs250p pfets
    'Chip model
    #chip 16f1783,8

    'support for Common Cathode
    #define 7Seg_CommonAnode

    'support for pfet or pnp high side drivers
    #define 7Seg_HighSide

    #define DISP_SEG_A PORTC.0
    #define DISP_SEG_B PORTC.1
    #define DISP_SEG_C PORTC.2
    #define DISP_SEG_D PORTC.3
    #define DISP_SEG_E PORTC.4
    #define DISP_SEG_F PORTC.5
    #define DISP_SEG_G PORTC.6
    #define DISP_SEG_DOT PORTC.7

    #define Disp_Sel_1 PortA.1
    #define Disp_Sel_2 PortA.2
    #define Disp_Sel_3 PortA.3

    dim count as word
    dim number as word

    Do Forever
      For count = 0 to 999
          number = count
          Num2 = 0
          Num3 = 0
          If number >= 100 Then
            Num3 = number / 100
            'SysCalcTempX is the remainder after a division has been completed
            number = SysCalcTempX
          End if
          If number >= 10 Then
            Num2 = number / 10
            number = SysCalcTempX
          end if
          Num1 = number
          Repeat 10
            DisplayValue 1, Num1, 1 'Optional third parameter turns on the dp on that digit
            wait 5 ms
            DisplayValue 2, Num2
            wait 5 ms
            DisplayValue 3, Num3
            wait 5 ms
           end Repeat
      Next
    Loop
```

<span class="strong">**Also, see**</span>
<a href="7_segment_displays_overview" class="link" title="7 Segment Displays Overview">7 Degment Display Overview</a>,
<a href="displaychar" class="link" title="DisplayChar">DisplayChar</a>,
<a href="displayvalue" class="link" title="DisplayValue">DisplayValue</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Common Cathode</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_legacy.html" title="7 Segment Displays - Legacy"><link rel="prev" href="_7_segment_displays_legacy.html" title="7 Segment Displays - Legacy"><link rel="next" href="_common_anode.html" title="Common Anode"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_common_cathode"></a>Common Cathode</h6></div></div></div><p>This is a Common Cathode 7 Segment display example.</p><p>No additional configuration is required when using Common Cathnode.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Comment</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">7Seg_CommonAnode</code></p></td><td align="left" valign="top"><p>Inverts controls for Common Anode displays</p></td><td align="left" valign="top"><p>Required for Common Cathode displays</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">7Seg_HighSide</code></p></td><td align="left" valign="top"><p>Support PFET or PNP high side driving of the display</p></td><td align="left" valign="top"><p>Inverts Common Cathode addressing pin logic for multiplexed displays</p></td></tr></tbody></table></div><p>This is a Common Cathode 7 Segment display example.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Chip model
    #chip 16f1783,8

    'Output ports for the 7-segment device
    #define DISP_SEG_A PORTC.0
    #define DISP_SEG_B PORTC.1
    #define DISP_SEG_C PORTC.2
    #define DISP_SEG_D PORTC.3
    #define DISP_SEG_E PORTC.4
    #define DISP_SEG_F PORTC.5
    #define DISP_SEG_G PORTC.6

    ' This is the usage of the SEG_DOT for decimal point support
	' An optional third parameter of '1' will turn on the decimal point
	' of that digit when using DisplayValue command
    #define DISP_SEG_DOT PortC.7

    'Select ports for the 7-segment device
    #define Disp_Sel_1 PortA.1
    #define Disp_Sel_2 PortA.2
    #define Disp_Sel_3 PortA.3

    dim count as word
    dim number as word

    Do Forever
        For count = 0 to 999
            number = count
            Num2 = 0
            Num3 = 0
            If number &gt;= 100 Then
              Num3 = number / 100
              'SysCalcTempX is the remainder after a division has been completed
              number = SysCalcTempX
            End if
            If number &gt;= 10 Then
              Num2 = number / 10
              number = SysCalcTempX
            end if
            Num1 = number
            Repeat 10
              DisplayValue 1, Num1,1  'Optional third parameter turns on the dp dot on that digit
              wait 5 ms
              DisplayValue 2, Num2
              wait 5 ms
              DisplayValue 3, Num3
              wait 5 ms

            end Repeat
        Next
    Loop</pre><p><span class="strong"><strong>Also, see</strong></span>
<a class="link" href="_7_segment_displays_overview.html" title="7 Segment Displays Overview">7 Degment Display Overview</a>,<a class="link" href="_displaychar.html" title="DisplayChar">DisplayChar</a>, <a class="link" href="_displayvalue.html" title="DisplayValue">DisplayValue</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="common_cathode"></span>Common Cathode

</div>

</div>

</div>

This is a Common Cathode 7 Segment display example.

No additional configuration is required when using Common Cathnode.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span>             | <span class="strong">**Comment**</span>                              |
|:----------------------------------------------|:-----------------------------------------------------|:---------------------------------------------------------------------|
| `7Seg_CommonAnode`                            | Inverts controls for Common Anode displays           | Required for Common Cathode displays                                 |
| `7Seg_HighSide`                               | Support PFET or PNP high side driving of the display | Inverts Common Cathode addressing pin logic for multiplexed displays |

</div>

This is a Common Cathode 7 Segment display example.

<span class="strong">**Example:**</span>

``` screen
    'Chip model
    #chip 16f1783,8

    'Output ports for the 7-segment device
    #define DISP_SEG_A PORTC.0
    #define DISP_SEG_B PORTC.1
    #define DISP_SEG_C PORTC.2
    #define DISP_SEG_D PORTC.3
    #define DISP_SEG_E PORTC.4
    #define DISP_SEG_F PORTC.5
    #define DISP_SEG_G PORTC.6

    ' This is the usage of the SEG_DOT for decimal point support
    ' An optional third parameter of '1' will turn on the decimal point
    ' of that digit when using DisplayValue command
    #define DISP_SEG_DOT PortC.7

    'Select ports for the 7-segment device
    #define Disp_Sel_1 PortA.1
    #define Disp_Sel_2 PortA.2
    #define Disp_Sel_3 PortA.3

    dim count as word
    dim number as word

    Do Forever
        For count = 0 to 999
            number = count
            Num2 = 0
            Num3 = 0
            If number >= 100 Then
              Num3 = number / 100
              'SysCalcTempX is the remainder after a division has been completed
              number = SysCalcTempX
            End if
            If number >= 10 Then
              Num2 = number / 10
              number = SysCalcTempX
            end if
            Num1 = number
            Repeat 10
              DisplayValue 1, Num1,1  'Optional third parameter turns on the dp dot on that digit
              wait 5 ms
              DisplayValue 2, Num2
              wait 5 ms
              DisplayValue 3, Num3
              wait 5 ms

            end Repeat
        Next
    Loop
```

<span class="strong">**Also, see**</span>
<a href="7_segment_displays_overview" class="link" title="7 Segment Displays Overview">7 Degment Display Overview</a>,<a href="displaychar" class="link" title="DisplayChar">DisplayChar</a>,
<a href="displayvalue" class="link" title="DisplayValue">DisplayValue</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Compiler Directives</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_lockpps.html" title="LockPPS"><link rel="next" href="__asmraw.html" title="#asmraw"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_compiler_directives"></a>Compiler Directives</h2></div></div></div><p>This is the Compiler Directives section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="compiler_directives"></span>Compiler Directives
----------------------------------------------------------

</div>

</div>

</div>

This is the Compiler Directives section of the Help file. Please refer
the sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Compiler Insights</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_troubleshooting.html" title="Troubleshooting"><link rel="next" href="_libraries_overview.html" title="Libraries Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_compiler_insights"></a>Compiler Insights</h2></div></div></div><p>This section will provide some insights into what the compiler does</p><p><span class="strong"><strong>How does the compiler cope with read only registers in the Chip Family 12 range?</strong></span></p><p>Within this chip range the Option register is a write only register. Reading the register is not permitted.</p><p>GCBASIC needs to update this when the user wants to change the configuration - the Sleep process is an example of a user change.</p><p>The compiler handles this by the creation of the Option_reg byte variable. This byte is created by the compiler to manage the required write process.</p><p>The Option_reg variable is a cache that compiler will create if any bits of option_reg have been set manually.</p><p>If the user changes any of the bits in a program, then the compiler will find any uses of the option instruction and insert a "movwf OPTION_REG" immediately before the option instruction to cache the value in the buffer.</p><p>If Option_reg bits aren&#8217;t set individually anywhere, then option_reg doesn&#8217;t get created, and nothing special is done with the option instruction.</p><p>Essentially the compiler maintains a special variable and manages the whole process without the user being aware.</p><p><span class="strong"><strong>How does the compiler cope with the TRIS register in the 10f products?</strong></span></p><p>The compiler ensures that a TRIS cache matches the actual TRIS register.  The TRIS cache is a byte variable called TRISIO.  The TRISIO cache is required as TRIS is a write-only register.</p><p>All ports default to input ( where all TRIS bits to 1) on reset.  Therefore, this is assumed to be the value 255.</p><p>TRISIO is updated when required by the user code and then used in the writing to the correct register.</p><p>The example user code and the associated assembly shows TRISIO cache in use.  This method complies with datasheet.</p><p>User Code</p><pre class="literallayout">'set as input
dir gpio.0 in
gpio0State = gpio.0
'set as output this will require TRIS GPIO to be set using the TRISIO cache.
dir gpio.0 out
gpio.0 = 1</pre><p>ASM</p><pre class="literallayout">;dir gpio.0 in
  bsf TRISIO,0
  movf  TRISIO,W
  tris  GPIO
;gpio0State = gpio.0
  clrf  GPIO0STATE
  btfsc GPIO,0
  incf  GPIO0STATE,F
;dir gpio.0 out
  bcf TRISIO,0
  movf  TRISIO,W
  tris  GPIO
;gpio.0 = 1
  bsf GPIO,0</pre><p>Anywhere that an individual TRIS bit is set/cleared by change the port direction, the bit in the cache is changed and then that gets written to the TRIS register.</p><p><span class="strong"><strong>Forcing the ASM to contain comments</strong></span></p><p>It may be useful to force comments into the ASM file.  The verbose mode of creating the ASM will include ALL the source program as comments but it may be useful to have specific comments in the ASM to aid the understanding of code or to support debugging.</p><p>To force an assembly comment use the following:</p><pre class="screen">    asm showdebug  `comment`</pre><p>Where the <code class="literal">comment</code> will be placed into the ASM file.</p><p>Example.</p><p>The source file contains the following, where the comment text is <code class="literal">OSCCON type is 100</code></p><pre class="screen">    asm showdebug OSCCON type is 100
    OSCCON1 = 0x60</pre><p>The generated assembly will be as following - this assumes verbose mode is not selected.</p><pre class="screen">    INITSYS
    ;osccon type is 100
      movlw 96
      banksel OSCCON1</pre><p><span class="strong"><strong>Constants, variables, subs and function and labels</strong></span></p><p>GCBASIC uses a single namespace.  A namespace is the set of names used to identify and refer to objects of various kinds.&nbsp;&nbsp;
In GCBASIC these can be constants, variables, methods, and labels.&nbsp;&nbsp;Wwhere a label is a true label like the start of sub, function or macro.&nbsp;&nbsp;
A namespace ensures that all of a given set of objects have unique names so that they can be identified.&nbsp;&nbsp;
This organises constants, variables, methods, labels etc into a single list - the single namespace.</p><p>The namespace includes all libraries and source GCBASIC source files. &nbsp;&nbsp;
If using MPASM this expands to chip specific INF file.&nbsp;&nbsp;
If using PICAS then all of the PICAS toolchain including non-chip specific files. &nbsp;&nbsp;There are changes already in place to resolve this issue for PICAS as HEX and LINE are reserved with PICAS toolchain and these conflict with GCBASIC methods.&nbsp;&nbsp;
These are automatically resolved by the GCBASIC compiler.</p><p>So, given that a constants, variables, methods, labels etc are number, the compiler does not know if that is a constant, a variable, a method, or a call to a label. Some are use cases using a constant called <code class="literal">NORMAL</code> follow.&nbsp;&nbsp;
<code class="literal">NORMAL</code> is defined as a constant with <code class="literal">0</code>.&nbsp;&nbsp;</p><p>#1. Code segment</p><pre class="screen">  #DEFINE NORMAL 0
  CALL Normal</pre><p>The compiler will issue no error.&nbsp;&nbsp;
The compiler will assume the following and will do as instructed.&nbsp;&nbsp;
Call normal - this calls normal which has a value of 0</p><p>Resulting ASM</p><pre class="screen">  ;CALL Normal
  call 0</pre><p>#2. Code segment</p><pre class="screen">  #DEFINE NORMAL 0
  CALL Normal()</pre><p>The compiler will issue no error.&nbsp;&nbsp;
The compiler will assume the following and will do as instructed.&nbsp;&nbsp;
Call normal() - this calls normal which has a value of 0</p><p>Resulting ASM</p><pre class="screen">    ;CALL Normal()
    call 0</pre><p>#3. Code segment</p><pre class="screen">  #DEFINE NORMAL 0
  Normal</pre><p>The compiler will issue an error message.&nbsp;&nbsp;
The compiler will try to resolve the constant normal to a sub but it cannot as it is a value of 0.</p><p>Resulting ASM</p><pre class="screen">    ;Normal
    0 ;?F1L8S0I8?</pre><p>#4. Code segment</p><pre class="screen">  #DEFINE NORMAL 0
  Normal()</pre><p>The compiler will issue an error message.&nbsp;&nbsp;
The compiler will try to resolve the constant normal to a sub but it cannot as it is a value of 0.</p><p>Resulting ASM</p><pre class="screen">    ;Normal()
    0() ;?F1L8S0I8?</pre><p>#5. Code segment</p><pre class="screen">  #DEFINE NORMAL 0
  Normal = 1</pre><p>The compiler will issue an error message.&nbsp;&nbsp;
This tries to assign a value to the object.</p><p>Resulting ASM</p><pre class="screen">  ;Normal = 1
  0 = 1</pre><p>#6. Code segment</p><pre class="screen">  #DEFINE NORMAL 0
  Goto normal</pre><p>The compiler will not issue an error message.&nbsp;&nbsp;
The compiler will <code class="literal">goto</code> (same for <code class="literal">jmp</code>) to the value of the object.</p><p>Resulting ASM</p><pre class="screen">    ;goto Normal
    goto 0</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="compiler_insights"></span>Compiler Insights
------------------------------------------------------

</div>

</div>

</div>

This section will provide some insights into what the compiler does

<span class="strong">**How does the compiler cope with read only
registers in the Chip Family 12 range?**</span>

Within this chip range the Option register is a write only register.
Reading the register is not permitted.

GCBASIC needs to update this when the user wants to change the
configuration - the Sleep process is an example of a user change.

The compiler handles this by the creation of the Option\_reg byte
variable. This byte is created by the compiler to manage the required
write process.

The Option\_reg variable is a cache that compiler will create if any
bits of option\_reg have been set manually.

If the user changes any of the bits in a program, then the compiler will
find any uses of the option instruction and insert a "movwf OPTION\_REG"
immediately before the option instruction to cache the value in the
buffer.

If Option\_reg bits aren’t set individually anywhere, then option\_reg
doesn’t get created, and nothing special is done with the option
instruction.

Essentially the compiler maintains a special variable and manages the
whole process without the user being aware.

<span class="strong">**How does the compiler cope with the TRIS register
in the 10f products?**</span>

The compiler ensures that a TRIS cache matches the actual TRIS register.
The TRIS cache is a byte variable called TRISIO. The TRISIO cache is
required as TRIS is a write-only register.

All ports default to input ( where all TRIS bits to 1) on reset.
Therefore, this is assumed to be the value 255.

TRISIO is updated when required by the user code and then used in the
writing to the correct register.

The example user code and the associated assembly shows TRISIO cache in
use. This method complies with datasheet.

User Code

``` literallayout
'set as input
dir gpio.0 in
gpio0State = gpio.0
'set as output this will require TRIS GPIO to be set using the TRISIO cache.
dir gpio.0 out
gpio.0 = 1
```

ASM

``` literallayout
;dir gpio.0 in
  bsf TRISIO,0
  movf  TRISIO,W
  tris  GPIO
;gpio0State = gpio.0
  clrf  GPIO0STATE
  btfsc GPIO,0
  incf  GPIO0STATE,F
;dir gpio.0 out
  bcf TRISIO,0
  movf  TRISIO,W
  tris  GPIO
;gpio.0 = 1
  bsf GPIO,0
```

Anywhere that an individual TRIS bit is set/cleared by change the port
direction, the bit in the cache is changed and then that gets written to
the TRIS register.

<span class="strong">**Forcing the ASM to contain comments**</span>

It may be useful to force comments into the ASM file. The verbose mode
of creating the ASM will include ALL the source program as comments but
it may be useful to have specific comments in the ASM to aid the
understanding of code or to support debugging.

To force an assembly comment use the following:

``` screen
    asm showdebug  `comment`
```

Where the `comment` will be placed into the ASM file.

Example.

The source file contains the following, where the comment text is
`OSCCON type is 100`

``` screen
    asm showdebug OSCCON type is 100
    OSCCON1 = 0x60
```

The generated assembly will be as following - this assumes verbose mode
is not selected.

``` screen
    INITSYS
    ;osccon type is 100
      movlw 96
      banksel OSCCON1
```

<span class="strong">**Constants, variables, subs and function and
labels**</span>

GCBASIC uses a single namespace. A namespace is the set of names used to
identify and refer to objects of various kinds.   In GCBASIC these can
be constants, variables, methods, and labels.  Wwhere a label is a true
label like the start of sub, function or macro.   A namespace ensures
that all of a given set of objects have unique names so that they can be
identified.   This organises constants, variables, methods, labels etc
into a single list - the single namespace.

The namespace includes all libraries and source GCBASIC source files.   
If using MPASM this expands to chip specific INF file.   If using PICAS
then all of the PICAS toolchain including non-chip specific files.
  There are changes already in place to resolve this issue for PICAS as
HEX and LINE are reserved with PICAS toolchain and these conflict with
GCBASIC methods.   These are automatically resolved by the GCBASIC
compiler.

So, given that a constants, variables, methods, labels etc are number,
the compiler does not know if that is a constant, a variable, a method,
or a call to a label. Some are use cases using a constant called
`NORMAL` follow.   `NORMAL` is defined as a constant with `0`.  

\#1. Code segment

``` screen
  #DEFINE NORMAL 0
  CALL Normal
```

The compiler will issue no error.   The compiler will assume the
following and will do as instructed.   Call normal - this calls normal
which has a value of 0

Resulting ASM

``` screen
  ;CALL Normal
  call 0
```

\#2. Code segment

``` screen
  #DEFINE NORMAL 0
  CALL Normal()
```

The compiler will issue no error.   The compiler will assume the
following and will do as instructed.   Call normal() - this calls normal
which has a value of 0

Resulting ASM

``` screen
    ;CALL Normal()
    call 0
```

\#3. Code segment

``` screen
  #DEFINE NORMAL 0
  Normal
```

The compiler will issue an error message.   The compiler will try to
resolve the constant normal to a sub but it cannot as it is a value of
0.

Resulting ASM

``` screen
    ;Normal
    0 ;?F1L8S0I8?
```

\#4. Code segment

``` screen
  #DEFINE NORMAL 0
  Normal()
```

The compiler will issue an error message.   The compiler will try to
resolve the constant normal to a sub but it cannot as it is a value of
0.

Resulting ASM

``` screen
    ;Normal()
    0() ;?F1L8S0I8?
```

\#5. Code segment

``` screen
  #DEFINE NORMAL 0
  Normal = 1
```

The compiler will issue an error message.   This tries to assign a value
to the object.

Resulting ASM

``` screen
  ;Normal = 1
  0 = 1
```

\#6. Code segment

``` screen
  #DEFINE NORMAL 0
  Goto normal
```

The compiler will not issue an error message.   The compiler will `goto`
(same for `jmp`) to the value of the object.

Resulting ASM

``` screen
    ;goto Normal
    goto 0
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Compiler Options</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_other_directives.html" title="Other directives"><link rel="next" href="__option_explicit.html" title="#Option Explicit"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_compiler_options"></a>Compiler Options</h2></div></div></div><p>This is the Compiler Options section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="compiler_options"></span>Compiler Options
----------------------------------------------------

</div>

</div>

</div>

This is the Compiler Options section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Concatenation</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_wordtobin.html" title="WordToBin"><link rel="next" href="_miscellaneous_commands.html" title="Miscellaneous Commands"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_concatenation"></a>Concatenation</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>stringvar</em></span> = variable1 + variable2</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The method joins two variables into another variable.</p><p>This method does not change the existing strings, but returns a <span class="strong"><strong>new</strong></span> string containing the text of the joined variables, see Concatenated String Constraint below.</p><p>Concatenation joins the elements of a specified values using the specified separator between each variable.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Using concatenation as a parameter with commands like HSerPrint or Print the compiler will create a system string variable.&nbsp;&nbsp;  An examples of concatenating two strings constants like HSerPrint ("123"+"456") may yield incorrect results.&nbsp;&nbsp;Use the constant SYSDEFAULTCONCATSTRING to resolve.&nbsp;&nbsp;Without using SYSDEFAULTCONCATSTRING there is a risk that the compiler does not allocate sufficient RAM to hold the concatenated string.&nbsp;&nbsp;
The resulting string may be corrupted as the size of the system string variable is not sufficient.&nbsp;&nbsp;Use SYSDEFAULTCONCATSTRING within the source program to resolve.</p></div><p><span class="strong"><strong>Set a specific size of compiler created system string variable</strong></span></p><p>Use the following to set the size of the system string variable used during concatenation.&nbsp;&nbsp;</p><p>The compiler will create system string variables when you concatenate on a commands line like <code class="literal">HSerPrint</code>, <code class="literal">Print</code> and many others commands.&nbsp;&nbsp;
Using concatenate with a command is bad practice, using a lot of RAM and may create a number of system string variables.&nbsp;&nbsp;
It is recommended to define a string (of a known length), concatenate using an assignment then use the string.&nbsp;&nbsp;</p><p>To control the size of system string variable use the following.&nbsp;&nbsp;
Also, use this constant to set the size when the compiler does not create a system string variable.&nbsp;&nbsp;</p><pre class="screen">    'Define the constant to control the size of system created string variables called SYSSTRINGPARAM1, SYSSTRINGPARAM2 etc.
    Use #DEFINE  SYSDEFAULTCONCATSTRING  4

    'Then, use
    HSerPrint "A"+"123"   'will print A123. Without the SYSDEFAULTCONCATSTRING constant some microcontrollers may corrupt the result of the concatenation.</pre><p>This concatenation constraint does not apply using concatenation as an assignment.&nbsp;&nbsp;
<br>
<br>
<span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    timevariable = 999
    <span class="emphasis"><em>stringvar</em></span> = "Time = " + str(timevariable) ' Convert the <span class="emphasis"><em>timevariable</em></span> to a String.  This operation returns <span class="strong"><strong>Time = 999</strong></span></pre><p><span class="strong"><strong>Example 2:</strong></span></p><p>An example showing how to set a string to an escape sequence for an ANSI terminal.&nbsp;&nbsp;You can `Dim`ension a string and then assign the elements like an array.
{empty} +
{empty} +</p><pre class="screen">    dim line2 as string
    line2 =  27, "[", "2", "H", 27, "[","K"
    HSerPrint line2</pre><p>Will send the following to the terminal.
&lt;esc&gt;[2H&lt;esc&gt;[K
<br>
<br>
<span class="strong"><strong>Example 3: Assigning concatenated string to same string</strong></span></p><p>For reliable coding you must not assign a string concatenation to same source variable.&nbsp;&nbsp;You must assign the result of string concatenation to another string. &nbsp;&nbsp;To resolve see below:</p><pre class="screen">    Dim outstring, tmpstring as string * 16
    Dim outnumber as byte

    outnumber = 24
    outstring = "Result = "
    'This concatenation may yield an incorrect string on 10f, 12f or 16f chips
    outstring = outstring + str(outnumber)
    HserPrintCRLF 2
    HSerPrint outstring
    HserPrintCRLF 2

    outstring = "Result = "
    'This concatenation will yield an the correct string. With tmpstring1 containing the correct concatenated string
    tmpstring = outstring +str(outnumber)
    HSerPrint tmpstring
    HserPrintCRLF 2
    end</pre><p><br>
To resolve the constraint simply assign the source string to another string.</p><p><br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="concatenation"></span>Concatenation

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    stringvar = variable1 + variable2
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The method joins two variables into another variable.

This method does not change the existing strings, but returns a <span
class="strong">**new**</span> string containing the text of the joined
variables, see Concatenated String Constraint below.

Concatenation joins the elements of a specified values using the
specified separator between each variable.

<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

### Warning

Using concatenation as a parameter with commands like HSerPrint or Print
the compiler will create a system string variable.   An examples of
concatenating two strings constants like HSerPrint ("123"+"456") may
yield incorrect results.  Use the constant SYSDEFAULTCONCATSTRING to
resolve.  Without using SYSDEFAULTCONCATSTRING there is a risk that the
compiler does not allocate sufficient RAM to hold the concatenated
string.   The resulting string may be corrupted as the size of the
system string variable is not sufficient.  Use SYSDEFAULTCONCATSTRING
within the source program to resolve.

</div>

<span class="strong">**Set a specific size of compiler created system
string variable**</span>

Use the following to set the size of the system string variable used
during concatenation.  

The compiler will create system string variables when you concatenate on
a commands line like `HSerPrint`, `Print` and many others commands.  
Using concatenate with a command is bad practice, using a lot of RAM and
may create a number of system string variables.   It is recommended to
define a string (of a known length), concatenate using an assignment
then use the string.  

To control the size of system string variable use the following.   Also,
use this constant to set the size when the compiler does not create a
system string variable.  

``` screen
    'Define the constant to control the size of system created string variables called SYSSTRINGPARAM1, SYSSTRINGPARAM2 etc.
    Use #DEFINE  SYSDEFAULTCONCATSTRING  4

    'Then, use
    HSerPrint "A"+"123"   'will print A123. Without the SYSDEFAULTCONCATSTRING constant some microcontrollers may corrupt the result of the concatenation.
```

This concatenation constraint does not apply using concatenation as an
assignment.    
  
<span class="strong">**Example 1:**</span>

``` screen
    timevariable = 999
    stringvar = "Time = " + str(timevariable) ' Convert the timevariable to a String.  This operation returns Time = 999
```

<span class="strong">**Example 2:**</span>

An example showing how to set a string to an escape sequence for an ANSI
terminal.  You can \`Dim\`ension a string and then assign the elements
like an array. {empty} + {empty} +

``` screen
    dim line2 as string
    line2 =  27, "[", "2", "H", 27, "[","K"
    HSerPrint line2
```

Will send the following to the terminal. &lt;esc&gt;\[2H&lt;esc&gt;\[K  
  
<span class="strong">**Example 3: Assigning concatenated string to same
string**</span>

For reliable coding you must not assign a string concatenation to same
source variable.  You must assign the result of string concatenation to
another string.   To resolve see below:

``` screen
    Dim outstring, tmpstring as string * 16
    Dim outnumber as byte

    outnumber = 24
    outstring = "Result = "
    'This concatenation may yield an incorrect string on 10f, 12f or 16f chips
    outstring = outstring + str(outnumber)
    HserPrintCRLF 2
    HSerPrint outstring
    HserPrintCRLF 2

    outstring = "Result = "
    'This concatenation will yield an the correct string. With tmpstring1 containing the correct concatenated string
    tmpstring = outstring +str(outnumber)
    HSerPrint tmpstring
    HserPrintCRLF 2
    end
```

  
To resolve the constraint simply assign the source string to another
string.

  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Conditions</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_line_continuation.html" title="Line Continuation"><link rel="next" href="_constants.html" title="Constants"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_conditions"></a>Conditions</h3></div></div></div><p><span class="strong"><strong>About Conditions</strong></span></p><p>In GCBASIC (and most other programming languages) a condition is a
statement that can be either true or false. Conditions are used when the
program must make a decision.
A condition is generally given as a value or variable, a relative
operator (such as = or &gt;), and another value or variable. Several
conditions can be combined to form one condition through the use of
logical operators such as AND and OR.</p><p>GCBASIC supports these relative operators:</p><div class="informaltable"><table border="1" width="60%"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Symbol</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Meaning</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p><code class="literal">=</code></p></td><td align="center" valign="top"><p>Equal</p></td></tr><tr><td align="center" valign="top"><p><code class="literal">&lt;&gt;</code></p></td><td align="center" valign="top"><p>Not Equal</p></td></tr><tr><td align="center" valign="top"><p><code class="literal">&lt;</code></p></td><td align="center" valign="top"><p>Less Than</p></td></tr><tr><td align="center" valign="top"><p><code class="literal">&gt;</code></p></td><td align="center" valign="top"><p>Greater Than</p></td></tr><tr><td align="center" valign="top"><p><code class="literal">&#8656;</code></p></td><td align="center" valign="top"><p>Less than or equal to</p></td></tr><tr><td align="center" valign="top"><p><code class="literal">&gt;=</code></p></td><td align="center" valign="top"><p>Greater than or equal to</p></td></tr></tbody></table></div><p>In addition, these logical operators can be used to combine several
conditions into one:</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Name</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Abbreviation</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Condition true if</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p><code class="literal">AND</code></p></td><td align="center" valign="top"><p><code class="literal">&amp;</code></p></td><td align="center" valign="top"><p>both conditions are true</p></td></tr><tr><td align="center" valign="top"><p><code class="literal">OR</code></p></td><td align="center" valign="top"><p><code class="literal">|</code></p></td><td align="center" valign="top"><p>at least one condition is true</p></td></tr><tr><td align="center" valign="top"><p><code class="literal">XOR</code></p></td><td align="center" valign="top"><p><code class="literal">#</code></p></td><td align="center" valign="top"><p>one condition is true</p></td></tr><tr><td align="center" valign="top"><p><code class="literal">NOT</code></p></td><td align="center" valign="top"><p><code class="literal">!</code></p></td><td align="center" valign="top"><p>the condition is not true</p></td></tr></tbody></table></div><p>NOT is slightly different to the other logical operators, in that it
only needs one other condition. Other arithmetic operators may be
combined in conditions, to change values before they are compared, for
example.</p><p>GCBASIC has two built in conditions - TRUE, which is always true, and
FALSE, which is always false. These can be used to create Conditional tests and infinite
loops.</p><p>The condition bit_variable = TRUE is treated as TRUE if the bit is on.&nbsp;&nbsp;Any non-zero value will be treated as equal to a high bit.
The condition bit_variable  = other_type_of_variable generates a warning.&nbsp;&nbsp;If the byte_variable is set to TRUE and then compared to the bit, it will always be FALSE because the high bit will be treated as a 1.&nbsp;&nbsp;But the new warning will be generated, "Comparison will fail if %nonbit% is any value other than 0 or 1"</p><p>It is also possible to test individual bits in conditions. To do this,
specify the bit to test, then 1 or 0 (or ON and OFF respectively).
Presently there is no way to combine bit tests with other conditions -
NOT, AND, OR and XOR will not work.</p><p><span class="strong"><strong>Example conditions:</strong></span></p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Condition</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Comments</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>Temp = 0</p></td><td align="left" valign="top"><p>Condition is true if Temp = 0</p></td></tr><tr><td align="left" valign="top"><p>Sensor &lt;&gt; 0</p></td><td align="left" valign="top"><p>Condition is true if Sensor is not 0</p></td></tr><tr><td align="left" valign="top"><p>Reading1 &gt; Reading2</p></td><td align="left" valign="top"><p>True if Reading1 is more than Reading2</p></td></tr><tr><td align="left" valign="top"><p>Mode = 1 AND Time &gt; 10</p></td><td align="left" valign="top"><p>True if Mode is 1 and Time is more than 10</p></td></tr><tr><td align="left" valign="top"><p>Heat &gt; 5 OR Smoke &gt; 2</p></td><td align="left" valign="top"><p>True if Heat is more than 5 or Smoke is more than 2</p></td></tr><tr><td align="left" valign="top"><p>Light &gt;= 10 AND (NOT Time &gt; 7)</p></td><td align="left" valign="top"><p>True if Light is 10 or more, and Time is 7 or less</p></td></tr><tr><td align="left" valign="top"><p>Temp.0 ON</p></td><td align="left" valign="top"><p>True if Temp bit 0 is on</p></td></tr></tbody></table></div><p><span class="strong"><strong>Constraints when using Conditional Test</strong></span></p><p>As GCBASIC is very flexible with the use of variables type this can cause issues when testing constants and/or functions.</p><p>A few simple rules. <span class="strong"><strong>Always put the function or constant first, or, always call the function with the addition of the braces.</strong></span></p><p>The example code below shows the correct method and an example that does compile but will not work as expected.</p><pre class="screen">    'Example A - works
    'Call the function by adding the braces
    '
    Do
    Loop While HSerReceive() &lt;&gt; 62

    'Example B - works
    'Please the constant first - this is the general rule - put the constant first.
    '
    Do
    Loop While 62 &lt;&gt; HSerReceive</pre><p>This fails as the function will not be called</p><pre class="screen">    'Example C - compiles but does not operate as expected
    Do
    Loop While HSerReceive &lt;&gt; 62</pre><p><br>
<br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="conditions"></span>Conditions

</div>

</div>

</div>

<span class="strong">**About Conditions**</span>

In GCBASIC (and most other programming languages) a condition is a
statement that can be either true or false. Conditions are used when the
program must make a decision. A condition is generally given as a value
or variable, a relative operator (such as = or &gt;), and another value
or variable. Several conditions can be combined to form one condition
through the use of logical operators such as AND and OR.

GCBASIC supports these relative operators:

<div class="informaltable">

| <span class="strong">**Symbol**</span> | <span class="strong">**Meaning**</span> |
|:--------------------------------------:|:---------------------------------------:|
|                  `=`                   |                  Equal                  |
|                  `<>`                  |                Not Equal                |
|                  `<`                   |                Less Than                |
|                  `>`                   |              Greater Than               |
|                  `⇐`                   |          Less than or equal to          |
|                  `>=`                  |        Greater than or equal to         |

</div>

In addition, these logical operators can be used to combine several
conditions into one:

<div class="informaltable">

| <span class="strong">**Name**</span> | <span class="strong">**Abbreviation**</span> | <span class="strong">**Condition true if**</span> |
|:------------------------------------:|:--------------------------------------------:|:-------------------------------------------------:|
|                `AND`                 |                     `&`                      |             both conditions are true              |
|                 `OR`                 |                     `|`                      |          at least one condition is true           |
|                `XOR`                 |                     `#`                      |               one condition is true               |
|                `NOT`                 |                     `!`                      |             the condition is not true             |

</div>

NOT is slightly different to the other logical operators, in that it
only needs one other condition. Other arithmetic operators may be
combined in conditions, to change values before they are compared, for
example.

GCBASIC has two built in conditions - TRUE, which is always true, and
FALSE, which is always false. These can be used to create Conditional
tests and infinite loops.

The condition bit\_variable = TRUE is treated as TRUE if the bit is
on.  Any non-zero value will be treated as equal to a high bit. The
condition bit\_variable = other\_type\_of\_variable generates a
warning.  If the byte\_variable is set to TRUE and then compared to the
bit, it will always be FALSE because the high bit will be treated as a
1.  But the new warning will be generated, "Comparison will fail if
%nonbit% is any value other than 0 or 1"

It is also possible to test individual bits in conditions. To do this,
specify the bit to test, then 1 or 0 (or ON and OFF respectively).
Presently there is no way to combine bit tests with other conditions -
NOT, AND, OR and XOR will not work.

<span class="strong">**Example conditions:**</span>

<div class="informaltable">

| <span class="strong">**Condition**</span> | <span class="strong">**Comments**</span>            |
|:------------------------------------------|:----------------------------------------------------|
| Temp = 0                                  | Condition is true if Temp = 0                       |
| Sensor &lt;&gt; 0                         | Condition is true if Sensor is not 0                |
| Reading1 &gt; Reading2                    | True if Reading1 is more than Reading2              |
| Mode = 1 AND Time &gt; 10                 | True if Mode is 1 and Time is more than 10          |
| Heat &gt; 5 OR Smoke &gt; 2               | True if Heat is more than 5 or Smoke is more than 2 |
| Light &gt;= 10 AND (NOT Time &gt; 7)      | True if Light is 10 or more, and Time is 7 or less  |
| Temp.0 ON                                 | True if Temp bit 0 is on                            |

</div>

<span class="strong">**Constraints when using Conditional Test**</span>

As GCBASIC is very flexible with the use of variables type this can
cause issues when testing constants and/or functions.

A few simple rules. <span class="strong">**Always put the function or
constant first, or, always call the function with the addition of the
braces.**</span>

The example code below shows the correct method and an example that does
compile but will not work as expected.

``` screen
    'Example A - works
    'Call the function by adding the braces
    '
    Do
    Loop While HSerReceive() <> 62

    'Example B - works
    'Please the constant first - this is the general rule - put the constant first.
    '
    Do
    Loop While 62 <> HSerReceive
```

This fails as the function will not be called

``` screen
    'Example C - compiles but does not operate as expected
    Do
    Loop While HSerReceive <> 62
```

  
  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Configuration</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microcontroller_fundamentals.html" title="Microcontroller Fundamentals"><link rel="prev" href="_inputs_outputs.html" title="Inputs/Outputs"><link rel="next" href="_data_types.html" title="Data Types"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuration"></a>Configuration</h3></div></div></div><p><span class="strong"><strong>About Configuration</strong></span></p><p><span class="emphasis"><em>(Note: This section does not apply to Atmel AVR microcontrollers. Atmel AVR microcontrollers
do have a similar configuration settings, but they are controlled
through "Configuration Fuses". GCBASIC cannot set these -
you MUST use the programmer software.)</em></span></p><p>Every Microchip PIC has a CONFIG word. This is an area of memory on the chip
that stores settings which govern the operation of the chip.</p><p>The following asects of the chip are governed by the CONFIG word:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Oscillator selection - will the chip run from an internal oscillator,
or is an external one attached?</li><li class="listitem">Automatic resets - should the chip reset if the power drops too low?
If it detects it is running the same piece of code over and over?</li><li class="listitem">Code protection - what areas of memory must be kept hidden once
written to?</li><li class="listitem">Pin usage - which pins are available for programming, resetting the
chip, or emitting PWM signals?</li></ul></div><p>The exact configuration settings vary amongst chips. To find out a list
of valid settings, please consult the datasheet for the microcontrollers that
you wish to use.</p><p>This can all be rather confusing - hence, GCBASIC will automatically set
some config settings, unless told otherwise:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="strong"><strong>Low Voltage Programming (LVP) is turned off.</strong></span> This enables the PGM
pin (usually B3 or B4) to be used as a normal I/O pin.</li><li class="listitem"><span class="strong"><strong>Watchdog Timer (WDT) is turned off.</strong></span> The WDT resets the chip if it
runs the same piece of code over and over - this can cause trouble with
some of the longer delay routines in GCBASIC.</li><li class="listitem"><span class="strong"><strong>Master Clear (MCLR) is disabled where possible.</strong></span> On many newer chips
this allows the MCLR pin (often PORTA.5) to be used as a standard input
port. It also removes the need for a pull-up resistor on the MCLR pin.</li><li class="listitem"><p class="simpara"><span class="strong"><strong>An oscillator mode will be selected, based on the following rules:</strong></span></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">If the microcontroller has an internal oscillator, and the internal oscillator is
capable of generating the speed specified in the #chip line, then the
internal oscillator will be used.</li><li class="listitem">If the clock speed is over 4 Mhz, the external HS oscillator is
selected</li><li class="listitem">If the clock speed is 4 MHz or less, then the external XT oscillator
mode is selected.</li></ul></div></li></ul></div><p>Note that these settings can easily be individually overridden whenever
needed. For example, if the Watchdog Timer is needed, adding the line</p><pre class="screen">    #config WDT = ON</pre><p>This will enable the watchdog timer, without affecting any other
configuration settings.</p><p><span class="strong"><strong>Using Configuration</strong></span></p><p>Once the necessary CONFIG options have been determined, adding them to
the program is easy. On a new line type "#config" and then list the
desired options separated by commas, such as in this line:</p><pre class="screen">    #config OSC = RC, BODEN = OFF</pre><p>GCBASIC also supports this format on 10/12/16 series chips:</p><pre class="screen">    #config INTOSC_OSC_NOCLKOUT, BODEN_OFF</pre><p>However, for upwards compatibility with 18F chips, you should use the = style config settings.</p><p>It is possible to have several #config lines in a program - for
instance, one in the main program, and one in each of several #include
files. However, care must then be taken to ensure that the settings in
one file do not conflict with those in another.</p><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="__config.html" title="#config">#config Directive</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="configuration"></span>Configuration

</div>

</div>

</div>

<span class="strong">**About Configuration**</span>

<span class="emphasis">*(Note: This section does not apply to Atmel AVR
microcontrollers. Atmel AVR microcontrollers do have a similar
configuration settings, but they are controlled through "Configuration
Fuses". GCBASIC cannot set these - you MUST use the programmer
software.)*</span>

Every Microchip PIC has a CONFIG word. This is an area of memory on the
chip that stores settings which govern the operation of the chip.

The following asects of the chip are governed by the CONFIG word:

<div class="itemizedlist">

-   Oscillator selection - will the chip run from an internal
    oscillator, or is an external one attached?
-   Automatic resets - should the chip reset if the power drops too low?
    If it detects it is running the same piece of code over and over?
-   Code protection - what areas of memory must be kept hidden once
    written to?
-   Pin usage - which pins are available for programming, resetting the
    chip, or emitting PWM signals?

</div>

The exact configuration settings vary amongst chips. To find out a list
of valid settings, please consult the datasheet for the microcontrollers
that you wish to use.

This can all be rather confusing - hence, GCBASIC will automatically set
some config settings, unless told otherwise:

<div class="itemizedlist">

-   <span class="strong">**Low Voltage Programming (LVP) is turned
    off.**</span> This enables the PGM pin (usually B3 or B4) to be used
    as a normal I/O pin.

-   <span class="strong">**Watchdog Timer (WDT) is turned off.**</span>
    The WDT resets the chip if it runs the same piece of code over and
    over - this can cause trouble with some of the longer delay routines
    in GCBASIC.

-   <span class="strong">**Master Clear (MCLR) is disabled where
    possible.**</span> On many newer chips this allows the MCLR pin
    (often PORTA.5) to be used as a standard input port. It also removes
    the need for a pull-up resistor on the MCLR pin.

-   <span class="strong">**An oscillator mode will be selected, based on
    the following rules:**</span>

    <div class="itemizedlist">

    -   If the microcontroller has an internal oscillator, and the
        internal oscillator is capable of generating the speed specified
        in the \#chip line, then the internal oscillator will be used.
    -   If the clock speed is over 4 Mhz, the external HS oscillator is
        selected
    -   If the clock speed is 4 MHz or less, then the external XT
        oscillator mode is selected.

    </div>

</div>

Note that these settings can easily be individually overridden whenever
needed. For example, if the Watchdog Timer is needed, adding the line

``` screen
    #config WDT = ON
```

This will enable the watchdog timer, without affecting any other
configuration settings.

<span class="strong">**Using Configuration**</span>

Once the necessary CONFIG options have been determined, adding them to
the program is easy. On a new line type "\#config" and then list the
desired options separated by commas, such as in this line:

``` screen
    #config OSC = RC, BODEN = OFF
```

GCBASIC also supports this format on 10/12/16 series chips:

``` screen
    #config INTOSC_OSC_NOCLKOUT, BODEN_OFF
```

However, for upwards compatibility with 18F chips, you should use the =
style config settings.

It is possible to have several \#config lines in a program - for
instance, one in the main program, and one in each of several \#include
files. However, care must then be taken to ensure that the settings in
one file do not conflict with those in another.

<span class="strong">**For more help, see**</span>
<a href="_config" class="link" title="#config">#config Directive</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Constants</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_conditions.html" title="Conditions"><link rel="next" href="_functions.html" title="Functions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_constants"></a>Constants</h3></div></div></div><p><span class="strong"><strong>About Constants</strong></span></p><p>A constant tells the compiler to find a given
word, and replace it with another word or number. Define directives create constants.</p><p>Constants are useful for situations where a routine needs to be easily altered. For example, a
define could be used to specify the amount of time to run an alarm for
once triggered.</p><p>It is also possible to use defines to specify ports - thus defines can
be used to aid in the creation of code that can easily be adapted to run
on a different microcontroller with different ports.</p><p>GCBASIC makes considerable use of defines internally. For instance, the
LCD code uses defines to set the ports that it must use to communicate
with the LCD.</p><p><span class="strong"><strong>About Defines</strong></span></p><p>To create a define is a matter of using the #define directive. Here are
some examples of defines:</p><pre class="screen">    #define Line 34
    #define Light PORTB.0
    #define LightOn Set PORTB.0 on</pre><p><code class="literal">Line</code> is a simple constant - GCBASIC will find <code class="literal">Line</code> in the program, and
replace it with the number 34. This could be used in a line following
program, to make it easier to calibrate the program for different
lighting conditions.</p><p><code class="literal">Light</code> is a port - it represents a particular pin on the microcontroller. This
would be of use if the program had many lines of code that controlled
the light, and there was a possibility that the port the light was
attached to would need to change in the future.</p><p><code class="literal">LightOn</code> is a define used to make the program more readable. Rather than
typing <code class="literal">Set PORTB.0 on</code> over and over, it would then be made possible to
type <code class="literal">LightOn</code>, and have the compiler do the hard work.</p><p><span class="strong"><strong>GCBASIC Defined constants</strong></span></p><pre class="screen">    #define ON 1
    #define OFF 0
    #define TRUE 255
    #define FALSE 0

    'Names for symbols
    #define AND &amp;
    #define OR |
    #define XOR #
    #define NOT !
    #define MOD %</pre><p><span class="strong"><strong>GCBASIC special constant</strong></span></p><p><code class="literal">Forever</code> is a special constant.  For Graphical GCBASIC users think of this as 'false'. For those not using Graphical GCBASIC think of this as a non numeric value that has no value.  You can use <code class="literal">Forever</code> in a DO-LOOP but not in a REPEAT-END REPEAT loop, as the in the later case the REPEAT will have no value and you will create an error condition.</p><p><span class="strong"><strong>Precedence of Constants within GCBASIC.</strong></span>
<br>
<br>
The <code class="literal">#define</code> command creates constants, and, a script can creates constants.
<br>
<br>
The precedence is as follows:
<br>
<br>
<code class="literal">#define</code> in the main program are read first,
<br>
<br>
then, the <code class="literal">#define</code> in the include files. Constants defined in the include files will be ignored if they conflict or are different to another constant in the main program,
<br>
<br>
then, the scripts are processed. Scripts that create constants always override any constant value previously defined.
<br>
<br>
Scripts are highest priority, then constants in the main program, then constants in include files from the main program, then constants in the standard libraries.
<br>
<br></p><p>See <span class="strong"><strong><a class="link" href="__define.html" title="#DEFINE">#define</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="constants"></span>Constants

</div>

</div>

</div>

<span class="strong">**About Constants**</span>

A constant tells the compiler to find a given word, and replace it with
another word or number. Define directives create constants.

Constants are useful for situations where a routine needs to be easily
altered. For example, a define could be used to specify the amount of
time to run an alarm for once triggered.

It is also possible to use defines to specify ports - thus defines can
be used to aid in the creation of code that can easily be adapted to run
on a different microcontroller with different ports.

GCBASIC makes considerable use of defines internally. For instance, the
LCD code uses defines to set the ports that it must use to communicate
with the LCD.

<span class="strong">**About Defines**</span>

To create a define is a matter of using the \#define directive. Here are
some examples of defines:

``` screen
    #define Line 34
    #define Light PORTB.0
    #define LightOn Set PORTB.0 on
```

`Line` is a simple constant - GCBASIC will find `Line` in the program,
and replace it with the number 34. This could be used in a line
following program, to make it easier to calibrate the program for
different lighting conditions.

`Light` is a port - it represents a particular pin on the
microcontroller. This would be of use if the program had many lines of
code that controlled the light, and there was a possibility that the
port the light was attached to would need to change in the future.

`LightOn` is a define used to make the program more readable. Rather
than typing `Set PORTB.0 on` over and over, it would then be made
possible to type `LightOn`, and have the compiler do the hard work.

<span class="strong">**GCBASIC Defined constants**</span>

``` screen
    #define ON 1
    #define OFF 0
    #define TRUE 255
    #define FALSE 0

    'Names for symbols
    #define AND &
    #define OR |
    #define XOR #
    #define NOT !
    #define MOD %
```

<span class="strong">**GCBASIC special constant**</span>

`Forever` is a special constant. For Graphical GCBASIC users think of
this as 'false'. For those not using Graphical GCBASIC think of this as
a non numeric value that has no value. You can use `Forever` in a
DO-LOOP but not in a REPEAT-END REPEAT loop, as the in the later case
the REPEAT will have no value and you will create an error condition.

<span class="strong">**Precedence of Constants within
GCBASIC.**</span>  
  
The `#define` command creates constants, and, a script can creates
constants.  
  
The precedence is as follows:  
  
`#define` in the main program are read first,  
  
then, the `#define` in the include files. Constants defined in the
include files will be ignored if they conflict or are different to
another constant in the main program,  
  
then, the scripts are processed. Scripts that create constants always
override any constant value previously defined.  
  
Scripts are highest priority, then constants in the main program, then
constants in include files from the main program, then constants in the
standard libraries.  
  

See <span
class="strong">**<a href="_define" class="link" title="#DEFINE">#define</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Converters</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_subroutines.html" title="Subroutines"><link rel="next" href="_command_references.html" title="Command References"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_converters"></a>Converters</h3></div></div></div><p><span class="strong"><strong>About Converters</strong></span></p><p>Converters allow GCBASIC to read files that have been created by other programs.
A converter can convert these files into GCBASIC libraries or any GCBASIC instruction or a GCBASIC dataset.</p><p>A typical use case is when you have a data source file from another computer system and you want to consume the data within your GCBASIC program.
The data source file could be database, graphic, reference data or music file.
The converter will read these source files and convert them into a format that can be processed by GCBASIC.
The conversion process is completed by external application which can be written by the developer or you can use
one of the converters provided with the GCBASIC release.</p><p>The GCBASIC release includes the converter for BMP files and standard Text files.</p><p>With an appropriate Converter installed, and an associated <code class="literal">#include</code> to these non-GCBASIC files,
GCBASIC will detect that the file extension and hand the processing to the external converting program.
When the external converting program had complete, GCBASIC will then continue with the converted source file as a GCBASIC source file.</p><p>An example of a converter is to read an existing picture file, convert the picture file to a GCB table and then refer to the picture
file table to display the picture file on a GLCD.</p><p>Conversion is achieved by including a command within the source program to transform external data.
The command used is the instruction <code class="literal">#include</code> followed by the data source.  An example:</p><pre class="screen">    'Convert ManLooking.BMP to a GCBASIC usable format.

    #include &lt;..\converters\ManLooking.BMP&gt;</pre><p>The inclusion of the #include line within a GCBASIC  program will enable the commencement of the following process:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">GCBASIC  will examine the <code class="literal">..\converters</code> folder structure for a configuration file that will handle the file extension specified in the include statement.</li><li class="listitem">GCBASIC  will examine the configuration file(s) <code class="literal">*.INI</code> for command line instructions.</li><li class="listitem">GCBASIC  will at stage examine the folder structure for the source file and the target transformed file.
If the source file is older than the transformed file the next step will not be executed, goto step 6.</li><li class="listitem"><p class="simpara">GCBASIC  will execute the command as specified within the configuration file to transform the source file to the target file.</p><p class="simpara">The Conversion program must create the output file extension as specified in the configuration file.  If the include statement as an extension
of <code class="literal">.TXT</code> and the configuration files states the input file extension as <code class="literal">.TXT</code> and the output as <code class="literal">.GCB</code> the converted file must have the extension of <code class="literal">.GCB</code>.</p><pre class="literallayout">#include &lt;..\converters\ManLooking.BMP&gt;</pre><p class="simpara">Init file is input file as BMP and output as GCB, then the file expected is <code class="literal">..\converters\ManLooking.GCB</code></p></li><li class="listitem">GCBASIC  will attempt to include the transformed target file (with the file extension as specified in the configuration file) within the GCBASIC  program.</li><li class="listitem">GCBASIC  will resume normal processing of the GCBASIC program including the transformed target file, therefore, with normal compiling and errors handling.</li></ol></div><p>For example programs see <a class="link" href="_converters.html#XX0">here</a>.</p><p><span class="strong"><strong>More about Converters</strong></span></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">The configuration file</p><p class="simpara">The configuration file MUST have the extension of <code class="literal">.INI</code>.  No leading spaces are permitted in the configuration file.
Specification of the configuration file.
The file has four items: <code class="literal">desc</code>, <code class="literal">in</code>, <code class="literal">out</code> and <code class="literal">exe</code>. Where:</p><pre class="literallayout">desc         : Is the description shown in GCGB
in           : Is the source file extension to be transformed
out          : Is the target transformed file extension.
exe          : Is the executable to be run for this specific configuration file.
params       : Optional, is the required parameter to be passed from the compiler.  Example:  params = %filename% %chipmodel%
deletetarget : Optional, will always recreate the target transformed file. The default is to retain the target transformed file unless source has changed. Options are Y or N</pre><p class="simpara">You can have multiple configuration files within the <code class="literal">..\converters folder structure</code>.</p><p class="simpara">GCBASIC will examine all configuration file to match the extension as specified in the <code class="literal">#include</code> command.</p><p class="simpara"><span class="strong"><strong>Example 1 :</strong></span></p><div class="informalexample"><p>BMP (Black and White) conversion configuration file is called <code class="literal">BMP2GCBasic.ini</code>.  The source extension is <code class="literal">.bmp</code>,
the transformed file extension is <code class="literal">.GCB</code>, and the executable is called <code class="literal">BMP2GCBASIC.exe</code>.</p><pre class="literallayout">desc = BMP file (*.bmp)
in = bmp
out = GCB
exe = BMP2GCBASIC .exe</pre><p>An example :</p><pre class="literallayout">#include &lt;..\converters\ManLooking.BMP&gt;</pre><p>Will be converted by the <code class="literal">BMP2GCBASIC .EXE</code> to <code class="literal">..\converters\ManLooking.GCB</code></p></div><p class="simpara"><span class="strong"><strong>Example 2 :</strong></span></p><div class="informalexample"><p>Data file conversion configuration file is called <code class="literal">TXT2GCB.ini</code>.  The source extension is <code class="literal">.TXT</code>, the transformed
file extension is <code class="literal">.GCB</code>, and the command line called <code class="literal">AWKRUN.BAT</code> .</p><pre class="literallayout">desc = Infrared Patterns (*.txt)
in = txt
out = GCB
exe = awkrun.bat</pre><p>An example :</p><pre class="literallayout">#include &lt;..\converters\InfraRedPatterns.TXT&gt;</pre><p>Will be converted by the <code class="literal">AWKRUN.BAT</code> to <code class="literal">..\converters\ InfraRedPatterns.GCB</code></p><p>The example would require a supporting batch file and a script process to complete the transformation.</p></div></li><li class="listitem"><p class="simpara">Conversion Executable</p><p class="simpara">The conversion executable may be written in any language (compiled or interpreted).</p><p class="simpara">The conversion executable MUST create the converted file with the correct file extension as specified in the configuration file.</p><p class="simpara">The conversion executable will be passed one parameter - the source file name.
Using example #1 the conversion executable would be passed   <code class="literal">..\converters\ManLooking.BMP</code></p><p class="simpara">The conversion executable MUST create a GCBASIC compatible source file.  Any valid commands/instruction are permitted.</p></li><li class="listitem"><p class="simpara">Installation</p><p class="simpara">The <code class="literal">INI</code> file, the source file and the conversion executable MUST be located in the <code class="literal">..\converters folder</code>.
The converters folder is relative to the <code class="literal">GCBASIC.EXE</code> compiler folder.</p></li></ol></div><p><a name="XX0"></a><span class="strong"><strong>Example 3 : Converter Program</strong></span></p><div class="informalexample"><p>This program converts the <code class="literal">InfraRedPatterns.TXT</code> into <code class="literal">InfraRedPatterns.GCB</code> that will have a GCBASIC table called <code class="literal">DataSource</code>.
This example is located in the converter folder of the GCBASIC installation.</p><pre class="screen">  #chip16f877a, 16
  #include &lt;..\converters\InfraRedPatterns.TXT&gt;

  dir portb out

  ' These must be WORDs as this could be large table.
  dim TableReadPosition, TableLen as word

  dir portb out

  ' Read the table length
  TableReadPosition = 0
  ReadTable DataSource, TableReadPosition, TableLen


  Do Forever
      For TableReadPosition = 1 to TableLen step 2
          ReadTable DataSource, TableReadPosition, TransmissionPattern
          ReadTable DataSource, TableReadPosition+1 , PulseDelay
          portb = TransmissionPattern
          wait PulseDelay ms
      next
  Loop</pre></div><p><span class="strong"><strong>Example 4 : Dynamic Import</strong></span></p><div class="informalexample"><p>This program converts a chip specific configuration file into <code class="literal">manifest.GCB</code> that will have a GCBASIC functions called <code class="literal">DataIn</code> and <code class="literal">DataOut</code>.
This example is located in the converter folder of the GCBASIC installation.</p><pre class="screen">    #chip 16f18326

    #include &lt;..\converters\manifest.mcc&gt;

    DataOut ( TX, RA0 )  'this method is created during the convert process. They do not exist withiut the converter.
    DataIn  ( Rx, RC6 )  'this method is created during the convert process. They do not exist withiut the converter.</pre><p>This example would use the optional parameters of <code class="literal">params</code> and <code class="literal">deletetarget</code> in the converter configuration file as follows:</p><pre class="screen">    desc = PPS file (*.PPS)
    params = %filename% %chipmodel%
    in = mcc
    out = GCB
    exe = DataHandler.exe
    deletetarget= y</pre></div><p><span class="strong"><strong>Example 5 : Add build numbers and time/date details to your programs</strong></span></p><p>This converter is used to expose two string variables as follows:</p><pre class="screen">    GCBBuildStr
    GCBBuildTimeStr</pre><p>The user code is simple. Using the #include statement specify any filename with an extension must be <code class="literal">cnt</code>. As follows:</p><pre class="screen">    #include "GCBVersionNumber.cnt"</pre><p>Complete code would like this - this not optimised - this shows the use of the exposed strings.</p><pre class="screen">    #include "GCBVersionNumber.cnt"

    dim versionString as string * 40
    versionString = "Max7219 build"+GCBBuildStr
    versionString = versionString + "@"+GCBBuildTimeStr
    Print versionString</pre><p>This outputs the following - where #20 is the current build and the date/time is correct for build time.</p><pre class="screen">    Max7219 build20@01-06-2021 08:00:21
    Commence main program</pre><p>This works as the support INI file instructs the compiler to call a utility that automatically creates a build number tracker file and the supportting string functions.
The utility creates a tracker file and the methods files in the same folder as your source program - so, each tracker is specific to each project.
The converter requires the following files - these are included within your Installation.</p><pre class="screen">    GCBVersionStamp.exe - the utility called by the converter capability.
    cnt2gcb.ini - the supporting ini file used by the compiler to handle this converter.</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="converters"></span>Converters

</div>

</div>

</div>

<span class="strong">**About Converters**</span>

Converters allow GCBASIC to read files that have been created by other
programs. A converter can convert these files into GCBASIC libraries or
any GCBASIC instruction or a GCBASIC dataset.

A typical use case is when you have a data source file from another
computer system and you want to consume the data within your GCBASIC
program. The data source file could be database, graphic, reference data
or music file. The converter will read these source files and convert
them into a format that can be processed by GCBASIC. The conversion
process is completed by external application which can be written by the
developer or you can use one of the converters provided with the GCBASIC
release.

The GCBASIC release includes the converter for BMP files and standard
Text files.

With an appropriate Converter installed, and an associated `#include` to
these non-GCBASIC files, GCBASIC will detect that the file extension and
hand the processing to the external converting program. When the
external converting program had complete, GCBASIC will then continue
with the converted source file as a GCBASIC source file.

An example of a converter is to read an existing picture file, convert
the picture file to a GCB table and then refer to the picture file table
to display the picture file on a GLCD.

Conversion is achieved by including a command within the source program
to transform external data. The command used is the instruction
`#include` followed by the data source. An example:

``` screen
    'Convert ManLooking.BMP to a GCBASIC usable format.

    #include <..\converters\ManLooking.BMP>
```

The inclusion of the \#include line within a GCBASIC program will enable
the commencement of the following process:

<div class="orderedlist">

1.  GCBASIC will examine the `..\converters` folder structure for a
    configuration file that will handle the file extension specified in
    the include statement.

2.  GCBASIC will examine the configuration file(s) `*.INI` for command
    line instructions.

3.  GCBASIC will at stage examine the folder structure for the source
    file and the target transformed file. If the source file is older
    than the transformed file the next step will not be executed, goto
    step 6.

4.  GCBASIC will execute the command as specified within the
    configuration file to transform the source file to the target file.

    The Conversion program must create the output file extension as
    specified in the configuration file. If the include statement as an
    extension of `.TXT` and the configuration files states the input
    file extension as `.TXT` and the output as `.GCB` the converted file
    must have the extension of `.GCB`.

    ``` literallayout
    #include <..\converters\ManLooking.BMP>
    ```

    Init file is input file as BMP and output as GCB, then the file
    expected is `..\converters\ManLooking.GCB`

5.  GCBASIC will attempt to include the transformed target file (with
    the file extension as specified in the configuration file) within
    the GCBASIC program.

6.  GCBASIC will resume normal processing of the GCBASIC program
    including the transformed target file, therefore, with normal
    compiling and errors handling.

</div>

For example programs see
<a href="converters#XX0" class="link">here</a>.

<span class="strong">**More about Converters**</span>

<div class="orderedlist">

1.  The configuration file

    The configuration file MUST have the extension of `.INI`. No leading
    spaces are permitted in the configuration file. Specification of the
    configuration file. The file has four items: `desc`, `in`, `out` and
    `exe`. Where:

    ``` literallayout
    desc         : Is the description shown in GCGB
    in           : Is the source file extension to be transformed
    out          : Is the target transformed file extension.
    exe          : Is the executable to be run for this specific configuration file.
    params       : Optional, is the required parameter to be passed from the compiler.  Example:  params = %filename% %chipmodel%
    deletetarget : Optional, will always recreate the target transformed file. The default is to retain the target transformed file unless source has changed. Options are Y or N
    ```

    You can have multiple configuration files within the
    `..\converters folder structure`.

    GCBASIC will examine all configuration file to match the extension
    as specified in the `#include` command.

    <span class="strong">**Example 1 :**</span>

    <div class="informalexample">

    BMP (Black and White) conversion configuration file is called
    `BMP2GCBasic.ini`. The source extension is `.bmp`, the transformed
    file extension is `.GCB`, and the executable is called
    `BMP2GCBASIC.exe`.

    ``` literallayout
    desc = BMP file (*.bmp)
    in = bmp
    out = GCB
    exe = BMP2GCBASIC .exe
    ```

    An example :

    ``` literallayout
    #include <..\converters\ManLooking.BMP>
    ```

    Will be converted by the `BMP2GCBASIC .EXE` to
    `..\converters\ManLooking.GCB`

    </div>

    <span class="strong">**Example 2 :**</span>

    <div class="informalexample">

    Data file conversion configuration file is called `TXT2GCB.ini`. The
    source extension is `.TXT`, the transformed file extension is
    `.GCB`, and the command line called `AWKRUN.BAT` .

    ``` literallayout
    desc = Infrared Patterns (*.txt)
    in = txt
    out = GCB
    exe = awkrun.bat
    ```

    An example :

    ``` literallayout
    #include <..\converters\InfraRedPatterns.TXT>
    ```

    Will be converted by the `AWKRUN.BAT` to
    `..\converters\ InfraRedPatterns.GCB`

    The example would require a supporting batch file and a script
    process to complete the transformation.

    </div>

2.  Conversion Executable

    The conversion executable may be written in any language (compiled
    or interpreted).

    The conversion executable MUST create the converted file with the
    correct file extension as specified in the configuration file.

    The conversion executable will be passed one parameter - the source
    file name. Using example \#1 the conversion executable would be
    passed `..\converters\ManLooking.BMP`

    The conversion executable MUST create a GCBASIC compatible source
    file. Any valid commands/instruction are permitted.

3.  Installation

    The `INI` file, the source file and the conversion executable MUST
    be located in the `..\converters folder`. The converters folder is
    relative to the `GCBASIC.EXE` compiler folder.

</div>

<span id="XX0"></span><span class="strong">**Example 3 : Converter
Program**</span>

<div class="informalexample">

This program converts the `InfraRedPatterns.TXT` into
`InfraRedPatterns.GCB` that will have a GCBASIC table called
`DataSource`. This example is located in the converter folder of the
GCBASIC installation.

``` screen
  #chip16f877a, 16
  #include <..\converters\InfraRedPatterns.TXT>

  dir portb out

  ' These must be WORDs as this could be large table.
  dim TableReadPosition, TableLen as word

  dir portb out

  ' Read the table length
  TableReadPosition = 0
  ReadTable DataSource, TableReadPosition, TableLen


  Do Forever
      For TableReadPosition = 1 to TableLen step 2
          ReadTable DataSource, TableReadPosition, TransmissionPattern
          ReadTable DataSource, TableReadPosition+1 , PulseDelay
          portb = TransmissionPattern
          wait PulseDelay ms
      next
  Loop
```

</div>

<span class="strong">**Example 4 : Dynamic Import**</span>

<div class="informalexample">

This program converts a chip specific configuration file into
`manifest.GCB` that will have a GCBASIC functions called `DataIn` and
`DataOut`. This example is located in the converter folder of the
GCBASIC installation.

``` screen
    #chip 16f18326

    #include <..\converters\manifest.mcc>

    DataOut ( TX, RA0 )  'this method is created during the convert process. They do not exist withiut the converter.
    DataIn  ( Rx, RC6 )  'this method is created during the convert process. They do not exist withiut the converter.
```

This example would use the optional parameters of `params` and
`deletetarget` in the converter configuration file as follows:

``` screen
    desc = PPS file (*.PPS)
    params = %filename% %chipmodel%
    in = mcc
    out = GCB
    exe = DataHandler.exe
    deletetarget= y
```

</div>

<span class="strong">**Example 5 : Add build numbers and time/date
details to your programs**</span>

This converter is used to expose two string variables as follows:

``` screen
    GCBBuildStr
    GCBBuildTimeStr
```

The user code is simple. Using the \#include statement specify any
filename with an extension must be `cnt`. As follows:

``` screen
    #include "GCBVersionNumber.cnt"
```

Complete code would like this - this not optimised - this shows the use
of the exposed strings.

``` screen
    #include "GCBVersionNumber.cnt"

    dim versionString as string * 40
    versionString = "Max7219 build"+GCBBuildStr
    versionString = versionString + "@"+GCBBuildTimeStr
    Print versionString
```

This outputs the following - where \#20 is the current build and the
date/time is correct for build time.

``` screen
    Max7219 build20@01-06-2021 08:00:21
    Commence main program
```

This works as the support INI file instructs the compiler to call a
utility that automatically creates a build number tracker file and the
supportting string functions. The utility creates a tracker file and the
methods files in the same folder as your source program - so, each
tracker is specific to each project. The converter requires the
following files - these are included within your Installation.

``` screen
    GCBVersionStamp.exe - the utility called by the converter capability.
    cnt2gcb.ini - the supporting ini file used by the compiler to handle this converter.
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Dataset for EEPROM</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_mcu_eeprom_dfm.html" title="MCU EEPROM ( DFM )"><link rel="prev" href="_epwrite.html" title="EPWrite"><link rel="next" href="_hefm_pfm.html" title="HEFM ( PFM )"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_dataset_for_eeprom"></a>Dataset for EEPROM</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">        EEPROM DataSetName [[,]address]
            // multiples values, strings etc.
            0,1,2,3
        END EEPROM</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC microcontrollers with EEPROM memory.
AVR support required use of AVR-ASM assembler.&nbsp;&nbsp;GCASM does not support AVR EEPROM operations.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The EEPROM construct creates an EEPROM dataset for use with the specific microcontroller.&nbsp;&nbsp;An EEPROM dataset is a list of values that are stored in the EEPROM memory of the microcontroller, which then can be accessed using the EPREAD() command or other EEPROM read operations.</p><p>The advantage of an EEPROM dataset is that they are memory efficient being loaded directly into the EEPROM during programming operations.</p><p>EEPROM datasets are defined as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Byte values,</li><li class="listitem">EEPROM addresses and EEPROM datasets CANNOT overlap,</li><li class="listitem">EEPROM addresses must not overlap TABLE data,</li><li class="listitem">TABLE data has precedence from address 0x00 until the the end of TABLE all data,</li><li class="listitem">Strings must be expressed as ASCII byte value(s),</li><li class="listitem">Multiple elements on a single line separated by commas,</li><li class="listitem">Constants and calculations within the single line dataset entries are permitted,</li><li class="listitem">Decimal values are NOT supported,</li><li class="listitem">Access is via EPRread(), not supported by READTABLE().</li><li class="listitem">18F devices must use even address for EEPROM location, and, 18F will pad (with 0x00) datasets to even number length.&nbsp;&nbsp;This is MPASM constraint and therefore the compiler and assembler will isssue specific error messages for odd EEPROM locations.
<br>
<br></li></ol></div><p><span class="strong"><strong>Defining EEPROM datasets</strong></span></p><p><span class="emphasis"><em>Single data values</em></span></p><p>A single value on each line with in the dataset.&nbsp;&nbsp;The example dataset, shown below, has the data on different line in within the set.</p><p>Simple example: This creates an EEPROM dataset at the first EEPROM location, then, the values of 12, 24, &#8230;&#8203; 72 are the consecutive values.</p><pre class="screen">        EEPROM EEDataSet
            12
            24
            36
            48
            60
            72
        End EEPROM</pre><p><span class="emphasis"><em>Multiple data values of the same line</em></span></p><p>The following example creates the EEPROM dataset at EEPROM offset address of 0x10.&nbsp;&nbsp;</p><p>Multiple elements on a single line separated by commas.&nbsp;&nbsp;The example dataset, shown below, has the data separated by <code class="literal">,</code> and on different line in within the dataset.</p><pre class="screen">        EEPROM EEDataSource  0x10
            12,  24, 36
            48,  60, 72
        End EEPROM</pre><p><span class="emphasis"><em>Data values as constants, and, with data transformation</em></span></p><p>Constants and calculations within the single line.  &nbsp;&nbsp;The example dataset, shown below, uses a defined constant to multiple the data with the dataset.</p><pre class="screen">        #define calculation_constant 2

        EEPROM EEDataSource  0x20
        1 * calculation_constant
        2 * calculation_constant
        3 * calculation_constant
        8 * calculation_constant
        4 * calculation_constant
        5 * calculation_constant
        End EEPROM</pre><p>&nbsp;&nbsp;
&nbsp;&nbsp;</p><p><span class="emphasis"><em>Data values as Strings</em></span></p><p>Strings can be defined.&nbsp;&nbsp;Strings are delimited by double quotes. &nbsp;&nbsp; The following examples show the methods.</p><p>Any ASCII characters between any two "    " (double quotes) will be converted to dataset data.&nbsp;&nbsp; Also see ASCII escape codes.</p><p>A source string can be one string per line or comma separated strings, therefore, on the same line.</p><p>Example:</p><pre class="screen">    EEPROM Test_1
     "ABCDEFGHIJ"
    End EEPROM</pre><p><span class="emphasis"><em>ASCII Escape code</em></span></p><p>Accepted escape strings are shown in the dataset below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Escape sequence</th><th align="left" valign="top">Meaning</th></tr></thead><tbody><tr><td align="left" valign="top"><p>\a</p></td><td align="left" valign="top"><p>beep</p></td></tr><tr><td align="left" valign="top"><p>\b</p></td><td align="left" valign="top"><p>backspace</p></td></tr><tr><td align="left" valign="top"><p>\f</p></td><td align="left" valign="top"><p>formfeed</p></td></tr><tr><td align="left" valign="top"><p>\l or \n</p></td><td align="left" valign="top"><p>newline</p></td></tr><tr><td align="left" valign="top"><p>\r</p></td><td align="left" valign="top"><p>carriage return</p></td></tr><tr><td align="left" valign="top"><p>\t</p></td><td align="left" valign="top"><p>tab</p></td></tr><tr><td align="left" valign="top"><p>\0</p></td><td align="left" valign="top"><p>Null value, equates to ASCII 0. Same as \&amp;000</p></td></tr><tr><td align="left" valign="top"><p>\&amp;nnn</p></td><td align="left" valign="top"><p>ascii char in decimal</p></td></tr><tr><td align="left" valign="top"><p>\\</p></td><td align="left" valign="top"><p>backslash</p></td></tr><tr><td align="left" valign="top"><p>\"</p></td><td align="left" valign="top"><p>double quote</p></td></tr><tr><td align="left" valign="top"><p>\'</p></td><td align="left" valign="top"><p>single quote</p></td></tr></tbody></table></div><p><span class="strong"><strong>Complete working example program</strong></span></p><p>This example creates several EEPROM datasets.&nbsp;&nbsp;The example also create a lookup table.&nbsp;&nbsp;The EEPROM dataset are addressed with the additional parameter to ensure there is no EEPROM dataset overlap.&nbsp;&nbsp;</p><pre class="screen">        #chip 16F886
        #option explicit

        #DEFINE USART_BAUD_RATE 9600
        #DEFINE USART_TX_BLOCKING
        #DEFINE USART_DELAY OFF

        Dim EEdataaddress, myvar as Byte
        EEdataaddress = 2

        Readtable TwoBytes,EEdataaddress,myVar
        HSerPrint myVar


        // *********************** EXAMPLE EE DATA ************************
        // * THIS IS ONLY ACCESSIBLE VIA EPREAD or other EE read functions.
        /*
        Usage:      EEProm EEPromBlockName [[,] OffSet Address ]
                    OffSet address defaults to 0x00 if not stated.

                    Addresses and datasets CANNOT overlap.
                    Addresses must not overlap TABLE data.
                    TABLE data has precendence from address 0x00 until the the end of TABLE data
        */


        EEProm EEDataSet1 0x10    // Locate EE Data at address
        3,2,1
        End EEProm

        EEProm VersionData 0x20   // Locate EE Data at address
        "    PWM2Laser   "
        "  Fabrice ENGEL "
        "   Version 1.4  "
        "  November 2023 "
        End EEProm

        EEProm EEDataSet2 0x0D    // Locate EE Data at address
        1,2,3
        End EEProm

        EEProm EEDataSet 0X04     // Locate EE Data at address
        1,2,3
        End EEProm

        // **********************  EXAMPLE TABLE DATA BEING LOADED INTO EE BY THE COMIPILER
        // *                       THIS IS ONLY ACCESSIBLE VIA READTABLE

        Table TwoBytes STORE data // EE Data Address Allocated by compiler
            0X55,0XAA,0X55
        End Table</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_epread.html" title="EPRead">EPRead</a>, <a class="link" href="_lookup_tables.html" title="Lookup Tables">Creating EEProm data from a Lookup Table</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="dataset_for_eeprom"></span>Dataset for EEPROM

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
        EEPROM DataSetName [[,]address]
            // multiples values, strings etc.
            0,1,2,3
        END EEPROM
```

<span class="strong">**Command Availability:**</span>

Available on all PIC microcontrollers with EEPROM memory. AVR support
required use of AVR-ASM assembler.  GCASM does not support AVR EEPROM
operations.

<span class="strong">**Explanation:**</span>

The EEPROM construct creates an EEPROM dataset for use with the specific
microcontroller.  An EEPROM dataset is a list of values that are stored
in the EEPROM memory of the microcontroller, which then can be accessed
using the EPREAD() command or other EEPROM read operations.

The advantage of an EEPROM dataset is that they are memory efficient
being loaded directly into the EEPROM during programming operations.

EEPROM datasets are defined as follows:

<div class="orderedlist">

1.  Byte values,
2.  EEPROM addresses and EEPROM datasets CANNOT overlap,
3.  EEPROM addresses must not overlap TABLE data,
4.  TABLE data has precedence from address 0x00 until the the end of
    TABLE all data,
5.  Strings must be expressed as ASCII byte value(s),
6.  Multiple elements on a single line separated by commas,
7.  Constants and calculations within the single line dataset entries
    are permitted,
8.  Decimal values are NOT supported,
9.  Access is via EPRread(), not supported by READTABLE().
10. 18F devices must use even address for EEPROM location, and, 18F will
    pad (with 0x00) datasets to even number length.  This is MPASM
    constraint and therefore the compiler and assembler will isssue
    specific error messages for odd EEPROM locations.  
      

</div>

<span class="strong">**Defining EEPROM datasets**</span>

<span class="emphasis">*Single data values*</span>

A single value on each line with in the dataset.  The example dataset,
shown below, has the data on different line in within the set.

Simple example: This creates an EEPROM dataset at the first EEPROM
location, then, the values of 12, 24, …​ 72 are the consecutive values.

``` screen
        EEPROM EEDataSet
            12
            24
            36
            48
            60
            72
        End EEPROM
```

<span class="emphasis">*Multiple data values of the same line*</span>

The following example creates the EEPROM dataset at EEPROM offset
address of 0x10.  

Multiple elements on a single line separated by commas.  The example
dataset, shown below, has the data separated by `,` and on different
line in within the dataset.

``` screen
        EEPROM EEDataSource  0x10
            12,  24, 36
            48,  60, 72
        End EEPROM
```

<span class="emphasis">*Data values as constants, and, with data
transformation*</span>

Constants and calculations within the single line.   The example
dataset, shown below, uses a defined constant to multiple the data with
the dataset.

``` screen
        #define calculation_constant 2

        EEPROM EEDataSource  0x20
        1 * calculation_constant
        2 * calculation_constant
        3 * calculation_constant
        8 * calculation_constant
        4 * calculation_constant
        5 * calculation_constant
        End EEPROM
```

     

<span class="emphasis">*Data values as Strings*</span>

Strings can be defined.  Strings are delimited by double quotes.    The
following examples show the methods.

Any ASCII characters between any two " " (double quotes) will be
converted to dataset data.   Also see ASCII escape codes.

A source string can be one string per line or comma separated strings,
therefore, on the same line.

Example:

``` screen
    EEPROM Test_1
     "ABCDEFGHIJ"
    End EEPROM
```

<span class="emphasis">*ASCII Escape code*</span>

Accepted escape strings are shown in the dataset below.

<div class="informaltable">

| Escape sequence | Meaning                                        |
|:----------------|:-----------------------------------------------|
| \\a             | beep                                           |
| \\b             | backspace                                      |
| \\f             | formfeed                                       |
| \\l or \\n      | newline                                        |
| \\r             | carriage return                                |
| \\t             | tab                                            |
| \\0             | Null value, equates to ASCII 0. Same as \\&000 |
| \\&nnn          | ascii char in decimal                          |
| \\\\            | backslash                                      |
| \\"             | double quote                                   |
| \\'             | single quote                                   |

</div>

<span class="strong">**Complete working example program**</span>

This example creates several EEPROM datasets.  The example also create a
lookup table.  The EEPROM dataset are addressed with the additional
parameter to ensure there is no EEPROM dataset overlap.  

``` screen
        #chip 16F886
        #option explicit

        #DEFINE USART_BAUD_RATE 9600
        #DEFINE USART_TX_BLOCKING
        #DEFINE USART_DELAY OFF

        Dim EEdataaddress, myvar as Byte
        EEdataaddress = 2

        Readtable TwoBytes,EEdataaddress,myVar
        HSerPrint myVar


        // *********************** EXAMPLE EE DATA ************************
        // * THIS IS ONLY ACCESSIBLE VIA EPREAD or other EE read functions.
        /*
        Usage:      EEProm EEPromBlockName [[,] OffSet Address ]
                    OffSet address defaults to 0x00 if not stated.

                    Addresses and datasets CANNOT overlap.
                    Addresses must not overlap TABLE data.
                    TABLE data has precendence from address 0x00 until the the end of TABLE data
        */


        EEProm EEDataSet1 0x10    // Locate EE Data at address
        3,2,1
        End EEProm

        EEProm VersionData 0x20   // Locate EE Data at address
        "    PWM2Laser   "
        "  Fabrice ENGEL "
        "   Version 1.4  "
        "  November 2023 "
        End EEProm

        EEProm EEDataSet2 0x0D    // Locate EE Data at address
        1,2,3
        End EEProm

        EEProm EEDataSet 0X04     // Locate EE Data at address
        1,2,3
        End EEProm

        // **********************  EXAMPLE TABLE DATA BEING LOADED INTO EE BY THE COMIPILER
        // *                       THIS IS ONLY ACCESSIBLE VIA READTABLE

        Table TwoBytes STORE data // EE Data Address Allocated by compiler
            0X55,0XAA,0X55
        End Table
```

<span class="strong">**For more help, see
<a href="epread" class="link" title="EPRead">EPRead</a>,
<a href="lookup_tables" class="link" title="Lookup Tables">Creating EEProm data from a Lookup Table</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Data Types</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microcontroller_fundamentals.html" title="Microcontroller Fundamentals"><link rel="prev" href="_configuration.html" title="Configuration"><link rel="next" href="_variable_types.html" title="Variable Types"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_data_types"></a>Data Types</h3></div></div></div><p>This section discusses the different types and sizes of data variables used by GCBASIC, and how they are interpreted or handled by GCBASIC methods.</p><p>The section also provides an insight of which type of variable to use and when.</p><p><span class="strong"><strong>What variable sizes are suported by GCBASIC?</strong></span></p><p>GCBASIC implements support for Bit, Byte, Word, Integer and Long Variable Types, all of which are described below.</p><p>Supported variables are <span class="strong"><strong>Bit</strong></span> (1 Bit), <span class="strong"><strong>Byte</strong></span> (8 Bit), <span class="strong"><strong>Word</strong></span> (16 Bit), <span class="strong"><strong>Long</strong></span> (32 Bit).  GCBASIC does not support decimal numbers.</p><p><span class="strong"><strong>Bit</strong></span> is used as a Flag or a Port Pin and has two states which may be:</p><pre class="screen">    ON or OFF
    TRUE or FALSE
    HIGH or LOW
    1 or 0
    SET or RESET</pre><p>other complementary states depending on how your application interprets and handles the data.</p><p><span class="strong"><strong>Byte</strong></span> is the most common size in 8 Bit devices and could represent a Number, an ASCII Character, a Port, two Nibbles (as used by Hex or BCD number systems), an Internal Register, an 8 bit Variable or any user defined collection of to eight Bits such as a group of flags.</p><p><span class="strong"><strong>Word</strong></span> is normally used for its Numeric value. 16 Bits will allow it to store Numbers from Zero to 65535 which is large enough to store the product of any two 8 bit Bytes without overflowing. &nbsp;&nbsp;However, it is not confined to being used as a numeric value.&nbsp;&nbsp; A Word may be used in any manner that your application needs depending on how it interprets the 16 Bits of data. Examples may be a memory address or a data pointer.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="strong"><strong>Note:</strong></span> The Word size of a device (as opposed to the Word Type above) is a representation of the number of Bits that it can manipulate simultaneously by the chip. &nbsp;&nbsp; The number of Bits for PIC and AVR Microcontrolers supported by GCBASIC are 8 Bits and so they are considered to have an 8 Bit Word.*</li></ul></div><p><span class="strong"><strong>Long</strong></span> is for situations where Values exceeding 65535 have to be handled and has a range of zero to 4294967295 (2^32-1).&nbsp;&nbsp;It is rarely used in 8 Bit devices but is invaluable on the rare occasions that it is needed. &nbsp;&nbsp; The Millis() is an example that  uses the Long Data Type to handle time periods of up to 50 days.</p><p>All of the above can be considered to be Integer Values of varying magnitude as they can hold non Fractional Positive Whole Numbers, but try not to confuse <span class="strong"><strong>Integer Values</strong></span> with the <span class="strong"><strong>Integer Variable Type</strong></span>, they are complementary but separate concepts as you will see below.</p><p>An <span class="strong"><strong>integer</strong></span> is a whole number (not a fractional number) that can be Positive, Negative, or Zero.</p><p>In your application there may be a need to be able represent Negative Numbers in our variables and that is where the GCBASIC <span class="strong"><strong>Integer Variable Type</strong></span> is useful.  An <span class="strong"><strong>Integer Variable</strong></span> is similar to the <span class="strong"><strong>Word Variable</strong></span> as they are both 16 bits. &nbsp;&nbsp; The difference how the GCBASIC compiler interprets the data bits that it contains.</p><p>The compiler will treat a <span class="strong"><strong>Word Variable Type</strong></span> as a Variable that can store the values 0 &lt; 65535 but it will see the <span class="strong"><strong>Integer Variable Type</strong></span> as a Variable that can store values of -32768 &lt; 0 &lt;32767.</p><p><span class="strong"><strong>Variable size</strong></span></p><p>Each type of variable is defined in various bit lengths, in this case GCBASIC  these are:</p><pre class="screen">    Byte                 8 Bit
    Integer             16 Bit
    Word                16 Bit
    Long                32 Bit</pre><p>All four of the above are number types are true Integers. &nbsp;&nbsp;In that they are representations of a integer non fractional number as follows:</p><pre class="screen">    8  Bit - an 8 Bit number can be in the range of 0 to 255
    16 Bit - a 16 Bit number can be in the range of 0 to 65535
    32 Bit - a 32 Bit number can be in the range of 0 to 43294967295</pre><p>But, they can only represent positive numbers. &nbsp;&nbsp;In Mathematics there is a need for an Integer that can be Positive, Negative, or Zero. &nbsp;&nbsp;Note that Zero is always a Positive Whole Number.</p><p><span class="strong"><strong>Two&#8217;s Complement</strong></span></p><p>To take the Two&#8217;s Complement of a number it is inverted then incremented:</p><pre class="screen">        MyVar = NOT MyVar + 1</pre><p>The increment, of adding 1, has two effects, it avoids the possible creation of a negative zero as a value of 1000000 would be seen as -128 and it allows subtraction to be achieved through addition.</p><p>If MyVar contained a value of 1 the 8 Bit representation would be:</p><pre class="screen">    00000001</pre><p>The NOT will make it</p><pre class="screen">    11111110</pre><p>Note that the Most significant Bit is now 1 so as a signed value it is negative.</p><p>The increment will result in a value of:</p><pre class="screen">    11111111</pre><p>So Minus one using an 8 Bit representation in Two&#8217;s Complement notation is 11111111</p><p>Let&#8217;s test it by adding -1 to plus 3</p><pre class="screen">    11111111    -1
    00000011 +   3
    ==============
    00000010     2</pre><p>We have successfully subtracted 1 from 3 by adding Minus 1 to 3 and obtaining a result of 2.</p><p>Notice that while a Byte is normally used to represent 0 &lt; 255 by making the MSB (Most Significant Bit) into a sign bit the maximum value is now 127.&nbsp;&nbsp; A signed 8 Bit integer can represent numbers in the range -128 &lt; 0 &lt; 127. &nbsp;&nbsp;That is still 256 values including Zero but they can now be Negative or Positive numbers.</p><p>The benefit of the two&#8217;s complement method is that it works for any size of variable:</p><pre class="screen">    MyByte = NOT MyByte +1
    MyWord = NOT MyWord +1
    MyLong = NOT MyLong +1</pre><p>All of the above will result in a Negated version of the original contents.</p><p>But not all, in fact relatively few, methods of a microcontroller require negative values so in situations where negative values are not required the loss of half of the magnitude of a Byte or Word can be significant. That is why it is necessary to be able to specify if a value is Signed or Unsigned, that is if the MSB is the sign bit or part of the value.</p><p>It is obviously important from the above that the user program ds need to know what sort of data to expect as a value of 0xFF could be considered to be both 255 and -1 depending on the interpretation of the variable. &nbsp;&nbsp; That is why it is important to have Signed and Unsigned Data Types so that the compiler can decide how to handle or interpret the contents. &nbsp;&nbsp;As show above in GCBASIC those types are referred to as Integer and Word respectively.</p><p><span class="strong"><strong>Summary</strong></span></p><p>GCBASIC implements support for Bit, Byte, Word, Integer and Long Variable Types, all of which are described above.</p><p>And, that negative numbers are represented as two&#8217;s complement.&nbsp;&nbsp;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="data_types"></span>Data Types

</div>

</div>

</div>

This section discusses the different types and sizes of data variables
used by GCBASIC, and how they are interpreted or handled by GCBASIC
methods.

The section also provides an insight of which type of variable to use
and when.

<span class="strong">**What variable sizes are suported by
GCBASIC?**</span>

GCBASIC implements support for Bit, Byte, Word, Integer and Long
Variable Types, all of which are described below.

Supported variables are <span class="strong">**Bit**</span> (1 Bit),
<span class="strong">**Byte**</span> (8 Bit), <span
class="strong">**Word**</span> (16 Bit), <span
class="strong">**Long**</span> (32 Bit). GCBASIC does not support
decimal numbers.

<span class="strong">**Bit**</span> is used as a Flag or a Port Pin and
has two states which may be:

``` screen
    ON or OFF
    TRUE or FALSE
    HIGH or LOW
    1 or 0
    SET or RESET
```

other complementary states depending on how your application interprets
and handles the data.

<span class="strong">**Byte**</span> is the most common size in 8 Bit
devices and could represent a Number, an ASCII Character, a Port, two
Nibbles (as used by Hex or BCD number systems), an Internal Register, an
8 bit Variable or any user defined collection of to eight Bits such as a
group of flags.

<span class="strong">**Word**</span> is normally used for its Numeric
value. 16 Bits will allow it to store Numbers from Zero to 65535 which
is large enough to store the product of any two 8 bit Bytes without
overflowing.   However, it is not confined to being used as a numeric
value.   A Word may be used in any manner that your application needs
depending on how it interprets the 16 Bits of data. Examples may be a
memory address or a data pointer.

<div class="itemizedlist">

-   <span class="strong">**Note:**</span> The Word size of a device (as
    opposed to the Word Type above) is a representation of the number of
    Bits that it can manipulate simultaneously by the chip.    The
    number of Bits for PIC and AVR Microcontrolers supported by GCBASIC
    are 8 Bits and so they are considered to have an 8 Bit Word.\*

</div>

<span class="strong">**Long**</span> is for situations where Values
exceeding 65535 have to be handled and has a range of zero to 4294967295
(2^32-1).  It is rarely used in 8 Bit devices but is invaluable on the
rare occasions that it is needed.    The Millis() is an example that
uses the Long Data Type to handle time periods of up to 50 days.

All of the above can be considered to be Integer Values of varying
magnitude as they can hold non Fractional Positive Whole Numbers, but
try not to confuse <span class="strong">**Integer Values**</span> with
the <span class="strong">**Integer Variable Type**</span>, they are
complementary but separate concepts as you will see below.

An <span class="strong">**integer**</span> is a whole number (not a
fractional number) that can be Positive, Negative, or Zero.

In your application there may be a need to be able represent Negative
Numbers in our variables and that is where the GCBASIC <span
class="strong">**Integer Variable Type**</span> is useful. An <span
class="strong">**Integer Variable**</span> is similar to the <span
class="strong">**Word Variable**</span> as they are both 16 bits.    The
difference how the GCBASIC compiler interprets the data bits that it
contains.

The compiler will treat a <span class="strong">**Word Variable
Type**</span> as a Variable that can store the values 0 &lt; 65535 but
it will see the <span class="strong">**Integer Variable Type**</span> as
a Variable that can store values of -32768 &lt; 0 &lt;32767.

<span class="strong">**Variable size**</span>

Each type of variable is defined in various bit lengths, in this case
GCBASIC these are:

``` screen
    Byte                 8 Bit
    Integer             16 Bit
    Word                16 Bit
    Long                32 Bit
```

All four of the above are number types are true Integers.   In that they
are representations of a integer non fractional number as follows:

``` screen
    8  Bit - an 8 Bit number can be in the range of 0 to 255
    16 Bit - a 16 Bit number can be in the range of 0 to 65535
    32 Bit - a 32 Bit number can be in the range of 0 to 43294967295
```

But, they can only represent positive numbers.   In Mathematics there is
a need for an Integer that can be Positive, Negative, or Zero.   Note
that Zero is always a Positive Whole Number.

<span class="strong">**Two’s Complement**</span>

To take the Two’s Complement of a number it is inverted then
incremented:

``` screen
        MyVar = NOT MyVar + 1
```

The increment, of adding 1, has two effects, it avoids the possible
creation of a negative zero as a value of 1000000 would be seen as -128
and it allows subtraction to be achieved through addition.

If MyVar contained a value of 1 the 8 Bit representation would be:

``` screen
    00000001
```

The NOT will make it

``` screen
    11111110
```

Note that the Most significant Bit is now 1 so as a signed value it is
negative.

The increment will result in a value of:

``` screen
    11111111
```

So Minus one using an 8 Bit representation in Two’s Complement notation
is 11111111

Let’s test it by adding -1 to plus 3

``` screen
    11111111    -1
    00000011 +   3
    ==============
    00000010     2
```

We have successfully subtracted 1 from 3 by adding Minus 1 to 3 and
obtaining a result of 2.

Notice that while a Byte is normally used to represent 0 &lt; 255 by
making the MSB (Most Significant Bit) into a sign bit the maximum value
is now 127.   A signed 8 Bit integer can represent numbers in the range
-128 &lt; 0 &lt; 127.   That is still 256 values including Zero but they
can now be Negative or Positive numbers.

The benefit of the two’s complement method is that it works for any size
of variable:

``` screen
    MyByte = NOT MyByte +1
    MyWord = NOT MyWord +1
    MyLong = NOT MyLong +1
```

All of the above will result in a Negated version of the original
contents.

But not all, in fact relatively few, methods of a microcontroller
require negative values so in situations where negative values are not
required the loss of half of the magnitude of a Byte or Word can be
significant. That is why it is necessary to be able to specify if a
value is Signed or Unsigned, that is if the MSB is the sign bit or part
of the value.

It is obviously important from the above that the user program ds need
to know what sort of data to expect as a value of 0xFF could be
considered to be both 255 and -1 depending on the interpretation of the
variable.    That is why it is important to have Signed and Unsigned
Data Types so that the compiler can decide how to handle or interpret
the contents.   As show above in GCBASIC those types are referred to as
Integer and Word respectively.

<span class="strong">**Summary**</span>

GCBASIC implements support for Bit, Byte, Word, Integer and Long
Variable Types, all of which are described above.

And, that negative numbers are represented as two’s complement.  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>DecToBcd_GCB</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_bcdtodec_gcb.html" title="BcdToDec_GCB"><link rel="next" href="_rotate.html" title="Rotate"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_dectobcd_gcb"></a>DecToBcd_GCB</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen"> DectoBcd( ByteVariable )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Converts numbers from Decimal to Binary Coded Decimal format. Support Bytes only.</p><p>You can add this function. Just add this to your GCBASIC program and then call it when you need it.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    Function DecToBcd(va) as Byte
       DecToBcd=(va/10)*16+va%10
    End Function</pre><p><span class="strong"><strong>Also see</strong></span> <a class="link" href="_bcdtodec_gcb.html" title="BcdToDec_GCB">BcdToDec_GCB</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="dectobcd_gcb"></span>DecToBcd\_GCB

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
 DectoBcd( ByteVariable )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

Converts numbers from Decimal to Binary Coded Decimal format. Support
Bytes only.

You can add this function. Just add this to your GCBASIC program and
then call it when you need it.

<span class="strong">**Example:**</span>

``` screen
    Function DecToBcd(va) as Byte
       DecToBcd=(va/10)*16+va%10
    End Function
```

<span class="strong">**Also see**</span>
<a href="bcdtodec_gcb" class="link" title="BcdToDec_GCB">BcdToDec_GCB</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Development Guide</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_gcbasic_maintenance_and_development.html" title="GCBASIC Maintenance and Development"><link rel="prev" href="_gcbasic_maintenance.html" title="GCBASIC Maintenance"><link rel="next" href="_development_guide_for_gcbasic_exe_compiler.html" title="Development Guide for GCBASIC.EXE compiler"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_development_guide"></a>Development Guide</h3></div></div></div><p>There are lots of ways to contribute to the GCBASIC project: coding, testing, improving the build process and tools, or contributing to the documentation.
This guide provides information that will not only help you get started as a GCBASIC contributor,
but that you wiil find useful to refer to EVEN if you are already an experienced contributor.</p><p><span class="strong"><strong>Need Help?</strong></span></p><p>The GCBASIC community prides itself on being an open, accessible, and friendly community for new participants.
If you have any difficulties getting involved or finding answers to your questions, please bring those questions to the forum via the discussion boards, where we can help you get started.</p><p>We know EVEN before you start contributing that getting set up to work on GCBASIC and finding a bug that is a good fit for your skills can be a challenge.
We are always looking for ways to improve this process: making GCBASIC more open, accessible, and easier to participate with.
If you are having any trouble following this documentation, or hit a barrier you cannot get around, please contact use via the discussion forum.
We will solve hurdles for new contributors and make GCBASIC better.</p><p>This section addresses developing libraries but this guide is appropriate to any GCBASIC development.</p><p>The section covers the recommended programming style, Constants, Variables, Script syntax (gotchas) and tab usage.</p><p></p><p><span class="strong"><strong>PROGRAMMING STYLES</strong></span></p><p>Indenting is standardized.</p><p>All scripts within a specific library should be the first major section the library.   Scripts within methods should not be used.</p><p>Some #defines may need to be placed before the script to provide clarity to the structure of the library.</p><pre class="screen">        #startup  startupsub

        #Define I2C_ADDRESS_1  0x4E    'The default address if user does not specify in the user program

        #SCRIPT
                ... code script
                ... code script
                ... code script
       #ENDSCRIPT</pre><p>Scripts support structures like IF &lt;CONDITION&gt; THEN &lt;ACTION&gt; END iF.
Scripts supports the &lt;condition&gt; argument that must generate a TRUE result, meaning that at a literal level, your conditional formatting rule is an If - THEN statement along the lines of &#8220;If this condition is TRUE, THEN process the &lt;ACTION&gt;.  the condition must use   logical "AND" and "OR" to test two conditions.
Using "AND" or "OR" reduces the script size, however, it is essential the the conditional test(s) are valid.  If a test fails then  you may not get the results you expect.</p><pre class="screen">        IF .. THEN

        END IF</pre><p></p><p><span class="strong"><strong>CONSTANTS</strong></span></p><p>A constant is a value that cannot be altered by the program during normal execution.&nbsp;&nbsp;
Within GCBASIC there are two ways to create constants.&nbsp; &nbsp;
1. with the <code class="literal">#DEFINE</code> instruction, or,
2. via `#SCRIPT .. #ENDSCRIPT'. ;&nbsp;&nbsp; Within a script constants can be created and changed.  A script is process that is executed  prior to the GCBASIC source program is processing the main user program.</p><p>An example of using <code class="literal">#DEFINE</code> is</p><pre class="screen">        #DEFINE TIME_DELAY_VALUE    10</pre><p>The script construct is</p><pre class="screen">        #SCRIPT
              'Create a constant
              TIME_REPEAT_VALUE  =  10
        #ENDSCRIPT</pre><p><span class="strong"><strong><span class="emphasis"><em>Guide for constants</em></span></strong></span></p><p>The following rules are recommended.</p><p>1 - All CONSTANTS are capitalized</p><p>2 - Do not define a constant in a library unless required</p><p>3 - Create all library constants within a script ( see example below <span class="strong"><strong>Constrain a Constant Example</strong></span> on how to constrain a constant)</p><p>2 - Underscores are permitted in constant names within Scripts **</p><p>3 - No prefix is required when a CONSTANT is PUBLIC.  A PUBLIC constant is one that the user sets or the user can use.</p><p>4 - Prefix CONSTANTS with SCRIPT_  when the CONSTANT is used outside of the library specific script section AND ARE NOT EXPOSED AS PUBLIC Constants.</p><p>5 - Prefix CONSTANTS with __ (two underscores)  when the CONSTANT is ONLY used inside the library specific script section</p><p>6 - For PUBLIC prefix CONSTANTS with the capability name, _ (one underscore)  and then a meaningful title, as follows
            GLCD_HEIGHT
            SPISRAM_TYPE</p><p>7 - All scripts within a specific library should be the first major section the library.   Scripts within methods  ( Sub, Functions) should not be used.</p><p>8 - All scripts within a specific library should be the first major section the library.   Scripts within methods  ( Sub, Functions) should not be used.</p><p>9 - Other naming recommendations.   Do not use underscores in subroutine, function or variable names</p><p><span class="strong"><strong><span class="emphasis"><em>Example script within a library</em></span></strong></span></p><pre class="screen">          #startup  startupsub
          #DEFINE I2C_ADDRESS_1  0x4E    'Default address if user omits
          #SCRIPT
                'script code
                'script code
                'script code
          #ENDSCRIPT</pre><p><span class="strong"><strong><span class="emphasis"><em>Simple Example</em></span></strong></span></p><pre class="screen">     #SCRIPT  'Calculate Delay Time
             __LCD_DELAY  = ( __LCD_TIMEPERIOD - __LCD_DELAYS) - (INT((4/ChipMHZ) * __LCD_INSTRUCTIONS))
            SCRIPT_LCD_POSTWRITEDELAY = __LCD_DELAY
            SCRIPT_LCD_CHECKBUSYFLAG = TRUE
     #ENDSCRIPT

     'usage within user code or code outside of script
     #IF SCRIPT_LCD_CHECKBUSYFLAG = TRUE
           WaitForReady    'Call subroutine to poll busy flag
           set LCD_RW OFF  'Write mode
     #ENDIF
     WAIT SCRIPT_LCDPOSTWRITEDELAY us</pre><p><span class="strong"><strong><span class="emphasis"><em>Create Constant Example</em></span></strong></span></p><p>Background:&nbsp;&nbsp;All constants are always processed, regardless of where they are placed in the user code or library.&nbsp;&nbsp;
This includes any constant defined anywhere in user code or any library - the constant will be processed and the constant will be defined.&nbsp;&nbsp;
The only method to constrain a constant is via a script.&nbsp;&nbsp;</p><p>The following code segment will not constrain the constant.&nbsp;&nbsp;
The constant <code class="literal">MYCONSTANT</code> will be created.&nbsp;&nbsp;The <code class="literal">#IFDEF PIC</code> will not constrain even if an AVR or LGT chip.</p><pre class="screen">    #IFDEF PIC
          #DEFINE MYCONSTANT 255
    #ENDIF</pre><p>The recommended method follows.  The constant will only be created when a PIC.</p><pre class="screen">    #SCRIPT
      IF PIC then
          MYCONSTANT  = 255
       End IF
    #ENDSCRIPT</pre><p><span class="strong"><strong><span class="emphasis"><em>Constrain a Constant Example</em></span></strong></span></p><p>An example to constrain a constant is to test if a user constant is define in the user source program.&nbsp;&nbsp;
In this example the constant <code class="literal">SENDALOW</code> is defined in user source program.&nbsp;&nbsp;</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">If yes, then define the library specific constants.&nbsp;&nbsp;</li><li class="listitem">If no, then do not define the library specific constants.&nbsp;&nbsp;</li></ul></div><p>Using the method below defines constants only when the user requires the constants assuming they have defined <code class="literal">SENDALOW</code> in the user source program.</p><pre class="screen">    #SCRIPT
         IF SENDALOW then
                NONE = 0 : ODD = 1 : EVEN = 2 : NORMAL = 0 : INVERT = 1
                WAITFORSTART = 128 : SERIALINITDELAY = 5
         END IF

         IF SENDALOW then
                NONE = 0 : ODD = 1 : EVEN = 2 : NORMAL = 0 : INVERT = 1
                WAITFORSTART = 128 : SERIALINITDELAY = 5
         END IF

         IF SENDALOW then
                NONE = 0 : ODD = 1 : EVEN = 2 : NORMAL = 0 : INVERT = 1
                WAITFORSTART = 128 : SERIALINITDELAY = 5
         END IF
    #ENDSCRIPT</pre><p></p><p><span class="strong"><strong>SCRIPTS VARIABLES</strong></span></p><p>Scripting has the concept of variable that can be used within the script.&nbsp;&nbsp;
The variables are NOT available as variables to a user program or a library beyond the scope of the script.&nbsp;&nbsp;
The variables are available  to a user program as constants.&nbsp;&nbsp;
The variables will be integer values, if accessed in a user program.&nbsp;&nbsp;</p><p><span class="strong"><strong>SCRIPT SYNTAX</strong></span></p><p>Scripting support the preprocessing of the program to create specific constants.&nbsp;&nbsp;
Scripting has a basic syntax and this is detailed in the HELP.&nbsp;&nbsp;
However, this guide is intended to provide insights into the gotchas and best practices.</p><p><span class="strong"><strong><span class="emphasis"><em>Script Insights</em></span></strong></span></p><p>Scripting handles the creation of specific constants that can be used within the library.&nbsp;&nbsp;
Many libraries have script to create constants to support PWM, Serial, HEFSAF etc.&nbsp;&nbsp;</p><p>You can use the limited script language to complete calculations using real numbers but you MUST ensure the resulting constant is an integer value.&nbsp;&nbsp;
Use the IN() method to ensure an integer is assigned.</p><p>You can use IF-THEN-ENDIF but if your IF condtional test uses a chip regiseter or a user define constant then you must ensure the register or constant exists.&nbsp;&nbsp;
If you do not check the registrer or constant exists the script will fail to operate as expected.&nbsp;&nbsp;</p><p>There is limted syntax checking.
You must ensure the quality of the script by extensive testing.</p><pre class="screen">    int( register +1s))  'Will not create an error, but, simple give an unexpected result.</pre><p><br>
<br></p><p></p><p><span class="strong"><strong>TAB USAGE AND INDENTING</strong></span></p><p>Four spaces are to be used. A tab is not permitted</p><p>Example follows where the indents are all four spaces.</p><pre class="screen">sub  ExampleSub (In VariableName)
    select case VariableName
        case 1
            Do This
        case 2
            Do That
    end select
end sub</pre><p>Not like this:</p><pre class="screen">    SUB  ExampleSub (In VariableName)
            Select Case VariableName
                  Case 1
                                   Do This
                  Case 2
                                    Do That
             End Select
End SUB</pre><p>and, not like this</p><pre class="screen">    Sub  ExampleSub (In VariableName)
    Select Case VariableName
    Case 1
    Do This
    Case 2
    Do That
    End Select
    End Sub</pre><p></p><p><span class="strong"><strong>OPTION REQUIRED</strong></span></p><p><code class="literal">#Option Required</code> supports ensuring the microcontroller has the mandated capabilities, such as EEPROM, HEF, SAF, USART.</p><p>Syntax:</p><pre class="screen">    #option REQUIRED PIC|AVR CONSTANT %message.dat entry%
    #option REQUIRED PIC|AVR CONSTANT "Message string"</pre><p>This option ensure that the specific CONSTANT exists within a library to ensure a specific capability is available with the microcontroller.</p><p>This will cause the compiler check the CONSTANT is a non zero value.  If the CONSTANT does not exist it will be treated as a zero value.</p><p>Example:</p><p>This example tests the CONSTANT CHIPUSART for both the PIC and AVR microcontrollers.  If the CONSTANT is zero or does not exist then the string will be displayed as an error message.</p><pre class="screen">    #option REQUIRED PIC CHIPUSART "Hardware Serial operations. Remove USART commands to resolve errors."
    #option REQUIRED AVR CHIPUSART "Hardware Serial operations. Remove USART commands to resolve errors."</pre><p><span class="strong"><strong>RAISING COMPILER ERROR CONDITIONS</strong></span></p><p>From build 1131 the compiler now supports raising a compiler error message.</p><p>The method uses the `RaiseCompilerError  ""&lt;string&gt;""|%string%" ` method to pass an error message to the compilation process.</p><p>An example from USART.H/INITUSART subroutine is shown below.&nbsp;&nbsp;This example tests for the existence of one of the three supported baud rate constants.&nbsp;&nbsp;If none of the constants exist and the constant (in this example) <code class="literal">STOPCOMPILERERRORHANDLER</code> does not exist the <code class="literal">RaiseCompilerError</code> with the string will be passed to the assembler for error processing.&nbsp;&nbsp;
This permits the inspect of the user program with appropriate messages to inform the user.</p><pre class="screen">  ....
  #IFNDEF ONEOF(USART_BAUD_RATE,USART1_BAUD_RATE,USART2_BAUD_RATE) THEN
    'Look for one of the baud rates CONSTANTS
    #IFNDEF STOPCOMPILERERRORHANDLER
      'Use one of the following - the string MUST be start and end with a double quote

        ' Use the message.dat file
        ' RaiseCompilerError "%USART_NO_BAUD_RATE%"

        ' Use hard code text
        ' RaiseCompilerError "USART not setup correctly. No baud rate specified - please correct USART setup"

        RaiseCompilerError "%USART_NO_BAUD_RATE%"

    #ENDIF
  #ENDIF
  ....</pre><p>The <code class="literal">RaiseCompilerError</code> handler can be stopped using the constant STOPCOMPILERERRORHANDLER as shown above.
<br>
<br>
<span class="strong"><strong>LCD ERROR HANDLING</strong></span></p><p>The setup of an LCD is inspected and an appropriate error message is displayed.&nbsp;&nbsp;
The Compiler now controls error messages when LCD is not setup up correctly.&nbsp;&nbsp;
This the text displayed is held in the messages.dat file - LCD_Not_Setup entry.
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="development_guide"></span>Development Guide

</div>

</div>

</div>

There are lots of ways to contribute to the GCBASIC project: coding,
testing, improving the build process and tools, or contributing to the
documentation. This guide provides information that will not only help
you get started as a GCBASIC contributor, but that you wiil find useful
to refer to EVEN if you are already an experienced contributor.

<span class="strong">**Need Help?**</span>

The GCBASIC community prides itself on being an open, accessible, and
friendly community for new participants. If you have any difficulties
getting involved or finding answers to your questions, please bring
those questions to the forum via the discussion boards, where we can
help you get started.

We know EVEN before you start contributing that getting set up to work
on GCBASIC and finding a bug that is a good fit for your skills can be a
challenge. We are always looking for ways to improve this process:
making GCBASIC more open, accessible, and easier to participate with. If
you are having any trouble following this documentation, or hit a
barrier you cannot get around, please contact use via the discussion
forum. We will solve hurdles for new contributors and make GCBASIC
better.

This section addresses developing libraries but this guide is
appropriate to any GCBASIC development.

The section covers the recommended programming style, Constants,
Variables, Script syntax (gotchas) and tab usage.

<span class="strong">**PROGRAMMING STYLES**</span>

Indenting is standardized.

All scripts within a specific library should be the first major section
the library. Scripts within methods should not be used.

Some \#defines may need to be placed before the script to provide
clarity to the structure of the library.

``` screen
        #startup  startupsub

        #Define I2C_ADDRESS_1  0x4E    'The default address if user does not specify in the user program

        #SCRIPT
                ... code script
                ... code script
                ... code script
       #ENDSCRIPT
```

Scripts support structures like IF &lt;CONDITION&gt; THEN &lt;ACTION&gt;
END iF. Scripts supports the &lt;condition&gt; argument that must
generate a TRUE result, meaning that at a literal level, your
conditional formatting rule is an If - THEN statement along the lines of
“If this condition is TRUE, THEN process the &lt;ACTION&gt;. the
condition must use logical "AND" and "OR" to test two conditions. Using
"AND" or "OR" reduces the script size, however, it is essential the the
conditional test(s) are valid. If a test fails then you may not get the
results you expect.

``` screen
        IF .. THEN

        END IF
```

<span class="strong">**CONSTANTS**</span>

A constant is a value that cannot be altered by the program during
normal execution.   Within GCBASIC there are two ways to create
constants.    1. with the `#DEFINE` instruction, or, 2. via \`\#SCRIPT
.. \#ENDSCRIPT'. ;   Within a script constants can be created and
changed. A script is process that is executed prior to the GCBASIC
source program is processing the main user program.

An example of using `#DEFINE` is

``` screen
        #DEFINE TIME_DELAY_VALUE    10
```

The script construct is

``` screen
        #SCRIPT
              'Create a constant
              TIME_REPEAT_VALUE  =  10
        #ENDSCRIPT
```

<span class="strong">**<span class="emphasis">*Guide for
constants*</span>**</span>

The following rules are recommended.

1 - All CONSTANTS are capitalized

2 - Do not define a constant in a library unless required

3 - Create all library constants within a script ( see example below
<span class="strong">**Constrain a Constant Example**</span> on how to
constrain a constant)

2 - Underscores are permitted in constant names within Scripts \*\*

3 - No prefix is required when a CONSTANT is PUBLIC. A PUBLIC constant
is one that the user sets or the user can use.

4 - Prefix CONSTANTS with SCRIPT\_ when the CONSTANT is used outside of
the library specific script section AND ARE NOT EXPOSED AS PUBLIC
Constants.

5 - Prefix CONSTANTS with \_\_ (two underscores) when the CONSTANT is
ONLY used inside the library specific script section

6 - For PUBLIC prefix CONSTANTS with the capability name, \_ (one
underscore) and then a meaningful title, as follows GLCD\_HEIGHT
SPISRAM\_TYPE

7 - All scripts within a specific library should be the first major
section the library. Scripts within methods ( Sub, Functions) should not
be used.

8 - All scripts within a specific library should be the first major
section the library. Scripts within methods ( Sub, Functions) should not
be used.

9 - Other naming recommendations. Do not use underscores in subroutine,
function or variable names

<span class="strong">**<span class="emphasis">*Example script within a
library*</span>**</span>

``` screen
          #startup  startupsub
          #DEFINE I2C_ADDRESS_1  0x4E    'Default address if user omits
          #SCRIPT
                'script code
                'script code
                'script code
          #ENDSCRIPT
```

<span class="strong">**<span class="emphasis">*Simple
Example*</span>**</span>

``` screen
     #SCRIPT  'Calculate Delay Time
             __LCD_DELAY  = ( __LCD_TIMEPERIOD - __LCD_DELAYS) - (INT((4/ChipMHZ) * __LCD_INSTRUCTIONS))
            SCRIPT_LCD_POSTWRITEDELAY = __LCD_DELAY
            SCRIPT_LCD_CHECKBUSYFLAG = TRUE
     #ENDSCRIPT

     'usage within user code or code outside of script
     #IF SCRIPT_LCD_CHECKBUSYFLAG = TRUE
           WaitForReady    'Call subroutine to poll busy flag
           set LCD_RW OFF  'Write mode
     #ENDIF
     WAIT SCRIPT_LCDPOSTWRITEDELAY us
```

<span class="strong">**<span class="emphasis">*Create Constant
Example*</span>**</span>

Background:  All constants are always processed, regardless of where
they are placed in the user code or library.   This includes any
constant defined anywhere in user code or any library - the constant
will be processed and the constant will be defined.   The only method to
constrain a constant is via a script.  

The following code segment will not constrain the constant.   The
constant `MYCONSTANT` will be created.  The `#IFDEF PIC` will not
constrain even if an AVR or LGT chip.

``` screen
    #IFDEF PIC
          #DEFINE MYCONSTANT 255
    #ENDIF
```

The recommended method follows. The constant will only be created when a
PIC.

``` screen
    #SCRIPT
      IF PIC then
          MYCONSTANT  = 255
       End IF
    #ENDSCRIPT
```

<span class="strong">**<span class="emphasis">*Constrain a Constant
Example*</span>**</span>

An example to constrain a constant is to test if a user constant is
define in the user source program.   In this example the constant
`SENDALOW` is defined in user source program.  

<div class="itemizedlist">

-   If yes, then define the library specific constants.  
-   If no, then do not define the library specific constants.  

</div>

Using the method below defines constants only when the user requires the
constants assuming they have defined `SENDALOW` in the user source
program.

``` screen
    #SCRIPT
         IF SENDALOW then
                NONE = 0 : ODD = 1 : EVEN = 2 : NORMAL = 0 : INVERT = 1
                WAITFORSTART = 128 : SERIALINITDELAY = 5
         END IF

         IF SENDALOW then
                NONE = 0 : ODD = 1 : EVEN = 2 : NORMAL = 0 : INVERT = 1
                WAITFORSTART = 128 : SERIALINITDELAY = 5
         END IF

         IF SENDALOW then
                NONE = 0 : ODD = 1 : EVEN = 2 : NORMAL = 0 : INVERT = 1
                WAITFORSTART = 128 : SERIALINITDELAY = 5
         END IF
    #ENDSCRIPT
```

<span class="strong">**SCRIPTS VARIABLES**</span>

Scripting has the concept of variable that can be used within the
script.   The variables are NOT available as variables to a user program
or a library beyond the scope of the script.   The variables are
available to a user program as constants.   The variables will be
integer values, if accessed in a user program.  

<span class="strong">**SCRIPT SYNTAX**</span>

Scripting support the preprocessing of the program to create specific
constants.   Scripting has a basic syntax and this is detailed in the
HELP.   However, this guide is intended to provide insights into the
gotchas and best practices.

<span class="strong">**<span class="emphasis">*Script
Insights*</span>**</span>

Scripting handles the creation of specific constants that can be used
within the library.   Many libraries have script to create constants to
support PWM, Serial, HEFSAF etc.  

You can use the limited script language to complete calculations using
real numbers but you MUST ensure the resulting constant is an integer
value.   Use the IN() method to ensure an integer is assigned.

You can use IF-THEN-ENDIF but if your IF condtional test uses a chip
regiseter or a user define constant then you must ensure the register or
constant exists.   If you do not check the registrer or constant exists
the script will fail to operate as expected.  

There is limted syntax checking. You must ensure the quality of the
script by extensive testing.

``` screen
    int( register +1s))  'Will not create an error, but, simple give an unexpected result.
```

  
  

<span class="strong">**TAB USAGE AND INDENTING**</span>

Four spaces are to be used. A tab is not permitted

Example follows where the indents are all four spaces.

``` screen
sub  ExampleSub (In VariableName)
    select case VariableName
        case 1
            Do This
        case 2
            Do That
    end select
end sub
```

Not like this:

``` screen
    SUB  ExampleSub (In VariableName)
            Select Case VariableName
                  Case 1
                                   Do This
                  Case 2
                                    Do That
             End Select
End SUB
```

and, not like this

``` screen
    Sub  ExampleSub (In VariableName)
    Select Case VariableName
    Case 1
    Do This
    Case 2
    Do That
    End Select
    End Sub
```

<span class="strong">**OPTION REQUIRED**</span>

`#Option Required` supports ensuring the microcontroller has the
mandated capabilities, such as EEPROM, HEF, SAF, USART.

Syntax:

``` screen
    #option REQUIRED PIC|AVR CONSTANT %message.dat entry%
    #option REQUIRED PIC|AVR CONSTANT "Message string"
```

This option ensure that the specific CONSTANT exists within a library to
ensure a specific capability is available with the microcontroller.

This will cause the compiler check the CONSTANT is a non zero value. If
the CONSTANT does not exist it will be treated as a zero value.

Example:

This example tests the CONSTANT CHIPUSART for both the PIC and AVR
microcontrollers. If the CONSTANT is zero or does not exist then the
string will be displayed as an error message.

``` screen
    #option REQUIRED PIC CHIPUSART "Hardware Serial operations. Remove USART commands to resolve errors."
    #option REQUIRED AVR CHIPUSART "Hardware Serial operations. Remove USART commands to resolve errors."
```

<span class="strong">**RAISING COMPILER ERROR CONDITIONS**</span>

From build 1131 the compiler now supports raising a compiler error
message.

The method uses the \`RaiseCompilerError ""&lt;string&gt;""\|%string%"
\` method to pass an error message to the compilation process.

An example from USART.H/INITUSART subroutine is shown below.  This
example tests for the existence of one of the three supported baud rate
constants.  If none of the constants exist and the constant (in this
example) `STOPCOMPILERERRORHANDLER` does not exist the
`RaiseCompilerError` with the string will be passed to the assembler for
error processing.   This permits the inspect of the user program with
appropriate messages to inform the user.

``` screen
  ....
  #IFNDEF ONEOF(USART_BAUD_RATE,USART1_BAUD_RATE,USART2_BAUD_RATE) THEN
    'Look for one of the baud rates CONSTANTS
    #IFNDEF STOPCOMPILERERRORHANDLER
      'Use one of the following - the string MUST be start and end with a double quote

        ' Use the message.dat file
        ' RaiseCompilerError "%USART_NO_BAUD_RATE%"

        ' Use hard code text
        ' RaiseCompilerError "USART not setup correctly. No baud rate specified - please correct USART setup"

        RaiseCompilerError "%USART_NO_BAUD_RATE%"

    #ENDIF
  #ENDIF
  ....
```

The `RaiseCompilerError` handler can be stopped using the constant
STOPCOMPILERERRORHANDLER as shown above.  
  
<span class="strong">**LCD ERROR HANDLING**</span>

The setup of an LCD is inspected and an appropriate error message is
displayed.   The Compiler now controls error messages when LCD is not
setup up correctly.   This the text displayed is held in the
messages.dat file - LCD\_Not\_Setup entry.  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Development Guide for GCBASIC.EXE compiler</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_gcbasic_maintenance_and_development.html" title="GCBASIC Maintenance and Development"><link rel="prev" href="_development_guide.html" title="Development Guide"><link rel="next" href="_development_guide_for_gcbasic_preferences_editor.html" title="Development Guide for GCBASIC Preferences Editor"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_development_guide_for_gcbasic_exe_compiler"></a>Development Guide for GCBASIC.EXE compiler</h3></div></div></div><p>There are lots of ways to contribute to the GCBASIC project: coding, testing, improving the build process and tools, or contributing to the documentation.
This guide provides information that will not only help you get started as a GCBASIC contributor, but that you will inform you as an experienced contributor wanting to help.</p><p><br></p><p><span class="strong"><strong>Need Help?</strong></span></p><p>The GCBASIC community prides itself on being an open, accessible, and friendly community for new participants.&nbsp;&nbsp;
If you have difficulties getting involved or finding answers to your questions, please bring those questions to the forum via the discussion boards, where we can help you get started.</p><p>We know EVEN before you start contributing that getting can be a challenge.&nbsp;&nbsp;
This guide is intended to help.&nbsp;&nbsp;
We are always looking for ways to improve the software: making GCBASIC more open, accessible, and easier to participate with.&nbsp;&nbsp;
If you are having any trouble following this guide, or hit a barrier you cannot get around, please contact us via the discussion forum.&nbsp;&nbsp;
We will solve hurdles for new contributors and make GCBASIC better.&nbsp;&nbsp;</p><p>This addresses the changes and updates to the GCBASIC compiler.&nbsp;&nbsp;</p><p><br>
<br></p><p><span class="strong"><strong>BACKGROUND</strong></span></p><p>The compiler was created by Dr. Hugh Considine when he was 12 years old.&nbsp;&nbsp;That was in 2005.&nbsp;&nbsp;Hugh came up with the idea for a new compiler - of the then available compilers - they were hard to use and not free. &nbsp;&nbsp;And, he had some spare time.</p><p>Hugh believes that GCBASIC should be free to all - forever.&nbsp;&nbsp;</p><p>The original software was called GCBASIC, but, he had some resistance in getting high schools in Australia to use and agree to the use of text based programming.&nbsp;&nbsp;
Graphical GCBASIC was created to address the need for a graphical user interface.&nbsp;&nbsp;Graphical GCBASIC acts like a set of training wheels. &nbsp;&nbsp;
The concept of Graphical GCBASIC is that the icons make it less scary, and since they all share names with the BASIC commands it is then easy to remember what command corresponds to each icon..&nbsp;&nbsp;
Using Graphical GCBASIC users can then switch to text mode whenever they want to, go backwards and forwards a few times if they want, and finally end up using just the text programming.&nbsp;&nbsp;
It is a journey from a graphical user interface to text based programming.&nbsp;&nbsp;
<br>
<br>
Those who already have programming experience can go straight to GCBASIC, while those who would prefer a lighter learning curve can take the Graphical GCBASIC option. &nbsp;&nbsp;
The two approaches targets two different sets of users who ultimately want to do the same thing.
<br>
<br>
As for the <span class="strong"><strong>name</strong></span>, it was about the fourth name Hugh tried. &nbsp;&nbsp;First name was BASPIC, but it did not seem memorable enough.&nbsp;&nbsp;
Then, he considered some animal names - first thought was Chipmunk BASIC, but someone already used that!&nbsp;&nbsp;
Then, Bear BASIC, but decided against it on finding out the slang meaning of bear.&nbsp;&nbsp;
Final  name was GCBASIC, which is named after something his sister and he came up with (when aged 12 and 15!!).&nbsp;&nbsp;
No-one else had that name, it had no meanings that could offend, and it was something odd enough to be memorable, so GCBASIC it was.</p><p>In 2013 Evan Venn joined the team as a compiler developer, with others joining in Bernd Dau, Trevor Roydhouse, Pete Everett, Theo Loermans, Giuseppe D&#8217;Elia, Derek Gore,  Ian Smith, Bernd Dau, Theo Loermans, Urs Hopp, Kent Schafer, and Frank Steinberg.&nbsp;&nbsp;
Some those that joined in drove changes to the compiler, some changed the source code, some built tools and some built libraries.&nbsp;&nbsp;
They all had one thing in common - improvements to the GCBASIC compiler.</p><p>In 2021 we are still having new developers join the project like ToniG adding a new capability for handling Tables.</p><p><br>
<br></p><p><span class="strong"><strong>THE COMPILER</strong></span></p><p>The compiler executable is called GCBASIC.EXE. &nbsp;&nbsp;
The compiler source is written in FreeBASIC.&nbsp;&nbsp;
FreeBASIC is a multiplatform, free/open source (GPL) BASIC programming language and a compiler for Microsoft Windows, protected-mode MS-DOS (DOS extender), Linux and FreeBSD.
&nbsp;&nbsp;
<br>
<br>
The official website is <a class="link" href="https://www.freebasic.net/" target="_top">https://www.freebasic.net/</a>
<br>
<br>
FreeBASIC provides syntax compatibility with programs originally written in Microsoft QuickBASIC (QB).&nbsp;&nbsp;
FreeBASIC is a command line only compiler, unless users manually install an external integrated development environment (IDE) of their choice.&nbsp;&nbsp;
IDEs specifically made for FreeBASIC include FBide and FbEdit, while more graphical options include WinFBE Suite and VisualFBEditor.&nbsp;&nbsp;
<br>
<br>
The source code is Open Source.&nbsp;&nbsp;
And, has a GNU GENERAL PUBLIC LICENSE.&nbsp;&nbsp;
<br>
<br>
The source code for the compiler can be found on <a class="link" href="https://sourceforge.net/p/gcbasic/code/HEAD/tree/GCBASIC/trunk/" target="_top">SourceForge</a>
<br>
<br>
Use SVN to UPDATE and COMMIT code changes.&nbsp;&nbsp;
You require developer access to SourceForge but if you have got this far then you already know this.&nbsp;&nbsp;
You are therefore  required to use SVN for source code management.</p><p>When COMMITting you MUST update the change log, then, when you commit an update use the change log with the SourceForge commit number.&nbsp;&nbsp;
Then, add the new change at the end of the change log.&nbsp;&nbsp;
The COMMIT message should be the same as the description in the change log.&nbsp;&nbsp;
Add the [<span class="emphasis"><em>COMMIT NUMBER]</em></span> to the description in the change log to show the COMMIT number.&nbsp;&nbsp;</p><p>You will find the changelog <a class="link" href="https://onedrive.live.com/Edit.aspx?resid=2F87FFE77F3DBEC7!67634&amp;wd=cpe&amp;authkey=!ADmkT3exl5l4Pkc" target="_top">here</a>.&nbsp;&nbsp;
The change log is an EXCEL spreadsheet.&nbsp;&nbsp;</p><p><br>
<br></p><p><span class="strong"><strong>COMPILER ARCHITECTURE</strong></span></p><p>The compiler is relatively simple in terms of the architecture.&nbsp;&nbsp;
There is a main source program with a set of header files that contain other methods or declarations.&nbsp;&nbsp;
The GCBASIC header files are the following:</p><pre class="screen">    1. preprocessor.bi -  methods, statements, defines, declarations, prototypes, constants, enumerations, or similar types of statements
    2. utils.bi - methods that are shared across the architecture
    3. variables.bi - methods that control the creation and management of variables
    4. assembly.bi - methods specific to the generation of GCAssembler (GCASM)
    5. file.bi - the FreeBASIC files library
    6. string.bi - the FreeBASIC string library</pre><p>The supporting files are:</p><pre class="screen">    1. messages.dat - the English messages source file.  All user messages from the compiler are sourced from this file.
    2. reservedwords.dat - the list of system reserved words</pre><p><br>
<br>
The compiler process is simple.&nbsp;&nbsp;
The process, shown below, generates the ASM source and the HEX file from the user source program.</p><pre class="screen">    1. Create the indexes
    2. Declare the methods, arrays and variables
    3. Process the user source programs using PreProcessor method. This includes
        i.     Loading of all source files including including files
        ii.    Translate files, if needed
        iii.   Examine source for comments, tables, asm, rawasm, functions;subs;macros, set origin of valid code
                    Origin = ";?F" + Str(RF) + "L" + Str(LC) + "S" + Str(SBC) + "?"
                    RF = File number
                    L  = Line number in source file
                    S  = Sub Routine number
        iv.    Find compiler directives, except SCRIPT, ENDSCRIPT, IFDEF and ENDIF - including all the #DEINEs outside of condiontal statements
        v.     ReadChipData
        vi.    CheckClockSpeed
        viii.  ReadOptions
        ix.    PreparePageData
        x.     PrepareBuiltIn.  Initialise built-in data, and prepare built-in subs.
        xi.    RunScripts
        xii.   BuildMemoryMap
        xiii.  Process samevar and samebit
        xiv.   RemIfDefs.  Remove any #IFDEFs that do not apply to the program.
        xv.    Prepare programmer, need to know chip model and need to do this before checking config
        xvi.   Replace Constants
        xvii.  Replace table value.  Replace constants and calculations in tables with actual values
    4. Compile the program using the CompileProgram method
         i.    Compile calls to other subroutines, insert macros
         ii.   Compile DIMs again, in case any come through from macros
         iii.  Compile FOR commands
         iv.   Process arrays
         v.    Add system variable(s) and bit(s)
         vi.   Compile Tables
         vii.  Compile Pot
         viii. Compile Do
         ix.   Compile Dir
         x.    Compile Wait
         xi.   Compile On Interrupt
         xii.  Compile Set(s)
         xiii. Compile Rotate
         xiv.  Compile Repeat
         xv.   Compile Select
         xvi.  Compile Return
         xvii. Compile If(s)
         xviii Compile Exit Sub
         xix.  Compile Goto(s)
    5. Allocate RAM using the AllocateRAM method
    6. Optimise the generated code using the TidyProgram method
    7. Combine and locate the subroutines and functions for the selected chip using the MergeSubroutines method
    8. Complete the final optimisation using the FinalOptimise method
    9. Write the assembly using the WriteAssembly method
    10. Assemble and generate the hex file using GCASM, MPASM, PICAS or some other define Assembler
    11. Optionally, pass programming operations to the programmer
    12. Write compilation report using the WriteCompilationReport method
    13. If needed, write the error and warning log using the WriteErrorLog method
    14. Exit, setting the ERRORLEVEL</pre><p>Note #1:  Constants are can be created in many places and the order is critical when trying to understant the process.</p><p>Step 3.iv; Step 3.xi, 3.xiv and xvi. These are Find compiler directives; Runscripts, process IFDEFs and replace Constants values respectively.&nbsp;&nbsp;
This means constants that are not created by the Find compiler directives step are clearly not available in the RunScripts step, and the same applies to the process IFDEFs step.&nbsp;&nbsp;So, please consider the order of constant creation in terms of these steps.&nbsp;&nbsp;Always think about the precendence of constant creation.&nbsp;&nbsp;</p><p>Note #2:  When using IFDEFs Conditional statements you should #UNDEFINE all constants prior to #DEFINE.&nbsp;&nbsp;Whilst the will be cases where the constant does not exist, or where the Preprocessor can determine the outcome of the Conditional statements there will be cases, specifically nested IFDEFs Conditional statements, where you will be required to use #UNDEFINE to remove all warnings.</p><p>Note #3:  Good practice is NOT to create constants in a library where the user can overwrite the value of the same constant.&nbsp;&nbsp;You must determine if the user has created the constant and then create a default value if the user has not defined a value.&nbsp;&nbsp;  An example:</p><pre class="screen">  IF NODEF(AD_DELAY) THEN
     'Acquisition time. Can be reduced in some circumstances - see PIC manual for details
     AD_DELAY = 2 10US
  END IF</pre><p>This will create the constant AD_DELAY only when the user program does not define a value.
<br></p><p><span class="strong"><strong>FreeBASIC COMPILATION OF GCBASIC SOURCE CODE</strong></span></p><p>The compiler is relatively simple in terms of the compilation.&nbsp;&nbsp;</p><p>Use the following versions of the FreeBASIC compiler to compile the GCBASIC source code.</p><p>For Windows 32 bit</p><pre class="screen">    FreeBASIC Compiler - Version 1.07.1 (2019-09-27), built for win32 (32bit)
    Copyright (C) 2004-2019 The FreeBASIC development team.</pre><p>For Windows 64 bit</p><pre class="screen">    FreeBASIC Compiler - Version 1.07.1 (2019-09-27), built for win64 (64bit)
    Copyright (C) 2004-2019 The FreeBASIC development team.</pre><p>Using other version of Windows FREEBASIC compiler are NOT tested and may fail.&nbsp;&nbsp;
Use the specific versions shown above.</p><p>The compile use the following command lines.
Where "%ProgramFiles% is the root location of the FreeBASIC installation, and
$SF is the location of the source files and the destination of the compiled executable.</p><p>For Windows 32 bit</p><pre class="screen">    "%ProgramFiles%\FreeBASIC\win32\fbc.exe"  $SF\gcbasic.bas   -exx -arch 586 -x $SF\gcbasic32.exe</pre><p>For Windows 64 bit</p><pre class="screen">    "%ProgramFiles%\FreeBASIC\win64\fbc.exe"  $SF\gcbasic.bas   -x $SF\gcbasic64.exe -ex</pre><p>Linux, FreeBSD and Pi OS are also supported.&nbsp;&nbsp;
Please see <a class="link" href="http://gcbasic.sourceforge.net/help/" target="_top">Online Help</a> and search for the specific operating system.&nbsp;&nbsp;</p><p><br>
<br></p><p><span class="strong"><strong>FreeBASIC COMPILER TOOLCHAIN</strong></span></p><p>To simplify the establishment of  development enviroment download a complete installation from <a class="link" href="https://sourceforge.net/projects/gcbasic/files/Support%20Files/GCBASICWindowsToolchain/FreeBASIC.zip/download" target="_top">here</a>.&nbsp;&nbsp;
This includes the correct version of FreeBASIC and the libraries - all ready for use.&nbsp;&nbsp;
Simply unzip the ZIP to a folder and the toolchain is ready for use.&nbsp;&nbsp;
For an IDE please see the information above.&nbsp;&nbsp;</p><p><br>
<br></p><p><span class="strong"><strong>BUILDING THE GCBASIC EXECUTABLE USING THE FBEDIT IDE</strong></span></p><p>To build GCBASIC from the source files.&nbsp;&nbsp;
The list shows the installation of the FBEdit IDE.</p><p>Complete the following:</p><pre class="screen">        1. Download and install FreeBASIC from  url shown above.
        2. Download and install fbedit from https://sourceforge.net/projects/fbedit/?source=dlp
        3. Download the GCBASIC source using SVN into a gcbasic source folder.
        4. Run fbedit (installed at step #2).  Load project  GCBASIC.fbp  from GBASIC source folder.
        5. Hit &lt;f5&gt; to compile.</pre><p><br>
<br></p><p><span class="strong"><strong>CODING STYLES</strong></span></p><p>Remember, Hugh was 12 when he started this project.&nbsp;&nbsp;
You must forgive him for being a genius, but, he did not implement many programming styles and conventions that are common place today.&nbsp;&nbsp;</p><p>There is a general lack of documentation.&nbsp;&nbsp;
We are adding documentation as we progress.&nbsp;&nbsp;
This can make the source frustrating initially but can find the code segments as they are clearly within method blocks.&nbsp;&nbsp;</p><p>The following rules are recommended.</p><pre class="screen">    1. All CONSTANTS are capitalized
    2. Do not use TAB - use two spaces
    3. You can rename a variable to a meaningful name.  Hugh used a lot of single character variables many years ago.  This should be avoided in new code.
    4. Document as you progress.
    5. Ask for help.</pre><p><br></p><p><span class="strong"><strong>COMPILER SOURCE INSIGHTS</strong></span></p><p><span class="emphasis"><em>There are many very useful methods</em></span>, a lot of methods, look at existing code before adding any new method.&nbsp;&nbsp;
The compiler is mature from a functionality standpoint.&nbsp;&nbsp;
Just immature in terms of documentation.&nbsp;&nbsp;</p><p><span class="strong"><strong>COMPILER DEBUGGING</strong></span></p><p><span class="emphasis"><em>To debug or isolate a specific issue</em></span> use lots of messages using PRINT or HSERPRINT&nbsp;&nbsp;Both of these methods are easy to setup and use.</p><p><span class="emphasis"><em>Specific to #SCRIPT</em></span> you can use WARNING messages to display results of calculations or assignments.</p><p><span class="emphasis"><em>Specific to CONDITIONAL Compilation</em></span> use <code class="literal">conditionaldebugfile</code> (se above) to display conditional statement debug for the specified file. &nbsp;&nbsp; Options are any valid source file or nothing. &nbsp;&nbsp;
Nested conditions are evaluated sequentially, therefor the first, second, third etc etc.  &nbsp;&nbsp;
The compiler does not at this point rationalised the hierarchy of nested conditions.&nbsp;&nbsp;  It simply finds a condition and then matches to an #ENDIF.&nbsp;&nbsp;
So, the compiler walks through the nested conditions as the outer nested, then the next nest, the next nest etc. etc.&nbsp;&nbsp;
This compiler is completing the following actions:&nbsp;&nbsp;</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">If the conditional is not valid.&nbsp;&nbsp;  Remove the code segment include the #IF and the #ENDIF</li><li class="listitem">If the conditional is valid.&nbsp;&nbsp;  Remove the just the #IF and the #ENDIF</li></ol></div><p>So, is this context the compiler walks the code many time (as these are lists not arrrays this is blindly fast) removing code segments.&nbsp;&nbsp;</p><p>The following program shows the impact of nested conditions..&nbsp;&nbsp;Each nest is evaluated until all conditions have been assessed..&nbsp;&nbsp;See the comment section of the listing to see the output from the debugging.</p><pre class="screen">        #CHIP 18F16Q41
        #OPTION EXPLICIT

        ; -----  Add the following line to USE.ini ------------------
        ;
        ;        conditionaldebugfile = IFDEF_TEST.gcb
        ;
        ; -----------------------------------------------------------

        #IFDEF PIC
            #IFDEF ONEOF(CHIP_18F15Q41, CHIP_18F16Q41)
                #IF CHIPRAM = 2048  'TRUE
                    #IF CHIPWORDS = 32768 ' TRUE
                        #IFDEF VAR(NVMLOCK) 'TRUE
                            #IFDEF VAR(OSCCON2)  'TRUE
                                #IFDEF  VAR(NVMCON0)  'TRUE    set var1 to 1
                                    DIM _VAR1
                                    _VAR1 = 1
                                #ENDIF
                            #ENDIF
                        #ENDIF
                    #ENDIF
                #ENDIF

                #IF CHIPRAM = 4096  'TRUE
                    #IF CHIPWORDS = 32768 ' TRUE
                        #IFDEF VAR(NVMLOCK) 'TRUE
                            #IFDEF VAR(OSCCON2)  'TRUE
                                #IFDEF  VAR(NVMCON0)  'TRUE   = set var1 to 0
                                    DIM _VAR1
                                    _VAR1 = 0
                                #ENDIF
                            #ENDIF
                        #ENDIF
                    #ENDIF
                #ENDIF
            #ENDIF
        #ENDIF

        Do
        Loop

        // ===============================================
        // ***  Below is debugger output for this file ***
        // ===============================================

        // GCBASIC (0.99.02 2022-07-21 (Windows 32 bit) : Build 1143)

        // Compiling c:\Users\admin\Downloads\IFDEF_TEST.gcb

        //               13: #IFDEF PIC
        //               15: #IFDEF ONEOF(CHIP_18F15Q41, CHIP_18F16Q41)
        //               17: #IF CHIPRAM = 2048
        //               19: #IF CHIPWORDS = 32768
        //               21: #IFDEF VAR(NVMLOCK)
        //               23: #IFDEF VAR(OSCCON2)
        //               25: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               27: DIM _VAR1
        //               ;_VAR1 = 1
        //               28: _VAR1 = 1

        //               15: #IFDEF ONEOF(CHIP_18F15Q41, CHIP_18F16Q41)
        //               17: #IF CHIPRAM = 2048
        //               19: #IF CHIPWORDS = 32768
        //               21: #IFDEF VAR(NVMLOCK)
        //               23: #IFDEF VAR(OSCCON2)
        //               25: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               27: DIM _VAR1
        //               ;_VAR1 = 1
        //               28: _VAR1 = 1

        //               39: #IF CHIPRAM = 4096
        //               41: #IF CHIPWORDS = 32768
        //               43: #IFDEF VAR(NVMLOCK)
        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               41: #IF CHIPWORDS = 32768
        //               43: #IFDEF VAR(NVMLOCK)
        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               43: #IFDEF VAR(NVMLOCK)
        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        // Program compiled successfully (Compile time: 1 seconds)

        // Assembling program using GCASM
        // Program assembled successfully (Assembly time: 0.125 seconds)
        // Done</pre><p><br>
<br></p><p>The resulting ASM from the about code is as expected.&nbsp;&nbsp;The assignment of <code class="literal">VAR1 = 0</code>.&nbsp;&nbsp;</p><pre class="screen">        ;DIM _VAR1
        ;_VAR1 = 0
            clrf	_VAR1,ACCESS
        ;Do
        SysDoLoop_S1
        ;Loop
            bra	SysDoLoop_S1
        SysDoLoop_E1</pre><p><br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="development_guide_for_gcbasic_exe_compiler"></span>Development Guide for GCBASIC.EXE compiler

</div>

</div>

</div>

There are lots of ways to contribute to the GCBASIC project: coding,
testing, improving the build process and tools, or contributing to the
documentation. This guide provides information that will not only help
you get started as a GCBASIC contributor, but that you will inform you
as an experienced contributor wanting to help.

  

<span class="strong">**Need Help?**</span>

The GCBASIC community prides itself on being an open, accessible, and
friendly community for new participants.   If you have difficulties
getting involved or finding answers to your questions, please bring
those questions to the forum via the discussion boards, where we can
help you get started.

We know EVEN before you start contributing that getting can be a
challenge.   This guide is intended to help.   We are always looking for
ways to improve the software: making GCBASIC more open, accessible, and
easier to participate with.   If you are having any trouble following
this guide, or hit a barrier you cannot get around, please contact us
via the discussion forum.   We will solve hurdles for new contributors
and make GCBASIC better.  

This addresses the changes and updates to the GCBASIC compiler.  

  
  

<span class="strong">**BACKGROUND**</span>

The compiler was created by Dr. Hugh Considine when he was 12 years
old.  That was in 2005.  Hugh came up with the idea for a new compiler -
of the then available compilers - they were hard to use and not free.
  And, he had some spare time.

Hugh believes that GCBASIC should be free to all - forever.  

The original software was called GCBASIC, but, he had some resistance in
getting high schools in Australia to use and agree to the use of text
based programming.   Graphical GCBASIC was created to address the need
for a graphical user interface.  Graphical GCBASIC acts like a set of
training wheels.    The concept of Graphical GCBASIC is that the icons
make it less scary, and since they all share names with the BASIC
commands it is then easy to remember what command corresponds to each
icon..   Using Graphical GCBASIC users can then switch to text mode
whenever they want to, go backwards and forwards a few times if they
want, and finally end up using just the text programming.   It is a
journey from a graphical user interface to text based programming.    
  
Those who already have programming experience can go straight to
GCBASIC, while those who would prefer a lighter learning curve can take
the Graphical GCBASIC option.    The two approaches targets two
different sets of users who ultimately want to do the same thing.  
  
As for the <span class="strong">**name**</span>, it was about the fourth
name Hugh tried.   First name was BASPIC, but it did not seem memorable
enough.   Then, he considered some animal names - first thought was
Chipmunk BASIC, but someone already used that!   Then, Bear BASIC, but
decided against it on finding out the slang meaning of bear.   Final
name was GCBASIC, which is named after something his sister and he came
up with (when aged 12 and 15!!).   No-one else had that name, it had no
meanings that could offend, and it was something odd enough to be
memorable, so GCBASIC it was.

In 2013 Evan Venn joined the team as a compiler developer, with others
joining in Bernd Dau, Trevor Roydhouse, Pete Everett, Theo Loermans,
Giuseppe D’Elia, Derek Gore, Ian Smith, Bernd Dau, Theo Loermans, Urs
Hopp, Kent Schafer, and Frank Steinberg.   Some those that joined in
drove changes to the compiler, some changed the source code, some built
tools and some built libraries.   They all had one thing in common -
improvements to the GCBASIC compiler.

In 2021 we are still having new developers join the project like ToniG
adding a new capability for handling Tables.

  
  

<span class="strong">**THE COMPILER**</span>

The compiler executable is called GCBASIC.EXE.    The compiler source is
written in FreeBASIC.   FreeBASIC is a multiplatform, free/open source
(GPL) BASIC programming language and a compiler for Microsoft Windows,
protected-mode MS-DOS (DOS extender), Linux and FreeBSD.     
  
The official website is <https://www.freebasic.net/>  
  
FreeBASIC provides syntax compatibility with programs originally written
in Microsoft QuickBASIC (QB).   FreeBASIC is a command line only
compiler, unless users manually install an external integrated
development environment (IDE) of their choice.   IDEs specifically made
for FreeBASIC include FBide and FbEdit, while more graphical options
include WinFBE Suite and VisualFBEditor.    
  
The source code is Open Source.   And, has a GNU GENERAL PUBLIC
LICENSE.    
  
The source code for the compiler can be found on
<a href="https://sourceforge.net/p/gcbasic/code/HEAD/tree/GCBASIC/trunk/" class="link">SourceForge</a>  
  
Use SVN to UPDATE and COMMIT code changes.   You require developer
access to SourceForge but if you have got this far then you already know
this.   You are therefore required to use SVN for source code
management.

When COMMITting you MUST update the change log, then, when you commit an
update use the change log with the SourceForge commit number.   Then,
add the new change at the end of the change log.   The COMMIT message
should be the same as the description in the change log.   Add the
\[<span class="emphasis">*COMMIT NUMBER\]*</span> to the description in
the change log to show the COMMIT number.  

You will find the changelog
<a href="https://onedrive.live.com/Edit.aspx?resid=2F87FFE77F3DBEC7!67634&amp;wd=cpe&amp;authkey=!ADmkT3exl5l4Pkc" class="link">here</a>.  
The change log is an EXCEL spreadsheet.  

  
  

<span class="strong">**COMPILER ARCHITECTURE**</span>

The compiler is relatively simple in terms of the architecture.   There
is a main source program with a set of header files that contain other
methods or declarations.   The GCBASIC header files are the following:

``` screen
    1. preprocessor.bi -  methods, statements, defines, declarations, prototypes, constants, enumerations, or similar types of statements
    2. utils.bi - methods that are shared across the architecture
    3. variables.bi - methods that control the creation and management of variables
    4. assembly.bi - methods specific to the generation of GCAssembler (GCASM)
    5. file.bi - the FreeBASIC files library
    6. string.bi - the FreeBASIC string library
```

The supporting files are:

``` screen
    1. messages.dat - the English messages source file.  All user messages from the compiler are sourced from this file.
    2. reservedwords.dat - the list of system reserved words
```

  
  
The compiler process is simple.   The process, shown below, generates
the ASM source and the HEX file from the user source program.

``` screen
    1. Create the indexes
    2. Declare the methods, arrays and variables
    3. Process the user source programs using PreProcessor method. This includes
        i.     Loading of all source files including including files
        ii.    Translate files, if needed
        iii.   Examine source for comments, tables, asm, rawasm, functions;subs;macros, set origin of valid code
                    Origin = ";?F" + Str(RF) + "L" + Str(LC) + "S" + Str(SBC) + "?"
                    RF = File number
                    L  = Line number in source file
                    S  = Sub Routine number
        iv.    Find compiler directives, except SCRIPT, ENDSCRIPT, IFDEF and ENDIF - including all the #DEINEs outside of condiontal statements
        v.     ReadChipData
        vi.    CheckClockSpeed
        viii.  ReadOptions
        ix.    PreparePageData
        x.     PrepareBuiltIn.  Initialise built-in data, and prepare built-in subs.
        xi.    RunScripts
        xii.   BuildMemoryMap
        xiii.  Process samevar and samebit
        xiv.   RemIfDefs.  Remove any #IFDEFs that do not apply to the program.
        xv.    Prepare programmer, need to know chip model and need to do this before checking config
        xvi.   Replace Constants
        xvii.  Replace table value.  Replace constants and calculations in tables with actual values
    4. Compile the program using the CompileProgram method
         i.    Compile calls to other subroutines, insert macros
         ii.   Compile DIMs again, in case any come through from macros
         iii.  Compile FOR commands
         iv.   Process arrays
         v.    Add system variable(s) and bit(s)
         vi.   Compile Tables
         vii.  Compile Pot
         viii. Compile Do
         ix.   Compile Dir
         x.    Compile Wait
         xi.   Compile On Interrupt
         xii.  Compile Set(s)
         xiii. Compile Rotate
         xiv.  Compile Repeat
         xv.   Compile Select
         xvi.  Compile Return
         xvii. Compile If(s)
         xviii Compile Exit Sub
         xix.  Compile Goto(s)
    5. Allocate RAM using the AllocateRAM method
    6. Optimise the generated code using the TidyProgram method
    7. Combine and locate the subroutines and functions for the selected chip using the MergeSubroutines method
    8. Complete the final optimisation using the FinalOptimise method
    9. Write the assembly using the WriteAssembly method
    10. Assemble and generate the hex file using GCASM, MPASM, PICAS or some other define Assembler
    11. Optionally, pass programming operations to the programmer
    12. Write compilation report using the WriteCompilationReport method
    13. If needed, write the error and warning log using the WriteErrorLog method
    14. Exit, setting the ERRORLEVEL
```

Note \#1: Constants are can be created in many places and the order is
critical when trying to understant the process.

Step 3.iv; Step 3.xi, 3.xiv and xvi. These are Find compiler directives;
Runscripts, process IFDEFs and replace Constants values respectively.  
This means constants that are not created by the Find compiler
directives step are clearly not available in the RunScripts step, and
the same applies to the process IFDEFs step.  So, please consider the
order of constant creation in terms of these steps.  Always think about
the precendence of constant creation.  

Note \#2: When using IFDEFs Conditional statements you should \#UNDEFINE
all constants prior to \#DEFINE.  Whilst the will be cases where the
constant does not exist, or where the Preprocessor can determine the
outcome of the Conditional statements there will be cases, specifically
nested IFDEFs Conditional statements, where you will be required to use
\#UNDEFINE to remove all warnings.

Note \#3: Good practice is NOT to create constants in a library where
the user can overwrite the value of the same constant.  You must
determine if the user has created the constant and then create a default
value if the user has not defined a value.   An example:

``` screen
  IF NODEF(AD_DELAY) THEN
     'Acquisition time. Can be reduced in some circumstances - see PIC manual for details
     AD_DELAY = 2 10US
  END IF
```

This will create the constant AD\_DELAY only when the user program does
not define a value.  

<span class="strong">**FreeBASIC COMPILATION OF GCBASIC SOURCE
CODE**</span>

The compiler is relatively simple in terms of the compilation.  

Use the following versions of the FreeBASIC compiler to compile the
GCBASIC source code.

For Windows 32 bit

``` screen
    FreeBASIC Compiler - Version 1.07.1 (2019-09-27), built for win32 (32bit)
    Copyright (C) 2004-2019 The FreeBASIC development team.
```

For Windows 64 bit

``` screen
    FreeBASIC Compiler - Version 1.07.1 (2019-09-27), built for win64 (64bit)
    Copyright (C) 2004-2019 The FreeBASIC development team.
```

Using other version of Windows FREEBASIC compiler are NOT tested and may
fail.   Use the specific versions shown above.

The compile use the following command lines. Where "%ProgramFiles% is
the root location of the FreeBASIC installation, and $SF is the location
of the source files and the destination of the compiled executable.

For Windows 32 bit

``` screen
    "%ProgramFiles%\FreeBASIC\win32\fbc.exe"  $SF\gcbasic.bas   -exx -arch 586 -x $SF\gcbasic32.exe
```

For Windows 64 bit

``` screen
    "%ProgramFiles%\FreeBASIC\win64\fbc.exe"  $SF\gcbasic.bas   -x $SF\gcbasic64.exe -ex
```

Linux, FreeBSD and Pi OS are also supported.   Please see
<a href="http://gcbasic.sourceforge.net/help/" class="link">Online Help</a>
and search for the specific operating system.  

  
  

<span class="strong">**FreeBASIC COMPILER TOOLCHAIN**</span>

To simplify the establishment of development enviroment download a
complete installation from
<a href="https://sourceforge.net/projects/gcbasic/files/Support%20Files/GCBASICWindowsToolchain/FreeBASIC.zip/download" class="link">here</a>.  
This includes the correct version of FreeBASIC and the libraries - all
ready for use.   Simply unzip the ZIP to a folder and the toolchain is
ready for use.   For an IDE please see the information above.  

  
  

<span class="strong">**BUILDING THE GCBASIC EXECUTABLE USING THE FBEDIT
IDE**</span>

To build GCBASIC from the source files.   The list shows the
installation of the FBEdit IDE.

Complete the following:

``` screen
        1. Download and install FreeBASIC from  url shown above.
        2. Download and install fbedit from https://sourceforge.net/projects/fbedit/?source=dlp
        3. Download the GCBASIC source using SVN into a gcbasic source folder.
        4. Run fbedit (installed at step #2).  Load project  GCBASIC.fbp  from GBASIC source folder.
        5. Hit <f5> to compile.
```

  
  

<span class="strong">**CODING STYLES**</span>

Remember, Hugh was 12 when he started this project.   You must forgive
him for being a genius, but, he did not implement many programming
styles and conventions that are common place today.  

There is a general lack of documentation.   We are adding documentation
as we progress.   This can make the source frustrating initially but can
find the code segments as they are clearly within method blocks.  

The following rules are recommended.

``` screen
    1. All CONSTANTS are capitalized
    2. Do not use TAB - use two spaces
    3. You can rename a variable to a meaningful name.  Hugh used a lot of single character variables many years ago.  This should be avoided in new code.
    4. Document as you progress.
    5. Ask for help.
```

  

<span class="strong">**COMPILER SOURCE INSIGHTS**</span>

<span class="emphasis">*There are many very useful methods*</span>, a
lot of methods, look at existing code before adding any new method.  
The compiler is mature from a functionality standpoint.   Just immature
in terms of documentation.  

<span class="strong">**COMPILER DEBUGGING**</span>

<span class="emphasis">*To debug or isolate a specific issue*</span> use
lots of messages using PRINT or HSERPRINT  Both of these methods are
easy to setup and use.

<span class="emphasis">*Specific to \#SCRIPT*</span> you can use WARNING
messages to display results of calculations or assignments.

<span class="emphasis">*Specific to CONDITIONAL Compilation*</span> use
`conditionaldebugfile` (se above) to display conditional statement debug
for the specified file.    Options are any valid source file or nothing.
   Nested conditions are evaluated sequentially, therefor the first,
second, third etc etc.    The compiler does not at this point
rationalised the hierarchy of nested conditions.   It simply finds a
condition and then matches to an \#ENDIF.   So, the compiler walks
through the nested conditions as the outer nested, then the next nest,
the next nest etc. etc.   This compiler is completing the following
actions:  

<div class="orderedlist">

1.  If the conditional is not valid.   Remove the code segment include
    the \#IF and the \#ENDIF
2.  If the conditional is valid.   Remove the just the \#IF and the
    \#ENDIF

</div>

So, is this context the compiler walks the code many time (as these are
lists not arrrays this is blindly fast) removing code segments.  

The following program shows the impact of nested conditions..  Each nest
is evaluated until all conditions have been assessed..  See the comment
section of the listing to see the output from the debugging.

``` screen
        #CHIP 18F16Q41
        #OPTION EXPLICIT

        ; -----  Add the following line to USE.ini ------------------
        ;
        ;        conditionaldebugfile = IFDEF_TEST.gcb
        ;
        ; -----------------------------------------------------------

        #IFDEF PIC
            #IFDEF ONEOF(CHIP_18F15Q41, CHIP_18F16Q41)
                #IF CHIPRAM = 2048  'TRUE
                    #IF CHIPWORDS = 32768 ' TRUE
                        #IFDEF VAR(NVMLOCK) 'TRUE
                            #IFDEF VAR(OSCCON2)  'TRUE
                                #IFDEF  VAR(NVMCON0)  'TRUE    set var1 to 1
                                    DIM _VAR1
                                    _VAR1 = 1
                                #ENDIF
                            #ENDIF
                        #ENDIF
                    #ENDIF
                #ENDIF

                #IF CHIPRAM = 4096  'TRUE
                    #IF CHIPWORDS = 32768 ' TRUE
                        #IFDEF VAR(NVMLOCK) 'TRUE
                            #IFDEF VAR(OSCCON2)  'TRUE
                                #IFDEF  VAR(NVMCON0)  'TRUE   = set var1 to 0
                                    DIM _VAR1
                                    _VAR1 = 0
                                #ENDIF
                            #ENDIF
                        #ENDIF
                    #ENDIF
                #ENDIF
            #ENDIF
        #ENDIF

        Do
        Loop

        // ===============================================
        // ***  Below is debugger output for this file ***
        // ===============================================

        // GCBASIC (0.99.02 2022-07-21 (Windows 32 bit) : Build 1143)

        // Compiling c:\Users\admin\Downloads\IFDEF_TEST.gcb

        //               13: #IFDEF PIC
        //               15: #IFDEF ONEOF(CHIP_18F15Q41, CHIP_18F16Q41)
        //               17: #IF CHIPRAM = 2048
        //               19: #IF CHIPWORDS = 32768
        //               21: #IFDEF VAR(NVMLOCK)
        //               23: #IFDEF VAR(OSCCON2)
        //               25: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               27: DIM _VAR1
        //               ;_VAR1 = 1
        //               28: _VAR1 = 1

        //               15: #IFDEF ONEOF(CHIP_18F15Q41, CHIP_18F16Q41)
        //               17: #IF CHIPRAM = 2048
        //               19: #IF CHIPWORDS = 32768
        //               21: #IFDEF VAR(NVMLOCK)
        //               23: #IFDEF VAR(OSCCON2)
        //               25: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               27: DIM _VAR1
        //               ;_VAR1 = 1
        //               28: _VAR1 = 1

        //               39: #IF CHIPRAM = 4096
        //               41: #IF CHIPWORDS = 32768
        //               43: #IFDEF VAR(NVMLOCK)
        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               41: #IF CHIPWORDS = 32768
        //               43: #IFDEF VAR(NVMLOCK)
        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               43: #IFDEF VAR(NVMLOCK)
        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        // Program compiled successfully (Compile time: 1 seconds)

        // Assembling program using GCASM
        // Program assembled successfully (Assembly time: 0.125 seconds)
        // Done
```

  
  

The resulting ASM from the about code is as expected.  The assignment of
`VAR1 = 0`.  

``` screen
        ;DIM _VAR1
        ;_VAR1 = 0
            clrf    _VAR1,ACCESS
        ;Do
        SysDoLoop_S1
        ;Loop
            bra SysDoLoop_S1
        SysDoLoop_E1
```

  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Development Guide for GCBASIC Preferences Editor</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_gcbasic_maintenance_and_development.html" title="GCBASIC Maintenance and Development"><link rel="prev" href="_development_guide_for_gcbasic_exe_compiler.html" title="Development Guide for GCBASIC.EXE compiler"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_development_guide_for_gcbasic_preferences_editor"></a>Development Guide for GCBASIC Preferences Editor</h3></div></div></div><p>This section deals with the GCBASIC Preferences Editor (Pref Editor).&nbsp;&nbsp;
The Prefs Editor is the software enables the user to select programmers, select the options when compiling, select the assembler and other settings.&nbsp;&nbsp;
The Prefs Editor uses an ini to read and store the compiler settings.&nbsp;&nbsp;
The INI structure is explained the first section, then, the Prefs Editor in detail.</p><p><br></p><p><span class="strong"><strong>ABOUT THE INI FILES</strong></span></p><p>You can provide the compiler an INI file with a number of settings and programmers.&nbsp;&nbsp;</p><p>The following section provide details of the specifics within an example INI file.&nbsp;&nbsp;
The comments are NOT part of an INI file.&nbsp;&nbsp;</p><p>The settings are in the INI section called [gcbasic].&nbsp;&nbsp;</p><pre class="screen">    [gcbasic]
    'The current order of the programmers as shown in Prefs Editor
    programmer = tinybootloader, lgt8fx8p, arduinouno, pickitpluscmd0, nsprog

    'Show the progress counters when compiling.  This can be changed in the INI or by a command line switch. There is no support in Prefs Editor to change this parameter.
    showprogresscounters = n

    'Show verbose when compiling.  This can be changed in the INI or by a command line switch
    verbose = n

    'Show source code in the generated ASM or .S files. This can be changed in the INI or by a command line switch
    preserve = a

    'Treat warning as errors. This can be changed in the INI or by a command line switch.&amp;#160;&amp;#160;There is no support in Prefs Editor to change this parameter.
    warningsaserrors = n

    'Pause after compilation. This can be changed in the INI or by a command line switch.&amp;#160;&amp;#160;There is no support in Prefs Editor to change this parameter.
    pauseaftercompile = n

    'Flash the chip only. This can be changed in the INI or by a command line switch. There is no support in Prefs Editor to change this parameter.
    flashonly = n

    'Selected assembler. This can be changed in the INI or by a command line switch.
    assembler = PIC-AS

    'Add comments to hex to show source compiler. This can be changed in the INI or by a command line switch.
    hexappendgcbmessage = n

    'Mute banners when compiling. This can be changed in the INI or by a command line switch. There is no support in Prefs Editor to change this parameter.
    mutebanners = n

    'Show the extended verbose messages when compiling. his can only be changed in the INI. There is no support in Prefs Editor or a command line switch to change this parameter.  Not managed by Prefs Editor.
    evbs = n

    'Use LAXSYNTAX supports lax validation.  This disables reserved word inspection, permits use of reserved words in GOTO statement.  Not managed by Prefs Editor.
    laxsyntax = y

    'Use NoSummary supports minimal compiler and assembly information when set to y.  Supports y|n.  Not managed by Prefs Editor.
    nosummary = n

    'Use the system temp directory for compiler temp files.  Options are "tempdir" or "instdir" or remove the option.
    workingdir = "tempdir"

    'Display conditional statement debug for the specified file.  Options are any valid source file or nothing. The enry will be remove if a prefixed by a comment ( a single quote ).
    conditionaldebugfile =</pre><p>The section shows an example [tool] assembler section.&nbsp;&nbsp;</p><pre class="screen">    [tool=pic-as]
    'An assember
    type = assembler
    'Location of the assember using a parameter substitution.
    command = %picaslocation%\pic-as.exe
    'Parameters
    params = -mcpu=%ChipModel%  "%Fn_NoExt%.S" -msummary=-mem,+psect,-class,-hex,-file,-sha1,-sha256,-xml,-xmlfull  -Wl -mcallgraph=std -mno-download-hex -o"%Fn_NoExt%.hex"  -Wl,-Map="%Fn_NoExt%.map" -Wa,-a

    [tool=mpasm]
    'An assember
    type = assembler
    'Location of the assember using a parameter substitution.
    command = %mpasmlocation%\mpasmx.exe
    'Paramters
    params = /c- /o- /q+ /l+ /x- /w1 "%FileName%"</pre><p>The section shows an example [patch] section.</p><p>This section shows and explicit set of patches applied to PIC-AS assembler.</p><pre class="screen">    [patch=asm2picas]
    desc = PICAS correction entries.  Format is STRICT as follows:  Must have quotes and the equal sign as the delimeter. PartName +COLON+"BadConfig"="GoodConfig"    Where BadConfig is from .s file and GoodConfig is from .cfgmap file
    16f88x:"intoscio = "="FOSC=INTRC_NOCLKOUT"
    16f8x:"intrc = IO"="FOSC=INTOSCIO"
    12f67x:"intrc = OSC_NOCLKOUT"="FOSC=INTRCIO"</pre><p>The section shows an example [programmer] section.&nbsp;&nbsp;</p><pre class="screen">    [tool = pk4_pic_ipecmd_program_release_from_reset]
    'Description
    desc = MPLAB-IPE PK4 CLI for PIC 5v0
    'A programmer
    type = programmer
    'Command line using a parameter substitution.
    command = %mplabxipedirectory%\ipecmd.exe
    'Parameters using a parameter substitution.
    params = -TPPK4 -P%chipmodel%  -F"%filename%" -M  -E -OL -W5
    'Worting direcroty using a parameter substitution.
    workingdir = %mplabxipedirectory%
    'Useif constraints - this shows none
    useif =
    'Mandated programming config constraints - this shows none
    progconfig =</pre><p><span class="strong"><strong>ABOUT THE PREFS EDITOR</strong></span></p><p>This is a utility for editing GCBASIC ini files.&nbsp;&nbsp;
It is derived from the Graphical GCBASIC utilities, and requires some files from Graphical GCBASIC to compile.&nbsp;&nbsp;</p><p>The software is developed using Sharp Develop v.3.2.1 ( not Visual Studio ).&nbsp;&nbsp;</p><p><br></p><p><span class="strong"><strong>COMPILING</strong></span></p><p>Ensure that the "Programmer Editor" folder is in the same folder as a "Graphical GCBASIC" folder.&nbsp;&nbsp;
The "Graphical GCBASIC" folder must contain the following files from GCGB:
 - Preferences.vb
 - PreferencesWindow.vb
 - ProgrammerEditor.vb
 - Translator.vb
 - ProgrammerEditor.resources</p><p>Once these files are in place, it should be possible to compile the Programmer Editor using SharpDevelop 3.2 (or similar).</p><p><br></p><p><span class="strong"><strong>USING PREFS EDITOR</strong></span></p><p>If run without any parameters, this program will create an ini file in whatever directory it is located in.&nbsp;&nbsp;
If it is given the name of an ini file as a command line parameter, it will use that file.&nbsp;&nbsp;</p><p>As well as the ini file it is told to load, this program will also read any files that are included from that file..&nbsp;&nbsp;
This makes it possible to keep the settings file in the Application Data folder if GCBASIC is installed in the Program Files directory..&nbsp;&nbsp;
To put the settings file into the Application Data folder, create a small ini file containing the following 3 lines and place it in the same directory as this program:</p><pre class="screen">    include %appdata%\gcgb.ini
    [gcgb]
    useappdata = true</pre><p>The include line tells the program (and GCBASIC) to read from the Application Data folder.&nbsp;&nbsp;
The useappdata=true line in the [gcgb] section will cause this program to write any output to a file in Application Data called gcgb.ini.&nbsp;&nbsp;
The hard coding of GCGB is required this program is based on GCGB.&nbsp;&nbsp;
It will result in programmer definitions being shared between GCGB and any other environment using this editor, which may be a positive side effect.</p><p><br></p><p><span class="strong"><strong>BUILDING THE PROGRAMMER EDITOR EXECUTABLE USING SHARP DEVELOP</strong></span></p><p>To build Prefs Editor from the source files.&nbsp;&nbsp;
The list shows the installation of the Sharp Develop IDE.</p><p>Complete the following:</p><pre class="screen">        1. Download and install Sharp Develop from  https://sourceforge.net/projects/sharpdevelop/files/SharpDevelop%203.x/3.2/[SourceForge]
        2. Download the Prefs Editor source using SVN into a source folder.  This is the folder ..\utils\Programmer Editor
        4. Run Sharp Develop (installed at step #1).  Load project  "Programmer Editor.sln"  from source source folder.
        5. Hit &lt;f8&gt; to compile.</pre><p><br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="development_guide_for_gcbasic_preferences_editor"></span>Development Guide for GCBASIC Preferences Editor

</div>

</div>

</div>

This section deals with the GCBASIC Preferences Editor (Pref Editor).  
The Prefs Editor is the software enables the user to select programmers,
select the options when compiling, select the assembler and other
settings.   The Prefs Editor uses an ini to read and store the compiler
settings.   The INI structure is explained the first section, then, the
Prefs Editor in detail.

  

<span class="strong">**ABOUT THE INI FILES**</span>

You can provide the compiler an INI file with a number of settings and
programmers.  

The following section provide details of the specifics within an example
INI file.   The comments are NOT part of an INI file.  

The settings are in the INI section called \[gcbasic\].  

``` screen
    [gcbasic]
    'The current order of the programmers as shown in Prefs Editor
    programmer = tinybootloader, lgt8fx8p, arduinouno, pickitpluscmd0, nsprog

    'Show the progress counters when compiling.  This can be changed in the INI or by a command line switch. There is no support in Prefs Editor to change this parameter.
    showprogresscounters = n

    'Show verbose when compiling.  This can be changed in the INI or by a command line switch
    verbose = n

    'Show source code in the generated ASM or .S files. This can be changed in the INI or by a command line switch
    preserve = a

    'Treat warning as errors. This can be changed in the INI or by a command line switch.&#160;&#160;There is no support in Prefs Editor to change this parameter.
    warningsaserrors = n

    'Pause after compilation. This can be changed in the INI or by a command line switch.&#160;&#160;There is no support in Prefs Editor to change this parameter.
    pauseaftercompile = n

    'Flash the chip only. This can be changed in the INI or by a command line switch. There is no support in Prefs Editor to change this parameter.
    flashonly = n

    'Selected assembler. This can be changed in the INI or by a command line switch.
    assembler = PIC-AS

    'Add comments to hex to show source compiler. This can be changed in the INI or by a command line switch.
    hexappendgcbmessage = n

    'Mute banners when compiling. This can be changed in the INI or by a command line switch. There is no support in Prefs Editor to change this parameter.
    mutebanners = n

    'Show the extended verbose messages when compiling. his can only be changed in the INI. There is no support in Prefs Editor or a command line switch to change this parameter.  Not managed by Prefs Editor.
    evbs = n

    'Use LAXSYNTAX supports lax validation.  This disables reserved word inspection, permits use of reserved words in GOTO statement.  Not managed by Prefs Editor.
    laxsyntax = y

    'Use NoSummary supports minimal compiler and assembly information when set to y.  Supports y|n.  Not managed by Prefs Editor.
    nosummary = n

    'Use the system temp directory for compiler temp files.  Options are "tempdir" or "instdir" or remove the option.
    workingdir = "tempdir"

    'Display conditional statement debug for the specified file.  Options are any valid source file or nothing. The enry will be remove if a prefixed by a comment ( a single quote ).
    conditionaldebugfile =
```

The section shows an example \[tool\] assembler section.  

``` screen
    [tool=pic-as]
    'An assember
    type = assembler
    'Location of the assember using a parameter substitution.
    command = %picaslocation%\pic-as.exe
    'Parameters
    params = -mcpu=%ChipModel%  "%Fn_NoExt%.S" -msummary=-mem,+psect,-class,-hex,-file,-sha1,-sha256,-xml,-xmlfull  -Wl -mcallgraph=std -mno-download-hex -o"%Fn_NoExt%.hex"  -Wl,-Map="%Fn_NoExt%.map" -Wa,-a

    [tool=mpasm]
    'An assember
    type = assembler
    'Location of the assember using a parameter substitution.
    command = %mpasmlocation%\mpasmx.exe
    'Paramters
    params = /c- /o- /q+ /l+ /x- /w1 "%FileName%"
```

The section shows an example \[patch\] section.

This section shows and explicit set of patches applied to PIC-AS
assembler.

``` screen
    [patch=asm2picas]
    desc = PICAS correction entries.  Format is STRICT as follows:  Must have quotes and the equal sign as the delimeter. PartName +COLON+"BadConfig"="GoodConfig"    Where BadConfig is from .s file and GoodConfig is from .cfgmap file
    16f88x:"intoscio = "="FOSC=INTRC_NOCLKOUT"
    16f8x:"intrc = IO"="FOSC=INTOSCIO"
    12f67x:"intrc = OSC_NOCLKOUT"="FOSC=INTRCIO"
```

The section shows an example \[programmer\] section.  

``` screen
    [tool = pk4_pic_ipecmd_program_release_from_reset]
    'Description
    desc = MPLAB-IPE PK4 CLI for PIC 5v0
    'A programmer
    type = programmer
    'Command line using a parameter substitution.
    command = %mplabxipedirectory%\ipecmd.exe
    'Parameters using a parameter substitution.
    params = -TPPK4 -P%chipmodel%  -F"%filename%" -M  -E -OL -W5
    'Worting direcroty using a parameter substitution.
    workingdir = %mplabxipedirectory%
    'Useif constraints - this shows none
    useif =
    'Mandated programming config constraints - this shows none
    progconfig =
```

<span class="strong">**ABOUT THE PREFS EDITOR**</span>

This is a utility for editing GCBASIC ini files.   It is derived from
the Graphical GCBASIC utilities, and requires some files from Graphical
GCBASIC to compile.  

The software is developed using Sharp Develop v.3.2.1 ( not Visual
Studio ).  

  

<span class="strong">**COMPILING**</span>

Ensure that the "Programmer Editor" folder is in the same folder as a
"Graphical GCBASIC" folder.   The "Graphical GCBASIC" folder must
contain the following files from GCGB: - Preferences.vb -
PreferencesWindow.vb - ProgrammerEditor.vb - Translator.vb -
ProgrammerEditor.resources

Once these files are in place, it should be possible to compile the
Programmer Editor using SharpDevelop 3.2 (or similar).

  

<span class="strong">**USING PREFS EDITOR**</span>

If run without any parameters, this program will create an ini file in
whatever directory it is located in.   If it is given the name of an ini
file as a command line parameter, it will use that file.  

As well as the ini file it is told to load, this program will also read
any files that are included from that file..   This makes it possible to
keep the settings file in the Application Data folder if GCBASIC is
installed in the Program Files directory..   To put the settings file
into the Application Data folder, create a small ini file containing the
following 3 lines and place it in the same directory as this program:

``` screen
    include %appdata%\gcgb.ini
    [gcgb]
    useappdata = true
```

The include line tells the program (and GCBASIC) to read from the
Application Data folder.   The useappdata=true line in the \[gcgb\]
section will cause this program to write any output to a file in
Application Data called gcgb.ini.   The hard coding of GCGB is required
this program is based on GCGB.   It will result in programmer
definitions being shared between GCGB and any other environment using
this editor, which may be a positive side effect.

  

<span class="strong">**BUILDING THE PROGRAMMER EDITOR EXECUTABLE USING
SHARP DEVELOP**</span>

To build Prefs Editor from the source files.   The list shows the
installation of the Sharp Develop IDE.

Complete the following:

``` screen
        1. Download and install Sharp Develop from  https://sourceforge.net/projects/sharpdevelop/files/SharpDevelop%203.x/3.2/[SourceForge]
        2. Download the Prefs Editor source using SVN into a source folder.  This is the folder ..\utils\Programmer Editor
        4. Run Sharp Develop (installed at step #1).  Load project  "Programmer Editor.sln"  from source source folder.
        5. Hit <f8> to compile.
```

  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>DeviceConfigurationRead</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_progmem_mcu_configuration.html" title="PROGMEM ( MCU Configuration )"><link rel="prev" href="_progmem_mcu_configuration.html" title="PROGMEM ( MCU Configuration )"><link rel="next" href="_safm.html" title="SAFM"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_deviceconfigurationread"></a>DeviceConfigurationRead</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    deviceconfigurationRead (<span class="emphasis"><em>location, store</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip PIC microcontrollers with self read capability. Not available on
Atmel AVR at present.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">deviceconfigurationRead</code> reads information from the configurations area of the  memory on chips that
support this feature. <code class="literal"><span class="emphasis"><em>location</em></span></code> and <code class="literal"><span class="emphasis"><em>store</em></span></code> are both word variables,
meaning that they can be values greater than 255.</p><p>The  <code class="literal"><span class="emphasis"><em>location</em></span></code> depends on the amount Microchip PIC microcontroller, which is given on the datasheet. <code class="literal"><span class="emphasis"><em>store</em></span></code> is
14 bits wide, and thus can store values up to <code class="literal">16383</code>.</p><p>This is an advanced command which should only be used by advanced developers.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="deviceconfigurationread"></span>DeviceConfigurationRead

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    deviceconfigurationRead (location, store)
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip PIC microcontrollers with self read
capability. Not available on Atmel AVR at present.

<span class="strong">**Explanation:**</span>

`deviceconfigurationRead` reads information from the configurations area
of the memory on chips that support this feature. `location` and `store`
are both word variables, meaning that they can be values greater than
255.

The `location` depends on the amount Microchip PIC microcontroller,
which is given on the datasheet. `store` is 14 bits wide, and thus can
store values up to `16383`.

This is an advanced command which should only be used by advanced
developers.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Difference</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_maths.html" title="Maths"><link rel="prev" href="_average.html" title="Average"><link rel="next" href="_logarithms.html" title="Logarithms"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_difference"></a>Difference</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <code class="literal">Difference ( word_variable1 , word_variable2 )</code> or
    <code class="literal">Difference ( byte_variable1 , byte_variable2 )</code></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>A function that returns the difference between of two numbers. This only supports byte or word variables.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    Difference( 8 ,4 ) ' Will return 4
    Difference( 0xff01 , 0xfffa ) ' Will return 0xf9 or 249d</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="difference"></span>Difference

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Difference ( word_variable1 , word_variable2 ) or
    Difference ( byte_variable1 , byte_variable2 )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

A function that returns the difference between of two numbers. This only
supports byte or word variables.

<span class="strong">**Example:**</span>

``` screen
    Difference( 8 ,4 ) ' Will return 4
    Difference( 0xff01 , 0xfffa ) ' Will return 0xf9 or 249d
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Dim</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_variable_lifecycle.html" title="Variable Lifecycle"><link rel="next" href="_alloc.html" title="Alloc"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_dim"></a>Dim</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="strong"><strong><span class="emphasis"><em>For Variables &gt; 1 byte:</em></span></strong></span>
    Dim <span class="emphasis"><em>variable</em></span>[, <span class="emphasis"><em>variable2</em></span> [, <span class="emphasis"><em>variable3</em></span>]] [As <span class="emphasis"><em>type</em></span>] [Alias <span class="emphasis"><em>othervar</em></span> [, <span class="emphasis"><em>othervar2</em></span>]]

    'or

    Dim <span class="emphasis"><em>variable</em></span>[, <span class="emphasis"><em>variable2</em></span> [, <span class="emphasis"><em>variable3</em></span>]] [As <span class="emphasis"><em>type</em></span>] [At <span class="emphasis"><em>location</em></span>]


    <span class="strong"><strong><span class="emphasis"><em>For Arrays:</em></span></strong></span>
    Dim <span class="emphasis"><em>array</em></span>(<span class="emphasis"><em>size</em></span>) [As <span class="emphasis"><em>type</em></span>] [At <span class="emphasis"><em>location</em></span>]

    <span class="strong"><strong><span class="emphasis"><em>For String:</em></span></strong></span>
    Dim <span class="emphasis"><em>string [* _size</em></span>] [At <span class="emphasis"><em>location</em></span>]</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Dim has two uses:&nbsp;&nbsp;It can be used to define 1) variables of many types and 2) arrays.</p><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p>The <code class="literal">Dim</code> variable command is used to instruct GCBASIC to allocate variables or to create alternate names for existing  variables (using Alias) or to create variables at a specific memory location (using At).</p><p>The <code class="literal">Dim array</code> command also sets up array variables. The maximum array size is determined by the parameter <code class="literal"><span class="emphasis"><em>size</em></span></code> is dynamically allocated by the compiler and depends on the specific chip used, as well as the complexity of the program.</p><p>The limit on array size varies dependent on the chip type.  See the <span class="strong"><strong>Maximum Array Size</strong></span> section in <a class="link" href="">Arrays</a> for more information.</p><p><code class="literal"><span class="emphasis"><em>type</em></span></code> specifies the type of variable that is to be created. Different variable types can hold values over different ranges, and use different amounts of RAM. See the <a class="link" href="">Variables</a> article for more information.</p><p>When multiple variables are included on the one line, GCBASIC will set them all to the type that is specified at the end of the line. If there is no type specified, then GCBASIC will make the variable a byte.</p><p><code class="literal">Alias</code> creates a variable using the same memory location as one or more other variables. &nbsp;&nbsp;It is mainly used internally in GCBASIC to treat system variables as a word.&nbsp;&nbsp; For example, this command is used to create a word variable, made up from the two memory locations used to store the result of an A/D conversion.&nbsp;&nbsp;`Alias` is mutually exclusive to <code class="literal">At</code> and therefore <code class="literal">Alias</code> and <code class="literal">At</code> on the same declaration line will cause an compiler error.</p><p><code class="literal">AT</code> a variable can be placed at a specific location in the data memory of the chip using the At option. &nbsp;&nbsp;`<span class="emphasis"><em>location</em></span>` will be used whether it is a valid location or not, but a warning will be generated if GCBASIC has already allocated the memory, or if the memory does not appear to be valid. &nbsp;&nbsp;This can be used for peripherals that have multi byte buffers in RAM.&nbsp;&nbsp;`At` is mutually exclusive to <code class="literal">Alias</code> and therefore <code class="literal">At</code> and <code class="literal">Alias</code> on the same declaration line will cause an compiler error.</p><p>A String declared with a fixed size (numeric constant that can be evaluated at compile time) is a fixed length string. It has no descriptor and it is not resized to fit its contents. If data overflows the size of the string, the memory may be overwrtten.
Fixed length strings are not NULL terminated, and they use size + 1 bytes of space.
String variable names need not end in a dollar sign $ as in other dialects of BASIC.</p><pre class="screen">    Dim ADResult As Word Alias ADRESH, ADRESL</pre><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will set up a array of ten bytes and a word variable

    dim DataList(10)
    dim Reading as word

    Reading = 21978
    DataList(1) = 15

    dim stringvariable as string</pre><p><span class="strong"><strong>For more help, see:&nbsp;&nbsp;</strong></span><a class="link" href="_serprint.html" title="SerPrint">SerPrint</a> articles as these articales show how to use Dim to create string variables and <a class="link" href="">Variables</a> for more details in creating and managing strings lengths.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="dim"></span>Dim

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    For Variables > 1 byte:
    Dim variable[, variable2 [, variable3]] [As type] [Alias othervar [, othervar2]]

    'or

    Dim variable[, variable2 [, variable3]] [As type] [At location]


    For Arrays:
    Dim array(size) [As type] [At location]

    For String:
    Dim string [* _size] [At location]
```

<span class="strong">**Explanation:**</span>

Dim has two uses:  It can be used to define 1) variables of many types
and 2) arrays.

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

The `Dim` variable command is used to instruct GCBASIC to allocate
variables or to create alternate names for existing variables (using
Alias) or to create variables at a specific memory location (using At).

The `Dim array` command also sets up array variables. The maximum array
size is determined by the parameter `size` is dynamically allocated by
the compiler and depends on the specific chip used, as well as the
complexity of the program.

The limit on array size varies dependent on the chip type. See the <span
class="strong">**Maximum Array Size**</span> section in
<a href="" class="link">Arrays</a> for more information.

`type` specifies the type of variable that is to be created. Different
variable types can hold values over different ranges, and use different
amounts of RAM. See the <a href="" class="link">Variables</a> article
for more information.

When multiple variables are included on the one line, GCBASIC will set
them all to the type that is specified at the end of the line. If there
is no type specified, then GCBASIC will make the variable a byte.

`Alias` creates a variable using the same memory location as one or more
other variables.   It is mainly used internally in GCBASIC to treat
system variables as a word.   For example, this command is used to
create a word variable, made up from the two memory locations used to
store the result of an A/D conversion.  \`Alias\` is mutually exclusive
to `At` and therefore `Alias` and `At` on the same declaration line will
cause an compiler error.

`AT` a variable can be placed at a specific location in the data memory
of the chip using the At option.   \`<span
class="emphasis">*location*</span>\` will be used whether it is a valid
location or not, but a warning will be generated if GCBASIC has already
allocated the memory, or if the memory does not appear to be valid.
  This can be used for peripherals that have multi byte buffers in
RAM.  \`At\` is mutually exclusive to `Alias` and therefore `At` and
`Alias` on the same declaration line will cause an compiler error.

A String declared with a fixed size (numeric constant that can be
evaluated at compile time) is a fixed length string. It has no
descriptor and it is not resized to fit its contents. If data overflows
the size of the string, the memory may be overwrtten. Fixed length
strings are not NULL terminated, and they use size + 1 bytes of space.
String variable names need not end in a dollar sign $ as in other
dialects of BASIC.

``` screen
    Dim ADResult As Word Alias ADRESH, ADRESL
```

<span class="strong">**Example:**</span>

``` screen
    'This program will set up a array of ten bytes and a word variable

    dim DataList(10)
    dim Reading as word

    Reading = 21978
    DataList(1) = 15

    dim stringvariable as string
```

<span class="strong">**For more help,
see:  **</span><a href="serprint" class="link" title="SerPrint">SerPrint</a>
articles as these articales show how to use Dim to create string
variables and <a href="" class="link">Variables</a> for more details in
creating and managing strings lengths.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Dir</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_miscellaneous_commands.html" title="Miscellaneous Commands"><link rel="prev" href="_miscellaneous_commands.html" title="Miscellaneous Commands"><link rel="next" href="_getuserid.html" title="GetUserID"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_dir"></a>Dir</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Dir <span class="emphasis"><em>port.bit</em></span> {In | Out}               <span class="strong"><strong><span class="emphasis"><em>(Individual Form)</em></span></strong></span>
    Dir <span class="emphasis"><em>port</em></span> {In | Out | <span class="emphasis"><em>DirectionByte</em></span>}  <span class="strong"><strong><span class="emphasis"><em>(Entire Port Form)</em></span></strong></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Dir</code> command is used to set the direction of the ports of the microcontroller chip. The individual form sets the direction of one pin at a time, whereas the entire port form will set all bits in a port.</p><p>In the individual form, specify the port and bit (ie. <code class="literal">PORTB.4</code>), then the direction, which is either In or Out.</p><p>The entire port form is similiar to the <code class="literal">TRIS</code> instruction offered by some Microchip PIC microcontrollers. To use it, give the name of the port (<span class="emphasis"><em>i.e.</em></span> <code class="literal">PORTA</code>), and then a byte is to be written into the <code class="literal">TRIS</code> variable. This form of the command is for those who are familiar with the Microchip PIC microcontrollers internal architecture.</p><p><span class="strong"><strong>Note:</strong></span>
Entire port form will work differently on Atmel AVR microcontrollers when a value other than IN or OUT is used. Atmel AVR microcontrollers use 0 to indicate in and 1 to indicate out, whereas Microchip PIC microcontrollers use 0 for out and 1 for in. When IN and OUT are used there are no compatibility issues.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program sets PORTA bits 0 and 1 to in, and the rest to out.
    'It also sets all of PORTB to output, except for B1.
    'Individual form is used for PORTA:
    DIR PORTA.0 IN
    DIR PORTA.1 IN
    DIR PORTA.2 OUT
    DIR PORTA.3 OUT
    DIR PORTA.4 OUT
    DIR PORTA.5 OUT
    DIR PORTA.6 OUT
    DIR PORTA.7 OUT
    'Entire port form used for B:
    DIR PORTB b'00000010'

    'Entire port form used for C:
    DIR PORTC IN</pre><p><span class="strong"><strong>Automatic DIRection setting by the compiler</strong></span></p><p>The compiler will set the automatic pin DIRection using the following logic.</p><p>Any time that the user program reads a pin or port, the compiler records that.   Any time that the user program writes to a pin or entire port, the compiler also records that.</p><p>Once all input code has been compiled, the compiler examinies the list of reads and writes.</p><p>If a pin is only ever written to, the compiler makes it an output.</p><p>If a pin is only ever read, the compiler does not know if the intent is to read the latch or an input value, so it sets that pin to be an input.</p><p>If the compiler sees a pin being read and written to, the compiler does not know if you are using a pin for some sort of bidirectional communication, or if you are just reading the latch. To avoid making incorrect assumptions, the compiler will expect you to set the pin direction manually.</p><p>If you use "portA.2 = 1", you&#8217;ve only written to the pin, so the compiler knows it must be an output.</p><p>If you use "portA.2 = not portA.2", the compiler sees that you are reading and writing to the pin, and will expect the user program set the direction instead of trying to guess what you are doing.</p><p>The compiler also records any use of the Dir command, and will not do any automatic direction setting on a pin if Dir has been used on that pin anywhere in the user program..</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="dir"></span>Dir

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Dir port.bit {In | Out}               (Individual Form)
    Dir port {In | Out | DirectionByte}  (Entire Port Form)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Dir` command is used to set the direction of the ports of the
microcontroller chip. The individual form sets the direction of one pin
at a time, whereas the entire port form will set all bits in a port.

In the individual form, specify the port and bit (ie. `PORTB.4`), then
the direction, which is either In or Out.

The entire port form is similiar to the `TRIS` instruction offered by
some Microchip PIC microcontrollers. To use it, give the name of the
port (<span class="emphasis">*i.e.*</span> `PORTA`), and then a byte is
to be written into the `TRIS` variable. This form of the command is for
those who are familiar with the Microchip PIC microcontrollers internal
architecture.

<span class="strong">**Note:**</span> Entire port form will work
differently on Atmel AVR microcontrollers when a value other than IN or
OUT is used. Atmel AVR microcontrollers use 0 to indicate in and 1 to
indicate out, whereas Microchip PIC microcontrollers use 0 for out and 1
for in. When IN and OUT are used there are no compatibility issues.

<span class="strong">**Example:**</span>

``` screen
    'This program sets PORTA bits 0 and 1 to in, and the rest to out.
    'It also sets all of PORTB to output, except for B1.
    'Individual form is used for PORTA:
    DIR PORTA.0 IN
    DIR PORTA.1 IN
    DIR PORTA.2 OUT
    DIR PORTA.3 OUT
    DIR PORTA.4 OUT
    DIR PORTA.5 OUT
    DIR PORTA.6 OUT
    DIR PORTA.7 OUT
    'Entire port form used for B:
    DIR PORTB b'00000010'

    'Entire port form used for C:
    DIR PORTC IN
```

<span class="strong">**Automatic DIRection setting by the
compiler**</span>

The compiler will set the automatic pin DIRection using the following
logic.

Any time that the user program reads a pin or port, the compiler records
that. Any time that the user program writes to a pin or entire port, the
compiler also records that.

Once all input code has been compiled, the compiler examinies the list
of reads and writes.

If a pin is only ever written to, the compiler makes it an output.

If a pin is only ever read, the compiler does not know if the intent is
to read the latch or an input value, so it sets that pin to be an input.

If the compiler sees a pin being read and written to, the compiler does
not know if you are using a pin for some sort of bidirectional
communication, or if you are just reading the latch. To avoid making
incorrect assumptions, the compiler will expect you to set the pin
direction manually.

If you use "portA.2 = 1", you’ve only written to the pin, so the
compiler knows it must be an output.

If you use "portA.2 = not portA.2", the compiler sees that you are
reading and writing to the pin, and will expect the user program set the
direction instead of trying to guess what you are doing.

The compiler also records any use of the Dir command, and will not do
any automatic direction setting on a pin if Dir has been used on that
pin anywhere in the user program..

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>DisplayChar</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_legacy.html" title="7 Segment Displays - Legacy"><link rel="prev" href="_displayvalue.html" title="DisplayValue"><link rel="next" href="_displaysegment.html" title="DisplaySegment"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_displaychar"></a>DisplayChar</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    DisplayChar (<span class="emphasis"><em>display, character, dot</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will display the given ASCII character on a seven segment
LED display.</p><p><code class="literal"><span class="emphasis"><em>display</em></span></code> is the number of the display to use. Up to 4 digits.<br></p><p><code class="literal"><span class="emphasis"><em>character</em></span></code> is the ASCII character to be shown.</p><p><code class="literal"><span class="emphasis"><em>dot</em></span></code> is an optional parameter. When it is 1 then the decimal point for that digit  is turned on.</p><p>This example below is a Common Cathode configuration.</p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">   'This program will show " Hello  " on a LED display
    'The display should be connected to PORTB and the Enable on PORTA.0

    #chip 16F877A, 20

    #define DISPLAYPORTA PORTB
    #define DISP_SEL_1 PORTA.0


    Dim Message As String
    Message = " Hello  "
  Do
    For Counter = 1 to len(Message)
      DisplayChar 1, Message(Counter)
      Wait 250 ms
    Next
  Loop</pre><p>This is a Common Anode example
There are three different methods for port specification
Note the ports are specified bit by bit in this case but
could be specified like Example 1
See Overview for further explanation.</p><p><span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">  'This program will show amessage on a LED display
  'This is a Dual digit Common anode with driver transistors example
   #chip 16F886, 8

    'support for Common Anode
    #define 7Seg_CommonAnode

    'support for pfet or pnp high side drivers
    #define 7Seg_HighSide

  ' Constants
  ' You need to specify the port settings
    #define DISP_SEG_A PORTB.0
    #define DISP_SEG_B PORTB.1
    #define DISP_SEG_C PORTB.2
    #define DISP_SEG_D PORTB.3
    #define DISP_SEG_E PORTB.4
    #define DISP_SEG_F PORTB.5
    #define DISP_SEG_G PORTB.6

    #define DISP_SEL_1 PORTC.5
    #define DISP_SEL_2 PORTC.4

    Dim Message As String
    Message = " Happy Holidays  "
    Do
    For Counter = 1 to len(Message)-2
      Repeat 50
        Displaychar 1, Message(Counter)
        wait 3 ms
        DisplayChar 2, Message(Counter+1)
        wait 3 ms
        end Repeat
      Wait 100 ms
    Next
    Loop</pre><p><span class="strong"><strong>Also, see</strong></span> <a class="link" href="_7_segment_displays_overview.html" title="7 Segment Displays Overview">7 Degment Display Overview</a>, <a class="link" href="_displayvalue.html" title="DisplayValue">DisplayValue</a>, <a class="link" href="_displaysegment.html" title="DisplaySegment">DisplaySegment</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="displaychar"></span>DisplayChar

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    DisplayChar (display, character, dot)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This command will display the given ASCII character on a seven segment
LED display.

`display` is the number of the display to use. Up to 4 digits.  

`character` is the ASCII character to be shown.

`dot` is an optional parameter. When it is 1 then the decimal point for
that digit is turned on.

This example below is a Common Cathode configuration.

<span class="strong">**Example 1:**</span>

``` screen
   'This program will show " Hello  " on a LED display
    'The display should be connected to PORTB and the Enable on PORTA.0

    #chip 16F877A, 20

    #define DISPLAYPORTA PORTB
    #define DISP_SEL_1 PORTA.0


    Dim Message As String
    Message = " Hello  "
  Do
    For Counter = 1 to len(Message)
      DisplayChar 1, Message(Counter)
      Wait 250 ms
    Next
  Loop
```

This is a Common Anode example There are three different methods for
port specification Note the ports are specified bit by bit in this case
but could be specified like Example 1 See Overview for further
explanation.

<span class="strong">**Example 2:**</span>

``` screen
  'This program will show amessage on a LED display
  'This is a Dual digit Common anode with driver transistors example
   #chip 16F886, 8

    'support for Common Anode
    #define 7Seg_CommonAnode

    'support for pfet or pnp high side drivers
    #define 7Seg_HighSide

  ' Constants
  ' You need to specify the port settings
    #define DISP_SEG_A PORTB.0
    #define DISP_SEG_B PORTB.1
    #define DISP_SEG_C PORTB.2
    #define DISP_SEG_D PORTB.3
    #define DISP_SEG_E PORTB.4
    #define DISP_SEG_F PORTB.5
    #define DISP_SEG_G PORTB.6

    #define DISP_SEL_1 PORTC.5
    #define DISP_SEL_2 PORTC.4

    Dim Message As String
    Message = " Happy Holidays  "
    Do
    For Counter = 1 to len(Message)-2
      Repeat 50
        Displaychar 1, Message(Counter)
        wait 3 ms
        DisplayChar 2, Message(Counter+1)
        wait 3 ms
        end Repeat
      Wait 100 ms
    Next
    Loop
```

<span class="strong">**Also, see**</span>
<a href="7_segment_displays_overview" class="link" title="7 Segment Displays Overview">7 Degment Display Overview</a>,
<a href="displayvalue" class="link" title="DisplayValue">DisplayValue</a>,
<a href="displaysegment" class="link" title="DisplaySegment">DisplaySegment</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>DisplaySegment</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_legacy.html" title="7 Segment Displays - Legacy"><link rel="prev" href="_displaychar.html" title="DisplayChar"><link rel="next" href="_7_segment_displays_tm1637_4_digits.html" title="7 Segment Displays - TM1637 4 Digits"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_displaysegment"></a>DisplaySegment</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    DisplayValue (<span class="emphasis"><em>display, data</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will display the given value on a seven segment LED
display.</p><p><code class="literal"><span class="emphasis"><em>display</em></span></code> is the number of the display to use. Up to 4 digits.<br></p><p><code class="literal"><span class="emphasis"><em>data</em></span></code> is the value between 0 and 255. Where <span class="emphasis"><em>data</em></span> is the representation of the segments to be set.</p><p><span class="strong"><strong>Example</strong></span></p><pre class="screen">      'This program will count from 10 to 0 then fire the rocket!
      'The method DisplaySegment 1, smallTCharacter.  Sets the 7 segment to the value of 120, see the constant, 120 equates to a small t.
      ; ----- Configuration

        #chip 16F690, 4

      ; ----- Define Hardware settings
        Dir PORTC Out
        DIR PORTA.5 out
        DIR PORTA.4 out
        DIR PORTA.0 out
        DIR PORTA.1 out
        DIR PORTA.2 in
        DIR PORTB.7 out
      ; ----- Constants
        ; You need to specify the port settings
        #define DISP_SEG_A PORTC.0
        #define DISP_SEG_B PORTC.1
        #define DISP_SEG_C PORTC.2
        #define DISP_SEG_D PORTC.3
        #define DISP_SEG_E PORTC.4
        #define DISP_SEG_F PORTC.5
        #define DISP_SEG_G PORTC.6
        #define DECPNT     PORTC.7
        #define DISP_SEL_1 PORTA.5
        #define DISP_SEL_2 PORTA.4
        #define DISP_SEL_3 PORTA.1
        #define DISP_SEL_4 PORTA.0

        #define smallTCharacter 120 'raw character for 't' on 7 segment.

        #define sw1 PORTA.2

        #define firingPort PORTB.7

      ; ----- Variables
        CountDownValue = 10

      ; ----- Main body of program commences here.
      DECPNT = 1 'Decimal Point off

        Main:
          ' Push number to 7 Segment Display
        if sw1 = 0 then goto Countdown

         num2 = 1
         num3 = 0
         cnt = 5
         gosub display

      goto main

        Countdown:


          num2 = CountDownValue/10
          num3 = CountDownValue%10
          cnt = 60

          gosub display

          If sw1 = 0 then goto hld

          if CountDownValue = 0 then
              firingPort = 1
              cnt = 200
              gosub dispfire
              firingPort = 0
             CountDownValue = 10
             goto main
          end if

          CountDownValue = CountDownValue - 1

        goto Countdown


        display:
         Repeat cnt
                DisplaySegment 1, smallTCharacter
                wait 5 ms
                Displaychar 2, "-"
                DisplayValue 3, Num2
                wait 5 ms
                DisplayValue 4, Num3
                wait 5 ms
         end Repeat

         return

       hld:
        if sw1 = 0 then goto hld
        cnt = 5
        gosub Display
        if sw1 = 1 then goto hld
        goto countdown

       DispFire:
        Repeat cnt

                Displaychar 1, "F"
                wait 5 ms
                Displaychar 2, "i"
                wait 5 ms
                Displaychar 3, "r"
                wait 5 ms
                Displaychar 4, "E"
                wait 5 ms
        End Repeat
       return

      end</pre><p><span class="strong"><strong>Also, see</strong></span> <a class="link" href="_7_segment_displays_overview.html" title="7 Segment Displays Overview">7 Segment Display Overview</a>, <a class="link" href="_displaychar.html" title="DisplayChar">DisplayChar</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="displaysegment"></span>DisplaySegment

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    DisplayValue (display, data)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This command will display the given value on a seven segment LED
display.

`display` is the number of the display to use. Up to 4 digits.  

`data` is the value between 0 and 255. Where <span
class="emphasis">*data*</span> is the representation of the segments to
be set.

<span class="strong">**Example**</span>

``` screen
      'This program will count from 10 to 0 then fire the rocket!
      'The method DisplaySegment 1, smallTCharacter.  Sets the 7 segment to the value of 120, see the constant, 120 equates to a small t.
      ; ----- Configuration

        #chip 16F690, 4

      ; ----- Define Hardware settings
        Dir PORTC Out
        DIR PORTA.5 out
        DIR PORTA.4 out
        DIR PORTA.0 out
        DIR PORTA.1 out
        DIR PORTA.2 in
        DIR PORTB.7 out
      ; ----- Constants
        ; You need to specify the port settings
        #define DISP_SEG_A PORTC.0
        #define DISP_SEG_B PORTC.1
        #define DISP_SEG_C PORTC.2
        #define DISP_SEG_D PORTC.3
        #define DISP_SEG_E PORTC.4
        #define DISP_SEG_F PORTC.5
        #define DISP_SEG_G PORTC.6
        #define DECPNT     PORTC.7
        #define DISP_SEL_1 PORTA.5
        #define DISP_SEL_2 PORTA.4
        #define DISP_SEL_3 PORTA.1
        #define DISP_SEL_4 PORTA.0

        #define smallTCharacter 120 'raw character for 't' on 7 segment.

        #define sw1 PORTA.2

        #define firingPort PORTB.7

      ; ----- Variables
        CountDownValue = 10

      ; ----- Main body of program commences here.
      DECPNT = 1 'Decimal Point off

        Main:
          ' Push number to 7 Segment Display
        if sw1 = 0 then goto Countdown

         num2 = 1
         num3 = 0
         cnt = 5
         gosub display

      goto main

        Countdown:


          num2 = CountDownValue/10
          num3 = CountDownValue%10
          cnt = 60

          gosub display

          If sw1 = 0 then goto hld

          if CountDownValue = 0 then
              firingPort = 1
              cnt = 200
              gosub dispfire
              firingPort = 0
             CountDownValue = 10
             goto main
          end if

          CountDownValue = CountDownValue - 1

        goto Countdown


        display:
         Repeat cnt
                DisplaySegment 1, smallTCharacter
                wait 5 ms
                Displaychar 2, "-"
                DisplayValue 3, Num2
                wait 5 ms
                DisplayValue 4, Num3
                wait 5 ms
         end Repeat

         return

       hld:
        if sw1 = 0 then goto hld
        cnt = 5
        gosub Display
        if sw1 = 1 then goto hld
        goto countdown

       DispFire:
        Repeat cnt

                Displaychar 1, "F"
                wait 5 ms
                Displaychar 2, "i"
                wait 5 ms
                Displaychar 3, "r"
                wait 5 ms
                Displaychar 4, "E"
                wait 5 ms
        End Repeat
       return

      end
```

<span class="strong">**Also, see**</span>
<a href="7_segment_displays_overview" class="link" title="7 Segment Displays Overview">7 Segment Display Overview</a>,
<a href="displaychar" class="link" title="DisplayChar">DisplayChar</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>DisplayValue</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_legacy.html" title="7 Segment Displays - Legacy"><link rel="prev" href="_common_anode.html" title="Common Anode"><link rel="next" href="_displaychar.html" title="DisplayChar"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_displayvalue"></a>DisplayValue</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    DisplayValue (<span class="emphasis"><em>display, data, dot</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will display the given value on a seven segment LED
display.</p><p><code class="literal"><span class="emphasis"><em>display</em></span></code> is the number of the display to use. Up to 4 digits.<br></p><p><code class="literal"><span class="emphasis"><em>data</em></span></code> is the value between 0 and F to be shown.</p><p><code class="literal"><span class="emphasis"><em>dot</em></span></code> is an optional parameter. When it is 1 then the decimal point for that digit  is turned on.</p><p>The command also support HEX characters in the range between 0x00 and
0x0F (0 to 15). See example two below for usage.</p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    'This program will count from 0 to 99 on two LED displays
    #chip 16F819, 8

  'See 7 Segment Display Overview for alternate ways of defining Ports
    #define DISP_SEG_A PORTB.0
    #define DISP_SEG_B PORTB.1
    #define DISP_SEG_C PORTB.2
    #define DISP_SEG_D PORTB.3
    #define DISP_SEG_E PORTB.4
    #define DISP_SEG_F PORTB.5
    #define DISP_SEG_G PORTB.6
  '#define DISP_SEG_DOT PORTB.7 ' Optional DP

    #define DISP_SEL_1 PORTA.0
    #define DISP_SEL_2 PORTA.1

    Do
        For Counter = 0 To 99

            'Get the 2 digits
            Number = Counter
            Num1 = 0
            If Number &gt;= 10 Then
                Num1 = Number / 10
                'SysCalcTempX stores remainder after division
                Number = SysCalcTempX
            End If
            Num2 = Number

            'Show the digits
            'Each DisplayValue will erase the other (multiplexing)
            'So they must be called often enough that the flickering
            'cannot be seen.
            Repeat 500
                DisplayValue 1, Num1
                Wait 1 ms
                DisplayValue 2, Num2
                Wait 1 ms
            End Repeat
        Next
    Loop</pre><p><span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    'This program will count from 0 to 0xff on two LED displays
    #chip 16F819, 8

    #define DISP_SEG_A PORTB.0
    #define DISP_SEG_B PORTB.1
    #define DISP_SEG_C PORTB.2
    #define DISP_SEG_D PORTB.3
    #define DISP_SEG_E PORTB.4
    #define DISP_SEG_F PORTB.5
    #define DISP_SEG_G PORTB.6

    #define DISP_SEL_1 PORTA.0
    #define DISP_SEL_2 PORTA.1
    #define DISP_SEL_4 PORTA.2
    #define DISP_SEL_3 PORTA.3

    Do
        For Counter = 0 To 0xff

            'Get the 2 digits
            Number = Counter
            Num1 = 0
            If Number &gt;= 0x10 Then
                Num1 = Number / 0x10
                'SysCalcTempX stores remainder after division
                Number = SysCalcTempX
            End If
            Num2 = Number

            'Show the digits
            'Each DisplayValue will erase the other (multiplexing)
            'So they must be called often enough that the flickering
            'cannot be seen.
            Repeat 500
                DisplayValue 1, Num1
                Wait 1 ms
                DisplayValue 2, Num2
                Wait 1 ms
            End Repeat
        Next
    Loop</pre><p><span class="strong"><strong>Also, see</strong></span> <a class="link" href="_7_segment_displays_overview.html" title="7 Segment Displays Overview">7 Segment Display Overview</a>, <a class="link" href="_displaychar.html" title="DisplayChar">DisplayChar</a>, <a class="link" href="_displaysegment.html" title="DisplaySegment">DisplaySegment</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="displayvalue"></span>DisplayValue

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    DisplayValue (display, data, dot)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This command will display the given value on a seven segment LED
display.

`display` is the number of the display to use. Up to 4 digits.  

`data` is the value between 0 and F to be shown.

`dot` is an optional parameter. When it is 1 then the decimal point for
that digit is turned on.

The command also support HEX characters in the range between 0x00 and
0x0F (0 to 15). See example two below for usage.

<span class="strong">**Example 1:**</span>

``` screen
    'This program will count from 0 to 99 on two LED displays
    #chip 16F819, 8

  'See 7 Segment Display Overview for alternate ways of defining Ports
    #define DISP_SEG_A PORTB.0
    #define DISP_SEG_B PORTB.1
    #define DISP_SEG_C PORTB.2
    #define DISP_SEG_D PORTB.3
    #define DISP_SEG_E PORTB.4
    #define DISP_SEG_F PORTB.5
    #define DISP_SEG_G PORTB.6
  '#define DISP_SEG_DOT PORTB.7 ' Optional DP

    #define DISP_SEL_1 PORTA.0
    #define DISP_SEL_2 PORTA.1

    Do
        For Counter = 0 To 99

            'Get the 2 digits
            Number = Counter
            Num1 = 0
            If Number >= 10 Then
                Num1 = Number / 10
                'SysCalcTempX stores remainder after division
                Number = SysCalcTempX
            End If
            Num2 = Number

            'Show the digits
            'Each DisplayValue will erase the other (multiplexing)
            'So they must be called often enough that the flickering
            'cannot be seen.
            Repeat 500
                DisplayValue 1, Num1
                Wait 1 ms
                DisplayValue 2, Num2
                Wait 1 ms
            End Repeat
        Next
    Loop
```

<span class="strong">**Example 2:**</span>

``` screen
    'This program will count from 0 to 0xff on two LED displays
    #chip 16F819, 8

    #define DISP_SEG_A PORTB.0
    #define DISP_SEG_B PORTB.1
    #define DISP_SEG_C PORTB.2
    #define DISP_SEG_D PORTB.3
    #define DISP_SEG_E PORTB.4
    #define DISP_SEG_F PORTB.5
    #define DISP_SEG_G PORTB.6

    #define DISP_SEL_1 PORTA.0
    #define DISP_SEL_2 PORTA.1
    #define DISP_SEL_4 PORTA.2
    #define DISP_SEL_3 PORTA.3

    Do
        For Counter = 0 To 0xff

            'Get the 2 digits
            Number = Counter
            Num1 = 0
            If Number >= 0x10 Then
                Num1 = Number / 0x10
                'SysCalcTempX stores remainder after division
                Number = SysCalcTempX
            End If
            Num2 = Number

            'Show the digits
            'Each DisplayValue will erase the other (multiplexing)
            'So they must be called often enough that the flickering
            'cannot be seen.
            Repeat 500
                DisplayValue 1, Num1
                Wait 1 ms
                DisplayValue 2, Num2
                Wait 1 ms
            End Repeat
        Next
    Loop
```

<span class="strong">**Also, see**</span>
<a href="7_segment_displays_overview" class="link" title="7 Segment Displays Overview">7 Segment Display Overview</a>,
<a href="displaychar" class="link" title="DisplayChar">DisplayChar</a>,
<a href="displaysegment" class="link" title="DisplaySegment">DisplaySegment</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Do</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_flow_control.html" title="Flow control"><link rel="prev" href="_flow_control.html" title="Flow control"><link rel="next" href="_end.html" title="End"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_do"></a>Do</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Do [{While | Until} <span class="emphasis"><em>condition</em></span>]
    ...
    <span class="emphasis"><em>program code</em></span>
    ...
    <span class="emphasis"><em>&lt;condition&gt;</em></span> Exit Do
    ...
    Loop [{While | Until} <span class="emphasis"><em>condition</em></span>]</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Do</code> command will cause the code between the <code class="literal">Do</code> and the <code class="literal">Loop</code> to run
repeatedly while <code class="literal"><span class="emphasis"><em>condition</em></span></code> is true or until <code class="literal"><span class="emphasis"><em>condition</em></span></code> is true,
depending on whether <code class="literal">While</code> or <code class="literal">Until</code> has been specified.</p><p>Note that the <code class="literal">While</code> or <code class="literal">Until</code> and the condition can only be specified
once, or not at all. If they are not specified, then the code will
repeat endlessly.</p><p>Optionally, you can specify a condition to <code class="literal">EXIT</code> the <code class="literal">Do-Loop</code> immediately.</p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    'This code will flash a light until the button is pressed
    #chip 12F629, 4

    #define BUTTON GPIO.3
    #define LIGHT GPIO.5

    Dir BUTTON In
    Dir LIGHT Out

    Do Until BUTTON = 1
      PulseOut LIGHT, 1 s
      Wait 1 s
    Loop</pre><p><span class="strong"><strong>Example 2:</strong></span></p><p>This code will also flash a light until the button is pressed. This
example uses <code class="literal">EXIT DO</code> within a continuous loop.</p><pre class="screen">    #chip 12F629, 4

    #define BUTTON GPIO.3
    #define LIGHT GPIO.5

    Dir BUTTON In
    Dir LIGHT Out

    Do
      PulseOut LIGHT, 1 s
      Wait 1 s
      if BUTTON = 1 then EXIT DO
    Loop</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_conditions.html" title="Conditions">Conditions</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="do"></span>Do

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Do [{While | Until} condition]
    ...
    program code
    ...
    <condition> Exit Do
    ...
    Loop [{While | Until} condition]
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Do` command will cause the code between the `Do` and the `Loop` to
run repeatedly while `condition` is true or until `condition` is true,
depending on whether `While` or `Until` has been specified.

Note that the `While` or `Until` and the condition can only be specified
once, or not at all. If they are not specified, then the code will
repeat endlessly.

Optionally, you can specify a condition to `EXIT` the `Do-Loop`
immediately.

<span class="strong">**Example 1:**</span>

``` screen
    'This code will flash a light until the button is pressed
    #chip 12F629, 4

    #define BUTTON GPIO.3
    #define LIGHT GPIO.5

    Dir BUTTON In
    Dir LIGHT Out

    Do Until BUTTON = 1
      PulseOut LIGHT, 1 s
      Wait 1 s
    Loop
```

<span class="strong">**Example 2:**</span>

This code will also flash a light until the button is pressed. This
example uses `EXIT DO` within a continuous loop.

``` screen
    #chip 12F629, 4

    #define BUTTON GPIO.3
    #define LIGHT GPIO.5

    Dir BUTTON In
    Dir LIGHT Out

    Do
      PulseOut LIGHT, 1 s
      Wait 1 s
      if BUTTON = 1 then EXIT DO
    Loop
```

<span class="strong">**For more help, see
<a href="conditions" class="link" title="Conditions">Conditions</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>DS18B20</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_one_wire_devices.html" title="One Wire Devices"><link rel="prev" href="_one_wire_devices.html" title="One Wire Devices"><link rel="next" href="_readdigitaltemp.html" title="ReadDigitalTemp"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_ds18b20"></a>DS18B20</h4></div></div></div><p>The DS18B20 is a 1-Wire digital temperature sensor from Maxim IC.</p><p>The sensor reports degrees C with 9 to 12-bit precision from -55C to 125C (+/- 0.5C).</p><p>Each sensor has a unique 64-Bit Serial number etched into it. This allows for a number of sensors to be used on one data bus. This sensor is used in many data-logging and temperature control projects.</p><p>Reading the temperature from a DS18B20 takes up to 750ms(max).</p><p>To use the DS18B20 driver the following is required to added to the GCBASIC source file.</p><pre class="screen">    #include &lt;DS18B20.h&gt;</pre><p>Note the GCBASIC commands do not work with the older DS1820 or DS18S20 as they have a different internal resolution.</p><p>These commands are not designed to be used with parasitically powered DS18B20 sensors.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Usage</th><th align="left" valign="top">Returns</th></tr></thead><tbody><tr><td align="left" valign="top"><p>ReadDigitalTemp</p></td><td align="left" valign="top"><p>Returns two global variables.&nbsp;&nbsp;As follows:
</p><p><span class="strong"><strong><code class="literal">DSint</code></strong></span> the integer value read from the sensors
<span class="strong"><strong><code class="literal">DSdec</code></strong></span> the string value read from the sensors</p></td><td align="left" valign="top"><p>Byte variables:
<span class="strong"><strong><code class="literal">DSint</code></strong></span>
</p><p>String variable: <span class="strong"><strong><code class="literal">DSdec</code></strong></span></p></td></tr><tr><td align="left" valign="top"><p>ReadTemp</p></td><td align="left" valign="top"><p><span class="strong"><strong><code class="literal">ReadTemp</code></strong></span> is a function that returns the raw value of the sensor.
</p><p>The temperature is read back in whole degree steps, and the sensor operates from -55 to + 125 degrees Celsius.;&nbsp;&amp;#160Note that bit 7 is 0 for positive temperature values and 1 for negative values (ie negative values will appear as 128 + numeric value).</p></td><td align="left" valign="top"><p>Word variable via the ReadTemp() function</p></td></tr><tr><td align="left" valign="top"><p>ReadTemp12</p></td><td align="left" valign="top"><p><span class="strong"><strong><code class="literal">ReadTemp</code></strong></span> is a function that returns the raw 12bit value of the sensor.
</p><p>The temperature is read back as the raw 12 bit data into a word variable (0.0625 degree resolution).;&nbsp;&amp;#160The user must interpret the data through mathematical manipulation. See the DS18B20 datasheet for more information on the 12 bit temperature/data information construct.</p></td><td align="left" valign="top"><p>Word variable via the ReadTemp12() function</p></td></tr></tbody></table></div><p><br>
<br></p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_readdigitaltemp.html" title="ReadDigitalTemp">ReadDigitalTemp</a>, <a class="link" href="_readtemp.html" title="ReadTemp">ReadTemp</a> or <a class="link" href="_readtemp12.html" title="ReadTemp12">ReadTemp12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="ds18b20"></span>DS18B20

</div>

</div>

</div>

The DS18B20 is a 1-Wire digital temperature sensor from Maxim IC.

The sensor reports degrees C with 9 to 12-bit precision from -55C to
125C (+/- 0.5C).

Each sensor has a unique 64-Bit Serial number etched into it. This
allows for a number of sensors to be used on one data bus. This sensor
is used in many data-logging and temperature control projects.

Reading the temperature from a DS18B20 takes up to 750ms(max).

To use the DS18B20 driver the following is required to added to the
GCBASIC source file.

``` screen
    #include <DS18B20.h>
```

Note the GCBASIC commands do not work with the older DS1820 or DS18S20
as they have a different internal resolution.

These commands are not designed to be used with parasitically powered
DS18B20 sensors.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Usage</th>
<th style="text-align: left;">Returns</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>ReadDigitalTemp</p></td>
<td style="text-align: left;"><p>Returns two global variables.  As follows:</p>
<p><span class="strong"><strong><code class="literal">DSint</code></strong></span> the integer value read from the sensors <span class="strong"><strong><code class="literal">DSdec</code></strong></span> the string value read from the sensors</p></td>
<td style="text-align: left;"><p>Byte variables: <span class="strong"><strong><code class="literal">DSint</code></strong></span></p>
<p>String variable: <span class="strong"><strong><code class="literal">DSdec</code></strong></span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>ReadTemp</p></td>
<td style="text-align: left;"><p><span class="strong"><strong><code class="literal">ReadTemp</code></strong></span> is a function that returns the raw value of the sensor.</p>
<p>The temperature is read back in whole degree steps, and the sensor operates from -55 to + 125 degrees Celsius.; &amp;#160Note that bit 7 is 0 for positive temperature values and 1 for negative values (ie negative values will appear as 128 + numeric value).</p></td>
<td style="text-align: left;"><p>Word variable via the ReadTemp() function</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>ReadTemp12</p></td>
<td style="text-align: left;"><p><span class="strong"><strong><code class="literal">ReadTemp</code></strong></span> is a function that returns the raw 12bit value of the sensor.</p>
<p>The temperature is read back as the raw 12 bit data into a word variable (0.0625 degree resolution).; &amp;#160The user must interpret the data through mathematical manipulation. See the DS18B20 datasheet for more information on the 12 bit temperature/data information construct.</p></td>
<td style="text-align: left;"><p>Word variable via the ReadTemp12() function</p></td>
</tr>
</tbody>
</table>

</div>

  
  

<span class="strong">**For more help, see**</span>
<a href="readdigitaltemp" class="link" title="ReadDigitalTemp">ReadDigitalTemp</a>,
<a href="readtemp" class="link" title="ReadTemp">ReadTemp</a> or
<a href="readtemp12" class="link" title="ReadTemp12">ReadTemp12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>DS18B20SetResolution</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_one_wire_devices.html" title="One Wire Devices"><link rel="prev" href="_readtemp12.html" title="ReadTemp12"><link rel="next" href="_serial_communications.html" title="Serial Communications"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_ds18b20setresolution"></a>DS18B20SetResolution</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><p>For Single Channel/Device only. The method assumes a single DS18B20 device on the OneWire bus.</p><pre class="screen">    DS18B20SetResolution ( [DS18B20SetResolution_CONTSTANT] )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Set the DS18B20 operating resolution.&nbsp;&nbsp;
The configuration register of the DS18B20 allows the user to set the resolution of the temperature-to-digital conversion to 9, 10, 11, or 12 bits. &nbsp;&nbsp;
This method set the operating resolution to either 9, 10, 11, or 12 bits.&nbsp;&nbsp;</p><p>Calling the method with no parameter will set the operating resolution of the DS18B20 to 12 bits.&nbsp;&nbsp;
See example 3 below.</p><p><span class="strong"><strong>Constants</strong></span></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">CONSTANT</th><th align="left" valign="top">Operating resolution</th><th align="left" valign="top">Temprature resolution</th></tr></thead><tbody><tr><td align="left" valign="top"><p>DS18B20_TEMP_9_BIT</p></td><td align="left" valign="top"><p>9 bits</p></td><td align="left" valign="top"><p>0.5c</p></td></tr><tr><td align="left" valign="top"><p>DS18B20_TEMP_10_BIT</p></td><td align="left" valign="top"><p>10 bits</p></td><td align="left" valign="top"><p>0.25c</p></td></tr><tr><td align="left" valign="top"><p>DS18B20_TEMP_11_BIT</p></td><td align="left" valign="top"><p>11 bits</p></td><td align="left" valign="top"><p>0.125c</p></td></tr><tr><td align="left" valign="top"><p>DS18B20_TEMP_12_BIT</p></td><td align="left" valign="top"><p>12 bits</p></td><td align="left" valign="top"><p>0.0625c</p></td></tr></tbody></table></div><p><br>
<span class="strong"><strong>Example Usage 1</strong></span></p><p>The follow example sets the operating resolution of the DS18B20 to 12 bits.</p><pre class="screen">    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required
    DS18B20SetResolution ( DS18B20_TEMP_12_BIT )</pre><p><span class="strong"><strong>Example Usage 2</strong></span></p><p>The follow example sets the operating resolution of the DS18B20 to 9 bits.</p><pre class="screen">    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required
    DS18B20SetResolution ( DS18B20_TEMP_9_BIT )</pre><p><span class="strong"><strong>Example Usage 3</strong></span></p><p>The follow example sets the operating resolution of the DS18B20 to the default value of 12 bits.</p><pre class="screen">    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required
    DS18B20SetResolution ( )</pre><p><span class="strong"><strong>Working Example Program</strong></span></p><p>The following program will display the temperature on a serial attached LCD.&nbsp;&nbsp;
Change the <code class="literal">DS18B20SetResolution ()</code> method to set the resolution of a specific setting.</p><p>You may need to change the chip, edit/remove PPS, and/or the change LCD settings to make this program work with your configuration.&nbsp;&nbsp;</p><pre class="screen">#chip 16f18313
#config MCLR=ON
#option Explicit
#include &lt;ds18b20.h&gt;

    'Generated by PIC PPS Tool for GCBASIC
    'PPS Tool version: 0.0.6.1
    'PinManager data: v1.79.0
    'Generated for 16f18313
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85
    #define PPSToolPart 16f18313

    Sub InitPPS

            'Module: EUSART
            RA5PPS = 0x0014    'TX &gt; RA5

    End Sub
    'Template comment at the end of the config file

    'USART settings for USART1
    #define USART_BAUD_RATE 115200
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF

    #define LCD_IO 107   'K107
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width


    ; ----- Constants
    ' DS18B20 port settings
    #define DQ RA4

; ----- Variables
  dim TempC_100 as LONG   ' a variabler to handle the temperature calculations
  Dim DSdata,WHOLE, FRACT, DIG as word
  Dim CCOUNT, SIGNBIT as Byte


; ----- Main body of program commences here.

    ccount = 0
    CLS
    print "GCBasic 2021"
    locate 1,0
    print "DS18B20 Demo"
    wait 2 s
    CLS

    DS18B20SetResolution ( DS18B20_TEMP_12_BIT )

    do forever
       ' The function readtemp returns the integer value of the sensor
       DSdata = readtemp

       ' Display the integer value of the sensor on the LCD
       locate 0,0
       print hex(ccount)
       print " Ceil"
       locate 0,8
       print DSdata
       print chr(223)+"C"



       ' Display the integer and decimal value of the sensor on the LCD

       ' The function readtemp12 returns the raw value of the sensor.
       ' The sensor is read as a 12 bit value therefore each unit equates to 0.0625 of a degree
       DSdata = readtemp12


       SignBit = DSdata / 256 / 128
       If SignBit = 0 Then goto Positive
       ' its negative!
       DSdata = ( DSdata # 0xffff ) + 1 ' take twos comp


    Positive:
       ' Convert value * 0.0625 by factorisation
       TempC_100 =  DSdata *  625
       Whole = TempC_100 / 10000
       Fract = TempC_100 % 10000


       If SignBit = 0 Then goto DisplayTemp
       Print "-"

    DisplayTemp:
       Locate 3,0
       Print Whole
       Print "."
       Print leftpad( str(Fract),4,"0")

       wait 2 s
       ccount++

    loop</pre><p><br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="ds18b20setresolution"></span>DS18B20SetResolution

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

For Single Channel/Device only. The method assumes a single DS18B20
device on the OneWire bus.

``` screen
    DS18B20SetResolution ( [DS18B20SetResolution_CONTSTANT] )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

Set the DS18B20 operating resolution.   The configuration register of
the DS18B20 allows the user to set the resolution of the
temperature-to-digital conversion to 9, 10, 11, or 12 bits.    This
method set the operating resolution to either 9, 10, 11, or 12 bits.  

Calling the method with no parameter will set the operating resolution
of the DS18B20 to 12 bits.   See example 3 below.

<span class="strong">**Constants**</span>

<div class="informaltable">

| CONSTANT               | Operating resolution | Temprature resolution |
|:-----------------------|:---------------------|:----------------------|
| DS18B20\_TEMP\_9\_BIT  | 9 bits               | 0.5c                  |
| DS18B20\_TEMP\_10\_BIT | 10 bits              | 0.25c                 |
| DS18B20\_TEMP\_11\_BIT | 11 bits              | 0.125c                |
| DS18B20\_TEMP\_12\_BIT | 12 bits              | 0.0625c               |

</div>

  
<span class="strong">**Example Usage 1**</span>

The follow example sets the operating resolution of the DS18B20 to 12
bits.

``` screen
    #include <DS18B20.h>
    #define DQ PortC.3 ; change port configuration as required
    DS18B20SetResolution ( DS18B20_TEMP_12_BIT )
```

<span class="strong">**Example Usage 2**</span>

The follow example sets the operating resolution of the DS18B20 to 9
bits.

``` screen
    #include <DS18B20.h>
    #define DQ PortC.3 ; change port configuration as required
    DS18B20SetResolution ( DS18B20_TEMP_9_BIT )
```

<span class="strong">**Example Usage 3**</span>

The follow example sets the operating resolution of the DS18B20 to the
default value of 12 bits.

``` screen
    #include <DS18B20.h>
    #define DQ PortC.3 ; change port configuration as required
    DS18B20SetResolution ( )
```

<span class="strong">**Working Example Program**</span>

The following program will display the temperature on a serial attached
LCD.   Change the `DS18B20SetResolution ()` method to set the resolution
of a specific setting.

You may need to change the chip, edit/remove PPS, and/or the change LCD
settings to make this program work with your configuration.  

``` screen
#chip 16f18313
#config MCLR=ON
#option Explicit
#include <ds18b20.h>

    'Generated by PIC PPS Tool for GCBASIC
    'PPS Tool version: 0.0.6.1
    'PinManager data: v1.79.0
    'Generated for 16f18313
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85
    #define PPSToolPart 16f18313

    Sub InitPPS

            'Module: EUSART
            RA5PPS = 0x0014    'TX > RA5

    End Sub
    'Template comment at the end of the config file

    'USART settings for USART1
    #define USART_BAUD_RATE 115200
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF

    #define LCD_IO 107   'K107
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width


    ; ----- Constants
    ' DS18B20 port settings
    #define DQ RA4

; ----- Variables
  dim TempC_100 as LONG   ' a variabler to handle the temperature calculations
  Dim DSdata,WHOLE, FRACT, DIG as word
  Dim CCOUNT, SIGNBIT as Byte


; ----- Main body of program commences here.

    ccount = 0
    CLS
    print "GCBasic 2021"
    locate 1,0
    print "DS18B20 Demo"
    wait 2 s
    CLS

    DS18B20SetResolution ( DS18B20_TEMP_12_BIT )

    do forever
       ' The function readtemp returns the integer value of the sensor
       DSdata = readtemp

       ' Display the integer value of the sensor on the LCD
       locate 0,0
       print hex(ccount)
       print " Ceil"
       locate 0,8
       print DSdata
       print chr(223)+"C"



       ' Display the integer and decimal value of the sensor on the LCD

       ' The function readtemp12 returns the raw value of the sensor.
       ' The sensor is read as a 12 bit value therefore each unit equates to 0.0625 of a degree
       DSdata = readtemp12


       SignBit = DSdata / 256 / 128
       If SignBit = 0 Then goto Positive
       ' its negative!
       DSdata = ( DSdata # 0xffff ) + 1 ' take twos comp


    Positive:
       ' Convert value * 0.0625 by factorisation
       TempC_100 =  DSdata *  625
       Whole = TempC_100 / 10000
       Fract = TempC_100 % 10000


       If SignBit = 0 Then goto DisplayTemp
       Print "-"

    DisplayTemp:
       Locate 3,0
       Print Whole
       Print "."
       Print leftpad( str(Fract),4,"0")

       wait 2 s
       ccount++

    loop
```

  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>EERAM ( Device )</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_memory.html" title="Memory"><link rel="prev" href="_saferaseblock.html" title="SAFEraseBlock"><link rel="next" href="_47xxx_eeram_devices.html" title="47xxx EERam Devices"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_eeram_device"></a>EERAM ( Device )</h4></div></div></div><p>This is the EERAM section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="eeram_device"></span>EERAM ( Device )

</div>

</div>

</div>

This is the EERAM section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Ellipse</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_circle.html" title="Circle"><link rel="next" href="_filledbox.html" title="FilledBox"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_ellipse"></a>Ellipse</h4></div></div></div><p><span class="strong"><strong>Ellipse:</strong></span></p><pre class="screen">    Ellipse(XPixelPosition, YPixelPosition, XRadius, YRadius [,Optional LineColour] )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Draws a Ellipse on a GLCD at <code class="literal">XPixelPosition</code>, <code class="literal">YPixelPosition</code> with a specific vertex of <code class="literal">XRadius</code> and <code class="literal">YRadius</code>.</p><p>The constant <code class="literal">GLCD_PROTECTOVERRUN</code> can be added to prevent Ellipses from
re-drawing at the screen edges. Ensure the <code class="literal">GLCD_Width</code> and <code class="literal">GLCD_HEIGHT</code>
constants are set correctly when using this additional constant.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #include &lt;glcd.h&gt;

    Ellipse(63, 31, 20, 10)</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="ellipse"></span>Ellipse

</div>

</div>

</div>

<span class="strong">**Ellipse:**</span>

``` screen
    Ellipse(XPixelPosition, YPixelPosition, XRadius, YRadius [,Optional LineColour] )
```

<span class="strong">**Explanation:**</span>

Draws a Ellipse on a GLCD at `XPixelPosition`, `YPixelPosition` with a
specific vertex of `XRadius` and `YRadius`.

The constant `GLCD_PROTECTOVERRUN` can be added to prevent Ellipses from
re-drawing at the screen edges. Ensure the `GLCD_Width` and
`GLCD_HEIGHT` constants are set correctly when using this additional
constant.

<span class="strong">**Example:**</span>

``` screen
    #include <glcd.h>

    Ellipse(63, 31, 20, 10)
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>End</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_flow_control.html" title="Flow control"><link rel="prev" href="_do.html" title="Do"><link rel="next" href="_exit.html" title="Exit"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_end"></a>End</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    End</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>When the <code class="literal">End</code> command is used, the program will immediately stop running.
There are very few cases where this command is needed - generally, the
program should be an endless loop.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will turn on the red light, but not the green light
    Set RED On
    End
    Set GREEN On</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="end"></span>End

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    End
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

When the `End` command is used, the program will immediately stop
running. There are very few cases where this command is needed -
generally, the program should be an endless loop.

<span class="strong">**Example:**</span>

``` screen
    'This program will turn on the red light, but not the green light
    Set RED On
    End
    Set GREEN On
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>EPRead</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_mcu_eeprom_dfm.html" title="MCU EEPROM ( DFM )"><link rel="prev" href="_mcu_eeprom_dfm.html" title="MCU EEPROM ( DFM )"><link rel="next" href="_epwrite.html" title="EPWrite"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_epread"></a>EPRead</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    EPRead <span class="emphasis"><em>location, store</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip PIC and Atmel AVR microcontrollers with EEPROM data memory.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">EPRead</code> is used to read information from the EEPROM data storage that many microcontroller chips are equipped with.
<code class="literal"><span class="emphasis"><em>location</em></span></code> represents the location to read data from, and varies from one chip to another.
<code class="literal"><span class="emphasis"><em>store</em></span></code> is the variable in which to store the data after it has been read from EEPROM.</p><p>Note
Do not exceed the location ( also known as the EEProm address ) of the physical EEProm.  If the EEProm size is 256 ensure location is in the range of 0 to 255;  If the EEProm size is 512 ensure location is in the range of 0 to 511 and use a Word variable as the location parameter.
Example:</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Program to turn a light on and off
    'Will remember the last status

    #chip tiny2313, 1
    #define Button PORTB.0
    #define Light PORTB.1

    Dir Button In
    Dir Light Out

    'Load saved status
    EPRead 0, LightStatus

    If LightStatus = 0 Then
      Set Light Off
    Else
      Set Light On
    End If

    Do
      'Wait for the button to be pressed
      Wait While Button = On
      Wait While Button = Off
      'Toggle value, record
      LightStatus = !LightStatus
      EPWrite 0, LightStatus

      'Update light
      If LightStatus = 0 Then
        Set Light Off
      Else
        Set Light On
      End If
    Loop</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_epwrite.html" title="EPWrite">EPWrite</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="epread"></span>EPRead

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    EPRead location, store
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip PIC and Atmel AVR microcontrollers with
EEPROM data memory.

<span class="strong">**Explanation:**</span>

`EPRead` is used to read information from the EEPROM data storage that
many microcontroller chips are equipped with. `location` represents the
location to read data from, and varies from one chip to another. `store`
is the variable in which to store the data after it has been read from
EEPROM.

Note Do not exceed the location ( also known as the EEProm address ) of
the physical EEProm. If the EEProm size is 256 ensure location is in the
range of 0 to 255; If the EEProm size is 512 ensure location is in the
range of 0 to 511 and use a Word variable as the location parameter.
Example:

<span class="strong">**Example:**</span>

``` screen
    'Program to turn a light on and off
    'Will remember the last status

    #chip tiny2313, 1
    #define Button PORTB.0
    #define Light PORTB.1

    Dir Button In
    Dir Light Out

    'Load saved status
    EPRead 0, LightStatus

    If LightStatus = 0 Then
      Set Light Off
    Else
      Set Light On
    End If

    Do
      'Wait for the button to be pressed
      Wait While Button = On
      Wait While Button = Off
      'Toggle value, record
      LightStatus = !LightStatus
      EPWrite 0, LightStatus

      'Update light
      If LightStatus = 0 Then
        Set Light Off
      Else
        Set Light On
      End If
    Loop
```

<span class="strong">**For more help, see
<a href="epwrite" class="link" title="EPWrite">EPWrite</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>EPWrite</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_mcu_eeprom_dfm.html" title="MCU EEPROM ( DFM )"><link rel="prev" href="_epread.html" title="EPRead"><link rel="next" href="_dataset_for_eeprom.html" title="Dataset for EEPROM"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_epwrite"></a>EPWrite</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    EPWrite <span class="emphasis"><em>location</em></span>, <span class="emphasis"><em>data</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip PIC and Atmel AVR microcontrollers with EEPROM data memory.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">EPWrite</code> is used to write information to the EEPROM data storage, so that
it can be accessed later by a programmer on the PC, or by the <code class="literal">EPRead</code>
command. <code class="literal"><span class="emphasis"><em>location</em></span></code> represents the location to write data to, and the location varies
from one chip to another. <code class="literal"><span class="emphasis"><em>data</em></span></code> is the data that is to be written to the
EEPROM, and can be a value or a variable.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Do not exceed the location ( also known as the EEProm address ) of the physical EEProm.&nbsp;&nbsp;If the EEProm size is 256 ensure location is in the range of 0 to 255;&nbsp;&nbsp;If the EEProm size is 512 ensure location is in the range of 0 to 511 and use a Word variable as the location parameter.</p></div><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #chip 16F819, 8

    'Set the input pin direction
    Dir PORTA.0 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

    'Take a reading and log it
    EPWrite CurrentAddress, ReadAD(AN0)

    'Wait 10 minutes before getting another reading
    Wait 10 min

    Next</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_epread.html" title="EPRead">EPRead</a>,<a class="link" href="_lookup_tables.html" title="Lookup Tables">Creating EEProm data from a Lookup Table</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="epwrite"></span>EPWrite

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    EPWrite location, data
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip PIC and Atmel AVR microcontrollers with
EEPROM data memory.

<span class="strong">**Explanation:**</span>

`EPWrite` is used to write information to the EEPROM data storage, so
that it can be accessed later by a programmer on the PC, or by the
`EPRead` command. `location` represents the location to write data to,
and the location varies from one chip to another. `data` is the data
that is to be written to the EEPROM, and can be a value or a variable.

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

### Note

Do not exceed the location ( also known as the EEProm address ) of the
physical EEProm.  If the EEProm size is 256 ensure location is in the
range of 0 to 255;  If the EEProm size is 512 ensure location is in the
range of 0 to 511 and use a Word variable as the location parameter.

</div>

<span class="strong">**Example:**</span>

``` screen
    #chip 16F819, 8

    'Set the input pin direction
    Dir PORTA.0 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

    'Take a reading and log it
    EPWrite CurrentAddress, ReadAD(AN0)

    'Wait 10 minutes before getting another reading
    Wait 10 min

    Next
```

<span class="strong">**For more help, see
<a href="epread" class="link" title="EPRead">EPRead</a>,<a href="lookup_tables" class="link" title="Lookup Tables">Creating EEProm data from a Lookup Table</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Examples</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_put.html" title="Put"><link rel="next" href="_lcd_io_2_example.html" title="LCD_IO 2 Example"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_examples"></a>Examples</h4></div></div></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="examples"></span>Examples

</div>

</div>

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Example Macros</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_macros.html" title="Macros"><link rel="prev" href="_macros_overview.html" title="Macros Overview"><link rel="next" href="_measuring_a_pulse_width.html" title="Measuring a Pulse Width"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_example_macros"></a>Example Macros</h3></div></div></div><p>This is the Example Macros section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="example_macros"></span>Example Macros

</div>

</div>

</div>

This is the Example Macros section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Example Programs</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_implementing_a_method_with_a_pin_name_as_a_parameter.html" title="Implementing a method with a Pin name as a parameter"><link rel="next" href="_flashing_leds_and_an_interrupt.html" title="Flashing LEDs and an Interrupt"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_example_programs"></a>Example Programs</h2></div></div></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="example_programs"></span>Example Programs
----------------------------------------------------

</div>

</div>

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Exit</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_flow_control.html" title="Flow control"><link rel="prev" href="_end.html" title="End"><link rel="next" href="_for.html" title="For"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_exit"></a>Exit</h4></div></div></div><p><span class="strong"><strong>Syntax options:</strong></span></p><pre class="screen">    Exit Sub | Exit Function | Exit Do | Exit For | Exit Repeat</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will make the program exit the routine it is currently in,
as it would if it came to the end of the routine.</p><p>Applies to Subroutines, Functions, For-Next loops, Do-Loop loops and
Repeat loops.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #chip tiny13, 1

    #define SENSOR PORTB.0
    #define BUZZER PORTB.1
    #define LIGHT PORTB.2
    Dir SENSOR In
    Dir BUZZER Out
    Dir LIGHT Out

    Do
      Burglar
    Loop

    'Burglar Alarm subroutine
    Sub Burglar
      If SENSOR = 0 Then
        Set BUZZER Off
        Set LIGHT Off
        Exit Sub
      End If
      Set BUZZER On
      Set LIGHT On
    End Sub</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_do.html" title="Do">Do</a>, <a class="link" href="_for.html" title="For">For</a>, <a class="link" href="_subroutines.html" title="Subroutines">Sub</a>,
<a class="link" href="_functions.html" title="Functions">Functions</a></strong></span> and <span class="strong"><strong><a class="link" href="_repeat.html" title="Repeat">Repeat</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="exit"></span>Exit

</div>

</div>

</div>

<span class="strong">**Syntax options:**</span>

``` screen
    Exit Sub | Exit Function | Exit Do | Exit For | Exit Repeat
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This command will make the program exit the routine it is currently in,
as it would if it came to the end of the routine.

Applies to Subroutines, Functions, For-Next loops, Do-Loop loops and
Repeat loops.

<span class="strong">**Example:**</span>

``` screen
    #chip tiny13, 1

    #define SENSOR PORTB.0
    #define BUZZER PORTB.1
    #define LIGHT PORTB.2
    Dir SENSOR In
    Dir BUZZER Out
    Dir LIGHT Out

    Do
      Burglar
    Loop

    'Burglar Alarm subroutine
    Sub Burglar
      If SENSOR = 0 Then
        Set BUZZER Off
        Set LIGHT Off
        Exit Sub
      End If
      Set BUZZER On
      Set LIGHT On
    End Sub
```

<span class="strong">**For more help, see
<a href="do" class="link" title="Do">Do</a>,
<a href="for" class="link" title="For">For</a>,
<a href="subroutines" class="link" title="Subroutines">Sub</a>,
<a href="functions" class="link" title="Functions">Functions</a>**</span>
and <span
class="strong">**<a href="repeat" class="link" title="Repeat">Repeat</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>e-Paper Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_fonts_and_characters.html" title="Fonts and Characters"><link rel="next" href="_hx8347g_controllers.html" title="HX8347G Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_e_paper_controllers"></a>e-Paper Controllers</h5></div></div></div><p>This section covers GLCD devices known as e-Papers.</p><p>An e-paper device is a Microencapsulated Electrophoretic Display, MED.</p><p>A MED display uses tiny spheres, in which the charged color pigments are suspending in the transparent oil and would move depending on the electronic charge.&nbsp;&nbsp;
The e-paper screen display patterns by reflecting the ambient light, so it has no background light requirement.&nbsp;&nbsp;
Under sunshine, the e-paper screen still has high visibility with a wide viewing angle of 180 degree.&nbsp;&nbsp;
It is the ideal choice for e-reading or providing information that can be refeshed at a slow rate of change.&nbsp;&nbsp;</p><p><span class="strong"><strong>GLCD Support for e-Papers</strong></span></p><p>GCBASIC supports covers the full range of GLCD capabilities like line, circle, print.</p><p>GCBASIC supports SPI communications for the e-Papers - both hardware and software.  And, GCBASIC suppors low memory configurations and SRAM for the display buffer.</p><p>See the demonstration programs to show you how to use these GCLD capabilities.</p><p><span class="strong"><strong>Memory Usage</strong></span></p><p>The GCBASIC library uses RAM to buffer the e-paper display.&nbsp;&nbsp;
The amount of RAM used is specific the the total pixel of the specific e-paper display.&nbsp;&nbsp;
You can control to amount of RAM used as the buffer using the device specific constants, see below.&nbsp;&nbsp;
Each device specific library has four memory options.&nbsp;&nbsp;
Each of the memory options uses different amount RAM.&nbsp;&nbsp;
The greater the amount of RAM used the faster the process of updating the e-paper display.&nbsp;&nbsp;
Conversely, the smaller the amount of RAM used the slower the process of updating the e-paper display.&nbsp;&nbsp;</p><p><span class="strong"><strong>GLCD Page Transactions</strong></span></p><p>To make the operation of the library seamless - the library supports GLCDTransaction.&nbsp;&nbsp;
GLCDTransaction automatically manages the methods to update the e-paper via the buffer, where the buffer can be small.&nbsp;&nbsp;
The process of transaction send GLCD commands to the e-paper display on a page and page basis.&nbsp;&nbsp;
Each page is the size of the buffer and for a large e-paper display the number of pages may be equivilent to the numbers of pixels high (height).</p><p>GLCDTransaction simplies the operation by ensure the buffer is setup correctly, handles the GLCD appropiately, handles the sending of the buffer and then close out the process to update to the display.</p><p>To use GLCDTransaction use the followng two methods.</p><pre class="screen">        GLCD_Open_PageTransaction
            ....
            glcd commands
            .....

        GLCD_Close_PageTransaction</pre><p>It recommended to use GLCDTransactions at all times.&nbsp;&nbsp;These methods remove the complexity of the e-paper update process.</p><p>When using GLCDTransaction you must start the transaction with`GLCD_Open_PageTransaction` then include a series of GLCD commands and then terminate the transaction with <code class="literal">GLCD_Close_PageTransaction</code>.</p><p><span class="strong"><strong>GLCDTransaction Insight</strong></span>: When using GLCDtransactions the number of buffer pages is probably be greater then 1 (unless using the SRAM option), so the process of incrementing variables and calls to non-GLCD methods must be considered carefully. &nbsp;&nbsp; The transaction process <span class="strong"><strong>will</strong></span> increment variables and call non-GLCD methods the same number of times as the number of pages.&nbsp;&nbsp;Therefore, design GLCDTransaction operations with this is mind.</p><p><span class="strong"><strong>SRAM as the e-paper buffer</strong></span></p><p>To improve memory usage the e-paper the e-Paper libraries support the use of SRAM.&nbsp;&nbsp;
SRAM can be used as an alternative to the microcontrollers RAM.&nbsp;&nbsp;
Using SRAM does have a small performance impact but does free up the critical resource of the microcontroller RAM.&nbsp;&nbsp;
The use of SRAM within the e-paper library is transparent to the user.&nbsp;&nbsp;
To use SRAM as the e-paper buffer you will need to set-up the SRAM library.&nbsp;&nbsp;
See the SRAM library for more details on SRAM usage. &nbsp;&nbsp;</p><p>When using SRAM for the e-paper buffer it is still remcommend to use GLCDTransaction as this ensure the SRAM buffer is correctly initialised.</p><p><span class="strong"><strong>Refresh mode</strong></span></p><p>This library uses Full refresh:&nbsp;&nbsp;The e-Paper will flicker when full refreshing.&nbsp;&nbsp;
This flicker removes the ghost image from the display.&nbsp;&nbsp;
You could use Partial refresh as this doesnot flicker.&nbsp;&nbsp;
Note that you cannot use Partial refresh all the time, you should full refresh e-paper regularly, otherwise, the ghost problem will get worse and even damage the display.&nbsp;&nbsp;</p><p><span class="strong"><strong>Refresh rate</strong></span></p><p>When using the e-Paper library, you should set the update interval at least 180seconds, except when using Partial mode.&nbsp;&nbsp;</p><p>Please set the e-Paper to sleep mode in software or remove the power directly, otherwise, the e-Paper will be damaged because of working in high voltage for extendedtime periods.&nbsp;&nbsp;
You need to update the content of the e-Paper at least once every 24 hours to avoid from burn-in problem.&nbsp;&nbsp;</p><p><span class="strong"><strong>Operating Voltages</strong></span></p><p>The e-Paper should be driven with 3V3 operating voltages and signals.&nbsp;&nbsp;</p><p>If your Microcontroller (PIC, AVR and therefore an Arduino)cannot drive the e-Paper successfully.&nbsp;&nbsp;
You must convert the level to 3.3V. &nbsp;&nbsp;
The I/O level of Arduino is 5V.&nbsp;&nbsp; HEALTH WARNING:You can also try to connect the Vcc pin to the 5V of Arduino to see whether the e-Paper works, but we recommend you not to use 5V for a long time.&nbsp;&nbsp;</p><p><span class="strong"><strong>The e-Paper looks a little black or grey</strong></span></p><p>You can try to change the value of Vcom the library by setting the VCOM_AND_DATA_INTERVAL constant.&nbsp;&nbsp;
See the Vcom and data interval in the dataheet.&nbsp;&nbsp;VCOM_AND_DATA_INTERVAL can be 0x00 to 0x0F</p><p><span class="strong"><strong>GCBASIC library supports Black/White NOT Black/White/Red</strong></span></p><p>The default is Black/White. To support Black/White/Red add `#define PANEL_SETTING_KWR 0x00`to you user program.&nbsp;</p><p>The constant are the TFT_BLACK and TFT_WHITE constants.</p><p><span class="strong"><strong>The e-paper has ghosting problem after working for some days</strong></span></p><p>Please set the e-paper to sleep mode or disconnect it if you do not refresh the e-paper but need to power on your solution.&nbsp;&nbsp;</p><p>Do NOT leave power on for extended periods, otherwise, the voltage of panel remains high and it will damage the e-paper display.&nbsp;&nbsp;</p><p><span class="strong"><strong>e-Paper Guidelines</strong></span></p><p>Remove power if practical.</p><p>ALWAYS use <code class="literal">GLCDDisplay Off</code> or sleep mode.</p><p>When in storage CLEAR the screen&#8230;&#8203;. avoid burn it - use</p><pre class="screen">    GLCDCLD TFT_WHITE
    GLCDDisplay Off</pre><p>The recommended method is:</p><pre class="screen">    GLCDCLS TFT_WHITE
    GLCDDisplay Off
    do
    loop</pre><p><span class="strong"><strong>Using the e-Paper Library</strong></span></p><p>To use the e-Paper driver for a specific simply include the following in your user code.&nbsp;&nbsp;</p><p>This will initialise the driver.&nbsp;&nbsp;</p><pre class="screen">    'Setup for the e-Paper
     #include &lt;glcd.h&gt;

     #define GLCD_TYPE GLCD_TYPE_EPD_EPD7in5
     #define GLCD_EXTENDEDFONTSET1
     #define GLCD_OLED_FONT
     #define GLCD_TYPE_EPD7in5_LOWMEMORY4_GLCD_MODE fastest but uses a lot of RAM
     '#define GLCD_TYPE_EPD7in5_LOWMEMORY3_GLCD_MODE
     '#define GLCD_TYPE_EPD7in5_LOWMEMORY2_GLCD_MODE
     '#define GLCD_TYPE_EPD7in5_LOWMEMORY1_GLCD_MODEslowest uses the least amount of RAM


    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC portA.0 ' Data(hight)/ command(low) line
    #define GLCD_CS portC.1 ' Chip select line (negate)
    #define GLCD_RESETportD.2 ' Reset line (negate)
    #define GLCD_DO portC.5 ' GLCD MOSI connect to MCU SDO
    #define GLCD_SCKportC.3 ' Clock Line
    #define GLCD_Busy portC.0 ' Busy Line

    'The following should be used for hardware SPI remove or comment out if you want to use software SPI.
    #define EPD_HardwareSPI</pre><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_EPD_EPD7in5</code></p></td><td align="left" valign="top"><p>GLCD_TYPE_EPD_EPD7in5 and GLCD_TYPE_EPD_EPD2in13D supported</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_&lt;device_memory_mode&gt;</code></p></td><td align="left" valign="top"><p>Memory usage for the display buffer.&nbsp;&nbsp;
</p><p>Memory management is crutial when using the e-paper displays.</p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_EPD7in5_LOWMEMORY4_GLCD_MODE</code> &#8230;&#8203;  <code class="literal">GLCD_TYPE_EPD7in5_LOWMEMORY1_GLCD_MODE</code>,
</p><p>or,
</p><p><code class="literal">GLCD_TYPE_EPD2in13D_LOWMEMORY4_GLCD_MODE</code> &#8230;&#8203;  <code class="literal">GLCD_TYPE_EPD2in13D_LOWMEMORY1_GLCD_MODE</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DC</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command IO pin on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS) on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Reset</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DO</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on
the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_SCK</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Clock (CLK) pin on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_BUSY</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Busy pin on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">EPD_HardwareSPI</code></p></td><td align="left" valign="top"><p>Instructs the library to use hardware SPI, remove or comment out if you want to use software SPI.</p></td><td align="left" valign="top"><p><code class="literal">#define EPD_HardwareSPI</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HWSPIMode</code></p></td><td align="left" valign="top"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td><td align="left" valign="top"><p>Optional defaults to MASTERFAST.
</p><p>Options are MASTERSLOW,<br>
MASTER,<br>
MASTERFAST, or<br>
MASTERULTRAFAST for specific AVRs only.</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="center" valign="top"><p>Specific to the e-Paper selected<br>
This cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="center" valign="top"><p>Specific to the e-Paper selected<br>
This cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="center" valign="top"><p><code class="literal">6</code> or <code class="literal">5</code> for the OLED font set.</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDisplay</code></p></td><td align="left" valign="top"><p>Enables sleep mode, or, enables operations</p></td><td align="left" valign="top"><p><code class="literal">GLCDDisplay Off</code>, or, <code class="literal">GLCDDisplay On</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Open_PageTransaction</code></p></td><td align="left" valign="top"><p>Commence a series of GLCD commands with memory buffer management.  Must be followed a  <code class="literal">GLCD_Close_PageTransaction</code> command.</p></td><td align="left" valign="top"><p><code class="literal">GLCD_Open_PageTransaction</code>. Parameters may be passed where the two parameters are the range of pages to be updated</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Close_PageTransaction</code></p></td><td align="left" valign="top"><p>Terminate a series of GLCD commands.  Must follow a <code class="literal">GLCD_Open_PageTransaction</code> command.</p></td><td align="left" valign="top"><p><code class="literal">GLCD_Close_PageTransaction</code>. Terminates the GLCDTransaction.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example Usage:</strong></span></p><pre class="screen">#chip mega328p, 16
#include &lt;uno_mega328p.h&gt;
#option explicit

 '******************************************************************************************************

'Setup the E-Paper
 #include &lt;glcd.h&gt;

 #define HWSPIMode ULTRAFAST

 #define GLCD_TYPE GLCD_TYPE_EPD_EPD2in13D
 #define GLCD_EXTENDEDFONTSET1
 #define GLCD_TYPE_EPD2in13D_LOWMEMORY4_GLCD_MODE
 #define GLCD_OLED_FONT
 #define GLCD_PROTECTOVERRUN



 'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
 #define GLCD_DC DIGITAL_9
 #define GLCD_CS DIGITAL_10
 #define GLCD_RESETDIGITAL_8
 #define GLCD_DO DIGITAL_11
 #define GLCD_SCKDIGITAL_13
 #define GLCD_Busy DIGITAL_7

 #define EPD_HARDWARESPI

 '***********************************************************************************************


'Main program

GLCDForeground=TFT_BLACK
GLCDBackground=TFT_WHITE


 GLCD_Open_PageTransaction
    GLCDPrintStringLN ("GCBASIC")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("Test of the e-Paper")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("December 2021")
 GLCD_Close_PageTransaction
 GLCDDisplay Off

 wait 2 s
 GLCDDisplay On
 GLCDCLS
 GLCDDisplay off

 do

 loop</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a>, <a class="link" href="_pset.html" title="Pset">Pset</a> or <a class="link" href="_glcdtransaction.html" title="GLCDTransaction">GLCDTransaction</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="e_paper_controllers"></span>e-Paper Controllers

</div>

</div>

</div>

This section covers GLCD devices known as e-Papers.

An e-paper device is a Microencapsulated Electrophoretic Display, MED.

A MED display uses tiny spheres, in which the charged color pigments are
suspending in the transparent oil and would move depending on the
electronic charge.   The e-paper screen display patterns by reflecting
the ambient light, so it has no background light requirement.   Under
sunshine, the e-paper screen still has high visibility with a wide
viewing angle of 180 degree.   It is the ideal choice for e-reading or
providing information that can be refeshed at a slow rate of change.  

<span class="strong">**GLCD Support for e-Papers**</span>

GCBASIC supports covers the full range of GLCD capabilities like line,
circle, print.

GCBASIC supports SPI communications for the e-Papers - both hardware and
software. And, GCBASIC suppors low memory configurations and SRAM for
the display buffer.

See the demonstration programs to show you how to use these GCLD
capabilities.

<span class="strong">**Memory Usage**</span>

The GCBASIC library uses RAM to buffer the e-paper display.   The amount
of RAM used is specific the the total pixel of the specific e-paper
display.   You can control to amount of RAM used as the buffer using the
device specific constants, see below.   Each device specific library has
four memory options.   Each of the memory options uses different amount
RAM.   The greater the amount of RAM used the faster the process of
updating the e-paper display.   Conversely, the smaller the amount of
RAM used the slower the process of updating the e-paper display.  

<span class="strong">**GLCD Page Transactions**</span>

To make the operation of the library seamless - the library supports
GLCDTransaction.   GLCDTransaction automatically manages the methods to
update the e-paper via the buffer, where the buffer can be small.   The
process of transaction send GLCD commands to the e-paper display on a
page and page basis.   Each page is the size of the buffer and for a
large e-paper display the number of pages may be equivilent to the
numbers of pixels high (height).

GLCDTransaction simplies the operation by ensure the buffer is setup
correctly, handles the GLCD appropiately, handles the sending of the
buffer and then close out the process to update to the display.

To use GLCDTransaction use the followng two methods.

``` screen
        GLCD_Open_PageTransaction
            ....
            glcd commands
            .....

        GLCD_Close_PageTransaction
```

It recommended to use GLCDTransactions at all times.  These methods
remove the complexity of the e-paper update process.

When using GLCDTransaction you must start the transaction
with\`GLCD\_Open\_PageTransaction\` then include a series of GLCD
commands and then terminate the transaction with
`GLCD_Close_PageTransaction`.

<span class="strong">**GLCDTransaction Insight**</span>: When using
GLCDtransactions the number of buffer pages is probably be greater then
1 (unless using the SRAM option), so the process of incrementing
variables and calls to non-GLCD methods must be considered carefully.   
The transaction process <span class="strong">**will**</span> increment
variables and call non-GLCD methods the same number of times as the
number of pages.  Therefore, design GLCDTransaction operations with this
is mind.

<span class="strong">**SRAM as the e-paper buffer**</span>

To improve memory usage the e-paper the e-Paper libraries support the
use of SRAM.   SRAM can be used as an alternative to the
microcontrollers RAM.   Using SRAM does have a small performance impact
but does free up the critical resource of the microcontroller RAM.   The
use of SRAM within the e-paper library is transparent to the user.   To
use SRAM as the e-paper buffer you will need to set-up the SRAM
library.   See the SRAM library for more details on SRAM usage.   

When using SRAM for the e-paper buffer it is still remcommend to use
GLCDTransaction as this ensure the SRAM buffer is correctly initialised.

<span class="strong">**Refresh mode**</span>

This library uses Full refresh:  The e-Paper will flicker when full
refreshing.   This flicker removes the ghost image from the display.  
You could use Partial refresh as this doesnot flicker.   Note that you
cannot use Partial refresh all the time, you should full refresh e-paper
regularly, otherwise, the ghost problem will get worse and even damage
the display.  

<span class="strong">**Refresh rate**</span>

When using the e-Paper library, you should set the update interval at
least 180seconds, except when using Partial mode.  

Please set the e-Paper to sleep mode in software or remove the power
directly, otherwise, the e-Paper will be damaged because of working in
high voltage for extendedtime periods.   You need to update the content
of the e-Paper at least once every 24 hours to avoid from burn-in
problem.  

<span class="strong">**Operating Voltages**</span>

The e-Paper should be driven with 3V3 operating voltages and signals.  

If your Microcontroller (PIC, AVR and therefore an Arduino)cannot drive
the e-Paper successfully.   You must convert the level to 3.3V.    The
I/O level of Arduino is 5V.   HEALTH WARNING:You can also try to connect
the Vcc pin to the 5V of Arduino to see whether the e-Paper works, but
we recommend you not to use 5V for a long time.  

<span class="strong">**The e-Paper looks a little black or grey**</span>

You can try to change the value of Vcom the library by setting the
VCOM\_AND\_DATA\_INTERVAL constant.   See the Vcom and data interval in
the dataheet.  VCOM\_AND\_DATA\_INTERVAL can be 0x00 to 0x0F

<span class="strong">**GCBASIC library supports Black/White NOT
Black/White/Red**</span>

The default is Black/White. To support Black/White/Red add \`\#define
PANEL\_SETTING\_KWR 0x00\`to you user program. 

The constant are the TFT\_BLACK and TFT\_WHITE constants.

<span class="strong">**The e-paper has ghosting problem after working
for some days**</span>

Please set the e-paper to sleep mode or disconnect it if you do not
refresh the e-paper but need to power on your solution.  

Do NOT leave power on for extended periods, otherwise, the voltage of
panel remains high and it will damage the e-paper display.  

<span class="strong">**e-Paper Guidelines**</span>

Remove power if practical.

ALWAYS use `GLCDDisplay Off` or sleep mode.

When in storage CLEAR the screen…​. avoid burn it - use

``` screen
    GLCDCLD TFT_WHITE
    GLCDDisplay Off
```

The recommended method is:

``` screen
    GLCDCLS TFT_WHITE
    GLCDDisplay Off
    do
    loop
```

<span class="strong">**Using the e-Paper Library**</span>

To use the e-Paper driver for a specific simply include the following in
your user code.  

This will initialise the driver.  

``` screen
    'Setup for the e-Paper
     #include <glcd.h>

     #define GLCD_TYPE GLCD_TYPE_EPD_EPD7in5
     #define GLCD_EXTENDEDFONTSET1
     #define GLCD_OLED_FONT
     #define GLCD_TYPE_EPD7in5_LOWMEMORY4_GLCD_MODE fastest but uses a lot of RAM
     '#define GLCD_TYPE_EPD7in5_LOWMEMORY3_GLCD_MODE
     '#define GLCD_TYPE_EPD7in5_LOWMEMORY2_GLCD_MODE
     '#define GLCD_TYPE_EPD7in5_LOWMEMORY1_GLCD_MODEslowest uses the least amount of RAM


    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC portA.0 ' Data(hight)/ command(low) line
    #define GLCD_CS portC.1 ' Chip select line (negate)
    #define GLCD_RESETportD.2 ' Reset line (negate)
    #define GLCD_DO portC.5 ' GLCD MOSI connect to MCU SDO
    #define GLCD_SCKportC.3 ' Clock Line
    #define GLCD_Busy portC.0 ' Busy Line

    'The following should be used for hardware SPI remove or comment out if you want to use software SPI.
    #define EPD_HardwareSPI
```

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Options</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE</code></p></td>
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_EPD_EPD7in5</code></p></td>
<td style="text-align: left;"><p>GLCD_TYPE_EPD_EPD7in5 and GLCD_TYPE_EPD_EPD2in13D supported</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_&lt;device_memory_mode&gt;</code></p></td>
<td style="text-align: left;"><p>Memory usage for the display buffer.  </p>
<p>Memory management is crutial when using the e-paper displays.</p></td>
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_EPD7in5_LOWMEMORY4_GLCD_MODE</code> …​ <code class="literal">GLCD_TYPE_EPD7in5_LOWMEMORY1_GLCD_MODE</code>,</p>
<p>or,</p>
<p><code class="literal">GLCD_TYPE_EPD2in13D_LOWMEMORY4_GLCD_MODE</code> …​ <code class="literal">GLCD_TYPE_EPD2in13D_LOWMEMORY1_GLCD_MODE</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_DC</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_CS</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Chip Select (CS) on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_Reset</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DO</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_SCK</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_BUSY</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Busy pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">EPD_HardwareSPI</code></p></td>
<td style="text-align: left;"><p>Instructs the library to use hardware SPI, remove or comment out if you want to use software SPI.</p></td>
<td style="text-align: left;"><p><code class="literal">#define EPD_HardwareSPI</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HWSPIMode</code></p></td>
<td style="text-align: left;"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td>
<td style="text-align: left;"><p>Optional defaults to MASTERFAST.</p>
<p>Options are MASTERSLOW,<br />
MASTER,<br />
MASTERFAST, or<br />
MASTERULTRAFAST for specific AVRs only.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: center;"><p>Specific to the e-Paper selected<br />
This cannot be changed</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: center;"><p>Specific to the e-Paper selected<br />
This cannot be changed</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Specifies the font width of the GCBASIC font set.</p></td>
<td style="text-align: center;"><p><code class="literal">6</code> or <code class="literal">5</code> for the OLED font set.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**Purpose**</span>                                                                                    | <span class="strong">**Example**</span>                                                                             |
|:----------------------------------------|:---------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------|
| `GLCDCLS`                               | Clear screen of GLCD                                                                                                       | `GLCDCLS`                                                                                                           |
| `GLCDDisplay`                           | Enables sleep mode, or, enables operations                                                                                 | `GLCDDisplay Off`, or, `GLCDDisplay On`                                                                             |
| `GLCDPrint`                             | Print string of characters on GLCD using GCB font set                                                                      | `GLCDPrint( Xposition, Yposition, Stringvariable )`                                                                 |
| `GLCDDrawChar`                          | Print character on GLCD using GCB font set                                                                                 | `GLCDDrawChar( Xposition, Yposition, CharCode )`                                                                    |
| `GLCDDrawString`                        | Print characters on GLCD using GCB font set                                                                                | `GLCDDrawString( Xposition, Yposition, Stringvariable )`                                                            |
| `Box`                                   | Draw a box on the GLCD to a specific size                                                                                  | `Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )`                        |
| `FilledBox`                             | Draw a box on the GLCD to a specific size that is filled with the foreground colour.                                       | `FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`                      |
| `Line`                                  | Draw a line on the GLCD to a specific length that is filled with the specific attribute.                                   | `Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`                          |
| `PSet`                                  | Set a pixel on the GLCD at a specific position that is set with the specific attribute.                                    | `PSet(Xposition, Yposition, Pixel Colour 0 or 1)`                                                                   |
| `GLCD_Open_PageTransaction`             | Commence a series of GLCD commands with memory buffer management. Must be followed a `GLCD_Close_PageTransaction` command. | `GLCD_Open_PageTransaction`. Parameters may be passed where the two parameters are the range of pages to be updated |
| `GLCD_Close_PageTransaction`            | Terminate a series of GLCD commands. Must follow a `GLCD_Open_PageTransaction` command.                                    | `GLCD_Close_PageTransaction`. Terminates the GLCDTransaction.                                                       |

</div>

<span class="strong">**Example Usage:**</span>

``` screen
#chip mega328p, 16
#include <uno_mega328p.h>
#option explicit

 '******************************************************************************************************

'Setup the E-Paper
 #include <glcd.h>

 #define HWSPIMode ULTRAFAST

 #define GLCD_TYPE GLCD_TYPE_EPD_EPD2in13D
 #define GLCD_EXTENDEDFONTSET1
 #define GLCD_TYPE_EPD2in13D_LOWMEMORY4_GLCD_MODE
 #define GLCD_OLED_FONT
 #define GLCD_PROTECTOVERRUN



 'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
 #define GLCD_DC DIGITAL_9
 #define GLCD_CS DIGITAL_10
 #define GLCD_RESETDIGITAL_8
 #define GLCD_DO DIGITAL_11
 #define GLCD_SCKDIGITAL_13
 #define GLCD_Busy DIGITAL_7

 #define EPD_HARDWARESPI

 '***********************************************************************************************


'Main program

GLCDForeground=TFT_BLACK
GLCDBackground=TFT_WHITE


 GLCD_Open_PageTransaction
    GLCDPrintStringLN ("GCBASIC")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("Test of the e-Paper")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("December 2021")
 GLCD_Close_PageTransaction
 GLCDDisplay Off

 wait 2 s
 GLCDDisplay On
 GLCDCLS
 GLCDDisplay off

 do

 loop
```

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>,
<a href="pset" class="link" title="Pset">Pset</a> or
<a href="glcdtransaction" class="link" title="GLCDTransaction">GLCDTransaction</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>FastHWSPITransfer</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_spi.html" title="SPI"><link rel="prev" href="_spitransfer.html" title="SPITransfer"><link rel="next" href="_i2c_software.html" title="I2C Software"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_fasthwspitransfer"></a>FastHWSPITransfer</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  <code class="literal">FastHWSPITransfer</code> <span class="emphasis"><em>tx</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on Microchip PIC microcontrollers with Hardware SPI modules.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command only sends a byte of data using the
SPI protocol. This command only supports master mode.</p><p>As a master, <code class="literal">FastHWSPITransfer</code> will initiate a transfer. The
data in <code class="literal"><span class="emphasis"><em>tx</em></span></code> will be sent to the slave.</p><p><span class="strong"><strong>Example:</strong></span></p><p>This is an example for this command.</p><p><span class="strong"><strong>Master Program:</strong></span></p><pre class="screen">  'General hardware configuration
  #chip 16F877A, 20

  'Set SPI pin directions
  dir PORTC.5 out
  dir PORTC.4 in
  dir PORTC.3 out

  'Set SPI Mode to master, with fast clock
  SPIMode MasterFast

  'Main Loop
  do

      'Send the value of 0x55
      FastHWSPITransfer 0x55

  loop</pre><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_spitransfer.html" title="SPITransfer">SPITransfer</a>,<a class="link" href="_spimode.html" title="SPIMode">SPIMode</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="fasthwspitransfer"></span>FastHWSPITransfer

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  FastHWSPITransfer tx
```

<span class="strong">**Command Availability:**</span>

Available on Microchip PIC microcontrollers with Hardware SPI modules.

<span class="strong">**Explanation:**</span>

This command only sends a byte of data using the SPI protocol. This
command only supports master mode.

As a master, `FastHWSPITransfer` will initiate a transfer. The data in
`tx` will be sent to the slave.

<span class="strong">**Example:**</span>

This is an example for this command.

<span class="strong">**Master Program:**</span>

``` screen
  'General hardware configuration
  #chip 16F877A, 20

  'Set SPI pin directions
  dir PORTC.5 out
  dir PORTC.4 in
  dir PORTC.3 out

  'Set SPI Mode to master, with fast clock
  SPIMode MasterFast

  'Main Loop
  do

      'Send the value of 0x55
      FastHWSPITransfer 0x55

  loop
```

<span class="strong">**See also**</span>
<a href="spitransfer" class="link" title="SPITransfer">SPITransfer</a>,<a href="spimode" class="link" title="SPIMode">SPIMode</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Fill</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_chr.html" title="Chr"><link rel="next" href="_hex.html" title="Hex"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_fill"></a>Fill</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>stringvar</em></span> =  Fill ( byte_value_of_the_new_length , pad_character )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The Fill function is used to create string to a specific length that is of a specific character.</p><p>The length of the string is specified by the first parameter.
The character used to pad the string is specified by the second parameter, this parameter is optional as the " "(space) character is assumed.</p><p>A typical use is to fill a string to be displayed on an LCD or serial terminal.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip 16F886


    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
   #define USART_TX_BLOCKING



    HserPrint Fill ( 16, "<span class="strong"><strong>" ) ;will print a string of '<span class="strong"><strong></strong></span></strong></span><span class="strong"><strong><span class="strong"><strong></strong></span><span class="strong"><strong></strong></span></strong></span>*'
    HSerPrintCRLF</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_asc.html" title="Asc">Asc</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="fill"></span>Fill

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    stringvar =  Fill ( byte_value_of_the_new_length , pad_character )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The Fill function is used to create string to a specific length that is
of a specific character.

The length of the string is specified by the first parameter. The
character used to pad the string is specified by the second parameter,
this parameter is optional as the " "(space) character is assumed.

A typical use is to fill a string to be displayed on an LCD or serial
terminal.

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip 16F886


    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
   #define USART_TX_BLOCKING



    HserPrint Fill ( 16, "" ) ;will print a string of '*'
    HSerPrintCRLF
```

<span class="strong">**For more help, see**</span>
<a href="asc" class="link" title="Asc">Asc</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>FilledBox</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_ellipse.html" title="Ellipse"><link rel="next" href="_filledcircle.html" title="FilledCircle"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_filledbox"></a>FilledBox</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    FilledBox(LineX1,LineY1, LineX2, LineY2, Optional LineColour = 1)</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Draws a filled box on a graphic LCD from the upper corner of pixel X1, Y1
location to pixel X2,Y2 location.<br></p><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_box.html" title="Box">Box</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="filledbox"></span>FilledBox

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    FilledBox(LineX1,LineY1, LineX2, LineY2, Optional LineColour = 1)
```

<span class="strong">**Explanation:**</span>

Draws a filled box on a graphic LCD from the upper corner of pixel X1,
Y1 location to pixel X2,Y2 location.  

<span class="strong">**See also**</span>
<a href="box" class="link" title="Box">Box</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>FilledCircle</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_filledbox.html" title="FilledBox"><link rel="next" href="_filledellipse.html" title="FilledEllipse"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_filledcircle"></a>FilledCircle</h4></div></div></div><p><span class="strong"><strong>Circle:</strong></span></p><pre class="screen">    FilledCircle(XPixelPosition, YPixelPosition, Radius [,Optional LineColour] )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Draws a circle on a GLCD at <code class="literal">XPixelPosition</code>, <code class="literal">YPixelPosition</code> with a specific <code class="literal">Radius</code>.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #include &lt;glcd.h&gt;

    filledcircle(10,10,10)  ;upper left
    filledcircle(117,10,10) ;upper right
    filledcircle(63,31,10)  ;center
    filledcircle(63,31,20)  ;center
    filledcircle(10,53,10)  ;lower left
    filledcircle(117,53,10) ;lower right</pre><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/filledcircleb1.PNG" align="middle" alt="graphic"></div></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="filledcircle"></span>FilledCircle

</div>

</div>

</div>

<span class="strong">**Circle:**</span>

``` screen
    FilledCircle(XPixelPosition, YPixelPosition, Radius [,Optional LineColour] )
```

<span class="strong">**Explanation:**</span>

Draws a circle on a GLCD at `XPixelPosition`, `YPixelPosition` with a
specific `Radius`.

<span class="strong">**Example:**</span>

``` screen
    #include <glcd.h>

    filledcircle(10,10,10)  ;upper left
    filledcircle(117,10,10) ;upper right
    filledcircle(63,31,10)  ;center
    filledcircle(63,31,20)  ;center
    filledcircle(10,53,10)  ;lower left
    filledcircle(117,53,10) ;lower right
```

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/filledcircleb1.PNG)

</div>

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>FilledEllipse</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_filledcircle.html" title="FilledCircle"><link rel="next" href="_filledtriangle.html" title="FilledTriangle"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_filledellipse"></a>FilledEllipse</h4></div></div></div><p><span class="strong"><strong>FilledEllipse:</strong></span></p><pre class="screen">    FilledEllipse(XPixelPosition, YPixelPosition, XRadius, YRadius [,Optional LineColour] )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Draws a FilledEllipse on a GLCD at <code class="literal">XPixelPosition</code>, <code class="literal">YPixelPosition</code> with a specific vertex of <code class="literal">XRadius</code> and <code class="literal">YRadius</code>.</p><p>The constant <code class="literal">GLCD_PROTECTOVERRUN</code> can be added to prevent FilledEllipses from
re-drawing at the screen edges. Ensure the <code class="literal">GLCD_Width</code> and <code class="literal">GLCD_HEIGHT</code>
constants are set correctly when using this additional constant.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #include &lt;glcd.h&gt;

    FilledEllipse(63, 31, 20, 10)</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="filledellipse"></span>FilledEllipse

</div>

</div>

</div>

<span class="strong">**FilledEllipse:**</span>

``` screen
    FilledEllipse(XPixelPosition, YPixelPosition, XRadius, YRadius [,Optional LineColour] )
```

<span class="strong">**Explanation:**</span>

Draws a FilledEllipse on a GLCD at `XPixelPosition`, `YPixelPosition`
with a specific vertex of `XRadius` and `YRadius`.

The constant `GLCD_PROTECTOVERRUN` can be added to prevent
FilledEllipses from re-drawing at the screen edges. Ensure the
`GLCD_Width` and `GLCD_HEIGHT` constants are set correctly when using
this additional constant.

<span class="strong">**Example:**</span>

``` screen
    #include <glcd.h>

    FilledEllipse(63, 31, 20, 10)
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>FilledTriangle</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_filledellipse.html" title="FilledEllipse"><link rel="next" href="_glcdcls.html" title="GLCDCLS"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_filledtriangle"></a>FilledTriangle</h4></div></div></div><p><span class="strong"><strong>FilledTriangle:</strong></span></p><pre class="screen">    FilledTriangle( XPixelPosition1, YPixelPosition1, XPixelPosition2, YPixelPosition2, XPixelPosition3, YPixelPosition3 [,Optional LineColour] )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Draws a FilledTriangle on a GLCD at <code class="literal">XPixelPositionN</code>, <code class="literal">YPixelPositionN</code>.</p><p>The constant <code class="literal">GLCD_PROTECTOVERRUN</code> can be added to prevent FilledTriangles from
re-drawing at the screen edges. Ensure the <code class="literal">GLCD_Width</code> and <code class="literal">GLCD_HEIGHT</code>
constants are set correctly when using this additional constant.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #include &lt;glcd.h&gt;

    FilledTriangle(0, 0, 31, 63, 127, 0 )</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="filledtriangle"></span>FilledTriangle

</div>

</div>

</div>

<span class="strong">**FilledTriangle:**</span>

``` screen
    FilledTriangle( XPixelPosition1, YPixelPosition1, XPixelPosition2, YPixelPosition2, XPixelPosition3, YPixelPosition3 [,Optional LineColour] )
```

<span class="strong">**Explanation:**</span>

Draws a FilledTriangle on a GLCD at `XPixelPositionN`,
`YPixelPositionN`.

The constant `GLCD_PROTECTOVERRUN` can be added to prevent
FilledTriangles from re-drawing at the screen edges. Ensure the
`GLCD_Width` and `GLCD_HEIGHT` constants are set correctly when using
this additional constant.

<span class="strong">**Example:**</span>

``` screen
    #include <glcd.h>

    FilledTriangle(0, 0, 31, 63, 127, 0 )
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Fixed Voltage Reference</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_wait.html" title="Wait"><link rel="next" href="_fvrinitialize.html" title="FVRInitialize"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_fixed_voltage_reference"></a>Fixed Voltage Reference</h3></div></div></div><p>This is the  Fixed Voltage Reference section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="fixed_voltage_reference"></span>Fixed Voltage Reference

</div>

</div>

</div>

This is the Fixed Voltage Reference section of the Help file. Please
refer the sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Flashing LEDs and an Interrupt</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_programs.html" title="Example Programs"><link rel="prev" href="_example_programs.html" title="Example Programs"><link rel="next" href="_flashing_led_with_timing_parameters.html" title="Flashing LED with timing parameters"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_flashing_leds_and_an_interrupt"></a>Flashing LEDs and an Interrupt</h3></div></div></div><p><span class="strong"><strong>Explanation:</strong></span></p><p>This code implements four flashing LEDs. This is based on the Microchip PIC Low Pin Count Demo Board.</p><p>The example program will blink the four red lights in succession. Press the Push Button Switch, labeled <span class="strong"><strong>SW1</strong></span>, and the sequence of the lights will reverse. Rotate the potentiometer, labeled <span class="strong"><strong>RP1</strong></span>, and the light sequence will blink at a different rate.</p><p>This implements an interrupt for the switch press, reads the analog port and set the LEDs.</p><p><span class="strong"><strong>Demonstration program:</strong></span></p><pre class="screen">    #chip 18F14K22, 32
    #config MCLRE_OFF

    'Works with the low count demo board

    'Set the input pin direction
        #define SwitchIn1 PORTa.3
        Dir SwitchIn1 In

    #define LedPort PORTc
        DIR PORTC OUT

    'Setup the ADC  pin direction
        Dir PORTA.0 In
        dim ADCreading as word


    'Setup the input pin direction
        #define IntPortA PORTA.1
        Dir IntPortA In

    'Variable and constants
        #define intstate as byte
        intstate = 0
        #define minwait 1

        dim ccount as byte
        dim leddir as byte

        ccount = 8
        leddir = 0

        SET PORTC = 15
        WAIT 1 S

        SET PORTC = 0

    'Setup the Interrupt
        Set IOCA.3 on
        Dir porta.3 in
        On Interrupt PORTABCHANGE Call Setir

    'Set initial LED direction
        setLedDirection

    DO FOREVER


        INTON
        ADCreading = ReadAD10(AN0)
        if ADCreading &lt; minwait then ADCreading = minwait

        'Set LEDs
        Set PortC = ccount
        wait ADCreading ms

        if leddir = 0 then
          rotate ccount left simple
          'Restart LED position
          if ccount = 16 then
              ccount = 128
          end if

        end if

        if leddir = 1 then
          rotate ccount Right simple
          'Restart LED position
          if ccount = 128 then
            ccount = 8
          end if

        end if
        'Reset interrupt - this may be been reset so set to zero so interrupt can operate.
        intstate = 0

    Loop


    'Interrupt routine.
    sub Setir

        if IntPortA  = 0 and intstate = 0 then
          intstate = 1
          wait while SwitchIn1 = 0
          setLedDirection
        end if


    end sub

    sub setLedDirection

      'Set LED values
      select case leddir

        case 0
          leddir = 1
          ccount  = 8

        case 1
          leddir = 0
          ccount = 1

        end select

    End Sub</pre><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_interrupts.html" title="Interrupts">Interrupts</a>, <a class="link" href="_readad10.html" title="ReadAD10">ReadAD10</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="flashing_leds_and_an_interrupt"></span>Flashing LEDs and an Interrupt

</div>

</div>

</div>

<span class="strong">**Explanation:**</span>

This code implements four flashing LEDs. This is based on the Microchip
PIC Low Pin Count Demo Board.

The example program will blink the four red lights in succession. Press
the Push Button Switch, labeled <span class="strong">**SW1**</span>, and
the sequence of the lights will reverse. Rotate the potentiometer,
labeled <span class="strong">**RP1**</span>, and the light sequence will
blink at a different rate.

This implements an interrupt for the switch press, reads the analog port
and set the LEDs.

<span class="strong">**Demonstration program:**</span>

``` screen
    #chip 18F14K22, 32
    #config MCLRE_OFF

    'Works with the low count demo board

    'Set the input pin direction
        #define SwitchIn1 PORTa.3
        Dir SwitchIn1 In

    #define LedPort PORTc
        DIR PORTC OUT

    'Setup the ADC  pin direction
        Dir PORTA.0 In
        dim ADCreading as word


    'Setup the input pin direction
        #define IntPortA PORTA.1
        Dir IntPortA In

    'Variable and constants
        #define intstate as byte
        intstate = 0
        #define minwait 1

        dim ccount as byte
        dim leddir as byte

        ccount = 8
        leddir = 0

        SET PORTC = 15
        WAIT 1 S

        SET PORTC = 0

    'Setup the Interrupt
        Set IOCA.3 on
        Dir porta.3 in
        On Interrupt PORTABCHANGE Call Setir

    'Set initial LED direction
        setLedDirection

    DO FOREVER


        INTON
        ADCreading = ReadAD10(AN0)
        if ADCreading < minwait then ADCreading = minwait

        'Set LEDs
        Set PortC = ccount
        wait ADCreading ms

        if leddir = 0 then
          rotate ccount left simple
          'Restart LED position
          if ccount = 16 then
              ccount = 128
          end if

        end if

        if leddir = 1 then
          rotate ccount Right simple
          'Restart LED position
          if ccount = 128 then
            ccount = 8
          end if

        end if
        'Reset interrupt - this may be been reset so set to zero so interrupt can operate.
        intstate = 0

    Loop


    'Interrupt routine.
    sub Setir

        if IntPortA  = 0 and intstate = 0 then
          intstate = 1
          wait while SwitchIn1 = 0
          setLedDirection
        end if


    end sub

    sub setLedDirection

      'Set LED values
      select case leddir

        case 0
          leddir = 1
          ccount  = 8

        case 1
          leddir = 0
          ccount = 1

        end select

    End Sub
```

<span class="strong">**See Also**</span>
<a href="interrupts" class="link" title="Interrupts">Interrupts</a>,
<a href="readad10" class="link" title="ReadAD10">ReadAD10</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Flashing LED with timing parameters</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_programs.html" title="Example Programs"><link rel="prev" href="_flashing_leds_and_an_interrupt.html" title="Flashing LEDs and an Interrupt"><link rel="next" href="_generate_accurate_pulses.html" title="Generate Accurate Pulses"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_flashing_led_with_timing_parameters"></a>Flashing LED with timing parameters</h3></div></div></div><p><span class="strong"><strong>Explanation:</strong></span></p><p>This is an example of how to define a subroutine.</p><p>When called, this subroutine will blink an LED for the number of times and duration as determined by the input parameters.</p><p>The syntax of the subroutine is:</p><pre class="screen">    ' Flash_LED (numtimes, OnTime, (optional) OffTime)
    ' Where numtimes is from 1 - 255 and OnTime/OffTime is
    ' from 0 - 65535 ms. If OffTime is not entered, then
    ' OffTime = OnTime.

    Sub Flash_LED (in numtimes, in OnTime as WORD, Optional OffTime as WORD = OnTime)
        repeat numtimes
            set LED on
            wait OnTime ms
            set LED OFF
            wait OffTime ms
        end repeat
    End Sub</pre><p>Shown below is a working example program using a Microchip PIC 18F25K22.</p><p>Change Settings/PORTS as needed for other Chips.</p><p>Connect an LED to the LED pin via a 1K series resistor.</p><p><span class="strong"><strong>Demonstration program:</strong></span></p><pre class="screen">    #chip 18F25K22, 16
    #define LED PORTC.1       'Led on PIN 14 via 1K resistor
    DIR LED OUT
    wait 1 sec

    ;======== MAIN PROGRAM LOOP ================
    Do
       Flash_LED ( 3,250 )        '3 Flashes 250 ms equal on/off time
       Wait 2 Sec
       Flash_LED ( 5,250,500 )    '5 flashes On 250 ms / off 500 ms
       Wait 2 Sec
       Flash_LED ( 10,100 )       '10 rapid flashes
       Wait 2 Sec
    Loop
    ;==========================================

    Sub Flash_LED (in numtimes, in OnTime as WORD, optional OffTime as word = OnTime)
        repeat numtimes
            set LED on
            wait OnTime ms
            set LED OFF
            wait OffTime ms
        end repeat
    End Sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="flashing_led_with_timing_parameters"></span>Flashing LED with timing parameters

</div>

</div>

</div>

<span class="strong">**Explanation:**</span>

This is an example of how to define a subroutine.

When called, this subroutine will blink an LED for the number of times
and duration as determined by the input parameters.

The syntax of the subroutine is:

``` screen
    ' Flash_LED (numtimes, OnTime, (optional) OffTime)
    ' Where numtimes is from 1 - 255 and OnTime/OffTime is
    ' from 0 - 65535 ms. If OffTime is not entered, then
    ' OffTime = OnTime.

    Sub Flash_LED (in numtimes, in OnTime as WORD, Optional OffTime as WORD = OnTime)
        repeat numtimes
            set LED on
            wait OnTime ms
            set LED OFF
            wait OffTime ms
        end repeat
    End Sub
```

Shown below is a working example program using a Microchip PIC 18F25K22.

Change Settings/PORTS as needed for other Chips.

Connect an LED to the LED pin via a 1K series resistor.

<span class="strong">**Demonstration program:**</span>

``` screen
    #chip 18F25K22, 16
    #define LED PORTC.1       'Led on PIN 14 via 1K resistor
    DIR LED OUT
    wait 1 sec

    ;======== MAIN PROGRAM LOOP ================
    Do
       Flash_LED ( 3,250 )        '3 Flashes 250 ms equal on/off time
       Wait 2 Sec
       Flash_LED ( 5,250,500 )    '5 flashes On 250 ms / off 500 ms
       Wait 2 Sec
       Flash_LED ( 10,100 )       '10 rapid flashes
       Wait 2 Sec
    Loop
    ;==========================================

    Sub Flash_LED (in numtimes, in OnTime as WORD, optional OffTime as word = OnTime)
        repeat numtimes
            set LED on
            wait OnTime ms
            set LED OFF
            wait OffTime ms
        end repeat
    End Sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Flow control</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_sramwrite.html" title="SRAMWrite"><link rel="next" href="_do.html" title="Do"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_flow_control"></a>Flow control</h3></div></div></div><p>This is the Flow control section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="flow_control"></span>Flow control

</div>

</div>

</div>

This is the Flow control section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>FnLSL</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_bitwise.html" title="Bitwise"><link rel="prev" href="_bitwise_operations_overview.html" title="Bitwise Operations Overview"><link rel="next" href="_fnlsr.html" title="FnLSR"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_fnlsl"></a>FnLSL</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    BitsOut = FnLSL(BitsIn, NumBits)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">FnLSL</code> (Logical Shift Left) will perform a Bitwise left shift.
<code class="literal">FnLSL</code> will return BitsIn shifted NumBits to the left, it is equivalent to the 'C' operation:</p><pre class="screen">    BitsOut = BitsIn &lt;&lt; NumBits</pre><p>Each left shift is the equivalent of multiplying BitsIn by 2.
BitsIn and NumBits may be may be a variable and of  type: Bit, Byte, Word, Long, Constant or another Function.
Zeros are shifted in from the right, Bits that are shifted out are lost.</p><p>It is useful for mathematical and logical operations, as well as creating serial data streams or manipulating I/O ports.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    ' This program will shift the LEDs on the Microchip PIC Low Pin
    ' Count Demo Board from Right to Left, that is DS1(RC0) to
    ' DS4(RC3) and repeat

    #chip    16f690        ' declare the target Device

    #define  LEDPORT PORTC ' LEDs on pins 16, 15, 14 and 7

    Dim LEDMask as Byte    ' Pattern to be displayed
    LEDMask = 0b0001       ' Initialise the Patten
    Dir LEDPORT Out        ' Enable the LED Port.

    Do
        LEDMask = FnLSL(LEDMask, 1) &amp; 0x0F    ' Mask the lower 4 bits
        if LEDPORT.3 then LEDMask.0 = 1       ' Restart the sequence
        LEDPORT = LEDMask                     ' Display the Pattern
        wait 500 ms
    Loop
    End</pre><p><span class="strong"><strong>See Also <a class="link" href="_bitwise_operations_overview.html" title="Bitwise Operations Overview">Bitwise Operations Overview</a></strong></span> and <span class="strong"><strong><a class="link" href="_conditions.html" title="Conditions">Conditions</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="fnlsl"></span>FnLSL

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    BitsOut = FnLSL(BitsIn, NumBits)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

`FnLSL` (Logical Shift Left) will perform a Bitwise left shift. `FnLSL`
will return BitsIn shifted NumBits to the left, it is equivalent to the
'C' operation:

``` screen
    BitsOut = BitsIn << NumBits
```

Each left shift is the equivalent of multiplying BitsIn by 2. BitsIn and
NumBits may be may be a variable and of type: Bit, Byte, Word, Long,
Constant or another Function. Zeros are shifted in from the right, Bits
that are shifted out are lost.

It is useful for mathematical and logical operations, as well as
creating serial data streams or manipulating I/O ports.

<span class="strong">**Example:**</span>

``` screen
    ' This program will shift the LEDs on the Microchip PIC Low Pin
    ' Count Demo Board from Right to Left, that is DS1(RC0) to
    ' DS4(RC3) and repeat

    #chip    16f690        ' declare the target Device

    #define  LEDPORT PORTC ' LEDs on pins 16, 15, 14 and 7

    Dim LEDMask as Byte    ' Pattern to be displayed
    LEDMask = 0b0001       ' Initialise the Patten
    Dir LEDPORT Out        ' Enable the LED Port.

    Do
        LEDMask = FnLSL(LEDMask, 1) & 0x0F    ' Mask the lower 4 bits
        if LEDPORT.3 then LEDMask.0 = 1       ' Restart the sequence
        LEDPORT = LEDMask                     ' Display the Pattern
        wait 500 ms
    Loop
    End
```

<span class="strong">**See Also
<a href="bitwise_operations_overview" class="link" title="Bitwise Operations Overview">Bitwise Operations Overview</a>**</span>
and <span
class="strong">**<a href="conditions" class="link" title="Conditions">Conditions</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>FnLSR</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_bitwise.html" title="Bitwise"><link rel="prev" href="_fnlsl.html" title="FnLSL"><link rel="next" href="_setwith.html" title="SetWith"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_fnlsr"></a>FnLSR</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    BitsOut = FnLSR(BitsIn, NumBits)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">FnLSR</code> (Logical Shift Right) will perform a Bitwise right shift. <code class="literal">FnLSR</code> will return BitsIn shifted NumBits to the right, it is equivalent to the 'C' operation:</p><pre class="screen">    BitsOut = BitsIn &gt;&gt; NumBits</pre><p>Each right shift is the equivalent of dividing BitsIn by 2.</p><p>BitsIn and NumBits may be may be a variable and of  type: Bit, Byte, Word, Long, Constant or another Function.</p><p>Zeros are shifted in from the left, Bits that are shifted out are lost.</p><p>It is useful for mathematical and logical operations, as well as creating serial data streams or manipulating I/O ports.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    ' This program will shift the LEDs on the Microchip PIC Low Pin Count Demo Board
    ' from Right to Left, that is DS4(RC3) to DS1(RC0) and repeat.

    #chip    16f690        ' declare the target Device

    #define  LEDPORT PORTC ' LEDs on pins 16, 15, 14 and 7

    Dim LEDMask as Byte    ' Pattern to be displayed
    LEDMask = 0b1000       ' Initialise the Patten
    Dir LEDPORT Out        ' Enable the LED Port.

    Do
      LEDPORT = LEDMask    ' Display the Pattern
      wait 500 ms
      LEDMask = FnLSR(LEDMask, 1) &amp; 0x0F ' Mask the lower 4 bits
      if LEDPORT.0 then LEDMask.3 = 1    ' Restart the sequence
    Loop
    End</pre><p><span class="strong"><strong>See Also <a class="link" href="_bitwise_operations_overview.html" title="Bitwise Operations Overview">Bitwise Operations Overview</a></strong></span> and <span class="strong"><strong><a class="link" href="_conditions.html" title="Conditions">Conditions</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="fnlsr"></span>FnLSR

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    BitsOut = FnLSR(BitsIn, NumBits)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

`FnLSR` (Logical Shift Right) will perform a Bitwise right shift.
`FnLSR` will return BitsIn shifted NumBits to the right, it is
equivalent to the 'C' operation:

``` screen
    BitsOut = BitsIn >> NumBits
```

Each right shift is the equivalent of dividing BitsIn by 2.

BitsIn and NumBits may be may be a variable and of type: Bit, Byte,
Word, Long, Constant or another Function.

Zeros are shifted in from the left, Bits that are shifted out are lost.

It is useful for mathematical and logical operations, as well as
creating serial data streams or manipulating I/O ports.

<span class="strong">**Example:**</span>

``` screen
    ' This program will shift the LEDs on the Microchip PIC Low Pin Count Demo Board
    ' from Right to Left, that is DS4(RC3) to DS1(RC0) and repeat.

    #chip    16f690        ' declare the target Device

    #define  LEDPORT PORTC ' LEDs on pins 16, 15, 14 and 7

    Dim LEDMask as Byte    ' Pattern to be displayed
    LEDMask = 0b1000       ' Initialise the Patten
    Dir LEDPORT Out        ' Enable the LED Port.

    Do
      LEDPORT = LEDMask    ' Display the Pattern
      wait 500 ms
      LEDMask = FnLSR(LEDMask, 1) & 0x0F ' Mask the lower 4 bits
      if LEDPORT.0 then LEDMask.3 = 1    ' Restart the sequence
    Loop
    End
```

<span class="strong">**See Also
<a href="bitwise_operations_overview" class="link" title="Bitwise Operations Overview">Bitwise Operations Overview</a>**</span>
and <span
class="strong">**<a href="conditions" class="link" title="Conditions">Conditions</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Fonts and Characters</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_glcd_overview.html" title="GLCD Overview"><link rel="next" href="_e_paper_controllers.html" title="e-Paper Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_fonts_and_characters"></a>Fonts and Characters</h5></div></div></div><p>This section covers GLCD fonts and characters.</p><p><span class="strong"><strong>GLCD Support for Fonts</strong></span></p><p>lorem ipsum.&nbsp;&nbsp;</p><p><span class="strong"><strong>GLCD Support for Characters</strong></span></p><p>lorem ipsum.&nbsp;&nbsp;</p><p><span class="strong"><strong>GLCD Character Table</strong></span></p><p>lorem ipsum.&nbsp;&nbsp;</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/OLEDASCIIcharacter.png" align="middle" alt="graphic"></div></div><p><span class="strong"><strong>GLCD Controlling Constants</strong></span></p><p>The GCBASIC constants for control of fonts and characters are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">CONSTANT</code></p></td><td align="left" valign="top"><p>Words</p></td><td align="left" valign="top"><p>Explaination</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ANOTHER CONSTANT</code></p></td><td align="left" valign="top"><p>Words</p></td><td align="left" valign="top"><p>Explaination</p></td></tr></tbody></table></div><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="fonts_and_characters"></span>Fonts and Characters

</div>

</div>

</div>

This section covers GLCD fonts and characters.

<span class="strong">**GLCD Support for Fonts**</span>

lorem ipsum.  

<span class="strong">**GLCD Support for Characters**</span>

lorem ipsum.  

<span class="strong">**GLCD Character Table**</span>

lorem ipsum.  

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/OLEDASCIIcharacter.png)

</div>

</div>

<span class="strong">**GLCD Controlling Constants**</span>

The GCBASIC constants for control of fonts and characters are shown in
the table below.

<div class="informaltable">

| <span class="strong">**Constants**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Options**</span> |
|:------------------------------------------|:-----------------------------------------|:----------------------------------------|
| `CONSTANT`                                | Words                                    | Explaination                            |
| `ANOTHER CONSTANT`                        | Words                                    | Explaination                            |

</div>

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>For</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_flow_control.html" title="Flow control"><link rel="prev" href="_exit.html" title="Exit"><link rel="next" href="_gosub.html" title="Gosub"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_for"></a>For</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    For <span class="emphasis"><em>counter</em></span> = <span class="emphasis"><em>start</em></span> To <span class="emphasis"><em>end</em></span> [Step <span class="emphasis"><em>increment</em></span>]
    ...
    <span class="emphasis"><em>program code</em></span>
    ...
    &lt;<span class="emphasis"><em>condition</em></span>&gt; Exit For
    ...
    Next</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The For command is ideal for situations where a piece of code needs to
be run a set number of times, and where it is necessary to keep track of
how many times the code has run. When the For command is first executed,
<code class="literal"><span class="emphasis"><em>counter</em></span></code> is set to <code class="literal"><span class="emphasis"><em>start</em></span></code>. Then, each successive time the program
loops, <code class="literal"><span class="emphasis"><em>increment</em></span></code> is added to <code class="literal"><span class="emphasis"><em>counter</em></span></code>, until <code class="literal"><span class="emphasis"><em>counter</em></span></code> is equal to
<code class="literal"><span class="emphasis"><em>end</em></span></code>. Then, the program continues beyond the Next.</p><p><code class="literal"><span class="emphasis"><em>Step</em></span></code> and <code class="literal"><span class="emphasis"><em>increment</em></span></code> are optionals. If Step is not specified, GCBASIC
will increment <code class="literal"><span class="emphasis"><em>counter</em></span></code> by 1 each time the code is run.</p><p><code class="literal"><span class="emphasis"><em>increment</em></span></code> can be a positive or negative constant or an integer.</p><p>The <code class="literal">Exit For</code> is optional and can be used to exit the loop upon a specific
condition.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p><code class="literal">#define USELEGACYFORNEXT</code> to enable legacy FOR-NEXT support.&nbsp;&nbsp;
The GCBASIC compiler was revised in 2021 to improve the handling of the FOR-NEXT support.&nbsp;&nbsp;
You can revert to the legacy FOR-NEXT support by using <code class="literal">#DEFINE USELEGACYFORNEXT</code> but using this legacy support will cause your program to operate incorrectly. &nbsp;&nbsp;
The use of <code class="literal">#DEFINE USELEGACYFORNEXT</code> is NOT recommended.</p></div><p><span class="strong"><strong>Examples.</strong></span></p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    'This code will flash a green light 6 times.

    #chip 16F88, 8

    #define LED PORTB.0
    Dir LED Out

    For LoopCounter = 1 to 6

      PulseOut Led, 1 s
      Wait 1 s

    Next</pre><p><span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">'This code will flash alternate LEDS until the switch is pressed.

    #chip 16F88, 8

    #define LED1 PORTB.0
    Dir LED1 Out
    #define LED2 PORTB.2
    Dir LED2 Out

    #define SWITCH1 PORTA.0
    Dir SWITCH1 In
    main:
    PulseOut LED1, 1 s
    For LoopCounterOut = 1 to 250

      PulseOut LED2, 4 Ms
      if switch = On then Exit For

    Next
    Set LED2 OFF
    goto main</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_repeat.html" title="Repeat">Repeat</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="for"></span>For

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    For counter = start To end [Step increment]
    ...
    program code
    ...
    <condition> Exit For
    ...
    Next
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The For command is ideal for situations where a piece of code needs to
be run a set number of times, and where it is necessary to keep track of
how many times the code has run. When the For command is first executed,
`counter` is set to `start`. Then, each successive time the program
loops, `increment` is added to `counter`, until `counter` is equal to
`end`. Then, the program continues beyond the Next.

`Step` and `increment` are optionals. If Step is not specified, GCBASIC
will increment `counter` by 1 each time the code is run.

`increment` can be a positive or negative constant or an integer.

The `Exit For` is optional and can be used to exit the loop upon a
specific condition.

<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

### Warning

`#define USELEGACYFORNEXT` to enable legacy FOR-NEXT support.   The
GCBASIC compiler was revised in 2021 to improve the handling of the
FOR-NEXT support.   You can revert to the legacy FOR-NEXT support by
using `#DEFINE USELEGACYFORNEXT` but using this legacy support will
cause your program to operate incorrectly.    The use of
`#DEFINE USELEGACYFORNEXT` is NOT recommended.

</div>

<span class="strong">**Examples.**</span>

<span class="strong">**Example 1:**</span>

``` screen
    'This code will flash a green light 6 times.

    #chip 16F88, 8

    #define LED PORTB.0
    Dir LED Out

    For LoopCounter = 1 to 6

      PulseOut Led, 1 s
      Wait 1 s

    Next
```

<span class="strong">**Example 2:**</span>

``` screen
'This code will flash alternate LEDS until the switch is pressed.

    #chip 16F88, 8

    #define LED1 PORTB.0
    Dir LED1 Out
    #define LED2 PORTB.2
    Dir LED2 Out

    #define SWITCH1 PORTA.0
    Dir SWITCH1 In
    main:
    PulseOut LED1, 1 s
    For LoopCounterOut = 1 to 250

      PulseOut LED2, 4 Ms
      if switch = On then Exit For

    Next
    Set LED2 OFF
    goto main
```

<span class="strong">**For more help, see
<a href="repeat" class="link" title="Repeat">Repeat</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Frequently Asked Questions</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_a_glossary.html" title="A Glossary"><link rel="next" href="_troubleshooting.html" title="Troubleshooting"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_frequently_asked_questions"></a>Frequently Asked Questions</h2></div></div></div><p><span class="strong"><strong>Why doesn&#8217;t anything come up when I run GCBASIC.exe?</strong></span></p><p>GCBASIC IS a command line compiler. To compile a file, you can
drag and drop it onto the GCBASIC.exe icon.</p><p>If you use an Integrated Development Environment (IDE) you can edit your program and press an ICON  to send the program to the chip. Several are listed on the GCBASIC website.</p><p>The recommended IDE for Windows is GCCODE.</p><p><br>
<br>
<span class="strong"><strong>What Microchip PIC, Atmel AVR or LGT microcontrollers does GCBASIC support?</strong></span></p><p>Hopefully, all 8 bit Microchip PIC, Atmel AVR and LGT microcontrollers and (those in the PIC10, PIC12, PIC16 and PIC18 families). If you find one that GCBASIC does not work with
properly, please post about it in the Compiler Problems section of the
GCBASIC forum.
<br>
<br>
<span class="strong"><strong>Is GCBASIC case sensitive?</strong></span></p><p>No! For example, <code class="literal">Set</code>, <code class="literal">SET</code>, <code class="literal">set</code>, <code class="literal">SeT</code>, etc are all treated exactly the
same way by GCBASIC.
<br>
<br>
<span class="strong"><strong>Can I specify the bit of a variable to alter using another variable?</strong></span></p><p>GCBASIC support bitwise assignments. As follows:</p><pre class="screen">    portc.0 = !porta.1</pre><p>You can also use a shift function.  As in other languages, by using the Shift Function FnLSL.  AN example is:</p><pre class="screen">    MyVar = FnLSL( 1, BitNum)`  is Equivalent to `MyVar = 1&lt;&lt;BitNum`</pre><p>To set a bit of a port and to prevent glitches during operations, use <code class="literal">#option volatile</code> as folllows.</p><pre class="screen">    'add this option for a specific port.
    #option volatile portc.0

    'then in your code
    portc.0 = !porta.1</pre><p>To set a bit of a port or variable. Encapsulate it in the SetWith method, this also eliminates any glitches during the update, use this method.</p><pre class="screen">    SetWith(MyPORT, MyPORT OR FnLSL( 1, BitNum))</pre><p>To clear a bit of a port, use this method.</p><pre class="screen">    MyPORT = MyPORT AND NOT FnLSL( 1, BitNum))</pre><p>To set a bit within an array, use this method.</p><pre class="screen">    video_buffer_A1(video_adress) = video_buffer_A1(video_adress) OR FnLSL( 1, BitNum)</pre><p>To set a bit within a variable, use this method.</p><pre class="screen">    Dim my_variable as byte
    Dim my_bit_address_variable as byte

    'example
    my_variable = 0
    my_bit_address_variable = 7

    my_variable.my_bit_address_variable = 1   ' where 1 or 0 or any bit address is valid

    'Sets bit 7 of my_variable therefore 128</pre><p>See also  <a class="link" href="_set.html" title="Set">Set</a>, <a class="link" href="_fnlsl.html" title="FnLSL">FnLSL</a>, <a class="link" href="_fnlsr.html" title="FnLSR">FnLSR</a> and <a class="link" href="_rotate.html" title="Rotate">Rotate</a>
<br>
<br>
<span class="strong"><strong>Why is x feature not implemented?</strong></span></p><p>Because it has not been thought of, or no-one has been able to implement
it!</p><p>If there are any features that you would like to see in GCBASIC, please post them in the "Open Discussion" section of the GCBASIC forum. Or, if you can, have a go at adding the feature yourself!
<br>
<br></p><p><span class="strong"><strong>When using an include file does this use lots of memory?</strong></span></p><p>When using include files, for instance the &lt;ds3231.h&gt; include, if
you are not using all the functions of the include file, GCBASIC knows
not to include the  unused functions within the user program when
compiling.</p><p><span class="strong"><strong>If I am using the hardware I2C, does all the code related to hardware I2C still get compiled in the code?</strong></span></p><p>GCBASIC only compiles functions and subroutines if they are called.
GCBASIC starts by compiling the main routine, then anything called from
there. Each time it finds a new subroutine that is called, it compiles
it and anything that it calls. If a subroutine is not needed, it does
not get compiled.
<br>
<br>
<span class="strong"><strong>My LCD will not operate as expected?</strong></span></p><p>Try adding. <code class="literal">#define LCD_SPEED SLOW</code></p><p>This will slow the writing to the LCD.
<br>
<br>
<span class="strong"><strong>Atmel AVR memory usage displayed is incorrect?</strong></span></p><p>Atmel AVR memory values are specified in WORDS in GCBASIC. The GCBASIC compiler uses words, not bytes, for consistency between Microchip PIC and Atmel AVR microcontrollers. This keeps parts of the compiler simpler.
<br>
<br>
<span class="strong"><strong>I cannot open the Window Help File?</strong></span></p><p>See <a class="link" href="http://digital.ni.com/public.nsf/allkb/B59D2B24D624B823862575FC0056F3D0" target="_top">http://digital.ni.com/public.nsf/allkb/B59D2B24D624B823862575FC0056F3D0</a>
<br>
<br>
<span class="strong"><strong>How do I revert the FOR-NEXT loop to the Legacy FOR-NEXT method ?</strong></span></p><p>Some background.&nbsp;&nbsp;
In 2021 the GCBASIC compiler was updated to improve the operation of the FOR-NEXT loop.&nbsp;&nbsp;
The improvement did increase the size of the ASM generated.&nbsp;&nbsp;
The legacy FOR-NEXT loop had some major issues that included never ending loops, incorrect end loop and unexpected operations.&nbsp;&nbsp;
This was all caused by the compiler, not the user, and in 2021 the compiler was updated to resolve these issues.&nbsp;&nbsp;</p><p>However, there is a risk that the new FOR-NEXT method causes 1) larger ASM that will not fit in small microcontrollers or 2) the new code does not operate as expected.&nbsp;&nbsp;
In either case you can disable the new FOR-NEXT method by adding a constant as shown below.&nbsp;&nbsp;
Adding this constant will revert the FOR-NEXT loop asm generated to the legacy method.&nbsp;&nbsp;</p><pre class="screen">    #DEFINE USELEGACYFORNEXT</pre><p><br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="frequently_asked_questions"></span>Frequently Asked Questions
------------------------------------------------------------------------

</div>

</div>

</div>

<span class="strong">**Why doesn’t anything come up when I run
GCBASIC.exe?**</span>

GCBASIC IS a command line compiler. To compile a file, you can drag and
drop it onto the GCBASIC.exe icon.

If you use an Integrated Development Environment (IDE) you can edit your
program and press an ICON to send the program to the chip. Several are
listed on the GCBASIC website.

The recommended IDE for Windows is GCCODE.

  
  
<span class="strong">**What Microchip PIC, Atmel AVR or LGT
microcontrollers does GCBASIC support?**</span>

Hopefully, all 8 bit Microchip PIC, Atmel AVR and LGT microcontrollers
and (those in the PIC10, PIC12, PIC16 and PIC18 families). If you find
one that GCBASIC does not work with properly, please post about it in
the Compiler Problems section of the GCBASIC forum.  
  
<span class="strong">**Is GCBASIC case sensitive?**</span>

No! For example, `Set`, `SET`, `set`, `SeT`, etc are all treated exactly
the same way by GCBASIC.  
  
<span class="strong">**Can I specify the bit of a variable to alter
using another variable?**</span>

GCBASIC support bitwise assignments. As follows:

``` screen
    portc.0 = !porta.1
```

You can also use a shift function. As in other languages, by using the
Shift Function FnLSL. AN example is:

``` screen
    MyVar = FnLSL( 1, BitNum)`  is Equivalent to `MyVar = 1<<BitNum`
```

To set a bit of a port and to prevent glitches during operations, use
`#option volatile` as folllows.

``` screen
    'add this option for a specific port.
    #option volatile portc.0

    'then in your code
    portc.0 = !porta.1
```

To set a bit of a port or variable. Encapsulate it in the SetWith
method, this also eliminates any glitches during the update, use this
method.

``` screen
    SetWith(MyPORT, MyPORT OR FnLSL( 1, BitNum))
```

To clear a bit of a port, use this method.

``` screen
    MyPORT = MyPORT AND NOT FnLSL( 1, BitNum))
```

To set a bit within an array, use this method.

``` screen
    video_buffer_A1(video_adress) = video_buffer_A1(video_adress) OR FnLSL( 1, BitNum)
```

To set a bit within a variable, use this method.

``` screen
    Dim my_variable as byte
    Dim my_bit_address_variable as byte

    'example
    my_variable = 0
    my_bit_address_variable = 7

    my_variable.my_bit_address_variable = 1   ' where 1 or 0 or any bit address is valid

    'Sets bit 7 of my_variable therefore 128
```

See also <a href="set" class="link" title="Set">Set</a>,
<a href="fnlsl" class="link" title="FnLSL">FnLSL</a>,
<a href="fnlsr" class="link" title="FnLSR">FnLSR</a> and
<a href="rotate" class="link" title="Rotate">Rotate</a>  
  
<span class="strong">**Why is x feature not implemented?**</span>

Because it has not been thought of, or no-one has been able to implement
it!

If there are any features that you would like to see in GCBASIC, please
post them in the "Open Discussion" section of the GCBASIC forum. Or, if
you can, have a go at adding the feature yourself!  
  

<span class="strong">**When using an include file does this use lots of
memory?**</span>

When using include files, for instance the &lt;ds3231.h&gt; include, if
you are not using all the functions of the include file, GCBASIC knows
not to include the unused functions within the user program when
compiling.

<span class="strong">**If I am using the hardware I2C, does all the code
related to hardware I2C still get compiled in the code?**</span>

GCBASIC only compiles functions and subroutines if they are called.
GCBASIC starts by compiling the main routine, then anything called from
there. Each time it finds a new subroutine that is called, it compiles
it and anything that it calls. If a subroutine is not needed, it does
not get compiled.  
  
<span class="strong">**My LCD will not operate as expected?**</span>

Try adding. `#define LCD_SPEED SLOW`

This will slow the writing to the LCD.  
  
<span class="strong">**Atmel AVR memory usage displayed is
incorrect?**</span>

Atmel AVR memory values are specified in WORDS in GCBASIC. The GCBASIC
compiler uses words, not bytes, for consistency between Microchip PIC
and Atmel AVR microcontrollers. This keeps parts of the compiler
simpler.  
  
<span class="strong">**I cannot open the Window Help File?**</span>

See
<http://digital.ni.com/public.nsf/allkb/B59D2B24D624B823862575FC0056F3D0>  
  
<span class="strong">**How do I revert the FOR-NEXT loop to the Legacy
FOR-NEXT method ?**</span>

Some background.   In 2021 the GCBASIC compiler was updated to improve
the operation of the FOR-NEXT loop.   The improvement did increase the
size of the ASM generated.   The legacy FOR-NEXT loop had some major
issues that included never ending loops, incorrect end loop and
unexpected operations.   This was all caused by the compiler, not the
user, and in 2021 the compiler was updated to resolve these issues.  

However, there is a risk that the new FOR-NEXT method causes 1) larger
ASM that will not fit in small microcontrollers or 2) the new code does
not operate as expected.   In either case you can disable the new
FOR-NEXT method by adding a constant as shown below.   Adding this
constant will revert the FOR-NEXT loop asm generated to the legacy
method.  

``` screen
    #DEFINE USELEGACYFORNEXT
```

  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Frequent errors</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_command_line_parameters.html" title="Command Line Parameters"><link rel="next" href="_a_glossary.html" title="A Glossary"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_frequent_errors"></a>Frequent errors</h2></div></div></div><p><span class="red">Frequent errors that may happen, from the initial creation of a program and onwards.</span></p><p><span class="red">Strange timings:</span>  You declared an oscillator frequency, different from the oscillator actually attached to the micrcontroller.
<br>
<br>
<span class="red">No oscillator:</span>  Keep in mind that, besides the frequency, you must also set the type of oscillator, internal or external.
<br>
<br>
<span class="red">No GCBASIC frequency stated:</span> If not declared in your source program - GCBASIC uses a preset frequency suitable for operating the microcontroller as the fastest practical.
<br>
<br>
<span class="red">External oscillators:</span> It must be explicitly stated, if not stated GCBASIC  will attempt to setup the internal oscillator.
<br>
<br>
<span class="red">Ports:</span> GCBASIC will set the ports automatically but you may need to set the ports outputs or inputs when needed.
<br>
<br>
<span class="red">Analog levels:</span>  When applied on the ports defined as digital inputs. can cause current consumption in the input buffer, which is outside the device specifications. Beware.
<br>
<br>
<span class="red">Current drawn:</span> Current taken from the microcontroller outputs, exceeding the maximum allowed (not all pins supply the same current).  Beware of drawing to much current.
<br>
<br>
<span class="red">Watchdog Timer (WDT):</span> The WDT is a useful timer.  Enable to reset the microcontroller when processing can get stuck in a loop.
<br>
<br>
<span class="red">Interrupts:</span> A badly controlled interrupt (in some cases) will prevent the execution of the entire program.
<br>
<br>
<span class="red">No action:</span> The circuit is not powered.
<br>
<br>
<span class="red">Still no action:</span> The microcontroller is not present or different from the device you expected.
<br>
<br>
<span class="red">Still no action:</span> The microcontroller inserted incorrectly in the appropriate socket.
<br>
<br>
<span class="red">Cannot program:</span> Incorrect programmer, Incorrect programmer parameters or circuit connections are incorrect.
<br>
<br>
<span class="red">Still Cannot program:</span> Values of excessively incorrect circuit resistances.
<br>
<br>
<span class="red">Serial Communcations:</span> The TX and RX pins of the serial port are exchanged, and/or the connections with the level converter, ttl / rs232 or ttl / usb.
<br>
<br>
<span class="red">Stlll no Serial Communcations:</span> Serial speed, different from the one set in the circuit with which it is intended to communicate or vice versa.
<br>
<br>
<span class="red">No I2C/TWI:</span>  SDL and/or SCL pin exchanged on the I2C/TWI bus connection, and/or no pull-up resistors, and/or no common 0 voltage.
<br>
<br>
<span class="red">Incorrect timing:</span> Calculation of any timings related to the frequency of the external oscillator, without taking into account the division by 4.
<br>
<br>
<span class="red">Strange Numeric Values:</span> The variables declared are insufficient to contain the values &#8203;&#8203;to be processed.
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="frequent_errors"></span>Frequent errors
--------------------------------------------------

</div>

</div>

</div>

<span class="red">Frequent errors that may happen, from the initial
creation of a program and onwards.</span>

<span class="red">Strange timings:</span> You declared an oscillator
frequency, different from the oscillator actually attached to the
micrcontroller.  
  
<span class="red">No oscillator:</span> Keep in mind that, besides the
frequency, you must also set the type of oscillator, internal or
external.  
  
<span class="red">No GCBASIC frequency stated:</span> If not declared in
your source program - GCBASIC uses a preset frequency suitable for
operating the microcontroller as the fastest practical.  
  
<span class="red">External oscillators:</span> It must be explicitly
stated, if not stated GCBASIC will attempt to setup the internal
oscillator.  
  
<span class="red">Ports:</span> GCBASIC will set the ports automatically
but you may need to set the ports outputs or inputs when needed.  
  
<span class="red">Analog levels:</span> When applied on the ports
defined as digital inputs. can cause current consumption in the input
buffer, which is outside the device specifications. Beware.  
  
<span class="red">Current drawn:</span> Current taken from the
microcontroller outputs, exceeding the maximum allowed (not all pins
supply the same current). Beware of drawing to much current.  
  
<span class="red">Watchdog Timer (WDT):</span> The WDT is a useful
timer. Enable to reset the microcontroller when processing can get stuck
in a loop.  
  
<span class="red">Interrupts:</span> A badly controlled interrupt (in
some cases) will prevent the execution of the entire program.  
  
<span class="red">No action:</span> The circuit is not powered.  
  
<span class="red">Still no action:</span> The microcontroller is not
present or different from the device you expected.  
  
<span class="red">Still no action:</span> The microcontroller inserted
incorrectly in the appropriate socket.  
  
<span class="red">Cannot program:</span> Incorrect programmer, Incorrect
programmer parameters or circuit connections are incorrect.  
  
<span class="red">Still Cannot program:</span> Values of excessively
incorrect circuit resistances.  
  
<span class="red">Serial Communcations:</span> The TX and RX pins of the
serial port are exchanged, and/or the connections with the level
converter, ttl / rs232 or ttl / usb.  
  
<span class="red">Stlll no Serial Communcations:</span> Serial speed,
different from the one set in the circuit with which it is intended to
communicate or vice versa.  
  
<span class="red">No I2C/TWI:</span> SDL and/or SCL pin exchanged on the
I2C/TWI bus connection, and/or no pull-up resistors, and/or no common 0
voltage.  
  
<span class="red">Incorrect timing:</span> Calculation of any timings
related to the frequency of the external oscillator, without taking into
account the division by 4.  
  
<span class="red">Strange Numeric Values:</span> The variables declared
are insufficient to contain the values ​​to be processed.  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Functions</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_constants.html" title="Constants"><link rel="next" href="_labels.html" title="Labels"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_functions"></a>Functions</h3></div></div></div><p><span class="strong"><strong>About Functions</strong></span></p><p>Functions are a special type of subroutine that can return a value. This
means that when the name of the function is used in the place of a
variable, GCBASIC will call the function, get a value from it, and then
put the value into the line of code in the place of the variable.</p><p>Functions may also have parameters - these are treated in exactly the
same way as parameters for subroutines. The only exception is that
brackets are required around any parameters when calling a function.</p><p><span class="strong"><strong>Using Functions</strong></span></p><p>This program uses a function called <code class="literal">AverageAD</code> to take two analog
readings, and then make a decision based on the average:</p><pre class="screen">    'Select chip
    #chip 16F88, 20

    'Define ports
    #define LED PORTB.0
    #define Sensor AN0

    'Set port directions
    dir LED out
    dir PORTA.0 in

    'Main code
    Do
    Set PORTB.0 Off
    If AverageAD &gt; 128 Then Set PORTB.0 On
    wait 10 ms
    Loop

    Function AverageAD
    'Get 2 readings, divide by 2, store in AverageAD
    'Note the cast, the result of ReadAD needs to be converted to
    'a word before adding, or the result may overflow.
    AverageAD = ([word]ReadAD(Sensor) + ReadAD(Sensor)) / 2
    end function</pre><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_subroutines.html" title="Subroutines">Subroutines</a>, <a class="link" href="_exit.html" title="Exit">Exit</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="functions"></span>Functions

</div>

</div>

</div>

<span class="strong">**About Functions**</span>

Functions are a special type of subroutine that can return a value. This
means that when the name of the function is used in the place of a
variable, GCBASIC will call the function, get a value from it, and then
put the value into the line of code in the place of the variable.

Functions may also have parameters - these are treated in exactly the
same way as parameters for subroutines. The only exception is that
brackets are required around any parameters when calling a function.

<span class="strong">**Using Functions**</span>

This program uses a function called `AverageAD` to take two analog
readings, and then make a decision based on the average:

``` screen
    'Select chip
    #chip 16F88, 20

    'Define ports
    #define LED PORTB.0
    #define Sensor AN0

    'Set port directions
    dir LED out
    dir PORTA.0 in

    'Main code
    Do
    Set PORTB.0 Off
    If AverageAD > 128 Then Set PORTB.0 On
    wait 10 ms
    Loop

    Function AverageAD
    'Get 2 readings, divide by 2, store in AverageAD
    'Note the cast, the result of ReadAD needs to be converted to
    'a word before adding, or the result may overflow.
    AverageAD = ([word]ReadAD(Sensor) + ReadAD(Sensor)) / 2
    end function
```

<span class="strong">**See Also**</span>
<a href="subroutines" class="link" title="Subroutines">Subroutines</a>,
<a href="exit" class="link" title="Exit">Exit</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>FVRInitialize</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_fixed_voltage_reference.html" title="Fixed Voltage Reference"><link rel="prev" href="_fixed_voltage_reference.html" title="Fixed Voltage Reference"><link rel="next" href="_fvrisoutputready.html" title="FVRIsOutputReady"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_fvrinitialize"></a>FVRInitialize</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    FVRInitialize ( FVR_OFF | FVR_1x | FVR_2x | FVR_4x  )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip microcontrollers with the  Fixed Voltage Reference (FVR) module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The method is a subroutine that sets the state of the FVR.&nbsp;&nbsp;&nbsp;</p><p><code class="literal">FVR_Off</code>&nbsp;=&nbsp;&nbsp;Fixed Voltage Reference is set to OFF</p><p><code class="literal">FVR_1x</code>&nbsp;&nbsp;=&nbsp; Fixed Voltage Reference is set to 1.024v</p><p><code class="literal">FVR_2x</code>&nbsp;&nbsp;=&nbsp; Fixed Voltage Reference is set to 2.048v</p><p><code class="literal">FVR_4x</code>&nbsp;&nbsp;=&nbsp; Fixed Voltage Reference is set to 4.096v</p><p>Using the the following device&#8217;s datasheet, as a general case, &nbsp;&nbsp;&nbsp;<a class="link" href="http://ww1.microchip.com/downloads/en/DeviceDoc/40001419F.pdf" target="_top">http://ww1.microchip.com/downloads/en/DeviceDoc/40001419F.pdf</a> &nbsp;&nbsp;&nbsp;that can be downloaded from the device&#8217;s page,&nbsp;&nbsp;&nbsp;<a class="link" href="http://www.microchip.com/wwwproducts/en/pic16f1828" target="_top">http://www.microchip.com/wwwproducts/en/pic16f1828</a>
parameter AD06 in table 30-8 at page 359, and the corresponding Note 4, tell us that the Vref voltage (Vref+ minus Vref-) should not be less than 1.8V, regardless of the reference voltage used, in order for the ADC module to work within the datasheet specifications.
&nbsp;&nbsp;Also, as Vref- cannot be a negative voltage (voltages below GND) the lowest voltage on it is 0V. &nbsp;&nbsp;Then an FVR of 1.024V cannot be used as VREF+ for the ADC, but only 2.048 and 4.098 values.</p><p>The 1.024V FVR value exists for usage with other modules not just the ADC module.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    '// use FVR 4096 as Reference
    FVRInitialize ( FVR_4x )
    wait while FVRIsOutputReady = false
    ADVal = ReadAd(AN0)

    '// Turn off FVR
    FVRInitialize ( FVR_Off )</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_fvrisoutputready.html" title="FVRIsOutputReady">FVRIsOutputReady</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="fvrinitialize"></span>FVRInitialize

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    FVRInitialize ( FVR_OFF | FVR_1x | FVR_2x | FVR_4x  )
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip microcontrollers with the Fixed Voltage
Reference (FVR) module.

<span class="strong">**Explanation:**</span>

The method is a subroutine that sets the state of the FVR.   

`FVR_Off` =  Fixed Voltage Reference is set to OFF

`FVR_1x`  =  Fixed Voltage Reference is set to 1.024v

`FVR_2x`  =  Fixed Voltage Reference is set to 2.048v

`FVR_4x`  =  Fixed Voltage Reference is set to 4.096v

Using the the following device’s datasheet, as a general case,
   <http://ww1.microchip.com/downloads/en/DeviceDoc/40001419F.pdf>
   that can be downloaded from the device’s
page,   <http://www.microchip.com/wwwproducts/en/pic16f1828> parameter
AD06 in table 30-8 at page 359, and the corresponding Note 4, tell us
that the Vref voltage (Vref+ minus Vref-) should not be less than 1.8V,
regardless of the reference voltage used, in order for the ADC module to
work within the datasheet specifications.   Also, as Vref- cannot be a
negative voltage (voltages below GND) the lowest voltage on it is 0V.
  Then an FVR of 1.024V cannot be used as VREF+ for the ADC, but only
2.048 and 4.098 values.

The 1.024V FVR value exists for usage with other modules not just the
ADC module.

<span class="strong">**Example:**</span>

``` screen
    '// use FVR 4096 as Reference
    FVRInitialize ( FVR_4x )
    wait while FVRIsOutputReady = false
    ADVal = ReadAd(AN0)

    '// Turn off FVR
    FVRInitialize ( FVR_Off )
```

<span class="strong">**For more help, see**</span>
<a href="fvrisoutputready" class="link" title="FVRIsOutputReady">FVRIsOutputReady</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>FVRIsOutputReady</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_fixed_voltage_reference.html" title="Fixed Voltage Reference"><link rel="prev" href="_fvrinitialize.html" title="FVRInitialize"><link rel="next" href="_interrupts.html" title="Interrupts"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_fvrisoutputready"></a>FVRIsOutputReady</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    user_var = FVRIsOutputReady()</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip microcontrollers with the  Fixed Voltage Reference (FVR) module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The method is a function that returns the state of the FVR.&nbsp;&nbsp;&nbsp;The returned value can be assigned to a variable to used as function.</p><p>The method returns 0 or 1.&nbsp;&nbsp;&nbsp;As follows:</p><p>0 = Fixed Voltage Reference output is not ready or not enabled</p><p>1 = Fixed Voltage Reference output is ready for use</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    '// use FVR 4096 as Reference
    FVRInitialize ( FVR_4x )
    wait while FVRIsOutputReady = false
    ADVal = ReadAd(AN0)</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_fvrinitialize.html" title="FVRInitialize">FVRInitialize</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="fvrisoutputready"></span>FVRIsOutputReady

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    user_var = FVRIsOutputReady()
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip microcontrollers with the Fixed Voltage
Reference (FVR) module.

<span class="strong">**Explanation:**</span>

The method is a function that returns the state of the FVR.   The
returned value can be assigned to a variable to used as function.

The method returns 0 or 1.   As follows:

0 = Fixed Voltage Reference output is not ready or not enabled

1 = Fixed Voltage Reference output is ready for use

<span class="strong">**Example:**</span>

``` screen
    '// use FVR 4096 as Reference
    FVRInitialize ( FVR_4x )
    wait while FVRIsOutputReady = false
    ADVal = ReadAd(AN0)
```

<span class="strong">**For more help, see**</span>
<a href="fvrinitialize" class="link" title="FVRInitialize">FVRInitialize</a>

</div>
ITSF   `      Z	  |{ "|{ "`              x       TP      P            w            ITSP   T   
                         	  j].! "T   PMGL?          /   /#IDXHDR½F /#ITBITS   	/#STRINGSž/#SYSTEM F./#TOCIDXF`/#TOPICS&0/#URLSTR^@/#URLTBLģV	/#WINDOWSxL/$FIftiMain;	/$OBJINSTL?/$WWAssociativeLinks/   /$WWAssociativeLinks/PropertyH/$WWKeywordLinks/   /$WWKeywordLinks/PropertyD<HTML>
<HEAD>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   </HEAD>
<BODY>
<OBJECT type="text/site properties">
<param name="ImageType" value="Folder">
</OBJECT>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Introducing GCBASIC">
<param name="Local" value="_introducing_gcbasic.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Using GCBASIC">
<param name="Local" value="_using_gcbasic.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PIC users and Beginners: Start Here">
<param name="Local" value="_pic_users_and_beginners_start_here.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Changes">
<param name="Local" value="_changes.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Command Line Parameters">
<param name="Local" value="_command_line_parameters.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Frequent errors">
<param name="Local" value="_frequent_errors.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="A Glossary">
<param name="Local" value="_a_glossary.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Frequently Asked Questions">
<param name="Local" value="_frequently_asked_questions.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Troubleshooting">
<param name="Local" value="_troubleshooting.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Compiler Insights">
<param name="Local" value="_compiler_insights.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Libraries Overview">
<param name="Local" value="_libraries_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Acknowledgements">
<param name="Local" value="_acknowledgements.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Tricks and Tips">
<param name="Local" value="_tricks_and_tips.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="UNO as ISP programmer">
<param name="Local" value="_uno_as_isp_programmer.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Microcontroller Fundamentals">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Inputs/Outputs">
<param name="Local" value="_inputs_outputs.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Configuration">
<param name="Local" value="_configuration.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Data Types">
<param name="Local" value="_data_types.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Variable Types">
<param name="Local" value="_variable_types.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Variable Advanced Types">
<param name="Local" value="_variable_advanced_types.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Variable Memory Allocation">
<param name="Local" value="_variable_memory_allocation.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="USB Drivers Installer">
<param name="Local" value="_usb_drivers_installer.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Syntax">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Arrays">
<param name="Local" value="_arrays.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Comments">
<param name="Local" value="_comments.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Line Continuation">
<param name="Local" value="_line_continuation.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Conditions">
<param name="Local" value="_conditions.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Constants">
<param name="Local" value="_constants.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Functions">
<param name="Local" value="_functions.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Labels">
<param name="Local" value="_labels.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Lookup Tables">
<param name="Local" value="_lookup_tables.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Miscellaneous">
<param name="Local" value="_miscellaneous.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ReadTable">
<param name="Local" value="_readtable.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Scripts">
<param name="Local" value="_scripts.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Subroutines">
<param name="Local" value="_subroutines.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Converters">
<param name="Local" value="_converters.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Command References">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Analog/Digital conversion">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Analog/Digital Conversion Overview">
<param name="Local" value="_analog_digital_conversion_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ADFormat (Deprecated - Do not use)">
<param name="Local" value="_adformat_deprecated_do_not_use.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ADOff">
<param name="Local" value="_adoff.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ReadAD">
<param name="Local" value="_readad.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ReadAD10">
<param name="Local" value="_readad10.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ReadAD12">
<param name="Local" value="_readad12.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Analog/Digital Conversion Code Optimisation">
<param name="Local" value="_analog_digital_conversion_code_optimisation.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Bitwise">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Bitwise Operations Overview">
<param name="Local" value="_bitwise_operations_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="FnLSL">
<param name="Local" value="_fnlsl.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="FnLSR">
<param name="Local" value="_fnlsr.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SetWith">
<param name="Local" value="_setwith.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Memory">
<param name="Local" value="_memory.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="MCU EEPROM ( DFM )">
<param name="Local" value="_mcu_eeprom_dfm.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="EPRead">
<param name="Local" value="_epread.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="EPWrite">
<param name="Local" value="_epwrite.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Dataset for EEPROM">
<param name="Local" value="_dataset_for_eeprom.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="HEFM ( PFM )">
<param name="Local" value="_hefm_pfm.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HEFM Overview">
<param name="Local" value="_hefm_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HEFRead">
<param name="Local" value="_hefread.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HEFReadWord">
<param name="Local" value="_hefreadword.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HEFWrite">
<param name="Local" value="_hefwrite.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HEFWriteWord">
<param name="Local" value="_hefwriteword.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HEFReadBlock">
<param name="Local" value="_hefreadblock.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HEFWriteBlock">
<param name="Local" value="_hefwriteblock.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HEFEraseBlock">
<param name="Local" value="_heferaseblock.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="PROGMEM ( PFM )">
<param name="Local" value="_progmem_pfm.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PFMRead">
<param name="Local" value="_pfmread.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PFMWrite">
<param name="Local" value="_pfmwrite.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ProgramErase">
<param name="Local" value="_programerase.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ProgramRead">
<param name="Local" value="_programread.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ProgramWrite">
<param name="Local" value="_programwrite.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="PROGMEM ( MCU Configuration )">
<param name="Local" value="_progmem_mcu_configuration.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="DeviceConfigurationRead">
<param name="Local" value="_deviceconfigurationread.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="SAFM">
<param name="Local" value="_safm.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SAFM Overview">
<param name="Local" value="_safm_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SAFRead">
<param name="Local" value="_safread.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SAFReadWord">
<param name="Local" value="_safreadword.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SAFWrite">
<param name="Local" value="_safwrite.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SAFWriteWord">
<param name="Local" value="_safwriteword.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SAFReadBlock">
<param name="Local" value="_safreadblock.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SAFWriteBlock">
<param name="Local" value="_safwriteblock.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SAFEraseBlock">
<param name="Local" value="_saferaseblock.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="EERAM ( Device )">
<param name="Local" value="_eeram_device.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="47xxx EERam Devices">
<param name="Local" value="_47xxx_eeram_devices.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="SRAM ( Device )">
<param name="Local" value="_sram_device.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SRAM Overview">
<param name="Local" value="_sram_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SRAMRead">
<param name="Local" value="_sramread.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SRAMWrite">
<param name="Local" value="_sramwrite.html"></OBJECT></LI>
</UL></UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Flow control">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Do">
<param name="Local" value="_do.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="End">
<param name="Local" value="_end.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Exit">
<param name="Local" value="_exit.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="For">
<param name="Local" value="_for.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Gosub">
<param name="Local" value="_gosub.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Goto">
<param name="Local" value="_goto.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="If">
<param name="Local" value="_if.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="IndCall">
<param name="Local" value="_indcall.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Pause">
<param name="Local" value="_pause.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Repeat">
<param name="Local" value="_repeat.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Select">
<param name="Local" value="_select.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Wait">
<param name="Local" value="_wait.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Fixed Voltage Reference">
<param name="Local" value="_fixed_voltage_reference.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="FVRInitialize">
<param name="Local" value="_fvrinitialize.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="FVRIsOutputReady">
<param name="Local" value="_fvrisoutputready.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Interrupts">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Interrupts overview">
<param name="Local" value="_interrupts_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="IntOff">
<param name="Local" value="_intoff.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="IntOn">
<param name="Local" value="_inton.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="On Interrupt">
<param name="Local" value="_on_interrupt.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="On Interrupt: The default handler">
<param name="Local" value="_on_interrupt_the_default_handler.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Keypad">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Keypad Overview">
<param name="Local" value="_keypad_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="KeypadData">
<param name="Local" value="_keypaddata.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="KeypadRaw">
<param name="Local" value="_keypadraw.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Graphical LCD">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCD Overview">
<param name="Local" value="_glcd_overview.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Fonts and Characters">
<param name="Local" value="_fonts_and_characters.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="e-Paper Controllers">
<param name="Local" value="_e_paper_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HX8347G Controllers">
<param name="Local" value="_hx8347g_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ILI9326 Controllers">
<param name="Local" value="_ili9326_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ILI9340 Controllers">
<param name="Local" value="_ili9340_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ILI9341 Controllers">
<param name="Local" value="_ili9341_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ILI9481 Controllers">
<param name="Local" value="_ili9481_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ILI9486(L) Controllers">
<param name="Local" value="_ili9486_l_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ILI9488 Controllers">
<param name="Local" value="_ili9488_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="KS0108 Controllers">
<param name="Local" value="_ks0108_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="NEXTION Controllers">
<param name="Local" value="_nextion_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="NT7108C Controllers">
<param name="Local" value="_nt7108c_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PCD8544 Controllers">
<param name="Local" value="_pcd8544_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SDD1289 Controllers">
<param name="Local" value="_sdd1289_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SH1106 Controllers">
<param name="Local" value="_sh1106_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SSD1306 Controllers">
<param name="Local" value="_ssd1306_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SSD1331 Controllers">
<param name="Local" value="_ssd1331_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SSD1351 Controllers">
<param name="Local" value="_ssd1351_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7567 Controllers">
<param name="Local" value="_st7567_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7735 Controllers">
<param name="Local" value="_st7735_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7789 Controllers">
<param name="Local" value="_st7789_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920 Controllers">
<param name="Local" value="_st7920_controllers.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920GLCDClearGraphics">
<param name="Local" value="_st7920glcdcleargraphics.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920GLCDDisableGraphics">
<param name="Local" value="_st7920glcddisablegraphics.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920GLCDEnableGraphics">
<param name="Local" value="_st7920glcdenablegraphics.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920GraphicTest">
<param name="Local" value="_st7920graphictest.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920LineHs">
<param name="Local" value="_st7920linehs.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920Locate">
<param name="Local" value="_st7920locate.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920Tile">
<param name="Local" value="_st7920tile.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920cTile">
<param name="Local" value="_st7920ctile.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920gLocate">
<param name="Local" value="_st7920glocate.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920gTile">
<param name="Local" value="_st7920gtile.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920lineh">
<param name="Local" value="_st7920lineh.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920linev">
<param name="Local" value="_st7920linev.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920GLCDReadByte">
<param name="Local" value="_st7920glcdreadbyte.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920WriteByte">
<param name="Local" value="_st7920writebyte.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920WriteCommand">
<param name="Local" value="_st7920writecommand.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920WriteData">
<param name="Local" value="_st7920writedata.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ST7920gReaddata">
<param name="Local" value="_st7920greaddata.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="T6963 Controllers">
<param name="Local" value="_t6963_controllers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="UC1601 Controllers">
<param name="Local" value="_uc1601_controllers.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Box">
<param name="Local" value="_box.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Circle">
<param name="Local" value="_circle.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Ellipse">
<param name="Local" value="_ellipse.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="FilledBox">
<param name="Local" value="_filledbox.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="FilledCircle">
<param name="Local" value="_filledcircle.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="FilledEllipse">
<param name="Local" value="_filledellipse.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="FilledTriangle">
<param name="Local" value="_filledtriangle.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDCLS">
<param name="Local" value="_glcdcls.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDDisplay">
<param name="Local" value="_glcddisplay.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDDrawChar">
<param name="Local" value="_glcddrawchar.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDDrawString">
<param name="Local" value="_glcddrawstring.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDPrint">
<param name="Local" value="_glcdprint.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDPrintLargeFont">
<param name="Local" value="_glcdprintlargefont.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDPrintWithSize">
<param name="Local" value="_glcdprintwithsize.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDLocateString">
<param name="Local" value="_glcdlocatestring.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDPrintString">
<param name="Local" value="_glcdprintstring.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDPrintStringLn">
<param name="Local" value="_glcdprintstringln.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDRotate">
<param name="Local" value="_glcdrotate.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDReadByte">
<param name="Local" value="_glcdreadbyte.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDTimeDelay">
<param name="Local" value="_glcdtimedelay.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDTransaction">
<param name="Local" value="_glcdtransaction.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GLCDWriteByte">
<param name="Local" value="_glcdwritebyte.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Line">
<param name="Local" value="_line.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Hyperbole">
<param name="Local" value="_hyperbole.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Parabola">
<param name="Local" value="_parabola.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Pset">
<param name="Local" value="_pset.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Triangle">
<param name="Local" value="_triangle.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Touch Screen">
<param name="Local" value="_touch_screen.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ADS 7843 Serial Driver">
<param name="Local" value="_ads_7843_serial_driver.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Liquid Crystal Display">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD Overview">
<param name="Local" value="_lcd_overview.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 0">
<param name="Local" value="_lcd_io_0.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 1">
<param name="Local" value="_lcd_io_1.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 2_74xx164">
<param name="Local" value="_lcd_io_2_74xx164.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 2">
<param name="Local" value="_lcd_io_2.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 3">
<param name="Local" value="_lcd_io_3.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 2_74xx174">
<param name="Local" value="_lcd_io_2_74xx174.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 4">
<param name="Local" value="_lcd_io_4.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 8">
<param name="Local" value="_lcd_io_8.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 10">
<param name="Local" value="_lcd_io_10.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 10 Port Configuration">
<param name="Local" value="_lcd_io_10_port_configuration.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 12">
<param name="Local" value="_lcd_io_12.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 12 Port Configuration">
<param name="Local" value="_lcd_io_12_port_configuration.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 14">
<param name="Local" value="_lcd_io_14.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 14 Port Configuration">
<param name="Local" value="_lcd_io_14_port_configuration.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 107">
<param name="Local" value="_lcd_io_107.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_VARIANT">
<param name="Local" value="_lcd_variant.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_SPEED">
<param name="Local" value="_lcd_speed.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_WIDTH">
<param name="Local" value="_lcd_width.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="CLS">
<param name="Local" value="_cls.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Get">
<param name="Local" value="_get.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCDBacklight">
<param name="Local" value="_lcdbacklight.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCDCreateChar">
<param name="Local" value="_lcdcreatechar.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCDCreateGraph">
<param name="Local" value="_lcdcreategraph.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCDCmd">
<param name="Local" value="_lcdcmd.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCDCursor">
<param name="Local" value="_lcdcursor.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCDHex">
<param name="Local" value="_lcdhex.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCDHome">
<param name="Local" value="_lcdhome.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCDDisplayOn">
<param name="Local" value="_lcddisplayon.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCDDisplayOff">
<param name="Local" value="_lcddisplayoff.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCDSpace">
<param name="Local" value="_lcdspace.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCDWriteChar">
<param name="Local" value="_lcdwritechar.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Locate">
<param name="Local" value="_locate.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Print">
<param name="Local" value="_print.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Put">
<param name="Local" value="_put.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Examples">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 2 Example">
<param name="Local" value="_lcd_io_2_example.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 4 Example">
<param name="Local" value="_lcd_io_4_example.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 8 Example">
<param name="Local" value="_lcd_io_8_example.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCD_IO 10 Example">
<param name="Local" value="_lcd_io_10_example.html"></OBJECT></LI>
</UL></UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Pulse width modulation">
<param name="Local" value="_pulse_width_modulation.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Microchip PIC PWM Overview">
<param name="Local" value="_microchip_pic_pwm_overview.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PWM Software Mode">
<param name="Local" value="_pwm_software_mode.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PWMOut">
<param name="Local" value="_pwmout.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="HPWM CCP">
<param name="Local" value="_hpwm_ccp.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HPWMUpdate for CCP/PWM Modules(s)">
<param name="Local" value="_hpwmupdate_for_ccp_pwm_modules_s.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HPWMOff">
<param name="Local" value="_hpwmoff.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="HPWM_CCPTimerN">
<param name="Local" value="_hpwm_ccptimern.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HPWMOff">
<param name="Local" value="_hpwmoff_2.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="HPWM 10 Bit">
<param name="Local" value="_hpwm_10_bit.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HPWMUpdate for PWM Module(s)">
<param name="Local" value="_hpwmupdate_for_pwm_module_s.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HPWMOff">
<param name="Local" value="_hpwmoff_3.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="HPWM 16 Bit">
<param name="Local" value="_hpwm_16_bit.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HPWM Fixed Mode">
<param name="Local" value="_hpwm_fixed_mode.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PWMOn">
<param name="Local" value="_pwmon.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PWMOff">
<param name="Local" value="_pwmoff.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Hardware PWM Code Optimisation">
<param name="Local" value="_hardware_pwm_code_optimisation.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="ATMEL AVR PWM Overview">
<param name="Local" value="_atmel_avr_pwm_overview.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HPWM AVR OCRnx">
<param name="Local" value="_hpwm_avr_ocrnx.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HPWM Fixed Mode for AVR">
<param name="Local" value="_hpwm_fixed_mode_for_avr.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PWMOn for AVR">
<param name="Local" value="_pwmon_for_avr.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PWMOff for AVR">
<param name="Local" value="_pwmoff_for_avr.html"></OBJECT></LI>
</UL></UL></UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Random Numbers">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Overview">
<param name="Local" value="_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Random">
<param name="Local" value="_random.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Randomize">
<param name="Local" value="_randomize.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="7-Segment Displays">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="7 Segment Displays Overview">
<param name="Local" value="_7_segment_displays_overview.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="7 Segment Displays - Legacy">
<param name="Local" value="_7_segment_displays_legacy.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Common Cathode">
<param name="Local" value="_common_cathode.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Common Anode">
<param name="Local" value="_common_anode.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="DisplayValue">
<param name="Local" value="_displayvalue.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="DisplayChar">
<param name="Local" value="_displaychar.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="DisplaySegment">
<param name="Local" value="_displaysegment.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="7 Segment Displays - TM1637 4 Digits">
<param name="Local" value="_7_segment_displays_tm1637_4_digits.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="TMWrite4Dig">
<param name="Local" value="_tmwrite4dig.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="TM_Bright">
<param name="Local" value="_tm_bright.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="TMDec">
<param name="Local" value="_tmdec.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="TMHex">
<param name="Local" value="_tmhex.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="TMWriteChar">
<param name="Local" value="_tmwritechar.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="7 Segment Displays - TM1637 6 Digits">
<param name="Local" value="_7_segment_displays_tm1637_6_digits.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="TMWrite6Dig">
<param name="Local" value="_tmwrite6dig.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="TM_Bright">
<param name="Local" value="_tm_bright_2.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="TMDec">
<param name="Local" value="_tmdec_2.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="TMHex">
<param name="Local" value="_tmhex_2.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="TMWriteChar">
<param name="Local" value="_tmwritechar_2.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="TM_Point">
<param name="Local" value="_tm_point.html"></OBJECT></LI>
</UL></UL></UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="One Wire Devices">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="DS18B20">
<param name="Local" value="_ds18b20.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ReadDigitalTemp">
<param name="Local" value="_readdigitaltemp.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ReadTemp">
<param name="Local" value="_readtemp.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ReadTemp12">
<param name="Local" value="_readtemp12.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="DS18B20SetResolution">
<param name="Local" value="_ds18b20setresolution.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Serial Communications">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="RS232 (software)">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="RS232 Software Overview">
<param name="Local" value="_rs232_software_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InitSer">
<param name="Local" value="_initser.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SerSend">
<param name="Local" value="_sersend.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SerReceive">
<param name="Local" value="_serreceive.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SerPrint">
<param name="Local" value="_serprint.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="RS232 (software optimised)">
<param name="Local" value="_rs232_software_optimised.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="RS232 Software Overview - Optimised">
<param name="Local" value="_rs232_software_overview_optimised.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SerNSend">
<param name="Local" value="_sernsend.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SerNPrint">
<param name="Local" value="_sernprint.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SerNReceive">
<param name="Local" value="_sernreceive.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="RS232 (hardware)">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="RS232 Hardware Overview">
<param name="Local" value="_rs232_hardware_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HSerGetNum">
<param name="Local" value="_hsergetnum.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HSerGetString">
<param name="Local" value="_hsergetstring.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HSerPrint">
<param name="Local" value="_hserprint.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HSerPrintStringCRLF">
<param name="Local" value="_hserprintstringcrlf.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HSerReceive">
<param name="Local" value="_hserreceive.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HSerReceiveFrom">
<param name="Local" value="_hserreceivefrom.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HSerSend">
<param name="Local" value="_hsersend.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HserPrintByteCRLF">
<param name="Local" value="_hserprintbytecrlf.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HserPrintCRLF">
<param name="Local" value="_hserprintcrlf.html"></OBJECT></LI>
</UL></UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="PS/2">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PS/2 Overview">
<param name="Local" value="_ps_2_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InKey">
<param name="Local" value="_inkey.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PS2SetKBLeds">
<param name="Local" value="_ps2setkbleds.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PS2ReadByte">
<param name="Local" value="_ps2readbyte.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PS2WriteByte">
<param name="Local" value="_ps2writebyte.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="SPI">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SPI Overview">
<param name="Local" value="_spi_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SPIMode">
<param name="Local" value="_spimode.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SPITransfer">
<param name="Local" value="_spitransfer.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="FastHWSPITransfer">
<param name="Local" value="_fasthwspitransfer.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="I2C Software">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="I2C Overview">
<param name="Local" value="_i2c_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="I2CAckPollState">
<param name="Local" value="_i2cackpollstate.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="I2CAckpoll">
<param name="Local" value="_i2cackpoll.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="I2CReceive">
<param name="Local" value="_i2creceive.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="I2CReset">
<param name="Local" value="_i2creset.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="I2CRestart">
<param name="Local" value="_i2crestart.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="I2CSend">
<param name="Local" value="_i2csend.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="I2CStart">
<param name="Local" value="_i2cstart.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="I2CStartoccurred">
<param name="Local" value="_i2cstartoccurred.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="I2CStop">
<param name="Local" value="_i2cstop.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="I2C/TWI Hardware Module">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HI2C Overview">
<param name="Local" value="_hi2c_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HI2CAckPollState">
<param name="Local" value="_hi2cackpollstate.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HI2CReceive">
<param name="Local" value="_hi2creceive.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HI2CRestart">
<param name="Local" value="_hi2crestart.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HI2CStart">
<param name="Local" value="_hi2cstart.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HI2CStartOccurred">
<param name="Local" value="_hi2cstartoccurred.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HI2CMode">
<param name="Local" value="_hi2cmode.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HI2CSetAddress">
<param name="Local" value="_hi2csetaddress.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HI2CStop">
<param name="Local" value="_hi2cstop.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HI2CStopped">
<param name="Local" value="_hi2cstopped.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="HI2CWaitMSSP">
<param name="Local" value="_hi2cwaitmssp.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Sound">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Sound Overview">
<param name="Local" value="_sound_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Tone">
<param name="Local" value="_tone.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ShortTone">
<param name="Local" value="_shorttone.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Play">
<param name="Local" value="_play.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Play RTTTL">
<param name="Local" value="_play_rtttl.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Timers">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Timer Overview">
<param name="Local" value="_timer_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ClearTimer">
<param name="Local" value="_cleartimer.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InitTimer0">
<param name="Local" value="_inittimer0.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InitTimer0 8bit/16bit">
<param name="Local" value="_inittimer0_8bit_16bit.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="InitTimer1">
<param name="Local" value="_inittimer1.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InitTimer2">
<param name="Local" value="_inittimer2.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InitTimer3">
<param name="Local" value="_inittimer3.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InitTimer4">
<param name="Local" value="_inittimer4.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InitTimer5">
<param name="Local" value="_inittimer5.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InitTimer6">
<param name="Local" value="_inittimer6.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InitTimer7">
<param name="Local" value="_inittimer7.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InitTimer8">
<param name="Local" value="_inittimer8.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InitTimer10">
<param name="Local" value="_inittimer10.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InitTimer12">
<param name="Local" value="_inittimer12.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Settimer">
<param name="Local" value="_settimer.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="StartTimer">
<param name="Local" value="_starttimer.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="StopTimer">
<param name="Local" value="_stoptimer.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Reading Timers">
<param name="Local" value="_reading_timers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SMT Timers">
<param name="Local" value="_smt_timers.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Variables Operations">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Using Variables">
<param name="Local" value="_using_variables.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="More on setting Variables and Constants">
<param name="Local" value="_more_on_setting_variables_and_constants.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Setting Variables">
<param name="Local" value="_setting_variables.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Variable Lifecycle">
<param name="Local" value="_variable_lifecycle.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Dim">
<param name="Local" value="_dim.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Alloc">
<param name="Local" value="_alloc.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="BcdToDec_GCB">
<param name="Local" value="_bcdtodec_gcb.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="DecToBcd_GCB">
<param name="Local" value="_dectobcd_gcb.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Rotate">
<param name="Local" value="_rotate.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Set">
<param name="Local" value="_set.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SWAP4">
<param name="Local" value="_swap4.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SWAP">
<param name="Local" value="_swap.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="String Manipulation">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Asc">
<param name="Local" value="_asc.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="ByteToBin">
<param name="Local" value="_bytetobin.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Chr">
<param name="Local" value="_chr.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Fill">
<param name="Local" value="_fill.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Hex">
<param name="Local" value="_hex.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Instr">
<param name="Local" value="_instr.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LCase">
<param name="Local" value="_lcase.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Left">
<param name="Local" value="_left.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LeftPad">
<param name="Local" value="_leftpad.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Len">
<param name="Local" value="_len.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Ltrim">
<param name="Local" value="_ltrim.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Mid">
<param name="Local" value="_mid.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Pad">
<param name="Local" value="_pad.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Right">
<param name="Local" value="_right.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Rtrim">
<param name="Local" value="_rtrim.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Str">
<param name="Local" value="_str.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Trim">
<param name="Local" value="_trim.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="UCase">
<param name="Local" value="_ucase.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Val">
<param name="Local" value="_val.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="IntegerToBin">
<param name="Local" value="_integertobin.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LongToBin">
<param name="Local" value="_longtobin.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="WordToBin">
<param name="Local" value="_wordtobin.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Concatenation">
<param name="Local" value="_concatenation.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Miscellaneous Commands">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Dir">
<param name="Local" value="_dir.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GetUserID">
<param name="Local" value="_getuserid.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Pot">
<param name="Local" value="_pot.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PulseOut">
<param name="Local" value="_pulseout.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PulseOutInv">
<param name="Local" value="_pulseoutinv.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PulseIn">
<param name="Local" value="_pulsein.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="PulseInInv">
<param name="Local" value="_pulseininv.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Peek">
<param name="Local" value="_peek.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Poke">
<param name="Local" value="_poke.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Weak Pullups">
<param name="Local" value="_weak_pullups.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Maths">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Abs">
<param name="Local" value="_abs.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Average">
<param name="Local" value="_average.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Difference">
<param name="Local" value="_difference.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Logarithms">
<param name="Local" value="_logarithms.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Log2">
<param name="Local" value="_log2.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Loge">
<param name="Local" value="_loge.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Log10">
<param name="Local" value="_log10.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Power">
<param name="Local" value="_power.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Scale">
<param name="Local" value="_scale.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Sqrt">
<param name="Local" value="_sqrt.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Trigonometry Sine, Cosine and Tangent">
<param name="Local" value="_trigonometry_sine_cosine_and_tangent.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Trigonometry ATAN">
<param name="Local" value="_trigonometry_atan.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Peripheral Pin Select">
<param name="Local" value="_peripheral_pin_select.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Peripheral Pin Select for Microchip microcontrollers.">
<param name="Local" value="_peripheral_pin_select_for_microchip_microcontrollers.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="UnLockPPS">
<param name="Local" value="_unlockpps.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="LockPPS">
<param name="Local" value="_lockpps.html"></OBJECT></LI>
</UL></UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Compiler Directives">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#asmraw">
<param name="Local" value="__asmraw.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#chip">
<param name="Local" value="__chip.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#config">
<param name="Local" value="__config.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#DEFINE">
<param name="Local" value="__define.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#UNDEFINE">
<param name="Local" value="__undefine.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#if">
<param name="Local" value="__if.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#ifnot">
<param name="Local" value="__ifnot.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#ifdef">
<param name="Local" value="__ifdef.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#ifndef">
<param name="Local" value="__ifndef.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#include">
<param name="Local" value="__include.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#insert">
<param name="Local" value="__insert.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#script">
<param name="Local" value="__script.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#startup">
<param name="Local" value="__startup.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#mem">
<param name="Local" value="__mem.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Other directives">
<param name="Local" value="_other_directives.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Compiler Options">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#Option Explicit">
<param name="Local" value="__option_explicit.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#Option NoConfig">
<param name="Local" value="__option_noconfig.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#Option Bootloader">
<param name="Local" value="__option_bootloader.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#Option NoContextSave">
<param name="Local" value="__option_nocontextsave.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#Option NoLatch">
<param name="Local" value="__option_nolatch.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#Option Required">
<param name="Local" value="__option_required.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#Option Volatile">
<param name="Local" value="__option_volatile.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="#Option ReserveHighProg">
<param name="Local" value="__option_reservehighprog.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Using Assembler">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Assembler Overview">
<param name="Local" value="_assembler_overview.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Macros">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Macros Overview">
<param name="Local" value="_macros_overview.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Example Macros">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Measuring a Pulse Width">
<param name="Local" value="_measuring_a_pulse_width.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Implementing a method with a Pin name as a parameter">
<param name="Local" value="_implementing_a_method_with_a_pin_name_as_a_parameter.html"></OBJECT></LI>
</UL></UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Example Programs">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Flashing LEDs and an Interrupt">
<param name="Local" value="_flashing_leds_and_an_interrupt.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Flashing LED with timing parameters">
<param name="Local" value="_flashing_led_with_timing_parameters.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Generate Accurate Pulses">
<param name="Local" value="_generate_accurate_pulses.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Graphical LCD Demonstration">
<param name="Local" value="_graphical_lcd_demonstration.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="InfraRed Remote">
<param name="Local" value="_infrared_remote.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="SonyRemote.h">
<param name="Local" value="_sonyremote_h.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Midpoint Circle Algorithm">
<param name="Local" value="_midpoint_circle_algorithm.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="I2C Master Hardware">
<param name="Local" value="_i2c_master_hardware.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="I2C Slave Hardware">
<param name="Local" value="_i2c_slave_hardware.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="RGB LED Control">
<param name="Local" value="_rgb_led_control.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Serial/RS232 Buffer Ring">
<param name="Local" value="_serial_rs232_buffer_ring.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Trigonometry Circle">
<param name="Local" value="_trigonometry_circle.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="Graphical GCBASIC">
<param name="Local" value="_graphical_gcbasic.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Code Documentation">
<param name="Local" value="_code_documentation.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Windows .NET Support">
<param name="Local" value="_windows_net_support.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="GCBASIC for Linux">
</OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Overview - Linux Operating System">
<param name="Local" value="_overview_linux_operating_system.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Make ASM, Make HEX and Programming Operations using the provided Linux scripts">
<param name="Local" value="_make_asm_make_hex_and_programming_operations_using_the_provided_linux_scripts.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="GCBASIC for ARM &amp; Pi">
<param name="Local" value="_gcbasic_for_arm_pi.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Overview - Raspberry Pi">
<param name="Local" value="_overview_raspberry_pi.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="GCBASIC for Apple macOS">
<param name="Local" value="_gcbasic_for_apple_macos.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Overview - Apple macOS GCBASIC">
<param name="Local" value="_overview_apple_macos_gcbasic.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="GCBASIC for FreeBSD">
<param name="Local" value="_gcbasic_for_freebsd.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Overview - FreeBSD GCBASIC">
<param name="Local" value="_overview_freebsd_gcbasic.html"></OBJECT></LI>
</UL><LI><OBJECT type="text/sitemap">
<param name="Name" value="GCBASIC Maintenance and Development">
<param name="Local" value="_gcbasic_maintenance_and_development.html"></OBJECT></LI>
<UL>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="GCBASIC Maintenance">
<param name="Local" value="_gcbasic_maintenance.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Development Guide">
<param name="Local" value="_development_guide.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Development Guide for GCBASIC.EXE compiler">
<param name="Local" value="_development_guide_for_gcbasic_exe_compiler.html"></OBJECT></LI>
<LI><OBJECT type="text/sitemap">
<param name="Name" value="Development Guide for GCBASIC Preferences Editor">
<param name="Local" value="_development_guide_for_gcbasic_preferences_editor.html"></OBJECT></LI>
</UL></UL></BODY></HTML>[OPTIONS]
Binary TOC=Yes
Compatibility=1.1 or later
Compiled file=gcbasic.chm
Contents file=gcbasic.hhc
Default Window=Main
Default topic=_introducing_gcbasic.html
Display compile progress=Yes
Full-text search=Yes
Language=0x0409 English (UNITED STATES)
Title=GCBASIC Help
Enhanced decompilation=No

[WINDOWS]
Main="GCBASIC Help","gcbasic.hhc",,"_introducing_gcbasic.html","_introducing_gcbasic.html",,,,,0x42520,,0x603006,,,,,,,,0


[FILES]
index.html
_introducing_gcbasic.html
_using_gcbasic.html
_pic_users_and_beginners_start_here.html
_changes.html
_command_line_parameters.html
_frequent_errors.html
_a_glossary.html
_frequently_asked_questions.html
_troubleshooting.html
_compiler_insights.html
_libraries_overview.html
_acknowledgements.html
_tricks_and_tips.html
_uno_as_isp_programmer.html
_microcontroller_fundamentals.html
_inputs_outputs.html
_configuration.html
_data_types.html
_variable_types.html
_variable_advanced_types.html
_variable_memory_allocation.html
_usb_drivers_installer.html
_syntax.html
_arrays.html
_comments.html
_line_continuation.html
_conditions.html
_constants.html
_functions.html
_labels.html
_lookup_tables.html
_miscellaneous.html
_readtable.html
_scripts.html
_subroutines.html
_converters.html
_command_references.html
_analog_digital_conversion.html
_analog_digital_conversion_overview.html
_adformat_deprecated_do_not_use.html
_adoff.html
_readad.html
_readad10.html
_readad12.html
_analog_digital_conversion_code_optimisation.html
_bitwise.html
_bitwise_operations_overview.html
_fnlsl.html
_fnlsr.html
_setwith.html
_memory.html
_mcu_eeprom_dfm.html
_epread.html
_epwrite.html
_dataset_for_eeprom.html
_hefm_pfm.html
_hefm_overview.html
_hefread.html
_hefreadword.html
_hefwrite.html
_hefwriteword.html
_hefreadblock.html
_hefwriteblock.html
_heferaseblock.html
_progmem_pfm.html
_pfmread.html
_pfmwrite.html
_programerase.html
_programread.html
_programwrite.html
_progmem_mcu_configuration.html
_deviceconfigurationread.html
_safm.html
_safm_overview.html
_safread.html
_safreadword.html
_safwrite.html
_safwriteword.html
_safreadblock.html
_safwriteblock.html
_saferaseblock.html
_eeram_device.html
_47xxx_eeram_devices.html
_sram_device.html
_sram_overview.html
_sramread.html
_sramwrite.html
_flow_control.html
_do.html
_end.html
_exit.html
_for.html
_gosub.html
_goto.html
_if.html
_indcall.html
_pause.html
_repeat.html
_select.html
_wait.html
_fixed_voltage_reference.html
_fvrinitialize.html
_fvrisoutputready.html
_interrupts.html
_interrupts_overview.html
_intoff.html
_inton.html
_on_interrupt.html
_on_interrupt_the_default_handler.html
_keypad.html
_keypad_overview.html
_keypaddata.html
_keypadraw.html
_graphical_lcd.html
_glcd_overview.html
_fonts_and_characters.html
_e_paper_controllers.html
_hx8347g_controllers.html
_ili9326_controllers.html
_ili9340_controllers.html
_ili9341_controllers.html
_ili9481_controllers.html
_ili9486_l_controllers.html
_ili9488_controllers.html
_ks0108_controllers.html
_nextion_controllers.html
_nt7108c_controllers.html
_pcd8544_controllers.html
_sdd1289_controllers.html
_sh1106_controllers.html
_ssd1306_controllers.html
_ssd1331_controllers.html
_ssd1351_controllers.html
_st7567_controllers.html
_st7735_controllers.html
_st7789_controllers.html
_st7920_controllers.html
_st7920glcdcleargraphics.html
_st7920glcddisablegraphics.html
_st7920glcdenablegraphics.html
_st7920graphictest.html
_st7920linehs.html
_st7920locate.html
_st7920tile.html
_st7920ctile.html
_st7920glocate.html
_st7920gtile.html
_st7920lineh.html
_st7920linev.html
_st7920glcdreadbyte.html
_st7920writebyte.html
_st7920writecommand.html
_st7920writedata.html
_st7920greaddata.html
_t6963_controllers.html
_uc1601_controllers.html
_box.html
_circle.html
_ellipse.html
_filledbox.html
_filledcircle.html
_filledellipse.html
_filledtriangle.html
_glcdcls.html
_glcddisplay.html
_glcddrawchar.html
_glcddrawstring.html
_glcdprint.html
_glcdprintlargefont.html
_glcdprintwithsize.html
_glcdlocatestring.html
_glcdprintstring.html
_glcdprintstringln.html
_glcdrotate.html
_glcdreadbyte.html
_glcdtimedelay.html
_glcdtransaction.html
_glcdwritebyte.html
_line.html
_hyperbole.html
_parabola.html
_pset.html
_triangle.html
_touch_screen.html
_ads_7843_serial_driver.html
_liquid_crystal_display.html
_lcd_overview.html
_lcd_io_0.html
_lcd_io_1.html
_lcd_io_2_74xx164.html
_lcd_io_2.html
_lcd_io_3.html
_lcd_io_2_74xx174.html
_lcd_io_4.html
_lcd_io_8.html
_lcd_io_10.html
_lcd_io_10_port_configuration.html
_lcd_io_12.html
_lcd_io_12_port_configuration.html
_lcd_io_14.html
_lcd_io_14_port_configuration.html
_lcd_io_107.html
_lcd_variant.html
_lcd_speed.html
_lcd_width.html
_cls.html
_get.html
_lcdbacklight.html
_lcdcreatechar.html
_lcdcreategraph.html
_lcdcmd.html
_lcdcursor.html
_lcdhex.html
_lcdhome.html
_lcddisplayon.html
_lcddisplayoff.html
_lcdspace.html
_lcdwritechar.html
_locate.html
_print.html
_put.html
_examples.html
_lcd_io_2_example.html
_lcd_io_4_example.html
_lcd_io_8_example.html
_lcd_io_10_example.html
_pulse_width_modulation.html
_microchip_pic_pwm_overview.html
_pwm_software_mode.html
_pwmout.html
_hpwm_ccp.html
_hpwmupdate_for_ccp_pwm_modules_s.html
_hpwmoff.html
_hpwm_ccptimern.html
_hpwmoff_2.html
_hpwm_10_bit.html
_hpwmupdate_for_pwm_module_s.html
_hpwmoff_3.html
_hpwm_16_bit.html
_hpwm_fixed_mode.html
_pwmon.html
_pwmoff.html
_hardware_pwm_code_optimisation.html
_atmel_avr_pwm_overview.html
_hpwm_avr_ocrnx.html
_hpwm_fixed_mode_for_avr.html
_pwmon_for_avr.html
_pwmoff_for_avr.html
_random_numbers.html
_overview.html
_random.html
_randomize.html
_7_segment_displays.html
_7_segment_displays_overview.html
_7_segment_displays_legacy.html
_common_cathode.html
_common_anode.html
_displayvalue.html
_displaychar.html
_displaysegment.html
_7_segment_displays_tm1637_4_digits.html
_tmwrite4dig.html
_tm_bright.html
_tmdec.html
_tmhex.html
_tmwritechar.html
_7_segment_displays_tm1637_6_digits.html
_tmwrite6dig.html
_tm_bright_2.html
_tmdec_2.html
_tmhex_2.html
_tmwritechar_2.html
_tm_point.html
_one_wire_devices.html
_ds18b20.html
_readdigitaltemp.html
_readtemp.html
_readtemp12.html
_ds18b20setresolution.html
_serial_communications.html
_rs232_software.html
_rs232_software_overview.html
_initser.html
_sersend.html
_serreceive.html
_serprint.html
_rs232_software_optimised.html
_rs232_software_overview_optimised.html
_sernsend.html
_sernprint.html
_sernreceive.html
_rs232_hardware.html
_rs232_hardware_overview.html
_hsergetnum.html
_hsergetstring.html
_hserprint.html
_hserprintstringcrlf.html
_hserreceive.html
_hserreceivefrom.html
_hsersend.html
_hserprintbytecrlf.html
_hserprintcrlf.html
_ps_2.html
_ps_2_overview.html
_inkey.html
_ps2setkbleds.html
_ps2readbyte.html
_ps2writebyte.html
_spi.html
_spi_overview.html
_spimode.html
_spitransfer.html
_fasthwspitransfer.html
_i2c_software.html
_i2c_overview.html
_i2cackpollstate.html
_i2cackpoll.html
_i2creceive.html
_i2creset.html
_i2crestart.html
_i2csend.html
_i2cstart.html
_i2cstartoccurred.html
_i2cstop.html
_i2c_twi_hardware_module.html
_hi2c_overview.html
_hi2cackpollstate.html
_hi2creceive.html
_hi2crestart.html
_hi2cstart.html
_hi2cstartoccurred.html
_hi2cmode.html
_hi2csetaddress.html
_hi2cstop.html
_hi2cstopped.html
_hi2cwaitmssp.html
_sound.html
_sound_overview.html
_tone.html
_shorttone.html
_play.html
_play_rtttl.html
_timers.html
_timer_overview.html
_cleartimer.html
_inittimer0.html
_inittimer0_8bit_16bit.html
_inittimer1.html
_inittimer2.html
_inittimer3.html
_inittimer4.html
_inittimer5.html
_inittimer6.html
_inittimer7.html
_inittimer8.html
_inittimer10.html
_inittimer12.html
_settimer.html
_starttimer.html
_stoptimer.html
_reading_timers.html
_smt_timers.html
_variables_operations.html
_using_variables.html
_more_on_setting_variables_and_constants.html
_setting_variables.html
_variable_lifecycle.html
_dim.html
_alloc.html
_bcdtodec_gcb.html
_dectobcd_gcb.html
_rotate.html
_set.html
_swap4.html
_swap.html
_string_manipulation.html
_asc.html
_bytetobin.html
_chr.html
_fill.html
_hex.html
_instr.html
_lcase.html
_left.html
_leftpad.html
_len.html
_ltrim.html
_mid.html
_pad.html
_right.html
_rtrim.html
_str.html
_trim.html
_ucase.html
_val.html
_integertobin.html
_longtobin.html
_wordtobin.html
_concatenation.html
_miscellaneous_commands.html
_dir.html
_getuserid.html
_pot.html
_pulseout.html
_pulseoutinv.html
_pulsein.html
_pulseininv.html
_peek.html
_poke.html
_weak_pullups.html
_maths.html
_abs.html
_average.html
_difference.html
_logarithms.html
_log2.html
_loge.html
_log10.html
_power.html
_scale.html
_sqrt.html
_trigonometry_sine_cosine_and_tangent.html
_trigonometry_atan.html
_peripheral_pin_select.html
_peripheral_pin_select_for_microchip_microcontrollers.html
_unlockpps.html
_lockpps.html
_compiler_directives.html
__asmraw.html
__chip.html
__config.html
__define.html
__undefine.html
__if.html
__ifnot.html
__ifdef.html
__ifndef.html
__include.html
__insert.html
__script.html
__startup.html
__mem.html
_other_directives.html
_compiler_options.html
__option_explicit.html
__option_noconfig.html
__option_bootloader.html
__option_nocontextsave.html
__option_nolatch.html
__option_required.html
__option_volatile.html
__option_reservehighprog.html
_using_assembler.html
_assembler_overview.html
_macros.html
_macros_overview.html
_example_macros.html
_measuring_a_pulse_width.html
_implementing_a_method_with_a_pin_name_as_a_parameter.html
_example_programs.html
_flashing_leds_and_an_interrupt.html
_flashing_led_with_timing_parameters.html
_generate_accurate_pulses.html
_graphical_lcd_demonstration.html
_infrared_remote.html
_sonyremote_h.html
_midpoint_circle_algorithm.html
_i2c_master_hardware.html
_i2c_slave_hardware.html
_rgb_led_control.html
_serial_rs232_buffer_ring.html
_trigonometry_circle.html
_graphical_gcbasic.html
_code_documentation.html
_windows_net_support.html
_gcbasic_for_linux.html
_overview_linux_operating_system.html
_make_asm_make_hex_and_programming_operations_using_the_provided_linux_scripts.html
_gcbasic_for_arm_pi.html
_overview_raspberry_pi.html
_gcbasic_for_apple_macos.html
_overview_apple_macos_gcbasic.html
_gcbasic_for_freebsd.html
_overview_freebsd_gcbasic.html
_gcbasic_maintenance_and_development.html
_gcbasic_maintenance.html
_development_guide.html
_development_guide_for_gcbasic_exe_compiler.html
_development_guide_for_gcbasic_preferences_editor.html
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GCBASIC for Apple macOS</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_overview_raspberry_pi.html" title="Overview - Raspberry Pi"><link rel="next" href="_overview_apple_macos_gcbasic.html" title="Overview - Apple macOS GCBASIC"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_gcbasic_for_apple_macos"></a>GCBASIC for Apple macOS</h2></div></div></div><p>This is the GCBASIC for Apple macOS section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="gcbasic_for_apple_macos"></span>GCBASIC for Apple macOS
------------------------------------------------------------------

</div>

</div>

</div>

This is the GCBASIC for Apple macOS section of the Help file. Please
refer the sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GCBASIC for ARM &amp; Pi</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_make_asm_make_hex_and_programming_operations_using_the_provided_linux_scripts.html" title="Make ASM, Make HEX and Programming Operations using the provided Linux scripts"><link rel="next" href="_overview_raspberry_pi.html" title="Overview - Raspberry Pi"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_gcbasic_for_arm_pi"></a>GCBASIC for ARM &amp; Pi</h2></div></div></div><p>This is the GCBASIC for Pi section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="gcbasic_for_arm_pi"></span>GCBASIC for ARM & Pi
----------------------------------------------------------

</div>

</div>

</div>

This is the GCBASIC for Pi section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GCBASIC for FreeBSD</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_overview_apple_macos_gcbasic.html" title="Overview - Apple macOS GCBASIC"><link rel="next" href="_overview_freebsd_gcbasic.html" title="Overview - FreeBSD GCBASIC"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_gcbasic_for_freebsd"></a>GCBASIC for FreeBSD</h2></div></div></div><p>This is the GCBASIC for FreeBSD OS section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="gcbasic_for_freebsd"></span>GCBASIC for FreeBSD
----------------------------------------------------------

</div>

</div>

</div>

This is the GCBASIC for FreeBSD OS section of the Help file. Please
refer the sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GCBASIC for Linux</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_windows_net_support.html" title="Windows .NET Support"><link rel="next" href="_overview_linux_operating_system.html" title="Overview - Linux Operating System"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_gcbasic_for_linux"></a>GCBASIC for Linux</h2></div></div></div><p>This is the GCBASIC for Linux section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="gcbasic_for_linux"></span>GCBASIC for Linux
------------------------------------------------------

</div>

</div>

</div>

This is the GCBASIC for Linux section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GCBASIC Maintenance</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_gcbasic_maintenance_and_development.html" title="GCBASIC Maintenance and Development"><link rel="prev" href="_gcbasic_maintenance_and_development.html" title="GCBASIC Maintenance and Development"><link rel="next" href="_development_guide.html" title="Development Guide"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_gcbasic_maintenance"></a>GCBASIC Maintenance</h3></div></div></div><p><span class="strong"><strong>Introduction:</strong></span>
GCBASIC maintenance covers the key processes that the developers use to maintain and build the solution.</p><p>These insights are not distribution specific.</p><p><span class="strong"><strong>Solution Architecture:</strong></span>
These components are key for a complete solution:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">GCBASIC installer</li><li class="listitem">GCBASIC chip specific .DAT files</li><li class="listitem">GCBASIC Help</li><li class="listitem">GCBASIC IDE</li></ol></div><p><br>
<br>
<span class="strong"><strong>GCBASIC installers:</strong></span>
<br>
<br>
The Windows GCBASIC installer uses the <span class="emphasis"><em>InnoSoft</em></span> installer with packaging completed using R2Build.<br></p><p>The process uses a Gold build structure.  The R2Build software creates four packages for Windows and one package for the Linux distribution.  The process is automated with automatic versioning and configuration.</p><p>The macOS GCBASIC installer uses the <span class="emphasis"><em>Packages</em></span> installer (<a class="link" href="http://s.sudre.free.fr/Software/Packages/about.html" target="_top">http://s.sudre.free.fr/Software/Packages/about.html</a>) with packaging completed using the Bourne shell script <code class="literal">pkg2dmg.sh</code> to create a compressed disk image file containing the installer.</p><p><br>
<br>
<span class="strong"><strong>GCBASIC chip specific .DAT files:</strong></span>
<br>
<br>
What are the .DAT files?</p><p>The DAT files are the GCBASIC representation of the capabilities of a specific microcontroller.&nbsp;&nbsp;The DAT is based upon a number of vendor sources and corrections/omissions added by the GCBASIC development team.&nbsp;&nbsp;The DAT file is exposed to the user program as a set of registers and register bits that can used to configure the program in terms of the microcontroller specifics.
<br>
<br></p><p>The process to create the .DAT file for microcontrollers is as follows:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Step</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>1</p></td><td align="left" valign="top"><p>Obtain the MPASM *.INC or the AVR *.XML files to be used. These files determine the scope of registers and register bits.</p></td></tr><tr><td align="left" valign="top"><p>2</p></td><td align="left" valign="top"><p>For Microchip only.  Place the source INC files in the ..DAT\incfiles\OrgFiles.
</p><p>Process the file using 'Preprocess.bat'. &nbsp;&nbsp; This is an AWK text processor - you will need AWK.EXE in the executing folder.
</p><p>This preprocessing will examine all the INC files in the ..DAT\incfiles\OrgFiles folder.&nbsp;&nbsp;The resulting files will be placed in the ..DAT\incfiles folder.&nbsp;&nbsp;The resulting files will have the 'BITS' section sorted in port priority - this priority ensures the bits are assigned in the target DAT in the same order every time.</p></td></tr><tr><td align="left" valign="top"><p>3</p></td><td align="left" valign="top"><p>Update the database of support microcontrollers.&nbsp;&nbsp;This database contains the microcontroller configuration that GCBASIC requires as the core information for the DAT files.
</p><p>The database is called <code class="literal">chipdata.csv</code> or <code class="literal">avr_chipdata.csv</code> for Microchip and AVR respectively.
- These files are comma delimited.&nbsp;&nbsp;The first row of data specifies the field name - these field names control the chip conversion program, see later notes.&nbsp;&nbsp;
</p><p>The database fields are controlled by the GCBASIC development team and the specification of the database may change between releases to support new capabilities.
</p><p>Database fields will have the suffix of <code class="literal">Variant</code> such as PWMTimerVariant and SMTClockSourceVariant and are microcontroller specific configuration settings to support the various microcontroller settings.&nbsp;&nbsp;The values of these <code class="literal">variants</code> are determined by the examination of the microcontroller datasheets as this information is NOT specified in the source files.&nbsp;&nbsp;Variants are exposed in the user program with the prefix of Chip.&nbsp;&nbsp;If the variant is called <code class="literal">PWMTimerVariant</code> a constant called <code class="literal">ChipPWMTimerVariant</code> will be exposed in the user program.</p></td></tr><tr><td align="left" valign="top"><p>4</p></td><td align="left" valign="top"><p>Update the <code class="literal">CriticalChanges.txt</code> file, if required.&nbsp;&nbsp;The <code class="literal">CriticalChanges.txt</code> file contains changes to the INC file during processing that are corrections or additions to the source files.
</p><p>The format of each line is the <code class="literal">filename</code> , <code class="literal">Append (new line) or Replace</code>, <code class="literal">find</code>, <code class="literal">replace</code>.
</p><p>Each line is comma delimited and spaces are NOT critical.  &nbsp;&nbsp;Essentially, the processing with find a partial line and replace or append the whole line.
</p><p>example:  p16lf1615.inc,R,OSCFIE          EQU  H'0007',OSFIE           EQU  H'0007'&nbsp;&nbsp;&nbsp;&nbsp;
- so, when processing p16lf1615.inc find the line OSCFIE          EQU  H'0007' and replace with OSFIE           EQU  H'0007'.</p></td></tr><tr><td align="left" valign="top"><p>5</p></td><td align="left" valign="top"><p>If required.  &nbsp;&nbsp;This is not normally edited. &nbsp;&nbsp; Update the <code class="literal">18FDefaultASMConfig.txt</code> to set the 18f configuration defaults.</p></td></tr><tr><td align="left" valign="top"><p>6</p></td><td align="left" valign="top"><p>Maintain the conversion program.&nbsp;&nbsp;The conversion program may require maintenance. &nbsp;&nbsp;The programs are written in FreeBASIC and therefore require compilation.
</p><p>An example of maintenance is a new variant field is required.&nbsp;&nbsp;The source program will need to be updated to support the new variant - simply edit the source, compile and publish.&nbsp;&nbsp;Another example is the addition of a new Interrupt - follow the same process to edit, compile and publish.</p></td></tr><tr><td align="left" valign="top"><p>7</p></td><td align="left" valign="top"><p>Execute the program to convert the source files to the DAT files for Microchip or AVR.&nbsp;&nbsp;There are two programs for each architecture.
</p><p>Executing the conversion program without a parameter will process ALL the entries in the database (the csv file), passing a single parameter to the conversion program will only convert the single microcontroller.
</p><p>The conversion program will process as follows:
</p><p>a) Read the database for the chip specifics
</p><p>b) If a .DEV file or .INFO file is not present a routine called GuessDefaultConfig is invoked.  This method sets the bit(s).
</p><p>In all cases the default mask is sometimes specified for a particular config option and that is used for ASMConfig
</p><p>See the section below for the processing of a .DEV file.
</p><p>c) For all microcontrollers read the <code class="literal">CriticalChanges.txt</code> file and process.
</p><p>d) For 18f microcontrollers read the <code class="literal">18FDefaultASMConfig.txt</code>.  This simply overwrites all options stated in 18FDefaultASMConfig.TXT  and marks this in the output DAT file.
</p><p>e) Create the output DAT file.</p></td></tr><tr><td align="left" valign="top"><p>8</p></td><td align="left" valign="top"><p>Test and publish the DAT file(s) to the distribution as required.</p></td></tr></tbody></table></div><p><span class="strong"><strong>An example the processing of a .DEV</strong></span>.</p><p>This is the 18F25K20 example.   For this microcontroller <code class="literal">Disabled</code> is default:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/xml2.PNG" align="middle" alt="graphic"></div></div><p class="text-left"><br>
<br>
Where the default is selected from the Info_Type.
<br>
<br></p><p><span class="strong"><strong>Prog = .  An explanation of the parameter</strong></span>.
The Prog value is measured in words. It is the same in the device specific.dat files.
<br></p><p>Microchip in the past have used words, but then they started using bytes on the website instead to make their chips appear to have larger capacity.
<br></p><p>An example: If a device has 8192 words, which is 8192 * 14 = 114688 bits, or 14336 bytes.&nbsp;&nbsp;It is an odd measurement because dividing 14336 by 14/8 to see how many instructions you can use is extra maths work within the compiler.
<br></p><p>The GCBASIC PROGram memory analysis are in words.
<br></p><p><br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="gcbasic_maintenance"></span>GCBASIC Maintenance

</div>

</div>

</div>

<span class="strong">**Introduction:**</span> GCBASIC maintenance covers
the key processes that the developers use to maintain and build the
solution.

These insights are not distribution specific.

<span class="strong">**Solution Architecture:**</span> These components
are key for a complete solution:

<div class="orderedlist">

1.  GCBASIC installer
2.  GCBASIC chip specific .DAT files
3.  GCBASIC Help
4.  GCBASIC IDE

</div>

  
  
<span class="strong">**GCBASIC installers:**</span>  
  
The Windows GCBASIC installer uses the <span
class="emphasis">*InnoSoft*</span> installer with packaging completed
using R2Build.  

The process uses a Gold build structure. The R2Build software creates
four packages for Windows and one package for the Linux distribution.
The process is automated with automatic versioning and configuration.

The macOS GCBASIC installer uses the <span
class="emphasis">*Packages*</span> installer
(<http://s.sudre.free.fr/Software/Packages/about>) with packaging
completed using the Bourne shell script `pkg2dmg.sh` to create a
compressed disk image file containing the installer.

  
  
<span class="strong">**GCBASIC chip specific .DAT files:**</span>  
  
What are the .DAT files?

The DAT files are the GCBASIC representation of the capabilities of a
specific microcontroller.  The DAT is based upon a number of vendor
sources and corrections/omissions added by the GCBASIC development
team.  The DAT file is exposed to the user program as a set of registers
and register bits that can used to configure the program in terms of the
microcontroller specifics.  
  

The process to create the .DAT file for microcontrollers is as follows:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Step</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"><p>Obtain the MPASM *.INC or the AVR *.XML files to be used. These files determine the scope of registers and register bits.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>2</p></td>
<td style="text-align: left;"><p>For Microchip only. Place the source INC files in the ..DAT\incfiles\OrgFiles.</p>
<p>Process the file using 'Preprocess.bat'.    This is an AWK text processor - you will need AWK.EXE in the executing folder.</p>
<p>This preprocessing will examine all the INC files in the ..DAT\incfiles\OrgFiles folder.  The resulting files will be placed in the ..DAT\incfiles folder.  The resulting files will have the 'BITS' section sorted in port priority - this priority ensures the bits are assigned in the target DAT in the same order every time.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>3</p></td>
<td style="text-align: left;"><p>Update the database of support microcontrollers.  This database contains the microcontroller configuration that GCBASIC requires as the core information for the DAT files.</p>
<p>The database is called <code class="literal">chipdata.csv</code> or <code class="literal">avr_chipdata.csv</code> for Microchip and AVR respectively. - These files are comma delimited.  The first row of data specifies the field name - these field names control the chip conversion program, see later notes.  </p>
<p>The database fields are controlled by the GCBASIC development team and the specification of the database may change between releases to support new capabilities.</p>
<p>Database fields will have the suffix of <code class="literal">Variant</code> such as PWMTimerVariant and SMTClockSourceVariant and are microcontroller specific configuration settings to support the various microcontroller settings.  The values of these <code class="literal">variants</code> are determined by the examination of the microcontroller datasheets as this information is NOT specified in the source files.  Variants are exposed in the user program with the prefix of Chip.  If the variant is called <code class="literal">PWMTimerVariant</code> a constant called <code class="literal">ChipPWMTimerVariant</code> will be exposed in the user program.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>4</p></td>
<td style="text-align: left;"><p>Update the <code class="literal">CriticalChanges.txt</code> file, if required.  The <code class="literal">CriticalChanges.txt</code> file contains changes to the INC file during processing that are corrections or additions to the source files.</p>
<p>The format of each line is the <code class="literal">filename</code> , <code class="literal">Append (new line) or Replace</code>, <code class="literal">find</code>, <code class="literal">replace</code>.</p>
<p>Each line is comma delimited and spaces are NOT critical.   Essentially, the processing with find a partial line and replace or append the whole line.</p>
<p>example: p16lf1615.inc,R,OSCFIE EQU H'0007',OSFIE EQU H'0007'     - so, when processing p16lf1615.inc find the line OSCFIE EQU H'0007' and replace with OSFIE EQU H'0007'.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>5</p></td>
<td style="text-align: left;"><p>If required.   This is not normally edited.    Update the <code class="literal">18FDefaultASMConfig.txt</code> to set the 18f configuration defaults.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>6</p></td>
<td style="text-align: left;"><p>Maintain the conversion program.  The conversion program may require maintenance.   The programs are written in FreeBASIC and therefore require compilation.</p>
<p>An example of maintenance is a new variant field is required.  The source program will need to be updated to support the new variant - simply edit the source, compile and publish.  Another example is the addition of a new Interrupt - follow the same process to edit, compile and publish.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>7</p></td>
<td style="text-align: left;"><p>Execute the program to convert the source files to the DAT files for Microchip or AVR.  There are two programs for each architecture.</p>
<p>Executing the conversion program without a parameter will process ALL the entries in the database (the csv file), passing a single parameter to the conversion program will only convert the single microcontroller.</p>
<p>The conversion program will process as follows:</p>
<p>a) Read the database for the chip specifics</p>
<p>b) If a .DEV file or .INFO file is not present a routine called GuessDefaultConfig is invoked. This method sets the bit(s).</p>
<p>In all cases the default mask is sometimes specified for a particular config option and that is used for ASMConfig</p>
<p>See the section below for the processing of a .DEV file.</p>
<p>c) For all microcontrollers read the <code class="literal">CriticalChanges.txt</code> file and process.</p>
<p>d) For 18f microcontrollers read the <code class="literal">18FDefaultASMConfig.txt</code>. This simply overwrites all options stated in 18FDefaultASMConfig.TXT and marks this in the output DAT file.</p>
<p>e) Create the output DAT file.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>8</p></td>
<td style="text-align: left;"><p>Test and publish the DAT file(s) to the distribution as required.</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**An example the processing of a .DEV**</span>.

This is the 18F25K20 example. For this microcontroller `Disabled` is
default:

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/xml2.PNG)

</div>

</div>

  
  
Where the default is selected from the Info\_Type.  
  

<span class="strong">**Prog = . An explanation of the
parameter**</span>. The Prog value is measured in words. It is the same
in the device specific.dat files.  

Microchip in the past have used words, but then they started using bytes
on the website instead to make their chips appear to have larger
capacity.  

An example: If a device has 8192 words, which is 8192 \* 14 = 114688
bits, or 14336 bytes.  It is an odd measurement because dividing 14336
by 14/8 to see how many instructions you can use is extra maths work
within the compiler.  

The GCBASIC PROGram memory analysis are in words.  

  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GCBASIC Maintenance and Development</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_overview_freebsd_gcbasic.html" title="Overview - FreeBSD GCBASIC"><link rel="next" href="_gcbasic_maintenance.html" title="GCBASIC Maintenance"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_gcbasic_maintenance_and_development"></a>GCBASIC Maintenance and Development</h2></div></div></div><p>This is the GCBASIC maintenance section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="gcbasic_maintenance_and_development"></span>GCBASIC Maintenance and Development
------------------------------------------------------------------------------------------

</div>

</div>

</div>

This is the GCBASIC maintenance section of the Help file. Please refer
the sub-sections for details using the contents/folder view.

</div>
body {background-color: #FFFCEA;}
p {font-family: Arial, Helvetica, sans-serif; font-size=12pt}
.informaltable {font-family: Arial, Helvetica, sans-serif; font-size=12pt}
.itemizedlist {font-family: Arial, Helvetica, sans-serif; font-size=12pt}
.variablelist {font-family: Arial, Helvetica, sans-serif; font-size=12pt}
.listitem {font-family: Arial, Helvetica, sans-serif; font-size=12pt}
.screen {font-family: "Courier New", Courier, monospace; font-size=12pt}
.literal {font-family: "Courier New", Courier, monospace; font-size=12pt}
.literallayout {font-family: "Courier New", Courier, monospace; font-size=12pt}
.blue {color: blue}
.red {color: red}
.gray {color: gray}
h1,h2,h3,h4,h5,h6 { font-family: Arial, Helvetica, sans-serif; font-size=14pt; background-color: #C0C0C0 ; }
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Generate Accurate Pulses</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_programs.html" title="Example Programs"><link rel="prev" href="_flashing_led_with_timing_parameters.html" title="Flashing LED with timing parameters"><link rel="next" href="_graphical_lcd_demonstration.html" title="Graphical LCD Demonstration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_generate_accurate_pulses"></a>Generate Accurate Pulses</h3></div></div></div><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">PulseOut</code> Command is a reliable method for generating pulses if accuracy is not critical,
the <code class="literal">PulseOut</code> command uses a calculation of the clock to speed for the timing .</p><p>If you need better accuracy and resolution then an alternative approach is required.</p><p>To generate pulses in the 100 us to 2500 us range with an accuracy of +- 1us over this range is practical using the approach shown in this example.</p><p>This example code works on a midrange PIC16F690 operating at 8Mhz.
However, it should work on any Microchip PIC microcontroller, but may need some minor modifications.</p><p><span class="strong"><strong>Usage:</strong></span></p><pre class="screen">    Pulse_Out_us ( word_value )</pre><p><span class="strong"><strong>How It Works:</strong></span></p><p><code class="literal">Timer1</code> is loaded with a preset value based upon the variable passed to the sub routine.
The timer (<code class="literal">Timer1</code>) is started and the pulse pin (the output pin) is set high.
When <code class="literal">Timer1</code> overflows the Timer1 interrupt flag bit (<code class="literal">TMR1IF</code>) is set.  This causes the program to
exit a polling loop and set the pulse Pin off. Then, <code class="literal">Timer1</code> is stopped and <code class="literal">TMRIF</code> flag is cleared and the sub routine exits.</p><p>This method supports delays between 5 us and 65535 us and uses Timer1.</p><p><span class="strong"><strong>Test Results:</strong></span></p><p>These tests were completed using a Saleae Logic Analyzer.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Pulse setting</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Time Results</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">Pulse_Out_us (2500)</code></p></td><td align="left" valign="top"><p><code class="literal">2501.375 us</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Pulse_Out_us (1000)</code></p></td><td align="left" valign="top"><p><code class="literal">1000.750 us</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Pulse_Out_us (100)</code></p></td><td align="left" valign="top"><p><code class="literal">100. 125 us</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Pulse_Out_us (10)</code></p></td><td align="left" valign="top"><p><code class="literal">10.125 us</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Pulse_Out_us with less then 4</code></p></td><td align="left" valign="top"><p><code class="literal">Unreliable results</code></p></td></tr></tbody></table></div><p><span class="strong"><strong>Demonstration program:</strong></span></p><pre class="screen">    ;**************************************
    ; Code:  Output an accurate pulse
    ; Author: William Roth 03/13/2021
    ;**************************************

    #chip 16F690,8

    ; ---- Define Hardware settings
    ; ---- Define I2C settings - CHANGE PORTS AS REQUIRED
    #define I2C_MODE Master
    #define I2C_DATA PORTB.4
    #define I2C_CLOCK PORTB.6
    #define I2C_DISABLE_INTERRUPTS ON

    ; ---- Set up LCD - Using I2C LCD Backpack
    #define LCD_IO 10
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_I2C_Address_1 0x4e ; default to 0x4E
    ; ----  May need to use SLOW or MEDIUM if your LCD is a slower device.
    #define LCD_SPEED Medium
    #define LCD_Backlight_On_State  1
    #define LCD_Backlight_Off_State 0

    CLS
    ; ---- USART settings
    #define USART_BAUD_RATE 38400
    #define USART_TX_BLOCKING
    DIR PORTB.7 OUT

    ; ---- Setup Pulse parameters
    #define PulsePin PORTC.4
    Dim Time_us As WORD
    Dir PulsePin Out     'Pulsout pin
    Set PulsePin off

    ; ---- Setup Timer
    InitTimer1 Osc, PS1_2  'For 8Mhz Chip
    'InitTimer1 Osc, PS1_4, 'For 16 Mhz Chip
    TMR1H = 0: TMR1L = 0   'Clear timer1
    TMR1IF = 0  'Clear timer1 int flag
    TMR1IE = on 'Enable timer1 Interrupt (Flag only)

    ' **** This is the MAIN loop *****
    Do
        PULSE_OUT_US (2500)  'Measured as 2501.375 us
        wait 19 ms
        Pulse_Out_US (1000)  'Measured as 1000.750 us
        wait 19 ms
        Pulse_Out_US (100)   'Measured as 100.125 us
        wait 19 ms
        Pulse_Out_US (10)    'Measured as 10.125 us
        Wait 19 ms
    loop

    SUB PULSE_OUT_US (IN Variable as WORD)
    TMR1H = 65535 - Variable_H      'Timer 1 Preset High
    TMR1L = (65535 - Variable) + 4  'Timer 1 Preset Low
    Set TMR1ON ON                'Start timer1
    Set PulsePin ON               'Set Pin high
    Do While TMR1IF = 0      'Wait  for Timer1 overflow
        Loop
    Set PulsePin off          ' Pin Low
    Set TMR1ON OFF            ' Stop timer 1
    TMR1IF = 0             'Clear the Int flag
    END SUB</pre><p>Also see <a class="link" href="_pulseout.html" title="PulseOut">PulseOut</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="generate_accurate_pulses"></span>Generate Accurate Pulses

</div>

</div>

</div>

<span class="strong">**Explanation:**</span>

The `PulseOut` Command is a reliable method for generating pulses if
accuracy is not critical, the `PulseOut` command uses a calculation of
the clock to speed for the timing .

If you need better accuracy and resolution then an alternative approach
is required.

To generate pulses in the 100 us to 2500 us range with an accuracy of +-
1us over this range is practical using the approach shown in this
example.

This example code works on a midrange PIC16F690 operating at 8Mhz.
However, it should work on any Microchip PIC microcontroller, but may
need some minor modifications.

<span class="strong">**Usage:**</span>

``` screen
    Pulse_Out_us ( word_value )
```

<span class="strong">**How It Works:**</span>

`Timer1` is loaded with a preset value based upon the variable passed to
the sub routine. The timer (`Timer1`) is started and the pulse pin (the
output pin) is set high. When `Timer1` overflows the Timer1 interrupt
flag bit (`TMR1IF`) is set. This causes the program to exit a polling
loop and set the pulse Pin off. Then, `Timer1` is stopped and `TMRIF`
flag is cleared and the sub routine exits.

This method supports delays between 5 us and 65535 us and uses Timer1.

<span class="strong">**Test Results:**</span>

These tests were completed using a Saleae Logic Analyzer.

<div class="informaltable">

| <span class="strong">**Pulse setting**</span> | <span class="strong">**Time Results**</span> |
|:----------------------------------------------|:---------------------------------------------|
| `Pulse_Out_us (2500)`                         | `2501.375 us`                                |
| `Pulse_Out_us (1000)`                         | `1000.750 us`                                |
| `Pulse_Out_us (100)`                          | `100. 125 us`                                |
| `Pulse_Out_us (10)`                           | `10.125 us`                                  |
| `Pulse_Out_us with less then 4`               | `Unreliable results`                         |

</div>

<span class="strong">**Demonstration program:**</span>

``` screen
    ;**************************************
    ; Code:  Output an accurate pulse
    ; Author: William Roth 03/13/2021
    ;**************************************

    #chip 16F690,8

    ; ---- Define Hardware settings
    ; ---- Define I2C settings - CHANGE PORTS AS REQUIRED
    #define I2C_MODE Master
    #define I2C_DATA PORTB.4
    #define I2C_CLOCK PORTB.6
    #define I2C_DISABLE_INTERRUPTS ON

    ; ---- Set up LCD - Using I2C LCD Backpack
    #define LCD_IO 10
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_I2C_Address_1 0x4e ; default to 0x4E
    ; ----  May need to use SLOW or MEDIUM if your LCD is a slower device.
    #define LCD_SPEED Medium
    #define LCD_Backlight_On_State  1
    #define LCD_Backlight_Off_State 0

    CLS
    ; ---- USART settings
    #define USART_BAUD_RATE 38400
    #define USART_TX_BLOCKING
    DIR PORTB.7 OUT

    ; ---- Setup Pulse parameters
    #define PulsePin PORTC.4
    Dim Time_us As WORD
    Dir PulsePin Out     'Pulsout pin
    Set PulsePin off

    ; ---- Setup Timer
    InitTimer1 Osc, PS1_2  'For 8Mhz Chip
    'InitTimer1 Osc, PS1_4, 'For 16 Mhz Chip
    TMR1H = 0: TMR1L = 0   'Clear timer1
    TMR1IF = 0  'Clear timer1 int flag
    TMR1IE = on 'Enable timer1 Interrupt (Flag only)

    ' **** This is the MAIN loop *****
    Do
        PULSE_OUT_US (2500)  'Measured as 2501.375 us
        wait 19 ms
        Pulse_Out_US (1000)  'Measured as 1000.750 us
        wait 19 ms
        Pulse_Out_US (100)   'Measured as 100.125 us
        wait 19 ms
        Pulse_Out_US (10)    'Measured as 10.125 us
        Wait 19 ms
    loop

    SUB PULSE_OUT_US (IN Variable as WORD)
    TMR1H = 65535 - Variable_H      'Timer 1 Preset High
    TMR1L = (65535 - Variable) + 4  'Timer 1 Preset Low
    Set TMR1ON ON                'Start timer1
    Set PulsePin ON               'Set Pin high
    Do While TMR1IF = 0      'Wait  for Timer1 overflow
        Loop
    Set PulsePin off          ' Pin Low
    Set TMR1ON OFF            ' Stop timer 1
    TMR1IF = 0             'Clear the Int flag
    END SUB
```

Also see
<a href="pulseout" class="link" title="PulseOut">PulseOut</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Get</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_cls.html" title="CLS"><link rel="next" href="_lcdbacklight.html" title="LCDBacklight"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_get"></a>Get</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    var = Get(Line, Column)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with the LCD R/W line (pin 5) connected and if the following constant definition is used;
<code class="literal">#define LCD_RW</code>. Only available when the LCD is connected using the 4 or 8 bit mode and when the constant definition
<code class="literal">#define LCD_NO_RW</code> is NOT used.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Get</code> function reads the ASCII character code at a given location on
the LCD.</p><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_put.html" title="Put">Put</a>,
<a class="link" href="_lcd_overview.html" title="LCD Overview">LCD Overview</a></p><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="get"></span>Get

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    var = Get(Line, Column)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with the LCD R/W line (pin 5)
connected and if the following constant definition is used;
`#define LCD_RW`. Only available when the LCD is connected using the 4
or 8 bit mode and when the constant definition `#define LCD_NO_RW` is
NOT used.

<span class="strong">**Explanation:**</span>

The `Get` function reads the ASCII character code at a given location on
the LCD.

<span class="strong">**For more help, see**</span>
<a href="put" class="link" title="Put">Put</a>,
<a href="lcd_overview" class="link" title="LCD Overview">LCD Overview</a>

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GetUserID</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_miscellaneous_commands.html" title="Miscellaneous Commands"><link rel="prev" href="_dir.html" title="Dir"><link rel="next" href="_pot.html" title="Pot"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_getuserid"></a>GetUserID</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen"></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip microcontrollers that support UserIDs.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Reads the memory location and returns the ID for a specific microcontroller.</p><p>If the microcontroller does not support GetUSerID then the following message will be issued during compilation <code class="literal">Warning: GetUserID not supported by this microcontroller</code>.</p><p>The method reads the memory location 0x8000 + Index and returns it as a Word value, where the Index 0x00 to 0x0B as follows:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="left" valign="top">Address</th><th align="left" valign="top">Function</th><th align="left" valign="top">Read</th><th align="left" valign="top">Write</th></tr></thead><tbody><tr><td align="left" valign="top"><p>8000h-8003h</p></td><td align="left" valign="top"><p>User IDs</p></td><td align="left" valign="top"><p>Yes</p></td><td align="left" valign="top"><p>Yes</p></td></tr><tr><td align="left" valign="top"><p>8006h/8005h</p></td><td align="left" valign="top"><p>Device ID/Revision ID</p></td><td align="left" valign="top"><p>Yes</p></td><td align="left" valign="top"><p>No</p></td></tr><tr><td align="left" valign="top"><p>8007h-800Bh</p></td><td align="left" valign="top"><p>Configuration Words 1 through 5</p></td><td align="left" valign="top"><p>Yes</p></td><td align="left" valign="top"><p>No</p></td></tr></tbody></table></div><p>Refer to your particular Device Datasheet to confirm the address table</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">      #chip 16F1455
      #Config MCLRE_ON

      #include &lt;GetUserID.h&gt;

      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

      'Implement ANSI escaope code for serial terminal NOT using a LCD!
      #define ESC   chr(27)
      #define CLS   HSerPrint(ESC+"[2J")
      #define HOME  HSerPrint(ESC+"[H")
      #define Print HSerPrint

      CLS
      HOME

      dim UserIDRegister as word

      For Index = 0 to 0xF
        UserIDRegister  = GetUserID(Index)
        HserPrint "80" + hex(NVIndex)
        HserPrint " : "
        HserPrint hex( UserIDRegister_H )
        HserPrint hex( UserIDRegister    )
      Next Index

    End</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="getuserid"></span>GetUserID

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip microcontrollers that support UserIDs.

<span class="strong">**Explanation:**</span>

Reads the memory location and returns the ID for a specific
microcontroller.

If the microcontroller does not support GetUSerID then the following
message will be issued during compilation
`Warning: GetUserID not supported by this microcontroller`.

The method reads the memory location 0x8000 + Index and returns it as a
Word value, where the Index 0x00 to 0x0B as follows:

<div class="informaltable">

| Address     | Function                        | Read | Write |
|:------------|:--------------------------------|:-----|:------|
| 8000h-8003h | User IDs                        | Yes  | Yes   |
| 8006h/8005h | Device ID/Revision ID           | Yes  | No    |
| 8007h-800Bh | Configuration Words 1 through 5 | Yes  | No    |

</div>

Refer to your particular Device Datasheet to confirm the address table

<span class="strong">**Example:**</span>

``` screen
      #chip 16F1455
      #Config MCLRE_ON

      #include <GetUserID.h>

      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

      'Implement ANSI escaope code for serial terminal NOT using a LCD!
      #define ESC   chr(27)
      #define CLS   HSerPrint(ESC+"[2J")
      #define HOME  HSerPrint(ESC+"[H")
      #define Print HSerPrint

      CLS
      HOME

      dim UserIDRegister as word

      For Index = 0 to 0xF
        UserIDRegister  = GetUserID(Index)
        HserPrint "80" + hex(NVIndex)
        HserPrint " : "
        HserPrint hex( UserIDRegister_H )
        HserPrint hex( UserIDRegister    )
      Next Index

    End
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDCLS</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_filledtriangle.html" title="FilledTriangle"><link rel="next" href="_glcddisplay.html" title="GLCDDisplay"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcdcls"></a>GLCDCLS</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDCLS [GLCDBackground]</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Clears the screen of a Graphic LCD.  This command is supported by all GLCD displays.</p><p>For colour GLCD displays only.  The optional parameter can be used to clear the screen to a specific colour.  Using this additional parameter will also change the GLCDBackground colour to this same colour.</p><p>Specific to the ST7920 GLCD devices. This command supports the clearing the GLCD to either text mode or graphics mode.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcdcls"></span>GLCDCLS

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDCLS [GLCDBackground]
```

<span class="strong">**Explanation:**</span>

Clears the screen of a Graphic LCD. This command is supported by all
GLCD displays.

For colour GLCD displays only. The optional parameter can be used to
clear the screen to a specific colour. Using this additional parameter
will also change the GLCDBackground colour to this same colour.

Specific to the ST7920 GLCD devices. This command supports the clearing
the GLCD to either text mode or graphics mode.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDDisplay</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcdcls.html" title="GLCDCLS"><link rel="next" href="_glcddrawchar.html" title="GLCDDrawChar"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcddisplay"></a>GLCDDisplay</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDDisplay Off | On</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Places the GLCD in sleep mode or enables the GLCD for normal operations.</p><p>The options are:</p><pre class="screen">    OFF
    ON</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcddisplay"></span>GLCDDisplay

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDDisplay Off | On
```

<span class="strong">**Explanation:**</span>

Places the GLCD in sleep mode or enables the GLCD for normal operations.

The options are:

``` screen
    OFF
    ON
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDDrawChar</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcddisplay.html" title="GLCDDisplay"><link rel="next" href="_glcddrawstring.html" title="GLCDDrawString"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcddrawchar"></a>GLCDDrawChar</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDDrawChar(CharLocX, CharLocY, CharCode [, Optional Colour] )</pre><p><code class="literal">CharLocX</code> is the <code class="literal">X</code> coordinate location for the character<br>
<code class="literal">CharLocY</code> is the <code class="literal">Y</code> coordinate location for the character<br>
<code class="literal">CharCode</code> is the ASCII number of the character to display. Can be decimal
hex or binary.</p><p>Colour can be <code class="literal">ON</code> or <code class="literal">OFF</code>. For the ST7735 devices this an be any word
value that represents the color palette.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Displays an ASCII character at a specified X and Y location.
On a 128x64 Graphic LCD:</p><p>X = 1 to 128<br>
Y = 1 to 64<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcddrawchar"></span>GLCDDrawChar

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDDrawChar(CharLocX, CharLocY, CharCode [, Optional Colour] )
```

`CharLocX` is the `X` coordinate location for the character  
`CharLocY` is the `Y` coordinate location for the character  
`CharCode` is the ASCII number of the character to display. Can be
decimal hex or binary.

Colour can be `ON` or `OFF`. For the ST7735 devices this an be any word
value that represents the color palette.

<span class="strong">**Explanation:**</span>

Displays an ASCII character at a specified X and Y location. On a 128x64
Graphic LCD:

X = 1 to 128  
Y = 1 to 64  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDDrawString</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcddrawchar.html" title="GLCDDrawChar"><link rel="next" href="_glcdprint.html" title="GLCDPrint"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcddrawstring"></a>GLCDDrawString</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDDrawString(CharLocX, CharLocY, String [, Optional Colour] )</pre><p><code class="literal">CharLocX</code> is the X corrdinate location for the character<br>
<code class="literal">CharLocY</code> is the Y coordinate location for the character<br>
<code class="literal">String</code> is the string of characters to display<br>
<code class="literal">Colour</code> can be ON or OFF. For the ST7735 devices this an be any word
value that represents the color palette</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Displays an ASCII character at a specified X and Y location.<br>
On a 128x64 Graphic LCD :<br>
X = 1 to 128<br>
Y = 1 to 64<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcddrawstring"></span>GLCDDrawString

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDDrawString(CharLocX, CharLocY, String [, Optional Colour] )
```

`CharLocX` is the X corrdinate location for the character  
`CharLocY` is the Y coordinate location for the character  
`String` is the string of characters to display  
`Colour` can be ON or OFF. For the ST7735 devices this an be any word
value that represents the color palette

<span class="strong">**Explanation:**</span>

Displays an ASCII character at a specified X and Y location.  
On a 128x64 Graphic LCD :  
X = 1 to 128  
Y = 1 to 64  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDLocateString</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcdprintwithsize.html" title="GLCDPrintWithSize"><link rel="next" href="_glcdprintstring.html" title="GLCDPrintString"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcdlocatestring"></a>GLCDLocateString</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDLocateString(PrintLocX, PrintLocY )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Moves the GLCD string pointer to the specified location on the GLCD screen.</p><p><code class="literal">PrintLocX</code> is the X corrdinate location for the data<br>
<code class="literal">PrintLocY</code> is the Y coordinate location for the data<br></p><p>For the purpose of this command. The screen addressing is the first line equates to the parameter 1, the second line equates to the paramter 2 etc.</p><p>An example:</p><pre class="screen">    GLCDLocateString( 0, 1 )    'The first line of the display
    GLCDLocateString( 0, 6 )    'The sixth line of the display</pre><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    GLCDPrintStringLn ( "1.First Ln" )
    GLCDPrintStringLn ( "2.Second Ln" )
    GLCDPrintStringLn ( "" )
    GLCDPrintStringLn ( "4.Forth Ln" )
    GLCDLocateString( 0, 5 )
    GLCDPrintString ( "5." )
    GLCDPrintStringLn ( "Fifth Ln" )

    GLCDPrintStringLn ( "6.Sixth Ln" )
    GLCDLocateString( 0, 3 )
    dim val3 as Byte
    val3 = 3
    GLCDPrintStringLn ( str( val3 ) + ".Third Ln" )</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcdlocatestring"></span>GLCDLocateString

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDLocateString(PrintLocX, PrintLocY )
```

<span class="strong">**Explanation:**</span>

Moves the GLCD string pointer to the specified location on the GLCD
screen.

`PrintLocX` is the X corrdinate location for the data  
`PrintLocY` is the Y coordinate location for the data  

For the purpose of this command. The screen addressing is the first line
equates to the parameter 1, the second line equates to the paramter 2
etc.

An example:

``` screen
    GLCDLocateString( 0, 1 )    'The first line of the display
    GLCDLocateString( 0, 6 )    'The sixth line of the display
```

<span class="strong">**Example:**</span>

``` screen
    GLCDPrintStringLn ( "1.First Ln" )
    GLCDPrintStringLn ( "2.Second Ln" )
    GLCDPrintStringLn ( "" )
    GLCDPrintStringLn ( "4.Forth Ln" )
    GLCDLocateString( 0, 5 )
    GLCDPrintString ( "5." )
    GLCDPrintStringLn ( "Fifth Ln" )

    GLCDPrintStringLn ( "6.Sixth Ln" )
    GLCDLocateString( 0, 3 )
    dim val3 as Byte
    val3 = 3
    GLCDPrintStringLn ( str( val3 ) + ".Third Ln" )
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDPrint</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcddrawstring.html" title="GLCDDrawString"><link rel="next" href="_glcdprintlargefont.html" title="GLCDPrintLargeFont"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcdprint"></a>GLCDPrint</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDPrint(PrintLocX, PrintLocY, PrintData_Byte [, Optional Colour] )    ',or
    GLCDPrint(PrintLocX, PrintLocY, PrintData_Word [, Optional Colour] )    ',or
    GLCDPrint(PrintLocX, PrintLocY, PrintData_Long [, Optional Colour] )    ',or

    GLCDPrint(PrintLocX, PrintLocY, PrintData_String [, Optional Colour] )</pre><p><br>
<br>
<code class="literal">PrintLocX</code> is the X corrdinate location for the data<br>
<code class="literal">PrintLocY</code> is the Y coordinate location for the data<br>
<code class="literal">PrintData_[type]</code> is a variable or constant to be displayed
<br>
<br>
<span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
Prints data values (byte, word, long or string) at a specified location on the GLCD screen.
<br>
<br>
To display an integer use:
<br>
<br></p><pre class="screen">    GLCDPrint(PrintLocX, PrintLocY, strinteger(integer_value) )</pre><p><br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcdprint"></span>GLCDPrint

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDPrint(PrintLocX, PrintLocY, PrintData_Byte [, Optional Colour] )    ',or
    GLCDPrint(PrintLocX, PrintLocY, PrintData_Word [, Optional Colour] )    ',or
    GLCDPrint(PrintLocX, PrintLocY, PrintData_Long [, Optional Colour] )    ',or

    GLCDPrint(PrintLocX, PrintLocY, PrintData_String [, Optional Colour] )
```

  
  
`PrintLocX` is the X corrdinate location for the data  
`PrintLocY` is the Y coordinate location for the data  
`PrintData_[type]` is a variable or constant to be displayed  
  
<span class="strong">**Explanation:**</span>  
  
Prints data values (byte, word, long or string) at a specified location
on the GLCD screen.  
  
To display an integer use:  
  

``` screen
    GLCDPrint(PrintLocX, PrintLocY, strinteger(integer_value) )
```

  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDPrintLargeFont</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcdprint.html" title="GLCDPrint"><link rel="next" href="_glcdprintwithsize.html" title="GLCDPrintWithSize"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcdprintlargefont"></a>GLCDPrintLargeFont</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDPrintLargeFont( PrintLocX, PrintLocY, PrintData_String [, Optional Colour] )</pre><p>GLCD supports for a larger fixed font of 13 pixels.&nbsp;&nbsp;  GLCDPrintLargeFont supports strings only.</p><p><br>
<br>
<code class="literal">PrintLocX</code> is the X corrdinate location for the data<br>
<code class="literal">PrintLocY</code> is the Y coordinate location for the data<br>
<code class="literal">PrintData_[type]</code> is a variable or constant to be displayed
<br>
<br>
<span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
Prints data values (byte, word, long or string) at a specified location on the GLCD screen.
<br>
<br>
To display an integer use:
<br>
<br></p><pre class="screen">    GLCDPrintLargeFont( 0, 0, "13 Pixels Fixed Font" )</pre><p><br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcdprintlargefont"></span>GLCDPrintLargeFont

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDPrintLargeFont( PrintLocX, PrintLocY, PrintData_String [, Optional Colour] )
```

GLCD supports for a larger fixed font of 13 pixels.   GLCDPrintLargeFont
supports strings only.

  
  
`PrintLocX` is the X corrdinate location for the data  
`PrintLocY` is the Y coordinate location for the data  
`PrintData_[type]` is a variable or constant to be displayed  
  
<span class="strong">**Explanation:**</span>  
  
Prints data values (byte, word, long or string) at a specified location
on the GLCD screen.  
  
To display an integer use:  
  

``` screen
    GLCDPrintLargeFont( 0, 0, "13 Pixels Fixed Font" )
```

  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDPrintString</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcdlocatestring.html" title="GLCDLocateString"><link rel="next" href="_glcdprintstringln.html" title="GLCDPrintStringLn"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcdprintstring"></a>GLCDPrintString</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDPrintString( String )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Prints string character(s) at a current XY location on the GLCD screen.</p><p>Where <code class="literal">String</code> is a String or String variable of the data to display</p><p>This command will <span class="strong"><strong>NOT</strong></span> move the to start of the next line after the string has been displayed</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    GLCDPrintStringLn ( "1.First Ln" )
    GLCDPrintStringLn ( "2.Second Ln" )
    GLCDPrintStringLn ( "" )
    GLCDPrintStringLn ( "4.Forth Ln" )
    GLCDLocateString( 0, 5 )
    GLCDPrintString ( "5." )
    GLCDPrintStringLn ( "Fifth Ln" )

    GLCDPrintStringLn ( "6.Sixth Ln" )
    GLCDLocateString( 0, 3 )
    dim val3 as Byte
    val3 = 3
    GLCDPrintStringLn ( str( val3 ) + ".Third Ln" )</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcdprintstring"></span>GLCDPrintString

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDPrintString( String )
```

<span class="strong">**Explanation:**</span>

Prints string character(s) at a current XY location on the GLCD screen.

Where `String` is a String or String variable of the data to display

This command will <span class="strong">**NOT**</span> move the to start
of the next line after the string has been displayed

<span class="strong">**Example:**</span>

``` screen
    GLCDPrintStringLn ( "1.First Ln" )
    GLCDPrintStringLn ( "2.Second Ln" )
    GLCDPrintStringLn ( "" )
    GLCDPrintStringLn ( "4.Forth Ln" )
    GLCDLocateString( 0, 5 )
    GLCDPrintString ( "5." )
    GLCDPrintStringLn ( "Fifth Ln" )

    GLCDPrintStringLn ( "6.Sixth Ln" )
    GLCDLocateString( 0, 3 )
    dim val3 as Byte
    val3 = 3
    GLCDPrintStringLn ( str( val3 ) + ".Third Ln" )
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDPrintStringLn</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcdprintstring.html" title="GLCDPrintString"><link rel="next" href="_glcdrotate.html" title="GLCDRotate"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcdprintstringln"></a>GLCDPrintStringLn</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDPrintStringLn( String )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Prints string character(s) at a current XY location on the GLCD screen.</p><p>Where <code class="literal">String</code> is a String or String variable of the data to display</p><p>This command will move to the start of the next line after the string has been displayed</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    GLCDPrintStringLn ( "1.First Ln" )
    GLCDPrintStringLn ( "2.Second Ln" )
    GLCDPrintStringLn ( "" )
    GLCDPrintStringLn ( "4.Forth Ln" )
    GLCDLocateString( 0, 5 )
    GLCDPrintString ( "5." )
    GLCDPrintStringLn ( "Fifth Ln" )

    GLCDPrintStringLn ( "6.Sixth Ln" )
    GLCDLocateString( 0, 3 )
    dim val3 as Byte
    val3 = 3
    GLCDPrintStringLn ( str( val3 ) + ".Third Ln" )</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcdprintstringln"></span>GLCDPrintStringLn

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDPrintStringLn( String )
```

<span class="strong">**Explanation:**</span>

Prints string character(s) at a current XY location on the GLCD screen.

Where `String` is a String or String variable of the data to display

This command will move to the start of the next line after the string
has been displayed

<span class="strong">**Example:**</span>

``` screen
    GLCDPrintStringLn ( "1.First Ln" )
    GLCDPrintStringLn ( "2.Second Ln" )
    GLCDPrintStringLn ( "" )
    GLCDPrintStringLn ( "4.Forth Ln" )
    GLCDLocateString( 0, 5 )
    GLCDPrintString ( "5." )
    GLCDPrintStringLn ( "Fifth Ln" )

    GLCDPrintStringLn ( "6.Sixth Ln" )
    GLCDLocateString( 0, 3 )
    dim val3 as Byte
    val3 = 3
    GLCDPrintStringLn ( str( val3 ) + ".Third Ln" )
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDPrintWithSize</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcdprintlargefont.html" title="GLCDPrintLargeFont"><link rel="next" href="_glcdlocatestring.html" title="GLCDLocateString"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcdprintwithsize"></a>GLCDPrintWithSize</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_Byte , FontSize [, Color ] )    ',or
    GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_Word , FontSize [, Color ] )    ',or
    GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_Long , FontSize [, Color ] )    ',or

    GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_String , FontSize [, Color ] )</pre><p><br>
<br>
<code class="literal">PrintLocX</code> is the X corrdinate location for the data<br>
<code class="literal">PrintLocY</code> is the Y coordinate location for the data<br>
<code class="literal">PrintData_[type]</code> is a variable or constant to be displayed<br>
<code class="literal">FontSize</code> is the GLCD fontsize.&nbsp;&nbsp; Typical values are 1, 2 or 3<br>
<code class="literal">Color</code> is an optional parameter to change the color the GLCD printed text.
<br>
<br>
<span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
Prints data values (byte, word, long or string) at a specified location on the GLCD screen with a specific font size.
<br>
<br>
To display a string using font size two use:
<br>
<br></p><pre class="screen">    GLCDPrintWithSize(PrintLocX, PrintLocY, "Using font size #2", 2 )</pre><p><br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcdprintwithsize"></span>GLCDPrintWithSize

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_Byte , FontSize [, Color ] )    ',or
    GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_Word , FontSize [, Color ] )    ',or
    GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_Long , FontSize [, Color ] )    ',or

    GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_String , FontSize [, Color ] )
```

  
  
`PrintLocX` is the X corrdinate location for the data  
`PrintLocY` is the Y coordinate location for the data  
`PrintData_[type]` is a variable or constant to be displayed  
`FontSize` is the GLCD fontsize.   Typical values are 1, 2 or 3  
`Color` is an optional parameter to change the color the GLCD printed
text.  
  
<span class="strong">**Explanation:**</span>  
  
Prints data values (byte, word, long or string) at a specified location
on the GLCD screen with a specific font size.  
  
To display a string using font size two use:  
  

``` screen
    GLCDPrintWithSize(PrintLocX, PrintLocY, "Using font size #2", 2 )
```

  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDReadByte</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcdrotate.html" title="GLCDRotate"><link rel="next" href="_glcdtimedelay.html" title="GLCDTimeDelay"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcdreadbyte"></a>GLCDReadByte</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    byte_variable = GLCDReadByte</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Reads a byte of data from the Graphic LCD memory</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcdreadbyte"></span>GLCDReadByte

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    byte_variable = GLCDReadByte
```

<span class="strong">**Explanation:**</span>

Reads a byte of data from the Graphic LCD memory

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDRotate</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcdprintstringln.html" title="GLCDPrintStringLn"><link rel="next" href="_glcdreadbyte.html" title="GLCDReadByte"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcdrotate"></a>GLCDRotate</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDROTATE LANDSCOPE | PORTRAIT_REV | LANDSCAPE_REV  | PORTRAIT</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Rotate the GLCD display to a relative position.</p><p>GLCD rotation needs to be supported by the GLCD chipset. <span class="strong"><strong>NOT</strong></span> all GLCD chipset support these commands.</p><p>The options are:</p><pre class="screen">    LANDSCAPE
    PORTRAIT_REV
    LANDSCAPE_REV
    PORTRAIT</pre><p>The command will rotate the screen and set the following variables using the global variables shown below.</p><pre class="screen">    GLCD_WIDTH
    GLCD_HEIGHT</pre><p>The command is supported by the following global constants.</p><pre class="screen">    #define LANDSCAPE       1
    #define PORTRAIT_REV    2
    #define LANDSCAPE_REV   3
    #define PORTRAIT        4</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcdrotate"></span>GLCDRotate

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDROTATE LANDSCOPE | PORTRAIT_REV | LANDSCAPE_REV  | PORTRAIT
```

<span class="strong">**Explanation:**</span>

Rotate the GLCD display to a relative position.

GLCD rotation needs to be supported by the GLCD chipset. <span
class="strong">**NOT**</span> all GLCD chipset support these commands.

The options are:

``` screen
    LANDSCAPE
    PORTRAIT_REV
    LANDSCAPE_REV
    PORTRAIT
```

The command will rotate the screen and set the following variables using
the global variables shown below.

``` screen
    GLCD_WIDTH
    GLCD_HEIGHT
```

The command is supported by the following global constants.

``` screen
    #define LANDSCAPE       1
    #define PORTRAIT_REV    2
    #define LANDSCAPE_REV   3
    #define PORTRAIT        4
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDTimeDelay</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcdreadbyte.html" title="GLCDReadByte"><link rel="next" href="_glcdtransaction.html" title="GLCDTransaction"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcdtimedelay"></a>GLCDTimeDelay</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDTime</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This will call the delay routine that delays data transmissions. By
default this is set to <code class="literal">20</code>, which equate to <code class="literal">20 us</code>. <code class="literal">GLCDTimeDelay</code> default
of <code class="literal">20us</code> is for 32Mhz support. The can be reduced for slower chip speeds
by change the constant <code class="literal">ST7920WriteDelay</code>.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    GLCDTime                       'call the delay routine
    #define ST7920WriteDelay 1     'set the delay to 1 us</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcdtimedelay"></span>GLCDTimeDelay

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDTime
```

<span class="strong">**Explanation:**</span>

This will call the delay routine that delays data transmissions. By
default this is set to `20`, which equate to `20 us`. `GLCDTimeDelay`
default of `20us` is for 32Mhz support. The can be reduced for slower
chip speeds by change the constant `ST7920WriteDelay`.

<span class="strong">**Example usage:**</span>

``` screen
    GLCDTime                       'call the delay routine
    #define ST7920WriteDelay 1     'set the delay to 1 us
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDTransaction</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcdtimedelay.html" title="GLCDTimeDelay"><link rel="next" href="_glcdwritebyte.html" title="GLCDWriteByte"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcdtransaction"></a>GLCDTransaction</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCD_Open_PageTransaction
      ....
        additional number of other GLCD methods
      ....
    GLCD_Close_PageTransaction</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>To make the operation of GLCD seamless - specific library supports GLCDTransaction.&nbsp;&nbsp;
GLCDTransaction automatically manages the methods to update the GLCD display via a RAM memory buffer, where this buffer can be small relative to the size of the total number of GLCD pixels.</p><p>The process of GLCDtransaction sends GLCD commands to the GLCD display on a page and page basis.&nbsp;&nbsp;
Each page is the size of the buffer and for a large GLCD display the number of pages may be equivilent to the numbers of pixels high (height).</p><p>GLCDTransaction simplies the operation by ensure the buffer is setup correctly, handles the GLCD appropiately, handles the sending of the buffer and then close out the update to the display.</p><p>To use GLCDTransaction use the followng methods.</p><pre class="screen">    GLCD_Open_PageTransaction
      ....
      additional number of other GLCD methods
      ....
    GLCD_Close_PageTransaction</pre><p>It recommended to use GLCDTransactions at all times when using the e-Paper libraries.&nbsp;&nbsp;
Other GLCD libraries support GLCDTransaction to reduce the memory requirement.&nbsp;&nbsp;</p><p>Thes GLCDTransactions methods remove the complexity of the GLCD display update process when RAM within the microcontroller is limited.</p><p>When using GLCDTransaction you must commence with GLCD_Open_PageTransaction then a series of GLCD commands and then terminate with GLCD_Close_PageTransaction.</p><p><span class="strong"><strong>GLCDTransaction Insight</strong></span>: When using GLCDtransactions the number of buffer pages is probably be greater then 1 (unless using the SRAM option), so the process of incrementing variables and calls to non-GLCD methods must be considered carefully.    The transaction process will increment variables and call non-GLCD methods the same number of times as the number of pages.  Therefore, design GLCDTransaction operations with this is mind.</p><p><span class="strong"><strong>SRAM as the display buffer</strong></span></p><p>To improve memory usage the e-paper the e-Paper libraries support the use of SRAM.   SRAM can be used as an alternative to the microcontrollers RAM.   Using SRAM does have a small performance impact but does free up the critical resource of the microcontroller RAM.   The use of SRAM within the e-paper library is transparent to the user.   To use SRAM as the e-paper buffer you will need to set-up the SRAM library.   See the SRAM library for more details on SRAM usage.</p><p>When using SRAM for the e-paper buffer it is still remcommend to use GLCDTransaction as this ensure the SRAM buffer is correctly initialised.</p><p><span class="strong"><strong>Optional GLCD_Open_Transaction parameters</strong></span></p><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCD_Open_PageTransaction ( low_page, high_page )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>You can optionally pass <code class="literal">GLCD_Open_PageTransaction</code> two parmeters.  The parameters will constrain the GLCD display update process to the specific pages.</p><p>This can be used when only updating a potion of the screen to improve performance.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcdtransaction"></span>GLCDTransaction

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCD_Open_PageTransaction
      ....
        additional number of other GLCD methods
      ....
    GLCD_Close_PageTransaction
```

<span class="strong">**Explanation:**</span>

To make the operation of GLCD seamless - specific library supports
GLCDTransaction.   GLCDTransaction automatically manages the methods to
update the GLCD display via a RAM memory buffer, where this buffer can
be small relative to the size of the total number of GLCD pixels.

The process of GLCDtransaction sends GLCD commands to the GLCD display
on a page and page basis.   Each page is the size of the buffer and for
a large GLCD display the number of pages may be equivilent to the
numbers of pixels high (height).

GLCDTransaction simplies the operation by ensure the buffer is setup
correctly, handles the GLCD appropiately, handles the sending of the
buffer and then close out the update to the display.

To use GLCDTransaction use the followng methods.

``` screen
    GLCD_Open_PageTransaction
      ....
      additional number of other GLCD methods
      ....
    GLCD_Close_PageTransaction
```

It recommended to use GLCDTransactions at all times when using the
e-Paper libraries.   Other GLCD libraries support GLCDTransaction to
reduce the memory requirement.  

Thes GLCDTransactions methods remove the complexity of the GLCD display
update process when RAM within the microcontroller is limited.

When using GLCDTransaction you must commence with
GLCD\_Open\_PageTransaction then a series of GLCD commands and then
terminate with GLCD\_Close\_PageTransaction.

<span class="strong">**GLCDTransaction Insight**</span>: When using
GLCDtransactions the number of buffer pages is probably be greater then
1 (unless using the SRAM option), so the process of incrementing
variables and calls to non-GLCD methods must be considered carefully.
The transaction process will increment variables and call non-GLCD
methods the same number of times as the number of pages. Therefore,
design GLCDTransaction operations with this is mind.

<span class="strong">**SRAM as the display buffer**</span>

To improve memory usage the e-paper the e-Paper libraries support the
use of SRAM. SRAM can be used as an alternative to the microcontrollers
RAM. Using SRAM does have a small performance impact but does free up
the critical resource of the microcontroller RAM. The use of SRAM within
the e-paper library is transparent to the user. To use SRAM as the
e-paper buffer you will need to set-up the SRAM library. See the SRAM
library for more details on SRAM usage.

When using SRAM for the e-paper buffer it is still remcommend to use
GLCDTransaction as this ensure the SRAM buffer is correctly initialised.

<span class="strong">**Optional GLCD\_Open\_Transaction
parameters**</span>

<span class="strong">**Syntax:**</span>

``` screen
    GLCD_Open_PageTransaction ( low_page, high_page )
```

<span class="strong">**Explanation:**</span>

You can optionally pass `GLCD_Open_PageTransaction` two parmeters. The
parameters will constrain the GLCD display update process to the
specific pages.

This can be used when only updating a potion of the screen to improve
performance.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCDWriteByte</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcdtransaction.html" title="GLCDTransaction"><link rel="next" href="_line.html" title="Line"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcdwritebyte"></a>GLCDWriteByte</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    GLCDWriteByte (LCDByte)</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Writes a byte of data to the Graphic LCD memory</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcdwritebyte"></span>GLCDWriteByte

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    GLCDWriteByte (LCDByte)
```

<span class="strong">**Explanation:**</span>

Writes a byte of data to the Graphic LCD memory

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GLCD Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_graphical_lcd.html" title="Graphical LCD"><link rel="next" href="_fonts_and_characters.html" title="Fonts and Characters"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_glcd_overview"></a>GLCD Overview</h4></div></div></div><p>The GLCD commands are used to control a Graphical Liquid Crystal Display (GLCD)
based on the a number of GLCD chipsets. These are often 128x64 pixel displays but the size can vary.
GLCD devices draw graphical elements by enabling or disabling pixels.</p><p>A GLCD is an upgrade from the
popular 16x2 LCDs (see <a class="link" href="_lcd_overview.html" title="LCD Overview">Liquid Crystal
Display Overview</a> ) but the GLCD allows full graphical control of the
display.</p><p>Typical displays are</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Color or mono displays</li><li class="listitem">Low power white LED, OLED with or without back-light</li><li class="listitem">e-Paper with low power consumption</li><li class="listitem">Driven by on-board interface chipsets amd/or interface controllers</li><li class="listitem">The GLCDs are very common and well documented</li><li class="listitem">Small to large view areas</li><li class="listitem">Typically requires from 3-pin to 36-pin header connections and 10K contrast pot</li><li class="listitem">Typically have back-lit pixels</li><li class="listitem">Require memory in the microcontroller to support graphial operations or can be used in text and picture mode</li></ul></div><p>GCBASIC makes this type of device easier to control with the
commands for the GLCD.</p><p><span class="strong"><strong>Microcontroller Requirements:</strong></span>
Specific GLCDs require different configurations of a microcontroller.  Parameters include</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Communications protocol: These incldue 8 wire bus, I2C, SPI etc</li><li class="listitem">Operating votlage: These are typically 3.3v or 5.v</li><li class="listitem">Memory required: For full GLCD capabilites you will require 1k or more, for text only and JPG mode low memory devices are supported</li></ul></div><p>Review your choice of microcontroller and GLCD carefully before commencing your project.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"><col class="col_5"><col class="col_6"><col class="col_7"><col class="col_8"><col class="col_9"><col class="col_10"><col class="col_11"><col class="col_12"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>#</strong></span></th><th align="left" valign="top"><span class="strong"><strong>ChipSet</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Size</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Pixels</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Depth</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Type</strong></span></th><th align="left" valign="top"><span class="strong"><strong>I/O</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Support</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Operating</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Comments</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Requirements</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Assessment</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>1</p></td><td align="left" valign="top"><p>KS0108</p></td><td align="left" valign="top"><p>2.9 inch and less. various sizes</p></td><td align="left" valign="top"><p>128 * 64</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Mono</p></td><td align="left" valign="top"><p>LCD typically with backlight</p></td><td align="left" valign="top"><p>8-bit parallel PIC and AVR: Software device specific protocol</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications 8-bit bus required.</p></td><td align="left" valign="top"><p>Bit 7 of the bus is read/write &#8211; this could cause potential lockup &#8211; this is low risk.&nbsp;&nbsp;&nbsp;Uses the KS0107B (or NT7107C) a 64-channel common driver which generates the timing signal to control the two KS0108B segment drivers.</p></td><td align="left" valign="top"><p>Requires 12 ports/connections.</p></td><td align="left" valign="top"><p>These are low cost mono devices.</p></td></tr><tr><td align="left" valign="top"><p>2</p></td><td align="left" valign="top"><p>ILI9481</p></td><td align="left" valign="top"><p>3.2inch</p></td><td align="left" valign="top"><p>320 * 240</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>TFT LCD  8-bit parallel</p></td><td align="left" valign="top"><p>PIC: Set per bit. AVR: via Shield set via AND PORT command</p></td><td align="left" valign="top"><p>+VCC from 2.7 to  5. Always check voltage specifications</p></td><td align="left" valign="top"><p>UNO shield is excellent. Very fast display.</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td><td align="left" valign="top"><p>Good GLCD with very good GLCD performance.</p></td></tr><tr><td align="left" valign="top"><p>3</p></td><td align="left" valign="top"><p>PCD8544</p></td><td align="left" valign="top"><p>1.77inch</p></td><td align="left" valign="top"><p>Nokia 3310 or 5110</p></td><td align="left" valign="top"><p>160 * 128</p></td><td align="left" valign="top"><p>Small  Mono  LCD with LED</p></td><td align="left" valign="top"><p>SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Device specific SPI command, all in software.</p></td><td align="left" valign="top"><p>Display can operate in text mode only for low RAM microcontrollers as full GLCD capabilities requires 512bytes of RAM. +VCC 3.3.  Always check voltage specifications  Nice display.
Sensitive to operating voltages.</p></td><td align="left" valign="top"><p>Minimum RAM required is 512 bytes then add user variables for graphics mode, this display can operate in text mode only for low RAM microcontrollers.</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td><td align="left" valign="top"><p>Good for cost and performance</p></td></tr><tr><td align="left" valign="top"><p>4</p></td><td align="left" valign="top"><p>ILI9341</p></td><td align="left" valign="top"><p>2.8 Inch or 3.2 Inch</p></td><td align="left" valign="top"><p>320 * 240</p></td><td align="left" valign="top"><p>Medium</p></td><td align="left" valign="top"><p>Color TFT</p></td><td align="left" valign="top"><p>SPI  PIC and AVR: Hardware and software SPI</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications</p></td><td align="left" valign="top"><p>+VCC from 2.7 to 5. Always check voltage specifications</p></td><td align="left" valign="top"><p>Very nice display.</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td><td align="left" valign="top"><p>Good  for cost and performance</p></td></tr><tr><td align="left" valign="top"><p>5</p></td><td align="left" valign="top"><p>SSD1289</p></td><td align="left" valign="top"><p>3.2inch</p></td><td align="left" valign="top"><p>240 * 320</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>TFT LCD</p></td><td align="left" valign="top"><p>16-bit parallel  AVR: Software device specific protocol.</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications</p></td><td align="left" valign="top"><p>Mega2560 shield required.</p></td><td align="left" valign="top"><p>Connectivity requires 20 ports.</p></td><td align="left" valign="top"><p>Good for Mega2560 type shields</p></td></tr><tr><td align="left" valign="top"><p>6</p></td><td align="left" valign="top"><p>ST7735</p></td><td align="left" valign="top"><p>1.8 Inch</p></td><td align="left" valign="top"><p>128 * 64</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>TFT LCD</p></td><td align="left" valign="top"><p>SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software SPI</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications Very nice display.</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td><td align="left" valign="top"><p>Good for cost and performance</p></td></tr><tr><td align="left" valign="top"><p>7</p></td><td align="left" valign="top"><p>ST7735R</p></td><td align="left" valign="top"><p>1.8 Inch</p></td><td align="left" valign="top"><p>128 * 160</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>TFT LCD</p></td><td align="left" valign="top"><p>SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software SPI</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications Very nice display.</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td><td align="left" valign="top"><p>Good for cost and performance</p></td></tr><tr><td align="left" valign="top"><p>8</p></td><td align="left" valign="top"><p>ST7735R_160_80</p></td><td align="left" valign="top"><p>1.8 Inch</p></td><td align="left" valign="top"><p>160 * 80</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>TFT LCD</p></td><td align="left" valign="top"><p>SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software SPI</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications Very nice display.</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td><td align="left" valign="top"><p>Good for cost and performance</p></td></tr><tr><td align="left" valign="top"><p>9</p></td><td align="left" valign="top"><p>ILI9340</p></td><td align="left" valign="top"><p>2.2 Inch</p></td><td align="left" valign="top"><p>240 * 320</p></td><td align="left" valign="top"><p>Medium</p></td><td align="left" valign="top"><p>Mono</p></td><td align="left" valign="top"><p>TFT LCD</p></td><td align="left" valign="top"><p>SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software SPI</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td><td align="left" valign="top"><p>Good for cost and performance</p></td></tr><tr><td align="left" valign="top"><p>10</p></td><td align="left" valign="top"><p>ILI9486L or ILI9486</p></td><td align="left" valign="top"><p>4inch</p></td><td align="left" valign="top"><p>RPI   240 * 320</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>TFT LCD</p></td><td align="left" valign="top"><p>SPI and 8Bit Bus</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software SPI
AVR: 8Bit Bus using an UNO Shield.  PIC: 8bit port suppported.</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications Great pixel display.</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.
8Bit Bus requires 8 ports plus 4 control ports. Typically 13 in total using an 8bit bus solution.</p></td><td align="left" valign="top"><p>An expensive option</p></td></tr><tr><td align="left" valign="top"><p>11</p></td><td align="left" valign="top"><p>Nexion</p></td><td align="left" valign="top"><p>ITEAD Nexion</p></td><td align="left" valign="top"><p>240 * 320 to
800 * 480</p></td><td align="left" valign="top"><p>Large - 2.4 to 7inches</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>TFT LCD</p></td><td align="left" valign="top"><p>Serial - hardware or software serial is supported.</p></td><td align="left" valign="top"><p>Nextion specfic and GLCD command set</p></td><td align="left" valign="top"><p>Typically operates at VCC 5 with external power supply. Always check voltage specifications  Great command set, you need to learn the GUI and then interface to GCBASIC.</p></td><td align="left" valign="top"><p>2 ports for the read/write serial operations.</p></td><td align="left" valign="top"><p>A very nice option but if you need flexibility then the best!</p></td></tr><tr><td align="left" valign="top"><p>12</p></td><td align="left" valign="top"><p>SH1106</p></td><td align="left" valign="top"><p>1.3 inch or 0.96inch</p></td><td align="left" valign="top"><p>128 * 64</p></td><td align="left" valign="top"><p>Small</p></td><td align="left" valign="top"><p>Mono OLED</p></td><td align="left" valign="top"><p>I2C</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software I2C</p></td><td align="left" valign="top"><p>Always at 3.3v. Always check voltage specifications</p></td><td align="left" valign="top"><p>RAM for Full Mode GLCD is 1024 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.</p></td><td align="left" valign="top"><p>I2C requires 2 ports.</p></td><td align="left" valign="top"><p>Good OLED display, excellent value for money</p></td></tr><tr><td align="left" valign="top"><p>13</p></td><td align="left" valign="top"><p>SDD1306</p></td><td align="left" valign="top"><p>0.96inch</p></td><td align="left" valign="top"><p>128 * 64</p></td><td align="left" valign="top"><p>Small</p></td><td align="left" valign="top"><p>Mono</p></td><td align="left" valign="top"><p>OLED</p></td><td align="left" valign="top"><p>I2C and SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td><td align="left" valign="top"><p>RAM for Full Mode GLCD is 1024 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.
Typically operates at VCC 5. Always check voltage specifications  Very good OLED display. Driver supports gaming. Minimum RAM required is  1024 bytes then add user variables for graphics mode.
</p><p>Display can operate in text mode only for low RAM microcontrollers</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.
</p><p>I2C requires 2 ports.</p></td><td align="left" valign="top"><p>Good OLED display, excellent value for money</p></td></tr><tr><td align="left" valign="top"><p>14</p></td><td align="left" valign="top"><p>SDD1306 Twin Screen</p></td><td align="left" valign="top"><p>0.96inch * 2</p></td><td align="left" valign="top"><p>128 * 128</p></td><td align="left" valign="top"><p>Small</p></td><td align="left" valign="top"><p>Mono</p></td><td align="left" valign="top"><p>OLED</p></td><td align="left" valign="top"><p>I2C and SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td><td align="left" valign="top"><p>RAM for Full Mode GLCD is 2048 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.
Typically operates at VCC 5. Always check voltage specifications  Very good OLED display. Driver supports gaming. Minimum RAM required is  1024 bytes then add user variables for graphics mode.
</p><p>Display can operate in text mode only for low RAM microcontrollers</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 3 ports. Typically 7 in total.
</p><p>I2C requires 2 ports.</p></td><td align="left" valign="top"><p>Good OLED display, excellent value for money</p></td></tr><tr><td align="left" valign="top"><p>15</p></td><td align="left" valign="top"><p>SDD1306_32</p></td><td align="left" valign="top"><p>0.96inch</p></td><td align="left" valign="top"><p>128 * 32</p></td><td align="left" valign="top"><p>Very small</p></td><td align="left" valign="top"><p>Mono</p></td><td align="left" valign="top"><p>OLED</p></td><td align="left" valign="top"><p>I2C and SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td><td align="left" valign="top"><p>RAM for Full Mode GLCD is 512 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.
Typically operates at VCC 5. Always check voltage specifications  Best small OLED display. Driver supports gaming.  Minimum RAM required is  512 bytes then add user variables for graphics mode, this display can operate in text mode only for low RAM microcontrollers</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.
</p><p>I2C requires 2 ports.</p></td><td align="left" valign="top"><p>Good OLED display, excellent value for money</p></td></tr><tr><td align="left" valign="top"><p>16</p></td><td align="left" valign="top"><p>ST7920</p></td><td align="left" valign="top"><p>2.9inch</p></td><td align="left" valign="top"><p>128 * 64</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Mono</p></td><td align="left" valign="top"><p>LCD typically with backlight 8-bit parallel</p></td><td align="left" valign="top"><p>PIC and AVR:  Software device specific protocol.</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications</p></td><td align="left" valign="top"><p>8-bit bus required.  Bit 7 of the bus is read/write &#8211; this could cause potential lockup &#8211; this is low risk.
</p><p>This looks like a KS0108 but it is NOT! Supports Chinese font set.</p></td><td align="left" valign="top"><p>Requires 12 ports.</p></td><td align="left" valign="top"><p>A very slow device.</p></td></tr><tr><td align="left" valign="top"><p>17</p></td><td align="left" valign="top"><p>HX8347G</p></td><td align="left" valign="top"><p>2.2inch</p></td><td align="left" valign="top"><p>240 * 320</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>TFT LCD</p></td><td align="left" valign="top"><p>SPI</p></td><td align="left" valign="top"><p>AVR 8 bit bus</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications Great pixel display.</p></td><td align="left" valign="top"><p>Controller requires 8 ports plus 5 control ports. Typically 13 in total with an UNO shield.</p></td><td align="left" valign="top"><p>An very nice display</p></td></tr><tr><td align="left" valign="top"><p>18</p></td><td align="left" valign="top"><p>SDD1331</p></td><td align="left" valign="top"><p>0.96inch</p></td><td align="left" valign="top"><p>96 * 48</p></td><td align="left" valign="top"><p>Small</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>OLED</p></td><td align="left" valign="top"><p>SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications</p></td><td align="left" valign="top"><p>SPI requires typically 6 in total.</p></td><td align="left" valign="top"><p>Very good color OLED display, excellent value for money</p></td></tr><tr><td align="left" valign="top"><p>19</p></td><td align="left" valign="top"><p>ILI9326</p></td><td align="left" valign="top"><p>3.00inch</p></td><td align="left" valign="top"><p>400 * 320</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>OLED</p></td><td align="left" valign="top"><p>8 bit bus</p></td><td align="left" valign="top"><p>PIC and AVR: 8 bit bus</p></td><td align="left" valign="top"><p>Typically operates at VCC 3.3. Always check voltage specifications</p></td><td align="left" valign="top"><p>Requires typically 13 in total plus 0v, VCC and LED.</p></td><td align="left" valign="top"><p>Good color OLED display, good value for money as it is fast.  But, the rotate is all executed in software and this does slow down processing.
</p><p><br>
The LED connected is typically to ground.  You can solder the GND connect to make the backlite permanently on.</p></td></tr><tr><td align="left" valign="top"><p>20</p></td><td align="left" valign="top"><p>NT7108C</p></td><td align="left" valign="top"><p>2.9 inch and less. various sizes</p></td><td align="left" valign="top"><p>128 * 64</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Mono</p></td><td align="left" valign="top"><p>LCD typically with backlight</p></td><td align="left" valign="top"><p>8-bit parallel PIC and AVR: Software device specific protocol</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications 8-bit bus required.</p></td><td align="left" valign="top"><p>Look similar to KS0108, but, it is NOT the same, hence this driver.&nbsp;&nbsp;&nbsp;Uses the Winstar&#8217;s WDG0151-TMI module, which is a 128&times;64 pixel monochromatic display.&nbsp;&nbsp;&nbsp;This uses two Neotic display controller chips:&nbsp;NT7108C and NT7107C. The WDG0151 module contains two sets of it to drive 128 segments.&nbsp;&nbsp;&nbsp;On the other hand, the KS0107B (or NT7107C) is a 64-channel common driver which generates the timing signal to control the two KS0108B segment drivers.
<br>
<br>
The NT7108C is very sensitive with respect to clock timing.&nbsp;&nbsp;&nbsp;You may have to adjust to ensure the display operates as correctly.</p></td><td align="left" valign="top"><p>Requires 12 ports/connections.</p></td><td align="left" valign="top"><p>These are medium cost mono devices.</p></td></tr><tr><td align="left" valign="top"><p>21</p></td><td align="left" valign="top"><p>T6963_64</p></td><td align="left" valign="top"><p>4inches by 2inches</p></td><td align="left" valign="top"><p>240 * 64</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Mono</p></td><td align="left" valign="top"><p>LCD typically with backlight</p></td><td align="left" valign="top"><p>8-bit parallel PIC and AVR: Software device specific protocol</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications 8-bit bus required.</p></td><td align="left" valign="top"><p>Operating similar to KS0108 and an LCD.  segment drivers.
<br>
<br></p></td><td align="left" valign="top"><p>Requires 12 ports/connections.</p></td><td align="left" valign="top"><p>These are medium cost mono devices.</p></td></tr><tr><td align="left" valign="top"><p>22</p></td><td align="left" valign="top"><p>T6963_128</p></td><td align="left" valign="top"><p>4inches by 2inches</p></td><td align="left" valign="top"><p>240 * 128</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Mono</p></td><td align="left" valign="top"><p>LCD typically with backlight</p></td><td align="left" valign="top"><p>8-bit parallel PIC and AVR: Software device specific protocol</p></td><td align="left" valign="top"><p>Typically operates at VCC 5. Always check voltage specifications 8-bit bus required.</p></td><td align="left" valign="top"><p>Operating similar to KS0108 and an LCD.  segment drivers.
<br>
<br></p></td><td align="left" valign="top"><p>Requires 12 ports/connections.</p></td><td align="left" valign="top"><p>These are medium cost mono devices.</p></td></tr><tr><td align="left" valign="top"><p>23</p></td><td align="left" valign="top"><p>UC1601</p></td><td align="left" valign="top"><p>4.00inch</p></td><td align="left" valign="top"><p>132 * 22</p></td><td align="left" valign="top"><p>Medium</p></td><td align="left" valign="top"><p>Mono</p></td><td align="left" valign="top"><p>OLED</p></td><td align="left" valign="top"><p>I2C and SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td><td align="left" valign="top"><p>RAM for Full Mode GLCD is 396 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.
Typically operates at VCC 2.8v. Always check voltage specifications  Very good display. Driver supports gaming. Minimum RAM required is 396 bytes then add user variables for graphics mode.</p></td><td align="left" valign="top"><p>Requires up to 5 ports/connections.</p></td><td align="left" valign="top"><p>Low cost device</p></td></tr><tr><td align="left" valign="top"><p>24</p></td><td align="left" valign="top"><p>SDD1351</p></td><td align="left" valign="top"><p>1.50inch</p></td><td align="left" valign="top"><p>128 * 128</p></td><td align="left" valign="top"><p>Small</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>OLED</p></td><td align="left" valign="top"><p>SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td><td align="left" valign="top"><p>Typically operates at VCC 3.3 or 5. Always check voltage specifications</p></td><td align="left" valign="top"><p>SPI requires typically 6 in total.</p></td><td align="left" valign="top"><p>Very good color OLED display, excellent value for money</p></td></tr><tr><td align="left" valign="top"><p>25</p></td><td align="left" valign="top"><p>Waveshare e-Paper</p></td><td align="left" valign="top"><p>Various Size from 2.13 to 7.5 inches</p></td><td align="left" valign="top"><p>104 * 112 to 640 * 384</p></td><td align="left" valign="top"><p>Small to very large</p></td><td align="left" valign="top"><p>Black and White</p></td><td align="left" valign="top"><p>Microencapsulated Electrophoretic Display</p></td><td align="left" valign="top"><p>SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td><td align="left" valign="top"><p>Typically operates at VCC 3.3. Always check voltage specifications</p></td><td align="left" valign="top"><p>SPI requires typically 6 in total.</p></td><td align="left" valign="top"><p>Very good color e-Paper displays, excellent value for money
Display can operate in text mode only for low RAM microcontrollers using SRAM solution.</p></td></tr><tr><td align="left" valign="top"><p>26</p></td><td align="left" valign="top"><p>ST7789</p></td><td align="left" valign="top"><p>2.0 Inch</p></td><td align="left" valign="top"><p>240 * 240 or 320 * 240</p></td><td align="left" valign="top"><p>Medium</p></td><td align="left" valign="top"><p>Color TFT</p></td><td align="left" valign="top"><p>SPI  PIC and AVR: Hardware and software SPI</p></td><td align="left" valign="top"><p>Typically operates at 3v3. Always check voltage specifications</p></td><td align="left" valign="top"><p>+VCC from 3v3. Always check voltage specifications</p></td><td align="left" valign="top"><p>Very nice display.</p></td><td align="left" valign="top"><p>SPI requires 3 ports (data, clock &amp; command/data) plus 1 port ( reset ). Typically 4 in total.</p></td><td align="left" valign="top"><p>Good  for cost and performance</p></td></tr><tr><td align="left" valign="top"><p>27</p></td><td align="left" valign="top"><p>ST7735R_160_80</p></td><td align="left" valign="top"><p>1.8 Inch</p></td><td align="left" valign="top"><p>160 * 80</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>TFT LCD</p></td><td align="left" valign="top"><p>SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Hardware and software SPI</p></td><td align="left" valign="top"><p>Typically operates only at VCC 3.3. Always check voltage specifications Very nice display.</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td><td align="left" valign="top"><p>Good for cost and performance</p></td></tr><tr><td align="left" valign="top"><p>28</p></td><td align="left" valign="top"><p>ILI9488</p></td><td align="left" valign="top"><p>3.2inch</p></td><td align="left" valign="top"><p>320 * 240</p></td><td align="left" valign="top"><p>Large</p></td><td align="left" valign="top"><p>Color</p></td><td align="left" valign="top"><p>TFT LCD  SPI</p></td><td align="left" valign="top"><p>PIC/&amp;AVR: SPI Only</p></td><td align="left" valign="top"><p>+VCC from 3v3 to  5. GLCD I/O is ONLY 3v3. Always check voltage specifications.</p></td><td align="left" valign="top"><p>Display is good, however, slower than comparable (size) GLCDs as the color definitions are four bytes ( typical color definitions are two bytes)</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td><td align="left" valign="top"><p>Acceptable GLCD performance.</p></td></tr><tr><td align="left" valign="top"><p>29</p></td><td align="left" valign="top"><p>ST7567</p></td><td align="left" valign="top"><p>1.9inch</p></td><td align="left" valign="top"><p>128 * 64</p></td><td align="left" valign="top"><p>Medium</p></td><td align="left" valign="top"><p>Mono</p></td><td align="left" valign="top"><p>LCD</p></td><td align="left" valign="top"><p>I2C and SPI</p></td><td align="left" valign="top"><p>PIC and AVR: Software I2C, and, hardware software SPI.  Harware IC2 fails as the ST7567 does not comply witht the I2C standard.</p></td><td align="left" valign="top"><p>+VCC from 3v3 to  5. GLCD I/O is ONLY 3v3. Always check voltage specifications.</p></td><td align="left" valign="top"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.
</p><p>I2C requires 2 ports.</p></td><td align="left" valign="top"><p>Typically operates at VCC 3v3 but may support 5v0. Always check voltage specifications  Very good LCD display. Driver supports gaming. Minimum RAM required is 1024 bytes then add user variables for graphics mode.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Setup:</strong></span></p><p>You <span class="strong"><strong>must</strong></span> include the <code class="literal">glcd.h</code> file at the top of your program. The file
needs to be in brackets as shown below.</p><pre class="screen">    #include &lt;GLCD.h&gt;</pre><p><span class="strong"><strong>Defines:</strong></span></p><p>There are several connections that must be defined to use the GLCD
commands with a GLCD display. The <span class="emphasis"><em>I/O pin</em></span> is the pin on the Microchip PIC or the Atmel AVR microcontroller
that is connected to that specific pin on the graphical LCD.</p><p><span class="strong"><strong>Example: KS0108 connectivity</strong></span></p><pre class="screen">    #define GLCD_RW   _I/O pin_ &#8216;Read/Write pin connection
    #define GLCD_RESET  _I/O pin_ &#8216;Reset pin connection
    #define GLCD_CS1  _I/O pin_ &#8216;CS1 pin connection
    #define GLCD_CS2  _I/O pin_ &#8216;CS2 pin connection
    #define GLCD_RS   _I/O pin_ &#8216;RS pin connection
    #define GLCD_ENABLE _I/O pin_ &#8216;Enable pin Connection
    #define GLCD_DB0  _I/O pin_ &#8216;Data pin 0 Connection
    #define GLCD_DB1  _I/O pin_ &#8216;Data pin 1 Connection
    #define GLCD_DB2  _I/O pin_ &#8216;Data pin 2 Connection
    #define GLCD_DB3  _I/O pin_ &#8216;Data pin 3 Connection
    #define GLCD_DB4  _I/O pin_ &#8216;Data pin 4 Connection
    #define GLCD_DB5  _I/O pin_ &#8216;Data pin 5 Connection
    #define GLCD_DB6  _I/O pin_ &#8216;Data pin 6 Connection
    #define GLCD_DB7  _I/O pin_ &#8216;Data pin 7 Connection
    #define GLCD_PROTECTOVERRUN 'prevent screen overdrawing     'SSD1306 GLCD only
    #define GLCDDirection       'Invert GLCD Y axis             'KS0108 GCD only</pre><p>Common commands supported across the range of supported GLCDs are:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable</code> )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td></tr></tbody></table></div><p><br>
<br></p><p>Public variable supported across the range of supported GLCDs are shown in the table below.
These variables control the user definable parameters of a specific GLCD.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Variable</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Type</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDBackground</code></p></td><td align="left" valign="top"><p>Color of GLCD background.</p></td><td align="left" valign="top"><p>Can be monochrome or color.<br>
For mono GLCDs the default is White or 0x0001.
For color GLCDs the default is White or 0xFFFF.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDForeground</code></p></td><td align="left" valign="top"><p>Color of GLCD foreground.</p></td><td align="left" valign="top"><p>Can be monochrome or color.<br>
For mono GLCDs the default is non-white or 0x0000.
For color GLCDs the default is Black or 0x0000.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Width of the current GLCD font.</p></td><td align="left" valign="top"><p>Default is 6 pixels.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDfntDefault</code></p></td><td align="left" valign="top"><p>Size of the current GLCD font.</p></td><td align="left" valign="top"><p>Default is 0.+
This equates to the standard GCB font set.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDfntDefaultsize</code></p></td><td align="left" valign="top"><p>Size of the current GLCD font.</p></td><td align="left" valign="top"><p>Default is 1.+
This equates to the 8 pixel high.</p></td></tr></tbody></table></div><p>For color TFT displays any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF., see <a class="link" href="http://www.barth-dev.de/online/rgb565-color-picker/" target="_top">http://www.barth-dev.de/online/rgb565-color-picker/</a> for a wider range of color parameters.</p><p>The following color constants are prevent-defined.</p><pre class="screen">    TFT_BLACK       0x0000
    TFT_NAVY        0x000F
    TFT_DARKGREEN   0x03E0
    TFT_DARKCYAN    0x03EF
    TFT_MAROON      0x7800
    TFT_PURPLE      0x780F
    TFT_OLIVE       0x7BE0
    TFT_LIGHTGREY   0xC618
    TFT_DARKGREY    0x7BEF
    TFT_BLUE        0x001F
    TFT_GREEN       0x07E0
    TFT_CYAN        0x07FF
    TFT_RED         0xF800
    TFT_MAGENTA     0xF81F
    TFT_YELLOW      0xFFE0
    TFT_WHITE       0xFFFF
    TFT_ORANGE      0xFD20
    TFT_GREENYELLOW 0xAFE5
    TFT_PINK        0xF81F</pre><p>This example shows how to drive a KS0108 based Graphic LCD module with
the built in commands of GCBASIC. See
<a class="link" href="http://www.greatcowbasic.com/sample-projects.html" target="_top">Graphic LCD</a> for
details, this is an external web site.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    ;Chip Settings
    #chip 16F886,16
    '#config MCLRE = on 'enable reset switch on CHIPINO
    #include &lt;GLCD.h&gt;

    ;Defines (Constants)
    #define GLCD_RW PORTB.1  'D9 to pin 5 of LCD
    #define GLCD_RESET PORTB.5 'D13 to pin 17 of LCD
    #define GLCD_CS1 PORTB.3 'D12 to actually since CS1, CS2 can be inverted
    #define GLCD_CS2 PORTB.4 'D11 to actually since CS1, CS2 can be inverted
    #define GLCD_RS PORTB.0  'D8 to pin 4 D/I pin on LCD
    #define GLCD_ENABLE PORTB.2 'D10 to Pin 6 on LCD
    #define GLCD_DB0 PORTC.7 'D0 to pin 7 on LCD
    #define GLCD_DB1 PORTC.6 'D1 to pin 8 on LCD
    #define GLCD_DB2 PORTC.5 'D2 to pin 9 on LCD
    #define GLCD_DB3 PORTC.4 'D3 to pin 10 on LCD
    #define GLCD_DB4 PORTC.3 'D4 to pin 11 on LCD
    #define GLCD_DB5 PORTC.2 'D5 to pin 12 on LCD
    #define GLCD_DB6 PORTC.1 'D6 to pin 13 on LCD
    #define GLCD_DB7 PORTC.0 'D7 to pin 14 on LCD

    Start:
    GLCDCLS
    GLCDPrint 0,10,"Hello"        'Print Hello
    wait 5 s
    GLCDPrint 0,10, "ASCII #:"    'Print ASCII #:
    Box 18,30,28,40               'Draw Box Around ASCII Character
    for char = 15 to 129          'Print 0 through 9
      GLCDPrint 17, 20 , Str(char)+"  "
      GLCDdrawCHAR 20,30, char
      wait 125 ms
    next
    line 0,50,127,50               'Draw Line using line command
    for xvar = 0 to 80             'Draw line using Pset command
        pset xvar,63,on                    '
    next                                        '
    Wait 1 s
    GLCDPrint 0,10,"End  "          'Print Hello
    wait 1 s
    Goto Start</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_graphical_lcd_demonstration.html" title="Graphical LCD Demonstration">Graphical LCD Demonstration</a>,
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>,
<a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>,
<a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>,
<a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a>, <a class="link" href="_pset.html" title="Pset">Pset</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="glcd_overview"></span>GLCD Overview

</div>

</div>

</div>

The GLCD commands are used to control a Graphical Liquid Crystal Display
(GLCD) based on the a number of GLCD chipsets. These are often 128x64
pixel displays but the size can vary. GLCD devices draw graphical
elements by enabling or disabling pixels.

A GLCD is an upgrade from the popular 16x2 LCDs (see
<a href="lcd_overview" class="link" title="LCD Overview">Liquid Crystal Display Overview</a>
) but the GLCD allows full graphical control of the display.

Typical displays are

<div class="itemizedlist">

-   Color or mono displays
-   Low power white LED, OLED with or without back-light
-   e-Paper with low power consumption
-   Driven by on-board interface chipsets amd/or interface controllers
-   The GLCDs are very common and well documented
-   Small to large view areas
-   Typically requires from 3-pin to 36-pin header connections and 10K
    contrast pot
-   Typically have back-lit pixels
-   Require memory in the microcontroller to support graphial operations
    or can be used in text and picture mode

</div>

GCBASIC makes this type of device easier to control with the commands
for the GLCD.

<span class="strong">**Microcontroller Requirements:**</span> Specific
GLCDs require different configurations of a microcontroller. Parameters
include

<div class="itemizedlist">

-   Communications protocol: These incldue 8 wire bus, I2C, SPI etc
-   Operating votlage: These are typically 3.3v or 5.v
-   Memory required: For full GLCD capabilites you will require 1k or
    more, for text only and JPG mode low memory devices are supported

</div>

Review your choice of microcontroller and GLCD carefully before
commencing your project.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>#</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>ChipSet</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Size</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Pixels</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Depth</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Type</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>I/O</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Support</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Operating</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Comments</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Requirements</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Assessment</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"><p>KS0108</p></td>
<td style="text-align: left;"><p>2.9 inch and less. various sizes</p></td>
<td style="text-align: left;"><p>128 * 64</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Mono</p></td>
<td style="text-align: left;"><p>LCD typically with backlight</p></td>
<td style="text-align: left;"><p>8-bit parallel PIC and AVR: Software device specific protocol</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications 8-bit bus required.</p></td>
<td style="text-align: left;"><p>Bit 7 of the bus is read/write – this could cause potential lockup – this is low risk.   Uses the KS0107B (or NT7107C) a 64-channel common driver which generates the timing signal to control the two KS0108B segment drivers.</p></td>
<td style="text-align: left;"><p>Requires 12 ports/connections.</p></td>
<td style="text-align: left;"><p>These are low cost mono devices.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>2</p></td>
<td style="text-align: left;"><p>ILI9481</p></td>
<td style="text-align: left;"><p>3.2inch</p></td>
<td style="text-align: left;"><p>320 * 240</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>TFT LCD 8-bit parallel</p></td>
<td style="text-align: left;"><p>PIC: Set per bit. AVR: via Shield set via AND PORT command</p></td>
<td style="text-align: left;"><p>+VCC from 2.7 to 5. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>UNO shield is excellent. Very fast display.</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td>
<td style="text-align: left;"><p>Good GLCD with very good GLCD performance.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>3</p></td>
<td style="text-align: left;"><p>PCD8544</p></td>
<td style="text-align: left;"><p>1.77inch</p></td>
<td style="text-align: left;"><p>Nokia 3310 or 5110</p></td>
<td style="text-align: left;"><p>160 * 128</p></td>
<td style="text-align: left;"><p>Small Mono LCD with LED</p></td>
<td style="text-align: left;"><p>SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Device specific SPI command, all in software.</p></td>
<td style="text-align: left;"><p>Display can operate in text mode only for low RAM microcontrollers as full GLCD capabilities requires 512bytes of RAM. +VCC 3.3. Always check voltage specifications Nice display. Sensitive to operating voltages.</p></td>
<td style="text-align: left;"><p>Minimum RAM required is 512 bytes then add user variables for graphics mode, this display can operate in text mode only for low RAM microcontrollers.</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td>
<td style="text-align: left;"><p>Good for cost and performance</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>4</p></td>
<td style="text-align: left;"><p>ILI9341</p></td>
<td style="text-align: left;"><p>2.8 Inch or 3.2 Inch</p></td>
<td style="text-align: left;"><p>320 * 240</p></td>
<td style="text-align: left;"><p>Medium</p></td>
<td style="text-align: left;"><p>Color TFT</p></td>
<td style="text-align: left;"><p>SPI PIC and AVR: Hardware and software SPI</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>+VCC from 2.7 to 5. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>Very nice display.</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td>
<td style="text-align: left;"><p>Good for cost and performance</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>5</p></td>
<td style="text-align: left;"><p>SSD1289</p></td>
<td style="text-align: left;"><p>3.2inch</p></td>
<td style="text-align: left;"><p>240 * 320</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>TFT LCD</p></td>
<td style="text-align: left;"><p>16-bit parallel AVR: Software device specific protocol.</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>Mega2560 shield required.</p></td>
<td style="text-align: left;"><p>Connectivity requires 20 ports.</p></td>
<td style="text-align: left;"><p>Good for Mega2560 type shields</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>6</p></td>
<td style="text-align: left;"><p>ST7735</p></td>
<td style="text-align: left;"><p>1.8 Inch</p></td>
<td style="text-align: left;"><p>128 * 64</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>TFT LCD</p></td>
<td style="text-align: left;"><p>SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software SPI</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications Very nice display.</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td>
<td style="text-align: left;"><p>Good for cost and performance</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>7</p></td>
<td style="text-align: left;"><p>ST7735R</p></td>
<td style="text-align: left;"><p>1.8 Inch</p></td>
<td style="text-align: left;"><p>128 * 160</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>TFT LCD</p></td>
<td style="text-align: left;"><p>SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software SPI</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications Very nice display.</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td>
<td style="text-align: left;"><p>Good for cost and performance</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>8</p></td>
<td style="text-align: left;"><p>ST7735R_160_80</p></td>
<td style="text-align: left;"><p>1.8 Inch</p></td>
<td style="text-align: left;"><p>160 * 80</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>TFT LCD</p></td>
<td style="text-align: left;"><p>SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software SPI</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications Very nice display.</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td>
<td style="text-align: left;"><p>Good for cost and performance</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>9</p></td>
<td style="text-align: left;"><p>ILI9340</p></td>
<td style="text-align: left;"><p>2.2 Inch</p></td>
<td style="text-align: left;"><p>240 * 320</p></td>
<td style="text-align: left;"><p>Medium</p></td>
<td style="text-align: left;"><p>Mono</p></td>
<td style="text-align: left;"><p>TFT LCD</p></td>
<td style="text-align: left;"><p>SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software SPI</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td>
<td style="text-align: left;"><p>Good for cost and performance</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>10</p></td>
<td style="text-align: left;"><p>ILI9486L or ILI9486</p></td>
<td style="text-align: left;"><p>4inch</p></td>
<td style="text-align: left;"><p>RPI 240 * 320</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>TFT LCD</p></td>
<td style="text-align: left;"><p>SPI and 8Bit Bus</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software SPI AVR: 8Bit Bus using an UNO Shield. PIC: 8bit port suppported.</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications Great pixel display.</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total. 8Bit Bus requires 8 ports plus 4 control ports. Typically 13 in total using an 8bit bus solution.</p></td>
<td style="text-align: left;"><p>An expensive option</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>11</p></td>
<td style="text-align: left;"><p>Nexion</p></td>
<td style="text-align: left;"><p>ITEAD Nexion</p></td>
<td style="text-align: left;"><p>240 * 320 to 800 * 480</p></td>
<td style="text-align: left;"><p>Large - 2.4 to 7inches</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>TFT LCD</p></td>
<td style="text-align: left;"><p>Serial - hardware or software serial is supported.</p></td>
<td style="text-align: left;"><p>Nextion specfic and GLCD command set</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5 with external power supply. Always check voltage specifications Great command set, you need to learn the GUI and then interface to GCBASIC.</p></td>
<td style="text-align: left;"><p>2 ports for the read/write serial operations.</p></td>
<td style="text-align: left;"><p>A very nice option but if you need flexibility then the best!</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>12</p></td>
<td style="text-align: left;"><p>SH1106</p></td>
<td style="text-align: left;"><p>1.3 inch or 0.96inch</p></td>
<td style="text-align: left;"><p>128 * 64</p></td>
<td style="text-align: left;"><p>Small</p></td>
<td style="text-align: left;"><p>Mono OLED</p></td>
<td style="text-align: left;"><p>I2C</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software I2C</p></td>
<td style="text-align: left;"><p>Always at 3.3v. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>RAM for Full Mode GLCD is 1024 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.</p></td>
<td style="text-align: left;"><p>I2C requires 2 ports.</p></td>
<td style="text-align: left;"><p>Good OLED display, excellent value for money</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>13</p></td>
<td style="text-align: left;"><p>SDD1306</p></td>
<td style="text-align: left;"><p>0.96inch</p></td>
<td style="text-align: left;"><p>128 * 64</p></td>
<td style="text-align: left;"><p>Small</p></td>
<td style="text-align: left;"><p>Mono</p></td>
<td style="text-align: left;"><p>OLED</p></td>
<td style="text-align: left;"><p>I2C and SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td>
<td style="text-align: left;"><p>RAM for Full Mode GLCD is 1024 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode. Typically operates at VCC 5. Always check voltage specifications Very good OLED display. Driver supports gaming. Minimum RAM required is 1024 bytes then add user variables for graphics mode.</p>
<p>Display can operate in text mode only for low RAM microcontrollers</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p>
<p>I2C requires 2 ports.</p></td>
<td style="text-align: left;"><p>Good OLED display, excellent value for money</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>14</p></td>
<td style="text-align: left;"><p>SDD1306 Twin Screen</p></td>
<td style="text-align: left;"><p>0.96inch * 2</p></td>
<td style="text-align: left;"><p>128 * 128</p></td>
<td style="text-align: left;"><p>Small</p></td>
<td style="text-align: left;"><p>Mono</p></td>
<td style="text-align: left;"><p>OLED</p></td>
<td style="text-align: left;"><p>I2C and SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td>
<td style="text-align: left;"><p>RAM for Full Mode GLCD is 2048 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode. Typically operates at VCC 5. Always check voltage specifications Very good OLED display. Driver supports gaming. Minimum RAM required is 1024 bytes then add user variables for graphics mode.</p>
<p>Display can operate in text mode only for low RAM microcontrollers</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 3 ports. Typically 7 in total.</p>
<p>I2C requires 2 ports.</p></td>
<td style="text-align: left;"><p>Good OLED display, excellent value for money</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>15</p></td>
<td style="text-align: left;"><p>SDD1306_32</p></td>
<td style="text-align: left;"><p>0.96inch</p></td>
<td style="text-align: left;"><p>128 * 32</p></td>
<td style="text-align: left;"><p>Very small</p></td>
<td style="text-align: left;"><p>Mono</p></td>
<td style="text-align: left;"><p>OLED</p></td>
<td style="text-align: left;"><p>I2C and SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td>
<td style="text-align: left;"><p>RAM for Full Mode GLCD is 512 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode. Typically operates at VCC 5. Always check voltage specifications Best small OLED display. Driver supports gaming. Minimum RAM required is 512 bytes then add user variables for graphics mode, this display can operate in text mode only for low RAM microcontrollers</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p>
<p>I2C requires 2 ports.</p></td>
<td style="text-align: left;"><p>Good OLED display, excellent value for money</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>16</p></td>
<td style="text-align: left;"><p>ST7920</p></td>
<td style="text-align: left;"><p>2.9inch</p></td>
<td style="text-align: left;"><p>128 * 64</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Mono</p></td>
<td style="text-align: left;"><p>LCD typically with backlight 8-bit parallel</p></td>
<td style="text-align: left;"><p>PIC and AVR: Software device specific protocol.</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>8-bit bus required. Bit 7 of the bus is read/write – this could cause potential lockup – this is low risk.</p>
<p>This looks like a KS0108 but it is NOT! Supports Chinese font set.</p></td>
<td style="text-align: left;"><p>Requires 12 ports.</p></td>
<td style="text-align: left;"><p>A very slow device.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>17</p></td>
<td style="text-align: left;"><p>HX8347G</p></td>
<td style="text-align: left;"><p>2.2inch</p></td>
<td style="text-align: left;"><p>240 * 320</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>TFT LCD</p></td>
<td style="text-align: left;"><p>SPI</p></td>
<td style="text-align: left;"><p>AVR 8 bit bus</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications Great pixel display.</p></td>
<td style="text-align: left;"><p>Controller requires 8 ports plus 5 control ports. Typically 13 in total with an UNO shield.</p></td>
<td style="text-align: left;"><p>An very nice display</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>18</p></td>
<td style="text-align: left;"><p>SDD1331</p></td>
<td style="text-align: left;"><p>0.96inch</p></td>
<td style="text-align: left;"><p>96 * 48</p></td>
<td style="text-align: left;"><p>Small</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>OLED</p></td>
<td style="text-align: left;"><p>SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>SPI requires typically 6 in total.</p></td>
<td style="text-align: left;"><p>Very good color OLED display, excellent value for money</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>19</p></td>
<td style="text-align: left;"><p>ILI9326</p></td>
<td style="text-align: left;"><p>3.00inch</p></td>
<td style="text-align: left;"><p>400 * 320</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>OLED</p></td>
<td style="text-align: left;"><p>8 bit bus</p></td>
<td style="text-align: left;"><p>PIC and AVR: 8 bit bus</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 3.3. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>Requires typically 13 in total plus 0v, VCC and LED.</p></td>
<td style="text-align: left;"><p>Good color OLED display, good value for money as it is fast. But, the rotate is all executed in software and this does slow down processing.</p>
<p><br />
The LED connected is typically to ground. You can solder the GND connect to make the backlite permanently on.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>20</p></td>
<td style="text-align: left;"><p>NT7108C</p></td>
<td style="text-align: left;"><p>2.9 inch and less. various sizes</p></td>
<td style="text-align: left;"><p>128 * 64</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Mono</p></td>
<td style="text-align: left;"><p>LCD typically with backlight</p></td>
<td style="text-align: left;"><p>8-bit parallel PIC and AVR: Software device specific protocol</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications 8-bit bus required.</p></td>
<td style="text-align: left;"><p>Look similar to KS0108, but, it is NOT the same, hence this driver.   Uses the Winstar’s WDG0151-TMI module, which is a 128×64 pixel monochromatic display.   This uses two Neotic display controller chips: NT7108C and NT7107C. The WDG0151 module contains two sets of it to drive 128 segments.   On the other hand, the KS0107B (or NT7107C) is a 64-channel common driver which generates the timing signal to control the two KS0108B segment drivers.<br />
<br />
The NT7108C is very sensitive with respect to clock timing.   You may have to adjust to ensure the display operates as correctly.</p></td>
<td style="text-align: left;"><p>Requires 12 ports/connections.</p></td>
<td style="text-align: left;"><p>These are medium cost mono devices.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>21</p></td>
<td style="text-align: left;"><p>T6963_64</p></td>
<td style="text-align: left;"><p>4inches by 2inches</p></td>
<td style="text-align: left;"><p>240 * 64</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Mono</p></td>
<td style="text-align: left;"><p>LCD typically with backlight</p></td>
<td style="text-align: left;"><p>8-bit parallel PIC and AVR: Software device specific protocol</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications 8-bit bus required.</p></td>
<td style="text-align: left;"><p>Operating similar to KS0108 and an LCD. segment drivers.<br />
<br />
</p></td>
<td style="text-align: left;"><p>Requires 12 ports/connections.</p></td>
<td style="text-align: left;"><p>These are medium cost mono devices.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>22</p></td>
<td style="text-align: left;"><p>T6963_128</p></td>
<td style="text-align: left;"><p>4inches by 2inches</p></td>
<td style="text-align: left;"><p>240 * 128</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Mono</p></td>
<td style="text-align: left;"><p>LCD typically with backlight</p></td>
<td style="text-align: left;"><p>8-bit parallel PIC and AVR: Software device specific protocol</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 5. Always check voltage specifications 8-bit bus required.</p></td>
<td style="text-align: left;"><p>Operating similar to KS0108 and an LCD. segment drivers.<br />
<br />
</p></td>
<td style="text-align: left;"><p>Requires 12 ports/connections.</p></td>
<td style="text-align: left;"><p>These are medium cost mono devices.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>23</p></td>
<td style="text-align: left;"><p>UC1601</p></td>
<td style="text-align: left;"><p>4.00inch</p></td>
<td style="text-align: left;"><p>132 * 22</p></td>
<td style="text-align: left;"><p>Medium</p></td>
<td style="text-align: left;"><p>Mono</p></td>
<td style="text-align: left;"><p>OLED</p></td>
<td style="text-align: left;"><p>I2C and SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td>
<td style="text-align: left;"><p>RAM for Full Mode GLCD is 396 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode. Typically operates at VCC 2.8v. Always check voltage specifications Very good display. Driver supports gaming. Minimum RAM required is 396 bytes then add user variables for graphics mode.</p></td>
<td style="text-align: left;"><p>Requires up to 5 ports/connections.</p></td>
<td style="text-align: left;"><p>Low cost device</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>24</p></td>
<td style="text-align: left;"><p>SDD1351</p></td>
<td style="text-align: left;"><p>1.50inch</p></td>
<td style="text-align: left;"><p>128 * 128</p></td>
<td style="text-align: left;"><p>Small</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>OLED</p></td>
<td style="text-align: left;"><p>SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 3.3 or 5. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>SPI requires typically 6 in total.</p></td>
<td style="text-align: left;"><p>Very good color OLED display, excellent value for money</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>25</p></td>
<td style="text-align: left;"><p>Waveshare e-Paper</p></td>
<td style="text-align: left;"><p>Various Size from 2.13 to 7.5 inches</p></td>
<td style="text-align: left;"><p>104 * 112 to 640 * 384</p></td>
<td style="text-align: left;"><p>Small to very large</p></td>
<td style="text-align: left;"><p>Black and White</p></td>
<td style="text-align: left;"><p>Microencapsulated Electrophoretic Display</p></td>
<td style="text-align: left;"><p>SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software I2C, and software SPI</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 3.3. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>SPI requires typically 6 in total.</p></td>
<td style="text-align: left;"><p>Very good color e-Paper displays, excellent value for money Display can operate in text mode only for low RAM microcontrollers using SRAM solution.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>26</p></td>
<td style="text-align: left;"><p>ST7789</p></td>
<td style="text-align: left;"><p>2.0 Inch</p></td>
<td style="text-align: left;"><p>240 * 240 or 320 * 240</p></td>
<td style="text-align: left;"><p>Medium</p></td>
<td style="text-align: left;"><p>Color TFT</p></td>
<td style="text-align: left;"><p>SPI PIC and AVR: Hardware and software SPI</p></td>
<td style="text-align: left;"><p>Typically operates at 3v3. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>+VCC from 3v3. Always check voltage specifications</p></td>
<td style="text-align: left;"><p>Very nice display.</p></td>
<td style="text-align: left;"><p>SPI requires 3 ports (data, clock &amp; command/data) plus 1 port ( reset ). Typically 4 in total.</p></td>
<td style="text-align: left;"><p>Good for cost and performance</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>27</p></td>
<td style="text-align: left;"><p>ST7735R_160_80</p></td>
<td style="text-align: left;"><p>1.8 Inch</p></td>
<td style="text-align: left;"><p>160 * 80</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>TFT LCD</p></td>
<td style="text-align: left;"><p>SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Hardware and software SPI</p></td>
<td style="text-align: left;"><p>Typically operates only at VCC 3.3. Always check voltage specifications Very nice display.</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td>
<td style="text-align: left;"><p>Good for cost and performance</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>28</p></td>
<td style="text-align: left;"><p>ILI9488</p></td>
<td style="text-align: left;"><p>3.2inch</p></td>
<td style="text-align: left;"><p>320 * 240</p></td>
<td style="text-align: left;"><p>Large</p></td>
<td style="text-align: left;"><p>Color</p></td>
<td style="text-align: left;"><p>TFT LCD SPI</p></td>
<td style="text-align: left;"><p>PIC/&amp;AVR: SPI Only</p></td>
<td style="text-align: left;"><p>+VCC from 3v3 to 5. GLCD I/O is ONLY 3v3. Always check voltage specifications.</p></td>
<td style="text-align: left;"><p>Display is good, however, slower than comparable (size) GLCDs as the color definitions are four bytes ( typical color definitions are two bytes)</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p></td>
<td style="text-align: left;"><p>Acceptable GLCD performance.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>29</p></td>
<td style="text-align: left;"><p>ST7567</p></td>
<td style="text-align: left;"><p>1.9inch</p></td>
<td style="text-align: left;"><p>128 * 64</p></td>
<td style="text-align: left;"><p>Medium</p></td>
<td style="text-align: left;"><p>Mono</p></td>
<td style="text-align: left;"><p>LCD</p></td>
<td style="text-align: left;"><p>I2C and SPI</p></td>
<td style="text-align: left;"><p>PIC and AVR: Software I2C, and, hardware software SPI. Harware IC2 fails as the ST7567 does not comply witht the I2C standard.</p></td>
<td style="text-align: left;"><p>+VCC from 3v3 to 5. GLCD I/O is ONLY 3v3. Always check voltage specifications.</p></td>
<td style="text-align: left;"><p>SPI requires 4 ports plus 2 ports. Typically 6 in total.</p>
<p>I2C requires 2 ports.</p></td>
<td style="text-align: left;"><p>Typically operates at VCC 3v3 but may support 5v0. Always check voltage specifications Very good LCD display. Driver supports gaming. Minimum RAM required is 1024 bytes then add user variables for graphics mode.</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Setup:**</span>

You <span class="strong">**must**</span> include the `glcd.h` file at
the top of your program. The file needs to be in brackets as shown
below.

``` screen
    #include <GLCD.h>
```

<span class="strong">**Defines:**</span>

There are several connections that must be defined to use the GLCD
commands with a GLCD display. The <span class="emphasis">*I/O
pin*</span> is the pin on the Microchip PIC or the Atmel AVR
microcontroller that is connected to that specific pin on the graphical
LCD.

<span class="strong">**Example: KS0108 connectivity**</span>

``` screen
    #define GLCD_RW   _I/O pin_ ‘Read/Write pin connection
    #define GLCD_RESET  _I/O pin_ ‘Reset pin connection
    #define GLCD_CS1  _I/O pin_ ‘CS1 pin connection
    #define GLCD_CS2  _I/O pin_ ‘CS2 pin connection
    #define GLCD_RS   _I/O pin_ ‘RS pin connection
    #define GLCD_ENABLE _I/O pin_ ‘Enable pin Connection
    #define GLCD_DB0  _I/O pin_ ‘Data pin 0 Connection
    #define GLCD_DB1  _I/O pin_ ‘Data pin 1 Connection
    #define GLCD_DB2  _I/O pin_ ‘Data pin 2 Connection
    #define GLCD_DB3  _I/O pin_ ‘Data pin 3 Connection
    #define GLCD_DB4  _I/O pin_ ‘Data pin 4 Connection
    #define GLCD_DB5  _I/O pin_ ‘Data pin 5 Connection
    #define GLCD_DB6  _I/O pin_ ‘Data pin 6 Connection
    #define GLCD_DB7  _I/O pin_ ‘Data pin 7 Connection
    #define GLCD_PROTECTOVERRUN 'prevent screen overdrawing     'SSD1306 GLCD only
    #define GLCDDirection       'Invert GLCD Y axis             'KS0108 GCD only
```

Common commands supported across the range of supported GLCDs are:

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**Purpose**</span>                                                  | <span class="strong">**Example**</span>                                                        |
|:----------------------------------------|:-----------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------|
| `GLCDCLS`                               | Clear screen of GLCD                                                                     | `GLCDCLS`                                                                                      |
| `GLCDPrint`                             | Print string of characters on GLCD using GCB font set                                    | `GLCDPrint( Xposition, Yposition, Stringvariable` )                                            |
| `GLCDDrawChar`                          | Print character on GLCD using GCB font set                                               | `GLCDDrawChar( Xposition, Yposition, CharCode )`                                               |
| `GLCDDrawString`                        | Print characters on GLCD using GCB font set                                              | `GLCDDrawString( Xposition, Yposition, Stringvariable )`                                       |
| `Box`                                   | Draw a box on the GLCD to a specific size                                                | `Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )`   |
| `FilledBox`                             | Draw a box on the GLCD to a specific size that is filled with the foreground colour.     | `FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )` |
| `Line`                                  | Draw a line on the GLCD to a specific length that is filled with the specific attribute. | `Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`     |
| `PSet`                                  | Set a pixel on the GLCD at a specific position that is set with the specific attribute.  | `PSet(Xposition, Yposition, Pixel Colour 0 or 1)`                                              |

</div>

  
  

Public variable supported across the range of supported GLCDs are shown
in the table below. These variables control the user definable
parameters of a specific GLCD.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Variable</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Purpose</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Type</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDBackground</code></p></td>
<td style="text-align: left;"><p>Color of GLCD background.</p></td>
<td style="text-align: left;"><p>Can be monochrome or color.<br />
For mono GLCDs the default is White or 0x0001. For color GLCDs the default is White or 0xFFFF.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDForeground</code></p></td>
<td style="text-align: left;"><p>Color of GLCD foreground.</p></td>
<td style="text-align: left;"><p>Can be monochrome or color.<br />
For mono GLCDs the default is non-white or 0x0000. For color GLCDs the default is Black or 0x0000.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Width of the current GLCD font.</p></td>
<td style="text-align: left;"><p>Default is 6 pixels.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDfntDefault</code></p></td>
<td style="text-align: left;"><p>Size of the current GLCD font.</p></td>
<td style="text-align: left;"><p>Default is 0.+ This equates to the standard GCB font set.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDfntDefaultsize</code></p></td>
<td style="text-align: left;"><p>Size of the current GLCD font.</p></td>
<td style="text-align: left;"><p>Default is 1.+ This equates to the 8 pixel high.</p></td>
</tr>
</tbody>
</table>

</div>

For color TFT displays any color can be defined using a valid
hexidecimal word value between 0x0000 to 0xFFFF., see
<http://www.barth-dev.de/online/rgb565-color-picker/> for a wider range
of color parameters.

The following color constants are prevent-defined.

``` screen
    TFT_BLACK       0x0000
    TFT_NAVY        0x000F
    TFT_DARKGREEN   0x03E0
    TFT_DARKCYAN    0x03EF
    TFT_MAROON      0x7800
    TFT_PURPLE      0x780F
    TFT_OLIVE       0x7BE0
    TFT_LIGHTGREY   0xC618
    TFT_DARKGREY    0x7BEF
    TFT_BLUE        0x001F
    TFT_GREEN       0x07E0
    TFT_CYAN        0x07FF
    TFT_RED         0xF800
    TFT_MAGENTA     0xF81F
    TFT_YELLOW      0xFFE0
    TFT_WHITE       0xFFFF
    TFT_ORANGE      0xFD20
    TFT_GREENYELLOW 0xAFE5
    TFT_PINK        0xF81F
```

This example shows how to drive a KS0108 based Graphic LCD module with
the built in commands of GCBASIC. See
<a href="http://www.greatcowbasic.com/sample-projects" class="link">Graphic LCD</a>
for details, this is an external web site.

<span class="strong">**Example:**</span>

``` screen
    ;Chip Settings
    #chip 16F886,16
    '#config MCLRE = on 'enable reset switch on CHIPINO
    #include <GLCD.h>

    ;Defines (Constants)
    #define GLCD_RW PORTB.1  'D9 to pin 5 of LCD
    #define GLCD_RESET PORTB.5 'D13 to pin 17 of LCD
    #define GLCD_CS1 PORTB.3 'D12 to actually since CS1, CS2 can be inverted
    #define GLCD_CS2 PORTB.4 'D11 to actually since CS1, CS2 can be inverted
    #define GLCD_RS PORTB.0  'D8 to pin 4 D/I pin on LCD
    #define GLCD_ENABLE PORTB.2 'D10 to Pin 6 on LCD
    #define GLCD_DB0 PORTC.7 'D0 to pin 7 on LCD
    #define GLCD_DB1 PORTC.6 'D1 to pin 8 on LCD
    #define GLCD_DB2 PORTC.5 'D2 to pin 9 on LCD
    #define GLCD_DB3 PORTC.4 'D3 to pin 10 on LCD
    #define GLCD_DB4 PORTC.3 'D4 to pin 11 on LCD
    #define GLCD_DB5 PORTC.2 'D5 to pin 12 on LCD
    #define GLCD_DB6 PORTC.1 'D6 to pin 13 on LCD
    #define GLCD_DB7 PORTC.0 'D7 to pin 14 on LCD

    Start:
    GLCDCLS
    GLCDPrint 0,10,"Hello"        'Print Hello
    wait 5 s
    GLCDPrint 0,10, "ASCII #:"    'Print ASCII #:
    Box 18,30,28,40               'Draw Box Around ASCII Character
    for char = 15 to 129          'Print 0 through 9
      GLCDPrint 17, 20 , Str(char)+"  "
      GLCDdrawCHAR 20,30, char
      wait 125 ms
    next
    line 0,50,127,50               'Draw Line using line command
    for xvar = 0 to 80             'Draw line using Pset command
        pset xvar,63,on                    '
    next                                        '
    Wait 1 s
    GLCDPrint 0,10,"End  "          'Print Hello
    wait 1 s
    Goto Start
```

<span class="strong">**For more help, see**</span>
<a href="graphical_lcd_demonstration" class="link" title="Graphical LCD Demonstration">Graphical LCD Demonstration</a>,
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>,
<a href="pset" class="link" title="Pset">Pset</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Gosub</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_flow_control.html" title="Flow control"><link rel="prev" href="_for.html" title="For"><link rel="next" href="_goto.html" title="Goto"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_gosub"></a>Gosub</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Gosub <span class="emphasis"><em>label</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Gosub</code> command is used to jump to a label as a subroutine, in a
similar way to <code class="literal">Goto</code>. The difference is that <code class="literal">Return</code> can then be used to
return to the line of code after the <code class="literal">Goto</code>.</p><p><span class="strong"><strong>NOTE</strong></span></p><p><code class="literal">Gosub</code> should NOT be used if it can be avoided. It is not
required to call a subroutine that has been defined using
<a class="link" href="_subroutines.html" title="Subroutines">Sub</a>, just write the name of the subroutine.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will flash an LED on portb bit 0 and play a beep on
    'porta bit 4. until the microcontroller is turned off.

    #chip 16F628A, 4 'Change this to suit your circuit

    #define SOUNDOUT PORTA.4
    #define LIGHT PORTB.0
    Dir LIGHT Out

    Do
    	'Flash Light
    	PulseOut LIGHT, 1 s
    	Wait 1 s
    	'Beep
    	Gosub PlayBeep
    Loop

    PlayBeep:
    Tone 200, 10
    Tone 100, 10
    Return</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_goto.html" title="Goto">Goto</a></strong></span> and <span class="strong"><strong><a class="link" href="_labels.html" title="Labels">Labels</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="gosub"></span>Gosub

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Gosub label
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Gosub` command is used to jump to a label as a subroutine, in a
similar way to `Goto`. The difference is that `Return` can then be used
to return to the line of code after the `Goto`.

<span class="strong">**NOTE**</span>

`Gosub` should NOT be used if it can be avoided. It is not required to
call a subroutine that has been defined using
<a href="subroutines" class="link" title="Subroutines">Sub</a>,
just write the name of the subroutine.

<span class="strong">**Example:**</span>

``` screen
    'This program will flash an LED on portb bit 0 and play a beep on
    'porta bit 4. until the microcontroller is turned off.

    #chip 16F628A, 4 'Change this to suit your circuit

    #define SOUNDOUT PORTA.4
    #define LIGHT PORTB.0
    Dir LIGHT Out

    Do
        'Flash Light
        PulseOut LIGHT, 1 s
        Wait 1 s
        'Beep
        Gosub PlayBeep
    Loop

    PlayBeep:
    Tone 200, 10
    Tone 100, 10
    Return
```

<span class="strong">**For more help, see
<a href="goto" class="link" title="Goto">Goto</a>**</span> and
<span
class="strong">**<a href="labels" class="link" title="Labels">Labels</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Goto</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_flow_control.html" title="Flow control"><link rel="prev" href="_gosub.html" title="Gosub"><link rel="next" href="_if.html" title="If"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_goto"></a>Goto</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Goto <span class="emphasis"><em>label</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Goto</code> command will make the microcontroller jump to the line specified, and
continue running the program from there. The <code class="literal">Goto</code> command is mainly
useful for exiting out of loops - if you need to create an infinite
loop, use the <code class="literal">Do</code> command instead.</p><p>Be careful how you use <code class="literal">Goto</code>. If used too much, it can make programs very
hard to read.</p><p>To define a label, put the name of the label alone on a line, with just
a colon (:) after it.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will flash the light until the button is pressed
    'off. Notice the label named SWITCH_OFF.

    #chip 16F628A, 4 'Change this line to suit your circuit

    #define BUTTON PORTB.0
    #define LIGHT PORTB.1
    Dir BUTTON In
    Dir LIGHT Out

    Do
    	PulseOut LIGHT, 500 ms
    	If BUTTON = 1 Then Goto SWITCH_OFF
    	Wait 500 ms
    	If BUTTON = 1 Then Goto SWITCH_OFF
    Loop

    SWITCH_OFF:
    Set LIGHT Off
    'Chip will enter low power mode when program ends</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_gosub.html" title="Gosub">Gosub</a></strong></span> and <span class="strong"><strong><a class="link" href="_labels.html" title="Labels">Labels</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="goto"></span>Goto

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Goto label
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Goto` command will make the microcontroller jump to the line
specified, and continue running the program from there. The `Goto`
command is mainly useful for exiting out of loops - if you need to
create an infinite loop, use the `Do` command instead.

Be careful how you use `Goto`. If used too much, it can make programs
very hard to read.

To define a label, put the name of the label alone on a line, with just
a colon (:) after it.

<span class="strong">**Example:**</span>

``` screen
    'This program will flash the light until the button is pressed
    'off. Notice the label named SWITCH_OFF.

    #chip 16F628A, 4 'Change this line to suit your circuit

    #define BUTTON PORTB.0
    #define LIGHT PORTB.1
    Dir BUTTON In
    Dir LIGHT Out

    Do
        PulseOut LIGHT, 500 ms
        If BUTTON = 1 Then Goto SWITCH_OFF
        Wait 500 ms
        If BUTTON = 1 Then Goto SWITCH_OFF
    Loop

    SWITCH_OFF:
    Set LIGHT Off
    'Chip will enter low power mode when program ends
```

<span class="strong">**For more help, see
<a href="gosub" class="link" title="Gosub">Gosub</a>**</span> and
<span
class="strong">**<a href="labels" class="link" title="Labels">Labels</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Graphical GCBASIC</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_trigonometry_circle.html" title="Trigonometry Circle"><link rel="next" href="_code_documentation.html" title="Code Documentation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_graphical_gcbasic"></a>Graphical GCBASIC</h2></div></div></div><p>This is the Graphical GCBASIC section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="graphical_gcbasic"></span>Graphical GCBASIC
------------------------------------------------------

</div>

</div>

</div>

This is the Graphical GCBASIC section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Graphical LCD</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_keypadraw.html" title="KeypadRaw"><link rel="next" href="_glcd_overview.html" title="GLCD Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_graphical_lcd"></a>Graphical LCD</h3></div></div></div><p>This is the GLCD section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="graphical_lcd"></span>Graphical LCD

</div>

</div>

</div>

This is the GLCD section of the Help file. Please refer the sub-sections
for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Graphical LCD Demonstration</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_programs.html" title="Example Programs"><link rel="prev" href="_generate_accurate_pulses.html" title="Generate Accurate Pulses"><link rel="next" href="_infrared_remote.html" title="InfraRed Remote"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_graphical_lcd_demonstration"></a>Graphical LCD Demonstration</h3></div></div></div><p><span class="strong"><strong>Explanation:</strong></span></p><p>This demonstration code shows the set of commands supported by GCBASIC.</p><p><span class="strong"><strong>Demonstration program:</strong></span></p><pre class="screen">    ;Chip Settings
    #chip 16F877a,16

    #include &lt;glcd.h&gt;

    'Setup the GLCD
    #Define glcd_rw PORTD.3       'RW pin on LCD
    #Define glcd_reset PORTD.4    'Reset pin on LCD
    #Define glcd_cs1 PORTD.1      'CS1, CS2 can be reversed
    #Define glcd_cs2 PORTD.2      'CS1, CS2 are be reversed
    #Define glcd_rs PORTD.5       'D/I pin on LCD
    #Define glcd_enable PORTD.4   'E pin on LCD
    #Define glcd_db0 PORTB.0  'D0
    #Define glcd_db1 PORTB.1  'D1
    #Define glcd_db2 PORTB.2  'D2
    #Define glcd_db3 PORTB.3  'D3
    #Define glcd_db4 PORTB.4  'D4
    #Define glcd_db5 PORTB.5  'D5
    #Define glcd_db6 PORTB.6  'D6
    #Define glcd_db7 PORTB.7  'D7 on LCD

    'Specify the type of GLCD
    #define GLCD_TYPE GLCD_TYPE_KS0108
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 64
    #define GLCD_PROTECTOVERRUN

    wait 1 s
    GLCDCLS
    GLCDPrint 0, 1, "GCBASIC "
    wait 1 s
    GLCDCLS

    rrun = 0
    dim msg1 as string * 16

    do forever

      GLCDCLS
      Box 18,30,28,40
      Line 0,0,127,63
      Line 0,63,127,0
      wait 1 s

      FilledBox 18,30,28,40
      wait 1 s

      GLCDCLS

        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        Circle(10,10,10,1)              'upper left
        Circle(117,10,10,1)             'upper right
        Circle(63,31,10,1)              'center
        Circle(63,31,20,1)              'center
        Circle(10,53,10,1)              'lower left
        Circle(117,53,10,1)             'lower right
        wait 1 s

        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        FilledCircle(10,10,10,1)         'upper left
        FilledCircle(117,10,10,1)        'upper right
        FilledCircle(63,31,10,1)         'center
        FilledCircle(63,31,20,1)         'center
        FilledCircle(10,53,10,1)         'lower left
        FilledCircle(117,53,10,1)        'lower right
        wait 1 s

        GLCDCLS
        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        Circle(10,0,10,1)                 'upper left
        Circle(117,0,10,1)                'upper right
        Circle(63,31,10,1)                'center
        Circle(63,31,20,1)                'center
        Circle(10,63,10,1)                'lower left
        Circle(117,63,10,1)               'lower right
        wait 1 s

        GLCDCLS
        GLCDDrawString 0,10,"Hello" 'Print Hello
        wait 1 s
        GLCDDrawString 0,10, "ASCII #:"    'Print ASCII #:
        Box 18,30,28,40                    'Draw Box Around ASCII Character
        for char = 0x30 to 0x39            'Print 0 through 9
          GLCDDrawString 16, 20 , Str(char)+"  "
          GLCDdrawCHAR 20, 30, char
          wait 250 ms
        next
        line 0,50,127,50                    'Draw Line using line command
        for xvar = 0 to 80                  'Draw line using Pset command
            pset xvar,63,on
        next
        FilledBox 18,30,28,40               'Draw Box Around ASCII Character '
        wait 1 s
        GLCDCLS
        GLCDDrawString 0,10,"End  "
        wait 1 s
        GLCDCLS

        workingGLCDDrawChar:
        dim gtext as string
        gtext = "KS0108"

            for xchar = 1 to gtext(0)      'Print 0 through 9
              xxpos = (1+(xchar*6)-6)
              GLCDDrawChar xxpos , 0 , gtext(xchar)
           next

        GLCDDrawString  1, 9, "GCBASIC @2021"
        GLCDDrawString  1, 18,"GLCD 128*64"
        GLCDDrawString  1, 27,"Using GLCD.H from GCB"
        GLCDDrawString  1, 37,"Using GLCD.H GCB@2021"
        GLCDDrawString  1, 45,"GLCDDrawChar method"
        GLCDDrawString  1, 54,"Test Routines"

        wait 1 s
        GLCDCLS

        msg1 = "Run = " +str(rrun)
        rrun++
        GLCDPrint 0, 3, msg1
        wait 1 s
        GLCDCLS

    loop</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_graphical_lcd_demonstration.html" title="Graphical LCD Demonstration">Graphical LCD Demonstration</a>,
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>,
<a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>,
<a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>,
<a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a>, <a class="link" href="_pset.html" title="Pset">Pset</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="graphical_lcd_demonstration"></span>Graphical LCD Demonstration

</div>

</div>

</div>

<span class="strong">**Explanation:**</span>

This demonstration code shows the set of commands supported by GCBASIC.

<span class="strong">**Demonstration program:**</span>

``` screen
    ;Chip Settings
    #chip 16F877a,16

    #include <glcd.h>

    'Setup the GLCD
    #Define glcd_rw PORTD.3       'RW pin on LCD
    #Define glcd_reset PORTD.4    'Reset pin on LCD
    #Define glcd_cs1 PORTD.1      'CS1, CS2 can be reversed
    #Define glcd_cs2 PORTD.2      'CS1, CS2 are be reversed
    #Define glcd_rs PORTD.5       'D/I pin on LCD
    #Define glcd_enable PORTD.4   'E pin on LCD
    #Define glcd_db0 PORTB.0  'D0
    #Define glcd_db1 PORTB.1  'D1
    #Define glcd_db2 PORTB.2  'D2
    #Define glcd_db3 PORTB.3  'D3
    #Define glcd_db4 PORTB.4  'D4
    #Define glcd_db5 PORTB.5  'D5
    #Define glcd_db6 PORTB.6  'D6
    #Define glcd_db7 PORTB.7  'D7 on LCD

    'Specify the type of GLCD
    #define GLCD_TYPE GLCD_TYPE_KS0108
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 64
    #define GLCD_PROTECTOVERRUN

    wait 1 s
    GLCDCLS
    GLCDPrint 0, 1, "GCBASIC "
    wait 1 s
    GLCDCLS

    rrun = 0
    dim msg1 as string * 16

    do forever

      GLCDCLS
      Box 18,30,28,40
      Line 0,0,127,63
      Line 0,63,127,0
      wait 1 s

      FilledBox 18,30,28,40
      wait 1 s

      GLCDCLS

        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        Circle(10,10,10,1)              'upper left
        Circle(117,10,10,1)             'upper right
        Circle(63,31,10,1)              'center
        Circle(63,31,20,1)              'center
        Circle(10,53,10,1)              'lower left
        Circle(117,53,10,1)             'lower right
        wait 1 s

        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        FilledCircle(10,10,10,1)         'upper left
        FilledCircle(117,10,10,1)        'upper right
        FilledCircle(63,31,10,1)         'center
        FilledCircle(63,31,20,1)         'center
        FilledCircle(10,53,10,1)         'lower left
        FilledCircle(117,53,10,1)        'lower right
        wait 1 s

        GLCDCLS
        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        Circle(10,0,10,1)                 'upper left
        Circle(117,0,10,1)                'upper right
        Circle(63,31,10,1)                'center
        Circle(63,31,20,1)                'center
        Circle(10,63,10,1)                'lower left
        Circle(117,63,10,1)               'lower right
        wait 1 s

        GLCDCLS
        GLCDDrawString 0,10,"Hello" 'Print Hello
        wait 1 s
        GLCDDrawString 0,10, "ASCII #:"    'Print ASCII #:
        Box 18,30,28,40                    'Draw Box Around ASCII Character
        for char = 0x30 to 0x39            'Print 0 through 9
          GLCDDrawString 16, 20 , Str(char)+"  "
          GLCDdrawCHAR 20, 30, char
          wait 250 ms
        next
        line 0,50,127,50                    'Draw Line using line command
        for xvar = 0 to 80                  'Draw line using Pset command
            pset xvar,63,on
        next
        FilledBox 18,30,28,40               'Draw Box Around ASCII Character '
        wait 1 s
        GLCDCLS
        GLCDDrawString 0,10,"End  "
        wait 1 s
        GLCDCLS

        workingGLCDDrawChar:
        dim gtext as string
        gtext = "KS0108"

            for xchar = 1 to gtext(0)      'Print 0 through 9
              xxpos = (1+(xchar*6)-6)
              GLCDDrawChar xxpos , 0 , gtext(xchar)
           next

        GLCDDrawString  1, 9, "GCBASIC @2021"
        GLCDDrawString  1, 18,"GLCD 128*64"
        GLCDDrawString  1, 27,"Using GLCD.H from GCB"
        GLCDDrawString  1, 37,"Using GLCD.H GCB@2021"
        GLCDDrawString  1, 45,"GLCDDrawChar method"
        GLCDDrawString  1, 54,"Test Routines"

        wait 1 s
        GLCDCLS

        msg1 = "Run = " +str(rrun)
        rrun++
        GLCDPrint 0, 3, msg1
        wait 1 s
        GLCDCLS

    loop
```

<span class="strong">**For more help, see**</span>
<a href="graphical_lcd_demonstration" class="link" title="Graphical LCD Demonstration">Graphical LCD Demonstration</a>,
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>,
<a href="pset" class="link" title="Pset">Pset</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Hardware PWM Code Optimisation</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microchip_pic_pwm_overview.html" title="Microchip PIC PWM Overview"><link rel="prev" href="_pwmoff.html" title="PWMOff"><link rel="next" href="_atmel_avr_pwm_overview.html" title="ATMEL AVR PWM Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hardware_pwm_code_optimisation"></a>Hardware PWM Code Optimisation</h5></div></div></div><p><span class="strong"><strong>About Hardware PWM Code Optimisation</strong></span></p><p>For compatibility all channels are supported by default.  This is maintains backward compatibility.<br></p><p>To mimise the code, use the following to disable support for a specific Capture/Compare/PWM (CCP) module, timers or the PWM module.<br></p><p>Setting a constant to <span class="emphasis"><em>FALSE</em></span> will remove the support of the capability from the method and therefore will reduce the program size.</p><pre class="screen">    #define USE_HPWMCCP1 FALSE
    #define USE_HPWMCCP2 FALSE
    #define USE_HPWMCCP3 FALSE
    #define USE_HPWMCCP4 FALSE</pre><p>To further mimise the code, use the following to disable support for a specific PWM channels.  Only PWM channels 5, 6 and 7 are supported.</p><pre class="screen">    #define USE_HPWM3 FALSE
    #define USE_HPWM4 FALSE
    #define USE_HPWM5 FALSE
    #define USE_HPWM6 FALSE
    #define USE_HPWM7 FALSE</pre><p>To further mimise the code, use the following to disable support for a specific timers.</p><pre class="screen">    #define USE_HPWM_TIMER2 TRUE
    #define USE_HPWM_TIMER4 TRUE
    #define USE_HPWM_TIMER6 TRUE</pre><p><span class="strong"><strong>Example</strong></span></p><p>This will save 335 bytes of program memory by removing support for CCP1, CCP2 and CCP4.</p><pre class="screen">    #chip 16f18855,32
    #Config MCLRE_ON

    UNLOCKPPS
        RC2PPS = 0x0A       'RC2-&gt;CCP2:CCP2;
    LOCKPPS

    #define USE_HPWMCCP1 FALSE       ' This is not used so optimise
    #define USE_HPWMCCP2 TRUE        ' This is used so include in the compiled code
    #define USE_HPWMCCP3 FALSE       ' This is not used so optimise
    #define USE_HPWMCCP4 FALSE       ' This is not used so optimise


    'Setting the port an output is VERY important... LED will not work if you do not set as an output.
    dir portC.2 out    ; CCP2

    do forever
            For Bright = 1 to 255
                HPWM 2, 40, Bright
                wait 10 ms
            next

    loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hardware_pwm_code_optimisation"></span>Hardware PWM Code Optimisation

</div>

</div>

</div>

<span class="strong">**About Hardware PWM Code Optimisation**</span>

For compatibility all channels are supported by default. This is
maintains backward compatibility.  

To mimise the code, use the following to disable support for a specific
Capture/Compare/PWM (CCP) module, timers or the PWM module.  

Setting a constant to <span class="emphasis">*FALSE*</span> will remove
the support of the capability from the method and therefore will reduce
the program size.

``` screen
    #define USE_HPWMCCP1 FALSE
    #define USE_HPWMCCP2 FALSE
    #define USE_HPWMCCP3 FALSE
    #define USE_HPWMCCP4 FALSE
```

To further mimise the code, use the following to disable support for a
specific PWM channels. Only PWM channels 5, 6 and 7 are supported.

``` screen
    #define USE_HPWM3 FALSE
    #define USE_HPWM4 FALSE
    #define USE_HPWM5 FALSE
    #define USE_HPWM6 FALSE
    #define USE_HPWM7 FALSE
```

To further mimise the code, use the following to disable support for a
specific timers.

``` screen
    #define USE_HPWM_TIMER2 TRUE
    #define USE_HPWM_TIMER4 TRUE
    #define USE_HPWM_TIMER6 TRUE
```

<span class="strong">**Example**</span>

This will save 335 bytes of program memory by removing support for CCP1,
CCP2 and CCP4.

``` screen
    #chip 16f18855,32
    #Config MCLRE_ON

    UNLOCKPPS
        RC2PPS = 0x0A       'RC2->CCP2:CCP2;
    LOCKPPS

    #define USE_HPWMCCP1 FALSE       ' This is not used so optimise
    #define USE_HPWMCCP2 TRUE        ' This is used so include in the compiled code
    #define USE_HPWMCCP3 FALSE       ' This is not used so optimise
    #define USE_HPWMCCP4 FALSE       ' This is not used so optimise


    'Setting the port an output is VERY important... LED will not work if you do not set as an output.
    dir portC.2 out    ; CCP2

    do forever
            For Bright = 1 to 255
                HPWM 2, 40, Bright
                wait 10 ms
            next

    loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HEFEraseBlock</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hefm_pfm.html" title="HEFM ( PFM )"><link rel="prev" href="_hefwriteblock.html" title="HEFWriteBlock"><link rel="next" href="_progmem_pfm.html" title="PROGMEM ( PFM )"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_heferaseblock"></a>HEFEraseBlock</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HEFEraseBlock ( block_number )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with HEFM memory.</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
HEFEraseBlock is used to erase all data locations within the HEFM block.&nbsp;&nbsp;&nbsp; HEFM data within the HEFM block to the erase state value of the device.&nbsp;&nbsp;&nbsp;
This Value is 0xFF and will read 0x3FFF if the entire 14bit program memory word is displayed.
Use Caution. Once the HEFM block is erased, the HEFM data is gone forever and cannot be recovered unless it was previpusly saved.
<br>
<br>
The single parameter is as follows:</p><p><code class="literal">block_number</code> represents the block to be erased.&nbsp;&nbsp;&nbsp;
The block_number parameter is used to calculate the physical memory location(s) that are updated.
<br>
<br></p><p><span class="strong"><strong>Example 1:</strong></span></p><p>Erase a specific block of HEFM.</p><pre class="screen">    '... code preamble to select part
    '... code to setup serial, if needed


    'Erase block 2 of HEFM
    HEFEraseBlock ( 2)</pre><p><br>
<br>
See also
<a class="link" href="_hefm_overview.html" title="HEFM Overview">HEFM Overview</a>,
<a class="link" href="_hefread.html" title="HEFRead">HEFRead</a>,
<a class="link" href="_hefreadword.html" title="HEFReadWord">HEFReadWord</a>,
<a class="link" href="_hefwrite.html" title="HEFWrite">HEFWrite</a>,
<a class="link" href="_hefwriteword.html" title="HEFWriteWord">HEFWriteWord</a>,
<a class="link" href="_hefreadblock.html" title="HEFReadBlock">HEFReadBlock</a>,
<a class="link" href="_hefwriteblock.html" title="HEFWriteBlock">HEFWriteBlock</a>,
<a class="link" href="_heferaseblock.html" title="HEFEraseBlock">HEFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="heferaseblock"></span>HEFEraseBlock

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HEFEraseBlock ( block_number )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with HEFM memory.

<span class="strong">**Explanation:**</span>  
  
HEFEraseBlock is used to erase all data locations within the HEFM
block.    HEFM data within the HEFM block to the erase state value of
the device.    This Value is 0xFF and will read 0x3FFF if the entire
14bit program memory word is displayed. Use Caution. Once the HEFM block
is erased, the HEFM data is gone forever and cannot be recovered unless
it was previpusly saved.  
  
The single parameter is as follows:

`block_number` represents the block to be erased.    The block\_number
parameter is used to calculate the physical memory location(s) that are
updated.  
  

<span class="strong">**Example 1:**</span>

Erase a specific block of HEFM.

``` screen
    '... code preamble to select part
    '... code to setup serial, if needed


    'Erase block 2 of HEFM
    HEFEraseBlock ( 2)
```

  
  
See also
<a href="hefm_overview" class="link" title="HEFM Overview">HEFM Overview</a>,
<a href="hefread" class="link" title="HEFRead">HEFRead</a>,
<a href="hefreadword" class="link" title="HEFReadWord">HEFReadWord</a>,
<a href="hefwrite" class="link" title="HEFWrite">HEFWrite</a>,
<a href="hefwriteword" class="link" title="HEFWriteWord">HEFWriteWord</a>,
<a href="hefreadblock" class="link" title="HEFReadBlock">HEFReadBlock</a>,
<a href="hefwriteblock" class="link" title="HEFWriteBlock">HEFWriteBlock</a>,
<a href="heferaseblock" class="link" title="HEFEraseBlock">HEFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HEFM Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hefm_pfm.html" title="HEFM ( PFM )"><link rel="prev" href="_hefm_pfm.html" title="HEFM ( PFM )"><link rel="next" href="_hefread.html" title="HEFRead"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hefm_overview"></a>HEFM Overview</h5></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>Some enhanced mid-range Microchip PIC devices support High-Endurance Flash (HEF) memory. These devices lack the data EEPROM found on other devices.&nbsp;&nbsp;&nbsp;
Instead, they implement an equivalent amount of special flash memory, called HEF memory, that can provide an endurance comparable to that of a traditional data EEPROM.&nbsp;&nbsp;&nbsp;
HEF memory can be erased and written 100,000 times.&nbsp;&nbsp;&nbsp;
HEF memory appears in the regular program memory space and can be used for any purpose, like regular flash program memory.&nbsp;&nbsp;&nbsp;
<br>
<br>
As with all flash memory, data must be erased before it can be written and writing this memory will stall the device.&nbsp;&nbsp;&nbsp;
Methods to read, write and erase the HEF memory are included in GCBASIC and they are described in this introduction.&nbsp;&nbsp;&nbsp;Also see Microchip application note AN1673, Using the PIC16F1XXX High-Endurance Flash (HEF) Block.
<br>
<br>
The <code class="literal">hefsaf.h</code> library supports HEF operations for GCBASIC.
<br>
<br>
Note:  By default, GCBASIC will use HEF memory for regular executable code unless it is told otherwise.&nbsp;&nbsp;&nbsp;
If you wish to store data here, you should reserve the HEF memory by using the compiler option, as shown below to reserve 128 words of HEF memory:</p><pre class="screen">    #option ReserveHighProg 128</pre><p>HEF memory is a block of memory locations found at the top of the flash program memory.    &nbsp;&nbsp;&nbsp;
Each memory location can be used to hold a 8-bit byte value.    &nbsp;&nbsp;&nbsp;
To further explain, the PIC 16F Enhanced Midrange Sevices memory architecture is 14-bits wide. &nbsp;&nbsp;&nbsp;   Therefore, for a single 14-bit memory location it is only practical to store an 8-bit byte value, and two 14-bit memory locations to hold one 16-bit word value.    &nbsp;&nbsp;&nbsp;
This is because the memory architecture only allows the use of the the lower 8-bits  of each 14-bit flash memory location for HEF usage
<br>
<br>
The main difference between HEF memory and EEPROM is that EEPROM allows byte-by-byte erase whereas the HEF memory does not.&nbsp;&nbsp;&nbsp;
With HEF memory, data must be erased before a write and the erase can only be performed in blocks of memory.&nbsp;&nbsp;&nbsp;
The blocks, also called rows, are a fixed size associated with the specific device.&nbsp;&nbsp;&nbsp;
<br>
<br>
GCBASIC handles the erase operation automatically.&nbsp;&nbsp;&nbsp;
When a write operation is used by a user the GCBASIC library reads to a cache, updates the cache, erase the block and finally write the caches.&nbsp;&nbsp;&nbsp;
The complexity of using HEF memory is reduced with the automatically handling of these operations.&nbsp;&nbsp;&nbsp;</p><p><br>
<br>
The <code class="literal">hefsaf.h</code> library provides a set of methods to support the use of HEF memory.
<br>
<br></p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top"><p>Method</p></td><td align="left" valign="top"><p>Parameters</p></td><td align="left" valign="top"><p>Usage</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFWrite</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: location, byte value</p></td><td align="left" valign="top"><p>HEFWrite ( location, byte_variable )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFWriteWord</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: location, word_value</p></td><td align="left" valign="top"><p>HEFWriteWord ( location, word_variable  )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFRead</code></p></td><td align="left" valign="top"><p>a function with the parameters: location returns a byte value</p></td><td align="left" valign="top"><p>byte_variable = HEFRead ( location  )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFRead</code></p></td><td align="left" valign="top"><p>a subroutine with the paramers: location, byte_value</p></td><td align="left" valign="top"><p>HEFRead ( location , out_byte_variable )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFReadWord</code></p></td><td align="left" valign="top"><p>a function with the parameters: location returns a word value</p></td><td align="left" valign="top"><p>word_variable = HEFRead ( location  )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFReadWord</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: location, word_value</p></td><td align="left" valign="top"><p>HEFRead ( location , out_word_variable )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFEraseBlock</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: block_number</p></td><td align="left" valign="top"><p>HEFEraseBlock ( 0 )
<br>
<br>
A value of 0,1,2,3 etc.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFWriteBlock</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: block_number, buffer() [, HEF_ROWSIZE_BYTES ]</p></td><td align="left" valign="top"><p>HEFWriteBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String
<br>
<br>
The Array or a String will contain the values to be wrttin to the HEFM.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFReadBlock</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: block_number, buffer() [, HEF_ROWSIZE_BYTES ]</p></td><td align="left" valign="top"><p>HEFReadBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String.
<br>
<br>
The Array or a String will contain the values from the HEFM.</p></td></tr></tbody></table></div><p><br>
<br>
The library also defines a set constants that are specific to the device.&nbsp;&nbsp;&nbsp;
These may be useful in the user program.&nbsp;&nbsp;&nbsp;
These constants are used by the library.&nbsp;&nbsp;&nbsp;
A user may use these public constants.
<br>
<br></p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Type</p></td><td align="left" valign="top"><p>Usage</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEF_ROWSIZE_BYTES</code></p></td><td align="left" valign="top"><p>Byte</p></td><td align="left" valign="top"><p>Size of an HEFM block in words</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEF_WORDS</code> and <code class="literal">HEF_BYTES</code></p></td><td align="left" valign="top"><p>Word or a Byte</p></td><td align="left" valign="top"><p>ChipHEFMemWords parameter from the device .dat file</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEF_START_ADDR</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Starting address of HEFM</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEF_NUM_BLOCKS</code></p></td><td align="left" valign="top"><p>Byte</p></td><td align="left" valign="top"><p>Number of blocks of HEFM</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPWORDS</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Device specific constant for the total flash size</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPHEFMEMWORDS</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Device specific constant for the number of HEFM words available</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPERASEROWSIZEWORDS</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Device specific constant for the number of HEFM in an erase row</p></td></tr></tbody></table></div><p><br>
<br></p><p><br>
<br></p><p><span class="strong"><strong>Warning</strong></span></p><p>Whenever you update the hex file of your Microchip PIC micro-controller with your programmer you MAY erase the data that are stored in HEF memory.&nbsp;&nbsp;&nbsp;
If you want to avoid that you will have to flash your Microchip PIC micro-controller with software that allows memory exclusion when flashing.&nbsp;&nbsp;&nbsp;
This is the case with Microchip PIC MPLAB IPE (Go to <code class="literal">Advanced Mode/Enter password/Select Memory/Tick &#8220;Preserve Flash on Program&#8221;/
Enter Start and End address</code> of your HEFM).&nbsp;&nbsp;&nbsp;Or, simply use the PICkitPlus suite of software to preserve HEF memory during programming.
<br>
<br>
See also
<a class="link" href="_hefread.html" title="HEFRead">HEFRead</a>,
<a class="link" href="_hefreadword.html" title="HEFReadWord">HEFReadWord</a>,
<a class="link" href="_hefwrite.html" title="HEFWrite">HEFWrite</a>,
<a class="link" href="_hefwriteword.html" title="HEFWriteWord">HEFWriteWord</a>,
<a class="link" href="_hefreadblock.html" title="HEFReadBlock">HEFReadBlock</a>,
<a class="link" href="_hefwriteblock.html" title="HEFWriteBlock">HEFWriteBlock</a>,
<a class="link" href="_heferaseblock.html" title="HEFEraseBlock">HEFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hefm_overview"></span>HEFM Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

Some enhanced mid-range Microchip PIC devices support High-Endurance
Flash (HEF) memory. These devices lack the data EEPROM found on other
devices.    Instead, they implement an equivalent amount of special
flash memory, called HEF memory, that can provide an endurance
comparable to that of a traditional data EEPROM.    HEF memory can be
erased and written 100,000 times.    HEF memory appears in the regular
program memory space and can be used for any purpose, like regular flash
program memory.     
  
As with all flash memory, data must be erased before it can be written
and writing this memory will stall the device.    Methods to read, write
and erase the HEF memory are included in GCBASIC and they are described
in this introduction.   Also see Microchip application note AN1673,
Using the PIC16F1XXX High-Endurance Flash (HEF) Block.  
  
The `hefsaf.h` library supports HEF operations for GCBASIC.  
  
Note: By default, GCBASIC will use HEF memory for regular executable
code unless it is told otherwise.    If you wish to store data here, you
should reserve the HEF memory by using the compiler option, as shown
below to reserve 128 words of HEF memory:

``` screen
    #option ReserveHighProg 128
```

HEF memory is a block of memory locations found at the top of the flash
program memory.     Each memory location can be used to hold a 8-bit
byte value.     To further explain, the PIC 16F Enhanced Midrange
Sevices memory architecture is 14-bits wide.     Therefore, for a single
14-bit memory location it is only practical to store an 8-bit byte
value, and two 14-bit memory locations to hold one 16-bit word value.
    This is because the memory architecture only allows the use of the
the lower 8-bits of each 14-bit flash memory location for HEF usage  
  
The main difference between HEF memory and EEPROM is that EEPROM allows
byte-by-byte erase whereas the HEF memory does not.    With HEF memory,
data must be erased before a write and the erase can only be performed
in blocks of memory.    The blocks, also called rows, are a fixed size
associated with the specific device.     
  
GCBASIC handles the erase operation automatically.    When a write
operation is used by a user the GCBASIC library reads to a cache,
updates the cache, erase the block and finally write the caches.    The
complexity of using HEF memory is reduced with the automatically
handling of these operations.   

  
  
The `hefsaf.h` library provides a set of methods to support the use of
HEF memory.  
  

<div class="informaltable">

<table data-border="1" width="80%">
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Method</p></td>
<td style="text-align: left;"><p>Parameters</p></td>
<td style="text-align: left;"><p>Usage</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HEFWrite</code></p></td>
<td style="text-align: left;"><p>a subroutine with the parameters: location, byte value</p></td>
<td style="text-align: left;"><p>HEFWrite ( location, byte_variable )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">HEFWriteWord</code></p></td>
<td style="text-align: left;"><p>a subroutine with the parameters: location, word_value</p></td>
<td style="text-align: left;"><p>HEFWriteWord ( location, word_variable )</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HEFRead</code></p></td>
<td style="text-align: left;"><p>a function with the parameters: location returns a byte value</p></td>
<td style="text-align: left;"><p>byte_variable = HEFRead ( location )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">HEFRead</code></p></td>
<td style="text-align: left;"><p>a subroutine with the paramers: location, byte_value</p></td>
<td style="text-align: left;"><p>HEFRead ( location , out_byte_variable )</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HEFReadWord</code></p></td>
<td style="text-align: left;"><p>a function with the parameters: location returns a word value</p></td>
<td style="text-align: left;"><p>word_variable = HEFRead ( location )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">HEFReadWord</code></p></td>
<td style="text-align: left;"><p>a subroutine with the parameters: location, word_value</p></td>
<td style="text-align: left;"><p>HEFRead ( location , out_word_variable )</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HEFEraseBlock</code></p></td>
<td style="text-align: left;"><p>a subroutine with the parameters: block_number</p></td>
<td style="text-align: left;"><p>HEFEraseBlock ( 0 )<br />
<br />
A value of 0,1,2,3 etc.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">HEFWriteBlock</code></p></td>
<td style="text-align: left;"><p>a subroutine with the parameters: block_number, buffer() [, HEF_ROWSIZE_BYTES ]</p></td>
<td style="text-align: left;"><p>HEFWriteBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String<br />
<br />
The Array or a String will contain the values to be wrttin to the HEFM.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HEFReadBlock</code></p></td>
<td style="text-align: left;"><p>a subroutine with the parameters: block_number, buffer() [, HEF_ROWSIZE_BYTES ]</p></td>
<td style="text-align: left;"><p>HEFReadBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String.<br />
<br />
The Array or a String will contain the values from the HEFM.</p></td>
</tr>
</tbody>
</table>

</div>

  
  
The library also defines a set constants that are specific to the
device.    These may be useful in the user program.    These constants
are used by the library.    A user may use these public constants.  
  

<div class="informaltable">

|                             |                |                                                                 |
|:----------------------------|:---------------|:----------------------------------------------------------------|
| Constant                    | Type           | Usage                                                           |
| `HEF_ROWSIZE_BYTES`         | Byte           | Size of an HEFM block in words                                  |
| `HEF_WORDS` and `HEF_BYTES` | Word or a Byte | ChipHEFMemWords parameter from the device .dat file             |
| `HEF_START_ADDR`            | Word           | Starting address of HEFM                                        |
| `HEF_NUM_BLOCKS`            | Byte           | Number of blocks of HEFM                                        |
| `CHIPWORDS`                 | Word           | Device specific constant for the total flash size               |
| `CHIPHEFMEMWORDS`           | Word           | Device specific constant for the number of HEFM words available |
| `CHIPERASEROWSIZEWORDS`     | Word           | Device specific constant for the number of HEFM in an erase row |

</div>

  
  

  
  

<span class="strong">**Warning**</span>

Whenever you update the hex file of your Microchip PIC micro-controller
with your programmer you MAY erase the data that are stored in HEF
memory.    If you want to avoid that you will have to flash your
Microchip PIC micro-controller with software that allows memory
exclusion when flashing.    This is the case with Microchip PIC MPLAB
IPE (Go to
`Advanced Mode/Enter password/Select Memory/Tick “Preserve Flash on Program”/ Enter Start and End address`
of your HEFM).   Or, simply use the PICkitPlus suite of software to
preserve HEF memory during programming.  
  
See also
<a href="hefread" class="link" title="HEFRead">HEFRead</a>,
<a href="hefreadword" class="link" title="HEFReadWord">HEFReadWord</a>,
<a href="hefwrite" class="link" title="HEFWrite">HEFWrite</a>,
<a href="hefwriteword" class="link" title="HEFWriteWord">HEFWriteWord</a>,
<a href="hefreadblock" class="link" title="HEFReadBlock">HEFReadBlock</a>,
<a href="hefwriteblock" class="link" title="HEFWriteBlock">HEFWriteBlock</a>,
<a href="heferaseblock" class="link" title="HEFEraseBlock">HEFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HEFM ( PFM )</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_memory.html" title="Memory"><link rel="prev" href="_dataset_for_eeprom.html" title="Dataset for EEPROM"><link rel="next" href="_hefm_overview.html" title="HEFM Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hefm_pfm"></a>HEFM ( PFM )</h4></div></div></div><p>This is the HEFM ( PFM ) section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hefm_pfm"></span>HEFM ( PFM )

</div>

</div>

</div>

This is the HEFM ( PFM ) section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HEFRead</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hefm_pfm.html" title="HEFM ( PFM )"><link rel="prev" href="_hefm_overview.html" title="HEFM Overview"><link rel="next" href="_hefreadword.html" title="HEFReadWord"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hefread"></a>HEFRead</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    'as a subroutine
    HEFRead ( location, data )

    'as a function
    data = HEFRead ( location )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with HEFM memory</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
HEFRead is used to read information, byte values, from HEFM, so that it can be accessed for use in a user program.
<br>
<br>
<code class="literal">location</code> represents the location or relative address to read.  The location will range from location 0 to HEF_BYTES - 1, or for all practical purposes 0-127 since all PIC Microcontrollers with HEF support 128 bytes of HEF Memory. HEF_BYTES is a GCBASIC constant that represents the number of bytes of HEF Memory.&nbsp;&nbsp;&nbsp;
<br>
<br>
<code class="literal">data</code> is the data that is to be read from the HEFM data storage area.&nbsp;&nbsp;&nbsp;
This can be a byte value or a byte variable.
<br>
<br>
This method reads data from HEFM given the specific relative location.&nbsp;&nbsp;&nbsp;
This method is similar to the EPRead method for EEPROM.
<br>
<br>
<span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup PPS
     '... code to setup serial

    'The following example reads the HEFM data value into the byte variable &#8220;byte_value&#8221; using a subroutine.

    Dim data_byte as byte

    ;Write a byte of data to HEFM Location 34
    HEFWrite( 34, 144)

    ;Read the byte back from HEFM location 34
    HEFread( 34, byte_value )

    ;Display the data on a terminal
    HserPrint "byte_value = "
    Hserprint byte_value</pre><p><br>
<br>
<span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    '... code preamble to select part '... code preamble to select part
    '... code to setup PPS
     '... code to setup serial

    'The following example reads the HEFM data value into the byte variable &#8220;byte_value&#8221; using a function.

    Dim data_byte as byte

    ;Write a byte of data to HEF Location 34
    HEFWrite( 34, 144)

    ;Read the byte back from HEF location 34
    byte_value = HEFread( 34 )

    ;Display the data on a terminal
    HserPrint "byte_value = "
    Hserprint byte_value</pre><p><br>
<br>
See also
<a class="link" href="_hefm_overview.html" title="HEFM Overview">HEFM Overview</a>,
<a class="link" href="_hefread.html" title="HEFRead">HEFRead</a>,
<a class="link" href="_hefreadword.html" title="HEFReadWord">HEFReadWord</a>,
<a class="link" href="_hefwrite.html" title="HEFWrite">HEFWrite</a>,
<a class="link" href="_hefwriteword.html" title="HEFWriteWord">HEFWriteWord</a>,
<a class="link" href="_hefreadblock.html" title="HEFReadBlock">HEFReadBlock</a>,
<a class="link" href="_hefwriteblock.html" title="HEFWriteBlock">HEFWriteBlock</a>,
<a class="link" href="_heferaseblock.html" title="HEFEraseBlock">HEFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hefread"></span>HEFRead

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    'as a subroutine
    HEFRead ( location, data )

    'as a function
    data = HEFRead ( location )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with HEFM memory

<span class="strong">**Explanation:**</span>  
  
HEFRead is used to read information, byte values, from HEFM, so that it
can be accessed for use in a user program.  
  
`location` represents the location or relative address to read. The
location will range from location 0 to HEF\_BYTES - 1, or for all
practical purposes 0-127 since all PIC Microcontrollers with HEF support
128 bytes of HEF Memory. HEF\_BYTES is a GCBASIC constant that
represents the number of bytes of HEF Memory.     
  
`data` is the data that is to be read from the HEFM data storage
area.    This can be a byte value or a byte variable.  
  
This method reads data from HEFM given the specific relative
location.    This method is similar to the EPRead method for EEPROM.  
  
<span class="strong">**Example 1:**</span>

``` screen
    '... code preamble to select part
    '... code to setup PPS
     '... code to setup serial

    'The following example reads the HEFM data value into the byte variable “byte_value” using a subroutine.

    Dim data_byte as byte

    ;Write a byte of data to HEFM Location 34
    HEFWrite( 34, 144)

    ;Read the byte back from HEFM location 34
    HEFread( 34, byte_value )

    ;Display the data on a terminal
    HserPrint "byte_value = "
    Hserprint byte_value
```

  
  
<span class="strong">**Example 2:**</span>

``` screen
    '... code preamble to select part '... code preamble to select part
    '... code to setup PPS
     '... code to setup serial

    'The following example reads the HEFM data value into the byte variable “byte_value” using a function.

    Dim data_byte as byte

    ;Write a byte of data to HEF Location 34
    HEFWrite( 34, 144)

    ;Read the byte back from HEF location 34
    byte_value = HEFread( 34 )

    ;Display the data on a terminal
    HserPrint "byte_value = "
    Hserprint byte_value
```

  
  
See also
<a href="hefm_overview" class="link" title="HEFM Overview">HEFM Overview</a>,
<a href="hefread" class="link" title="HEFRead">HEFRead</a>,
<a href="hefreadword" class="link" title="HEFReadWord">HEFReadWord</a>,
<a href="hefwrite" class="link" title="HEFWrite">HEFWrite</a>,
<a href="hefwriteword" class="link" title="HEFWriteWord">HEFWriteWord</a>,
<a href="hefreadblock" class="link" title="HEFReadBlock">HEFReadBlock</a>,
<a href="hefwriteblock" class="link" title="HEFWriteBlock">HEFWriteBlock</a>,
<a href="heferaseblock" class="link" title="HEFEraseBlock">HEFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HEFReadBlock</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hefm_pfm.html" title="HEFM ( PFM )"><link rel="prev" href="_hefwriteword.html" title="HEFWriteWord"><link rel="next" href="_hefwriteblock.html" title="HEFWriteBlock"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hefreadblock"></a>HEFReadBlock</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HEFReadBlock ( block_number,  buffer(), [, num_bytes] )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with HEFM memory.</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
HEFReadBlock is used to read information from the HEFM data storage into the buffer.&nbsp;&nbsp;&nbsp;
Once the buffer is populated it can be accessed for use within a user program.
<br>
<br>
The parameters are as follows:
<br>
<br>
<code class="literal">block_number</code> represents the block to be written to.&nbsp;&nbsp;&nbsp;
The block_number parameter is used to calculate the physical memory location(s) that are updated.
<br>
<br>
<code class="literal">buffer()</code> represents an array or string.&nbsp;&nbsp;&nbsp;
The buffer will be used as the data target for the block read operation.&nbsp;&nbsp;&nbsp;
The  buffer is handled as a buffer of bytes values.&nbsp;&nbsp;&nbsp;
In most cases the buffer should be the same size as a row/block of HEFM.&nbsp;&nbsp;&nbsp;
For most PIC Microcontrollers this will be 32 bytes.&nbsp;&nbsp;&nbsp;
For PIC microcontrollers with 2KW or less of Flash Program Memory this will be 16 Bytes.&nbsp;&nbsp;&nbsp;
Once data is read into the buffer from HEFM, the user program must handle the data as Byte, Word or String values, as appropriate.
<br>
<br>
<code class="literal">num_bytes</code> is an optional parameter, and can be used to specify number of bytes to read from HEFM, starting at the first location in the selected HEFM block.&nbsp;&nbsp;&nbsp;
This parameter is not normally required as the default is set to the GCBASIC constant <code class="literal">HEF_ROWSIZE_BYTES</code>.
<br>
<br></p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial

      Dim My_Buffer(HEF_ROWSIZE_BYTES)
      Dim index as byte

      ;Write some data to Block 2
      My_Buffer = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32
      HEFWriteBlock(2, My_Buffer())

      ;Read the data back from HEFM using HEFReadBock
      HEFReadBlock( 2 , My_buffer() )

     ;Send the data to a terminal in decimal format
      index = 1
      Repeat HEF_ROWSIZE_BYTES
          Hserprint(My_Buffer(index))
          HserPrint " "
          index++
     End Repeat</pre><p><br>
<br>
See also
<a class="link" href="_hefm_overview.html" title="HEFM Overview">HEFM Overview</a>,
<a class="link" href="_hefread.html" title="HEFRead">HEFRead</a>,
<a class="link" href="_hefreadword.html" title="HEFReadWord">HEFReadWord</a>,
<a class="link" href="_hefwrite.html" title="HEFWrite">HEFWrite</a>,
<a class="link" href="_hefwriteword.html" title="HEFWriteWord">HEFWriteWord</a>,
<a class="link" href="_hefreadblock.html" title="HEFReadBlock">HEFReadBlock</a>,
<a class="link" href="_hefwriteblock.html" title="HEFWriteBlock">HEFWriteBlock</a>,
<a class="link" href="_heferaseblock.html" title="HEFEraseBlock">HEFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hefreadblock"></span>HEFReadBlock

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HEFReadBlock ( block_number,  buffer(), [, num_bytes] )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with HEFM memory.

<span class="strong">**Explanation:**</span>  
  
HEFReadBlock is used to read information from the HEFM data storage into
the buffer.    Once the buffer is populated it can be accessed for use
within a user program.  
  
The parameters are as follows:  
  
`block_number` represents the block to be written to.    The
block\_number parameter is used to calculate the physical memory
location(s) that are updated.  
  
`buffer()` represents an array or string.    The buffer will be used as
the data target for the block read operation.    The buffer is handled
as a buffer of bytes values.    In most cases the buffer should be the
same size as a row/block of HEFM.    For most PIC Microcontrollers this
will be 32 bytes.    For PIC microcontrollers with 2KW or less of Flash
Program Memory this will be 16 Bytes.    Once data is read into the
buffer from HEFM, the user program must handle the data as Byte, Word or
String values, as appropriate.  
  
`num_bytes` is an optional parameter, and can be used to specify number
of bytes to read from HEFM, starting at the first location in the
selected HEFM block.    This parameter is not normally required as the
default is set to the GCBASIC constant `HEF_ROWSIZE_BYTES`.  
  

<span class="strong">**Example 1:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial

      Dim My_Buffer(HEF_ROWSIZE_BYTES)
      Dim index as byte

      ;Write some data to Block 2
      My_Buffer = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32
      HEFWriteBlock(2, My_Buffer())

      ;Read the data back from HEFM using HEFReadBock
      HEFReadBlock( 2 , My_buffer() )

     ;Send the data to a terminal in decimal format
      index = 1
      Repeat HEF_ROWSIZE_BYTES
          Hserprint(My_Buffer(index))
          HserPrint " "
          index++
     End Repeat
```

  
  
See also
<a href="hefm_overview" class="link" title="HEFM Overview">HEFM Overview</a>,
<a href="hefread" class="link" title="HEFRead">HEFRead</a>,
<a href="hefreadword" class="link" title="HEFReadWord">HEFReadWord</a>,
<a href="hefwrite" class="link" title="HEFWrite">HEFWrite</a>,
<a href="hefwriteword" class="link" title="HEFWriteWord">HEFWriteWord</a>,
<a href="hefreadblock" class="link" title="HEFReadBlock">HEFReadBlock</a>,
<a href="hefwriteblock" class="link" title="HEFWriteBlock">HEFWriteBlock</a>,
<a href="heferaseblock" class="link" title="HEFEraseBlock">HEFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HEFReadWord</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hefm_pfm.html" title="HEFM ( PFM )"><link rel="prev" href="_hefread.html" title="HEFRead"><link rel="next" href="_hefwrite.html" title="HEFWrite"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hefreadword"></a>HEFReadWord</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    'as a subroutine
    HEFReadWord ( location, data_word_variable )

    'as a function
    data_word_variable = HEFReadWord ( location )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with HEFM memory</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
HEFReadWord is used to read information, word values, from HEFM so that it can be accessed for use in a user program.
<br>
<br>
<code class="literal">location</code> represents the location or relative address to read.  The location will range from location 0 to HEF_BYTES - 1, or for all practical purposes 0-127 since all PIC Microcontrollers with HEF support 128 bytes of HEF Memory. HEF_BYTES is a GCBASIC constant that represents the number of bytes of HEF Memory.&nbsp;&nbsp;&nbsp;
<br>
<br>
<code class="literal">data</code> is the data that is to be read from the HEFM data storage.&nbsp;&nbsp;&nbsp;
This must be a word variable.&nbsp;&nbsp;&nbsp;
<br>
<br>
This method reads data from HEFM given the specific relative location.&nbsp;&nbsp;&nbsp;
<br>
<br>
<span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial

    'The following example reads the HEFM value into the word variable &#8220;data_word_variable&#8221; by initially writing some word values.

    dim data_word_variable as word
    HEFWriteWord( 254, 4660 )

    HEFReadWord( 254, data_word_variable )

    HSerPrint "Value = "
    HSerPrint data_word_variable
    HSerPrintCRLF</pre><p><br>
If example 1 were displayed on a serial terminal.&nbsp;&nbsp;&nbsp;The result would show:</p><pre class="screen">    Value = 4660</pre><p><br>
<br>
<span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial

    'The following example uses a function to read the HEFM value into the word variable &#8220;data_word_variable&#8221;.

    dim data_word_variable as word
    HEFWriteWord( 254, 17185 )

    data_word_variable = HEFReadWord( 254 )

    HSerPrint "Value = "
    HSerPrint data_word_variable
    HSerPrintCRLF</pre><p><br>
If example 2 were displayed on a serial terminal.&nbsp;&nbsp;&nbsp;The result would show:</p><pre class="screen">    Value = 17185</pre><p><br>
<br>
See also
<a class="link" href="_hefm_overview.html" title="HEFM Overview">HEFM Overview</a>,
<a class="link" href="_hefread.html" title="HEFRead">HEFRead</a>,
<a class="link" href="_hefreadword.html" title="HEFReadWord">HEFReadWord</a>,
<a class="link" href="_hefwrite.html" title="HEFWrite">HEFWrite</a>,
<a class="link" href="_hefwriteword.html" title="HEFWriteWord">HEFWriteWord</a>,
<a class="link" href="_hefreadblock.html" title="HEFReadBlock">HEFReadBlock</a>,
<a class="link" href="_hefwriteblock.html" title="HEFWriteBlock">HEFWriteBlock</a>,
<a class="link" href="_heferaseblock.html" title="HEFEraseBlock">HEFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hefreadword"></span>HEFReadWord

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    'as a subroutine
    HEFReadWord ( location, data_word_variable )

    'as a function
    data_word_variable = HEFReadWord ( location )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with HEFM memory

<span class="strong">**Explanation:**</span>  
  
HEFReadWord is used to read information, word values, from HEFM so that
it can be accessed for use in a user program.  
  
`location` represents the location or relative address to read. The
location will range from location 0 to HEF\_BYTES - 1, or for all
practical purposes 0-127 since all PIC Microcontrollers with HEF support
128 bytes of HEF Memory. HEF\_BYTES is a GCBASIC constant that
represents the number of bytes of HEF Memory.     
  
`data` is the data that is to be read from the HEFM data storage.   
This must be a word variable.     
  
This method reads data from HEFM given the specific relative
location.     
  
<span class="strong">**Example 1:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial

    'The following example reads the HEFM value into the word variable “data_word_variable” by initially writing some word values.

    dim data_word_variable as word
    HEFWriteWord( 254, 4660 )

    HEFReadWord( 254, data_word_variable )

    HSerPrint "Value = "
    HSerPrint data_word_variable
    HSerPrintCRLF
```

  
If example 1 were displayed on a serial terminal.   The result would
show:

``` screen
    Value = 4660
```

  
  
<span class="strong">**Example 2:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial

    'The following example uses a function to read the HEFM value into the word variable “data_word_variable”.

    dim data_word_variable as word
    HEFWriteWord( 254, 17185 )

    data_word_variable = HEFReadWord( 254 )

    HSerPrint "Value = "
    HSerPrint data_word_variable
    HSerPrintCRLF
```

  
If example 2 were displayed on a serial terminal.   The result would
show:

``` screen
    Value = 17185
```

  
  
See also
<a href="hefm_overview" class="link" title="HEFM Overview">HEFM Overview</a>,
<a href="hefread" class="link" title="HEFRead">HEFRead</a>,
<a href="hefreadword" class="link" title="HEFReadWord">HEFReadWord</a>,
<a href="hefwrite" class="link" title="HEFWrite">HEFWrite</a>,
<a href="hefwriteword" class="link" title="HEFWriteWord">HEFWriteWord</a>,
<a href="hefreadblock" class="link" title="HEFReadBlock">HEFReadBlock</a>,
<a href="hefwriteblock" class="link" title="HEFWriteBlock">HEFWriteBlock</a>,
<a href="heferaseblock" class="link" title="HEFEraseBlock">HEFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HEFWrite</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hefm_pfm.html" title="HEFM ( PFM )"><link rel="prev" href="_hefreadword.html" title="HEFReadWord"><link rel="next" href="_hefwriteword.html" title="HEFWriteWord"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hefwrite"></a>HEFWrite</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HEFWrite ( location, data )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with HEFM memory</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
HEFWrite is used to write information, byte values, to HEFM so that it can be accessed later for use in a user program.
<br>
<br>
<code class="literal">location</code> represents the location or relative address to write. The location will range from location 0 to HEF_BYTES - 1, or for all practical purposes 0-127 since all PIC Microcontrollers with HEF support 128 bytes of HEF Memory. HEF_BYTES is a GCBASIC constant that represents the number of bytes of HEF Memory.
<br>
<br>
<code class="literal">data</code> is the data that is to be written to the HEFM location.&nbsp;&nbsp;&nbsp;
This can be a byte value or a byte variable.
<br>
<br>
This method writes information to the HEFM given the specific location.
This method is similar to the EPWrite method for EEPROM.
<br>
<br></p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial

    'The following example writes a byte value of 126 into HEFM location 34

     HEFWrite( 34, 126 )</pre><p><br>
<br>
<span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial

    'This example will populate all 128 bytes of HEF memory with a value that is same as the HEFM location

     Dim Rel_Address, DataByte as Byte
     Dim NVM_Address as Long
     Dim  DataWord, as Word
     Dim HEFaddress as Byte

    For Rel_Address = 0 to 127
        HEFWrite ( Rel_Address, Rel_Address )
    Next
    HEFM_DUMP

    End

  ; This subroutine displays the High Endurance Flash Memory on a terminal.
  ; Words are in reverse byte order relative to address.
  ; HEF data resides in the low byte of each 14bit program memory word.
  ; The high byte is not HEF and should always read "3F".

  Sub HEFM_DUMP

    Dim Blocknum as Byte
    NVM_Address  = HEF_START_ADDR
    BlockNum = 0

    Repeat  HEF_BYTES  ;128

        If NVM_Address % HEF_ROWSIZE_BYTES = 0 then
            If BlockNum &gt; 0 then   HSERPRINTCRLF
           HSerprintCRLF
           HserPrint "Block"
           HSerprint BlockNum
           HSerprint "     0     1     2     3     4     5     6     7"
           BlockNum++
        End if

        IF NVM_Address  % 8 = 0 then
           HSerPrintCRLF
           hserprint hex(NVM_Address_H)
           hserprint hex(NVM_ADDRESS)
           hserprint "     "
        end if

        Rel_Address = (NVM_ADDRESS - HEF_START_ADDR)
        HEFRead(Rel_Address, DataWord)

        hserprint hex(DataWord_H)
        hserprint hex(DataWord)
        hserprint "  "

        NVM_Address++
    End Repeat
    HserPrintCRLF
End sub</pre><p><br>
<br>
If example 2 were displayed on a serial terminal.&nbsp;&nbsp;&nbsp;The result would show:</p><pre class="screen">Block0     0     1     2     3     4     5     6     7
3F80     3F00  3F01  3F02  3F03  3F04  3F05  3F06  3F07
3F88     3F08  3F09  3F0A  3F0B  3F0C  3F0D  3F0E  3F0F
3F90     3F10  3F11  3F12  3F13  3F14  3F15  3F16  3F17
3F98     3F18  3F19  3F1A  3F1B  3F1C  3F1D  3F1E  3F1F

Block1     0     1     2     3     4     5     6     7
3FA0     3F20  3F21  3F22  3F23  3F24  3F25  3F26  3F27
3FA8     3F28  3F29  3F2A  3F2B  3F2C  3F2D  3F2E  3F2F
3FB0     3F30  3F31  3F32  3F33  3F34  3F35  3F36  3F37
3FB8     3F38  3F39  3F3A  3F3B  3F3C  3F3D  3F3E  3F3F

Block2     0     1     2     3     4     5     6     7
3FC0     3F40  3F41  3F42  3F43  3F44  3F45  3F46  3F47
3FC8     3F48  3F49  3F4A  3F4B  3F4C  3F4D  3F4E  3F4F
3FD0     3F50  3F51  3F52  3F53  3F54  3F55  3F56  3F57
3FD8     3F58  3F59  3F5A  3F5B  3F5C  3F5D  3F5E  3F5F

Block3     0     1     2     3     4     5     6     7
3FE0     3F60  3F61  3F62  3F63  3F64  3F65  3F66  3F67
3FE8     3F68  3F69  3F6A  3F6B  3F6C  3F6D  3F6E  3F6F
3FF0     3F70  3F71  3F72  3F73  3F74  3F75  3F76  3F77
3FF8     3F78  3F79  3F7A  3F7B  3F7C  3F7D  3F7E  3F7F</pre><p><br>
<br>
See also
<a class="link" href="_hefm_overview.html" title="HEFM Overview">HEFM Overview</a>,
<a class="link" href="_hefread.html" title="HEFRead">HEFRead</a>,
<a class="link" href="_hefreadword.html" title="HEFReadWord">HEFReadWord</a>,
<a class="link" href="_hefwrite.html" title="HEFWrite">HEFWrite</a>,
<a class="link" href="_hefwriteword.html" title="HEFWriteWord">HEFWriteWord</a>,
<a class="link" href="_hefreadblock.html" title="HEFReadBlock">HEFReadBlock</a>,
<a class="link" href="_hefwriteblock.html" title="HEFWriteBlock">HEFWriteBlock</a>,
<a class="link" href="_heferaseblock.html" title="HEFEraseBlock">HEFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hefwrite"></span>HEFWrite

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HEFWrite ( location, data )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with HEFM memory

<span class="strong">**Explanation:**</span>  
  
HEFWrite is used to write information, byte values, to HEFM so that it
can be accessed later for use in a user program.  
  
`location` represents the location or relative address to write. The
location will range from location 0 to HEF\_BYTES - 1, or for all
practical purposes 0-127 since all PIC Microcontrollers with HEF support
128 bytes of HEF Memory. HEF\_BYTES is a GCBASIC constant that
represents the number of bytes of HEF Memory.  
  
`data` is the data that is to be written to the HEFM location.    This
can be a byte value or a byte variable.  
  
This method writes information to the HEFM given the specific location.
This method is similar to the EPWrite method for EEPROM.  
  

<span class="strong">**Example 1:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial

    'The following example writes a byte value of 126 into HEFM location 34

     HEFWrite( 34, 126 )
```

  
  
<span class="strong">**Example 2:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial

    'This example will populate all 128 bytes of HEF memory with a value that is same as the HEFM location

     Dim Rel_Address, DataByte as Byte
     Dim NVM_Address as Long
     Dim  DataWord, as Word
     Dim HEFaddress as Byte

    For Rel_Address = 0 to 127
        HEFWrite ( Rel_Address, Rel_Address )
    Next
    HEFM_DUMP

    End

  ; This subroutine displays the High Endurance Flash Memory on a terminal.
  ; Words are in reverse byte order relative to address.
  ; HEF data resides in the low byte of each 14bit program memory word.
  ; The high byte is not HEF and should always read "3F".

  Sub HEFM_DUMP

    Dim Blocknum as Byte
    NVM_Address  = HEF_START_ADDR
    BlockNum = 0

    Repeat  HEF_BYTES  ;128

        If NVM_Address % HEF_ROWSIZE_BYTES = 0 then
            If BlockNum > 0 then   HSERPRINTCRLF
           HSerprintCRLF
           HserPrint "Block"
           HSerprint BlockNum
           HSerprint "     0     1     2     3     4     5     6     7"
           BlockNum++
        End if

        IF NVM_Address  % 8 = 0 then
           HSerPrintCRLF
           hserprint hex(NVM_Address_H)
           hserprint hex(NVM_ADDRESS)
           hserprint "     "
        end if

        Rel_Address = (NVM_ADDRESS - HEF_START_ADDR)
        HEFRead(Rel_Address, DataWord)

        hserprint hex(DataWord_H)
        hserprint hex(DataWord)
        hserprint "  "

        NVM_Address++
    End Repeat
    HserPrintCRLF
End sub
```

  
  
If example 2 were displayed on a serial terminal.   The result would
show:

``` screen
Block0     0     1     2     3     4     5     6     7
3F80     3F00  3F01  3F02  3F03  3F04  3F05  3F06  3F07
3F88     3F08  3F09  3F0A  3F0B  3F0C  3F0D  3F0E  3F0F
3F90     3F10  3F11  3F12  3F13  3F14  3F15  3F16  3F17
3F98     3F18  3F19  3F1A  3F1B  3F1C  3F1D  3F1E  3F1F

Block1     0     1     2     3     4     5     6     7
3FA0     3F20  3F21  3F22  3F23  3F24  3F25  3F26  3F27
3FA8     3F28  3F29  3F2A  3F2B  3F2C  3F2D  3F2E  3F2F
3FB0     3F30  3F31  3F32  3F33  3F34  3F35  3F36  3F37
3FB8     3F38  3F39  3F3A  3F3B  3F3C  3F3D  3F3E  3F3F

Block2     0     1     2     3     4     5     6     7
3FC0     3F40  3F41  3F42  3F43  3F44  3F45  3F46  3F47
3FC8     3F48  3F49  3F4A  3F4B  3F4C  3F4D  3F4E  3F4F
3FD0     3F50  3F51  3F52  3F53  3F54  3F55  3F56  3F57
3FD8     3F58  3F59  3F5A  3F5B  3F5C  3F5D  3F5E  3F5F

Block3     0     1     2     3     4     5     6     7
3FE0     3F60  3F61  3F62  3F63  3F64  3F65  3F66  3F67
3FE8     3F68  3F69  3F6A  3F6B  3F6C  3F6D  3F6E  3F6F
3FF0     3F70  3F71  3F72  3F73  3F74  3F75  3F76  3F77
3FF8     3F78  3F79  3F7A  3F7B  3F7C  3F7D  3F7E  3F7F
```

  
  
See also
<a href="hefm_overview" class="link" title="HEFM Overview">HEFM Overview</a>,
<a href="hefread" class="link" title="HEFRead">HEFRead</a>,
<a href="hefreadword" class="link" title="HEFReadWord">HEFReadWord</a>,
<a href="hefwrite" class="link" title="HEFWrite">HEFWrite</a>,
<a href="hefwriteword" class="link" title="HEFWriteWord">HEFWriteWord</a>,
<a href="hefreadblock" class="link" title="HEFReadBlock">HEFReadBlock</a>,
<a href="hefwriteblock" class="link" title="HEFWriteBlock">HEFWriteBlock</a>,
<a href="heferaseblock" class="link" title="HEFEraseBlock">HEFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HEFWriteBlock</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hefm_pfm.html" title="HEFM ( PFM )"><link rel="prev" href="_hefreadblock.html" title="HEFReadBlock"><link rel="next" href="_heferaseblock.html" title="HEFEraseBlock"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hefwriteblock"></a>HEFWriteBlock</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HEFWriteBlock ( block_number,  buffer(), [, num_bytes] )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with HEFM memory.</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
HEFWriteBlock is used to write information from a user buffer to HEFM.&nbsp;&nbsp;&nbsp;
Once the block is written  it can be accessed for use within a user program.
<br>
<br>
The parameters are as follows:
<br>
<br>
<code class="literal">block_number</code> represents the block to be written to.&nbsp;&nbsp;&nbsp;
The block_number parameter is used to calculate the physical memory location(s) that are updated.
<br>
<br>
<code class="literal">buffer()</code> represents an array or string.&nbsp;&nbsp;&nbsp;
The buffer will be used as the data source that is written to the HEFM block.&nbsp;&nbsp;&nbsp;
The buffer is handled as a buffer of bytes values.&nbsp;&nbsp;&nbsp;
In most cases the buffer should be the same size as a row/block of HEFM.&nbsp;&nbsp;&nbsp;
For most PIC Microcontrollers this will be 32 bytes.&nbsp;&nbsp;&nbsp;
For PIC microcontrollers with 2KW or less of Flash Program Memory this will be 16 Bytes.&nbsp;&nbsp;&nbsp;
Best practice is to size the buffer using the HEF_ROWSIZE_BYTES constant.&nbsp;&nbsp;&nbsp;
If the size of the buffer exceeds the device specific HEF_ROWSIZE_BYTES, the excess data will not be handled and the buffer will be truncated at the HEF_ROWSIZE_BYTES limit.&nbsp;&nbsp;&nbsp;
<br>
<br>
<code class="literal">num_bytes</code> is an optional parameter, and can be used to specify number of bytes to write to HEFM, starting at the first location in the selected HEFM block.&nbsp;&nbsp;&nbsp;
This parameter is not normally required as the default is set to the GCBASIC constant <code class="literal">HEF_ROWSIZE_BYTES</code>.
<br>
<br>
<span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial

   Dim My_Buffer(HEF_ROWSIZE_BYTES)

   My_Buffer = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32

    'HEFwriteBlock operation!!
    HEFwriteBlock(2, My_Buffer)

    'A utility method to show the contents of HEFM.
     HEFM_Dump</pre><p>For HEFM_Dump routine,  see <a class="link" href="_hefread.html" title="HEFRead">HEFRead</a>
<br>
<br>
If example 1 were displayed on a serial terminal using HEFM_Dump.&nbsp;&nbsp;&nbsp;
The result would show. Note the value display at the start of block 2 @ 0x3F80.</p><pre class="screen">Block0  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F00    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F10    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F20    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F30    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF

Block1  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F40    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F50    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F60    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F70    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF

Block2  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F80    0201  0403  0605  0807  0A09  0C0B  0E0D  100F
7F90    1211  1413  1615  1817  1A19  1C1B  1E1D  201F
7FA0    2120  2322  2524  2726  2928  2B2A  2D2C  2F2E
7FB0    3130  3332  3534  3736  3938  3B3A  3D3C  3F3E

Block3  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7FC0    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7FD0    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7FE0    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7FF0    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF</pre><p><br>
<br>
See also
<a class="link" href="_hefm_overview.html" title="HEFM Overview">HEFM Overview</a>,
<a class="link" href="_hefread.html" title="HEFRead">HEFRead</a>,
<a class="link" href="_hefreadword.html" title="HEFReadWord">HEFReadWord</a>,
<a class="link" href="_hefwrite.html" title="HEFWrite">HEFWrite</a>,
<a class="link" href="_hefwriteword.html" title="HEFWriteWord">HEFWriteWord</a>,
<a class="link" href="_hefreadblock.html" title="HEFReadBlock">HEFReadBlock</a>,
<a class="link" href="_hefwriteblock.html" title="HEFWriteBlock">HEFWriteBlock</a>,
<a class="link" href="_heferaseblock.html" title="HEFEraseBlock">HEFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hefwriteblock"></span>HEFWriteBlock

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HEFWriteBlock ( block_number,  buffer(), [, num_bytes] )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with HEFM memory.

<span class="strong">**Explanation:**</span>  
  
HEFWriteBlock is used to write information from a user buffer to
HEFM.    Once the block is written it can be accessed for use within a
user program.  
  
The parameters are as follows:  
  
`block_number` represents the block to be written to.    The
block\_number parameter is used to calculate the physical memory
location(s) that are updated.  
  
`buffer()` represents an array or string.    The buffer will be used as
the data source that is written to the HEFM block.    The buffer is
handled as a buffer of bytes values.    In most cases the buffer should
be the same size as a row/block of HEFM.    For most PIC
Microcontrollers this will be 32 bytes.    For PIC microcontrollers with
2KW or less of Flash Program Memory this will be 16 Bytes.    Best
practice is to size the buffer using the HEF\_ROWSIZE\_BYTES
constant.    If the size of the buffer exceeds the device specific
HEF\_ROWSIZE\_BYTES, the excess data will not be handled and the buffer
will be truncated at the HEF\_ROWSIZE\_BYTES limit.     
  
`num_bytes` is an optional parameter, and can be used to specify number
of bytes to write to HEFM, starting at the first location in the
selected HEFM block.    This parameter is not normally required as the
default is set to the GCBASIC constant `HEF_ROWSIZE_BYTES`.  
  
<span class="strong">**Example 1:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial

   Dim My_Buffer(HEF_ROWSIZE_BYTES)

   My_Buffer = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32

    'HEFwriteBlock operation!!
    HEFwriteBlock(2, My_Buffer)

    'A utility method to show the contents of HEFM.
     HEFM_Dump
```

For HEFM\_Dump routine, see
<a href="hefread" class="link" title="HEFRead">HEFRead</a>  
  
If example 1 were displayed on a serial terminal using HEFM\_Dump.   
The result would show. Note the value display at the start of block 2 @
0x3F80.

``` screen
Block0  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F00    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F10    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F20    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F30    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF

Block1  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F40    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F50    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F60    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F70    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF

Block2  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F80    0201  0403  0605  0807  0A09  0C0B  0E0D  100F
7F90    1211  1413  1615  1817  1A19  1C1B  1E1D  201F
7FA0    2120  2322  2524  2726  2928  2B2A  2D2C  2F2E
7FB0    3130  3332  3534  3736  3938  3B3A  3D3C  3F3E

Block3  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7FC0    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7FD0    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7FE0    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7FF0    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
```

  
  
See also
<a href="hefm_overview" class="link" title="HEFM Overview">HEFM Overview</a>,
<a href="hefread" class="link" title="HEFRead">HEFRead</a>,
<a href="hefreadword" class="link" title="HEFReadWord">HEFReadWord</a>,
<a href="hefwrite" class="link" title="HEFWrite">HEFWrite</a>,
<a href="hefwriteword" class="link" title="HEFWriteWord">HEFWriteWord</a>,
<a href="hefreadblock" class="link" title="HEFReadBlock">HEFReadBlock</a>,
<a href="hefwriteblock" class="link" title="HEFWriteBlock">HEFWriteBlock</a>,
<a href="heferaseblock" class="link" title="HEFEraseBlock">HEFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HEFWriteWord</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hefm_pfm.html" title="HEFM ( PFM )"><link rel="prev" href="_hefwrite.html" title="HEFWrite"><link rel="next" href="_hefreadblock.html" title="HEFReadBlock"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hefwriteword"></a>HEFWriteWord</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HEFWriteWord ( location, data_word_value )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with HEFM memory</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
HEFWriteWord is used to write information, word values, to HEFM, so that it can be accessed in a user program via the HEFReadWord command.
<br>
<br>
<code class="literal">location</code> presents the location or relative address to write write. A data Word requires 2 HEF Locations, therefore the location will range from 0 to 126 in steps of 2.
<br>
<br>
<code class="literal">data</code> is the data that is to be written to the HEFM location.&nbsp;&nbsp;&nbsp;This can be a word value or a word variable.
<br>
<br>
This method writes information to the HEFM given the specific location in the HEFM data storage .
This method is similar to the methods for EEPROM but this method supports Word values.
<br>
<br></p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial

    'The following example stores a word value in HEFM location 0

    HEFWrite( 0, 0x1234)</pre><p><br>
<br>
<span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial

    'This example will write two word values to two specific locations.
    HEFWriteWord (16, 0xAA01)
    HEFWriteWord (18, 0xBB02)</pre><p><br>
<br>
If example 2 were displayed on a serial terminal.&nbsp;&nbsp;&nbsp;The result would show, where <code class="literal">--</code> is the existing value.</p><pre class="screen">    Block0
    3F00   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    3F10   01 AA 02 BB -- -- -- -- -- -- -- -- -- -- -- --
    3F20   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    3F30   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</pre><p><br>
<br>
See also
<a class="link" href="_hefm_overview.html" title="HEFM Overview">HEFM Overview</a>,
<a class="link" href="_hefread.html" title="HEFRead">HEFRead</a>,
<a class="link" href="_hefreadword.html" title="HEFReadWord">HEFReadWord</a>,
<a class="link" href="_hefwrite.html" title="HEFWrite">HEFWrite</a>,
<a class="link" href="_hefwriteword.html" title="HEFWriteWord">HEFWriteWord</a>,
<a class="link" href="_hefreadblock.html" title="HEFReadBlock">HEFReadBlock</a>,
<a class="link" href="_hefwriteblock.html" title="HEFWriteBlock">HEFWriteBlock</a>,
<a class="link" href="_heferaseblock.html" title="HEFEraseBlock">HEFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hefwriteword"></span>HEFWriteWord

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HEFWriteWord ( location, data_word_value )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with HEFM memory

<span class="strong">**Explanation:**</span>  
  
HEFWriteWord is used to write information, word values, to HEFM, so that
it can be accessed in a user program via the HEFReadWord command.  
  
`location` presents the location or relative address to write write. A
data Word requires 2 HEF Locations, therefore the location will range
from 0 to 126 in steps of 2.  
  
`data` is the data that is to be written to the HEFM location.   This
can be a word value or a word variable.  
  
This method writes information to the HEFM given the specific location
in the HEFM data storage . This method is similar to the methods for
EEPROM but this method supports Word values.  
  

<span class="strong">**Example 1:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial

    'The following example stores a word value in HEFM location 0

    HEFWrite( 0, 0x1234)
```

  
  
<span class="strong">**Example 2:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial

    'This example will write two word values to two specific locations.
    HEFWriteWord (16, 0xAA01)
    HEFWriteWord (18, 0xBB02)
```

  
  
If example 2 were displayed on a serial terminal.   The result would
show, where `--` is the existing value.

``` screen
    Block0
    3F00   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    3F10   01 AA 02 BB -- -- -- -- -- -- -- -- -- -- -- --
    3F20   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    3F30   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
```

  
  
See also
<a href="hefm_overview" class="link" title="HEFM Overview">HEFM Overview</a>,
<a href="hefread" class="link" title="HEFRead">HEFRead</a>,
<a href="hefreadword" class="link" title="HEFReadWord">HEFReadWord</a>,
<a href="hefwrite" class="link" title="HEFWrite">HEFWrite</a>,
<a href="hefwriteword" class="link" title="HEFWriteWord">HEFWriteWord</a>,
<a href="hefreadblock" class="link" title="HEFReadBlock">HEFReadBlock</a>,
<a href="hefwriteblock" class="link" title="HEFWriteBlock">HEFWriteBlock</a>,
<a href="heferaseblock" class="link" title="HEFEraseBlock">HEFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Hex</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_fill.html" title="Fill"><link rel="next" href="_instr.html" title="Instr"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hex"></a>Hex</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>stringvar</em></span> = Hex(<span class="emphasis"><em>number</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Hex</code> function will convert a number into hexadecimal format. The input <code class="literal"><span class="emphasis"><em>number</em></span></code> should be a byte variable, or a fixed number between 0 and 255 inclusive. After running the function, the string variable <code class="literal"><span class="emphasis"><em>stringvar</em></span></code> will contain a 2 digit hexadecimal number.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Send EEPROM data over serial connection
    'Uses Hex to display as hexadecimal
    For CurrentLocation = 0 to 255
        'Send location
        HSerPrint Hex(CurrentLocation)
        HSerPrint ":"
        'Read byte and send
        EPRead CurrentLocation, CurrByte
        HSerPrint Hex(CurrByte)
        'Send carriage return/line feed
        HSerPrintCRLF
    Next</pre><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_str.html" title="Str">Str</a>, <a class="link" href="_val.html" title="Val">Val</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hex"></span>Hex

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    stringvar = Hex(number)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Hex` function will convert a number into hexadecimal format. The
input `number` should be a byte variable, or a fixed number between 0
and 255 inclusive. After running the function, the string variable
`stringvar` will contain a 2 digit hexadecimal number.

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Send EEPROM data over serial connection
    'Uses Hex to display as hexadecimal
    For CurrentLocation = 0 to 255
        'Send location
        HSerPrint Hex(CurrentLocation)
        HSerPrint ":"
        'Read byte and send
        EPRead CurrentLocation, CurrByte
        HSerPrint Hex(CurrByte)
        'Send carriage return/line feed
        HSerPrintCRLF
    Next
```

<span class="strong">**See Also**</span>
<a href="str" class="link" title="Str">Str</a>,
<a href="val" class="link" title="Val">Val</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HI2CAckPollState</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"><link rel="prev" href="_hi2c_overview.html" title="HI2C Overview"><link rel="next" href="_hi2creceive.html" title="HI2CReceive"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hi2cackpollstate"></a>HI2CAckPollState</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    &lt;test condition[s]&gt; HI2CAckPollState</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available for microcontrollers with the hardware I2C or TWI module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Should only be used when I2C routines are operating in Master mode, this
command will return the last state of the acknowledge response from a
specific I2C device on the I2C bus.</p><p><code class="literal">HI2CSend</code> sets the state of variable <code class="literal">HI2CAckPollState</code>.<br>
<code class="literal">HI2CAckPollState</code> can only read - it cannot be set.</p><p><span class="strong"><strong>Note:</strong></span></p><p>This command is also available on microcontrollers with a second hardware I2C port.</p><pre class="screen">    &lt;test condition[s]&gt; HI2C2AckPollState</pre><p><span class="strong"><strong>Example:</strong></span></p><p>This example code would display the devices on the I2C bus.</p><pre class="screen">     ...
    for deviceID = 0 to 255
      HI2CStart
      HI2CSend ( deviceID )

      if <code class="literal">HI2CAckPollState</code> = false then
      HSerPrint "ID: 0x"
      HSerPrint hex(deviceID)
      HSerSend 9
      end if
    next
     ...</pre><p>Supported in &lt;HI2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hi2cackpollstate"></span>HI2CAckPollState

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    <test condition[s]> HI2CAckPollState
```

<span class="strong">**Command Availability:**</span>

Only available for microcontrollers with the hardware I2C or TWI module.

<span class="strong">**Explanation:**</span>

Should only be used when I2C routines are operating in Master mode, this
command will return the last state of the acknowledge response from a
specific I2C device on the I2C bus.

`HI2CSend` sets the state of variable `HI2CAckPollState`.  
`HI2CAckPollState` can only read - it cannot be set.

<span class="strong">**Note:**</span>

This command is also available on microcontrollers with a second
hardware I2C port.

``` screen
    <test condition[s]> HI2C2AckPollState
```

<span class="strong">**Example:**</span>

This example code would display the devices on the I2C bus.

``` screen
     ...
    for deviceID = 0 to 255
      HI2CStart
      HI2CSend ( deviceID )

      if HI2CAckPollState = false then
      HSerPrint "ID: 0x"
      HSerPrint hex(deviceID)
      HSerSend 9
      end if
    next
     ...
```

Supported in &lt;HI2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HI2CMode</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"><link rel="prev" href="_hi2cstartoccurred.html" title="HI2CStartOccurred"><link rel="next" href="_hi2csetaddress.html" title="HI2CSetAddress"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hi2cmode"></a>HI2CMode</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HI2CMode Master | Slave</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available for microcontrollers with the hardware I2C or TWI module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Sets the microcontroller to either a Master device or a Slave device.</p><p>Only used in slave mode</p><p><span class="strong"><strong>Note:</strong></span></p><p>This command is also available on microcontrollers with a second hardware I2C port.</p><pre class="screen">    HI2C2Mode Master | Slave</pre><p>Supported in &lt;HI2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hi2cmode"></span>HI2CMode

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HI2CMode Master | Slave
```

<span class="strong">**Command Availability:**</span>

Only available for microcontrollers with the hardware I2C or TWI module.

<span class="strong">**Explanation:**</span>

Sets the microcontroller to either a Master device or a Slave device.

Only used in slave mode

<span class="strong">**Note:**</span>

This command is also available on microcontrollers with a second
hardware I2C port.

``` screen
    HI2C2Mode Master | Slave
```

Supported in &lt;HI2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HI2CReceive</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"><link rel="prev" href="_hi2cackpollstate.html" title="HI2CAckPollState"><link rel="next" href="_hi2crestart.html" title="HI2CRestart"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hi2creceive"></a>HI2CReceive</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HI2CReceive <span class="emphasis"><em>data</em></span>

    HI2CReceive <span class="emphasis"><em>data</em></span>, ACK
    HI2CReceive <span class="emphasis"><em>data</em></span>, NACK</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available for microcontrollers with the hardware I2C or TWI module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The HI2CReceive command will send <span class="emphasis"><em>data</em></span> through the I2C connection. If
<code class="literal"><span class="emphasis"><em>ack</em></span></code> is TRUE, or no value is given for <code class="literal"><span class="emphasis"><em>ack</em></span></code>, then <code class="literal">HI2CReceive</code> will send
an ack to the I2C bus.</p><p>If in master mode, <code class="literal">HI2CReceive</code> will read the data immediately. If in
slave mode, <code class="literal">HI2CReceive</code> will wait for the master to send the data before
reading.</p><p><span class="strong"><strong>Note:</strong></span></p><p>This command is also available on microcontrollers with a second hardware I2C port.</p><pre class="screen">    HI2C2Receive  _data_

    HI2C2Receive _data_, ACK
    HI2C2Receive _data_, NACK</pre><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    'This program reads an I2C register and sets an LED if it is over 100.

    'It will read from I2C device with an address of 83, register 1.
    ' Change the processor
    #chip 16F1937, 32
    #config MCLRE_ON


    ' Define I2C settings
    #define HI2C_BAUD_RATE 400

    #define HI2C_DATA PORTC.4
      #define HI2C_CLOCK PORTC.3

    'I2C pins need to be input for SSP module
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in

    'MASTER I2C Device
    HI2CMode Master

    'Misc settings
    #define LED PORTB.0

    'Main loop
    Do
      'Send start
      HI2CStart

      'Request value
      HI2CSend 83
      HI2CSend 1

      'Read value
      HI2CReceive ValueIn

      'Send stop
      HI2CStop

      'Turn on LED if received value &gt; 100
      Set LED Off
      If ValueIn &gt; 100 Then Set LED On

      'Delay
      Wait 20 ms

    Loop</pre><p><span class="strong"><strong>Example 2:</strong></span></p><p>See the <a class="link" href="_i2c_overview.html" title="I2C Overview">I2C Overview</a> for the Master mode
device to control this Slave mode device.</p><pre class="screen">    ' I2CHardwareReceive_Slave.gcb - using a 16F88.
    ' This program receives commands from a GCB Master. This Slave has three LEDs attached.

    ; This Slave device responds to address 0x60 and may only be written to.
    ; Within it, there are three registers, 0,1 and 2 corresponding to the three LEDs. Writing a zero
    ; turns the respective LED off. Writing anything else turns it on.


    #chip 16F88, 4
    #config  MCLR_Off

    #define I2C_MODE    Slave     ;this is a slave device now
    #define I2C_CLOCK   portb.4   ;SCL on pin 10
    #define I2C_DATA    portb.1   ;SDA on pin 7
    #define I2C_ADDRESS 0x60      ;address of the slave device

    #define I2C_BIT_DELAY 20 us
    #define I2C_CLOCK_DELAY 10 us
    #define I2C_END_DELAY 10 us


    'Serial settings
    #define SerInPort PORTB.6
    #define SerOutPort PORTB.7

    #define SendAHigh Set SerOutPort OFF
    #define SendALow Set SerOutPort On
    'Set pin directions
    Dir SerOutPort Out
    Dir SerInPort In

    'Set up serial connection
    InitSer 1, r2400, 1 + WaitForStart, 8, 1, none, INVERT
    wait 1 s

    #define LED0  porta.2          ;pin 1
    #define LED1  porta.3          ;pin 2
    #define LED2  porta.4          ;pin 3

    ;----- Variables

    dim addr, reg, value,location as byte
    addr = 255
    reg = 255
    value = 255
    location = 0
    mempointer = 255

    ;----- Program

    dir LED0 out                  ;0, 1 and 2 are outputs (LEDs)
    dir LED1 out                  ;0, 1 and 2 are outputs (LEDs)
    dir LED2 out                  ;0, 1 and 2 are outputs (LEDs)

    set LED0 off
    set LED1 off
    set LED2 off

    #define SerialControlPort portb.3
    dir SerialControlPort in

    'Set up interrupt to process I2C

       dir I2C_CLOCK in           ; required to input for MSSP module
       dir I2C_DATA in            ; required to input for MSSP module
       SSPADD=I2C_ADDRESS         ; Slave address
       SSPSTAT=b'00000000'        ; configuration
       SSPCON=b'00110110'         ; configuration
       PIE1.SSPIE=1               ; enable interrupt


    repeat 3                      ;flash LEDs
      set LED0 on
      set LED1 on
      set LED2 on
      wait 50 ms
      set LED0 off
      set LED1 off
      set LED2 off
      wait  100 ms
    end Repeat

    oldvalue = 255                ; old value, set up value only
    oldreg = 255                  ; old value, set up value only

    UpdateLEDS                    ; call method to set LEDs
                    ; set up interrupt
    On Interrupt SSP1Ready call I2C_Interrupt

    do forever
       if reg &lt;&gt; oldreg then      ; only process when the reg is a new value
        oldreg = reg            ; retain old value
        show = 1                ; its time to show the LEDS!
        if  value &lt;&gt; oldvalue then    ; logic for tracking old values. You only want to update terminal once per change
          oldvalue = value
          show = 1
        end if
       end if

       UpdateLEDS                  ; Update date LEDs

                     ; update serial terminal
       if show = 1  and SerialControlPort = 1 then

        SerPrint 1, "0x"+hex(addr)
        SerSend 1,9

        SerPrint 1, STR(reg)
        SerSend 1,9

        SerPrint 1, STR(value)
        SerSend 1,10
        SerSend 1,13

        show = 0
       end if
    loop


    Sub I2C_Interrupt
      ' handle interrupt
      IF SSPIF=1 THEN                   ; its a valid interrupt

         IF SSPSTAT.D_A=0 THEN          ; its an address coming in!
          addr=SSPBUF
          IF addr=I2C_ADDRESS THEN    ; its our address

           mempointer = 0           ; set the memory pointer. This code emulates an EEPROM!

          end if
          IF addr = ( I2C_ADDRESS | 1 ) THEN    ; its our write address
           CKP = 0                            ; acknowledge command
                            ; If the SDA line was low (ACK), the transmit data must be loaded into
                            ; the SSPBUF register which also loads the SSPSR
                            ; register. Then, pin RB4/SCK/SCL should be enabled
                            ; by setting bit CKP.

           mempointer = 10                    ; set a pointer to track incoming write reqests
           if I2C_DATA = 0 then
            SSPBUF = 0x22
            CKP = 1
            readpointer = 0x55
           end if
          end if

         else

         if  SSPSTAT.P = 1 then             ' Stop bit has been detected - out of sequence
           ' handle event
         end if

         IF  SSPSTAT.S = 1 THEN             ' Start bit has been detected - out of sequence
           ' handle event
         END IF

         IF SSPSTAT.R_W = 0 THEN            ' Write operations requested

          SELECT CASE mempointer
               CASE 0
                reg = SSPBUF         ' incoming value
                mempointer++         ' increment our counter
               CASE 1
                value = SSPBUF       ' incoming value
                mempointer++         ' increment our counter
               CASE ELSE
                dummy = SSPBUF       ' incoming value
          END SELECT

         ELSE                                ' Read operations
          SSPBUF = readpointer             ' incoming value
          readpointer++                    ' increment our counter

         END IF
         END IF
         CKP = 1                               ' acknowledge command
         SSPOV = 0                             ' acknowledge command
      END IF
      SSPIF=0
    END SUB



    sub UpdateLEDS

      select case reg           ;now turn proper LED on or off
        case 0
        if value = 1 then
          set LED0 on
        else
          set LED0 off
        end if

        case 1
        if value = 1 then
          set LED1 on
        else
          set LED1 off
        end if

        case 2
        if value = 1 then
          set LED2 on
        else
          set LED2 off
        end if

      end select

    End Sub</pre><p>Supported in &lt;HI2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hi2creceive"></span>HI2CReceive

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HI2CReceive data

    HI2CReceive data, ACK
    HI2CReceive data, NACK
```

<span class="strong">**Command Availability:**</span>

Only available for microcontrollers with the hardware I2C or TWI module.

<span class="strong">**Explanation:**</span>

The HI2CReceive command will send <span class="emphasis">*data*</span>
through the I2C connection. If `ack` is TRUE, or no value is given for
`ack`, then `HI2CReceive` will send an ack to the I2C bus.

If in master mode, `HI2CReceive` will read the data immediately. If in
slave mode, `HI2CReceive` will wait for the master to send the data
before reading.

<span class="strong">**Note:**</span>

This command is also available on microcontrollers with a second
hardware I2C port.

``` screen
    HI2C2Receive  _data_

    HI2C2Receive _data_, ACK
    HI2C2Receive _data_, NACK
```

<span class="strong">**Example 1:**</span>

``` screen
    'This program reads an I2C register and sets an LED if it is over 100.

    'It will read from I2C device with an address of 83, register 1.
    ' Change the processor
    #chip 16F1937, 32
    #config MCLRE_ON


    ' Define I2C settings
    #define HI2C_BAUD_RATE 400

    #define HI2C_DATA PORTC.4
      #define HI2C_CLOCK PORTC.3

    'I2C pins need to be input for SSP module
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in

    'MASTER I2C Device
    HI2CMode Master

    'Misc settings
    #define LED PORTB.0

    'Main loop
    Do
      'Send start
      HI2CStart

      'Request value
      HI2CSend 83
      HI2CSend 1

      'Read value
      HI2CReceive ValueIn

      'Send stop
      HI2CStop

      'Turn on LED if received value > 100
      Set LED Off
      If ValueIn > 100 Then Set LED On

      'Delay
      Wait 20 ms

    Loop
```

<span class="strong">**Example 2:**</span>

See the
<a href="i2c_overview" class="link" title="I2C Overview">I2C Overview</a>
for the Master mode device to control this Slave mode device.

``` screen
    ' I2CHardwareReceive_Slave.gcb - using a 16F88.
    ' This program receives commands from a GCB Master. This Slave has three LEDs attached.

    ; This Slave device responds to address 0x60 and may only be written to.
    ; Within it, there are three registers, 0,1 and 2 corresponding to the three LEDs. Writing a zero
    ; turns the respective LED off. Writing anything else turns it on.


    #chip 16F88, 4
    #config  MCLR_Off

    #define I2C_MODE    Slave     ;this is a slave device now
    #define I2C_CLOCK   portb.4   ;SCL on pin 10
    #define I2C_DATA    portb.1   ;SDA on pin 7
    #define I2C_ADDRESS 0x60      ;address of the slave device

    #define I2C_BIT_DELAY 20 us
    #define I2C_CLOCK_DELAY 10 us
    #define I2C_END_DELAY 10 us


    'Serial settings
    #define SerInPort PORTB.6
    #define SerOutPort PORTB.7

    #define SendAHigh Set SerOutPort OFF
    #define SendALow Set SerOutPort On
    'Set pin directions
    Dir SerOutPort Out
    Dir SerInPort In

    'Set up serial connection
    InitSer 1, r2400, 1 + WaitForStart, 8, 1, none, INVERT
    wait 1 s

    #define LED0  porta.2          ;pin 1
    #define LED1  porta.3          ;pin 2
    #define LED2  porta.4          ;pin 3

    ;----- Variables

    dim addr, reg, value,location as byte
    addr = 255
    reg = 255
    value = 255
    location = 0
    mempointer = 255

    ;----- Program

    dir LED0 out                  ;0, 1 and 2 are outputs (LEDs)
    dir LED1 out                  ;0, 1 and 2 are outputs (LEDs)
    dir LED2 out                  ;0, 1 and 2 are outputs (LEDs)

    set LED0 off
    set LED1 off
    set LED2 off

    #define SerialControlPort portb.3
    dir SerialControlPort in

    'Set up interrupt to process I2C

       dir I2C_CLOCK in           ; required to input for MSSP module
       dir I2C_DATA in            ; required to input for MSSP module
       SSPADD=I2C_ADDRESS         ; Slave address
       SSPSTAT=b'00000000'        ; configuration
       SSPCON=b'00110110'         ; configuration
       PIE1.SSPIE=1               ; enable interrupt


    repeat 3                      ;flash LEDs
      set LED0 on
      set LED1 on
      set LED2 on
      wait 50 ms
      set LED0 off
      set LED1 off
      set LED2 off
      wait  100 ms
    end Repeat

    oldvalue = 255                ; old value, set up value only
    oldreg = 255                  ; old value, set up value only

    UpdateLEDS                    ; call method to set LEDs
                    ; set up interrupt
    On Interrupt SSP1Ready call I2C_Interrupt

    do forever
       if reg <> oldreg then      ; only process when the reg is a new value
        oldreg = reg            ; retain old value
        show = 1                ; its time to show the LEDS!
        if  value <> oldvalue then    ; logic for tracking old values. You only want to update terminal once per change
          oldvalue = value
          show = 1
        end if
       end if

       UpdateLEDS                  ; Update date LEDs

                     ; update serial terminal
       if show = 1  and SerialControlPort = 1 then

        SerPrint 1, "0x"+hex(addr)
        SerSend 1,9

        SerPrint 1, STR(reg)
        SerSend 1,9

        SerPrint 1, STR(value)
        SerSend 1,10
        SerSend 1,13

        show = 0
       end if
    loop


    Sub I2C_Interrupt
      ' handle interrupt
      IF SSPIF=1 THEN                   ; its a valid interrupt

         IF SSPSTAT.D_A=0 THEN          ; its an address coming in!
          addr=SSPBUF
          IF addr=I2C_ADDRESS THEN    ; its our address

           mempointer = 0           ; set the memory pointer. This code emulates an EEPROM!

          end if
          IF addr = ( I2C_ADDRESS | 1 ) THEN    ; its our write address
           CKP = 0                            ; acknowledge command
                            ; If the SDA line was low (ACK), the transmit data must be loaded into
                            ; the SSPBUF register which also loads the SSPSR
                            ; register. Then, pin RB4/SCK/SCL should be enabled
                            ; by setting bit CKP.

           mempointer = 10                    ; set a pointer to track incoming write reqests
           if I2C_DATA = 0 then
            SSPBUF = 0x22
            CKP = 1
            readpointer = 0x55
           end if
          end if

         else

         if  SSPSTAT.P = 1 then             ' Stop bit has been detected - out of sequence
           ' handle event
         end if

         IF  SSPSTAT.S = 1 THEN             ' Start bit has been detected - out of sequence
           ' handle event
         END IF

         IF SSPSTAT.R_W = 0 THEN            ' Write operations requested

          SELECT CASE mempointer
               CASE 0
                reg = SSPBUF         ' incoming value
                mempointer++         ' increment our counter
               CASE 1
                value = SSPBUF       ' incoming value
                mempointer++         ' increment our counter
               CASE ELSE
                dummy = SSPBUF       ' incoming value
          END SELECT

         ELSE                                ' Read operations
          SSPBUF = readpointer             ' incoming value
          readpointer++                    ' increment our counter

         END IF
         END IF
         CKP = 1                               ' acknowledge command
         SSPOV = 0                             ' acknowledge command
      END IF
      SSPIF=0
    END SUB



    sub UpdateLEDS

      select case reg           ;now turn proper LED on or off
        case 0
        if value = 1 then
          set LED0 on
        else
          set LED0 off
        end if

        case 1
        if value = 1 then
          set LED1 on
        else
          set LED1 off
        end if

        case 2
        if value = 1 then
          set LED2 on
        else
          set LED2 off
        end if

      end select

    End Sub
```

Supported in &lt;HI2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HI2CRestart</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"><link rel="prev" href="_hi2creceive.html" title="HI2CReceive"><link rel="next" href="_hi2cstart.html" title="HI2CStart"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hi2crestart"></a>HI2CRestart</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HI2CRestart</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available for microcontrollers with the hardware I2C or TWI module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>If the HI2C routines are operating in Master mode, this command will
send a start and restart condition in a single command.</p><p><span class="strong"><strong>Note:</strong></span></p><p>This command is also available on microcontrollers with a second hardware I2C port.</p><pre class="screen">    HI2C2Restart</pre><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    do
        HI2CReStart                           ;generate a start signal
        HI2CSend(eepDev)                      ;inidcate a write
    loop While HI2CAckPollState

    HI2CSend(eepAddr_H)                   ;as two bytes
    HI2CSend(eepAddr)
    HI2CReStart
    HI2CSend(eepDev + 1)                  ;indicate a read

    eep_i = 0                             ;loop consecutively
    do while (eep_i &lt; eepLen)             ;these many bytes
        eep_j = eep_i + 1                   ;arrays begin at 1 not 0
        if (eep_i  &lt; (eepLen - 1)) then
        HI2CReceive(eepArray(eep_j), ACK)  ;more data to get
        else
        HI2CReceive(eepArray(eep_j), NACK ) ;send NACK on last byte
        end if
        eep_i++                             ;get set for next
    loop
    HI2CStop</pre><p>Supported in &lt;HI2C.H&gt;</p><pre class="literallayout">==== HI2CSend</pre><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HI2CSend <span class="emphasis"><em>data</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available for microcontrollers with the hardware I2C or TWI module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The HI2CSend command will send <code class="literal"><span class="emphasis"><em>data</em></span></code> through the I2C connection.
If in master mode, HI2CSend will send the data immediately. If in slave
mode, HI2CSend will wait for the master to request the data before
sending.</p><p><span class="strong"><strong>Note:</strong></span></p><p>This command is also available on microcontrollers with a second hardware I2C port.</p><pre class="screen">    HI2C2Send  data</pre><p><span class="strong"><strong>Example:</strong></span></p><p>This example code retrieves multiple bytes from an EEPROM memory device.</p><pre class="screen">	do
	  HI2CReStart                         ;generate a start signal
	  HI2CSend(eepDev)                    ;indicate a write
	loop While HI2CAckPollState

	HI2CSend(eepAddr_H)                   ;as two bytes
	HI2CSend(eepAddr)
	HI2CReStart
	HI2CSend(eepDev + 1)                  ;indicate a read

	eep_i = 0                             ;loop consecutively
	do while (eep_i &lt; eepLen)             ;these many bytes
	  eep_j = eep_i + 1                   ;arrays begin at 1 not 0
	  if (eep_i  &lt; (eepLen - 1)) then
		HI2CReceive(eepArray(eep_j), ACK)  ;more data to get
	  else
		HI2CReceive(eepArray(eep_j), NACK ) ;send NACK on last byte
	  end if
	  eep_i++                             ;get set for next
	loop
	HI2CStop</pre><p>Supported in &lt;HI2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hi2crestart"></span>HI2CRestart

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HI2CRestart
```

<span class="strong">**Command Availability:**</span>

Only available for microcontrollers with the hardware I2C or TWI module.

<span class="strong">**Explanation:**</span>

If the HI2C routines are operating in Master mode, this command will
send a start and restart condition in a single command.

<span class="strong">**Note:**</span>

This command is also available on microcontrollers with a second
hardware I2C port.

``` screen
    HI2C2Restart
```

<span class="strong">**Example:**</span>

``` screen
    do
        HI2CReStart                           ;generate a start signal
        HI2CSend(eepDev)                      ;inidcate a write
    loop While HI2CAckPollState

    HI2CSend(eepAddr_H)                   ;as two bytes
    HI2CSend(eepAddr)
    HI2CReStart
    HI2CSend(eepDev + 1)                  ;indicate a read

    eep_i = 0                             ;loop consecutively
    do while (eep_i < eepLen)             ;these many bytes
        eep_j = eep_i + 1                   ;arrays begin at 1 not 0
        if (eep_i  < (eepLen - 1)) then
        HI2CReceive(eepArray(eep_j), ACK)  ;more data to get
        else
        HI2CReceive(eepArray(eep_j), NACK ) ;send NACK on last byte
        end if
        eep_i++                             ;get set for next
    loop
    HI2CStop
```

Supported in &lt;HI2C.H&gt;

``` literallayout
==== HI2CSend
```

<span class="strong">**Syntax:**</span>

``` screen
    HI2CSend data
```

<span class="strong">**Command Availability:**</span>

Only available for microcontrollers with the hardware I2C or TWI module.

<span class="strong">**Explanation:**</span>

The HI2CSend command will send `data` through the I2C connection. If in
master mode, HI2CSend will send the data immediately. If in slave mode,
HI2CSend will wait for the master to request the data before sending.

<span class="strong">**Note:**</span>

This command is also available on microcontrollers with a second
hardware I2C port.

``` screen
    HI2C2Send  data
```

<span class="strong">**Example:**</span>

This example code retrieves multiple bytes from an EEPROM memory device.

``` screen
 do
      HI2CReStart                         ;generate a start signal
      HI2CSend(eepDev)                    ;indicate a write
    loop While HI2CAckPollState

    HI2CSend(eepAddr_H)                   ;as two bytes
    HI2CSend(eepAddr)
    HI2CReStart
    HI2CSend(eepDev + 1)                  ;indicate a read

    eep_i = 0                             ;loop consecutively
    do while (eep_i < eepLen)             ;these many bytes
      eep_j = eep_i + 1                   ;arrays begin at 1 not 0
      if (eep_i  < (eepLen - 1)) then
        HI2CReceive(eepArray(eep_j), ACK)  ;more data to get
      else
        HI2CReceive(eepArray(eep_j), NACK ) ;send NACK on last byte
      end if
      eep_i++                             ;get set for next
    loop
    HI2CStop
```

Supported in &lt;HI2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HI2CSetAddress</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"><link rel="prev" href="_hi2cmode.html" title="HI2CMode"><link rel="next" href="_hi2cstop.html" title="HI2CStop"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hi2csetaddress"></a>HI2CSetAddress</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HI2CSetAddress address_number</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available for microcontrollers with the hardware I2C or TWI module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Sets the microcontroller address number in Slave mode.</p><p>Only used in slave mode.</p><p><span class="strong"><strong>Note:</strong></span></p><p>This command is also available on microcontrollers with a second hardware I2C port.</p><pre class="screen">    HI2C2SetAddress address_number</pre><p>Supported in &lt;HI2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hi2csetaddress"></span>HI2CSetAddress

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HI2CSetAddress address_number
```

<span class="strong">**Command Availability:**</span>

Only available for microcontrollers with the hardware I2C or TWI module.

<span class="strong">**Explanation:**</span>

Sets the microcontroller address number in Slave mode.

Only used in slave mode.

<span class="strong">**Note:**</span>

This command is also available on microcontrollers with a second
hardware I2C port.

``` screen
    HI2C2SetAddress address_number
```

Supported in &lt;HI2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HI2CStart</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"><link rel="prev" href="_hi2crestart.html" title="HI2CRestart"><link rel="next" href="_hi2cstartoccurred.html" title="HI2CStartOccurred"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hi2cstart"></a>HI2CStart</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HI2CStart</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available for microcontrollers with the hardware I2C or TWI module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>If the HI2C routines are operating in Master mode, this command will
send a start condition. If routines are in Slave mode, it will pause the
program until a start condition is sent by the master. It should be
placed at the start of every I2C transmission.</p><p><span class="strong"><strong>Note:</strong></span></p><p>This command is also available on microcontrollers with a second hardware I2C port.</p><pre class="screen">    HI2C2Start</pre><p><span class="strong"><strong>Example:</strong></span></p><p>Please see <a class="link" href="">HI2CSend</a> and <a class="link" href="_hi2creceive.html" title="HI2CReceive">HI2CReceive</a> for
examples.</p><p>Supported in &lt;HI2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hi2cstart"></span>HI2CStart

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HI2CStart
```

<span class="strong">**Command Availability:**</span>

Only available for microcontrollers with the hardware I2C or TWI module.

<span class="strong">**Explanation:**</span>

If the HI2C routines are operating in Master mode, this command will
send a start condition. If routines are in Slave mode, it will pause the
program until a start condition is sent by the master. It should be
placed at the start of every I2C transmission.

<span class="strong">**Note:**</span>

This command is also available on microcontrollers with a second
hardware I2C port.

``` screen
    HI2C2Start
```

<span class="strong">**Example:**</span>

Please see <a href="" class="link">HI2CSend</a> and
<a href="hi2creceive" class="link" title="HI2CReceive">HI2CReceive</a>
for examples.

Supported in &lt;HI2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HI2CStartOccurred</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"><link rel="prev" href="_hi2cstart.html" title="HI2CStart"><link rel="next" href="_hi2cmode.html" title="HI2CMode"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hi2cstartoccurred"></a>HI2CStartOccurred</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HI2CStartOccurred</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available for microcontrollers with the hardware I2C or TWI module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Check if a start condition has occurred since the last run of this
function</p><p>Only used in slave mode.</p><p><span class="strong"><strong>Note:</strong></span></p><p>This command is also available on microcontrollers with a second hardware I2C port.</p><pre class="screen">    HI2C2StartOccurred</pre><p>Supported in &lt;HI2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hi2cstartoccurred"></span>HI2CStartOccurred

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HI2CStartOccurred
```

<span class="strong">**Command Availability:**</span>

Only available for microcontrollers with the hardware I2C or TWI module.

<span class="strong">**Explanation:**</span>

Check if a start condition has occurred since the last run of this
function

Only used in slave mode.

<span class="strong">**Note:**</span>

This command is also available on microcontrollers with a second
hardware I2C port.

``` screen
    HI2C2StartOccurred
```

Supported in &lt;HI2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HI2CStop</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"><link rel="prev" href="_hi2csetaddress.html" title="HI2CSetAddress"><link rel="next" href="_hi2cstopped.html" title="HI2CStopped"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hi2cstop"></a>HI2CStop</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HI2CStop</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available for microcontrollers with the hardware I2C or TWI module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">HI2CStop</code> should be called at the end of every I2C transmission.</p><p><span class="strong"><strong>Note:</strong></span></p><p>This command is also available on microcontrollers with a second hardware I2C port.</p><pre class="screen">    HI2C2Stop</pre><p><span class="strong"><strong>Example:</strong></span></p><p>Please see <a class="link" href="">HI2CSend</a> and <a class="link" href="_hi2creceive.html" title="HI2CReceive">HI2CReceive</a> for an
example.</p><p>Supported in &lt;HI2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hi2cstop"></span>HI2CStop

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HI2CStop
```

<span class="strong">**Command Availability:**</span>

Only available for microcontrollers with the hardware I2C or TWI module.

<span class="strong">**Explanation:**</span>

`HI2CStop` should be called at the end of every I2C transmission.

<span class="strong">**Note:**</span>

This command is also available on microcontrollers with a second
hardware I2C port.

``` screen
    HI2C2Stop
```

<span class="strong">**Example:**</span>

Please see <a href="" class="link">HI2CSend</a> and
<a href="hi2creceive" class="link" title="HI2CReceive">HI2CReceive</a>
for an example.

Supported in &lt;HI2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HI2CStopped</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"><link rel="prev" href="_hi2cstop.html" title="HI2CStop"><link rel="next" href="_hi2cwaitmssp.html" title="HI2CWaitMSSP"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hi2cstopped"></a>HI2CStopped</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HI2CStopped</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available for microcontrollers with the hardware I2C or TWI module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>In Slave mode only. Check if start condition received since last used of
HI2CStopped.</p><p><span class="strong"><strong>Note:</strong></span></p><p>This command is also available on microcontrollers with a second hardware I2C port.</p><pre class="screen">    HI2C2Stopped</pre><p>Supported in &lt;HI2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hi2cstopped"></span>HI2CStopped

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HI2CStopped
```

<span class="strong">**Command Availability:**</span>

Only available for microcontrollers with the hardware I2C or TWI module.

<span class="strong">**Explanation:**</span>

In Slave mode only. Check if start condition received since last used of
HI2CStopped.

<span class="strong">**Note:**</span>

This command is also available on microcontrollers with a second
hardware I2C port.

``` screen
    HI2C2Stopped
```

Supported in &lt;HI2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HI2CWaitMSSP</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"><link rel="prev" href="_hi2cstopped.html" title="HI2CStopped"><link rel="next" href="_sound.html" title="Sound"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hi2cwaitmssp"></a>HI2CWaitMSSP</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HI2CWaitMSSP</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available for microcontrollers with the hardware I2C or TWI module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The methods sets the global byte variable <span class="emphasis"><em>HI2CWaitMSSPTimeout</em></span> to 255 ( or True ) if the MSSP module has timeout during operations.</p><p><span class="emphasis"><em>HI2CWaitMSSPTimeout</em></span> can tested for the status of the I2C bus.</p><p><span class="strong"><strong>Note:</strong></span></p><p>This command is also available on microcontrollers with a second hardware I2C port.</p><pre class="screen">    HI2C2WaitMSSP</pre><p>Supported in &lt;HI2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hi2cwaitmssp"></span>HI2CWaitMSSP

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HI2CWaitMSSP
```

<span class="strong">**Command Availability:**</span>

Only available for microcontrollers with the hardware I2C or TWI module.

<span class="strong">**Explanation:**</span>

The methods sets the global byte variable <span
class="emphasis">*HI2CWaitMSSPTimeout*</span> to 255 ( or True ) if the
MSSP module has timeout during operations.

<span class="emphasis">*HI2CWaitMSSPTimeout*</span> can tested for the
status of the I2C bus.

<span class="strong">**Note:**</span>

This command is also available on microcontrollers with a second
hardware I2C port.

``` screen
    HI2C2WaitMSSP
```

Supported in &lt;HI2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HI2C Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"><link rel="prev" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"><link rel="next" href="_hi2cackpollstate.html" title="HI2CAckPollState"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hi2c_overview"></a>HI2C Overview</h4></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>These methods allow GCBASIC programs to send and receive Inter- Integrated Circuit (I2C&#8482;) messages via:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Master Synchronous Serial Port (MSSP) module of the microcontroller for the Microchip PIC architecture, or</li><li class="listitem">ATMEL 2-wire Serial Interface (TWI) for the Atmel AVR microcontroller architecture.</li></ul></div><p>These methods are serial interfaces that are useful for communicating with other peripheral or microcontroller devices.
These peripheral devices may be serial EEPROMs, shift registers, display drivers, A/D converters, etc.</p><p>This method can operate in one of two operational modes:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Master Mode, or</li><li class="listitem">Slave mode (with general address call)</li></ul></div><p>These methods fully implement all the I2C master and slave functions (including general call support) and
supports interrupts on start and stop bits in hardware to determine a free bus (multi-master function).</p><p>These methods implement the standard mode specifications as well as 7-bit and 10-bit addressing.
A &#8220;glitch&#8221; filter is built into the SCL and SDA pins when the pin is an input.  This filter operates in both
the 100 KHz and 400 KHz modes. In the 100 KHz mode, when these pins are an output, there
is a slew rate control of the pin that is independent of device frequency.</p><p>A hardware I2C/TWI module within the microcontroller is required for these methods.</p><p>The driver supports two hardware I2C ports.  The second port is addressed by the suffix HI2C2.  All HI2C commands are applicable to the second HI2C2 port.</p><p>For the Microchip I2C modules Specific for the 18F class including the K42, K83 and Q10, see the later section regarding clock sources and I2C frequencies.</p><p>The method supports the following frequencies:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Frequency</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Description</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Support</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>Up to 400 kbits/s</p></td><td align="left" valign="top"><p>I2C/TWI <code class="literal">fast mode</code>: Defined as transfer rates up to 400 kbit/s.</p></td><td align="left" valign="top"><p>Supported</p></td></tr><tr><td align="left" valign="top"><p>Up to 100 kbit/s.</p></td><td align="left" valign="top"><p>I2C/TWI <code class="literal">standard mode</code>:  Defined as transfer rates up to 100 kbit/s.</p></td><td align="left" valign="top"><p>Supported</p></td></tr><tr><td align="left" valign="top"><p>Up to 1 Mbit/s.</p></td><td align="left" valign="top"><p>I2C <code class="literal">fast-mode plus</code>: Allowing up to 1 Mbit/s.</p></td><td align="left" valign="top"><p>Supported on I2C Module Only
</p><p>Requires alternative clock source to be set.</p></td></tr><tr><td align="left" valign="top"><p>Up to 3.4 Mbit/s.</p></td><td align="left" valign="top"><p>I2C <code class="literal">high speed</code>: Allowing up to 3.4 Mbit/s.</p></td><td align="left" valign="top"><p>Supported on I2C Module Only
</p><p>Requires alternative clock source to be set.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>These constants control the setup of the hardware I2C methods:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Usage</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">Master</code></p></td><td align="left" valign="top"><p>Operational mode of the microcontroller</p></td><td align="left" valign="top"><p><code class="literal">HI2CMode ( <span class="emphasis"><em>Master</em></span> )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Slave</code></p></td><td align="left" valign="top"><p>Operational mode of the microcontroller</p></td><td align="left" valign="top"><p><code class="literal">HI2CMode ( <span class="emphasis"><em>Slave</em></span> )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HI2C_BAUD_RATE</code></p></td><td align="left" valign="top"><p>Operational speed of the microcontroller. Defaults to 100 kbit/s</p></td><td align="left" valign="top"><p>For Microchip SSP or MSSP modules and AVR microcontrollers:
</p><p><code class="literal">#define HI2C_BAUD_RATE 400</code>   or <br>
<code class="literal">#define HI2C_BAUD_RATE 100.</code><br>
Where  <code class="literal">#define HI2C_BAUD_RATE 100</code> is the default value and therefore does need to be specified.
</p><p>For Microchip I2C module:
</p><p>'define HI2C_BAUD_RATE 125' is the default KHz.  You can override this value if you set up an alternative clock source.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HI2CITSCLWaitPeriod</code></p></td><td align="left" valign="top"><p>Sets the TSCL period to Zero as the Stop condition must be held for TSCL after Stop transition.
Default to 70, some solutions can use this set to 0. The clock source and clock method must be reviewed before changing this setting.</p></td><td align="left" valign="top"><p>#define HI2CITSCLWaitPeriod 70</p></td></tr></tbody></table></div><p><span class="strong"><strong>Port Settings:</strong></span></p><p>The settings of the pin direction is critical to the operation of these
methods.
<br>
For the Microchip SSP/MSSP modules both ports <span class="strong"><strong>must</strong></span> be set as <span class="strong"><strong>input</strong></span>.
<br>
For the  Microchip I2C module both ports <span class="strong"><strong>must</strong></span> be set as <span class="strong"><strong>output</strong></span>.  And, configure the pins as open-drain and set the I2C levels - see example below for usage.
<br>
In all case the data and clock line *must * be pulled up with an
appropriate resistor (typically 4.k @ 5.0v for 100Mkz transmissions).
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">HI2C_DATA</code></p></td><td align="left" valign="top"><p>Pin on microcontroller connected to I2C data</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HI2C_CLOCK</code></p></td><td align="left" valign="top"><p>Pin on microcontroller connected to I2C clock)</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr></tbody></table></div><p><br>
<span class="strong"><strong>Microchip I2C modules Specific Support - 18F class including the K42, k47, K83, Q43, Q40/Q41, Q83/Q84, and Q71</strong></span></p><p>Clock Sources: The Microchip I2C can select one of ten clocks sources as shown in the table below.  I2C1Clock_MFINTOSC is the default which supports 125KHz.
<br>
<br>
It is important to change the clock source from the default of 125KHz if you want faster I2C communications.   Change the following constant to change the clock source.
Obviously, you setup the clock source correctly for I2C to operate:
<br>
<br></p><pre class="screen">        #define I2C1CLOCKSOURCE  I2C1CLOCK_MFINTOSC</pre><p>Clock Constants that can be I2C clock sources are</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Clock Source</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>I2C1CLOCK_SMT1</p></td><td align="left" valign="top"><p>SMT</p></td><td align="left" valign="top"><p>0x09+
</p><p>You MUST setup the SMT clock source.</p></td></tr><tr><td align="left" valign="top"><p>I2C1CLOCK_TIMER6PSO</p></td><td align="left" valign="top"><p>Timer 6 Postscaler</p></td><td align="left" valign="top"><p>0x08+
</p><p>You MUST setup the timer6 clock source.</p></td></tr><tr><td align="left" valign="top"><p>I2C1CLOCK_TIMER4PSO</p></td><td align="left" valign="top"><p>Timer 4 Postscaler</p></td><td align="left" valign="top"><p>0x07+
</p><p>You MUST setup the timer4 clock source.</p></td></tr><tr><td align="left" valign="top"><p>I2C1CLOCK_TIMER2PSO</p></td><td align="left" valign="top"><p>Timer 2 Postscaler</p></td><td align="left" valign="top"><p>0x06+
</p><p>You MUST setup the timer3 clock source.</p></td></tr><tr><td align="left" valign="top"><p>I2C1CLOCK_TIMER0OVERFLOW</p></td><td align="left" valign="top"><p>Timer 0 Overflow</p></td><td align="left" valign="top"><p>0x05+
</p><p>You MUST setup the timer0 clock source.</p></td></tr><tr><td align="left" valign="top"><p>I2C1CLOCK_REFERENCEOUT</p></td><td align="left" valign="top"><p>Reference clock out</p></td><td align="left" valign="top"><p>0x04+
</p><p>You MUST ensure the clock source generates a within specification clock source.  Check the datasheet for more details.</p></td></tr><tr><td align="left" valign="top"><p>I2C1CLOCK_MFINTOSC</p></td><td align="left" valign="top"><p>MFINTOSC</p></td><td align="left" valign="top"><p>0x03 (default)+
</p><p>This is the default and will set the I2C clock to 125KHz</p></td></tr><tr><td align="left" valign="top"><p>I2C1CLOCK_HFINTOSC</p></td><td align="left" valign="top"><p>HFINTOSC</p></td><td align="left" valign="top"><p>0x02+
</p><p>You MUST ensure the clock source generates a within specification clock source.  Check the datasheet for more details.</p></td></tr><tr><td align="left" valign="top"><p>I2C1CLOCK_FOSC</p></td><td align="left" valign="top"><p>FOSC</p></td><td align="left" valign="top"><p>0x01+
</p><p>You MUST ensure the clock source generates a within specification clock source.  Check the datasheet for more details.</p></td></tr><tr><td align="left" valign="top"><p>I2C1CLOCK_FOSC4</p></td><td align="left" valign="top"><p>FOSC/4</p></td><td align="left" valign="top"><p>0x00+
</p><p>You MUST ensure the clock source generates a within specification clock source.  Check the datasheet for more details.</p></td></tr></tbody></table></div><p><br>
<br>
This an example of using a Clock Source.  This example uses the SMTClock source as the clock source, the following methods implement the SMT as the clock source.  The defintion of the constant, the include, setting of the SMT period, initialisation and starting of the clock source are ALL required.
<br></p><pre class="screen">    'Set the clock source constant
    #define I2C1CLOCKSOURCE I2C1CLOCK_SMT1

    'include the SMT capability
    #Include &lt;SMT_Timers.h&gt;

    'Setup the SMT
    '400 KHz @ 64MHZ
    Setsmt1Period ( 39 )
      ' 100 KHz @ 64MHZ
      ' Setsmt1Period ( 158 )
    'Initialise and start the SMT
    InitSMT1(SMT_FOSC,SMTPres_1)
    StartSMT1</pre><p>For other clock sources refer to the appropriate datasheet.
<br>
<br>
Error Codes: This module has extensive error reporting. For the standard error report refer to the appropriate datasheet.  GCBASIC also exposes the following error messages to enable the user code to handle the errors appropriately.  These are exposed via the variable <code class="literal">HI2C1lastError</code> - the bits of the <code class="literal">HI2C1lastError</code> are set as in the table shown below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Error Value/Bit</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>I2C1_GOOD</p></td><td align="left" valign="top"><p>0</p></td></tr><tr><td align="left" valign="top"><p>I2C1_FAIL_TIMEOUT</p></td><td align="left" valign="top"><p>1</p></td></tr><tr><td align="left" valign="top"><p>I2C1_TXBE_TIMEOUT</p></td><td align="left" valign="top"><p>2</p></td></tr><tr><td align="left" valign="top"><p>I2C1_START_TIMEOUT</p></td><td align="left" valign="top"><p>4</p></td></tr><tr><td align="left" valign="top"><p>I2C1_RESTART_TIMEOUT</p></td><td align="left" valign="top"><p>8</p></td></tr><tr><td align="left" valign="top"><p>I2C1_RXBF_TIMEOUT</p></td><td align="left" valign="top"><p>16</p></td></tr><tr><td align="left" valign="top"><p>I2C1_ACK_TIMEOUT</p></td><td align="left" valign="top"><p>32</p></td></tr><tr><td align="left" valign="top"><p>I2C1_MDR_TIMEOUT</p></td><td align="left" valign="top"><p>64</p></td></tr><tr><td align="left" valign="top"><p>I2C1_STOP_TIMEOUT</p></td><td align="left" valign="top"><p>128</p></td></tr></tbody></table></div><p><br>
Shown below are two examples of using Hardware I2C with GCBASIC.</p><p><br>
<span class="strong"><strong>Example 1:</strong></span>
<br>
This example examines the IC2 modules using the Microchip SSP/MSSP module and the AVR microcontrollers.  This will display the result on a serial terminal.
This code will require adaption but the code shows an approach to
discover the IC2 devices.</p><pre class="screen">    #chip mega328p, 16
    #config MCLRE_ON

    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA PORTC.5
    #define HI2C_CLOCK PORTC.4
    'I2C pins need to be input for SSP module when used on Microchip PIC device
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in

    'MASTER MODE
    HI2CMode Master

    'USART/SERIAL PORT WORKS WITH max232 THEN TO PC Terminal
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    Dir PORTc.6 Out
    #define USART_DELAY 0 ms

    HSerPrintCRLF 2
    HSerPrint "Hardware I2C Discover using the "
    HSerPrint CHipNameStr
    HSerPrintCRLF 2

    for deviceID = 0 to 255
      HI2CStart
      HI2CSend ( deviceID )

      if HI2CAckPollState = false then

         if (( deviceID &amp; 1 ) = 0 ) then
         HSerPrint "W"
        else
         HSerPrint "R"
        end if
        HSerSend 9
        HSerPrint   "ID: 0x"
        HSerPrint   hex(deviceID)
        HSerSend 9
        HSerPrint "(d)"+str(deviceID)
        HSerPrintCRLF
        HI2CSend ( 0 )

      end if

      HI2CStop
    next
    HSerPrintCRLF
    HSerPrint   "End of Device Search"
    HSerPrintCRLF 2</pre><p><br>
<br>
This example examines the IC2 devices and displays on a serial terminal for the I2C module only.
<br>
This code will require adaption but the code shows an approach to discover the IC2 devices.
<br>
This code will only operate on the Microchip I2C module.
<br></p><pre class="screen">    #chip 18f25k42, 16
    #option Explicit
    #config MCLRE_ON

    #startup InitPPS, 85

    Sub InitPPS

          RC4PPS =      0x22   'RC4-&gt;I2C1:SDA1
          RC3PPS =      0x21   'RC3-&gt;I2C1:SCL1
          I2C1SCLPPS =  0x13   'RC3-&gt;I2C1:SCL1
          I2C1SDAPPS =  0x14   'RC4-&gt;I2C1:SDA1

          'Module: UART1
          RC6PPS = 0x0013     'TX1 &gt; RC6
          U1RXPPS = 0x0017    'RC7 &gt; RX1

    End Sub

    'Template comment at the end of the config file

    'Setup Serial port
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    ' Define I2C settings
    #define HI2C_BAUD_RATE 125
    #define HI2C_DATA PORTC.4
    #define HI2C_CLOCK PORTC.3
    'Initialise I2C - note for the I2C module the ports need to be set to Output.
    Dir HI2C_DATA out
    Dir HI2C_CLOCK out
    RC3I2C.TH0=1   'Port specific controls may be required - see the datasheet
    RC4I2C.TH0=1   'Port specific controls may be required - see the datasheet

    'For this solution we can set the TSCL period to Zero as the Stop condition must be held for TSCL after Stop transition
    #define HI2CITSCLWaitPeriod 0

    '*****************************************************************************************************
    'Main program commences here.. everything before this is setup for the board.

    dim DeviceID as byte
    Dim DISPLAYNEWLINE as Byte

     do

        HSerPrintCRLF
        HSerPrint "Hardware I2C "
        HSerPrintCRLF 2

          ' Now assumes Serial Terminal is operational
          HSerPrintCRLF
          HSerPrint "   "
          'Create a horizontal row of numbers
          for DeviceID = 0 to 15
            HSerPrint hex(deviceID)
            HSerPrint " "
          next

          'Create a vertical column of numbers
          for DeviceID = 0 to 255
            DisplayNewLine = DeviceID % 16
            if DisplayNewLine = 0 Then
              HSerPrintCRLF
              HserPrint hex(DeviceID)
              if DisplayNewLine &gt; 0 then
                HSerPrint " "
              end if
            end if
            HSerPrint " "

            'Do an initial Start
            HI2CStart
            if HI2CWaitMSSPTimeout &lt;&gt; True then

              'Send to address to device
              HI2CSend ( deviceID )

              'Did device fail to respond?
              if HI2CAckPollState = false then
                HI2CSend ( 0 )
                HSerPrint   hex(deviceID)
              Else
                HSerPrint "--"
              end if
              'Do a stop.
              HI2CStop

            Else
              HSerPrint "! "
            end if

          next

          HSerPrintCRLF 2
          HSerPrint   "End of Search"
          HSerPrintCRLF 2
          wait 1 s
          wait while SwitchIn = On
      loop</pre><p><br>
<br></p><p>Supported in &lt;HI2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hi2c_overview"></span>HI2C Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

These methods allow GCBASIC programs to send and receive Inter-
Integrated Circuit (I2C™) messages via:

<div class="itemizedlist">

-   Master Synchronous Serial Port (MSSP) module of the microcontroller
    for the Microchip PIC architecture, or
-   ATMEL 2-wire Serial Interface (TWI) for the Atmel AVR
    microcontroller architecture.

</div>

These methods are serial interfaces that are useful for communicating
with other peripheral or microcontroller devices. These peripheral
devices may be serial EEPROMs, shift registers, display drivers, A/D
converters, etc.

This method can operate in one of two operational modes:

<div class="itemizedlist">

-   Master Mode, or
-   Slave mode (with general address call)

</div>

These methods fully implement all the I2C master and slave functions
(including general call support) and supports interrupts on start and
stop bits in hardware to determine a free bus (multi-master function).

These methods implement the standard mode specifications as well as
7-bit and 10-bit addressing. A “glitch” filter is built into the SCL and
SDA pins when the pin is an input. This filter operates in both the 100
KHz and 400 KHz modes. In the 100 KHz mode, when these pins are an
output, there is a slew rate control of the pin that is independent of
device frequency.

A hardware I2C/TWI module within the microcontroller is required for
these methods.

The driver supports two hardware I2C ports. The second port is addressed
by the suffix HI2C2. All HI2C commands are applicable to the second
HI2C2 port.

For the Microchip I2C modules Specific for the 18F class including the
K42, K83 and Q10, see the later section regarding clock sources and I2C
frequencies.

The method supports the following frequencies:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Frequency</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Description</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Support</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Up to 400 kbits/s</p></td>
<td style="text-align: left;"><p>I2C/TWI <code class="literal">fast mode</code>: Defined as transfer rates up to 400 kbit/s.</p></td>
<td style="text-align: left;"><p>Supported</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Up to 100 kbit/s.</p></td>
<td style="text-align: left;"><p>I2C/TWI <code class="literal">standard mode</code>: Defined as transfer rates up to 100 kbit/s.</p></td>
<td style="text-align: left;"><p>Supported</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Up to 1 Mbit/s.</p></td>
<td style="text-align: left;"><p>I2C <code class="literal">fast-mode plus</code>: Allowing up to 1 Mbit/s.</p></td>
<td style="text-align: left;"><p>Supported on I2C Module Only</p>
<p>Requires alternative clock source to be set.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Up to 3.4 Mbit/s.</p></td>
<td style="text-align: left;"><p>I2C <code class="literal">high speed</code>: Allowing up to 3.4 Mbit/s.</p></td>
<td style="text-align: left;"><p>Supported on I2C Module Only</p>
<p>Requires alternative clock source to be set.</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Relevant Constants:**</span>

These constants control the setup of the hardware I2C methods:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constant</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Usage</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Master</code></p></td>
<td style="text-align: left;"><p>Operational mode of the microcontroller</p></td>
<td style="text-align: left;"><p><code class="literal">HI2CMode ( Master )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">Slave</code></p></td>
<td style="text-align: left;"><p>Operational mode of the microcontroller</p></td>
<td style="text-align: left;"><p><code class="literal">HI2CMode ( Slave )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">HI2C_BAUD_RATE</code></p></td>
<td style="text-align: left;"><p>Operational speed of the microcontroller. Defaults to 100 kbit/s</p></td>
<td style="text-align: left;"><p>For Microchip SSP or MSSP modules and AVR microcontrollers:</p>
<p><code class="literal">#define HI2C_BAUD_RATE 400</code> or<br />
<code class="literal">#define HI2C_BAUD_RATE 100.</code><br />
Where <code class="literal">#define HI2C_BAUD_RATE 100</code> is the default value and therefore does need to be specified.</p>
<p>For Microchip I2C module:</p>
<p>'define HI2C_BAUD_RATE 125' is the default KHz. You can override this value if you set up an alternative clock source.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HI2CITSCLWaitPeriod</code></p></td>
<td style="text-align: left;"><p>Sets the TSCL period to Zero as the Stop condition must be held for TSCL after Stop transition. Default to 70, some solutions can use this set to 0. The clock source and clock method must be reviewed before changing this setting.</p></td>
<td style="text-align: left;"><p>#define HI2CITSCLWaitPeriod 70</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Port Settings:**</span>

The settings of the pin direction is critical to the operation of these
methods.  
For the Microchip SSP/MSSP modules both ports <span
class="strong">**must**</span> be set as <span
class="strong">**input**</span>.  
For the Microchip I2C module both ports <span
class="strong">**must**</span> be set as <span
class="strong">**output**</span>. And, configure the pins as open-drain
and set the I2C levels - see example below for usage.  
In all case the data and clock line \*must \* be pulled up with an
appropriate resistor (typically 4.k @ 5.0v for 100Mkz transmissions).  

<div class="informaltable">

| <span class="strong">**Constant**</span> | <span class="strong">**Controls**</span>       | <span class="strong">**Default Value**</span> |
|:-----------------------------------------|:-----------------------------------------------|:----------------------------------------------|
| `HI2C_DATA`                              | Pin on microcontroller connected to I2C data   | Must be defined                               |
| `HI2C_CLOCK`                             | Pin on microcontroller connected to I2C clock) | Must be defined                               |

</div>

  
<span class="strong">**Microchip I2C modules Specific Support - 18F
class including the K42, k47, K83, Q43, Q40/Q41, Q83/Q84, and
Q71**</span>

Clock Sources: The Microchip I2C can select one of ten clocks sources as
shown in the table below. I2C1Clock\_MFINTOSC is the default which
supports 125KHz.  
  
It is important to change the clock source from the default of 125KHz if
you want faster I2C communications. Change the following constant to
change the clock source. Obviously, you setup the clock source correctly
for I2C to operate:  
  

``` screen
        #define I2C1CLOCKSOURCE  I2C1CLOCK_MFINTOSC
```

Clock Constants that can be I2C clock sources are

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constant</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Clock Source</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Default Value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>I2C1CLOCK_SMT1</p></td>
<td style="text-align: left;"><p>SMT</p></td>
<td style="text-align: left;"><p>0x09+</p>
<p>You MUST setup the SMT clock source.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>I2C1CLOCK_TIMER6PSO</p></td>
<td style="text-align: left;"><p>Timer 6 Postscaler</p></td>
<td style="text-align: left;"><p>0x08+</p>
<p>You MUST setup the timer6 clock source.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>I2C1CLOCK_TIMER4PSO</p></td>
<td style="text-align: left;"><p>Timer 4 Postscaler</p></td>
<td style="text-align: left;"><p>0x07+</p>
<p>You MUST setup the timer4 clock source.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>I2C1CLOCK_TIMER2PSO</p></td>
<td style="text-align: left;"><p>Timer 2 Postscaler</p></td>
<td style="text-align: left;"><p>0x06+</p>
<p>You MUST setup the timer3 clock source.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>I2C1CLOCK_TIMER0OVERFLOW</p></td>
<td style="text-align: left;"><p>Timer 0 Overflow</p></td>
<td style="text-align: left;"><p>0x05+</p>
<p>You MUST setup the timer0 clock source.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>I2C1CLOCK_REFERENCEOUT</p></td>
<td style="text-align: left;"><p>Reference clock out</p></td>
<td style="text-align: left;"><p>0x04+</p>
<p>You MUST ensure the clock source generates a within specification clock source. Check the datasheet for more details.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>I2C1CLOCK_MFINTOSC</p></td>
<td style="text-align: left;"><p>MFINTOSC</p></td>
<td style="text-align: left;"><p>0x03 (default)+</p>
<p>This is the default and will set the I2C clock to 125KHz</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>I2C1CLOCK_HFINTOSC</p></td>
<td style="text-align: left;"><p>HFINTOSC</p></td>
<td style="text-align: left;"><p>0x02+</p>
<p>You MUST ensure the clock source generates a within specification clock source. Check the datasheet for more details.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>I2C1CLOCK_FOSC</p></td>
<td style="text-align: left;"><p>FOSC</p></td>
<td style="text-align: left;"><p>0x01+</p>
<p>You MUST ensure the clock source generates a within specification clock source. Check the datasheet for more details.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>I2C1CLOCK_FOSC4</p></td>
<td style="text-align: left;"><p>FOSC/4</p></td>
<td style="text-align: left;"><p>0x00+</p>
<p>You MUST ensure the clock source generates a within specification clock source. Check the datasheet for more details.</p></td>
</tr>
</tbody>
</table>

</div>

  
  
This an example of using a Clock Source. This example uses the SMTClock
source as the clock source, the following methods implement the SMT as
the clock source. The defintion of the constant, the include, setting of
the SMT period, initialisation and starting of the clock source are ALL
required.  

``` screen
    'Set the clock source constant
    #define I2C1CLOCKSOURCE I2C1CLOCK_SMT1

    'include the SMT capability
    #Include <SMT_Timers.h>

    'Setup the SMT
    '400 KHz @ 64MHZ
    Setsmt1Period ( 39 )
      ' 100 KHz @ 64MHZ
      ' Setsmt1Period ( 158 )
    'Initialise and start the SMT
    InitSMT1(SMT_FOSC,SMTPres_1)
    StartSMT1
```

For other clock sources refer to the appropriate datasheet.  
  
Error Codes: This module has extensive error reporting. For the standard
error report refer to the appropriate datasheet. GCBASIC also exposes
the following error messages to enable the user code to handle the
errors appropriately. These are exposed via the variable
`HI2C1lastError` - the bits of the `HI2C1lastError` are set as in the
table shown below.

<div class="informaltable">

| <span class="strong">**Constant**</span> | <span class="strong">**Error Value/Bit**</span> |
|:-----------------------------------------|:------------------------------------------------|
| I2C1\_GOOD                               | 0                                               |
| I2C1\_FAIL\_TIMEOUT                      | 1                                               |
| I2C1\_TXBE\_TIMEOUT                      | 2                                               |
| I2C1\_START\_TIMEOUT                     | 4                                               |
| I2C1\_RESTART\_TIMEOUT                   | 8                                               |
| I2C1\_RXBF\_TIMEOUT                      | 16                                              |
| I2C1\_ACK\_TIMEOUT                       | 32                                              |
| I2C1\_MDR\_TIMEOUT                       | 64                                              |
| I2C1\_STOP\_TIMEOUT                      | 128                                             |

</div>

  
Shown below are two examples of using Hardware I2C with GCBASIC.

  
<span class="strong">**Example 1:**</span>  
This example examines the IC2 modules using the Microchip SSP/MSSP
module and the AVR microcontrollers. This will display the result on a
serial terminal. This code will require adaption but the code shows an
approach to discover the IC2 devices.

``` screen
    #chip mega328p, 16
    #config MCLRE_ON

    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA PORTC.5
    #define HI2C_CLOCK PORTC.4
    'I2C pins need to be input for SSP module when used on Microchip PIC device
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in

    'MASTER MODE
    HI2CMode Master

    'USART/SERIAL PORT WORKS WITH max232 THEN TO PC Terminal
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    Dir PORTc.6 Out
    #define USART_DELAY 0 ms

    HSerPrintCRLF 2
    HSerPrint "Hardware I2C Discover using the "
    HSerPrint CHipNameStr
    HSerPrintCRLF 2

    for deviceID = 0 to 255
      HI2CStart
      HI2CSend ( deviceID )

      if HI2CAckPollState = false then

         if (( deviceID & 1 ) = 0 ) then
         HSerPrint "W"
        else
         HSerPrint "R"
        end if
        HSerSend 9
        HSerPrint   "ID: 0x"
        HSerPrint   hex(deviceID)
        HSerSend 9
        HSerPrint "(d)"+str(deviceID)
        HSerPrintCRLF
        HI2CSend ( 0 )

      end if

      HI2CStop
    next
    HSerPrintCRLF
    HSerPrint   "End of Device Search"
    HSerPrintCRLF 2
```

  
  
This example examines the IC2 devices and displays on a serial terminal
for the I2C module only.  
This code will require adaption but the code shows an approach to
discover the IC2 devices.  
This code will only operate on the Microchip I2C module.  

``` screen
    #chip 18f25k42, 16
    #option Explicit
    #config MCLRE_ON

    #startup InitPPS, 85

    Sub InitPPS

          RC4PPS =      0x22   'RC4->I2C1:SDA1
          RC3PPS =      0x21   'RC3->I2C1:SCL1
          I2C1SCLPPS =  0x13   'RC3->I2C1:SCL1
          I2C1SDAPPS =  0x14   'RC4->I2C1:SDA1

          'Module: UART1
          RC6PPS = 0x0013     'TX1 > RC6
          U1RXPPS = 0x0017    'RC7 > RX1

    End Sub

    'Template comment at the end of the config file

    'Setup Serial port
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    ' Define I2C settings
    #define HI2C_BAUD_RATE 125
    #define HI2C_DATA PORTC.4
    #define HI2C_CLOCK PORTC.3
    'Initialise I2C - note for the I2C module the ports need to be set to Output.
    Dir HI2C_DATA out
    Dir HI2C_CLOCK out
    RC3I2C.TH0=1   'Port specific controls may be required - see the datasheet
    RC4I2C.TH0=1   'Port specific controls may be required - see the datasheet

    'For this solution we can set the TSCL period to Zero as the Stop condition must be held for TSCL after Stop transition
    #define HI2CITSCLWaitPeriod 0

    '*****************************************************************************************************
    'Main program commences here.. everything before this is setup for the board.

    dim DeviceID as byte
    Dim DISPLAYNEWLINE as Byte

     do

        HSerPrintCRLF
        HSerPrint "Hardware I2C "
        HSerPrintCRLF 2

          ' Now assumes Serial Terminal is operational
          HSerPrintCRLF
          HSerPrint "   "
          'Create a horizontal row of numbers
          for DeviceID = 0 to 15
            HSerPrint hex(deviceID)
            HSerPrint " "
          next

          'Create a vertical column of numbers
          for DeviceID = 0 to 255
            DisplayNewLine = DeviceID % 16
            if DisplayNewLine = 0 Then
              HSerPrintCRLF
              HserPrint hex(DeviceID)
              if DisplayNewLine > 0 then
                HSerPrint " "
              end if
            end if
            HSerPrint " "

            'Do an initial Start
            HI2CStart
            if HI2CWaitMSSPTimeout <> True then

              'Send to address to device
              HI2CSend ( deviceID )

              'Did device fail to respond?
              if HI2CAckPollState = false then
                HI2CSend ( 0 )
                HSerPrint   hex(deviceID)
              Else
                HSerPrint "--"
              end if
              'Do a stop.
              HI2CStop

            Else
              HSerPrint "! "
            end if

          next

          HSerPrintCRLF 2
          HSerPrint   "End of Search"
          HSerPrintCRLF 2
          wait 1 s
          wait while SwitchIn = On
      loop
```

  
  

Supported in &lt;HI2C.H&gt;

</div>
<div class="article" lang="en">

<div class="titlepage">

<div>

<div>

</div>

<div>

<div class="author">

### <span class="firstname">The GCBASIC development team @ 2024</span>

</div>

</div>

</div>

------------------------------------------------------------------------

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HPWMOff</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hpwm_ccp.html" title="HPWM CCP"><link rel="prev" href="_hpwmupdate_for_ccp_pwm_modules_s.html" title="HPWMUpdate for CCP/PWM Modules(s)"><link rel="next" href="_hpwm_ccptimern.html" title="HPWM_CCPTimerN"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_hpwmoff"></a>HPWMOff</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HPWMOff ( channel )   'selectively turn off the CCP channel

    HPWMOff               'turn off CCP channel 1 only</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available on Microchip PIC microcontrollers with Capture&amp;Compare/PWM (CCP) modules.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will disable the output of the CCP1/PWM module on the Microchip PIC chip.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Select chip model and speed
    #chip 16F877A, 20

    'Set the CCP1 pin to output mode
    DIR PORTC.2 out

    'Main code
    do
        'Turn up brightness over 2.5 seconds
        For Bright = 1 to 255
            HPWM 1, 40, Bright
            wait 10 ms
        next

        wait 1 s
        HPWMOff ( 1 )' turn off the PWM channel

    loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_hpwmoff.html" title="HPWMOff">HPWMOff</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="hpwmoff"></span>HPWMOff

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HPWMOff ( channel )   'selectively turn off the CCP channel

    HPWMOff               'turn off CCP channel 1 only
```

<span class="strong">**Command Availability:**</span>

Only available on Microchip PIC microcontrollers with
Capture&Compare/PWM (CCP) modules.

<span class="strong">**Explanation:**</span>

This command will disable the output of the CCP1/PWM module on the
Microchip PIC chip.

<span class="strong">**Example:**</span>

``` screen
    'Select chip model and speed
    #chip 16F877A, 20

    'Set the CCP1 pin to output mode
    DIR PORTC.2 out

    'Main code
    do
        'Turn up brightness over 2.5 seconds
        For Bright = 1 to 255
            HPWM 1, 40, Bright
            wait 10 ms
        next

        wait 1 s
        HPWMOff ( 1 )' turn off the PWM channel

    loop
```

<span class="strong">**For more help, see**</span>
<a href="hpwmoff" class="link" title="HPWMOff">HPWMOff</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HPWMOff</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hpwm_ccptimern.html" title="HPWM_CCPTimerN"><link rel="prev" href="_hpwm_ccptimern.html" title="HPWM_CCPTimerN"><link rel="next" href="_hpwm_10_bit.html" title="HPWM 10 Bit"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_hpwmoff_2"></a>HPWMOff</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HPWMOff ( channel )   'selectively turn off the CCP channel

    HPWMOff               'turn off CCP channel 1 only</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available on Microchip PIC microcontrollers with Capture&amp;Compare/PWM (CCP) modules.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will disable the output of the CCP1/PWM module on the Microchip PIC chip.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Select chip model and speed
    #chip 16F877A, 20

    'Set the CCP1 pin to output mode
    DIR PORTC.2 out

    'Main code
    do
        'Turn up brightness over 2.5 seconds
        For Bright = 1 to 255
            HPWM 1, 40, Bright
            wait 10 ms
        next

        wait 1 s
        HPWMOff ( 1 )' turn off the PWM channel

    loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_hpwmoff.html" title="HPWMOff">HPWMOff</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="hpwmoff_2"></span>HPWMOff

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HPWMOff ( channel )   'selectively turn off the CCP channel

    HPWMOff               'turn off CCP channel 1 only
```

<span class="strong">**Command Availability:**</span>

Only available on Microchip PIC microcontrollers with
Capture&Compare/PWM (CCP) modules.

<span class="strong">**Explanation:**</span>

This command will disable the output of the CCP1/PWM module on the
Microchip PIC chip.

<span class="strong">**Example:**</span>

``` screen
    'Select chip model and speed
    #chip 16F877A, 20

    'Set the CCP1 pin to output mode
    DIR PORTC.2 out

    'Main code
    do
        'Turn up brightness over 2.5 seconds
        For Bright = 1 to 255
            HPWM 1, 40, Bright
            wait 10 ms
        next

        wait 1 s
        HPWMOff ( 1 )' turn off the PWM channel

    loop
```

<span class="strong">**For more help, see**</span>
<a href="hpwmoff" class="link" title="HPWMOff">HPWMOff</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HPWMOff</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hpwm_10_bit.html" title="HPWM 10 Bit"><link rel="prev" href="_hpwmupdate_for_pwm_module_s.html" title="HPWMUpdate for PWM Module(s)"><link rel="next" href="_hpwm_16_bit.html" title="HPWM 16 Bit"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_hpwmoff_3"></a>HPWMOff</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HPWMOff ( channel, PWMHardware )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available on Microchip PIC microcontrollers with PWM modules.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will disable the output of the PWM module on the Microchip PIC chip.<br></p><p><code class="literal">PWMHardware</code> is a GCBASIC defined constant not a user vaariable.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen"> 'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F18855, 32

    'Generated by PIC PPS Tool for GCBASIC
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM6
            RA2PPS = 0x000E    'PWM6OUT &gt; RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    'Main code
    For ForLoop = 1 to 4
        'Turn up brightness over 2.5 seconds
        For Bright = 1 to 255
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
        'Turn down brightness over 2.5 seconds
        For Bright = 255 to 1 Step -1
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
    next

    HPWMOff 6, PWMHardware   'where PWMHardware is the defined constant or you can use TRUE</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="hpwmoff_3"></span>HPWMOff

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HPWMOff ( channel, PWMHardware )
```

<span class="strong">**Command Availability:**</span>

Only available on Microchip PIC microcontrollers with PWM modules.

<span class="strong">**Explanation:**</span>

This command will disable the output of the PWM module on the Microchip
PIC chip.  

`PWMHardware` is a GCBASIC defined constant not a user vaariable.

<span class="strong">**Example:**</span>

``` screen
 'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F18855, 32

    'Generated by PIC PPS Tool for GCBASIC
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM6
            RA2PPS = 0x000E    'PWM6OUT > RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    'Main code
    For ForLoop = 1 to 4
        'Turn up brightness over 2.5 seconds
        For Bright = 1 to 255
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
        'Turn down brightness over 2.5 seconds
        For Bright = 255 to 1 Step -1
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
    next

    HPWMOff 6, PWMHardware   'where PWMHardware is the defined constant or you can use TRUE
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HPWMUpdate for CCP/PWM Modules(s)</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hpwm_ccp.html" title="HPWM CCP"><link rel="prev" href="_hpwm_ccp.html" title="HPWM CCP"><link rel="next" href="_hpwmoff.html" title="HPWMOff"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_hpwmupdate_for_ccp_pwm_modules_s"></a>HPWMUpdate for CCP/PWM Modules(s)</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HPWMUpdate ( channel, duty_cycle )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on Microchip PIC microcontrollers with the CCP module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command updates the <span class="strong"><strong>duty cycle only</strong></span>.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">You <span class="strong"><strong>MUST</strong></span> have previously called the HPWM CCP command using the full command to set the channel specific settings for frequency and timer source.&nbsp;&nbsp;See the example below for the usage.</li><li class="listitem">You <span class="strong"><strong>MUST</strong></span> specify the constant #define <code class="literal">HPWM_FAST</code> to support HPWMUpdate when using CCP module.</li></ul></div><p>This command only supports the previously called HPWM CCP command, or, if you have set more than one HPWM CCP channel then to use the command you must have set the channel to the same frequency.</p><p>The command only supports the CCP module of the Microchip PIC microcontroller to generate
a PWM waveform at the previously defined frequency and timer source.</p><p><code class="literal"><span class="emphasis"><em>channel</em></span></code> is 1, 2, 3, 4 or  5. These corresponds to the CCP1 through to CCP5 respectively.&nbsp;&nbsp;The channel <span class="strong"><strong>MUST</strong></span> be supported by the microcontroller.&nbsp;&nbsp;&nbsp;Check the microcontroller specific datasheet for the available channel.</p><p><code class="literal"><span class="emphasis"><em>duty cycle</em></span></code> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 255 where 255 is 100% duty cycle.</p><p><span class="strong"><strong>Example for CCP PWM:</strong></span></p><pre class="screen">    'This program will alter the brightness of an LED using
    'hardware PWM.

    #chip 16F1938
    #option Explicit

    'Set the direction of the CCP/PWM port
    DIR portc.2 Out

    #define HPWM_FAST           'Required to support HPWMUpdate when using CCP module
    HPWM 1, 40, dutyvalue

    do
        'use for-loop to show the duty changing a 8bit value
        dim dutyvalue as byte
        for dutyvalue = 0 to 255
            HPWMUpdate 1, dutyvalue
            wait 10 ms
        next
        for dutyvalue = 254 to 1
            HPWMUpdate 1, dutyvalue
            wait 10 ms
        next
    loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_pwmoff.html" title="PWMOff">PWMOff</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="hpwmupdate_for_ccp_pwm_modules_s"></span>HPWMUpdate for CCP/PWM Modules(s)

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HPWMUpdate ( channel, duty_cycle )
```

<span class="strong">**Command Availability:**</span>

Available on Microchip PIC microcontrollers with the CCP module.

<span class="strong">**Explanation:**</span>

This command updates the <span class="strong">**duty cycle
only**</span>.

<div class="itemizedlist">

-   You <span class="strong">**MUST**</span> have previously called the
    HPWM CCP command using the full command to set the channel specific
    settings for frequency and timer source.  See the example below for
    the usage.
-   You <span class="strong">**MUST**</span> specify the constant
    \#define `HPWM_FAST` to support HPWMUpdate when using CCP module.

</div>

This command only supports the previously called HPWM CCP command, or,
if you have set more than one HPWM CCP channel then to use the command
you must have set the channel to the same frequency.

The command only supports the CCP module of the Microchip PIC
microcontroller to generate a PWM waveform at the previously defined
frequency and timer source.

`channel` is 1, 2, 3, 4 or 5. These corresponds to the CCP1 through to
CCP5 respectively.  The channel <span class="strong">**MUST**</span> be
supported by the microcontroller.   Check the microcontroller specific
datasheet for the available channel.

`duty cycle` specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 255 where 255 is 100% duty cycle.

<span class="strong">**Example for CCP PWM:**</span>

``` screen
    'This program will alter the brightness of an LED using
    'hardware PWM.

    #chip 16F1938
    #option Explicit

    'Set the direction of the CCP/PWM port
    DIR portc.2 Out

    #define HPWM_FAST           'Required to support HPWMUpdate when using CCP module
    HPWM 1, 40, dutyvalue

    do
        'use for-loop to show the duty changing a 8bit value
        dim dutyvalue as byte
        for dutyvalue = 0 to 255
            HPWMUpdate 1, dutyvalue
            wait 10 ms
        next
        for dutyvalue = 254 to 1
            HPWMUpdate 1, dutyvalue
            wait 10 ms
        next
    loop
```

<span class="strong">**For more help, see**</span>
<a href="pwmoff" class="link" title="PWMOff">PWMOff</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HPWMUpdate for PWM Module(s)</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hpwm_10_bit.html" title="HPWM 10 Bit"><link rel="prev" href="_hpwm_10_bit.html" title="HPWM 10 Bit"><link rel="next" href="_hpwmoff_3.html" title="HPWMOff"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_hpwmupdate_for_pwm_module_s"></a>HPWMUpdate for PWM Module(s)</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HPWMUpdate ( channel, duty_cycle )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on Microchip PIC microcontrollers with the PWM module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command updates the <span class="strong"><strong>duty cycle only</strong></span>.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">You <span class="strong"><strong>MUST</strong></span> have previously called the HPWM 10 Bit command using the full command (see <a class="link" href="_hpwm_10_bit.html" title="HPWM 10 Bit">HPWM 10 Bit</a>) to set the channel specific settings for frequency and timer source.&nbsp;&nbsp;See the example below for the usage.</li><li class="listitem">You <span class="strong"><strong>MUST</strong></span> have previously called the HPWM 10 Bit command with the same type of variable, or, use casting to ensure the variable tpye is the same type.</li></ul></div><p>This command only supports the previously called HPWM 10 Bit command, or, if you have set more than one HPWM 10 Bit PWM channel then to use the command you must have set the channel to the same frequency.</p><p>The command only supports the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform at the previously defined frequency and timer source.</p><p><code class="literal"><span class="emphasis"><em>channel</em></span></code> is 1, 2, 3, 4, 5, 6, 7 or 8. These corresponds to the HPWM1 through to HPWM8 respectively.&nbsp;&nbsp;The channel <span class="strong"><strong>MUST</strong></span> be supported by the microcontroller.&nbsp;&nbsp;&nbsp;Check the microcontroller specific datasheet for the available channel.</p><p><code class="literal"><span class="emphasis"><em>duty cycle</em></span></code> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 1023 where 1023 is 100% duty cycle.</p><p><span class="strong"><strong>Example for Hardware PWM:</strong></span></p><pre class="screen">    'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F18855, 32

    'Generated by PIC PPS Tool for GCBASIC
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM6
            RA2PPS = 0x000E    'PWM6OUT &gt; RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    'Setup PWM - this is mandated as this specifies the frequency and the clock source.
    'Uses casting [word] to ensure the intialisation value of Zero (0) is a treated as a word.  The variable type MUST match the HPWMUpdate variable type.
    HPWM 6, 40, [word]0, 2
    'Main code
    do
        'Turn up brightness over 2.5 seconds
        For Bright = 0 to 1023
            HPWMUpdate 6, Bright
            wait 10 ms
        next
        'Turn down brightness over 2.5 seconds
        For Bright = 1023 to 0 Step -1
            HPWMUpdate 6, Bright
            wait 10 ms
        next
    loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_pwmoff.html" title="PWMOff">PWMOff</a>, <a class="link" href="_hpwm_10_bit.html" title="HPWM 10 Bit">HPWM 10 Bit</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="hpwmupdate_for_pwm_module_s"></span>HPWMUpdate for PWM Module(s)

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HPWMUpdate ( channel, duty_cycle )
```

<span class="strong">**Command Availability:**</span>

Available on Microchip PIC microcontrollers with the PWM module.

<span class="strong">**Explanation:**</span>

This command updates the <span class="strong">**duty cycle
only**</span>.

<div class="itemizedlist">

-   You <span class="strong">**MUST**</span> have previously called the
    HPWM 10 Bit command using the full command (see
    <a href="hpwm_10_bit" class="link" title="HPWM 10 Bit">HPWM 10 Bit</a>)
    to set the channel specific settings for frequency and timer
    source.  See the example below for the usage.
-   You <span class="strong">**MUST**</span> have previously called the
    HPWM 10 Bit command with the same type of variable, or, use casting
    to ensure the variable tpye is the same type.

</div>

This command only supports the previously called HPWM 10 Bit command,
or, if you have set more than one HPWM 10 Bit PWM channel then to use
the command you must have set the channel to the same frequency.

The command only supports the hardware PWM module of the Microchip PIC
microcontroller to generate a PWM waveform at the previously defined
frequency and timer source.

`channel` is 1, 2, 3, 4, 5, 6, 7 or 8. These corresponds to the HPWM1
through to HPWM8 respectively.  The channel <span
class="strong">**MUST**</span> be supported by the
microcontroller.   Check the microcontroller specific datasheet for the
available channel.

`duty cycle` specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 1023 where 1023 is 100% duty cycle.

<span class="strong">**Example for Hardware PWM:**</span>

``` screen
    'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F18855, 32

    'Generated by PIC PPS Tool for GCBASIC
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM6
            RA2PPS = 0x000E    'PWM6OUT > RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    'Setup PWM - this is mandated as this specifies the frequency and the clock source.
    'Uses casting [word] to ensure the intialisation value of Zero (0) is a treated as a word.  The variable type MUST match the HPWMUpdate variable type.
    HPWM 6, 40, [word]0, 2
    'Main code
    do
        'Turn up brightness over 2.5 seconds
        For Bright = 0 to 1023
            HPWMUpdate 6, Bright
            wait 10 ms
        next
        'Turn down brightness over 2.5 seconds
        For Bright = 1023 to 0 Step -1
            HPWMUpdate 6, Bright
            wait 10 ms
        next
    loop
```

<span class="strong">**For more help, see**</span>
<a href="pwmoff" class="link" title="PWMOff">PWMOff</a>,
<a href="hpwm_10_bit" class="link" title="HPWM 10 Bit">HPWM 10 Bit</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HPWM 10 Bit</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microchip_pic_pwm_overview.html" title="Microchip PIC PWM Overview"><link rel="prev" href="_hpwmoff_2.html" title="HPWMOff"><link rel="next" href="_hpwmupdate_for_pwm_module_s.html" title="HPWMUpdate for PWM Module(s)"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hpwm_10_bit"></a>HPWM 10 Bit</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HPWM <span class="emphasis"><em>channel, frequency, duty cycle, timer [, resolution]</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p><span class="strong"><strong>Only</strong></span> available on Microchip PIC microcontrollers with the 10-bit PWM module.</p><p>For the Capture/Compare/PWM (CCP) module, see here <a class="link" href="_hpwm_ccp.html" title="HPWM CCP">HPWM CCP</a></p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle. Once this command
is called, the PWM will be emitted until PWMOff is called.</p><p><code class="literal"><span class="emphasis"><em>channel</em></span></code> is 1, 2, 3, 4, 5, 6, 7 or 8. These corresponds to the HPWM1 through to HPWM8 respectively.<br>
The 10-bit PWM channel <span class="strong"><strong>MUST</strong></span> be supported by the microcontroller.   Check the microcontroller specific datasheet for the available channel.</p><p><code class="literal"><span class="emphasis"><em>frequency</em></span></code> sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 255 KHz. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller (ie 40 Khz on
a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the best duty cycle
resolution possible.</p><p><code class="literal"><span class="emphasis"><em>duty cycle</em></span></code> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 1023 where 1023 is 100% duty cycle.&nbsp;&nbsp;&nbsp; This should be a WORD value. &nbsp;&nbsp;&nbsp;Note: Byte values are supported as a Byte value is factorised to a Word value. To use a Byte value and to ensure the 10-bit resolution you should cast the parameter as a Word, [WORD]byte_value or  [WORD]constant_value</p><p><code class="literal"><span class="emphasis"><em>timer</em></span></code> specifies the desired timer to be used. These can be timer 2, 4 or 6.</p><p>Optional <code class="literal"><span class="emphasis"><em>resolution</em></span></code> specifies the desired resolution to be used. These can be either 255 or 1023.  The rational of this optional parameter is to support the duty cycle with a BYTE or a WORD range.  If you call the method with a WORD the resolution will be set to 1023.</p><p><br>
<br>
<span class="strong"><strong>Notes:</strong></span></p><p>PWM channels 1 and 2 are disable by default.&nbsp;&nbsp;You must enable using the constants USE_HPWMn where n is the PWM channel you want to enable.&nbsp;&nbsp;You can disable any PWM channel by setting the appropiatge change to FALSE.</p><p>On some microcontrollers you may need to set the port.pin as an output for PWM to operated as desired.
<br></p><pre class="screen">        #define USE_HPWM1 TRUE
        #define USE_HPWM2 TRUE</pre><p><br>
<br>
<span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F18855, 32

    'Generated by PIC PPS Tool for GCBASIC
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM6
            RA2PPS = 0x000E    'PWM6OUT &gt; RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    dim Bright as word

    'Main code
    do
        'Turn up brightness over the range
        For Bright = 0 to 1023
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
        'Turn down brightness over the range
        For Bright = 1023 to 0 Step -1
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
    loop</pre><p><span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F1705, 32

    'Generated by PIC PPS Tool for GCBASIC
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM3
            RA2PPS = 0x000E    'PWM3OUT &gt; RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    dim Bright as word

    'Main code
    do
        'Turn up brightness over the range
        For Bright = 0 to 1023
            HPWM 3, 40, Bright, 2
            wait 10 ms
        next
        'Turn down brightness over the range
        For Bright = 1023 to 0 Step -1
            HPWM 3, 40, Bright, 2
            wait 10 ms
        next
    loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_pwmoff.html" title="PWMOff">PWMOff</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hpwm_10_bit"></span>HPWM 10 Bit

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HPWM channel, frequency, duty cycle, timer [, resolution]
```

<span class="strong">**Command Availability:**</span>

<span class="strong">**Only**</span> available on Microchip PIC
microcontrollers with the 10-bit PWM module.

For the Capture/Compare/PWM (CCP) module, see here
<a href="hpwm_ccp" class="link" title="HPWM CCP">HPWM CCP</a>

<span class="strong">**Explanation:**</span>

This command sets up the hardware PWM module of the Microchip PIC
microcontroller to generate a PWM waveform of the given frequency and
duty cycle. Once this command is called, the PWM will be emitted until
PWMOff is called.

`channel` is 1, 2, 3, 4, 5, 6, 7 or 8. These corresponds to the HPWM1
through to HPWM8 respectively.  
The 10-bit PWM channel <span class="strong">**MUST**</span> be supported
by the microcontroller. Check the microcontroller specific datasheet for
the available channel.

`frequency` sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 255 KHz. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller
(ie 40 Khz on a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the
best duty cycle resolution possible.

`duty cycle` specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 1023 where 1023 is 100% duty cycle.    This should be a
WORD value.    Note: Byte values are supported as a Byte value is
factorised to a Word value. To use a Byte value and to ensure the 10-bit
resolution you should cast the parameter as a Word, \[WORD\]byte\_value
or \[WORD\]constant\_value

`timer` specifies the desired timer to be used. These can be timer 2, 4
or 6.

Optional `resolution` specifies the desired resolution to be used. These
can be either 255 or 1023. The rational of this optional parameter is to
support the duty cycle with a BYTE or a WORD range. If you call the
method with a WORD the resolution will be set to 1023.

  
  
<span class="strong">**Notes:**</span>

PWM channels 1 and 2 are disable by default.  You must enable using the
constants USE\_HPWMn where n is the PWM channel you want to enable.  You
can disable any PWM channel by setting the appropiatge change to FALSE.

On some microcontrollers you may need to set the port.pin as an output
for PWM to operated as desired.  

``` screen
        #define USE_HPWM1 TRUE
        #define USE_HPWM2 TRUE
```

  
  
<span class="strong">**Example 1:**</span>

``` screen
    'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F18855, 32

    'Generated by PIC PPS Tool for GCBASIC
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM6
            RA2PPS = 0x000E    'PWM6OUT > RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    dim Bright as word

    'Main code
    do
        'Turn up brightness over the range
        For Bright = 0 to 1023
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
        'Turn down brightness over the range
        For Bright = 1023 to 0 Step -1
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
    loop
```

<span class="strong">**Example 2:**</span>

``` screen
    'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F1705, 32

    'Generated by PIC PPS Tool for GCBASIC
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM3
            RA2PPS = 0x000E    'PWM3OUT > RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    dim Bright as word

    'Main code
    do
        'Turn up brightness over the range
        For Bright = 0 to 1023
            HPWM 3, 40, Bright, 2
            wait 10 ms
        next
        'Turn down brightness over the range
        For Bright = 1023 to 0 Step -1
            HPWM 3, 40, Bright, 2
            wait 10 ms
        next
    loop
```

<span class="strong">**For more help, see**</span>
<a href="pwmoff" class="link" title="PWMOff">PWMOff</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HPWM 16 Bit</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microchip_pic_pwm_overview.html" title="Microchip PIC PWM Overview"><link rel="prev" href="_hpwmoff_3.html" title="HPWMOff"><link rel="next" href="_hpwm_fixed_mode.html" title="HPWM Fixed Mode"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hpwm_16_bit"></a>HPWM 16 Bit</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HPWM16 <span class="emphasis"><em>channel, frequency, duty cycle</em></span>    'Enable a 16-bit PWM channel'

    HPWM16On <span class="emphasis"><em>channel</em></span>                         'Enable a specific PWM channel using parameters set by the HPWM16 method'

    HPWM16Off <span class="emphasis"><em>channel</em></span>                        'Disable a specific PWM channel'</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p><span class="strong"><strong>Only</strong></span> available on Microchip PIC microcontrollers with the 16-bit PWM module.  16-bit PWM support includes both dynamic mode and fixed mode operations. See the examples below for usage.</p><p>The PIC microcontroller chip specific DAT file must contain <code class="literal">CHIPPWM16TYPE = 1</code>.&nbsp;&nbsp;
If the chip specific DAT does not contain <code class="literal">CHIPPWM16TYPE = 1</code> and the microcontroller does support PWM 16 Bit please report the omission to GCBASIC the support forum.&nbsp;&nbsp;</p><p>For the Capture/Compare/PWM (CCP) module or the 10-bit PWM module, see the other sections of the Help.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle. Once this command
is called, the PWM will be emitted until HPWM16Off method is called.</p><p><code class="literal"><span class="emphasis"><em>channel</em></span></code> is 1, 2, 3.. 12. These corresponds to the 16-bit PWM channel respectively.<br>
The 16-bit PWM channel <span class="strong"><strong>MUST</strong></span> be supported by the microcontroller.   Check the microcontroller specific datasheet for the available channel.</p><p><code class="literal"><span class="emphasis"><em>frequency</em></span></code> sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 0xFFFF. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller (ie 40 Khz on
a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the best duty cycle
resolution possible.</p><p><code class="literal"><span class="emphasis"><em>duty cycle</em></span></code> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 0xFFFF where 0xFFFF is 100% duty cycle.&nbsp;&nbsp;&nbsp; This should be a WORD value.</p><p><br>
<br></p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    ' This program will enable dynamic mode PWM signals
    '
    ' All the 12 PWM16 channels can configured at separate dynamic frequencies  dynamic duty, the syntax is:
    '
    ' HPWM16(xx, frequency, duty )
    '
    ' xx can be 1 through 12, for this specific microcontroller there are three PWM16 channels.
    '
    ' To set the parameters of GCBASIC PWM fixed mode for the channels use the commands shown below::

        #chip 12F1572, 32
        #config mclr=on

        Dir PORTA Out

        HPWM16(1, 30, 16384)   '30 kHz, 25% duty cycle (16384/65535)
        HPWM16(2, 30, 16384)   '30 kHz, 25% duty cycle (16384/65535)
        HPWM16(3, 30, 16384)   '30 kHz, 25% duty cycle (16384/65535)


        do Forever
        loop


        #define USE_HPWM16_1 TRUE
        #define USE_HPWM16_2 TRUE
        #define USE_HPWM16_3 TRUE
        #define USE_HPWM16_4 FALSE
        #define USE_HPWM16_5 FALSE
        #define USE_HPWM16_6 FALSE
        #define USE_HPWM16_7 FALSE
        #define USE_HPWM16_8 FALSE
        #define USE_HPWM16_9 FALSE
        #define USE_HPWM16_10 FALSE
        #define USE_HPWM16_11 FALSE
        #define USE_HPWM16_12 FALSE</pre><p><br>
<br>
The 16-bit library also supports fixed mode PWM operations.  The following two examples show the constants and the commands to control 16-bit PWM Fixed Mode operations.
<br>
<br>
<span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    ' This program will enable fix mode PWM signals
    '
    ' All the 12 PWM16 channels can configured at separate fixed frequencies and fixed duty, the syntax is:
    '
    ' #define HPWM16_xx_Freq 38     'Set frequency in KHz on channel xx
    ' #define HPWM16_xx_Duty 50     'Set duty cycle to 50%  on channel xx
    '
    ' xx can be 1 through 12
    '
    ' To set the parameters of GCBASIC PWM fixed mode on channel 1 use the following:
    '
    '    #define HPWM16_1_Freq 0.1 to &gt; 1000         'Set the frequency, but, the clock speed must be low for low PWM frequency
    '    #define HPWM16_1_Duty 0.1 to 100            'Set duty cycle as percentage 0-100%, just change the number
    '


        #chip 12F1572, 32
        #config mclr=on

        Dir PORTA Out

        #define HPWM16_1_Freq 400         '800Hz to greater than 1mhz... greater than 1mhz at a clock speed of 32hz provides a clipped square wave.
        #define HPWM16_1_Duty 50
        HPWM16On ( 1 )

        do Forever
        loop</pre><p><br>
<br>
<span class="strong"><strong>Example 3:</strong></span></p><pre class="screen">    ' This program will enable fix mode PWM signals
    '
    ' All the 12 PWM16 channels can configured at separate fixed frequencies and fixed duty, the syntax is:
    '
    ' #define HPWM16_xx_Freq 38     'Set frequency in KHz on channel xx
    ' #define HPWM16_xx_Duty 50     'Set duty cycle to 50%  on channel xx
    '
    ' xx can be 1 through 12, for this specific microcontroller there are three PWM16 channels.
    '
    ' To set the parameters of GCBASIC PWM fixed mode for the three channels use the following:

        #chip 12F1572, 32
        #config mclr=on

        Dir PORTA Out

        #define HPWM16_1_Freq 100         '100khz
        #define HPWM16_1_Duty 40          '40% duty
        HPWM16On ( 1 )

        #define HPWM16_2_Freq 200         '200khz
        #define HPWM16_2_Duty 50          '50% duty
        HPWM16On ( 2 )

        #define HPWM16_3_Freq 300         '300khz
        #define HPWM16_3_Duty 60          '60% duty
        HPWM16On ( 3 )

        do Forever
        loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_pwmoff.html" title="PWMOff">PWMOff</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hpwm_16_bit"></span>HPWM 16 Bit

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HPWM16 channel, frequency, duty cycle    'Enable a 16-bit PWM channel'

    HPWM16On channel                         'Enable a specific PWM channel using parameters set by the HPWM16 method'

    HPWM16Off channel                        'Disable a specific PWM channel'
```

<span class="strong">**Command Availability:**</span>

<span class="strong">**Only**</span> available on Microchip PIC
microcontrollers with the 16-bit PWM module. 16-bit PWM support includes
both dynamic mode and fixed mode operations. See the examples below for
usage.

The PIC microcontroller chip specific DAT file must contain
`CHIPPWM16TYPE = 1`.   If the chip specific DAT does not contain
`CHIPPWM16TYPE = 1` and the microcontroller does support PWM 16 Bit
please report the omission to GCBASIC the support forum.  

For the Capture/Compare/PWM (CCP) module or the 10-bit PWM module, see
the other sections of the Help.

<span class="strong">**Explanation:**</span>

This command sets up the hardware PWM module of the Microchip PIC
microcontroller to generate a PWM waveform of the given frequency and
duty cycle. Once this command is called, the PWM will be emitted until
HPWM16Off method is called.

`channel` is 1, 2, 3.. 12. These corresponds to the 16-bit PWM channel
respectively.  
The 16-bit PWM channel <span class="strong">**MUST**</span> be supported
by the microcontroller. Check the microcontroller specific datasheet for
the available channel.

`frequency` sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 0xFFFF. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller
(ie 40 Khz on a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the
best duty cycle resolution possible.

`duty cycle` specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 0xFFFF where 0xFFFF is 100% duty cycle.    This should
be a WORD value.

  
  

<span class="strong">**Example 1:**</span>

``` screen
    ' This program will enable dynamic mode PWM signals
    '
    ' All the 12 PWM16 channels can configured at separate dynamic frequencies  dynamic duty, the syntax is:
    '
    ' HPWM16(xx, frequency, duty )
    '
    ' xx can be 1 through 12, for this specific microcontroller there are three PWM16 channels.
    '
    ' To set the parameters of GCBASIC PWM fixed mode for the channels use the commands shown below::

        #chip 12F1572, 32
        #config mclr=on

        Dir PORTA Out

        HPWM16(1, 30, 16384)   '30 kHz, 25% duty cycle (16384/65535)
        HPWM16(2, 30, 16384)   '30 kHz, 25% duty cycle (16384/65535)
        HPWM16(3, 30, 16384)   '30 kHz, 25% duty cycle (16384/65535)


        do Forever
        loop


        #define USE_HPWM16_1 TRUE
        #define USE_HPWM16_2 TRUE
        #define USE_HPWM16_3 TRUE
        #define USE_HPWM16_4 FALSE
        #define USE_HPWM16_5 FALSE
        #define USE_HPWM16_6 FALSE
        #define USE_HPWM16_7 FALSE
        #define USE_HPWM16_8 FALSE
        #define USE_HPWM16_9 FALSE
        #define USE_HPWM16_10 FALSE
        #define USE_HPWM16_11 FALSE
        #define USE_HPWM16_12 FALSE
```

  
  
The 16-bit library also supports fixed mode PWM operations. The
following two examples show the constants and the commands to control
16-bit PWM Fixed Mode operations.  
  
<span class="strong">**Example 2:**</span>

``` screen
    ' This program will enable fix mode PWM signals
    '
    ' All the 12 PWM16 channels can configured at separate fixed frequencies and fixed duty, the syntax is:
    '
    ' #define HPWM16_xx_Freq 38     'Set frequency in KHz on channel xx
    ' #define HPWM16_xx_Duty 50     'Set duty cycle to 50%  on channel xx
    '
    ' xx can be 1 through 12
    '
    ' To set the parameters of GCBASIC PWM fixed mode on channel 1 use the following:
    '
    '    #define HPWM16_1_Freq 0.1 to > 1000         'Set the frequency, but, the clock speed must be low for low PWM frequency
    '    #define HPWM16_1_Duty 0.1 to 100            'Set duty cycle as percentage 0-100%, just change the number
    '


        #chip 12F1572, 32
        #config mclr=on

        Dir PORTA Out

        #define HPWM16_1_Freq 400         '800Hz to greater than 1mhz... greater than 1mhz at a clock speed of 32hz provides a clipped square wave.
        #define HPWM16_1_Duty 50
        HPWM16On ( 1 )

        do Forever
        loop
```

  
  
<span class="strong">**Example 3:**</span>

``` screen
    ' This program will enable fix mode PWM signals
    '
    ' All the 12 PWM16 channels can configured at separate fixed frequencies and fixed duty, the syntax is:
    '
    ' #define HPWM16_xx_Freq 38     'Set frequency in KHz on channel xx
    ' #define HPWM16_xx_Duty 50     'Set duty cycle to 50%  on channel xx
    '
    ' xx can be 1 through 12, for this specific microcontroller there are three PWM16 channels.
    '
    ' To set the parameters of GCBASIC PWM fixed mode for the three channels use the following:

        #chip 12F1572, 32
        #config mclr=on

        Dir PORTA Out

        #define HPWM16_1_Freq 100         '100khz
        #define HPWM16_1_Duty 40          '40% duty
        HPWM16On ( 1 )

        #define HPWM16_2_Freq 200         '200khz
        #define HPWM16_2_Duty 50          '50% duty
        HPWM16On ( 2 )

        #define HPWM16_3_Freq 300         '300khz
        #define HPWM16_3_Duty 60          '60% duty
        HPWM16On ( 3 )

        do Forever
        loop
```

<span class="strong">**For more help, see**</span>
<a href="pwmoff" class="link" title="PWMOff">PWMOff</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HPWM AVR OCRnx</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_atmel_avr_pwm_overview.html" title="ATMEL AVR PWM Overview"><link rel="prev" href="_atmel_avr_pwm_overview.html" title="ATMEL AVR PWM Overview"><link rel="next" href="_hpwm_fixed_mode_for_avr.html" title="HPWM Fixed Mode for AVR"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hpwm_avr_ocrnx"></a>HPWM AVR OCRnx</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">     HPWM <span class="emphasis"><em>channel</em></span>, <span class="emphasis"><em>frequency</em></span>, <span class="emphasis"><em>duty cycle</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>The HPWM command is available on Atmel AVR microcontrollers with an OCnx pin, and is compatible with the PIC HPWM command method.  Due to the the unique way of AVR PWM implementation, and code efficiency, there are some notable differences in the HPWM initialization and its use.</p><p>This command supports the Fast PWM Mode and period registers for their respective devices.  Typically Timer0 and Timer2 do not have a period register and the "A" channel is sacrificed to provide that function.  Therefore, channel 1 and channel 6 will not be available, but are documented for possible future use.  Some device Timers do not have an adjustable period register, so this command is not feasible (consult the datasheet).</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The HPWM command sets up the hardware PWM module of the Atmel AVR microcontrollers to generate a PWM waveform of the given frequency and duty cycle.  Once this command is called, the PWM will be emitted until the duty cycle parameter is written to zero.</p><p>If the need is just one particular frequency and duty cycle, one should use PWMOn and the constants PWM_Freq and PWM_Duty instead.  PWMOn for the AVR is uniquely assigned to the OC0B pin, or channel 2. PWMOff will only shutdown  the AVR HPWM channel 2.</p><p><code class="literal"><span class="emphasis"><em>channel</em></span></code> described as 1, 2, 3,&#8230;&#8203;16 correspond to the pins OCR0A, OCR0B&#8230;&#8203;.OCR5C as detailed in the <span class="emphasis"><em>channel</em></span> constant table.  Channel 1 and channel 6 are not available.</p><p><code class="literal"><span class="emphasis"><em>frequency</em></span></code> sets the frequency of the PWM output measured in Khz.  The maximum value allowed is 255 KHz. In situations that do not require a specific PWM frequency, the PWM frequency should equal approximately 4 times the clock speed (GCB chipMHz) of the microcontroller (ie 63 KHz on a 16 MHz chip, 32 KHz on 8 MHz, 4 Khz on 1 MHz).  This gives the best duty cycle resolution possible.  Alternate frequencies with good duty cycle resolution are 1Khz, and 4Khz with chipMhz values of 16 and 8 respectively.</p><p><code class="literal"><span class="emphasis"><em>duty cycle</em></span></code> specifies the desired duty cycle of the PWM signal, and ranges from 0 to 255 where 255 is 100% duty cycle.  The AVR fast PWM mode has a small spike at the extreme setting of  0x00, on most devices, with each period register rollover.  By using the HPWM command, and writing 0x00 to the duty cycle parameter, the PWM signal will shutdown completely and avoid the spike.  The PWM signal can then be restarted again with a new HPWM command.</p><p>Note: Due to the AVR having a timer prescaler of just 1, 8, and 64; the AVR frequency and duty cycle resolution will be different from the PIC frequency and duty cycle resolution.   The AVR HPWM parameters will likely need adjusting ,when substituted into an existing PIC program, and where accuracy is required.</p><p><span class="strong"><strong>HPWM Constants:</strong></span></p><p>The AVR HPWM timer constants for channel number control are shown in the table below.  Each timer constant needs to be defined for any one of the channels it controls.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Timer</strong></span><br>
<span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>AVRTC0</p></td><td align="left" valign="top"><p>Specifies AVR TC0 associated  with <span class="emphasis"><em>channel</em></span> 1, and 2</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRTC1</p></td><td align="left" valign="top"><p>Specifies AVR TC1 associated  with <span class="emphasis"><em>channel</em></span> 3, 4 and 5<br>
Channel 5 present on larger pinout devices</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRTC2</p></td><td align="left" valign="top"><p>Specifies AVR TC2 associated  with <span class="emphasis"><em>channel</em></span> 6, and 7</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRTC3</p></td><td align="left" valign="top"><p>Specifies AVR TC3 associated  with <span class="emphasis"><em>channel</em></span> 8, 9, and 10</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRTC4</p></td><td align="left" valign="top"><p>Specifies AVR TC4 associated  with <span class="emphasis"><em>channel</em></span> 11,12, and 13</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRTC5</p></td><td align="left" valign="top"><p>Specifies AVR TC5 associated  with <span class="emphasis"><em>channel</em></span> 14, 15, and 16</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr></tbody></table></div><p>The GCBASIC HPWM channel constants for output pin control are shown in the table below.  Each HPWM channel used needs to be defined.  The Port pin associated with each OCnx must be set to output.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Channel</strong></span><br>
<span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>AVRCHAN1</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 1 to the associated output pin OC0A<br>
OCR0A is used as period register and thus not available</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN2</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 2 to the associated output pin OC0B</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN3</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 3 to the associated output pin OC1A<br>
MUX&#8217;d  with OC0A pin on some ATTiny&#8217;s</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN4</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 4 to the associated output pin OC1B</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN5</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 5 to the associated output pin OC1C<br>
On some larger pinout devices and MUX&#8217;d with OC0A pin</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN6</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 6 to the associated output pin OC2A<br>
OCR2A is used as a period register and thus not available</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN7</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 7 to the associated output pin OC2B</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN8</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 8 to the associated output pin OC3A</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN9</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 9 to the associated output pin OC3B</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN10</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 9 to the associated output pin OC3C</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN11</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 11 to the associated output pin OC4A</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN12</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 12 to the associated output pin OC4B</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN13</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 13 to the associated output pin OC4C</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN14</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 14 to the associated output pin OC5A</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN15</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 15 to the associated output pin OC5B</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p>AVRCHAN16</p></td><td align="left" valign="top"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 16 to the associated output pin OC5C</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">        'Using HPWM command to alternate ramping leds with the UNO board
    #chip mega328,16

    '************pwm************************
    'Must define AVRTCx, AVRCHANx, and set OCnX pin dir to out

    #define AVRTC0    'Timer0
    #define AVRCHAN2
    dir PortD.5 Out   'OC0B, UNO pin 5

    #define AVRTC1    'Timer1
    #define AVRCHAN3
    #define AVRCHAN4
    dir PortB.1 out   'OC1A, UNO pin 9
    dir PortB.2 Out   'OC1B, UNO pin 10

    #define AVRTC2    'Timer2
    #define AVRCHAN7
    dir PortD.3 Out   'OC2B, UNO pin 3

    do

    '63khz works good with 16MHz
    '32khz with 8MHz intosc
    '4KHz with 8MHz intosc and ckDiv8 fuse
    freq = 63
      For PWMled1 = 0 to 255
        HPWM 2,freq,PWMled1
        PWMled2 = NOT PWMled1
        HPWM 3,freq,PWMled2
        HPWM 4,freq,PWMled2
        HPWM 7,freq,PWMled1
        wait 5 ms
      Next

      For PWMled1 = 255 to 0
        HPWM 2,freq,PWMled1
        PWMled2 = NOT PWMled1
        HPWM 3,freq,PWMled2
        HPWM 4,freq,PWMled2
        HPWM 7,freq,PWMled1
        wait 5 ms
      Next

    loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hpwm_avr_ocrnx"></span>HPWM AVR OCRnx

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
     HPWM channel, frequency, duty cycle
```

<span class="strong">**Command Availability:**</span>

The HPWM command is available on Atmel AVR microcontrollers with an OCnx
pin, and is compatible with the PIC HPWM command method. Due to the the
unique way of AVR PWM implementation, and code efficiency, there are
some notable differences in the HPWM initialization and its use.

This command supports the Fast PWM Mode and period registers for their
respective devices. Typically Timer0 and Timer2 do not have a period
register and the "A" channel is sacrificed to provide that function.
Therefore, channel 1 and channel 6 will not be available, but are
documented for possible future use. Some device Timers do not have an
adjustable period register, so this command is not feasible (consult the
datasheet).

<span class="strong">**Explanation:**</span>

The HPWM command sets up the hardware PWM module of the Atmel AVR
microcontrollers to generate a PWM waveform of the given frequency and
duty cycle. Once this command is called, the PWM will be emitted until
the duty cycle parameter is written to zero.

If the need is just one particular frequency and duty cycle, one should
use PWMOn and the constants PWM\_Freq and PWM\_Duty instead. PWMOn for
the AVR is uniquely assigned to the OC0B pin, or channel 2. PWMOff will
only shutdown the AVR HPWM channel 2.

`channel` described as 1, 2, 3,…​16 correspond to the pins OCR0A,
OCR0B…​.OCR5C as detailed in the <span class="emphasis">*channel*</span>
constant table. Channel 1 and channel 6 are not available.

`frequency` sets the frequency of the PWM output measured in Khz. The
maximum value allowed is 255 KHz. In situations that do not require a
specific PWM frequency, the PWM frequency should equal approximately 4
times the clock speed (GCB chipMHz) of the microcontroller (ie 63 KHz on
a 16 MHz chip, 32 KHz on 8 MHz, 4 Khz on 1 MHz). This gives the best
duty cycle resolution possible. Alternate frequencies with good duty
cycle resolution are 1Khz, and 4Khz with chipMhz values of 16 and 8
respectively.

`duty cycle` specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 255 where 255 is 100% duty cycle. The AVR fast PWM mode
has a small spike at the extreme setting of 0x00, on most devices, with
each period register rollover. By using the HPWM command, and writing
0x00 to the duty cycle parameter, the PWM signal will shutdown
completely and avoid the spike. The PWM signal can then be restarted
again with a new HPWM command.

Note: Due to the AVR having a timer prescaler of just 1, 8, and 64; the
AVR frequency and duty cycle resolution will be different from the PIC
frequency and duty cycle resolution. The AVR HPWM parameters will likely
need adjusting ,when substituted into an existing PIC program, and where
accuracy is required.

<span class="strong">**HPWM Constants:**</span>

The AVR HPWM timer constants for channel number control are shown in the
table below. Each timer constant needs to be defined for any one of the
channels it controls.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Timer</strong></span><br />
<span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Options</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>AVRTC0</p></td>
<td style="text-align: left;"><p>Specifies AVR TC0 associated with <span class="emphasis"><em>channel</em></span> 1, and 2</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>AVRTC1</p></td>
<td style="text-align: left;"><p>Specifies AVR TC1 associated with <span class="emphasis"><em>channel</em></span> 3, 4 and 5<br />
Channel 5 present on larger pinout devices</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>AVRTC2</p></td>
<td style="text-align: left;"><p>Specifies AVR TC2 associated with <span class="emphasis"><em>channel</em></span> 6, and 7</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>AVRTC3</p></td>
<td style="text-align: left;"><p>Specifies AVR TC3 associated with <span class="emphasis"><em>channel</em></span> 8, 9, and 10</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>AVRTC4</p></td>
<td style="text-align: left;"><p>Specifies AVR TC4 associated with <span class="emphasis"><em>channel</em></span> 11,12, and 13</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>AVRTC5</p></td>
<td style="text-align: left;"><p>Specifies AVR TC5 associated with <span class="emphasis"><em>channel</em></span> 14, 15, and 16</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC HPWM channel constants for output pin control are shown in
the table below. Each HPWM channel used needs to be defined. The Port
pin associated with each OCnx must be set to output.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Channel</strong></span><br />
<span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Options</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>AVRCHAN1</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 1 to the associated output pin OC0A<br />
OCR0A is used as period register and thus not available</p></td>
<td style="text-align: left;"><p>N/A</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>AVRCHAN2</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 2 to the associated output pin OC0B</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>AVRCHAN3</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 3 to the associated output pin OC1A<br />
MUX’d with OC0A pin on some ATTiny’s</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>AVRCHAN4</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 4 to the associated output pin OC1B</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>AVRCHAN5</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 5 to the associated output pin OC1C<br />
On some larger pinout devices and MUX’d with OC0A pin</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>AVRCHAN6</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 6 to the associated output pin OC2A<br />
OCR2A is used as a period register and thus not available</p></td>
<td style="text-align: left;"><p>N/A</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>AVRCHAN7</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 7 to the associated output pin OC2B</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>AVRCHAN8</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 8 to the associated output pin OC3A</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>AVRCHAN9</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 9 to the associated output pin OC3B</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>AVRCHAN10</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 9 to the associated output pin OC3C</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>AVRCHAN11</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 11 to the associated output pin OC4A</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>AVRCHAN12</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 12 to the associated output pin OC4B</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>AVRCHAN13</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 13 to the associated output pin OC4C</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>AVRCHAN14</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 14 to the associated output pin OC5A</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>AVRCHAN15</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 15 to the associated output pin OC5B</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>AVRCHAN16</p></td>
<td style="text-align: left;"><p>Specifies AVR HPWM <span class="emphasis"><em>channel</em></span> 16 to the associated output pin OC5C</p></td>
<td style="text-align: left;"><p>Must be defined</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Example:**</span>

``` screen
        'Using HPWM command to alternate ramping leds with the UNO board
    #chip mega328,16

    '************pwm************************
    'Must define AVRTCx, AVRCHANx, and set OCnX pin dir to out

    #define AVRTC0    'Timer0
    #define AVRCHAN2
    dir PortD.5 Out   'OC0B, UNO pin 5

    #define AVRTC1    'Timer1
    #define AVRCHAN3
    #define AVRCHAN4
    dir PortB.1 out   'OC1A, UNO pin 9
    dir PortB.2 Out   'OC1B, UNO pin 10

    #define AVRTC2    'Timer2
    #define AVRCHAN7
    dir PortD.3 Out   'OC2B, UNO pin 3

    do

    '63khz works good with 16MHz
    '32khz with 8MHz intosc
    '4KHz with 8MHz intosc and ckDiv8 fuse
    freq = 63
      For PWMled1 = 0 to 255
        HPWM 2,freq,PWMled1
        PWMled2 = NOT PWMled1
        HPWM 3,freq,PWMled2
        HPWM 4,freq,PWMled2
        HPWM 7,freq,PWMled1
        wait 5 ms
      Next

      For PWMled1 = 255 to 0
        HPWM 2,freq,PWMled1
        PWMled2 = NOT PWMled1
        HPWM 3,freq,PWMled2
        HPWM 4,freq,PWMled2
        HPWM 7,freq,PWMled1
        wait 5 ms
      Next

    loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HPWM CCP</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microchip_pic_pwm_overview.html" title="Microchip PIC PWM Overview"><link rel="prev" href="_pwmout.html" title="PWMOut"><link rel="next" href="_hpwmupdate_for_ccp_pwm_modules_s.html" title="HPWMUpdate for CCP/PWM Modules(s)"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hpwm_ccp"></a>HPWM CCP</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HPWM <span class="emphasis"><em>channel, frequency, duty cycle</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available on Microchip PIC microcontrollers with Capture/Compare/PWM (CCP)
module.</p><p>This command supports the CCP 8 bit support with <span class="strong"><strong>Timer 2 only</strong></span>.<br></p><p>For CCP/PWM support for timers 2, 4 and 6, if the specific devices supports alternative CCP/PWM clock sources - see here <a class="link" href="_hpwm_ccptimern.html" title="HPWM_CCPTimerN">HPWM_CCPTimerN</a></p><p>For PWM 10 Bit support with other timers - see here <a class="link" href="_hpwm_10_bit.html" title="HPWM 10 Bit">HPWM 10 Bit</a></p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle.<br></p><p>If you only need one particular frequency and duty cycle, you should use PWMOn and
the constants PWM_Freq and PWM_Duty instead.</p><p><code class="literal"><span class="emphasis"><em>channel</em></span></code> is 1, 2, 3, 4 or 5, and corresponds to the pins CCP1, CCP2, CCP3, CCP4 and CCP5
respectively. On chips with only one CCP port, pin CCP or CCP1 is always
used, and <code class="literal"><span class="emphasis"><em>channel</em></span></code> is ignored. (It should be set to 1 anyway to allow
for future upgrades to more powerful microcontrollers.)</p><p><code class="literal"><span class="emphasis"><em>frequency</em></span></code> sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 255 KHz. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller (ie 40 Khz on
a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the best duty cycle
resolution possible.</p><p><code class="literal"><span class="emphasis"><em>duty cycle</em></span></code> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 255 where 255 is 100% duty cycle.</p><p>To stop the PWM signal use the <code class="literal">HPWMOff</code> method with the parameter of the channel.</p><pre class="screen">    'Stop the CCP/PWM signal
    HPWMOff ( 1 )</pre><p>The optional constant <code class="literal">HPWM_FAST</code> can be defined to enable the recalculation of the
timer prescaler when needed.  This will provide faster operation, but uses extra byte
of RAM and may cause problems if <code class="literal">HPWM</code> and <code class="literal">PWMOn</code> are used together in a program.
This will not cause any issue when using <code class="literal">HPWM</code> and <code class="literal">PWMOff</code> in the same program with <code class="literal">HPWM_FAST</code>.</p><p>The optional constant <code class="literal">DisableCCPFixedModePWM</code> can be defined to prevent Timer2 from being enabled.  This constant may be required when you need to use Timer2 for non-CCP/PWM support.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will alter the brightness of an LED using
    'CCP/PWM.

    'Select chip model and speed
    #chip 16F877A, 20

    'Set the CCP1 pin to output mode
    DIR PORTC.2 out

    'Main code
    do
        'Turn up brightness over the range
        For Bright = 1 to 255
            HPWM 1, 40, Bright
            wait 10 ms
        next
        'Turn down brightness over the range
        For Bright = 255 to 1 Step -1
            HPWM 1, 40, Bright
            wait 10 ms
        next
    loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hpwm_ccp"></span>HPWM CCP

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HPWM channel, frequency, duty cycle
```

<span class="strong">**Command Availability:**</span>

Only available on Microchip PIC microcontrollers with
Capture/Compare/PWM (CCP) module.

This command supports the CCP 8 bit support with <span
class="strong">**Timer 2 only**</span>.  

For CCP/PWM support for timers 2, 4 and 6, if the specific devices
supports alternative CCP/PWM clock sources - see here
<a href="hpwm_ccptimern" class="link" title="HPWM_CCPTimerN">HPWM_CCPTimerN</a>

For PWM 10 Bit support with other timers - see here
<a href="hpwm_10_bit" class="link" title="HPWM 10 Bit">HPWM 10 Bit</a>

<span class="strong">**Explanation:**</span>

This command sets up the hardware PWM module of the Microchip PIC
microcontroller to generate a PWM waveform of the given frequency and
duty cycle.  

If you only need one particular frequency and duty cycle, you should use
PWMOn and the constants PWM\_Freq and PWM\_Duty instead.

`channel` is 1, 2, 3, 4 or 5, and corresponds to the pins CCP1, CCP2,
CCP3, CCP4 and CCP5 respectively. On chips with only one CCP port, pin
CCP or CCP1 is always used, and `channel` is ignored. (It should be set
to 1 anyway to allow for future upgrades to more powerful
microcontrollers.)

`frequency` sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 255 KHz. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller
(ie 40 Khz on a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the
best duty cycle resolution possible.

`duty cycle` specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 255 where 255 is 100% duty cycle.

To stop the PWM signal use the `HPWMOff` method with the parameter of
the channel.

``` screen
    'Stop the CCP/PWM signal
    HPWMOff ( 1 )
```

The optional constant `HPWM_FAST` can be defined to enable the
recalculation of the timer prescaler when needed. This will provide
faster operation, but uses extra byte of RAM and may cause problems if
`HPWM` and `PWMOn` are used together in a program. This will not cause
any issue when using `HPWM` and `PWMOff` in the same program with
`HPWM_FAST`.

The optional constant `DisableCCPFixedModePWM` can be defined to prevent
Timer2 from being enabled. This constant may be required when you need
to use Timer2 for non-CCP/PWM support.

<span class="strong">**Example:**</span>

``` screen
    'This program will alter the brightness of an LED using
    'CCP/PWM.

    'Select chip model and speed
    #chip 16F877A, 20

    'Set the CCP1 pin to output mode
    DIR PORTC.2 out

    'Main code
    do
        'Turn up brightness over the range
        For Bright = 1 to 255
            HPWM 1, 40, Bright
            wait 10 ms
        next
        'Turn down brightness over the range
        For Bright = 255 to 1 Step -1
            HPWM 1, 40, Bright
            wait 10 ms
        next
    loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HPWM_CCPTimerN</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microchip_pic_pwm_overview.html" title="Microchip PIC PWM Overview"><link rel="prev" href="_hpwmoff.html" title="HPWMOff"><link rel="next" href="_hpwmoff_2.html" title="HPWMOff"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hpwm_ccptimern"></a>HPWM_CCPTimerN</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HPWM_CCPTimerN <span class="emphasis"><em>channel</em></span>, <span class="emphasis"><em>frequency</em></span>, <span class="emphasis"><em>duty cycle</em></span> [, <span class="emphasis"><em>timer</em></span> 2, 4 or 6 ]</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available on Microchip PIC microcontrollers with Capture/Compare/PWM (CCP)
module.</p><p>This command supports the CCP 8 bit support with selectable <span class="strong"><strong>Timer 2, 4 or 6 only</strong></span> for CCP/PWM only.<br></p><p>For CCP/PWM support for timers 2 only see <a class="link" href="_hpwm_ccp.html" title="HPWM CCP">HPWM CCPTimer</a></p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle.<br></p><p>If you only need one particular frequency and duty cycle, you should use PWMOn and
the constants PWM_Freq and PWM_Duty instead.</p><p><code class="literal"><span class="emphasis"><em>channel</em></span></code> is 1, 2, 3, 4 or 5, and corresponds to the pins CCP1, CCP2, CCP3, CCP4 and CCP5
respectively. On chips with only one CCP port, pin CCP or CCP1 is always
used, and <code class="literal"><span class="emphasis"><em>channel</em></span></code> is ignored. (It should be set to 1 anyway to allow
for future upgrades to more powerful microcontrollers.)</p><p><code class="literal"><span class="emphasis"><em>frequency</em></span></code> sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 255 KHz. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller (ie 40 Khz on
a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the best duty cycle
resolution possible.</p><p><code class="literal"><span class="emphasis"><em>duty cycle</em></span></code> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 255 where 255 is 100% duty cycle.</p><p><code class="literal">timer</code> specifies the timer source. Timers 2, 4 and 6 are supported.</p><p>To stop the PWM signal use the <code class="literal">HPWMOff</code> method with the parameter of the channel.</p><pre class="screen">    'Stop the CCP/PWM signal
    HPWMOff ( 1 )</pre><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #chip 16F1825, 4

    DIR portc Out
    DIR porta Out

    initialisation:

    'Command as follows:
    ' HPWM_CCPTimerN   CCP_Channel, Frequency, Duty, Timer Source.  Timer source defaults to timer 2, so, the timersource is optional.

    HPWM_CCPTimerN  3, 30, 77 , 4         'CCP/PWM module 3 using timer 4
    HPWM_CCPTimerN  4, 40, 102, 6         'CCP/PWM module 4 using timer 6
    HPWM  1, 10, 26                       'CCP/PWM module 1 with no parameter therefore timer 2

    do
    loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hpwm_ccptimern"></span>HPWM\_CCPTimerN

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HPWM_CCPTimerN channel, frequency, duty cycle [, timer 2, 4 or 6 ]
```

<span class="strong">**Command Availability:**</span>

Only available on Microchip PIC microcontrollers with
Capture/Compare/PWM (CCP) module.

This command supports the CCP 8 bit support with selectable <span
class="strong">**Timer 2, 4 or 6 only**</span> for CCP/PWM only.  

For CCP/PWM support for timers 2 only see
<a href="hpwm_ccp" class="link" title="HPWM CCP">HPWM CCPTimer</a>

<span class="strong">**Explanation:**</span>

This command sets up the hardware PWM module of the Microchip PIC
microcontroller to generate a PWM waveform of the given frequency and
duty cycle.  

If you only need one particular frequency and duty cycle, you should use
PWMOn and the constants PWM\_Freq and PWM\_Duty instead.

`channel` is 1, 2, 3, 4 or 5, and corresponds to the pins CCP1, CCP2,
CCP3, CCP4 and CCP5 respectively. On chips with only one CCP port, pin
CCP or CCP1 is always used, and `channel` is ignored. (It should be set
to 1 anyway to allow for future upgrades to more powerful
microcontrollers.)

`frequency` sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 255 KHz. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller
(ie 40 Khz on a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the
best duty cycle resolution possible.

`duty cycle` specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 255 where 255 is 100% duty cycle.

`timer` specifies the timer source. Timers 2, 4 and 6 are supported.

To stop the PWM signal use the `HPWMOff` method with the parameter of
the channel.

``` screen
    'Stop the CCP/PWM signal
    HPWMOff ( 1 )
```

<span class="strong">**Example:**</span>

``` screen
    #chip 16F1825, 4

    DIR portc Out
    DIR porta Out

    initialisation:

    'Command as follows:
    ' HPWM_CCPTimerN   CCP_Channel, Frequency, Duty, Timer Source.  Timer source defaults to timer 2, so, the timersource is optional.

    HPWM_CCPTimerN  3, 30, 77 , 4         'CCP/PWM module 3 using timer 4
    HPWM_CCPTimerN  4, 40, 102, 6         'CCP/PWM module 4 using timer 6
    HPWM  1, 10, 26                       'CCP/PWM module 1 with no parameter therefore timer 2

    do
    loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HPWM Fixed Mode</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microchip_pic_pwm_overview.html" title="Microchip PIC PWM Overview"><link rel="prev" href="_hpwm_16_bit.html" title="HPWM 16 Bit"><link rel="next" href="_pwmon.html" title="PWMOn"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hpwm_fixed_mode"></a>HPWM Fixed Mode</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PWMOn               'only applies to CCP/PWM channel 1
    'or
    PWMOff

    PWMOn( channel )            'where the parameter can be any valid CCP/PWM channel, 1, 2, 3, 4 or 5
    'or
    PWMOff( channel )

    PWMOn( module_number , <code class="literal">PWMModule</code>)            'where the parameter can be any valid PWM channel 1 .. 9
    'or
    PWMOff( module_number , <code class="literal">PWMModule</code>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p><span class="strong"><strong>Only</strong></span> available on Microchip PIC microcontrollers with a CCP/PWM or PWM module.</p><p>See here <a class="link" href="_hpwm_ccp.html" title="HPWM CCP">HPWM CCP</a> for the method to change PWM parameters dynamically or to use other CCP channels - this method support  CCP1/PWM, CCP2/PWM, CCP3/PWM, CCP4/PWM and CCP5/PWM.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle. &nbsp;&nbsp;Once this command
is called, the PWM will be emitted until PWMOff is called.</p><p>These constants are required to set the parameters for the PWM.  The frequency and the duty applies to all channels when using the method(s) or macro(s) shown above.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">PWM_Freq</code></p></td><td align="left" valign="top"><p>Specifies the output frequency of the PWM module in KHz.</p></td><td align="left" valign="top"><p>38</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PWM_Duty</code></p></td><td align="left" valign="top"><p>Sets the duty cycle of the PWM module output. Given as percentage.</p></td><td align="left" valign="top"><p>50</p></td></tr></tbody></table></div><p><br>
For CCP/PWM modules are also supported using a call to a method or a macro, as follows:
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Method/Macro</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>PWMOn</p></td><td align="left" valign="top"><p>No parameter enables CCP1/PWM only</p></td><td align="left" valign="top"><p>No parameter</p></td></tr><tr><td align="left" valign="top"><p>PWMOff</p></td><td align="left" valign="top"><p>Disables CCP1/PWM only</p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p>PWMOn( <code class="literal">channel</code> )</p></td><td align="left" valign="top"><p>Where the parameter is any valid CCP/PWM channel</p></td><td align="left" valign="top"><p><code class="literal">channel</code> can be 1, 2, 3, 4 or 5</p></td></tr><tr><td align="left" valign="top"><p>PWMOff( <code class="literal">channel</code> )</p></td><td align="left" valign="top"><p>Where the parameter is any valid CCP/PWM channel</p></td><td align="left" valign="top"><p><code class="literal">channel</code> can be 1, 2, 3, 4 or 5</p></td></tr><tr><td align="left" valign="top"><p>PWMOn( <code class="literal">module</code>, PWMMODULE )</p></td><td align="left" valign="top"><p>Where the parameter is any valid PWM module</p></td><td align="left" valign="top"><p><code class="literal">module</code> can be 1..9
<br>
 See the example below for the constants to control fixed mode PWM using PWM modules.</p></td></tr><tr><td align="left" valign="top"><p>PWMOff( <code class="literal">channel</code>, PWMMODULE )</p></td><td align="left" valign="top"><p>Where the parameter is any valid CCP/PWM module</p></td><td align="left" valign="top"><p><code class="literal">module</code> can be 1..9</p></td></tr></tbody></table></div><p><br>
<br>
<span class="strong"><strong>Fixed Mode PWM for PWM Modules.</strong></span></p><p>To set the Fixed Mode PWM for PWM Modules you need to set a timer frequency, a PWM module cycle and the PWM model source clock.</p><p>The options for source clock are shown below.    These are the PWM timers supported by the PWM modules, where <code class="literal">nn</code> is the frequency.</p><pre class="screen">    PWM_Timer2_Freq `nn` or
    PWM_Timer4_Freq `nn` or
    PWM_Timer6_Freq `nn`.</pre><p>The PWM module duty is set using PWM_`yy`_Duty <code class="literal">xx' where `yy</code> is between 1 and 9 and is a valid PWM module, and, <code class="literal">xx</code> is the Duty cycle for specific channels</p><pre class="screen">    #define PWM_yy_Duty xx</pre><p>The PMW module clock source us PWM_`zz`_Clock_Source <code class="literal">tt</code>.  Where <code class="literal">zz</code> is channel and <code class="literal">tt</code> is the PWM clock source.</p><pre class="screen">    #define PMW_zz_Clock_Source tt</pre><p>You do not need to define all the timers and or all the channels, just define the constants you need.</p><p>The minimum is
    A timer with a frequency
    A PWM channel with a duty
    A PWM channel clock source</p><p>Example: For PWM channel 6 with a frequency of 38Khz with a duty of 50% with a clock source of timer 2, use</p><pre class="screen">        #define PWM_Timer2_Freq 38
        #define PWM_7_Duty 50
        #define PMW_7_Clock_Source 6</pre><p>Details of the constants with  example parameters.</p><pre class="literallayout">#define PWM_Timer2_Freq 20        'Set frequency in KHz, just change the number
#define PWM_Timer4_Freq 40        'Set frequency in KHz, just change the number
#define PWM_Timer6_Freq 60        'Set frequency in KHz, just change the number</pre><p>Supported PWM modules, with example parameters.</p><pre class="literallayout">#define PWM_1_Duty 10            'Set duty cycle as percentage 0-100%, just change the number
#define PMW_1_Clock_Source 2</pre><pre class="literallayout">#define PWM_2_Duty 20
#define PMW_2_Clock_Source 4</pre><pre class="literallayout">#define PWM_3_Duty 30
#define PMW_3_Clock_Source 6</pre><pre class="literallayout">#define PWM_4_Duty 40
#define PMW_4_Clock_Source 2</pre><pre class="literallayout">#define PWM_5_Duty 50
#define PMW_5_Clock_Source 6</pre><pre class="literallayout">#define PWM_6_Duty 60
#define PMW_6_Clock_Source 6</pre><pre class="literallayout">#define PWM_7_Duty 70
#define PMW_7_Clock_Source 4</pre><pre class="literallayout">#define PWM_8_Duty 80
#define PMW_8_Clock_Source 4</pre><pre class="literallayout">#define PWM_9_Duty 90
#define PMW_9_Clock_Source 6</pre><p><br>
<br>
<span class="strong"><strong>Example #1:</strong></span></p><p>Enable CCP1/PWM channel only.  This is the legacy command.</p><pre class="screen">    #chip 16f877a,20

    'Set the PWM pin to output mode
    DIR PORTC.2 out

    'Main code

    #define PWM_Freq 38      'Frequency of PWM in KHz
    #define PWM_Duty 50      'Duty cycle of PWM (%)

    PWMOn    'Will enable CCP1/PWM Only

    wait 10 s                'Wait 10 s

    PWMOff   'Will disable CCP1/PWM Only

    do
    loop</pre><p><br>
<span class="strong"><strong>Example #2:</strong></span></p><p>Enable any CCP/PWM channel using a call to a method.</p><pre class="screen">    #chip 16f877a,20

    'Set the PWM pin to output mode
    DIR PORTC.2 out

    'Main code

    #define PWM_Freq 38      'Frequency of PWM in KHz
    #define PWM_Duty 50      'Duty cycle of PWM (%)

    PWMOn (2)    'Will enable any valid CCP/PWM channel

    wait 10 s                'Wait 10 s

    PWMOff (2)   'Will disable any valid CCP/PWM channel

    do
    loop</pre><p><br>
Example #3:*</p><p>Enable any PWM module using a PWM specific method.</p><pre class="screen">    'A real simple and easy PWM setup for 8 and 10 bit PWM channels
        #chip 18f25k42, 16

        #startup InitPPS, 85

        Sub InitPPS

                'Module: PWM5
                RA0PPS = 0x000D    'PWM5 &gt; RA0
                'Module: PWM6
                RA1PPS = 0x000E    'PWM6 &gt; RA1
                'Module: PWM7
                RA2PPS = 0x000F    'PWM7 &gt; RA2
                'Module: PWM8
                RA3PPS = 0x0010    'PWM8 &gt; RA3

        End Sub

        'Template comment at the end of the config file
        dir porta Out
        dir portb Out
        dir portc Out

    'This is the setup section for fixed mode PWM

        'The only options are PWM_Timer2_Freq nn|PWM_Timer4_Freq nn|PWM_Timer6_Freq nn. These are the PWM timers
        'The PWM_yy_Duty xx' where yy is between 1 and 9 and is a valid PWM module, and, xx is the Duty cycle for specific channels
        'The PMW_zz_Clock_Source tt.  Where zz is channel and tt is the PWM clock source.
        'You do not need to define all the timers and channels, just define the constants you need.
        'The minimum is
        '   A timer with a frequency
        '   A PWM channel with a duty
        '   A PWM channel clock source
        '   For PWM channel 2 with a frequency of 38Khz with a duty of 50% with a clock source of timer 2, use
        '     #define PWM_Timer2_Freq 38
        '     #define PWM_7_Duty 50
        '     #define PMW_7_Clock_Source 2

        #define PWM_Timer2_Freq 20        'Set frequency in KHz, just change the number
        #define PWM_Timer4_Freq 40        'Set frequency in KHz, just change the number
        #define PWM_Timer6_Freq 60        'Set frequency in KHz, just change the number


      '    Supported PWM module but not by this specific microcontroller
      '
      '    #define PWM_1_Duty 10            'Set duty cycle as percentage 0-100%, just change the number
      '    #define PMW_1_Clock_Source 2
      '
      '    #define PWM_2_Duty 20
      '    #define PMW_2_Clock_Source 4
      '
      '    #define PWM_3_Duty 30
      '    #define PMW_3_Clock_Source 6
      '
      '    #define PWM_4_Duty 40
      '    #define PMW_4_Clock_Source 2

        #define PWM_5_Duty 50
        #define PMW_5_Clock_Source 6

        #define PWM_6_Duty 60
        #define PMW_6_Clock_Source 6

        #define PWM_7_Duty 70
        #define PMW_7_Clock_Source 4

        #define PWM_8_Duty 80
        #define PMW_8_Clock_Source 4

        '    Supported PWM module but not by this specific microcontroller
        '
        '    #define PWM_9_Duty 90
        '    #define PMW_9_Clock_Source 6


        '   Enable module 7
        HPWMOn ( 7, PWMModule )
        wait 2 s
        '   Disable channel 7
        HPWMOff ( 7, PWMModule)
        '    wait 2 s

        '   Enable others module
        HPWMOn ( 5, PWMModule )
        HPWMOn ( 6, PWMModule )
        HPWMOn ( 7, PWMModule )
        HPWMOn ( 8, PWMModule )

        '  Enable CCP/PWM channel 1  - uses constants FREQ and DUTY
        PWMOn

        '  Enable CCP/PWM channel 2
        PWMOn ( 2 )
        do
        loop

    End</pre><p><br>
<br></p><p><br></p><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_pwmon.html" title="PWMOn">PWMOn</a> and <a class="link" href="_pwmoff.html" title="PWMOff">PWMOff</a> <span class="strong"><strong>or, for AVR see</strong></span> <a class="link" href="_hpwm_fixed_mode_for_avr.html" title="HPWM Fixed Mode for AVR">Fixed Mode PWM for AVR</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hpwm_fixed_mode"></span>HPWM Fixed Mode

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PWMOn               'only applies to CCP/PWM channel 1
    'or
    PWMOff

    PWMOn( channel )            'where the parameter can be any valid CCP/PWM channel, 1, 2, 3, 4 or 5
    'or
    PWMOff( channel )

    PWMOn( module_number , PWMModule)            'where the parameter can be any valid PWM channel 1 .. 9
    'or
    PWMOff( module_number , PWMModule)
```

<span class="strong">**Command Availability:**</span>

<span class="strong">**Only**</span> available on Microchip PIC
microcontrollers with a CCP/PWM or PWM module.

See here
<a href="hpwm_ccp" class="link" title="HPWM CCP">HPWM CCP</a> for
the method to change PWM parameters dynamically or to use other CCP
channels - this method support CCP1/PWM, CCP2/PWM, CCP3/PWM, CCP4/PWM
and CCP5/PWM.

<span class="strong">**Explanation:**</span>

This command sets up the hardware PWM module of the Microchip PIC
microcontroller to generate a PWM waveform of the given frequency and
duty cycle.   Once this command is called, the PWM will be emitted until
PWMOff is called.

These constants are required to set the parameters for the PWM. The
frequency and the duty applies to all channels when using the method(s)
or macro(s) shown above.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span>                           | <span class="strong">**Default Value**</span> |
|:----------------------------------------------|:-------------------------------------------------------------------|:----------------------------------------------|
| `PWM_Freq`                                    | Specifies the output frequency of the PWM module in KHz.           | 38                                            |
| `PWM_Duty`                                    | Sets the duty cycle of the PWM module output. Given as percentage. | 50                                            |

</div>

  
For CCP/PWM modules are also supported using a call to a method or a
macro, as follows:  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Method/Macro</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Default Value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>PWMOn</p></td>
<td style="text-align: left;"><p>No parameter enables CCP1/PWM only</p></td>
<td style="text-align: left;"><p>No parameter</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>PWMOff</p></td>
<td style="text-align: left;"><p>Disables CCP1/PWM only</p></td>
<td style="text-align: left;"> </td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>PWMOn( <code class="literal">channel</code> )</p></td>
<td style="text-align: left;"><p>Where the parameter is any valid CCP/PWM channel</p></td>
<td style="text-align: left;"><p><code class="literal">channel</code> can be 1, 2, 3, 4 or 5</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>PWMOff( <code class="literal">channel</code> )</p></td>
<td style="text-align: left;"><p>Where the parameter is any valid CCP/PWM channel</p></td>
<td style="text-align: left;"><p><code class="literal">channel</code> can be 1, 2, 3, 4 or 5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>PWMOn( <code class="literal">module</code>, PWMMODULE )</p></td>
<td style="text-align: left;"><p>Where the parameter is any valid PWM module</p></td>
<td style="text-align: left;"><p><code class="literal">module</code> can be 1..9<br />
See the example below for the constants to control fixed mode PWM using PWM modules.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>PWMOff( <code class="literal">channel</code>, PWMMODULE )</p></td>
<td style="text-align: left;"><p>Where the parameter is any valid CCP/PWM module</p></td>
<td style="text-align: left;"><p><code class="literal">module</code> can be 1..9</p></td>
</tr>
</tbody>
</table>

</div>

  
  
<span class="strong">**Fixed Mode PWM for PWM Modules.**</span>

To set the Fixed Mode PWM for PWM Modules you need to set a timer
frequency, a PWM module cycle and the PWM model source clock.

The options for source clock are shown below. These are the PWM timers
supported by the PWM modules, where `nn` is the frequency.

``` screen
    PWM_Timer2_Freq `nn` or
    PWM_Timer4_Freq `nn` or
    PWM_Timer6_Freq `nn`.
```

The PWM module duty is set using PWM\_\`yy\`\_Duty `` xx' where `yy ``
is between 1 and 9 and is a valid PWM module, and, `xx` is the Duty
cycle for specific channels

``` screen
    #define PWM_yy_Duty xx
```

The PMW module clock source us PWM\_\`zz\`\_Clock\_Source `tt`. Where
`zz` is channel and `tt` is the PWM clock source.

``` screen
    #define PMW_zz_Clock_Source tt
```

You do not need to define all the timers and or all the channels, just
define the constants you need.

The minimum is A timer with a frequency A PWM channel with a duty A PWM
channel clock source

Example: For PWM channel 6 with a frequency of 38Khz with a duty of 50%
with a clock source of timer 2, use

``` screen
        #define PWM_Timer2_Freq 38
        #define PWM_7_Duty 50
        #define PMW_7_Clock_Source 6
```

Details of the constants with example parameters.

``` literallayout
#define PWM_Timer2_Freq 20        'Set frequency in KHz, just change the number
#define PWM_Timer4_Freq 40        'Set frequency in KHz, just change the number
#define PWM_Timer6_Freq 60        'Set frequency in KHz, just change the number
```

Supported PWM modules, with example parameters.

``` literallayout
#define PWM_1_Duty 10            'Set duty cycle as percentage 0-100%, just change the number
#define PMW_1_Clock_Source 2
```

``` literallayout
#define PWM_2_Duty 20
#define PMW_2_Clock_Source 4
```

``` literallayout
#define PWM_3_Duty 30
#define PMW_3_Clock_Source 6
```

``` literallayout
#define PWM_4_Duty 40
#define PMW_4_Clock_Source 2
```

``` literallayout
#define PWM_5_Duty 50
#define PMW_5_Clock_Source 6
```

``` literallayout
#define PWM_6_Duty 60
#define PMW_6_Clock_Source 6
```

``` literallayout
#define PWM_7_Duty 70
#define PMW_7_Clock_Source 4
```

``` literallayout
#define PWM_8_Duty 80
#define PMW_8_Clock_Source 4
```

``` literallayout
#define PWM_9_Duty 90
#define PMW_9_Clock_Source 6
```

  
  
<span class="strong">**Example \#1:**</span>

Enable CCP1/PWM channel only. This is the legacy command.

``` screen
    #chip 16f877a,20

    'Set the PWM pin to output mode
    DIR PORTC.2 out

    'Main code

    #define PWM_Freq 38      'Frequency of PWM in KHz
    #define PWM_Duty 50      'Duty cycle of PWM (%)

    PWMOn    'Will enable CCP1/PWM Only

    wait 10 s                'Wait 10 s

    PWMOff   'Will disable CCP1/PWM Only

    do
    loop
```

  
<span class="strong">**Example \#2:**</span>

Enable any CCP/PWM channel using a call to a method.

``` screen
    #chip 16f877a,20

    'Set the PWM pin to output mode
    DIR PORTC.2 out

    'Main code

    #define PWM_Freq 38      'Frequency of PWM in KHz
    #define PWM_Duty 50      'Duty cycle of PWM (%)

    PWMOn (2)    'Will enable any valid CCP/PWM channel

    wait 10 s                'Wait 10 s

    PWMOff (2)   'Will disable any valid CCP/PWM channel

    do
    loop
```

  
Example \#3:\*

Enable any PWM module using a PWM specific method.

``` screen
    'A real simple and easy PWM setup for 8 and 10 bit PWM channels
        #chip 18f25k42, 16

        #startup InitPPS, 85

        Sub InitPPS

                'Module: PWM5
                RA0PPS = 0x000D    'PWM5 > RA0
                'Module: PWM6
                RA1PPS = 0x000E    'PWM6 > RA1
                'Module: PWM7
                RA2PPS = 0x000F    'PWM7 > RA2
                'Module: PWM8
                RA3PPS = 0x0010    'PWM8 > RA3

        End Sub

        'Template comment at the end of the config file
        dir porta Out
        dir portb Out
        dir portc Out

    'This is the setup section for fixed mode PWM

        'The only options are PWM_Timer2_Freq nn|PWM_Timer4_Freq nn|PWM_Timer6_Freq nn. These are the PWM timers
        'The PWM_yy_Duty xx' where yy is between 1 and 9 and is a valid PWM module, and, xx is the Duty cycle for specific channels
        'The PMW_zz_Clock_Source tt.  Where zz is channel and tt is the PWM clock source.
        'You do not need to define all the timers and channels, just define the constants you need.
        'The minimum is
        '   A timer with a frequency
        '   A PWM channel with a duty
        '   A PWM channel clock source
        '   For PWM channel 2 with a frequency of 38Khz with a duty of 50% with a clock source of timer 2, use
        '     #define PWM_Timer2_Freq 38
        '     #define PWM_7_Duty 50
        '     #define PMW_7_Clock_Source 2

        #define PWM_Timer2_Freq 20        'Set frequency in KHz, just change the number
        #define PWM_Timer4_Freq 40        'Set frequency in KHz, just change the number
        #define PWM_Timer6_Freq 60        'Set frequency in KHz, just change the number


      '    Supported PWM module but not by this specific microcontroller
      '
      '    #define PWM_1_Duty 10            'Set duty cycle as percentage 0-100%, just change the number
      '    #define PMW_1_Clock_Source 2
      '
      '    #define PWM_2_Duty 20
      '    #define PMW_2_Clock_Source 4
      '
      '    #define PWM_3_Duty 30
      '    #define PMW_3_Clock_Source 6
      '
      '    #define PWM_4_Duty 40
      '    #define PMW_4_Clock_Source 2

        #define PWM_5_Duty 50
        #define PMW_5_Clock_Source 6

        #define PWM_6_Duty 60
        #define PMW_6_Clock_Source 6

        #define PWM_7_Duty 70
        #define PMW_7_Clock_Source 4

        #define PWM_8_Duty 80
        #define PMW_8_Clock_Source 4

        '    Supported PWM module but not by this specific microcontroller
        '
        '    #define PWM_9_Duty 90
        '    #define PMW_9_Clock_Source 6


        '   Enable module 7
        HPWMOn ( 7, PWMModule )
        wait 2 s
        '   Disable channel 7
        HPWMOff ( 7, PWMModule)
        '    wait 2 s

        '   Enable others module
        HPWMOn ( 5, PWMModule )
        HPWMOn ( 6, PWMModule )
        HPWMOn ( 7, PWMModule )
        HPWMOn ( 8, PWMModule )

        '  Enable CCP/PWM channel 1  - uses constants FREQ and DUTY
        PWMOn

        '  Enable CCP/PWM channel 2
        PWMOn ( 2 )
        do
        loop

    End
```

  
  

  

<span class="strong">**For more help, see**</span>
<a href="pwmon" class="link" title="PWMOn">PWMOn</a> and
<a href="pwmoff" class="link" title="PWMOff">PWMOff</a> <span
class="strong">**or, for AVR see**</span>
<a href="hpwm_fixed_mode_for_avr" class="link" title="HPWM Fixed Mode for AVR">Fixed Mode PWM for AVR</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HPWM Fixed Mode for AVR</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_atmel_avr_pwm_overview.html" title="ATMEL AVR PWM Overview"><link rel="prev" href="_hpwm_avr_ocrnx.html" title="HPWM AVR OCRnx"><link rel="next" href="_pwmon_for_avr.html" title="PWMOn for AVR"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hpwm_fixed_mode_for_avr"></a>HPWM Fixed Mode for AVR</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PWMOn

    'or

    PWMOff</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>This command is only available on the Atmel AVR microcontrollers with a Timer/Counter0 OC0B register.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The PWMOn command will only enable the output of the OC0B/PWM module of the Atmel AVR microcontroller.</p><p>This command is not available for any other OCnx/PWM modules.</p><p>This command sets up the hardware PWM module of the Atmel AVR microcontroller to generate
a PWM waveform of the given frequency and duty cycle. &nbsp;&nbsp;Once PWMON method
is called, the PWM will be emitted until PWMOff is called.</p><p>These constants are required for PWMOn.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">PWM_Freq</code></p></td><td align="left" valign="top"><p>Specifies the output frequency of the PWM module in KHz.</p></td><td align="left" valign="top"><p>38</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PWM_Duty</code></p></td><td align="left" valign="top"><p>Sets the duty cycle of the PWM module output. Given as percentage.</p></td><td align="left" valign="top"><p>50</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program demonstrates the PWMOn and PWMOff commands
    'of the fixed mode HPWM on OC0B pin.

    #chip mega328p,16

    'activate appropriate PWM output pins
    dir PortD.5 Out     'OC0B

    'define PWM_Freq in kHz
    'define PWM_Duty in %

    #define PWM_Freq 40
    #define PWM_Duty 50

    do

      'turn on/off single channel 40 KHz PWM on OC0B pin
      PWMON
      wait 5 s
      PWMOFF
      wait 5 s

    loop</pre><p><br>
<br>
<span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_pwmon_for_avr.html" title="PWMOn for AVR">PWMOn</a> and <a class="link" href="_pwmoff_for_avr.html" title="PWMOff for AVR">PWMOff</a> <span class="strong"><strong>or, for Microchip microcontrollers see</strong></span> <a class="link" href="_hpwm_fixed_mode.html" title="HPWM Fixed Mode">Fixed Mode PWM for Microchip</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hpwm_fixed_mode_for_avr"></span>HPWM Fixed Mode for AVR

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PWMOn

    'or

    PWMOff
```

<span class="strong">**Command Availability:**</span>

This command is only available on the Atmel AVR microcontrollers with a
Timer/Counter0 OC0B register.

<span class="strong">**Explanation:**</span>

The PWMOn command will only enable the output of the OC0B/PWM module of
the Atmel AVR microcontroller.

This command is not available for any other OCnx/PWM modules.

This command sets up the hardware PWM module of the Atmel AVR
microcontroller to generate a PWM waveform of the given frequency and
duty cycle.   Once PWMON method is called, the PWM will be emitted until
PWMOff is called.

These constants are required for PWMOn.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span>                           | <span class="strong">**Default Value**</span> |
|:----------------------------------------------|:-------------------------------------------------------------------|:----------------------------------------------|
| `PWM_Freq`                                    | Specifies the output frequency of the PWM module in KHz.           | 38                                            |
| `PWM_Duty`                                    | Sets the duty cycle of the PWM module output. Given as percentage. | 50                                            |

</div>

<span class="strong">**Example:**</span>

``` screen
    'This program demonstrates the PWMOn and PWMOff commands
    'of the fixed mode HPWM on OC0B pin.

    #chip mega328p,16

    'activate appropriate PWM output pins
    dir PortD.5 Out     'OC0B

    'define PWM_Freq in kHz
    'define PWM_Duty in %

    #define PWM_Freq 40
    #define PWM_Duty 50

    do

      'turn on/off single channel 40 KHz PWM on OC0B pin
      PWMON
      wait 5 s
      PWMOFF
      wait 5 s

    loop
```

  
  
<span class="strong">**For more help, see**</span>
<a href="pwmon_for_avr" class="link" title="PWMOn for AVR">PWMOn</a>
and
<a href="pwmoff_for_avr" class="link" title="PWMOff for AVR">PWMOff</a>
<span class="strong">**or, for Microchip microcontrollers see**</span>
<a href="hpwm_fixed_mode" class="link" title="HPWM Fixed Mode">Fixed Mode PWM for Microchip</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HSerGetNum</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_hardware.html" title="RS232 (hardware)"><link rel="prev" href="_rs232_hardware_overview.html" title="RS232 Hardware Overview"><link rel="next" href="_hsergetstring.html" title="HSerGetString"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hsergetnum"></a>HSerGetNum</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  <code class="literal">HSerGetNum</code> <span class="emphasis"><em>myNum</em></span>    &#8216;Gets a multi digit number  from USART 1
  <code class="literal">HSerGetNum</code> <span class="emphasis"><em>myNum</em></span>,1  &#8216;Get a multi digit number from USART 1
  <code class="literal">HSerGetNum</code> <span class="emphasis"><em>myNum</em></span>,2  &#8216;Get a multi digit number from USART 2</pre><pre class="literallayout">When the variable type is a word the number range is 0 to 65535
When the variable type is a long the number range is 0 to 99999</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a USART or UART module.<br></p><p>Microchip PIC supports USART1 and 2.<br>
Atmel AVR supports USART 1,2,3 and 4.</p><p><span class="strong"><strong>Enabling Constants:</strong></span></p><p>To enable the use of the USART these are the enabling constants. &nbsp;&nbsp;These constants are required.&nbsp;&nbsp;You can change the <code class="literal">USART_BAUD_RATE</code> and to meet your needs.&nbsp;&nbsp;For addition USART ports use <code class="literal">#define USART<span class="strong"><strong>n</strong></span>_BAUD_RATE 9600</code> where <code class="literal"><span class="strong"><strong>n</strong></span>`</code> is the required port number.</p><pre class="screen">    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will read a multi digit number received as ascii chars followed by a CR from an external serial source using a  hardware serial module.  The command checks that only numbers are input disregarding other characters while waiting for the ending &lt;CR&gt;.  It can be used only as a subroutine.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  'This program receives a number and CR from a PC terminal and sends it back on both usarts
  #chip 18f26k22, 16

  'Set the pin directions
  #define USART_BAUD_RATE 9600
  #define USART_BLOCKING
  #define USART2_BAUD_RATE 9600
  #define USART2_BLOCKING

  'Init pins
  #define SerInPort PORTc.7    'usart1 in
  #define SerOutPort PORTc.6    'usart2 out
    'Set pin directions
    Dir SerOutPort Out
    Dir SerInPort In
    Dir PORTB.6 Out            'USART2 out
    Dir PORTB.7 In            'USArt2 in
    Dir PORTB.0 Out            'leds for testing
    Dir PORTB.1 Out            'leds for testing
    Wait 100 Ms

  'Variables
  Dim myNum as Word
  'Main body of program commences here.
  'Message after reset
  HSerPrint "18F26k22"
  HSerPrintCRLF

  'Main routine
  Do forever
    'wait for char from UART
    'HSerReceive InChar
    HSerGetNum myNum,2    'from usart 2
    HSerPrint myNum,1            ' send out usart 1
    HSerPrint myNum,2        'send out usart 2
    HSerPrintCRLF 1,2        'send one CRLF out usart 2
    HserPrintCRLF 1,1        &#8216;send one CRLF out usart 1
  loop</pre><p><span class="strong"><strong>Example:</strong></span>
This program receives number on serial port 1 and displays.  This example shows using a Long as the input variable.</p><p>Therefore, the result is in the range of 0-99999.  The example also shows how to detect a buffer overrun by testing the HSerInByte variable.</p><pre class="screen">    #chip mega328p, 16

    #define USART_BAUD_RATE 9600
    #define USART_BLOCKING

    Dim myNum as Long  ' range 0 to 99999
    HSerPrint "Restarted"
    HSerPrintCRLF

    Do
      HSerGetNum myNum
      HSerPrint myNum

      if HSerInByte &lt;&gt; 13 then
          HSerSend 9
          HSerPrint "Error buffer overrun"  'You should handle error appropiately
      End if
      HSerPrintCRLF
    loop
    End</pre><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_hserreceive.html" title="HSerReceive">HSerReceive</a> and <a class="link" href="_hsergetstring.html" title="HSerGetString">HSerGetString</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hsergetnum"></span>HSerGetNum

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  HSerGetNum myNum    ‘Gets a multi digit number  from USART 1
  HSerGetNum myNum,1  ‘Get a multi digit number from USART 1
  HSerGetNum myNum,2  ‘Get a multi digit number from USART 2
```

``` literallayout
When the variable type is a word the number range is 0 to 65535
When the variable type is a long the number range is 0 to 99999
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a USART or UART module.  

Microchip PIC supports USART1 and 2.  
Atmel AVR supports USART 1,2,3 and 4.

<span class="strong">**Enabling Constants:**</span>

To enable the use of the USART these are the enabling constants.   These
constants are required.  You can change the `USART_BAUD_RATE` and to
meet your needs.  For addition USART ports use
`#define USARTn_BAUD_RATE 9600` where `` n` `` is the required port
number.

``` screen
    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF
```

<span class="strong">**Explanation:**</span>

This command will read a multi digit number received as ascii chars
followed by a CR from an external serial source using a hardware serial
module. The command checks that only numbers are input disregarding
other characters while waiting for the ending &lt;CR&gt;. It can be used
only as a subroutine.

<span class="strong">**Example:**</span>

``` screen
  'This program receives a number and CR from a PC terminal and sends it back on both usarts
  #chip 18f26k22, 16

  'Set the pin directions
  #define USART_BAUD_RATE 9600
  #define USART_BLOCKING
  #define USART2_BAUD_RATE 9600
  #define USART2_BLOCKING

  'Init pins
  #define SerInPort PORTc.7    'usart1 in
  #define SerOutPort PORTc.6    'usart2 out
    'Set pin directions
    Dir SerOutPort Out
    Dir SerInPort In
    Dir PORTB.6 Out            'USART2 out
    Dir PORTB.7 In            'USArt2 in
    Dir PORTB.0 Out            'leds for testing
    Dir PORTB.1 Out            'leds for testing
    Wait 100 Ms

  'Variables
  Dim myNum as Word
  'Main body of program commences here.
  'Message after reset
  HSerPrint "18F26k22"
  HSerPrintCRLF

  'Main routine
  Do forever
    'wait for char from UART
    'HSerReceive InChar
    HSerGetNum myNum,2    'from usart 2
    HSerPrint myNum,1            ' send out usart 1
    HSerPrint myNum,2        'send out usart 2
    HSerPrintCRLF 1,2        'send one CRLF out usart 2
    HserPrintCRLF 1,1        ‘send one CRLF out usart 1
  loop
```

<span class="strong">**Example:**</span> This program receives number on
serial port 1 and displays. This example shows using a Long as the input
variable.

Therefore, the result is in the range of 0-99999. The example also shows
how to detect a buffer overrun by testing the HSerInByte variable.

``` screen
    #chip mega328p, 16

    #define USART_BAUD_RATE 9600
    #define USART_BLOCKING

    Dim myNum as Long  ' range 0 to 99999
    HSerPrint "Restarted"
    HSerPrintCRLF

    Do
      HSerGetNum myNum
      HSerPrint myNum

      if HSerInByte <> 13 then
          HSerSend 9
          HSerPrint "Error buffer overrun"  'You should handle error appropiately
      End if
      HSerPrintCRLF
    loop
    End
```

<span class="strong">**See also**</span>
<a href="hserreceive" class="link" title="HSerReceive">HSerReceive</a>
and
<a href="hsergetstring" class="link" title="HSerGetString">HSerGetString</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HSerGetString</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_hardware.html" title="RS232 (hardware)"><link rel="prev" href="_hsergetnum.html" title="HSerGetNum"><link rel="next" href="_hserprint.html" title="HSerPrint"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hsergetstring"></a>HSerGetString</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HSerGetString <span class="emphasis"><em>myString</em></span>      &#8216;Get a multi char string  from USART 1
    HSerGetString <span class="emphasis"><em>myString</em></span>,1    &#8216;Get a multi char string  from USART 1
    HSerGetString <span class="emphasis"><em>myString</em></span>,2    &#8216;Get a multi char string  from USART 2</pre><pre class="literallayout">Variable type is string and the  routine checks for numbers,letters, and puctuation.</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a USART or UART module.<br></p><p>Microchip PIC supports USART1 and 2.<br>
Atmel AVR supports USART 1,2,3 and 4.</p><p><span class="strong"><strong>Enabling Constants:</strong></span></p><p>To enable the use of the USART these are the enabling constants. &nbsp;&nbsp;These constants are required.&nbsp;&nbsp;You can change the <code class="literal">USART_BAUD_RATE</code> and to meet your needs.&nbsp;&nbsp;For addition USART ports use <code class="literal">#define USART<span class="strong"><strong>n</strong></span>_BAUD_RATE 9600</code> where <code class="literal"><span class="strong"><strong>n</strong></span>`</code> is the required port number.</p><pre class="screen">    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will read a multi character string received as ascii input to the hardware serial module followed by a CR from an external serial source. It can be used only as a subroutine. Variable type is string and the  routine checks for numbers,letters, and puctuation.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  'This program receives char string and CR from a PC terminal, sends back the string on the serial port, and turns Led&#8217;s on off by command

  #chip 18f26k22, 16

  'Set the pin directions
  #define USART_BAUD_RATE 9600
  #define USART_BLOCKING
  #define USART2_BAUD_RATE 9600
  #define USART2_BLOCKING

  'InitUSART
  #define SerInPort PORTc.7    'USART 1 Rx Pin
  #define SerOutPort PORTc.6    'USART 1 Tx Pin


  'Set pin directions
  Dir SerOutPort Out
  Dir SerInPort In

  Dir PORTB.6 Out        'second USART Tx Pin
  Dir PORTB.7 In        'second USART Rx Pin

  Dir PORTB.0 Out        ' LED hooked up for testing
  Dir PORTB.1 Out        ' LED hooked up for testing

  Wait 100 Ms

  ; ----- Variables
  ' All byte variables are defined upon use.
  Dim myNum as Word
  Dim MyString as String

  ; ----- Main body of program commences here.
  'Message after reset
  HSerPrint "18F26k22"
  HSerPrintCRLF

  'Main routine

  Do Forever

    HSerGetString MyString
    HSerPrint MyString
    HSerSend(13)
     If MyString = "LED1 ON" Then
       Set PORTB.0 Off
     End If
     If MyString = "LED1 OFF" Then
       Set PORTB.0 On
     End If
     If MyString = "LED2 ON" Then
       Set PORTB.1 Off
     End If
     If MyString = "LED2 OFF" Then
       Set PORTB.1 On
     End If

  Loop</pre><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_hserreceive.html" title="HSerReceive">HSerReceive</a> and <a class="link" href="_hsergetnum.html" title="HSerGetNum">HSerGetNum</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hsergetstring"></span>HSerGetString

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HSerGetString myString      ‘Get a multi char string  from USART 1
    HSerGetString myString,1    ‘Get a multi char string  from USART 1
    HSerGetString myString,2    ‘Get a multi char string  from USART 2
```

``` literallayout
Variable type is string and the  routine checks for numbers,letters, and puctuation.
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a USART or UART module.  

Microchip PIC supports USART1 and 2.  
Atmel AVR supports USART 1,2,3 and 4.

<span class="strong">**Enabling Constants:**</span>

To enable the use of the USART these are the enabling constants.   These
constants are required.  You can change the `USART_BAUD_RATE` and to
meet your needs.  For addition USART ports use
`#define USARTn_BAUD_RATE 9600` where `` n` `` is the required port
number.

``` screen
    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF
```

<span class="strong">**Explanation:**</span>

This command will read a multi character string received as ascii input
to the hardware serial module followed by a CR from an external serial
source. It can be used only as a subroutine. Variable type is string and
the routine checks for numbers,letters, and puctuation.

<span class="strong">**Example:**</span>

``` screen
  'This program receives char string and CR from a PC terminal, sends back the string on the serial port, and turns Led’s on off by command

  #chip 18f26k22, 16

  'Set the pin directions
  #define USART_BAUD_RATE 9600
  #define USART_BLOCKING
  #define USART2_BAUD_RATE 9600
  #define USART2_BLOCKING

  'InitUSART
  #define SerInPort PORTc.7    'USART 1 Rx Pin
  #define SerOutPort PORTc.6    'USART 1 Tx Pin


  'Set pin directions
  Dir SerOutPort Out
  Dir SerInPort In

  Dir PORTB.6 Out        'second USART Tx Pin
  Dir PORTB.7 In        'second USART Rx Pin

  Dir PORTB.0 Out        ' LED hooked up for testing
  Dir PORTB.1 Out        ' LED hooked up for testing

  Wait 100 Ms

  ; ----- Variables
  ' All byte variables are defined upon use.
  Dim myNum as Word
  Dim MyString as String

  ; ----- Main body of program commences here.
  'Message after reset
  HSerPrint "18F26k22"
  HSerPrintCRLF

  'Main routine

  Do Forever

    HSerGetString MyString
    HSerPrint MyString
    HSerSend(13)
     If MyString = "LED1 ON" Then
       Set PORTB.0 Off
     End If
     If MyString = "LED1 OFF" Then
       Set PORTB.0 On
     End If
     If MyString = "LED2 ON" Then
       Set PORTB.1 Off
     End If
     If MyString = "LED2 OFF" Then
       Set PORTB.1 On
     End If

  Loop
```

<span class="strong">**See also**</span>
<a href="hserreceive" class="link" title="HSerReceive">HSerReceive</a>
and
<a href="hsergetnum" class="link" title="HSerGetNum">HSerGetNum</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HSerPrint</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_hardware.html" title="RS232 (hardware)"><link rel="prev" href="_hsergetstring.html" title="HSerGetString"><link rel="next" href="_hserprintstringcrlf.html" title="HSerPrintStringCRLF"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hserprint"></a>HSerPrint</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HSerPrint <span class="emphasis"><em>user_value</em></span> [,1|2|3|4]  'Choose comport with optional parameter
                                       'Default comport is 1

    'Send a series of ASCII characters using the buffer called SerialPacket
    Dim SerialPacket as Alloc
    SerialPacket = 66, 105, 108, 108, 38, 69, 118, 97, 110, 13, 10
    HserPrint ( SerialPacket, 1 )  &#8217;explicit to comport 1
    SerialPacket = 66,44,73,44,82,13,10
    HserPrint ( SerialPacket )  &#8217;defaults to comport 1</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a USART or UART module.<br></p><p>Microchip PIC supports USART1 and 2.<br>
Atmel AVR supports USART 1,2,3 and 4.</p><p><span class="strong"><strong>Enabling Constants:</strong></span></p><p>To enable the use of the USART these are the enabling constants. &nbsp;&nbsp;These constants are required.&nbsp;&nbsp;You can change the <code class="literal">USART_BAUD_RATE</code> and to meet your needs.&nbsp;&nbsp;For addition USART ports use <code class="literal">#define USART<span class="strong"><strong>n</strong></span>_BAUD_RATE 9600</code> where <code class="literal"><span class="strong"><strong>n</strong></span>`</code> is the required port number.</p><pre class="screen">    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">HSerPrint</code> is used to send a value over the serial connection. <code class="literal"><span class="emphasis"><em>user_value</em></span></code>
can be a string, integer, long, word or byte. <code class="literal">HSerPrint</code> is very similar
to <code class="literal">Print</code>. The data will be sent out the hardware serial module.</p><p><code class="literal">HSerPrint</code> will not send any new line characters. If the chip is sending
to a terminal, these commands should follow every <code class="literal">HSerPrint</code> :</p><pre class="screen">  HSerPrint 13
  HSerPrint 10</pre><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  'This program will display any values received over the serial
  'connection. If "pot" is received, the value of the analog sensor
  'will be sent.
  'Note: This has been adapted from the SerPrint example.

  'Chip settings
  #chip 18F2525, 8

  'LCD settings
  #define LCD_IO 4
  #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
  #define LCD_RS PORTC.7
  #define LCD_RW PORTC.6
  #define LCD_Enable PORTC.5
  #define LCD_DB4 PORTC.4
  #define LCD_DB5 PORTC.3
  #define LCD_DB6 PORTC.2
  #define LCD_DB7 PORTC.1

  'USART settings
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING
  #define USART_DELAY OFF

  'Potentiometer
  #define POT_PORT PORTA.0
  #define POT_AN AN0

  'Set pin directions
  Dir POT_PORT In

  'Create buffer variables to store received messages
  Dim Buffer As String
  Dim OldBuffer As String
  BufferSize = 0

  'Show test messages
  Print "Serial Tester"
  Wait 1 s
  HSerPrint "GCBASIC RS232 Test"
  HSerSend 13
  HSerSend 10
  Wait 1 s

  'Main loop
  Do
    'Get a byte from the terminal
    HSerReceive Temp

    'If Enter key was pressed, deal with buffer contents
    If Temp = 13 Then
      Buffer(0) = BufferSize

      'Try to execute commands in buffer
      If Not ExecCommand (Buffer) Then
        'Show message on bottom line, last message on top.
        CLS
        Print OldBuffer
        Locate 1, 0
        Print Buffer
        'Store the message for next time
        OldBuffer = Buffer
      End If

      BufferSize = 0
    End If
    'Backspace code, delete last character in buffer
    If Temp = 8 Then
      If BufferSize &gt; 0 Then BufferSize -= 1
    End If
    'Received ASCII code between 32 and 127, add to buffer
    If Temp &gt;= 32 And Temp &lt;= 127 Then
      BufferSize += 1
      Buffer(BufferSize) = Temp
    End If
  Loop

  'Takes a sensor reading and sends it to terminal
  Sub SendSensorReading
    HSerPrint "Sensor Reading: "
    HSerPrint ReadAD10(POT_AN)
    HSerSend 13
    HSerSend 10
  End Sub

  'Will check the buffer for a command
  'If command found, run it and return true
  'If not, return false
  Function ExecCommand (CmdIn As String)
    ExecCommand = False
    'If received command is "pot", show potentiometer value
    If CmdIn = "pot" Then
      SendSensorReading
      ExecCommand = True
    End If
  End Function</pre><p><span class="strong"><strong>For more help, see also</strong></span>
<a class="link" href="_hserprintbytecrlf.html" title="HserPrintByteCRLF">HserPrintByteCRLF</a>, <a class="link" href="_hserprintstringcrlf.html" title="HSerPrintStringCRLF">HserPrintStringCRLF</a>
<span class="strong"><strong>and</strong></span> <a class="link" href="_hserprintcrlf.html" title="HserPrintCRLF">HserPrintCRLF</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hserprint"></span>HSerPrint

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HSerPrint user_value [,1|2|3|4]  'Choose comport with optional parameter
                                       'Default comport is 1

    'Send a series of ASCII characters using the buffer called SerialPacket
    Dim SerialPacket as Alloc
    SerialPacket = 66, 105, 108, 108, 38, 69, 118, 97, 110, 13, 10
    HserPrint ( SerialPacket, 1 )  ’explicit to comport 1
    SerialPacket = 66,44,73,44,82,13,10
    HserPrint ( SerialPacket )  ’defaults to comport 1
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a USART or UART module.  

Microchip PIC supports USART1 and 2.  
Atmel AVR supports USART 1,2,3 and 4.

<span class="strong">**Enabling Constants:**</span>

To enable the use of the USART these are the enabling constants.   These
constants are required.  You can change the `USART_BAUD_RATE` and to
meet your needs.  For addition USART ports use
`#define USARTn_BAUD_RATE 9600` where `` n` `` is the required port
number.

``` screen
    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF
```

<span class="strong">**Explanation:**</span>

`HSerPrint` is used to send a value over the serial connection.
`user_value` can be a string, integer, long, word or byte. `HSerPrint`
is very similar to `Print`. The data will be sent out the hardware
serial module.

`HSerPrint` will not send any new line characters. If the chip is
sending to a terminal, these commands should follow every `HSerPrint` :

``` screen
  HSerPrint 13
  HSerPrint 10
```

<span class="strong">**Example:**</span>

``` screen
  'This program will display any values received over the serial
  'connection. If "pot" is received, the value of the analog sensor
  'will be sent.
  'Note: This has been adapted from the SerPrint example.

  'Chip settings
  #chip 18F2525, 8

  'LCD settings
  #define LCD_IO 4
  #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
  #define LCD_RS PORTC.7
  #define LCD_RW PORTC.6
  #define LCD_Enable PORTC.5
  #define LCD_DB4 PORTC.4
  #define LCD_DB5 PORTC.3
  #define LCD_DB6 PORTC.2
  #define LCD_DB7 PORTC.1

  'USART settings
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING
  #define USART_DELAY OFF

  'Potentiometer
  #define POT_PORT PORTA.0
  #define POT_AN AN0

  'Set pin directions
  Dir POT_PORT In

  'Create buffer variables to store received messages
  Dim Buffer As String
  Dim OldBuffer As String
  BufferSize = 0

  'Show test messages
  Print "Serial Tester"
  Wait 1 s
  HSerPrint "GCBASIC RS232 Test"
  HSerSend 13
  HSerSend 10
  Wait 1 s

  'Main loop
  Do
    'Get a byte from the terminal
    HSerReceive Temp

    'If Enter key was pressed, deal with buffer contents
    If Temp = 13 Then
      Buffer(0) = BufferSize

      'Try to execute commands in buffer
      If Not ExecCommand (Buffer) Then
        'Show message on bottom line, last message on top.
        CLS
        Print OldBuffer
        Locate 1, 0
        Print Buffer
        'Store the message for next time
        OldBuffer = Buffer
      End If

      BufferSize = 0
    End If
    'Backspace code, delete last character in buffer
    If Temp = 8 Then
      If BufferSize > 0 Then BufferSize -= 1
    End If
    'Received ASCII code between 32 and 127, add to buffer
    If Temp >= 32 And Temp <= 127 Then
      BufferSize += 1
      Buffer(BufferSize) = Temp
    End If
  Loop

  'Takes a sensor reading and sends it to terminal
  Sub SendSensorReading
    HSerPrint "Sensor Reading: "
    HSerPrint ReadAD10(POT_AN)
    HSerSend 13
    HSerSend 10
  End Sub

  'Will check the buffer for a command
  'If command found, run it and return true
  'If not, return false
  Function ExecCommand (CmdIn As String)
    ExecCommand = False
    'If received command is "pot", show potentiometer value
    If CmdIn = "pot" Then
      SendSensorReading
      ExecCommand = True
    End If
  End Function
```

<span class="strong">**For more help, see also**</span>
<a href="hserprintbytecrlf" class="link" title="HserPrintByteCRLF">HserPrintByteCRLF</a>,
<a href="hserprintstringcrlf" class="link" title="HSerPrintStringCRLF">HserPrintStringCRLF</a>
<span class="strong">**and**</span>
<a href="hserprintcrlf" class="link" title="HserPrintCRLF">HserPrintCRLF</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HserPrintByteCRLF</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_hardware.html" title="RS232 (hardware)"><link rel="prev" href="_hsersend.html" title="HSerSend"><link rel="next" href="_hserprintcrlf.html" title="HserPrintCRLF"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hserprintbytecrlf"></a>HserPrintByteCRLF</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  <code class="literal">HserPrintByteCRLF</code>  <span class="emphasis"><em>user_data</em></span> [, 1 | 2  | 3 | 4 ]</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a USART or UART module.</p><p>Microchip PIC supports USART1 and 2.<br>
Atmel AVR supports USART 1,2,3 and 4.</p><p><span class="strong"><strong>Enabling Constants:</strong></span></p><p>To enable the use of the USART these are the enabling constants. &nbsp;&nbsp;These constants are required.&nbsp;&nbsp;You can change the <code class="literal">USART_BAUD_RATE</code> and to meet your needs.&nbsp;&nbsp;For addition USART ports use <code class="literal">#define USART<span class="strong"><strong>n</strong></span>_BAUD_RATE 9600</code> where <code class="literal"><span class="strong"><strong>n</strong></span>`</code> is the required port number.</p><pre class="screen">    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will send a byte given by <span class="emphasis"><em>user_data</em></span> using the hardware USART
module and then send the ASCII codes 13 and 10. ASCII codes 13 and 10
equate to a carriage return and line feed.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  'This program will send the status of PORTB through the hardware serial module.

  HserPrintByteCRLF 65    ' Will print a single A on the terminal
  HserPrintByteCRLF "A"   ' Will print a single A on the terminal</pre><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_hserprintcrlf.html" title="HserPrintCRLF">HserPrintCRLF</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hserprintbytecrlf"></span>HserPrintByteCRLF

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  HserPrintByteCRLF  user_data [, 1 | 2  | 3 | 4 ]
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a USART or UART module.

Microchip PIC supports USART1 and 2.  
Atmel AVR supports USART 1,2,3 and 4.

<span class="strong">**Enabling Constants:**</span>

To enable the use of the USART these are the enabling constants.   These
constants are required.  You can change the `USART_BAUD_RATE` and to
meet your needs.  For addition USART ports use
`#define USARTn_BAUD_RATE 9600` where `` n` `` is the required port
number.

``` screen
    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF
```

<span class="strong">**Explanation:**</span>

This command will send a byte given by <span
class="emphasis">*user\_data*</span> using the hardware USART module and
then send the ASCII codes 13 and 10. ASCII codes 13 and 10 equate to a
carriage return and line feed.

<span class="strong">**Example:**</span>

``` screen
  'This program will send the status of PORTB through the hardware serial module.

  HserPrintByteCRLF 65    ' Will print a single A on the terminal
  HserPrintByteCRLF "A"   ' Will print a single A on the terminal
```

<span class="strong">**See also**</span>
<a href="hserprintcrlf" class="link" title="HserPrintCRLF">HserPrintCRLF</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HserPrintCRLF</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_hardware.html" title="RS232 (hardware)"><link rel="prev" href="_hserprintbytecrlf.html" title="HserPrintByteCRLF"><link rel="next" href="_ps_2.html" title="PS/2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hserprintcrlf"></a>HserPrintCRLF</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HserPrintCRLF [optional BYTE] [, 1 | 2  | 3 | 4 ]</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a USART or UART module.<br></p><p>Microchip PIC supports USART1 and 2.+
Atmel AVR supports USART 1,2,3 and 4.</p><p><span class="strong"><strong>Enabling Constants:</strong></span></p><p>To enable the use of the USART these are the enabling constants. &nbsp;&nbsp;These constants are required.&nbsp;&nbsp;You can change the <code class="literal">USART_BAUD_RATE</code> and to meet your needs.&nbsp;&nbsp;For addition USART ports use <code class="literal">#define USART<span class="strong"><strong>n</strong></span>_BAUD_RATE 9600</code> where <code class="literal"><span class="strong"><strong>n</strong></span>`</code> is the required port number.</p><pre class="screen">    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will send ASCII codes 13 and 10 only using the hardware
RS232 module. ASCII codes 13 and 10 equate to a carriage return and line
feed.</p><p>Optionally, you can add a parameter. The number will determine the
number of ASCII codes 13 and 10 set to the hardware RS232 module.</p><p>Also you can choose the comport with second optional parameter if it is not the default comport 1. If there is no first optional parameter then you must have atleast acomma before it  to indicate this is the second parameter.</p><p><span class="strong"><strong>Examples:</strong></span></p><pre class="screen">  'This Line will send 1  CR and LF
  HserPrintCRLF    ' Will send a CR &amp; LF to the terminal

  'This Line will send 2  times (CR and LF)
  HserPrintCRLF 2    ' Will send 2 times (CR &amp; LF) to the terminal
            'out of comport 1

  'This Line will send 1  CR and LF
  HserPrintCRLF 1,2    ' Will send a CR &amp; LF out of
            'comport 2 to the terminal</pre><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_hserprintbytecrlf.html" title="HserPrintByteCRLF">HserPrintByteCRLF</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hserprintcrlf"></span>HserPrintCRLF

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HserPrintCRLF [optional BYTE] [, 1 | 2  | 3 | 4 ]
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a USART or UART module.  

Microchip PIC supports USART1 and 2.+ Atmel AVR supports USART 1,2,3 and
4.

<span class="strong">**Enabling Constants:**</span>

To enable the use of the USART these are the enabling constants.   These
constants are required.  You can change the `USART_BAUD_RATE` and to
meet your needs.  For addition USART ports use
`#define USARTn_BAUD_RATE 9600` where `` n` `` is the required port
number.

``` screen
    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF
```

<span class="strong">**Explanation:**</span>

This command will send ASCII codes 13 and 10 only using the hardware
RS232 module. ASCII codes 13 and 10 equate to a carriage return and line
feed.

Optionally, you can add a parameter. The number will determine the
number of ASCII codes 13 and 10 set to the hardware RS232 module.

Also you can choose the comport with second optional parameter if it is
not the default comport 1. If there is no first optional parameter then
you must have atleast acomma before it to indicate this is the second
parameter.

<span class="strong">**Examples:**</span>

``` screen
  'This Line will send 1  CR and LF
  HserPrintCRLF    ' Will send a CR & LF to the terminal

  'This Line will send 2  times (CR and LF)
  HserPrintCRLF 2    ' Will send 2 times (CR & LF) to the terminal
            'out of comport 1

  'This Line will send 1  CR and LF
  HserPrintCRLF 1,2    ' Will send a CR & LF out of
            'comport 2 to the terminal
```

<span class="strong">**See also**</span>
<a href="hserprintbytecrlf" class="link" title="HserPrintByteCRLF">HserPrintByteCRLF</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HSerPrintStringCRLF</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_hardware.html" title="RS232 (hardware)"><link rel="prev" href="_hserprint.html" title="HSerPrint"><link rel="next" href="_hserreceive.html" title="HSerReceive"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hserprintstringcrlf"></a>HSerPrintStringCRLF</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HSerPrintStringCRLF <span class="emphasis"><em>user_string</em></span> [,1|2|3|4]  'Choose comport with optional parameter
                                                'Default comport is 1</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a USART or UART module.<br></p><p>Microchip PIC supports USART1 and 2.<br>
Atmel AVR supports USART 1,2,3 and 4.</p><p><span class="strong"><strong>Enabling Constants:</strong></span></p><p>To enable the use of the USART these are the enabling constants. &nbsp;&nbsp;These constants are required.&nbsp;&nbsp;You can change the <code class="literal">USART_BAUD_RATE</code> and to meet your needs.&nbsp;&nbsp;For addition USART ports use <code class="literal">#define USART<span class="strong"><strong>n</strong></span>_BAUD_RATE 9600</code> where <code class="literal"><span class="strong"><strong>n</strong></span>`</code> is the required port number.</p><pre class="screen">    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">HSerPrintStringCRLF</code> is used to send a string over the serial connection. The parameter can only
 be a string. <code class="literal">HSerPrintStringCRLF</code> is very similar to <code class="literal">HserPrint</code> but <code class="literal">HserPrint</code> can handle all types of variables.</p><p>The data will be sent out the hardware serial module.</p><p><code class="literal">HSerPrintStringCRLF</code> will send new line characters:</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  'This program will display string over the serial connection.

  'Chip settings
  #chip 18F2525, 8

  'USART settings
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING

  'Show string message
  HSerPrintStringCRLF "GCBASIC RS232 Test"
  Wait 1 s</pre><p><span class="strong"><strong>For more help, see also</strong></span>
<a class="link" href="_hserprint.html" title="HSerPrint">HserPrint</a>, <a class="link" href="_hserprintbytecrlf.html" title="HserPrintByteCRLF">HserPrintByteCRLF</a> <span class="strong"><strong>and</strong></span> <a class="link" href="_hserprintcrlf.html" title="HserPrintCRLF">HserPrintCRLF</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hserprintstringcrlf"></span>HSerPrintStringCRLF

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HSerPrintStringCRLF user_string [,1|2|3|4]  'Choose comport with optional parameter
                                                'Default comport is 1
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a USART or UART module.  

Microchip PIC supports USART1 and 2.  
Atmel AVR supports USART 1,2,3 and 4.

<span class="strong">**Enabling Constants:**</span>

To enable the use of the USART these are the enabling constants.   These
constants are required.  You can change the `USART_BAUD_RATE` and to
meet your needs.  For addition USART ports use
`#define USARTn_BAUD_RATE 9600` where `` n` `` is the required port
number.

``` screen
    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF
```

<span class="strong">**Explanation:**</span>

`HSerPrintStringCRLF` is used to send a string over the serial
connection. The parameter can only be a string. `HSerPrintStringCRLF` is
very similar to `HserPrint` but `HserPrint` can handle all types of
variables.

The data will be sent out the hardware serial module.

`HSerPrintStringCRLF` will send new line characters:

<span class="strong">**Example:**</span>

``` screen
  'This program will display string over the serial connection.

  'Chip settings
  #chip 18F2525, 8

  'USART settings
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING

  'Show string message
  HSerPrintStringCRLF "GCBASIC RS232 Test"
  Wait 1 s
```

<span class="strong">**For more help, see also**</span>
<a href="hserprint" class="link" title="HSerPrint">HserPrint</a>,
<a href="hserprintbytecrlf" class="link" title="HserPrintByteCRLF">HserPrintByteCRLF</a>
<span class="strong">**and**</span>
<a href="hserprintcrlf" class="link" title="HserPrintCRLF">HserPrintCRLF</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HSerReceive</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_hardware.html" title="RS232 (hardware)"><link rel="prev" href="_hserprintstringcrlf.html" title="HSerPrintStringCRLF"><link rel="next" href="_hserreceivefrom.html" title="HSerReceiveFrom"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hserreceive"></a>HSerReceive</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><p><span class="strong"><strong><span class="emphasis"><em>Used as subroutine:</em></span></strong></span></p><pre class="screen">    HSerReceive (<span class="emphasis"><em>user_byte_variable</em></span>)</pre><p>or, if other multiple comports are in use, set the comport before using HSerReceive.</p><pre class="screen">    comport = 1   '(1|2|3|4|5)Not needed unless using multiple comports in use
    HSerReceive (_user_byte_variable_)</pre><p>or, used as function.</p><pre class="screen">  <span class="emphasis"><em>user_byte_variable</em></span> = <code class="literal">HSerReceive</code>  'Supports only USART1
  <span class="emphasis"><em>user_byte_variable</em></span> = <code class="literal">HSerReceive1</code> 'Supports only USART1
  <span class="emphasis"><em>user_byte_variable</em></span> = <code class="literal">HSerReceive2</code> 'Supports only USART2</pre><p>or, used to support assigning of received byte to word (or other multi-byte variables).&nbsp;&nbsp;Note the use of casting to ensure the <code class="literal">HSerReceive</code> uses byte addressing.</p><pre class="screen">  Dim dbAdr as Word

  HSerReceive [byte]dbAdr_H
  HSerReceive [byte]dbAdr</pre><p>For other comports use Function <code class="literal">HSerReceiveFrom</code></p><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a USART or UART module.</p><p>Microchip PIC supports USART1,2,3,4 and 5.<br>
Atmel AVR supports USART 1,2,3 and 4.</p><p><span class="strong"><strong>Enabling Constants:</strong></span></p><p>To enable the use of the USART these are the enabling constants. &nbsp;&nbsp;These constants are required.&nbsp;&nbsp;You can change the <code class="literal">USART_BAUD_RATE</code> and to meet your needs.&nbsp;&nbsp;For addition USART ports use <code class="literal">#define USART<span class="strong"><strong>n</strong></span>_BAUD_RATE 9600</code> where <code class="literal"><span class="strong"><strong>n</strong></span>`</code> is the required port number.</p><pre class="screen">    'USART settings for USART1
    #define USART_BAUD_RATE 9600       'Set the baud rate
    #define USART_TX_BLOCKING          'Ensure the transmit buffer is empty
    #define USART_BLOCKING             'Ensures a data byte is in the receive buffer
    #define USART_DELAY OFF	       'Disables USART delays</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will read a byte from the hardware RS232 module. It can be
used either as a subroutine or as a function. If used as a subroutine, a
variable must be supplied to store the received value in. If used as a
function, it will return the received value.</p><p>The subroutine HSerReceive can get a byte from any comport but must set the comport number immediately before the call.  If &#8221;#define USART_BLOCKING&#8221; is defined then the HserReceive waits in a loop until it receives a byte.   If&#8221; #define USART_BLOCKING&#8221; is NOT defined then HserReceive returns the new byte that was received OR returns 255 because of &#8220;DefaultUsartReturnValue = 255&#8221;  was defined.  This is good because it don&#8217;t hold up your program from executing other  commands and your can check it for new data priodically.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  'This program will read a value from the USART, and send it to PORTB.

  #chip 16F877A, 20

  'USART settings
  #define USART_BAUD_RATE 9600  'sets up comport 1 for 9600 baud

  'Set PORTB to output
  Dir PORTB Out
  'Set USART receive pin to input
  Dir PORTC.7 In

  'Main loop
  Do
    'Get serial data and output value to PortB as 8 bit binary
    HSerReceive(InChar)  'Receive data as Subroutine from comport 1
    'InChar = HSerReceive  'Could also be written as Function
    If InChar &lt;&gt; 255 Then   'If value is 255 then it is old data
      PortB = InChar    'If new data then it goes to PortB
    End If
  Loop</pre><p><span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">  'If you choose no &#8220;Blocking&#8221; and comment both of them out.
  'USART settings
  #define USART_BAUD_RATE 9600
  '#define USART_BLOCKING        ' just none OR one of the blocking
  '#define USART_TX_BLOCKING    ' statements should be defined

  'Main loop
  Do
    'Get and display value
    'If there is no new data, HSerReceive will return default value.
    comport = 1
    HSerReceive tempvalue
    If tempvalue &lt;&gt; 255    Then    &#8216; don&#8217;t change PortB if it is default
      PortB = tempvalue
    End If

  Loop</pre><p><span class="strong"><strong>Example 3:</strong></span></p><pre class="screen">  'If you choose no &#8220;Blocking&#8221; and comment both of them out.
  #chip mega328p, 16

  #define USART_BAUD_RATE 9600
  '#define USART_BLOCKING
  '#define USART_TX_BLOCKING

  'Don't forget to Set usart pin directions
  Dir PortD.1 Out    'com1   USART0
  Dir PortD.0 In

  Wait 1 s

  'Message after reset
  HSerPrint "ATmega328P  com test"
  HSerPrintCRLF

  'Main routine  hook up FTDI232 usb to serial and use terminal program to check
  Start:
    comport = 1
    HSerReceive(InChar)    'Subroutine needs the comport set
    'InChar = HSerReceive    ' This function will get from comport 1
      If InChar &lt;&gt; 255 Then    ' check if for received byte
                  'return 255 if old data
        HSerSend InChar    'send back char to UART
      End If
  Goto Start</pre><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_rs232_hardware_overview.html" title="RS232 Hardware Overview">RS232 Hardware Overview</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hserreceive"></span>HSerReceive

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

<span class="strong">**<span class="emphasis">*Used as
subroutine:*</span>**</span>

``` screen
    HSerReceive (user_byte_variable)
```

or, if other multiple comports are in use, set the comport before using
HSerReceive.

``` screen
    comport = 1   '(1|2|3|4|5)Not needed unless using multiple comports in use
    HSerReceive (_user_byte_variable_)
```

or, used as function.

``` screen
  user_byte_variable = HSerReceive  'Supports only USART1
  user_byte_variable = HSerReceive1 'Supports only USART1
  user_byte_variable = HSerReceive2 'Supports only USART2
```

or, used to support assigning of received byte to word (or other
multi-byte variables).  Note the use of casting to ensure the
`HSerReceive` uses byte addressing.

``` screen
  Dim dbAdr as Word

  HSerReceive [byte]dbAdr_H
  HSerReceive [byte]dbAdr
```

For other comports use Function `HSerReceiveFrom`

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a USART or UART module.

Microchip PIC supports USART1,2,3,4 and 5.  
Atmel AVR supports USART 1,2,3 and 4.

<span class="strong">**Enabling Constants:**</span>

To enable the use of the USART these are the enabling constants.   These
constants are required.  You can change the `USART_BAUD_RATE` and to
meet your needs.  For addition USART ports use
`#define USARTn_BAUD_RATE 9600` where `` n` `` is the required port
number.

``` screen
    'USART settings for USART1
    #define USART_BAUD_RATE 9600       'Set the baud rate
    #define USART_TX_BLOCKING          'Ensure the transmit buffer is empty
    #define USART_BLOCKING             'Ensures a data byte is in the receive buffer
    #define USART_DELAY OFF        'Disables USART delays
```

<span class="strong">**Explanation:**</span>

This command will read a byte from the hardware RS232 module. It can be
used either as a subroutine or as a function. If used as a subroutine, a
variable must be supplied to store the received value in. If used as a
function, it will return the received value.

The subroutine HSerReceive can get a byte from any comport but must set
the comport number immediately before the call. If ”\#define
USART\_BLOCKING” is defined then the HserReceive waits in a loop until
it receives a byte. If” \#define USART\_BLOCKING” is NOT defined then
HserReceive returns the new byte that was received OR returns 255
because of “DefaultUsartReturnValue = 255” was defined. This is good
because it don’t hold up your program from executing other commands and
your can check it for new data priodically.

<span class="strong">**Example:**</span>

``` screen
  'This program will read a value from the USART, and send it to PORTB.

  #chip 16F877A, 20

  'USART settings
  #define USART_BAUD_RATE 9600  'sets up comport 1 for 9600 baud

  'Set PORTB to output
  Dir PORTB Out
  'Set USART receive pin to input
  Dir PORTC.7 In

  'Main loop
  Do
    'Get serial data and output value to PortB as 8 bit binary
    HSerReceive(InChar)  'Receive data as Subroutine from comport 1
    'InChar = HSerReceive  'Could also be written as Function
    If InChar <> 255 Then   'If value is 255 then it is old data
      PortB = InChar    'If new data then it goes to PortB
    End If
  Loop
```

<span class="strong">**Example 2:**</span>

``` screen
  'If you choose no “Blocking” and comment both of them out.
  'USART settings
  #define USART_BAUD_RATE 9600
  '#define USART_BLOCKING        ' just none OR one of the blocking
  '#define USART_TX_BLOCKING    ' statements should be defined

  'Main loop
  Do
    'Get and display value
    'If there is no new data, HSerReceive will return default value.
    comport = 1
    HSerReceive tempvalue
    If tempvalue <> 255    Then    ‘ don’t change PortB if it is default
      PortB = tempvalue
    End If

  Loop
```

<span class="strong">**Example 3:**</span>

``` screen
  'If you choose no “Blocking” and comment both of them out.
  #chip mega328p, 16

  #define USART_BAUD_RATE 9600
  '#define USART_BLOCKING
  '#define USART_TX_BLOCKING

  'Don't forget to Set usart pin directions
  Dir PortD.1 Out    'com1   USART0
  Dir PortD.0 In

  Wait 1 s

  'Message after reset
  HSerPrint "ATmega328P  com test"
  HSerPrintCRLF

  'Main routine  hook up FTDI232 usb to serial and use terminal program to check
  Start:
    comport = 1
    HSerReceive(InChar)    'Subroutine needs the comport set
    'InChar = HSerReceive    ' This function will get from comport 1
      If InChar <> 255 Then    ' check if for received byte
                  'return 255 if old data
        HSerSend InChar    'send back char to UART
      End If
  Goto Start
```

<span class="strong">**See also**</span>
<a href="rs232_hardware_overview" class="link" title="RS232 Hardware Overview">RS232 Hardware Overview</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HSerReceiveFrom</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_hardware.html" title="RS232 (hardware)"><link rel="prev" href="_hserreceive.html" title="HSerReceive"><link rel="next" href="_hsersend.html" title="HSerSend"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hserreceivefrom"></a>HSerReceiveFrom</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  <span class="emphasis"><em>user_byte</em></span> = HSerReceiveFrom [,1 | 2 | 3 | 4]
  <span class="emphasis"><em>user_byte</em></span> = HSerReceiveFrom         'Defaults to USART1

  'other Receive functions
  <span class="emphasis"><em>user_byte</em></span> = HSerReceive1    'from USART1
  <span class="emphasis"><em>user_byte</em></span> = HSerReceive2    'from USART2</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a USART or UART module.<br></p><p>Microchip PIC supports USART1 and 2.<br>
Atmel AVR supports USART 1,2,3 and 4.</p><p><span class="strong"><strong>Enabling Constants:</strong></span></p><p>To enable the use of the USART these are the enabling constants. &nbsp;&nbsp;These constants are required.&nbsp;&nbsp;You can change the <code class="literal">USART_BAUD_RATE</code> and to meet your needs.&nbsp;&nbsp;For addition USART ports use <code class="literal">#define USART<span class="strong"><strong>n</strong></span>_BAUD_RATE 9600</code> where <code class="literal"><span class="strong"><strong>n</strong></span>`</code> is the required port number.</p><pre class="screen">    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will read a byte from the hardware RS232 module. It can be only be used as a function. It will return the received value.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  'This program will read a value from the USART, and display it on PORTB.

  #chip 16F877A, 20

  'USART settings
  #define USART_BAUD_RATE 9600
  #define USART_BLOCKING
  #define USART_TX_BLOCKING


  'Set PORTB to input
  Dir PORTB Out
  'Set USART receive pin to input
  Dir PORTC.7 In

  'Main loop
  Do
    'Get byte value
    bytein = HSerReceiveFrom (2)
    'do something useful
  Loop</pre><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_hserreceive.html" title="HSerReceive">HSerReceive</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hserreceivefrom"></span>HSerReceiveFrom

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  user_byte = HSerReceiveFrom [,1 | 2 | 3 | 4]
  user_byte = HSerReceiveFrom         'Defaults to USART1

  'other Receive functions
  user_byte = HSerReceive1    'from USART1
  user_byte = HSerReceive2    'from USART2
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a USART or UART module.  

Microchip PIC supports USART1 and 2.  
Atmel AVR supports USART 1,2,3 and 4.

<span class="strong">**Enabling Constants:**</span>

To enable the use of the USART these are the enabling constants.   These
constants are required.  You can change the `USART_BAUD_RATE` and to
meet your needs.  For addition USART ports use
`#define USARTn_BAUD_RATE 9600` where `` n` `` is the required port
number.

``` screen
    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF
```

<span class="strong">**Explanation:**</span>

This command will read a byte from the hardware RS232 module. It can be
only be used as a function. It will return the received value.

<span class="strong">**Example:**</span>

``` screen
  'This program will read a value from the USART, and display it on PORTB.

  #chip 16F877A, 20

  'USART settings
  #define USART_BAUD_RATE 9600
  #define USART_BLOCKING
  #define USART_TX_BLOCKING


  'Set PORTB to input
  Dir PORTB Out
  'Set USART receive pin to input
  Dir PORTC.7 In

  'Main loop
  Do
    'Get byte value
    bytein = HSerReceiveFrom (2)
    'do something useful
  Loop
```

<span class="strong">**See also**</span>
<a href="hserreceive" class="link" title="HSerReceive">HSerReceive</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HSerSend</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_hardware.html" title="RS232 (hardware)"><link rel="prev" href="_hserreceivefrom.html" title="HSerReceiveFrom"><link rel="next" href="_hserprintbytecrlf.html" title="HserPrintByteCRLF"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hsersend"></a>HSerSend</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    HSerSend <span class="emphasis"><em>user_byte</em></span> [,1|2|3|4]   'Choose comport with optional parameter
                                      'Default comport is 1</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a USART or UART module.</p><p>Microchip PIC supports USART1 and 2.<br>
Atmel AVR supports USART 1,2,3 and 4.</p><p><span class="strong"><strong>Enabling Constants:</strong></span></p><p>To enable the use of the USART these are the enabling constants. &nbsp;&nbsp;These constants are required.&nbsp;&nbsp;You can change the <code class="literal">USART_BAUD_RATE</code> and to meet your needs.&nbsp;&nbsp;For addition USART ports use <code class="literal">#define USART<span class="strong"><strong>n</strong></span>_BAUD_RATE 9600</code> where <code class="literal"><span class="strong"><strong>n</strong></span>`</code> is the required port number.</p><pre class="screen">    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will send a byte given by <span class="emphasis"><em>user_byte</em></span> using the hardware RS232
module.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  'This program will send the status of PORTB through the hardware
  'serial module.

  #chip 16F877A, 20

  'USART settings
  #define USART_BAUD_RATE 9600  'Initializes USART port with 9600 baud
  '#define USART_BLOCKING   ' Both of these blocking statements will
  #define USART_TX_BLOCKING ' wait for tx register to be empty
                ' use only one of the two constants
  #define USART_DELAY OFF

  'Set PORTB to input
  Dir PORTB In
  'Set USART transmit pin to output
  Dir PORTC.6 Out

  'Main loop
  Do
    'Send PORTB value through USART
    HSerSend PORTB
    HSerSend(13)    ' sends a CR
    'Short delay for receiver to process message
    Wait 10 ms      'probably not necessary with blocking statement
  Loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hsersend"></span>HSerSend

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    HSerSend user_byte [,1|2|3|4]   'Choose comport with optional parameter
                                      'Default comport is 1
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a USART or UART module.

Microchip PIC supports USART1 and 2.  
Atmel AVR supports USART 1,2,3 and 4.

<span class="strong">**Enabling Constants:**</span>

To enable the use of the USART these are the enabling constants.   These
constants are required.  You can change the `USART_BAUD_RATE` and to
meet your needs.  For addition USART ports use
`#define USARTn_BAUD_RATE 9600` where `` n` `` is the required port
number.

``` screen
    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF
```

<span class="strong">**Explanation:**</span>

This command will send a byte given by <span
class="emphasis">*user\_byte*</span> using the hardware RS232 module.

<span class="strong">**Example:**</span>

``` screen
  'This program will send the status of PORTB through the hardware
  'serial module.

  #chip 16F877A, 20

  'USART settings
  #define USART_BAUD_RATE 9600  'Initializes USART port with 9600 baud
  '#define USART_BLOCKING   ' Both of these blocking statements will
  #define USART_TX_BLOCKING ' wait for tx register to be empty
                ' use only one of the two constants
  #define USART_DELAY OFF

  'Set PORTB to input
  Dir PORTB In
  'Set USART transmit pin to output
  Dir PORTC.6 Out

  'Main loop
  Do
    'Send PORTB value through USART
    HSerSend PORTB
    HSerSend(13)    ' sends a CR
    'Short delay for receiver to process message
    Wait 10 ms      'probably not necessary with blocking statement
  Loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HX8347G Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_e_paper_controllers.html" title="e-Paper Controllers"><link rel="next" href="_ili9326_controllers.html" title="ILI9326 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hx8347g_controllers"></a>HX8347G Controllers</h5></div></div></div><p>This section covers GLCD devices that use the HX8347G graphics controller.</p><p>HX8347G is a 262k-color single-chip SoC driver for a-TFT liquid crystal display with resolution of 240&nbsp;RGB&nbsp;x&nbsp;320&nbsp;
dots.</p><p>The HX8347-G is designed to provide a single-chip solution that combines a gate
driver, a source driver, power supply circuit for 262k colors to drive a TFT panel
with 240RGBx320 dots at maximum.</p><p>GCBASIC supports 65K-color mode operations.</p><p>The HX8347-G can be operated in low-voltage (1.4V) condition for the interface and
integrated internal boosters that produce the liquid crystal voltage, breeder resistance
and the voltage follower circuit for liquid crystal driver. In addition, The HX8347-G also
supports various functions to reduce the power consumption of a LCD system via
software control.</p><p>The GCBASIC constants shown below control the configuration of the HX8347G controller.
&nbsp;&nbsp;&nbsp;The GCBASIC constants for control and data line connections are shown
in the table below.</p><p>Connectivity is via an 8-bit bus.  Where 8 pins are connected between the microcontroller and the GLCD to control the
data bus plus 5 control pins.  This is simple when using an Arduino GLCD Shield.</p><p>To use the HX8347G driver simply include the following in your user code.  This will initialise the driver.</p><p><br>
<br>
<span class="strong"><strong>8-bit mode</strong></span></p><pre class="screen">    'This GLCD driver supports 8 bit only. UNO ports can be replaced with porta.b constants.

    #include &lt;glcd.h&gt;
    #include &lt;UNO_mega328p.h &gt;
    #define GLCD_TYPE GLCD_TYPE_HX8347

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line

    #define GLCD_DB0       DIGITAL_8
    #define GLCD_DB1       DIGITAL_9
    #define GLCD_DB2       DIGITAL_2
    #define GLCD_DB3       DIGITAL_3
    #define GLCD_DB4       DIGITAL_4
    #define GLCD_DB5       DIGITAL_5
    #define GLCD_DB6       DIGITAL_6
    #define GLCD_DB7       DIGITAL_7</pre><p><br>
<br></p><p>The GCBASIC constants for the interface to the controller are shown in the table below.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Options</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_HX8347</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DB0..7</code></p></td><td align="left" valign="top"><p>Specifies the  pin that is connected to DB0..7 IO pin on the GLCD (8 bit DBI).</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RST</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset IO pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_WR</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data In (RW or WDR) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RD</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (RD or RDR) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr></tbody></table></div><p><br>
<br>
The GCBASIC constants for control display characteristics are shown in the table below.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Default</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">320</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">480</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="left" valign="top"><p><code class="literal">6</code> for GCB fonts, and <code class="literal">5</code> for OLED fonts.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_OLED_FONT</code></p></td><td align="left" valign="top"><p>Specifies the use of the optional OLED font set.
</p><p>The GLCDfntDefaultsize can be set to 1 or 2 only.
</p><p><code class="literal">GLCDfntDefaultsize=  1</code>.   A small 8 height pixel font with variable width.
<code class="literal">GLCDfntDefaultsize=  2</code>.   A larger 10 width * 16 height pixel font.</p></td><td align="left" valign="top"><p>Optional</p></td></tr></tbody></table></div><p><br>
<br></p><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDRotate</code></p></td><td align="left" valign="top"><p>Rotate the display</p></td><td align="left" valign="top"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HX8347G_[color]</code></p></td><td align="left" valign="top"><p>Specify color as a parameter for many GLCD commands</p></td><td align="left" valign="top"><p>Color constants for this device are shown in the list below.<br>
</p><p></p><p> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td></tr></tbody></table></div><p><br>
<br></p><pre class="screen">    HX8347G_BLACK   'hexidecimal value 0x0000
    HX8347G_RED     'hexidecimal value 0xF800
    HX8347G_GREEN   'hexidecimal value 0x0400
    HX8347G_BLUE    'hexidecimal value 0x001F
    HX8347G_WHITE   'hexidecimal value 0xFFFF
    HX8347G_PURPLE  'hexidecimal value 0xF11F
    HX8347G_YELLOW  'hexidecimal value 0xFFE0
    HX8347G_CYAN    'hexidecimal value 0x07FF
    HX8347G_D_GRAY  'hexidecimal value 0x528A
    HX8347G_L_GRAY  'hexidecimal value 0x7997
    HX8347G_SILVER  'hexidecimal value 0xC618
    HX8347G_MAROON  'hexidecimal value 0x8000
    HX8347G_OLIVE   'hexidecimal value 0x8400
    HX8347G_LIME    'hexidecimal value 0x07E0
    HX8347G_AQUA    'hexidecimal value 0x07FF
    HX8347G_TEAL    'hexidecimal value 0x0410
    HX8347G_NAVY    'hexidecimal value 0x0010
    HX8347G_FUCHSIA 'hexidecimal value 0xF81F</pre><p><br>
<br></p><p>These examples show how to drive a HX8347G based Graphic LCD module with the built in commands of GCBASIC.  The 8 bit DBI example uses a UNO shield, this can easily adapted to Microchip architecture.  The 16 bit DBI
example uses a Mega2560 board.</p><p><br>
<br>
<span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #chip mega328p, 16
    #option explicit


    #include &lt;glcd.h&gt;
    #include &lt;UNO_mega328p.h &gt;

    #define GLCD_TYPE GLCD_TYPE_HX8347
    #define GLCD_OLED_FONT

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line



    #define GLCD_DB0       DIGITAL_8
    #define GLCD_DB1       DIGITAL_9
    #define GLCD_DB2       DIGITAL_2
    #define GLCD_DB3       DIGITAL_3
    #define GLCD_DB4       DIGITAL_4
    #define GLCD_DB5       DIGITAL_5
    #define GLCD_DB6       DIGITAL_6
    #define GLCD_DB7       DIGITAL_7


    GLCDRotate ( Portrait )
    GLCDCLS HX8347_RED
    GLCDPrint(0, 0, "Test of the HX8347G Device")
    end</pre><p><br>
<br></p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>,  <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a>
<br>
<br>
Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="hx8347g_controllers"></span>HX8347G Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the HX8347G graphics
controller.

HX8347G is a 262k-color single-chip SoC driver for a-TFT liquid crystal
display with resolution of 240 RGB x 320  dots.

The HX8347-G is designed to provide a single-chip solution that combines
a gate driver, a source driver, power supply circuit for 262k colors to
drive a TFT panel with 240RGBx320 dots at maximum.

GCBASIC supports 65K-color mode operations.

The HX8347-G can be operated in low-voltage (1.4V) condition for the
interface and integrated internal boosters that produce the liquid
crystal voltage, breeder resistance and the voltage follower circuit for
liquid crystal driver. In addition, The HX8347-G also supports various
functions to reduce the power consumption of a LCD system via software
control.

The GCBASIC constants shown below control the configuration of the
HX8347G controller.    The GCBASIC constants for control and data line
connections are shown in the table below.

Connectivity is via an 8-bit bus. Where 8 pins are connected between the
microcontroller and the GLCD to control the data bus plus 5 control
pins. This is simple when using an Arduino GLCD Shield.

To use the HX8347G driver simply include the following in your user
code. This will initialise the driver.

  
  
<span class="strong">**8-bit mode**</span>

``` screen
    'This GLCD driver supports 8 bit only. UNO ports can be replaced with porta.b constants.

    #include <glcd.h>
    #include <UNO_mega328p.h >
    #define GLCD_TYPE GLCD_TYPE_HX8347

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line

    #define GLCD_DB0       DIGITAL_8
    #define GLCD_DB1       DIGITAL_9
    #define GLCD_DB2       DIGITAL_2
    #define GLCD_DB3       DIGITAL_3
    #define GLCD_DB4       DIGITAL_4
    #define GLCD_DB5       DIGITAL_5
    #define GLCD_DB6       DIGITAL_6
    #define GLCD_DB7       DIGITAL_7
```

  
  

The GCBASIC constants for the interface to the controller are shown in
the table below.  
  

<div class="informaltable">

| Constants     | Controls                                                                            | Options  |
|:--------------|:------------------------------------------------------------------------------------|:---------|
| `GLCD_TYPE`   | `GLCD_TYPE_HX8347`                                                                  |          |
| `GLCD_DB0..7` | Specifies the pin that is connected to DB0..7 IO pin on the GLCD (8 bit DBI).       | Required |
| `GLCD_RST`    | Specifies the output pin that is connected to Reset IO pin on the GLCD.             | Required |
| `GLCD_CS`     | Specifies the output pin that is connected to Chip Select (CS) on the GLCD.         | Required |
| `GLCD_RS`     | Specifies the output pin that is connected to Data/Command pin on the GLCD.         | Required |
| `GLCD_WR`     | Specifies the output pin that is connected to Data In (RW or WDR) pin on the GLCD.  | Required |
| `GLCD_RD`     | Specifies the output pin that is connected to Data Out (RD or RDR) pin on the GLCD. | Required |

</div>

  
  
The GCBASIC constants for control display characteristics are shown in
the table below.  
  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Constants</th>
<th style="text-align: left;">Controls</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">320</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">480</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Specifies the font width of the GCBASIC font set.</p></td>
<td style="text-align: left;"><p><code class="literal">6</code> for GCB fonts, and <code class="literal">5</code> for OLED fonts.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_OLED_FONT</code></p></td>
<td style="text-align: left;"><p>Specifies the use of the optional OLED font set.</p>
<p>The GLCDfntDefaultsize can be set to 1 or 2 only.</p>
<p><code class="literal">GLCDfntDefaultsize=  1</code>. A small 8 height pixel font with variable width. <code class="literal">GLCDfntDefaultsize=  2</code>. A larger 10 width * 16 height pixel font.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
</tbody>
</table>

</div>

  
  

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.  
  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
<td style="text-align: left;"><p>Clear screen of GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDPrint</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar</code></p></td>
<td style="text-align: left;"><p>Print character on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDDrawString</code></p></td>
<td style="text-align: left;"><p>Print characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Box</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size</p></td>
<td style="text-align: left;"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">FilledBox</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td>
<td style="text-align: left;"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Line</code></p></td>
<td style="text-align: left;"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">PSet</code></p></td>
<td style="text-align: left;"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte</code></p></td>
<td style="text-align: left;"><p>Set a byte value to the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDReadByte</code></p></td>
<td style="text-align: left;"><p>Read a byte value from the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDRotate</code></p></td>
<td style="text-align: left;"><p>Rotate the display</p></td>
<td style="text-align: left;"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HX8347G_[color]</code></p></td>
<td style="text-align: left;"><p>Specify color as a parameter for many GLCD commands</p></td>
<td style="text-align: left;"><p>Color constants for this device are shown in the list below.<br />
</p>
<p>Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td>
</tr>
</tbody>
</table>

</div>

  
  

``` screen
    HX8347G_BLACK   'hexidecimal value 0x0000
    HX8347G_RED     'hexidecimal value 0xF800
    HX8347G_GREEN   'hexidecimal value 0x0400
    HX8347G_BLUE    'hexidecimal value 0x001F
    HX8347G_WHITE   'hexidecimal value 0xFFFF
    HX8347G_PURPLE  'hexidecimal value 0xF11F
    HX8347G_YELLOW  'hexidecimal value 0xFFE0
    HX8347G_CYAN    'hexidecimal value 0x07FF
    HX8347G_D_GRAY  'hexidecimal value 0x528A
    HX8347G_L_GRAY  'hexidecimal value 0x7997
    HX8347G_SILVER  'hexidecimal value 0xC618
    HX8347G_MAROON  'hexidecimal value 0x8000
    HX8347G_OLIVE   'hexidecimal value 0x8400
    HX8347G_LIME    'hexidecimal value 0x07E0
    HX8347G_AQUA    'hexidecimal value 0x07FF
    HX8347G_TEAL    'hexidecimal value 0x0410
    HX8347G_NAVY    'hexidecimal value 0x0010
    HX8347G_FUCHSIA 'hexidecimal value 0xF81F
```

  
  

These examples show how to drive a HX8347G based Graphic LCD module with
the built in commands of GCBASIC. The 8 bit DBI example uses a UNO
shield, this can easily adapted to Microchip architecture. The 16 bit
DBI example uses a Mega2560 board.

  
  
<span class="strong">**Example:**</span>

``` screen
    #chip mega328p, 16
    #option explicit


    #include <glcd.h>
    #include <UNO_mega328p.h >

    #define GLCD_TYPE GLCD_TYPE_HX8347
    #define GLCD_OLED_FONT

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line



    #define GLCD_DB0       DIGITAL_8
    #define GLCD_DB1       DIGITAL_9
    #define GLCD_DB2       DIGITAL_2
    #define GLCD_DB3       DIGITAL_3
    #define GLCD_DB4       DIGITAL_4
    #define GLCD_DB5       DIGITAL_5
    #define GLCD_DB6       DIGITAL_6
    #define GLCD_DB7       DIGITAL_7


    GLCDRotate ( Portrait )
    GLCDCLS HX8347_RED
    GLCDPrint(0, 0, "Test of the HX8347G Device")
    end
```

  
  

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>  
  
Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Hyperbole</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_line.html" title="Line"><link rel="next" href="_parabola.html" title="Parabola"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_hyperbole"></a>Hyperbole</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Hyperbole (x,  y,  a_axis,  b_axis,  type, ModeStop, optional LineColour=GLCDForeground)</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Draws on a GLCD an hyperbole with equation (x/(a)<sup>2-(y/(b)</sup>2=1, centered at  pixel positions (x, y)  with axis a and b.</p><p>The hyperbole can be aligned either along the x axis or along the y axis.</p><p>Both cases a_axis&gt;=b:axis and a_axis&lt;b_axis are accepted.</p><p>The hyperbole is an unbounded curve made by four branches</p><p>Drawing hyperbole on the screen can be stopped by following two different criteria:
  -  a branch has reached a border of the display
  -  all branches have reached the display border</p><p>For an hyperbole centered on the display these criteria are equivalent.</p><p><span class="strong"><strong>Input parameters:</strong></span></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Parameter</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">x</code></p></td><td align="left" valign="top"><p>X coordinates  of hyperbole center (in pixel positions)</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">y</code></p></td><td align="left" valign="top"><p>Y coordinates  of hyperbole center (in pixel positions)
</p><p></p><p>The x or y coordinates are Word value.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">a_axis</code></p></td><td align="left" valign="top"><p>The a axis of the hyperbole</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">b_axis</code></p></td><td align="left" valign="top"><p>The b axis of the hyperbole</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">type</code></p></td><td align="left" valign="top"><p>type=1 the hyperbole is aligned along x axis
<br>
type=2 the hyperbole is aligned along y axis</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">modestop</code></p></td><td align="left" valign="top"><p>modestop=1 drawing stops when a display border is encountered by a hyperbole branch.
<br>
modestop=2 drawing stops when all the reachable display borders are encountered by all the hyperbole branches</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LineColour</code></p></td><td align="left" valign="top"><p>Color of the hyperbole</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Example for a 240x320 pixels GLCD

    #include &lt;glcd.h&gt;

    Hyperbole(120, 160, 40,20, 1, 2, GLCDForeground)   ; centered, a=40, b=20, x_axis alined, stops when all branches have reached a a border
    Hyperbole(120, 160, 40,20, 1, 1, GLCDForeground)   ; centered, a=40, b=20, x_axis alined, stops when a border is reached
    Hyperbole(120, 160, 40,20, 2, 1, GLCDForeground)   ; centered, a=40, b=20, y_axis alined, stops when a border is reached,

    Hyperbole(180, 80, 40,20, 1, 1, GLCDForeground)   ; upper right, a=40, b=20, x_axis alined, stops when a border is reached,
    Hyperbole(60, 240, 40,20, 1, 2, GLCDForeground)   ; lower left, a=40, b=20, x_axis alined, stops when all branches have reached a border

    Hyperbole(180, 80, 40,20, 2, 1, GLCDForeground)   ; upper right, a=40, b=20, y_axis alined, stops when a border is reached,
    Hyperbole(60, 240, 40,20, 2, 2, GLCDForeground)   ; lower left, a=40, b=20, y_axis alined, stops when all branches have reached a border</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="hyperbole"></span>Hyperbole

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Hyperbole (x,  y,  a_axis,  b_axis,  type, ModeStop, optional LineColour=GLCDForeground)
```

<span class="strong">**Explanation:**</span>

Draws on a GLCD an hyperbole with equation (x/(a)<sup>2-(y/(b)</sup>2=1,
centered at pixel positions (x, y) with axis a and b.

The hyperbole can be aligned either along the x axis or along the y
axis.

Both cases a\_axis&gt;=b:axis and a\_axis&lt;b\_axis are accepted.

The hyperbole is an unbounded curve made by four branches

Drawing hyperbole on the screen can be stopped by following two
different criteria: - a branch has reached a border of the display - all
branches have reached the display border

For an hyperbole centered on the display these criteria are equivalent.

<span class="strong">**Input parameters:**</span>

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Parameter</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">x</code></p></td>
<td style="text-align: left;"><p>X coordinates of hyperbole center (in pixel positions)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">y</code></p></td>
<td style="text-align: left;"><p>Y coordinates of hyperbole center (in pixel positions)</p>
<p>The x or y coordinates are Word value.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">a_axis</code></p></td>
<td style="text-align: left;"><p>The a axis of the hyperbole</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">b_axis</code></p></td>
<td style="text-align: left;"><p>The b axis of the hyperbole</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">type</code></p></td>
<td style="text-align: left;"><p>type=1 the hyperbole is aligned along x axis<br />
type=2 the hyperbole is aligned along y axis</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">modestop</code></p></td>
<td style="text-align: left;"><p>modestop=1 drawing stops when a display border is encountered by a hyperbole branch.<br />
modestop=2 drawing stops when all the reachable display borders are encountered by all the hyperbole branches</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LineColour</code></p></td>
<td style="text-align: left;"><p>Color of the hyperbole</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Example:**</span>

``` screen
    'Example for a 240x320 pixels GLCD

    #include <glcd.h>

    Hyperbole(120, 160, 40,20, 1, 2, GLCDForeground)   ; centered, a=40, b=20, x_axis alined, stops when all branches have reached a a border
    Hyperbole(120, 160, 40,20, 1, 1, GLCDForeground)   ; centered, a=40, b=20, x_axis alined, stops when a border is reached
    Hyperbole(120, 160, 40,20, 2, 1, GLCDForeground)   ; centered, a=40, b=20, y_axis alined, stops when a border is reached,

    Hyperbole(180, 80, 40,20, 1, 1, GLCDForeground)   ; upper right, a=40, b=20, x_axis alined, stops when a border is reached,
    Hyperbole(60, 240, 40,20, 1, 2, GLCDForeground)   ; lower left, a=40, b=20, x_axis alined, stops when all branches have reached a border

    Hyperbole(180, 80, 40,20, 2, 1, GLCDForeground)   ; upper right, a=40, b=20, y_axis alined, stops when a border is reached,
    Hyperbole(60, 240, 40,20, 2, 2, GLCDForeground)   ; lower left, a=40, b=20, y_axis alined, stops when all branches have reached a border
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2CAckpoll</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_software.html" title="I2C Software"><link rel="prev" href="_i2cackpollstate.html" title="I2CAckPollState"><link rel="next" href="_i2creceive.html" title="I2CReceive"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_i2cackpoll"></a>I2CAckpoll</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">	I2CAckpoll ( <span class="emphasis"><em>I2C_device_address</em></span> )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Should only be used when I2C routines are operating in Master mode, this
command will look for a specific I2C device on the I2C bus.</p><p>This sets a global variable <code class="literal">I2CAckPollState</code> that can be inspected in
your calling routine.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">	 ...
	' ACK polling removes the need to for the 24xxxxx device to have a 5ms write time
	I2CACKPOLL( eeprom_device )
	' You check the exit state, use I2CAckPollState to check the state of
	' the acknowledge from the target device
	 ...</pre><p>Supported in &lt;I2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="i2cackpoll"></span>I2CAckpoll

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  I2CAckpoll ( I2C_device_address )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers except 12 bit instruction Microchip
PIC microcontrollers (10F, 12F5xx, 16F5xx chips)

<span class="strong">**Explanation:**</span>

Should only be used when I2C routines are operating in Master mode, this
command will look for a specific I2C device on the I2C bus.

This sets a global variable `I2CAckPollState` that can be inspected in
your calling routine.

<span class="strong">**Example:**</span>

``` screen
    ...
    ' ACK polling removes the need to for the 24xxxxx device to have a 5ms write time
    I2CACKPOLL( eeprom_device )
    ' You check the exit state, use I2CAckPollState to check the state of
    ' the acknowledge from the target device
     ...
```

Supported in &lt;I2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2CAckPollState</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_software.html" title="I2C Software"><link rel="prev" href="_i2c_overview.html" title="I2C Overview"><link rel="next" href="_i2cackpoll.html" title="I2CAckpoll"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_i2cackpollstate"></a>I2CAckPollState</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">	&lt;test condition&gt; I2CAckPollState</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Should only be used when I2C routines are operating in Master mode, this
command will return the last state of the acknowledge response from a
specific I2C device on the I2C bus.</p><p><code class="literal">I2CACKPOLL</code> sets the state of variable <code class="literal">I2CAckPollState</code>. <code class="literal">I2CAckPollState</code>
can only read - it cannot be set.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">	 ...
	' ACK polling removes the need to for the 24xxxxx device to have a 5ms
	write time
	I2CACKPOLL( eeprom_device )
	' You check the exit state,
	' Use I2CAckPollState to check the state of a target device
	 ...</pre><p>Supported in &lt;I2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="i2cackpollstate"></span>I2CAckPollState

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
 <test condition> I2CAckPollState
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers except 12 bit instruction Microchip
PIC microcontrollers (10F, 12F5xx, 16F5xx chips)

<span class="strong">**Explanation:**</span>

Should only be used when I2C routines are operating in Master mode, this
command will return the last state of the acknowledge response from a
specific I2C device on the I2C bus.

`I2CACKPOLL` sets the state of variable `I2CAckPollState`.
`I2CAckPollState` can only read - it cannot be set.

<span class="strong">**Example:**</span>

``` screen
    ...
    ' ACK polling removes the need to for the 24xxxxx device to have a 5ms
    write time
    I2CACKPOLL( eeprom_device )
    ' You check the exit state,
    ' Use I2CAckPollState to check the state of a target device
     ...
```

Supported in &lt;I2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2CReceive</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_software.html" title="I2C Software"><link rel="prev" href="_i2cackpoll.html" title="I2CAckpoll"><link rel="next" href="_i2creset.html" title="I2CReset"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_i2creceive"></a>I2CReceive</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  I2CReceive <span class="emphasis"><em>data</em></span>
  I2CReceive <span class="emphasis"><em>data</em></span>, <span class="emphasis"><em>ack</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The I2CReceive command will send <code class="literal"><span class="emphasis"><em>data</em></span></code> through the I2C connection. If
<code class="literal"><span class="emphasis"><em>ack</em></span></code> is TRUE, or no value is given for <code class="literal"><span class="emphasis"><em>ack</em></span></code>, then <code class="literal">I2CReceive</code> will send
an ack.</p><p>If in master mode, <code class="literal">I2CReceive</code> will read the data immediately.</p><p>If in slave mode, <code class="literal">I2CReceive</code> will wait for the master to send the data
before reading. When the method <code class="literal">I2CReceive</code> is used in Slave mode the
global variable <code class="literal">I2CMatch</code> will be set to true when the received value is
equal to the constant <code class="literal">I2C_ADDRESS</code>.</p><p><span class="strong"><strong>Example 1 - Master Mode:</strong></span></p><pre class="screen">  ' I2C Receive - using the ChipIno board, see here for information. ' This program reads an I2C register and LED is set to on if the value  is over 100.
  ' This program will read from address 83, register 1.

  #chip 16F886, 8
  #config MCLRE_ON

  'I2C settings
  #define I2C_MODE Master
  #define I2C_DATA PORTC.4
  #define I2C_CLOCK PORTC.3

  'Misc settings
  #define LED PORTB.5
  dir LED Out

  'Main loop
  Do
    'Send start
    I2CStart

    'Request value
    I2CSend 83
    I2CSend 1

    'Read value
    I2CReceive ValueIn

    'Send stop
    I2CStop

    'Turn on LED if received value &gt; 100
    Set LED Off
    If ValueIn &gt; 100 Then Set LED On

    'Delay
    Wait 20 ms

  Loop</pre><p><span class="strong"><strong>Example 2 - Slave Mode:</strong></span></p><p>See the <a class="link" href="_i2c_overview.html" title="I2C Overview">I2C Overview</a> for the
Master mode device to control this Slave mode device.</p><pre class="screen">  ' I2CReceive_Slave.gcb - using a 16F88.
  ' This program receives commands from a GCB Master. This Slave has three LEDs attached.

  ;----- Configuration

  #chip 16F88, 8
  #config MCLR_OFF


  #define I2C_MODE    Slave     ;this is a slave device now
  #define I2C_CLOCK   portb.4    ;SCL on pin 10
  #define I2C_DATA    portb.1    ;SDA on pin 7
  #define I2C_ADDRESS 0x60      ;address of the slave device

  ;----- Variables

  dim addr, reg, value as byte

  ;----- Program
  #define LED0  porta.2          ;pin 1
  #define LED1  porta.3          ;pin 2
  #define LED2  porta.4          ;pin 3

  dir LED0 out                  ;0, 1 and 2 are outputs (LEDs)
  dir LED1 out                  ;0, 1 and 2 are outputs (LEDs)
  dir LED2 out                  ;0, 1 and 2 are outputs (LEDs)

  do
    I2CStart                 ;wait for Start signal
    I2CReceive( addr )         ;then wait for an address

    if I2CMatch  = true then    ;if it matches, proceed

    I2CReceive(regval, ACK)   ;get the register number
    I2CReceive(value, ACK)    ;and its value
    I2CStop                   ;release the bus from this end

    select case regval        ;now turn proper LED on or off
      case 0:
      if value then
        set LED0 on
      else
        set LED0 off
      end if

      case 1:
      if value then
        set LED1 on
      else
        set LED1 off
      end if

      case 2:
      if value then
        set LED2 on
      else
        set LED2 off
      end if
      case else
           ;other register numbers are ignored
    end select
    else
     I2CStop           ;release bus in any event
    end if

  loop</pre><p>Supported in &lt;I2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="i2creceive"></span>I2CReceive

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  I2CReceive data
  I2CReceive data, ack
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers except 12 bit instruction Microchip
PIC microcontrollers (10F, 12F5xx, 16F5xx chips)

<span class="strong">**Explanation:**</span>

The I2CReceive command will send `data` through the I2C connection. If
`ack` is TRUE, or no value is given for `ack`, then `I2CReceive` will
send an ack.

If in master mode, `I2CReceive` will read the data immediately.

If in slave mode, `I2CReceive` will wait for the master to send the data
before reading. When the method `I2CReceive` is used in Slave mode the
global variable `I2CMatch` will be set to true when the received value
is equal to the constant `I2C_ADDRESS`.

<span class="strong">**Example 1 - Master Mode:**</span>

``` screen
  ' I2C Receive - using the ChipIno board, see here for information. ' This program reads an I2C register and LED is set to on if the value  is over 100.
  ' This program will read from address 83, register 1.

  #chip 16F886, 8
  #config MCLRE_ON

  'I2C settings
  #define I2C_MODE Master
  #define I2C_DATA PORTC.4
  #define I2C_CLOCK PORTC.3

  'Misc settings
  #define LED PORTB.5
  dir LED Out

  'Main loop
  Do
    'Send start
    I2CStart

    'Request value
    I2CSend 83
    I2CSend 1

    'Read value
    I2CReceive ValueIn

    'Send stop
    I2CStop

    'Turn on LED if received value > 100
    Set LED Off
    If ValueIn > 100 Then Set LED On

    'Delay
    Wait 20 ms

  Loop
```

<span class="strong">**Example 2 - Slave Mode:**</span>

See the
<a href="i2c_overview" class="link" title="I2C Overview">I2C Overview</a>
for the Master mode device to control this Slave mode device.

``` screen
  ' I2CReceive_Slave.gcb - using a 16F88.
  ' This program receives commands from a GCB Master. This Slave has three LEDs attached.

  ;----- Configuration

  #chip 16F88, 8
  #config MCLR_OFF


  #define I2C_MODE    Slave     ;this is a slave device now
  #define I2C_CLOCK   portb.4    ;SCL on pin 10
  #define I2C_DATA    portb.1    ;SDA on pin 7
  #define I2C_ADDRESS 0x60      ;address of the slave device

  ;----- Variables

  dim addr, reg, value as byte

  ;----- Program
  #define LED0  porta.2          ;pin 1
  #define LED1  porta.3          ;pin 2
  #define LED2  porta.4          ;pin 3

  dir LED0 out                  ;0, 1 and 2 are outputs (LEDs)
  dir LED1 out                  ;0, 1 and 2 are outputs (LEDs)
  dir LED2 out                  ;0, 1 and 2 are outputs (LEDs)

  do
    I2CStart                 ;wait for Start signal
    I2CReceive( addr )         ;then wait for an address

    if I2CMatch  = true then    ;if it matches, proceed

    I2CReceive(regval, ACK)   ;get the register number
    I2CReceive(value, ACK)    ;and its value
    I2CStop                   ;release the bus from this end

    select case regval        ;now turn proper LED on or off
      case 0:
      if value then
        set LED0 on
      else
        set LED0 off
      end if

      case 1:
      if value then
        set LED1 on
      else
        set LED1 off
      end if

      case 2:
      if value then
        set LED2 on
      else
        set LED2 off
      end if
      case else
           ;other register numbers are ignored
    end select
    else
     I2CStop           ;release bus in any event
    end if

  loop
```

Supported in &lt;I2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2CReset</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_software.html" title="I2C Software"><link rel="prev" href="_i2creceive.html" title="I2CReceive"><link rel="next" href="_i2crestart.html" title="I2CRestart"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_i2creset"></a>I2CReset</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    I2CReset</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This will attempt a reset of the I2C by changing the state of the I2C
bus.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen"> ...
	I2CReset
 ...</pre><p>Supported in &lt;I2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="i2creset"></span>I2CReset

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    I2CReset
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers except 12 bit instruction Microchip
PIC microcontrollers (10F, 12F5xx, 16F5xx chips)

<span class="strong">**Explanation:**</span>

This will attempt a reset of the I2C by changing the state of the I2C
bus.

<span class="strong">**Example:**</span>

``` screen
 ...
    I2CReset
 ...
```

Supported in &lt;I2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2CRestart</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_software.html" title="I2C Software"><link rel="prev" href="_i2creset.html" title="I2CReset"><link rel="next" href="_i2csend.html" title="I2CSend"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_i2crestart"></a>I2CRestart</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    I2CRestart</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>If the I2C routines are operating in Master mode, this command will send
a start and restart condition in a single command.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen"> ...
	I2CRESTART
 ....</pre><p>Supported in &lt;I2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="i2crestart"></span>I2CRestart

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    I2CRestart
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers except 12 bit instruction Microchip
PIC microcontrollers (10F, 12F5xx, 16F5xx chips)

<span class="strong">**Explanation:**</span>

If the I2C routines are operating in Master mode, this command will send
a start and restart condition in a single command.

<span class="strong">**Example:**</span>

``` screen
 ...
    I2CRESTART
 ....
```

Supported in &lt;I2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2CSend</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_software.html" title="I2C Software"><link rel="prev" href="_i2crestart.html" title="I2CRestart"><link rel="next" href="_i2cstart.html" title="I2CStart"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_i2csend"></a>I2CSend</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">	I2CSend <span class="emphasis"><em>data</em></span>
	I2CSend <span class="emphasis"><em>data</em></span>, <span class="emphasis"><em>ack</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The I2CSend command will send <span class="emphasis"><em>data</em></span> through the I2C connection. If
<code class="literal"><span class="emphasis"><em>ack</em></span></code> is TRUE, or no value is given for <code class="literal"><span class="emphasis"><em>ack</em></span></code>, then <code class="literal">I2CSend</code> will wait
for an Ack from the receiver before continuing.
If in master mode, <code class="literal">I2CSend</code> will send the data immediately. If in slave
mode, <code class="literal">I2CSend</code> will wait for the master to request the data before
sending.</p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">	' I2CSend - using the ChipIno board, see here for information.
	' This program send commands to a GCB Slave with three LEDs attached.

	#chip 16F886, 8
	#config MCLRE_ON

	'I2C settings
	#define I2C_MODE Master
	#define I2C_DATA PORTC.4
	#define I2C_CLOCK PORTC.3
	#define I2C_BIT_DELAY 20 us
	#define I2C_CLOCK_DELAY 30 us


	#define I2C_ADDRESS 0x60      ;address of the slave device
	;----- Variables

	dim reg as byte

	;----- Program

	do

	  for reg = 0 to 2            ;three LEDs to control
		I2CStart                  ;take control of the bus
		I2CSend I2C_ADDRESS       ;address the device
		if I2CSendState = ACK then
		  I2CSend reg               ;address the particular register
		  I2CSend ON                ;command to turn on LED
		end if
		I2CStop                   ;relinquish the bus
		wait  100 ms
	  next reg
	  wait 1 S                  ;pause to show results

	  for reg = 0 to 2            ;similarly, turn them off
		I2CStart                  ;take control of the bus
		I2CSend I2C_ADDRESS       ;address the device
		if I2CSendState = ACK then
		  I2CSend reg               ;address the particular register
		  I2CSend OFF               ;command to turn off LED
		end if
		I2CStop                   ;relinquish the bus
		wait  100 ms
	  next reg
	  wait 1 S                  ;pause to show results

	loop</pre><p><span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">	'This program will act as an I2C analog to digital converter
	'When data is requested from address 83, registers 0 through
	'3, it will return the value of AN0 through AN3.

	'Chip model
	#chip 16F88, 8

	'I2C settings
	#define I2C_MODE Slave
	#define I2C_CLOCK PORTB.0
	#define I2C_DATA PORTB.1

	#define I2C_DISABLE_INTERRUPTS ON

	'Main loop
	Do
		'Wait for start condition
		I2CStart

		'Get address
		I2CReceive Address
		If Address = 83 Then
			'If address was this device's address, respond
			I2CReceive Register

			OutValue = ReadAD(Register)
			I2CSend OutValue
		End If

		I2CStop

		Wait 5 ms
	Loop</pre><p><span class="strong"><strong>Specific control of I2CSend</strong></span></p><p>The I2CSend method can be controller with command(s) the change the behaviour of method.&nbsp;&nbsp;The behaviour can be changed as a Prefix or Suffix therefore the start or end of the method.</p><p>The two macros ( defined constants) are I2CPreSendMacro and I2CPostSendMacro.&nbsp;&nbsp;The macros must be a single line, with colon delimiters are permitted.</p><p><span class="emphasis"><em>Examples</em></span></p><p>The following defined macros change the start and end behaviour.</p><pre class="screen">		#define I2CPreSendMacro if LabI2CState &lt;&gt; True then exit Sub  'I2CPreSendMacro to ensure GLCD operations only operate within specfic lab
		#define I2CPostSendMacro if LabI2CState = True then MSSP =1   'I2CPostSendMacro to ensure GLCD operations only operate within specfic lab setting a specific variable.</pre><p>The following defined macro changes- the start  behaviour to call an alternative I2CSend method.</p><pre class="screen">		#define I2CPreSendMacro     myI2CSend: exit sub


        sub myI2CSend
            // your i2C handler
        end sub</pre><p>The following defined macros changes- the start  behaviour to call an alternative I2CSend method, then jump to the I2CPostSendMacroLabel which is at the end of I2CSend method.</p><pre class="screen">		#define I2CPreSendMacro         myI2CSend: goto I2CPostSendMacroLabel
        #define I2CPostSendMacro        NOP

        sub myI2CSend
            // your i2C handler
        end sub</pre><p>This will generate the following ASM.&nbsp;&nbsp;The I2CPreSendMacro calls the MYI2CSEND() methhod, then BRAnches to the label I2CPOSTSENDMACROLABEL as the end of the method.</p><pre class="screen">		;Source: i2c.h (339)
		I2CSEND
		;I2CPreSendMacro
			rcall	MYI2CSEND
			bra	I2CPOSTSENDMACROLABEL
		;I2C_CLOCK_LOW                 'begin with SCL=0
			bcf	TRISC,3,ACCESS
			bcf	LATC,3,ACCESS
		...
		lots of ASM
		...
		;wait I2C_BIT_DELAY            'wait the usual bit length
			nop
			nop
		I2CPOSTSENDMACROLABEL
		;I2CPostSendMacro
			nop
			return</pre><p>Supported in &lt;I2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="i2csend"></span>I2CSend

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
 I2CSend data
    I2CSend data, ack
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers except 12 bit instruction Microchip
PIC microcontrollers (10F, 12F5xx, 16F5xx chips)

<span class="strong">**Explanation:**</span>

The I2CSend command will send <span class="emphasis">*data*</span>
through the I2C connection. If `ack` is TRUE, or no value is given for
`ack`, then `I2CSend` will wait for an Ack from the receiver before
continuing. If in master mode, `I2CSend` will send the data immediately.
If in slave mode, `I2CSend` will wait for the master to request the data
before sending.

<span class="strong">**Example 1:**</span>

``` screen
  ' I2CSend - using the ChipIno board, see here for information.
    ' This program send commands to a GCB Slave with three LEDs attached.

    #chip 16F886, 8
    #config MCLRE_ON

    'I2C settings
    #define I2C_MODE Master
    #define I2C_DATA PORTC.4
    #define I2C_CLOCK PORTC.3
    #define I2C_BIT_DELAY 20 us
    #define I2C_CLOCK_DELAY 30 us


    #define I2C_ADDRESS 0x60      ;address of the slave device
    ;----- Variables

    dim reg as byte

    ;----- Program

    do

      for reg = 0 to 2            ;three LEDs to control
        I2CStart                  ;take control of the bus
        I2CSend I2C_ADDRESS       ;address the device
        if I2CSendState = ACK then
          I2CSend reg               ;address the particular register
          I2CSend ON                ;command to turn on LED
        end if
        I2CStop                   ;relinquish the bus
        wait  100 ms
      next reg
      wait 1 S                  ;pause to show results

      for reg = 0 to 2            ;similarly, turn them off
        I2CStart                  ;take control of the bus
        I2CSend I2C_ADDRESS       ;address the device
        if I2CSendState = ACK then
          I2CSend reg               ;address the particular register
          I2CSend OFF               ;command to turn off LED
        end if
        I2CStop                   ;relinquish the bus
        wait  100 ms
      next reg
      wait 1 S                  ;pause to show results

    loop
```

<span class="strong">**Example 2:**</span>

``` screen
    'This program will act as an I2C analog to digital converter
    'When data is requested from address 83, registers 0 through
    '3, it will return the value of AN0 through AN3.

    'Chip model
    #chip 16F88, 8

    'I2C settings
    #define I2C_MODE Slave
    #define I2C_CLOCK PORTB.0
    #define I2C_DATA PORTB.1

    #define I2C_DISABLE_INTERRUPTS ON

    'Main loop
    Do
        'Wait for start condition
        I2CStart

        'Get address
        I2CReceive Address
        If Address = 83 Then
            'If address was this device's address, respond
            I2CReceive Register

            OutValue = ReadAD(Register)
            I2CSend OutValue
        End If

        I2CStop

        Wait 5 ms
    Loop
```

<span class="strong">**Specific control of I2CSend**</span>

The I2CSend method can be controller with command(s) the change the
behaviour of method.  The behaviour can be changed as a Prefix or Suffix
therefore the start or end of the method.

The two macros ( defined constants) are I2CPreSendMacro and
I2CPostSendMacro.  The macros must be a single line, with colon
delimiters are permitted.

<span class="emphasis">*Examples*</span>

The following defined macros change the start and end behaviour.

``` screen
     #define I2CPreSendMacro if LabI2CState <> True then exit Sub  'I2CPreSendMacro to ensure GLCD operations only operate within specfic lab
        #define I2CPostSendMacro if LabI2CState = True then MSSP =1   'I2CPostSendMacro to ensure GLCD operations only operate within specfic lab setting a specific variable.
```

The following defined macro changes- the start behaviour to call an
alternative I2CSend method.

``` screen
     #define I2CPreSendMacro     myI2CSend: exit sub


        sub myI2CSend
            // your i2C handler
        end sub
```

The following defined macros changes- the start behaviour to call an
alternative I2CSend method, then jump to the I2CPostSendMacroLabel which
is at the end of I2CSend method.

``` screen
     #define I2CPreSendMacro         myI2CSend: goto I2CPostSendMacroLabel
        #define I2CPostSendMacro        NOP

        sub myI2CSend
            // your i2C handler
        end sub
```

This will generate the following ASM.  The I2CPreSendMacro calls the
MYI2CSEND() methhod, then BRAnches to the label I2CPOSTSENDMACROLABEL as
the end of the method.

``` screen
      ;Source: i2c.h (339)
        I2CSEND
        ;I2CPreSendMacro
            rcall   MYI2CSEND
            bra I2CPOSTSENDMACROLABEL
        ;I2C_CLOCK_LOW                 'begin with SCL=0
            bcf TRISC,3,ACCESS
            bcf LATC,3,ACCESS
        ...
        lots of ASM
        ...
        ;wait I2C_BIT_DELAY            'wait the usual bit length
            nop
            nop
        I2CPOSTSENDMACROLABEL
        ;I2CPostSendMacro
            nop
            return
```

Supported in &lt;I2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2CStart</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_software.html" title="I2C Software"><link rel="prev" href="_i2csend.html" title="I2CSend"><link rel="next" href="_i2cstartoccurred.html" title="I2CStartoccurred"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_i2cstart"></a>I2CStart</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    I2CStart</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>If the I2C routines are operating in Master mode, this command will send
a start condition. If routines are in Slave mode, it will pause the
program until a start condition is sent by the master. It should be
placed at the start of every I2C transmission.</p><p>If interrupt handling is enabled, this command will disable it.</p><p><span class="strong"><strong>Example:</strong></span></p><p>Please see <a class="link" href="_i2csend.html" title="I2CSend">I2CSend</a> and <a class="link" href="_i2creceive.html" title="I2CReceive">I2CReceive</a>
for an example.</p><p>Supported in &lt;I2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="i2cstart"></span>I2CStart

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    I2CStart
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers except 12 bit instruction Microchip
PIC microcontrollers (10F, 12F5xx, 16F5xx chips)

<span class="strong">**Explanation:**</span>

If the I2C routines are operating in Master mode, this command will send
a start condition. If routines are in Slave mode, it will pause the
program until a start condition is sent by the master. It should be
placed at the start of every I2C transmission.

If interrupt handling is enabled, this command will disable it.

<span class="strong">**Example:**</span>

Please see
<a href="i2csend" class="link" title="I2CSend">I2CSend</a> and
<a href="i2creceive" class="link" title="I2CReceive">I2CReceive</a>
for an example.

Supported in &lt;I2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2CStartoccurred</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_software.html" title="I2C Software"><link rel="prev" href="_i2cstart.html" title="I2CStart"><link rel="next" href="_i2cstop.html" title="I2CStop"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_i2cstartoccurred"></a>I2CStartoccurred</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    I2CStartoccurred</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>If the I2C routine IS operating in Slave mode, this function will check if a start condition has occurred since the last run of this function.
	'Only used in slave mode</p><p><span class="strong"><strong>Example:</strong></span></p><p>Please see <a class="link" href="_i2csend.html" title="I2CSend">I2CSend</a> and <a class="link" href="_i2creceive.html" title="I2CReceive">I2CReceive</a>
for an example.</p><p>Supported in &lt;I2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="i2cstartoccurred"></span>I2CStartoccurred

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    I2CStartoccurred
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers except 12 bit instruction Microchip
PIC microcontrollers (10F, 12F5xx, 16F5xx chips)

<span class="strong">**Explanation:**</span>

If the I2C routine IS operating in Slave mode, this function will check
if a start condition has occurred since the last run of this function.
'Only used in slave mode

<span class="strong">**Example:**</span>

Please see
<a href="i2csend" class="link" title="I2CSend">I2CSend</a> and
<a href="i2creceive" class="link" title="I2CReceive">I2CReceive</a>
for an example.

Supported in &lt;I2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2CStop</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_software.html" title="I2C Software"><link rel="prev" href="_i2cstartoccurred.html" title="I2CStartoccurred"><link rel="next" href="_i2c_twi_hardware_module.html" title="I2C/TWI Hardware Module"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_i2cstop"></a>I2CStop</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    I2CStop</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers except 12 bit instruction microcontrollers (10F,
12F5xx, 16F5xx chips)</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>When in Master mode, this command will send an I2C stop condition, and
re-enable interrupts if <code class="literal">I2CStart</code> disabled them. In Slave mode, it will
re- enable interrupts.</p><p><code class="literal">I2CStop</code> should be called at the end of every I2C transmission.</p><p><span class="strong"><strong>Example:</strong></span></p><p>Please see <a class="link" href="_i2csend.html" title="I2CSend">I2CSend</a> and <a class="link" href="_i2creceive.html" title="I2CReceive">I2CReceive</a>
for an example.</p><p>Supported in &lt;I2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="i2cstop"></span>I2CStop

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    I2CStop
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers except 12 bit instruction
microcontrollers (10F, 12F5xx, 16F5xx chips)

<span class="strong">**Explanation:**</span>

When in Master mode, this command will send an I2C stop condition, and
re-enable interrupts if `I2CStart` disabled them. In Slave mode, it will
re- enable interrupts.

`I2CStop` should be called at the end of every I2C transmission.

<span class="strong">**Example:**</span>

Please see
<a href="i2csend" class="link" title="I2CSend">I2CSend</a> and
<a href="i2creceive" class="link" title="I2CReceive">I2CReceive</a>
for an example.

Supported in &lt;I2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2C Master Hardware</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_programs.html" title="Example Programs"><link rel="prev" href="_midpoint_circle_algorithm.html" title="Midpoint Circle Algorithm"><link rel="next" href="_i2c_slave_hardware.html" title="I2C Slave Hardware"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_i2c_master_hardware"></a>I2C Master Hardware</h3></div></div></div><p><span class="strong"><strong>Explanation:</strong></span></p><p>This program demonstrates how to read and write data from an EEPROM device using the serial protocal called I2C.<br></p><p>This program uses the hardware I2C module within the microcontroller.  If your microcontroller does not have a hardware I2C module then please use the software I2C GCBASIC ibrary.</p><p>This program has three sections.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Read a single byte from the EEPROM</li><li class="listitem">Write and read a page of 64 bytes to and from the EEPROM, and</li><li class="listitem">Finally display the contents of the EEPROM.</li></ol></div><p>This program has an interrupt driven serial handler to capture and manage input from a serial terminal.</p><p><span class="strong"><strong>Demonstration program:</strong></span></p><pre class="screen">    'Change the microcontroller, frequency and config to suit your needs.
    #chip 16F1937, 32
    #config MCLRE_ON

    'Required Library to read and write to an EEPROM
    #include &lt;I2CEEPROM.h&gt;

    ' Define I2C settings - CHANGE PORTS
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA PORTC.4
    #define HI2C_CLOCK PORTC.3
    'I2C pins need to be input for SSP module for Microchip PIC devices.
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in
    'I2C MASTER MODE
    HI2CMode Master

    ' THIS CONFIG OF THE SERIAL PORT WORKS WITH max232 THEN TO PC
    ' USART settings
    #define USART_BAUD_RATE 9600
    Dir PORTc.6 Out
    Dir PORTc.7 In
    #define USART_DELAY OFF
    #define USART_TX_BLOCKING
    wait 500 ms

    'Create a Serial Interrupt Handler
    On Interrupt UsartRX1Ready Call readUSART

    ' Constants etc required for the serial Buffer Ring
    #define BUFFER_SIZE 32
    #define bkbhit (next_in &lt;&gt; next_out)
    ' Required Variables for the serial Buffer Ring
    Dim buffer(BUFFER_SIZE)
    Dim next_in as byte: next_in = 1
    Dim next_out as byte: next_out = 1


    Dim syncbyte as Byte
    wait 125 ms

    ' Read ONE byte from the EEPROM
    dim DeviceID as byte
    dim EepromAddress, syscounter as word
    #define EEpromDevice 0xA0

    'Master Main Loop
    location = 0
    'Define our array
    dim outarray(64), inarray(64)

    do
        HSerPrintCRLF 2
        HSerPrint "Commence Array Write and Read"
        'Populate the array
        for tt = 1 to 64
            outarray(tt) = tt
        next

        'Library write call is: eeprom_wr_array(device_number, page_size, address, array_name, number_of_bytes)
        eeprom_wr_array(EEpromDevice, 64, location, outarray, 64)


        'Library read call is: eeprom_rd_array(device_number, address, array_name, number_of_bytes)
        eeprom_rd_array(EEpromDevice, location, inarray, 64)

        'Show results of the read of the I2C EEPROM
        HSerPrintCRLF 2
        for tt = 1 to 64

            if outarray(tt) &lt;&gt; inarray(tt) then
               Hserprint "!"
               HSerPrint inarray(tt)
            else
               HSerPrint inarray(tt)
            end if
            HSerPrint ","
        next

        HSerPrintCRLF 2
        HSerPrint "Commence Write and Read a single byte":HSerPrintCRLF
        HSerPrint "Read value should be "
        HSerPrint  str(location):HSerPrintCRLF
        HSerPrint "Read = "
        'Use library to write and read from the I2C EEPROM
        eeprom_wr_byte (EEpromDevice, location, location)
        eeprom_rd_byte (EEpromDevice, location, bbyte )

        HSerPrint bbyte
        location++
        HSerPrintCRLF 2

        'Show the connnected I2C devices on the Serial terminal.
        HI2CDeviceSearch
        HSerPrint "Commence Dump of the EEPROM"
        validateEEPROM
    Loop
    End


    'Show the attached I2C devices
    sub HI2CDeviceSearch
        'Assumes serial is operational
        HSerPrintCRLF
        HSerPrint "I2C Device Search"
        HSerPrintCRLF 2
        for deviceID = 0 to 255
        HI2CStart
        HI2CSend ( deviceID )
        if HI2CAckPollState = false then
            HSerPrint   "ID: 0x"
            HSerPrint   hex(deviceID)
            HSerSend 9
            testid = deviceID | 1
            select case testid
                 case 49
                      Hserprint "DS2482_1Channel_1Wire Master"
                 case 65
                      Hserprint "Serial_Expander_Device"
                 Case 73
                       Hserprint "Serial_Expander_Device"
                 case 161
                      Hserprint "EEProm_Device_Device"
                 case 163
                      Hserprint "EEProm_Device_Device"
                 case 165
                      Hserprint "EEProm_Device_Device"
                 case 167
                      Hserprint "EEProm_Device_Device"
                 case 169
                      Hserprint "EEProm_Device_Device"
                 case 171
                      Hserprint "EEProm_Device_Device"
                 case 173
                      Hserprint "EEProm_Device_Device"
                 case 175
                      Hserprint "EEProm_Device_Device"
                 case 209
                      Hserprint "DS1307_RTC_Device"
                 case 249
                      Hserprint "FRAM_Device"
                 case else
                      Hserprint "Unknown_Device"
            end select
            HI2CSend ( 0 )
            HSerPrintCRLF
        end if
        HI2CStop
        next
        HSerPrint   "End of Device Search"
        HSerPrintCRLF 2
    end sub

    'Validation EEPROOM code
    sub validateEEPROM
        EepromAddress = 0
        HSerPrintCRLF 2
        HSerPrint "Hx"
        HSerPrint hex(EepromAddress_h)
        HSerPrint hex(EepromAddress)
        HSerPrint " "

        for EepromAddress = 0 to 0xffff
            'Read from EEPROM using a library function
            eeprom_rd_byte EEPromDevice, EepromAddress, objType

            HSerPrint hex(objType)+" "
            if ((EepromAddress+1) % 8 ) = 0 then
                HSerPrintCRLF
                HSerPrint "Hx"
                syscounter = EepromAddress + 1
                HSerPrint hex(syscounter_h)
                HSerPrint hex(syscounter)
                HSerPrint " "
            end if
            'Has serial data been received
            if bkbhit then
                syschar = bgetc
                select case syschar
                    case 32
                        do while bgetc = 32
                        loop
                    case else
                        HSerPrintCRLF
                        HSerPrint "Done"
                        exit sub
                end select
            end if
        next
        HSerPrintCRLF
        HSerPrint "Done"
    end Sub


    ' Start of Serial Support functions
    ' Required to read the serial port
    ' Assumes serial port has been initialised
    Sub readUSART
        buffer(next_in) = HSerReceive
        temppnt = next_in
        next_in = ( next_in + 1 ) % BUFFER_SIZE
        if ( next_in = next_out ) then  ' buffer is full!!
            next_in = temppnt
        end if
    End Sub

    ' Serial Support functions
    ' Get characters from the serial port
    function bgetc
        wait while !(bkbhit)
        bgetc = buffer(next_out)
        next_out=(next_out+1) % BUFFER_SIZE
    end Function</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="i2c_master_hardware"></span>I2C Master Hardware

</div>

</div>

</div>

<span class="strong">**Explanation:**</span>

This program demonstrates how to read and write data from an EEPROM
device using the serial protocal called I2C.  

This program uses the hardware I2C module within the microcontroller. If
your microcontroller does not have a hardware I2C module then please use
the software I2C GCBASIC ibrary.

This program has three sections.

<div class="orderedlist">

1.  Read a single byte from the EEPROM
2.  Write and read a page of 64 bytes to and from the EEPROM, and
3.  Finally display the contents of the EEPROM.

</div>

This program has an interrupt driven serial handler to capture and
manage input from a serial terminal.

<span class="strong">**Demonstration program:**</span>

``` screen
    'Change the microcontroller, frequency and config to suit your needs.
    #chip 16F1937, 32
    #config MCLRE_ON

    'Required Library to read and write to an EEPROM
    #include <I2CEEPROM.h>

    ' Define I2C settings - CHANGE PORTS
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA PORTC.4
    #define HI2C_CLOCK PORTC.3
    'I2C pins need to be input for SSP module for Microchip PIC devices.
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in
    'I2C MASTER MODE
    HI2CMode Master

    ' THIS CONFIG OF THE SERIAL PORT WORKS WITH max232 THEN TO PC
    ' USART settings
    #define USART_BAUD_RATE 9600
    Dir PORTc.6 Out
    Dir PORTc.7 In
    #define USART_DELAY OFF
    #define USART_TX_BLOCKING
    wait 500 ms

    'Create a Serial Interrupt Handler
    On Interrupt UsartRX1Ready Call readUSART

    ' Constants etc required for the serial Buffer Ring
    #define BUFFER_SIZE 32
    #define bkbhit (next_in <> next_out)
    ' Required Variables for the serial Buffer Ring
    Dim buffer(BUFFER_SIZE)
    Dim next_in as byte: next_in = 1
    Dim next_out as byte: next_out = 1


    Dim syncbyte as Byte
    wait 125 ms

    ' Read ONE byte from the EEPROM
    dim DeviceID as byte
    dim EepromAddress, syscounter as word
    #define EEpromDevice 0xA0

    'Master Main Loop
    location = 0
    'Define our array
    dim outarray(64), inarray(64)

    do
        HSerPrintCRLF 2
        HSerPrint "Commence Array Write and Read"
        'Populate the array
        for tt = 1 to 64
            outarray(tt) = tt
        next

        'Library write call is: eeprom_wr_array(device_number, page_size, address, array_name, number_of_bytes)
        eeprom_wr_array(EEpromDevice, 64, location, outarray, 64)


        'Library read call is: eeprom_rd_array(device_number, address, array_name, number_of_bytes)
        eeprom_rd_array(EEpromDevice, location, inarray, 64)

        'Show results of the read of the I2C EEPROM
        HSerPrintCRLF 2
        for tt = 1 to 64

            if outarray(tt) <> inarray(tt) then
               Hserprint "!"
               HSerPrint inarray(tt)
            else
               HSerPrint inarray(tt)
            end if
            HSerPrint ","
        next

        HSerPrintCRLF 2
        HSerPrint "Commence Write and Read a single byte":HSerPrintCRLF
        HSerPrint "Read value should be "
        HSerPrint  str(location):HSerPrintCRLF
        HSerPrint "Read = "
        'Use library to write and read from the I2C EEPROM
        eeprom_wr_byte (EEpromDevice, location, location)
        eeprom_rd_byte (EEpromDevice, location, bbyte )

        HSerPrint bbyte
        location++
        HSerPrintCRLF 2

        'Show the connnected I2C devices on the Serial terminal.
        HI2CDeviceSearch
        HSerPrint "Commence Dump of the EEPROM"
        validateEEPROM
    Loop
    End


    'Show the attached I2C devices
    sub HI2CDeviceSearch
        'Assumes serial is operational
        HSerPrintCRLF
        HSerPrint "I2C Device Search"
        HSerPrintCRLF 2
        for deviceID = 0 to 255
        HI2CStart
        HI2CSend ( deviceID )
        if HI2CAckPollState = false then
            HSerPrint   "ID: 0x"
            HSerPrint   hex(deviceID)
            HSerSend 9
            testid = deviceID | 1
            select case testid
                 case 49
                      Hserprint "DS2482_1Channel_1Wire Master"
                 case 65
                      Hserprint "Serial_Expander_Device"
                 Case 73
                       Hserprint "Serial_Expander_Device"
                 case 161
                      Hserprint "EEProm_Device_Device"
                 case 163
                      Hserprint "EEProm_Device_Device"
                 case 165
                      Hserprint "EEProm_Device_Device"
                 case 167
                      Hserprint "EEProm_Device_Device"
                 case 169
                      Hserprint "EEProm_Device_Device"
                 case 171
                      Hserprint "EEProm_Device_Device"
                 case 173
                      Hserprint "EEProm_Device_Device"
                 case 175
                      Hserprint "EEProm_Device_Device"
                 case 209
                      Hserprint "DS1307_RTC_Device"
                 case 249
                      Hserprint "FRAM_Device"
                 case else
                      Hserprint "Unknown_Device"
            end select
            HI2CSend ( 0 )
            HSerPrintCRLF
        end if
        HI2CStop
        next
        HSerPrint   "End of Device Search"
        HSerPrintCRLF 2
    end sub

    'Validation EEPROOM code
    sub validateEEPROM
        EepromAddress = 0
        HSerPrintCRLF 2
        HSerPrint "Hx"
        HSerPrint hex(EepromAddress_h)
        HSerPrint hex(EepromAddress)
        HSerPrint " "

        for EepromAddress = 0 to 0xffff
            'Read from EEPROM using a library function
            eeprom_rd_byte EEPromDevice, EepromAddress, objType

            HSerPrint hex(objType)+" "
            if ((EepromAddress+1) % 8 ) = 0 then
                HSerPrintCRLF
                HSerPrint "Hx"
                syscounter = EepromAddress + 1
                HSerPrint hex(syscounter_h)
                HSerPrint hex(syscounter)
                HSerPrint " "
            end if
            'Has serial data been received
            if bkbhit then
                syschar = bgetc
                select case syschar
                    case 32
                        do while bgetc = 32
                        loop
                    case else
                        HSerPrintCRLF
                        HSerPrint "Done"
                        exit sub
                end select
            end if
        next
        HSerPrintCRLF
        HSerPrint "Done"
    end Sub


    ' Start of Serial Support functions
    ' Required to read the serial port
    ' Assumes serial port has been initialised
    Sub readUSART
        buffer(next_in) = HSerReceive
        temppnt = next_in
        next_in = ( next_in + 1 ) % BUFFER_SIZE
        if ( next_in = next_out ) then  ' buffer is full!!
            next_in = temppnt
        end if
    End Sub

    ' Serial Support functions
    ' Get characters from the serial port
    function bgetc
        wait while !(bkbhit)
        bgetc = buffer(next_out)
        next_out=(next_out+1) % BUFFER_SIZE
    end Function
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2C Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_software.html" title="I2C Software"><link rel="prev" href="_i2c_software.html" title="I2C Software"><link rel="next" href="_i2cackpollstate.html" title="I2CAckPollState"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_i2c_overview"></a>I2C Overview</h4></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>These software routines allow GCBASIC programs to send and receive I2C
messages. They can be configured to act as master or slave, and the
speed can also be altered.</p><p>No hardware I2C module is required for these routines - all
communication is handled in software. However, these routines will not
work on 12-bit instruction Microchip PIC microcontrollers (10F, 12F5xx and 16F5xx chips).</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>These constants control the setup of the software I2C routines:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>I2C_MODE</p></td><td align="left" valign="top"><p>Mode of I2C routines (Master or Slave)</p></td><td align="left" valign="top"><p>Master</p></td></tr><tr><td align="left" valign="top"><p>I2C_DATA</p></td><td align="left" valign="top"><p>Pin on microcontroller connected to I2C data</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p>I2C_CLOCK</p></td><td align="left" valign="top"><p>Pin on microcontroller connected to I2C clock</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p>I2C_BIT_DELAY</p></td><td align="left" valign="top"><p>Time for a bit (used for acknowledge detection)</p></td><td align="left" valign="top"><p>2 us</p></td></tr><tr><td align="left" valign="top"><p>I2C_CLOCK_DELAY</p></td><td align="left" valign="top"><p>Time for clock pulse to remain high</p></td><td align="left" valign="top"><p>1 us</p></td></tr><tr><td align="left" valign="top"><p>I2C_END_DELAY</p></td><td align="left" valign="top"><p>Time between clock pulses</p></td><td align="left" valign="top"><p>1 us</p></td></tr><tr><td align="left" valign="top"><p>I2C_USE_TIMEOUT</p></td><td align="left" valign="top"><p>Set to true if the I2C routines should stop waiting for the
I2c bus - the routine will exit if a timeout occurs.
Should be used when you need to prevent system lockups on the I2C bus.
</p><p>Supports both software I2C master and slave mode.
</p><p>Will return the variable <code class="literal">I2CAck = FALSE</code> when a timeout has occurred.</p></td><td align="left" valign="top"><p>Not Set</p></td></tr><tr><td align="left" valign="top"><p>I2C_DISABLE_INTERRUPTS</p></td><td align="left" valign="top"><p>Disable interrupts during I2C routines. Important when an i2C clock is
part of your solution</p></td><td align="left" valign="top"><p>Not defined.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example:</strong></span>
This example examines the IC2 devices and displays on a terminal.
This code will require adaption but the code shows an approach to discover the IC2 devices.</p><pre class="screen">  ' I2C Overview - using the ChipIno board, see here for information
  #chip 16F886, 8
  #config MCLRE_ON

  ' Define I2C settings
  #define I2C_MODE Master
  #define I2C_DATA PORTC.4
  #define I2C_CLOCK PORTC.3
  #define I2C_DISABLE_INTERRUPTS ON

  'USART/SERIAL PORT via a MAX232 TO PC Terminal
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING

  Dir PORTc.6 Out
  #define USART_DELAY 0 ms

  HSerPrintCRLF 2
  HSerPrint "I2C Discover using the ChipIno"
  HSerPrintCRLF 2

  HSerPrint "Started: "
  HSerPrint "Searching I2C address space: v0.85"
  HSerPrintCRLF

  wait 100 ms
  dim DeviceID as byte
  for DeviceID = 0 to 255
    I2CStart
    I2CSend ( deviceID )
    I2CSend ( 0 )
    I2CSend ( 0 )
    i2cstop

    if I2CSendState = True  then

      HSerPrint   "__"
      HSerPrint   "ID: 0x"
      HSerPrint   hex(deviceID)
      HSerPrint   " (d"
      HSerPrint   Str(deviceID)
      HSerPrint   ")"
      HSerPrintCRLF
    end if
  next
  HSerPrint   "End of Device Search": HSerPrintCRLF 2
  End</pre><p>Supported in &lt;I2C.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="i2c_overview"></span>I2C Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

These software routines allow GCBASIC programs to send and receive I2C
messages. They can be configured to act as master or slave, and the
speed can also be altered.

No hardware I2C module is required for these routines - all
communication is handled in software. However, these routines will not
work on 12-bit instruction Microchip PIC microcontrollers (10F, 12F5xx
and 16F5xx chips).

<span class="strong">**Relevant Constants:**</span>

These constants control the setup of the software I2C routines:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constant</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Default Value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>I2C_MODE</p></td>
<td style="text-align: left;"><p>Mode of I2C routines (Master or Slave)</p></td>
<td style="text-align: left;"><p>Master</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>I2C_DATA</p></td>
<td style="text-align: left;"><p>Pin on microcontroller connected to I2C data</p></td>
<td style="text-align: left;"><p>N/A</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>I2C_CLOCK</p></td>
<td style="text-align: left;"><p>Pin on microcontroller connected to I2C clock</p></td>
<td style="text-align: left;"><p>N/A</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>I2C_BIT_DELAY</p></td>
<td style="text-align: left;"><p>Time for a bit (used for acknowledge detection)</p></td>
<td style="text-align: left;"><p>2 us</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>I2C_CLOCK_DELAY</p></td>
<td style="text-align: left;"><p>Time for clock pulse to remain high</p></td>
<td style="text-align: left;"><p>1 us</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>I2C_END_DELAY</p></td>
<td style="text-align: left;"><p>Time between clock pulses</p></td>
<td style="text-align: left;"><p>1 us</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>I2C_USE_TIMEOUT</p></td>
<td style="text-align: left;"><p>Set to true if the I2C routines should stop waiting for the I2c bus - the routine will exit if a timeout occurs. Should be used when you need to prevent system lockups on the I2C bus.</p>
<p>Supports both software I2C master and slave mode.</p>
<p>Will return the variable <code class="literal">I2CAck = FALSE</code> when a timeout has occurred.</p></td>
<td style="text-align: left;"><p>Not Set</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>I2C_DISABLE_INTERRUPTS</p></td>
<td style="text-align: left;"><p>Disable interrupts during I2C routines. Important when an i2C clock is part of your solution</p></td>
<td style="text-align: left;"><p>Not defined.</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Example:**</span> This example examines the IC2
devices and displays on a terminal. This code will require adaption but
the code shows an approach to discover the IC2 devices.

``` screen
  ' I2C Overview - using the ChipIno board, see here for information
  #chip 16F886, 8
  #config MCLRE_ON

  ' Define I2C settings
  #define I2C_MODE Master
  #define I2C_DATA PORTC.4
  #define I2C_CLOCK PORTC.3
  #define I2C_DISABLE_INTERRUPTS ON

  'USART/SERIAL PORT via a MAX232 TO PC Terminal
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING

  Dir PORTc.6 Out
  #define USART_DELAY 0 ms

  HSerPrintCRLF 2
  HSerPrint "I2C Discover using the ChipIno"
  HSerPrintCRLF 2

  HSerPrint "Started: "
  HSerPrint "Searching I2C address space: v0.85"
  HSerPrintCRLF

  wait 100 ms
  dim DeviceID as byte
  for DeviceID = 0 to 255
    I2CStart
    I2CSend ( deviceID )
    I2CSend ( 0 )
    I2CSend ( 0 )
    i2cstop

    if I2CSendState = True  then

      HSerPrint   "_"
      HSerPrint   "ID: 0x"
      HSerPrint   hex(deviceID)
      HSerPrint   " (d"
      HSerPrint   Str(deviceID)
      HSerPrint   ")"
      HSerPrintCRLF
    end if
  next
  HSerPrint   "End of Device Search": HSerPrintCRLF 2
  End
```

Supported in &lt;I2C.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2C Slave Hardware</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_programs.html" title="Example Programs"><link rel="prev" href="_i2c_master_hardware.html" title="I2C Master Hardware"><link rel="next" href="_rgb_led_control.html" title="RGB LED Control"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_i2c_slave_hardware"></a>I2C Slave Hardware</h3></div></div></div><p><span class="strong"><strong>Explanation:</strong></span></p><p>This program demonstrates how to control and display using a LCD the code for the keypad.</p><p>This program can be adapted. This program uses the hardware I2C module within the microcontroller.  If your microcontroller does not have a hardware I2C module then please use the software I2C GCBASIC library for most microcontrollers.</p><p>This program also has an interrupt driven I2C handler to manage the I2C from the Start event.</p><p><span class="strong"><strong>Demonstration program:</strong></span></p><pre class="screen">    'Code for the keypad and LCD Microchip PIC microcontroller on the Microlab board v2
    'microcontroller is responsible for:
    ' - Reading keypad
    ' - Displaying data on LCD
    ' - communication with main Microchip PIC microcontroller via I2C
    ' - providing 5 keypad lines to main Microchip PIC microcontroller (for compatibility)
    ' - receiving remote control signals for button and keypad

    'This code has support for two keypad layouts. This is one possible layout:
    '0123
    '4567
    '89AB
    'CDEF
    'And this is the other possible layout:
    '123A
    '456E
    '789D
    'A0BC
    'Select the keypad layout by uncommenting one of these lines:
    '#define KEYPAD_KEYMAP KeypadMap0123
    #define KEYPAD_KEYMAP KeypadMap123F

    'Chip and config
    #chip 16F882, 8

    'Ports connected to keypad
    'Column ports need pullups, hence columns are on PORTB for built in weak pullups
    #define KEYPAD_COL_1 PORTB.4
    #define KEYPAD_COL_2 PORTB.5
    #define KEYPAD_COL_3 PORTB.6
    #define KEYPAD_COL_4 PORTB.7
    #define KEYPAD_ROW_1 PORTA.4
    #define KEYPAD_ROW_2 PORTA.3
    #define KEYPAD_ROW_3 PORTA.2
    #define KEYPAD_ROW_4 PORTA.1

    'Ports connected to LCD
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTA.7
    #define LCD_RS PORTA.6
    #define LCD_Enable PORTA.5
    #define LCD_DB4 PORTA.4
    #define LCD_DB5 PORTA.3
    #define LCD_DB6 PORTA.2
    #define LCD_DB7 PORTA.1
    #define BACKLIGHT PORTA.0

    'Button port (for remote control)
    #define BUTTON PORTB.0

    'Keypad ports connected to main Microchip PIC microcontroller
    'These are disabled when KeyoutDisabled = true
    #define KEYOUT_A PORTC.5
    #define KEYOUT_B PORTC.2
    #define KEYOUT_C PORTC.1
    #define KEYOUT_D PORTC.0
    #define KEYOUT_DA PORTB.1

    'I2C ports
    #define I2C_DATA PORTC.4
    #define I2C_CLOCK PORTC.3

    'RS232/USART settings
    'To do if/when remote support needed

    'Initialise
    Dir KEYOUT_A Out
    Dir KEYOUT_B Out
    Dir KEYOUT_C Out
    Dir KEYOUT_D Out
    Dir KEYOUT_DA Out

    Dir BACKLIGHT Out
    Dir BUTTON In 'Is an output, turn off by switching pin to Hi-Z

    'Initialise I2C Slave
    'I2C pins need to be input for SSP module
    Dir I2C_DATA In
    Dir I2C_CLOCK In
    HI2CMode Slave
    HI2CSetAddress 128

    'Buffer for incoming I2C messages
    'Each message takes 4 bytes
    Dim I2CBuffer(10)
    BufferSize = 0
    OldBufferSize = 0

    'Set up interrupt to process I2C
    On Interrupt SSP1Ready Call I2CHandler

    'Enable weak pullups on B4-7 (keypad col pins)
    NOT_RBPU = 0
    WPUB = b'11110000'

    'Key buffers
    '255 indicates no key, other value gives currently pressed key
    RemoteKey = 255
    OutKey = 255
    KeyoutDisabled = False 'False if KEYOUT lines used to send key

    'Main loop
    Do

        'Read keypad, send value
        CheckPressedKeys
        SendKeys

        'Check for I2C messages
        ProcessI2C

    Loop

    'This keymap table is for this arrangement:
    '0123
    '4567
    '89AB
    'CDEF
    Table KeypadMap0123
        3
        7
        11
        15
        2
        6
        10
        14
        1
        5
        9
        13
        0
        4
        8
        12
    End Table

    'This keymap table is for this arrangement:
    '123F
    '456E
    '789D
    'A0BC
    Table KeypadMap123F
        15
        14
        13
        12
        3
        6
        9
        11
        2
        5
        8
        0
        1
        4
        7
        10
    End Table

    Sub CheckPressedKeys
        'Subroutine to:
        ' - Read keypad
        ' - Check remote keypress
        ' - Decide which key to output

        'Read keypad
        If RemoteKey &lt;&gt; 255 Then
            OutKey = RemoteKey
        Else
            EnableKeypad
            OutKey = KeypadData

        End If

    End Sub

    Sub EnableKeypad
        'Disable LCD so that keypad can be activated
        Set LCD_RW Off 'Write mode, don't let LCD write

        'Re-init keypad
        InitKeypad

    End Sub

    Sub I2CHandler
        'Handle I2C interrupt
        'SSPIF doesn't trigger for stop condition, only start!

        'If buffer full flag set, read

        Do While HI2CHasData
            HI2CReceive DataIn

            'Sending code
            If BufferSize = 0 Then
                LastI2CWasRead = False
                'Detect read address
                If DataIn = 129 Then
                    LastI2CWasRead = True

                    HI2CSend OutKey

                    KeyoutDisabled = True
                    Dir KEYOUT_A In
                    Dir KEYOUT_B In
                    Dir KEYOUT_C In
                    Dir KEYOUT_D In
                    Dir KEYOUT_DA In

                    Exit Sub
                End If
            End If

            If BufferSize &lt; 10 Then I2CBuffer(BufferSize) = DataIn
            BufferSize += 1
        Loop

    End Sub

    Sub SendKeys

        'Don't run if not using KEYOUT lines
        If KeyoutDisabled Then Exit Sub

        'Send pressed keys
        If OutKey &lt;&gt; 255 Then
            'If there is a key pressed, set output lines
            If OutKey.0 Then
                KEYOUT_A = 1
            Else
                KEYOUT_A = 0
            End If
            If OutKey.1 Then
                KEYOUT_B = 1
            Else
                KEYOUT_B = 0
            End If
            If OutKey.2 Then
                KEYOUT_C = 1
            Else
                KEYOUT_C = 0
            End If
            If OutKey.3 Then
                KEYOUT_D = 1
            Else
                KEYOUT_D = 0
            End If

            KEYOUT_DA = 1
        Else
            'If no key pressed, clear data available line to main Microchip PIC microcontroller
            KEYOUT_DA = 0
        End If

    End Sub

    Sub ProcessI2C

        If HI2CStopped Then
            IntOff

            If LastI2CWasRead Then BufferSize = 0

            If BufferSize &lt;&gt; 0 Then
                OldBufferSize = BufferSize
                BufferSize = 0
            End If
            IntOn
        End If

        If OldBufferSize &lt;&gt; 0 Then

            CmdControl = I2CBuffer(1)

            'Set backlight
            If CmdControl.6 = On Then
                Set BACKLIGHT On
            Else
                Set BACKLIGHT Off
            End If

            'Set R/S bit
            LCD_RS = CmdControl.4

            'Send bytes to LCD
            LCDDataBytes = CmdControl And 0x0F
            If LCDDataBytes &gt; 0 Then
                For CurrSendByte = 1 To LCDDataBytes
                    LCDWriteByte I2CBuffer(LCDDataBytes + 1)
                Next
            End If
            'LCDWriteByte I2CBuffer(2)

            OldBufferSize = 0
        End If

    End Sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="i2c_slave_hardware"></span>I2C Slave Hardware

</div>

</div>

</div>

<span class="strong">**Explanation:**</span>

This program demonstrates how to control and display using a LCD the
code for the keypad.

This program can be adapted. This program uses the hardware I2C module
within the microcontroller. If your microcontroller does not have a
hardware I2C module then please use the software I2C GCBASIC library for
most microcontrollers.

This program also has an interrupt driven I2C handler to manage the I2C
from the Start event.

<span class="strong">**Demonstration program:**</span>

``` screen
    'Code for the keypad and LCD Microchip PIC microcontroller on the Microlab board v2
    'microcontroller is responsible for:
    ' - Reading keypad
    ' - Displaying data on LCD
    ' - communication with main Microchip PIC microcontroller via I2C
    ' - providing 5 keypad lines to main Microchip PIC microcontroller (for compatibility)
    ' - receiving remote control signals for button and keypad

    'This code has support for two keypad layouts. This is one possible layout:
    '0123
    '4567
    '89AB
    'CDEF
    'And this is the other possible layout:
    '123A
    '456E
    '789D
    'A0BC
    'Select the keypad layout by uncommenting one of these lines:
    '#define KEYPAD_KEYMAP KeypadMap0123
    #define KEYPAD_KEYMAP KeypadMap123F

    'Chip and config
    #chip 16F882, 8

    'Ports connected to keypad
    'Column ports need pullups, hence columns are on PORTB for built in weak pullups
    #define KEYPAD_COL_1 PORTB.4
    #define KEYPAD_COL_2 PORTB.5
    #define KEYPAD_COL_3 PORTB.6
    #define KEYPAD_COL_4 PORTB.7
    #define KEYPAD_ROW_1 PORTA.4
    #define KEYPAD_ROW_2 PORTA.3
    #define KEYPAD_ROW_3 PORTA.2
    #define KEYPAD_ROW_4 PORTA.1

    'Ports connected to LCD
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTA.7
    #define LCD_RS PORTA.6
    #define LCD_Enable PORTA.5
    #define LCD_DB4 PORTA.4
    #define LCD_DB5 PORTA.3
    #define LCD_DB6 PORTA.2
    #define LCD_DB7 PORTA.1
    #define BACKLIGHT PORTA.0

    'Button port (for remote control)
    #define BUTTON PORTB.0

    'Keypad ports connected to main Microchip PIC microcontroller
    'These are disabled when KeyoutDisabled = true
    #define KEYOUT_A PORTC.5
    #define KEYOUT_B PORTC.2
    #define KEYOUT_C PORTC.1
    #define KEYOUT_D PORTC.0
    #define KEYOUT_DA PORTB.1

    'I2C ports
    #define I2C_DATA PORTC.4
    #define I2C_CLOCK PORTC.3

    'RS232/USART settings
    'To do if/when remote support needed

    'Initialise
    Dir KEYOUT_A Out
    Dir KEYOUT_B Out
    Dir KEYOUT_C Out
    Dir KEYOUT_D Out
    Dir KEYOUT_DA Out

    Dir BACKLIGHT Out
    Dir BUTTON In 'Is an output, turn off by switching pin to Hi-Z

    'Initialise I2C Slave
    'I2C pins need to be input for SSP module
    Dir I2C_DATA In
    Dir I2C_CLOCK In
    HI2CMode Slave
    HI2CSetAddress 128

    'Buffer for incoming I2C messages
    'Each message takes 4 bytes
    Dim I2CBuffer(10)
    BufferSize = 0
    OldBufferSize = 0

    'Set up interrupt to process I2C
    On Interrupt SSP1Ready Call I2CHandler

    'Enable weak pullups on B4-7 (keypad col pins)
    NOT_RBPU = 0
    WPUB = b'11110000'

    'Key buffers
    '255 indicates no key, other value gives currently pressed key
    RemoteKey = 255
    OutKey = 255
    KeyoutDisabled = False 'False if KEYOUT lines used to send key

    'Main loop
    Do

        'Read keypad, send value
        CheckPressedKeys
        SendKeys

        'Check for I2C messages
        ProcessI2C

    Loop

    'This keymap table is for this arrangement:
    '0123
    '4567
    '89AB
    'CDEF
    Table KeypadMap0123
        3
        7
        11
        15
        2
        6
        10
        14
        1
        5
        9
        13
        0
        4
        8
        12
    End Table

    'This keymap table is for this arrangement:
    '123F
    '456E
    '789D
    'A0BC
    Table KeypadMap123F
        15
        14
        13
        12
        3
        6
        9
        11
        2
        5
        8
        0
        1
        4
        7
        10
    End Table

    Sub CheckPressedKeys
        'Subroutine to:
        ' - Read keypad
        ' - Check remote keypress
        ' - Decide which key to output

        'Read keypad
        If RemoteKey <> 255 Then
            OutKey = RemoteKey
        Else
            EnableKeypad
            OutKey = KeypadData

        End If

    End Sub

    Sub EnableKeypad
        'Disable LCD so that keypad can be activated
        Set LCD_RW Off 'Write mode, don't let LCD write

        'Re-init keypad
        InitKeypad

    End Sub

    Sub I2CHandler
        'Handle I2C interrupt
        'SSPIF doesn't trigger for stop condition, only start!

        'If buffer full flag set, read

        Do While HI2CHasData
            HI2CReceive DataIn

            'Sending code
            If BufferSize = 0 Then
                LastI2CWasRead = False
                'Detect read address
                If DataIn = 129 Then
                    LastI2CWasRead = True

                    HI2CSend OutKey

                    KeyoutDisabled = True
                    Dir KEYOUT_A In
                    Dir KEYOUT_B In
                    Dir KEYOUT_C In
                    Dir KEYOUT_D In
                    Dir KEYOUT_DA In

                    Exit Sub
                End If
            End If

            If BufferSize < 10 Then I2CBuffer(BufferSize) = DataIn
            BufferSize += 1
        Loop

    End Sub

    Sub SendKeys

        'Don't run if not using KEYOUT lines
        If KeyoutDisabled Then Exit Sub

        'Send pressed keys
        If OutKey <> 255 Then
            'If there is a key pressed, set output lines
            If OutKey.0 Then
                KEYOUT_A = 1
            Else
                KEYOUT_A = 0
            End If
            If OutKey.1 Then
                KEYOUT_B = 1
            Else
                KEYOUT_B = 0
            End If
            If OutKey.2 Then
                KEYOUT_C = 1
            Else
                KEYOUT_C = 0
            End If
            If OutKey.3 Then
                KEYOUT_D = 1
            Else
                KEYOUT_D = 0
            End If

            KEYOUT_DA = 1
        Else
            'If no key pressed, clear data available line to main Microchip PIC microcontroller
            KEYOUT_DA = 0
        End If

    End Sub

    Sub ProcessI2C

        If HI2CStopped Then
            IntOff

            If LastI2CWasRead Then BufferSize = 0

            If BufferSize <> 0 Then
                OldBufferSize = BufferSize
                BufferSize = 0
            End If
            IntOn
        End If

        If OldBufferSize <> 0 Then

            CmdControl = I2CBuffer(1)

            'Set backlight
            If CmdControl.6 = On Then
                Set BACKLIGHT On
            Else
                Set BACKLIGHT Off
            End If

            'Set R/S bit
            LCD_RS = CmdControl.4

            'Send bytes to LCD
            LCDDataBytes = CmdControl And 0x0F
            If LCDDataBytes > 0 Then
                For CurrSendByte = 1 To LCDDataBytes
                    LCDWriteByte I2CBuffer(LCDDataBytes + 1)
                Next
            End If
            'LCDWriteByte I2CBuffer(2)

            OldBufferSize = 0
        End If

    End Sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2C Software</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_fasthwspitransfer.html" title="FastHWSPITransfer"><link rel="next" href="_i2c_overview.html" title="I2C Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_i2c_software"></a>I2C Software</h3></div></div></div><p>This is the I2C Software section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="i2c_software"></span>I2C Software

</div>

</div>

</div>

This is the I2C Software section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2C/TWI Hardware Module</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_i2cstop.html" title="I2CStop"><link rel="next" href="_hi2c_overview.html" title="HI2C Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_i2c_twi_hardware_module"></a>I2C/TWI Hardware Module</h3></div></div></div><p>This is the I2C/TWI section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="i2c_twi_hardware_module"></span>I2C/TWI Hardware Module

</div>

</div>

</div>

This is the I2C/TWI section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>If</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_flow_control.html" title="Flow control"><link rel="prev" href="_goto.html" title="Goto"><link rel="next" href="_indcall.html" title="IndCall"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_if"></a>If</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen"><span class="strong"><strong><span class="emphasis"><em>Short form:</em></span></strong></span>

    If <span class="emphasis"><em>condition</em></span> Then <span class="emphasis"><em>command</em></span>

<span class="strong"><strong><span class="emphasis"><em>Long form:</em></span></strong></span>

    If <span class="emphasis"><em>condition</em></span> Then
    ...
    <span class="emphasis"><em>program code</em></span>
    ...
    End If

<span class="strong"><strong><span class="emphasis"><em>Using Else:</em></span></strong></span>

    If <span class="emphasis"><em>condition</em></span> Then
      <span class="emphasis"><em>code to run if true</em></span>
    Else
      <span class="emphasis"><em>code to run if false</em></span>
    End If

<span class="strong"><strong><span class="emphasis"><em>Using If Else:</em></span></strong></span>

    If <span class="emphasis"><em>condition</em></span> Then
      <span class="emphasis"><em>code to run if true</em></span>
    Else if <span class="emphasis"><em>nextcondition</em></span> then
      <span class="emphasis"><em>code to run if nextcondition true</em></span>
    Else
      <span class="emphasis"><em>code to run if false</em></span>
    End If</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">If</code> command is the most common command used to make decisions. If
<code class="literal"><span class="emphasis"><em>condition</em></span></code> is <code class="literal">true</code>, then <code class="literal"><span class="emphasis"><em>command</em></span></code> (short) or <code class="literal"><span class="emphasis"><em>program code</em></span></code> (long)
will be run. If it is <code class="literal">false</code>, then the microcontroller will skip to the code
located on the next line (short) or after the <code class="literal">End If</code> (long form).</p><p>If <code class="literal">Else</code> is used, then the condition between <code class="literal">If</code> and <code class="literal">Else</code> will run if the
condition is <code class="literal">true</code>, and the code between <code class="literal">Else</code> and <code class="literal">End If</code> will run if the
condition is <code class="literal">false</code>.</p><p>If <code class="literal">Else if</code> is used, then the condition after the  <code class="literal">Else if</code> will run if the
condition is <code class="literal">true</code>.</p><p><span class="strong"><strong>Note:</strong></span>
<code class="literal">Else</code> must be on a separate line in the source code.</p><p>Supported:</p><pre class="screen">    &lt;instruction&gt; 'is supported
    Else
    &lt;instruction&gt;</pre><pre class="screen">    &lt;instruction&gt; Else 'Not Supported, but will compile
    &lt;instruction&gt;</pre><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Turn a light on or off depending on a light sensor

    #chip 12F683, 8

    #define LIGHT GPIO.1
    #define SENSOR AN3
    #define SENSOR_PORT GPIO.4

    Dir LIGHT Out
    Dir SENSOR_PORT In

    Do
      If ReadAD(SENSOR) &gt; 128 Then
        Set LIGHT Off
      Else
        Set LIGHT On
      End If
    Loop</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_conditions.html" title="Conditions">Conditions</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="if"></span>If

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
Short form:

    If condition Then command

Long form:

    If condition Then
    ...
    program code
    ...
    End If

Using Else:

    If condition Then
      code to run if true
    Else
      code to run if false
    End If

Using If Else:

    If condition Then
      code to run if true
    Else if nextcondition then
      code to run if nextcondition true
    Else
      code to run if false
    End If
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `If` command is the most common command used to make decisions. If
`condition` is `true`, then `command` (short) or `program code` (long)
will be run. If it is `false`, then the microcontroller will skip to the
code located on the next line (short) or after the `End If` (long form).

If `Else` is used, then the condition between `If` and `Else` will run
if the condition is `true`, and the code between `Else` and `End If`
will run if the condition is `false`.

If `Else if` is used, then the condition after the `Else if` will run if
the condition is `true`.

<span class="strong">**Note:**</span> `Else` must be on a separate line
in the source code.

Supported:

``` screen
    <instruction> 'is supported
    Else
    <instruction>
```

``` screen
    <instruction> Else 'Not Supported, but will compile
    <instruction>
```

<span class="strong">**Example:**</span>

``` screen
    'Turn a light on or off depending on a light sensor

    #chip 12F683, 8

    #define LIGHT GPIO.1
    #define SENSOR AN3
    #define SENSOR_PORT GPIO.4

    Dir LIGHT Out
    Dir SENSOR_PORT In

    Do
      If ReadAD(SENSOR) > 128 Then
        Set LIGHT Off
      Else
        Set LIGHT On
      End If
    Loop
```

<span class="strong">**For more help, see
<a href="conditions" class="link" title="Conditions">Conditions</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ILI9326 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_hx8347g_controllers.html" title="HX8347G Controllers"><link rel="next" href="_ili9340_controllers.html" title="ILI9340 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_ili9326_controllers"></a>ILI9326 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the ILI9326 graphics controller.  The ILI9326 is a TFT LCD Single Chip Driver with 400RGBx320 Resolution and 262K colors.</p><p>GCBASIC supports 65K-color mode operations.</p><p>The GCBASIC constants shown below control the configuration of the ILI9326 controller. &nbsp;&nbsp;&nbsp;GCBASIC supports 8 bit bus connectivity  - this is shown in the tables below.</p><p>To use the ILI9326 driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9326

    'Pin mappings for ILI9326 - these MUST be specified
    #define GLCD_RD       porta.3        ' read command line
    #define GLCD_WR       porta.2         ' write command line
    #define GLCD_RS       porta.1         ' Command/Data line
    #define GLCD_CS       porta.0         ' Chip select line
    #define GLCD_RST      porta.5         ' Reset line
    #define GLCD_DataPort portD</pre><p>The GCBASIC constants for the interface to the controller are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Options</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_ILI9326</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RD</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to RD IO pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_WR</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to WR on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to RS pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to CS pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RST</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to RST pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DataPort</code></p></td><td align="left" valign="top"><p>Specifies the output port that is connected to DB0 to DB7 pins on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Default</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">320</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">240</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="left" valign="top"><p><code class="literal">6</code> for GCB fonts, and <code class="literal">5</code> for OLED fonts.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_OLED_FONT</code></p></td><td align="left" valign="top"><p>Specifies the use of the optional OLED font set.
</p><p>The GLCDfntDefaultsize can be set to 1 or 2 only.
</p><p><code class="literal">GLCDfntDefaultsize=  1</code>.   A small 8 height pixel font with variable width.
<code class="literal">GLCDfntDefaultsize=  2</code>.   A larger 10 width * 16 height pixel font.</p></td><td align="left" valign="top"><p>Optional</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDRotate</code></p></td><td align="left" valign="top"><p>Rotate the display</p></td><td align="left" valign="top"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ILI9326_[color]</code></p></td><td align="left" valign="top"><p>Specify color as a parameter for many GLCD commands</p></td><td align="left" valign="top"><p>Color constants for this device are shown in the list below.<br></p></td></tr></tbody></table></div><pre class="screen">    ILI9326_BLACK   'hexidecimal value 0x0000
    ILI9326_RED     'hexidecimal value 0xF800
    ILI9326_GREEN   'hexidecimal value 0x07E0
    ILI9326_BLUE    'hexidecimal value 0x001F
    ILI9326_WHITE   'hexidecimal value 0xFFFF
    ILI9326_PURPLE  'hexidecimal value 0xF11F
    ILI9326_YELLOW  'hexidecimal value 0xFFE0
    ILI9326_CYAN    'hexidecimal value 0x07FF
    ILI9326_D_GRAY  'hexidecimal value 0x528A
    ILI9326_L_GRAY  'hexidecimal value 0x7997
    ILI9326_SILVER  'hexidecimal value 0xC618
    ILI9326_MAROON  'hexidecimal value 0x8000
    ILI9326_OLIVE   'hexidecimal value 0x8400
    ILI9326_LIME    'hexidecimal value 0x07E0
    ILI9326_AQUA    'hexidecimal value 0x07FF
    ILI9326_TEAL    'hexidecimal value 0x0410
    ILI9326_NAVY    'hexidecimal value 0x0010
    ILI9326_FUCHSIA 'hexidecimal value 0xF81F</pre><p>For a ILI9326 datasheet, please refer to Google.</p><p>This example shows how to drive a ILI9326 based Graphic LCD module with the built in commands of GCBASIC.</p><p><span class="strong"><strong>Example #1</strong></span></p><pre class="screen">    ;Chip Settings
    #chip 16F1789,32

    #config MCLRE=on
    #option explicit
    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_ILI9326

    #define GLCD_RD       porta.3        ' read command line
    #define GLCD_WR       porta.2         ' write command line
    #define GLCD_RS       porta.1         ' Command/Data line
    #define GLCD_CS       porta.0         ' Chip select line
    #define GLCD_RST      porta.5         ' Reset line
    #define GLCD_DataPort portD

    GLCDPrint(0, 0, "Test of the ILI9326 Device")
    end</pre><p><br></p><p><span class="strong"><strong>Example #2</strong></span>
This example shows how to drive a ILI3941 with the OLED fonts.  Note the use of the <code class="literal">GLCDfntDefaultSize</code> to select the size of the OLED font in use.
<br></p><pre class="screen">  'Chip Settings
    #chip 16F1789,32

    #config MCLRE=on
    #option explicit
    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_ILI9326

    #define GLCD_RD       porta.3        ' read command line
    #define GLCD_WR       porta.2         ' write command line
    #define GLCD_RS       porta.1         ' Command/Data line
    #define GLCD_CS       porta.0         ' Chip select line
    #define GLCD_RST      porta.5         ' Reset line
    #define GLCD_DataPort portD

    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ILI9326" )
    GLCDPrint ( 0, 34, "Size: 400 x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</pre><p><br></p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="ili9326_controllers"></span>ILI9326 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the ILI9326 graphics
controller. The ILI9326 is a TFT LCD Single Chip Driver with 400RGBx320
Resolution and 262K colors.

GCBASIC supports 65K-color mode operations.

The GCBASIC constants shown below control the configuration of the
ILI9326 controller.    GCBASIC supports 8 bit bus connectivity - this is
shown in the tables below.

To use the ILI9326 driver simply include the following in your user
code. This will initialise the driver.

``` screen
    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9326

    'Pin mappings for ILI9326 - these MUST be specified
    #define GLCD_RD       porta.3        ' read command line
    #define GLCD_WR       porta.2         ' write command line
    #define GLCD_RS       porta.1         ' Command/Data line
    #define GLCD_CS       porta.0         ' Chip select line
    #define GLCD_RST      porta.5         ' Reset line
    #define GLCD_DataPort portD
```

The GCBASIC constants for the interface to the controller are shown in
the table below.

<div class="informaltable">

| Constants       | Controls                                                                    | Options  |
|:----------------|:----------------------------------------------------------------------------|:---------|
| `GLCD_TYPE`     | `GLCD_TYPE_ILI9326`                                                         |          |
| `GLCD_RD`       | Specifies the output pin that is connected to RD IO pin on the GLCD.        | Required |
| `GLCD_WR`       | Specifies the output pin that is connected to WR on the GLCD.               | Required |
| `GLCD_RS`       | Specifies the output pin that is connected to RS pin on the GLCD.           | Required |
| `GLCD_CS`       | Specifies the output pin that is connected to CS pin on the GLCD.           | Required |
| `GLCD_RST`      | Specifies the output pin that is connected to RST pin on the GLCD.          | Required |
| `GLCD_DataPort` | Specifies the output port that is connected to DB0 to DB7 pins on the GLCD. | Required |

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Constants</th>
<th style="text-align: left;">Controls</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">320</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">240</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Specifies the font width of the GCBASIC font set.</p></td>
<td style="text-align: left;"><p><code class="literal">6</code> for GCB fonts, and <code class="literal">5</code> for OLED fonts.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_OLED_FONT</code></p></td>
<td style="text-align: left;"><p>Specifies the use of the optional OLED font set.</p>
<p>The GLCDfntDefaultsize can be set to 1 or 2 only.</p>
<p><code class="literal">GLCDfntDefaultsize=  1</code>. A small 8 height pixel font with variable width. <code class="literal">GLCDfntDefaultsize=  2</code>. A larger 10 width * 16 height pixel font.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
<td style="text-align: left;"><p>Clear screen of GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDPrint</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar</code></p></td>
<td style="text-align: left;"><p>Print character on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDDrawString</code></p></td>
<td style="text-align: left;"><p>Print characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Box</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size</p></td>
<td style="text-align: left;"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">FilledBox</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td>
<td style="text-align: left;"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Line</code></p></td>
<td style="text-align: left;"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">PSet</code></p></td>
<td style="text-align: left;"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte</code></p></td>
<td style="text-align: left;"><p>Set a byte value to the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDReadByte</code></p></td>
<td style="text-align: left;"><p>Read a byte value from the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDRotate</code></p></td>
<td style="text-align: left;"><p>Rotate the display</p></td>
<td style="text-align: left;"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">ILI9326_[color]</code></p></td>
<td style="text-align: left;"><p>Specify color as a parameter for many GLCD commands</p></td>
<td style="text-align: left;"><p>Color constants for this device are shown in the list below.<br />
</p></td>
</tr>
</tbody>
</table>

</div>

``` screen
    ILI9326_BLACK   'hexidecimal value 0x0000
    ILI9326_RED     'hexidecimal value 0xF800
    ILI9326_GREEN   'hexidecimal value 0x07E0
    ILI9326_BLUE    'hexidecimal value 0x001F
    ILI9326_WHITE   'hexidecimal value 0xFFFF
    ILI9326_PURPLE  'hexidecimal value 0xF11F
    ILI9326_YELLOW  'hexidecimal value 0xFFE0
    ILI9326_CYAN    'hexidecimal value 0x07FF
    ILI9326_D_GRAY  'hexidecimal value 0x528A
    ILI9326_L_GRAY  'hexidecimal value 0x7997
    ILI9326_SILVER  'hexidecimal value 0xC618
    ILI9326_MAROON  'hexidecimal value 0x8000
    ILI9326_OLIVE   'hexidecimal value 0x8400
    ILI9326_LIME    'hexidecimal value 0x07E0
    ILI9326_AQUA    'hexidecimal value 0x07FF
    ILI9326_TEAL    'hexidecimal value 0x0410
    ILI9326_NAVY    'hexidecimal value 0x0010
    ILI9326_FUCHSIA 'hexidecimal value 0xF81F
```

For a ILI9326 datasheet, please refer to Google.

This example shows how to drive a ILI9326 based Graphic LCD module with
the built in commands of GCBASIC.

<span class="strong">**Example \#1**</span>

``` screen
    ;Chip Settings
    #chip 16F1789,32

    #config MCLRE=on
    #option explicit
    #include <glcd.h>
    #define GLCD_TYPE GLCD_TYPE_ILI9326

    #define GLCD_RD       porta.3        ' read command line
    #define GLCD_WR       porta.2         ' write command line
    #define GLCD_RS       porta.1         ' Command/Data line
    #define GLCD_CS       porta.0         ' Chip select line
    #define GLCD_RST      porta.5         ' Reset line
    #define GLCD_DataPort portD

    GLCDPrint(0, 0, "Test of the ILI9326 Device")
    end
```

  

<span class="strong">**Example \#2**</span> This example shows how to
drive a ILI3941 with the OLED fonts. Note the use of the
`GLCDfntDefaultSize` to select the size of the OLED font in use.  

``` screen
  'Chip Settings
    #chip 16F1789,32

    #config MCLRE=on
    #option explicit
    #include <glcd.h>
    #define GLCD_TYPE GLCD_TYPE_ILI9326

    #define GLCD_RD       porta.3        ' read command line
    #define GLCD_WR       porta.2         ' write command line
    #define GLCD_RS       porta.1         ' Command/Data line
    #define GLCD_CS       porta.0         ' Chip select line
    #define GLCD_RST      porta.5         ' Reset line
    #define GLCD_DataPort portD

    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ILI9326" )
    GLCDPrint ( 0, 34, "Size: 400 x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")
```

  

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ILI9340 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_ili9326_controllers.html" title="ILI9326 Controllers"><link rel="next" href="_ili9341_controllers.html" title="ILI9341 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_ili9340_controllers"></a>ILI9340 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the ILI9340 graphics controller.  The ILI9340 is a TFT LCD Single Chip Driver with 240RGBx320 Resolution and 262K colors.</p><p>GCBASIC supports 65K-color mode operations.</p><p>The GCBASIC constants shown below control the configuration of the ILI9340 controller. &nbsp;&nbsp;&nbsp;GCBASIC supports SPI hardware and software connectivity  - this is shown in the tables below.</p><p>To use the ILI9340 driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9340

    'Pin mappings for ILI9340 - these MUST be specified
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting</pre><p>The GCBASIC constants for the interface to the controller are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Options</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_ILI9340</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DC</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Reset</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DI</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DO</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_SCK</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.
#define GLCD_SCK    porta.5           'example port setting</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HWSPIMode</code></p></td><td align="left" valign="top"><p>User can specify the hardware SPI mode.  Must be one of MasterSlow, Master, Masterfast</p></td><td align="left" valign="top"><p>Optional. Defaults to Masterfast when chipMhz is less than 64mhz</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Default</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">320</code>+
Cannot be changed.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">240</code>+
Cannot be changed.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="left" valign="top"><p><code class="literal">6</code></p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDRotate</code></p></td><td align="left" valign="top"><p>Rotate the display</p></td><td align="left" valign="top"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ILI9340_[color]</code></p></td><td align="left" valign="top"><p>Specify color as a parameter for many GLCD commands</p></td><td align="left" valign="top"><p>Color constants for this device are shown in the list below.<br>
</p><p></p><p> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td></tr></tbody></table></div><pre class="screen">    ILI9340_BLACK   'hexidecimal value 0x0000
    ILI9340_RED     'hexidecimal value 0xF800
    ILI9340_GREEN   'hexidecimal value 0x07E0
    ILI9340_BLUE    'hexidecimal value 0x001F
    ILI9340_WHITE   'hexidecimal value 0xFFFF
    ILI9340_PURPLE  'hexidecimal value 0xF11F
    ILI9340_YELLOW  'hexidecimal value 0xFFE0
    ILI9340_CYAN    'hexidecimal value 0x07FF
    ILI9340_D_GRAY  'hexidecimal value 0x528A
    ILI9340_L_GRAY  'hexidecimal value 0x7997
    ILI9340_SILVER  'hexidecimal value 0xC618
    ILI9340_MAROON  'hexidecimal value 0x8000
    ILI9340_OLIVE   'hexidecimal value 0x8400
    ILI9340_LIME    'hexidecimal value 0x07E0
    ILI9340_AQUA    'hexidecimal value 0x07FF
    ILI9340_TEAL    'hexidecimal value 0x0410
    ILI9340_NAVY    'hexidecimal value 0x0010
    ILI9340_FUCHSIA 'hexidecimal value 0xF81F</pre><p>For a ILI9340 datasheet, please refer <a class="link" href="http://gcbasic.sourceforge.net/library/DISPLAY/ILI9340.pdf" target="_top">here</a>.</p><p>This example shows how to drive a ILI9340 based Graphic LCD module with the built in commands of GCBASIC.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    ;Chip Settings
    #chip 16F1937,32
    #config MCLRE_ON     'microcontroller specific configuration

    #include &lt;glcd.h&gt;

    'Defines for ILI9340
    #define GLCD_TYPE GLCD_TYPE_ILI9340

    'Pin mappings for ILI9340
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the ILI9340 Device")
    end</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="ili9340_controllers"></span>ILI9340 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the ILI9340 graphics
controller. The ILI9340 is a TFT LCD Single Chip Driver with 240RGBx320
Resolution and 262K colors.

GCBASIC supports 65K-color mode operations.

The GCBASIC constants shown below control the configuration of the
ILI9340 controller.    GCBASIC supports SPI hardware and software
connectivity - this is shown in the tables below.

To use the ILI9340 driver simply include the following in your user
code. This will initialise the driver.

``` screen
    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9340

    'Pin mappings for ILI9340 - these MUST be specified
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
```

The GCBASIC constants for the interface to the controller are shown in
the table below.

<div class="informaltable">

| Constants    | Controls                                                                                                                    | Options                                                          |
|:-------------|:----------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------|
| `GLCD_TYPE`  | `GLCD_TYPE_ILI9340`                                                                                                         |                                                                  |
| `GLCD_DC`    | Specifies the output pin that is connected to Data/Command IO pin on the GLCD.                                              | Required                                                         |
| `GLCD_CS`    | Specifies the output pin that is connected to Chip Select (CS) on the GLCD.                                                 | Required                                                         |
| `GLCD_Reset` | Specifies the output pin that is connected to Reset pin on the GLCD.                                                        | Required                                                         |
| `GLCD_DI`    | Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.                                           | Required                                                         |
| `GLCD_DO`    | Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.                                           | Required                                                         |
| `GLCD_SCK`   | Specifies the output pin that is connected to Clock (CLK) pin on the GLCD. \#define GLCD\_SCK porta.5 'example port setting | Required                                                         |
|              |                                                                                                                             |                                                                  |
| `HWSPIMode`  | User can specify the hardware SPI mode. Must be one of MasterSlow, Master, Masterfast                                       | Optional. Defaults to Masterfast when chipMhz is less than 64mhz |

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

| Constants       | Controls                                          | Default                   |
|:----------------|:--------------------------------------------------|:--------------------------|
| `GLCD_WIDTH`    | The width parameter of the GLCD                   | `320`+ Cannot be changed. |
| `GLCD_HEIGHT`   | The height parameter of the GLCD                  | `240`+ Cannot be changed. |
| `GLCDFontWidth` | Specifies the font width of the GCBASIC font set. | `6`                       |

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
<td style="text-align: left;"><p>Clear screen of GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDPrint</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar</code></p></td>
<td style="text-align: left;"><p>Print character on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDDrawString</code></p></td>
<td style="text-align: left;"><p>Print characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Box</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size</p></td>
<td style="text-align: left;"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">FilledBox</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td>
<td style="text-align: left;"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Line</code></p></td>
<td style="text-align: left;"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">PSet</code></p></td>
<td style="text-align: left;"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte</code></p></td>
<td style="text-align: left;"><p>Set a byte value to the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDReadByte</code></p></td>
<td style="text-align: left;"><p>Read a byte value from the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDRotate</code></p></td>
<td style="text-align: left;"><p>Rotate the display</p></td>
<td style="text-align: left;"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">ILI9340_[color]</code></p></td>
<td style="text-align: left;"><p>Specify color as a parameter for many GLCD commands</p></td>
<td style="text-align: left;"><p>Color constants for this device are shown in the list below.<br />
</p>
<p>Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td>
</tr>
</tbody>
</table>

</div>

``` screen
    ILI9340_BLACK   'hexidecimal value 0x0000
    ILI9340_RED     'hexidecimal value 0xF800
    ILI9340_GREEN   'hexidecimal value 0x07E0
    ILI9340_BLUE    'hexidecimal value 0x001F
    ILI9340_WHITE   'hexidecimal value 0xFFFF
    ILI9340_PURPLE  'hexidecimal value 0xF11F
    ILI9340_YELLOW  'hexidecimal value 0xFFE0
    ILI9340_CYAN    'hexidecimal value 0x07FF
    ILI9340_D_GRAY  'hexidecimal value 0x528A
    ILI9340_L_GRAY  'hexidecimal value 0x7997
    ILI9340_SILVER  'hexidecimal value 0xC618
    ILI9340_MAROON  'hexidecimal value 0x8000
    ILI9340_OLIVE   'hexidecimal value 0x8400
    ILI9340_LIME    'hexidecimal value 0x07E0
    ILI9340_AQUA    'hexidecimal value 0x07FF
    ILI9340_TEAL    'hexidecimal value 0x0410
    ILI9340_NAVY    'hexidecimal value 0x0010
    ILI9340_FUCHSIA 'hexidecimal value 0xF81F
```

For a ILI9340 datasheet, please refer
<a href="http://gcbasic.sourceforge.net/library/DISPLAY/ILI9340.pdf" class="link">here</a>.

This example shows how to drive a ILI9340 based Graphic LCD module with
the built in commands of GCBASIC.

<span class="strong">**Example:**</span>

``` screen
    ;Chip Settings
    #chip 16F1937,32
    #config MCLRE_ON     'microcontroller specific configuration

    #include <glcd.h>

    'Defines for ILI9340
    #define GLCD_TYPE GLCD_TYPE_ILI9340

    'Pin mappings for ILI9340
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the ILI9340 Device")
    end
```

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ILI9341 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_ili9340_controllers.html" title="ILI9340 Controllers"><link rel="next" href="_ili9481_controllers.html" title="ILI9481 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_ili9341_controllers"></a>ILI9341 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the ILI9341 graphics controller.  The ILI9341 is a TFT LCD Single Chip Driver with 240RGBx320 Resolution and 262K colors.</p><p>GCBASIC supports 65K-color mode operations.</p><p>The GCBASIC constants shown below control the configuration of the ILI9341 controller. &nbsp;&nbsp;&nbsp;GCBASIC supports SPI hardware and software connectivity  - this is shown in the tables below.</p><p>To use the ILI9341 driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9341

    'Pin mappings for ILI9341 - these MUST be specified
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting</pre><p>The GCBASIC constants for the interface to the controller are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Options</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_ILI9341</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DC</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Reset</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DI</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DO</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_SCK</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HWSPIMode</code></p></td><td align="left" valign="top"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td><td align="left" valign="top"><p>Optional defaults to MASTERFAST.
</p><p>Options are MASTERSLOW,<br>
MASTER,<br>
MASTERFAST, or<br>
MASTERULTRAFAST for specific AVRs only.</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Default</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">320</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">240</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="left" valign="top"><p><code class="literal">6</code> for GCB fonts, and <code class="literal">5</code> for OLED fonts.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_OLED_FONT</code></p></td><td align="left" valign="top"><p>Specifies the use of the optional OLED font set.
</p><p>The GLCDfntDefaultsize can be set to 1 or 2 only.
</p><p><code class="literal">GLCDfntDefaultsize=  1</code>.   A small 8 height pixel font with variable width.
<code class="literal">GLCDfntDefaultsize=  2</code>.   A larger 10 width * 16 height pixel font.</p></td><td align="left" valign="top"><p>Optional</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDRotate</code></p></td><td align="left" valign="top"><p>Rotate the display</p></td><td align="left" valign="top"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ILI9341_[color]</code></p></td><td align="left" valign="top"><p>Specify color as a parameter for many GLCD commands</p></td><td align="left" valign="top"><p>Color constants for this device are shown in the list below.<br></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ReadPixel</code></p></td><td align="left" valign="top"><p>Read the pixel color at the specified XY coordination.  Returns long variable with Red, Green and Blue encoded in the lower 24 bits.</p></td><td align="left" valign="top"><p>ReadPixel( Xosition , Yposition ) or ReadPixel_ILI9341( Xosition , Yposition )
</p><p> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td></tr></tbody></table></div><pre class="screen">    ILI9341_BLACK   'hexidecimal value 0x0000
    ILI9341_RED     'hexidecimal value 0xF800
    ILI9341_GREEN   'hexidecimal value 0x07E0
    ILI9341_BLUE    'hexidecimal value 0x001F
    ILI9341_WHITE   'hexidecimal value 0xFFFF
    ILI9341_PURPLE  'hexidecimal value 0xF11F
    ILI9341_YELLOW  'hexidecimal value 0xFFE0
    ILI9341_CYAN    'hexidecimal value 0x07FF
    ILI9341_D_GRAY  'hexidecimal value 0x528A
    ILI9341_L_GRAY  'hexidecimal value 0x7997
    ILI9341_SILVER  'hexidecimal value 0xC618
    ILI9341_MAROON  'hexidecimal value 0x8000
    ILI9341_OLIVE   'hexidecimal value 0x8400
    ILI9341_LIME    'hexidecimal value 0x07E0
    ILI9341_AQUA    'hexidecimal value 0x07FF
    ILI9341_TEAL    'hexidecimal value 0x0410
    ILI9341_NAVY    'hexidecimal value 0x0010
    ILI9341_FUCHSIA 'hexidecimal value 0xF81F</pre><p>For a ILI9341 datasheet, please refer <a class="link" href="http://gcbasic.sourceforge.net/library/DISPLAY/ILI9341.pdf" target="_top">here</a>.</p><p>This example shows how to drive a ILI9341 based Graphic LCD module with the built in commands of GCBASIC.</p><p><span class="strong"><strong>Example #1</strong></span></p><pre class="screen">    ;Chip Settings
    #chip 16F1937,32
    #config MCLRE_ON      'microcontroller specific configuration

    #include &lt;glcd.h&gt;

    'Defines for ILI9341
    #define GLCD_TYPE GLCD_TYPE_ILI9341

    'Pin mappings for ILI9341
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the ILI9341 Device")
    end</pre><p><br></p><p><span class="strong"><strong>Example #2</strong></span>
This example shows how to drive a ILI3941 with the OLED fonts.  Note the use of the <code class="literal">GLCDfntDefaultSize</code> to select the size of the OLED font in use.
<br></p><pre class="screen">    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ILI9341" )
    GLCDPrint ( 0, 34, "Size: 320 x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</pre><p><br></p><p><span class="strong"><strong>Example #2</strong></span>
This example shows how to disable the large OLED Fontset.  This disables the font to reduce memory usage.</p><p>When the extended OLED fontset is disabled every character will be shown as a block character.
<br></p><pre class="screen">    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts
    #define GLCD_Disable_OLED_FONT2       'The constant to disable the extended OLED fontset.

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ILI9341" )
    GLCDPrint ( 0, 34, "Size: 320 x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</pre><p><br></p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="ili9341_controllers"></span>ILI9341 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the ILI9341 graphics
controller. The ILI9341 is a TFT LCD Single Chip Driver with 240RGBx320
Resolution and 262K colors.

GCBASIC supports 65K-color mode operations.

The GCBASIC constants shown below control the configuration of the
ILI9341 controller.    GCBASIC supports SPI hardware and software
connectivity - this is shown in the tables below.

To use the ILI9341 driver simply include the following in your user
code. This will initialise the driver.

``` screen
    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9341

    'Pin mappings for ILI9341 - these MUST be specified
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting
```

The GCBASIC constants for the interface to the controller are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Constants</th>
<th style="text-align: left;">Controls</th>
<th style="text-align: left;">Options</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE</code></p></td>
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_ILI9341</code></p></td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DC</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_CS</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Chip Select (CS) on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_Reset</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_DI</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DO</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_SCK</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">HWSPIMode</code></p></td>
<td style="text-align: left;"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td>
<td style="text-align: left;"><p>Optional defaults to MASTERFAST.</p>
<p>Options are MASTERSLOW,<br />
MASTER,<br />
MASTERFAST, or<br />
MASTERULTRAFAST for specific AVRs only.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Constants</th>
<th style="text-align: left;">Controls</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">320</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">240</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Specifies the font width of the GCBASIC font set.</p></td>
<td style="text-align: left;"><p><code class="literal">6</code> for GCB fonts, and <code class="literal">5</code> for OLED fonts.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_OLED_FONT</code></p></td>
<td style="text-align: left;"><p>Specifies the use of the optional OLED font set.</p>
<p>The GLCDfntDefaultsize can be set to 1 or 2 only.</p>
<p><code class="literal">GLCDfntDefaultsize=  1</code>. A small 8 height pixel font with variable width. <code class="literal">GLCDfntDefaultsize=  2</code>. A larger 10 width * 16 height pixel font.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
<td style="text-align: left;"><p>Clear screen of GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDPrint</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar</code></p></td>
<td style="text-align: left;"><p>Print character on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDDrawString</code></p></td>
<td style="text-align: left;"><p>Print characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Box</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size</p></td>
<td style="text-align: left;"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">FilledBox</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td>
<td style="text-align: left;"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Line</code></p></td>
<td style="text-align: left;"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">PSet</code></p></td>
<td style="text-align: left;"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte</code></p></td>
<td style="text-align: left;"><p>Set a byte value to the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDReadByte</code></p></td>
<td style="text-align: left;"><p>Read a byte value from the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDRotate</code></p></td>
<td style="text-align: left;"><p>Rotate the display</p></td>
<td style="text-align: left;"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">ILI9341_[color]</code></p></td>
<td style="text-align: left;"><p>Specify color as a parameter for many GLCD commands</p></td>
<td style="text-align: left;"><p>Color constants for this device are shown in the list below.<br />
</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">ReadPixel</code></p></td>
<td style="text-align: left;"><p>Read the pixel color at the specified XY coordination. Returns long variable with Red, Green and Blue encoded in the lower 24 bits.</p></td>
<td style="text-align: left;"><p>ReadPixel( Xosition , Yposition ) or ReadPixel_ILI9341( Xosition , Yposition )</p>
<p>Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td>
</tr>
</tbody>
</table>

</div>

``` screen
    ILI9341_BLACK   'hexidecimal value 0x0000
    ILI9341_RED     'hexidecimal value 0xF800
    ILI9341_GREEN   'hexidecimal value 0x07E0
    ILI9341_BLUE    'hexidecimal value 0x001F
    ILI9341_WHITE   'hexidecimal value 0xFFFF
    ILI9341_PURPLE  'hexidecimal value 0xF11F
    ILI9341_YELLOW  'hexidecimal value 0xFFE0
    ILI9341_CYAN    'hexidecimal value 0x07FF
    ILI9341_D_GRAY  'hexidecimal value 0x528A
    ILI9341_L_GRAY  'hexidecimal value 0x7997
    ILI9341_SILVER  'hexidecimal value 0xC618
    ILI9341_MAROON  'hexidecimal value 0x8000
    ILI9341_OLIVE   'hexidecimal value 0x8400
    ILI9341_LIME    'hexidecimal value 0x07E0
    ILI9341_AQUA    'hexidecimal value 0x07FF
    ILI9341_TEAL    'hexidecimal value 0x0410
    ILI9341_NAVY    'hexidecimal value 0x0010
    ILI9341_FUCHSIA 'hexidecimal value 0xF81F
```

For a ILI9341 datasheet, please refer
<a href="http://gcbasic.sourceforge.net/library/DISPLAY/ILI9341.pdf" class="link">here</a>.

This example shows how to drive a ILI9341 based Graphic LCD module with
the built in commands of GCBASIC.

<span class="strong">**Example \#1**</span>

``` screen
    ;Chip Settings
    #chip 16F1937,32
    #config MCLRE_ON      'microcontroller specific configuration

    #include <glcd.h>

    'Defines for ILI9341
    #define GLCD_TYPE GLCD_TYPE_ILI9341

    'Pin mappings for ILI9341
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the ILI9341 Device")
    end
```

  

<span class="strong">**Example \#2**</span> This example shows how to
drive a ILI3941 with the OLED fonts. Note the use of the
`GLCDfntDefaultSize` to select the size of the OLED font in use.  

``` screen
    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ILI9341" )
    GLCDPrint ( 0, 34, "Size: 320 x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")
```

  

<span class="strong">**Example \#2**</span> This example shows how to
disable the large OLED Fontset. This disables the font to reduce memory
usage.

When the extended OLED fontset is disabled every character will be shown
as a block character.  

``` screen
    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts
    #define GLCD_Disable_OLED_FONT2       'The constant to disable the extended OLED fontset.

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ILI9341" )
    GLCDPrint ( 0, 34, "Size: 320 x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")
```

  

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ILI9481 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_ili9341_controllers.html" title="ILI9341 Controllers"><link rel="next" href="_ili9486_l_controllers.html" title="ILI9486(L) Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_ili9481_controllers"></a>ILI9481 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the ILI9481 graphics controller.</p><p>ILI9481 is a 262k-color single-chip SoC driver for a-TFT liquid crystal display with resolution of 320&nbsp;RGB&nbsp;x&nbsp;480&nbsp;
dots, comprising a 960-channel source driver, a 480-channel gate driver, 345,600 bytes GRAM for graphic data.</p><p>GCBASIC supports 65K-color mode operations.</p><p>The GCBASIC constants shown below control the configuration of the ILI9481controller.
&nbsp;&nbsp;&nbsp;The GCBASIC constants for control and data line connections are shown
in the table below. Two options are available for connectivity:</p><p>1)  The 8-bit mode where 8 pins are connected between the microcontroller and the GLCD to control the
data bus.</p><p>2)  The 16-bit mode where two data ports (8 pins each) are connected between  the microcontroller and the GLCD to control the data bus.</p><p>To use the ILI9481 driver simply include the following in your user code.  This will initialise the driver.</p><p><br>
<br>
<span class="strong"><strong>8-bit mode</strong></span></p><pre class="screen">    'Pin mappings for Data Bus Interface (DBI)
    'this GLCD driver supports 8 bit and 16 bit parallel data lines

    '8 bit DBI
    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9481

    '8 bit control and parallel data lines (UNO Board)
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line

    #define GLCD_DB0       DIGITAL_8        'Data port'
    #define GLCD_DB1       DIGITAL_9        'Data port'
    #define GLCD_DB2       DIGITAL_2        'Data port'
    #define GLCD_DB3       DIGITAL_3        'Data port'
    #define GLCD_DB4       DIGITAL_4        'Data port'
    #define GLCD_DB5       DIGITAL_5        'Data port'
    #define GLCD_DB6       DIGITAL_6        'Data port'
    #define GLCD_DB7       DIGITAL_7        'Data port'</pre><p><br>
<br></p><p><span class="strong"><strong>16-bit mode</strong></span></p><pre class="screen">    '16 bit DBI
    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_ILI9481
    #define GLCD_ILI9481_16bit

    '16 bit control and dual data port lines (Mega2560 Board)
    #define ILI9481_GLCD_CS PortG.1    'Chip Select line
    #define ILI9481_GLCD_RS PortD.7    'DC data command line
    #define ILI9481_GLCD_WR PortG.2    'Write command line
    #define ILI9481_GLCD_RST PortG.0    'Reset line

    #define ILI9481_DataPortH PortA    'DB[15:8]
    #define ILI9481_DataPortL PortC    'DB[7:0]</pre><p><br>
<br>
The GCBASIC constants for the interface to the controller are shown in the table below.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Options</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_ILI9481</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_ILI9481_16bit</code></p></td><td align="left" valign="top"><p>Specifies 16 bit DBI mode</p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DB0..7</code></p></td><td align="left" valign="top"><p>Specifies the  pin that is connected to DB0..7 IO pin on the GLCD (8 bit DBI).</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ILI9481_DataPortH</code></p></td><td align="left" valign="top"><p>Specifies the  port DB[15:8] pins on the GLCD (16 bit DBI).</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ILI9481_DataPortL</code></p></td><td align="left" valign="top"><p>Specifies the  port DB[7:0] pins on the GLCD (16 bit DBI).</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RST</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset IO pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_WR</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data In (RW or WDR) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RD</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (RD or RDR) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr></tbody></table></div><p><br>
<br>
The GCBASIC constants for control display characteristics are shown in the table below.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Default</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">320</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">480</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="left" valign="top"><p><code class="literal">6</code></p></td></tr></tbody></table></div><p><br>
<br></p><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDRotate</code></p></td><td align="left" valign="top"><p>Rotate the display</p></td><td align="left" valign="top"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ILI9481_[color]</code></p></td><td align="left" valign="top"><p>Specify color as a parameter for many GLCD commands</p></td><td align="left" valign="top"><p>Color constants for this device are shown in the list below.<br>
</p><p></p><p> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td></tr></tbody></table></div><p><br>
<br></p><pre class="screen">    ILI9481_BLACK   'hexidecimal value 0x0000
    ILI9481_RED     'hexidecimal value 0xF800
    ILI9481_GREEN   'hexidecimal value 0x0400
    ILI9481_BLUE    'hexidecimal value 0x001F
    ILI9481_WHITE   'hexidecimal value 0xFFFF
    ILI9481_PURPLE  'hexidecimal value 0xF11F
    ILI9481_YELLOW  'hexidecimal value 0xFFE0
    ILI9481_CYAN    'hexidecimal value 0x07FF
    ILI9481_D_GRAY  'hexidecimal value 0x528A
    ILI9481_L_GRAY  'hexidecimal value 0x7997
    ILI9481_SILVER  'hexidecimal value 0xC618
    ILI9481_MAROON  'hexidecimal value 0x8000
    ILI9481_OLIVE   'hexidecimal value 0x8400
    ILI9481_LIME    'hexidecimal value 0x07E0
    ILI9481_AQUA    'hexidecimal value 0x07FF
    ILI9481_TEAL    'hexidecimal value 0x0410
    ILI9481_NAVY    'hexidecimal value 0x0010
    ILI9481_FUCHSIA 'hexidecimal value 0xF81F</pre><p><br>
<br></p><p>These examples show how to drive a ILI9481 based Graphic LCD module with the built in commands of GCBASIC.  The 8 bit DBI example uses a UNO shield, this can easily adapted to Microchip architecture.  The 16 bit DBI
example uses a Mega2560 board.</p><p><br>
<br>
<span class="strong"><strong>Examples:</strong></span></p><pre class="screen">    '8 bit DBI
    #include &lt;glcd.h&gt;
    #include &lt;UNO_mega328p.h &gt;

    #define GLCD_TYPE GLCD_TYPE_ILI9481

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line

    #define GLCD_DB0       DIGITAL_8
    #define GLCD_DB1       DIGITAL_9
    #define GLCD_DB2       DIGITAL_2
    #define GLCD_DB3       DIGITAL_3
    #define GLCD_DB4       DIGITAL_4
    #define GLCD_DB5       DIGITAL_5
    #define GLCD_DB6       DIGITAL_6
    #define GLCD_DB7       DIGITAL_7

    GLCDPrint(0, 0, "Test of the ILI9481 Device")
    end</pre><p><br>
<br>
<br>
<br></p><pre class="screen">    '16 bit DBI
    #chip mega2560, 16
    #include &lt;glcd.h&gt;

    #define GLCD_TYPE GLCD_TYPE_ILI9481
    #define GLCD_ILI9481_16bit

    #define ILI9481_GLCD_CS PortG.1
    #define ILI9481_GLCD_RS PortD.7
    #define ILI9481_GLCD_WR PortG.2
    #define ILI9481_GLCD_RST PortG.0
    #define ILI9481_DataPortH PortA
    #define ILI9481_DataPortL PortC

    #define ILI9481_YELLOW1   0xFFC1
    #define ILI9481_BlueViolet  0x895C

    GLCDCLS_ILI9481 ILI9481_Black
    wait 1 s
    GLCDCLS_ILI9481 ILI9481_White
    wait 1 s

    GLCDfntDefaultsize = 3
    GLCDBackground = ILI9481_BlueViolet
    GLCDForeground = ILI9481_Yellow1
    GLCDCLS
    wait 1 s

    Start:

    'demonstrate screen rotation
    GLCDRotate (Portrait)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 - 24, "ILI9481 Driver")
    wait 5 s

    GLCDRotate (Landscape)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 -24, "ILI9481 Driver")
    wait 5 s

    GLCDRotate (Portrait_REV)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 - 24, "ILI9481 Driver")
    wait 5 s

    GLCDRotate (Landscape_REV)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 - 24, "ILI9481 Driver")
    wait 5 s

    goto Start</pre><p><br>
<br></p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>,  <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a>
<br>
<br>
Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="ili9481_controllers"></span>ILI9481 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the ILI9481 graphics
controller.

ILI9481 is a 262k-color single-chip SoC driver for a-TFT liquid crystal
display with resolution of 320 RGB x 480  dots, comprising a 960-channel
source driver, a 480-channel gate driver, 345,600 bytes GRAM for graphic
data.

GCBASIC supports 65K-color mode operations.

The GCBASIC constants shown below control the configuration of the
ILI9481controller.    The GCBASIC constants for control and data line
connections are shown in the table below. Two options are available for
connectivity:

1\) The 8-bit mode where 8 pins are connected between the
microcontroller and the GLCD to control the data bus.

2\) The 16-bit mode where two data ports (8 pins each) are connected
between the microcontroller and the GLCD to control the data bus.

To use the ILI9481 driver simply include the following in your user
code. This will initialise the driver.

  
  
<span class="strong">**8-bit mode**</span>

``` screen
    'Pin mappings for Data Bus Interface (DBI)
    'this GLCD driver supports 8 bit and 16 bit parallel data lines

    '8 bit DBI
    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9481

    '8 bit control and parallel data lines (UNO Board)
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line

    #define GLCD_DB0       DIGITAL_8        'Data port'
    #define GLCD_DB1       DIGITAL_9        'Data port'
    #define GLCD_DB2       DIGITAL_2        'Data port'
    #define GLCD_DB3       DIGITAL_3        'Data port'
    #define GLCD_DB4       DIGITAL_4        'Data port'
    #define GLCD_DB5       DIGITAL_5        'Data port'
    #define GLCD_DB6       DIGITAL_6        'Data port'
    #define GLCD_DB7       DIGITAL_7        'Data port'
```

  
  

<span class="strong">**16-bit mode**</span>

``` screen
    '16 bit DBI
    #include <glcd.h>
    #define GLCD_TYPE GLCD_TYPE_ILI9481
    #define GLCD_ILI9481_16bit

    '16 bit control and dual data port lines (Mega2560 Board)
    #define ILI9481_GLCD_CS PortG.1    'Chip Select line
    #define ILI9481_GLCD_RS PortD.7    'DC data command line
    #define ILI9481_GLCD_WR PortG.2    'Write command line
    #define ILI9481_GLCD_RST PortG.0    'Reset line

    #define ILI9481_DataPortH PortA    'DB[15:8]
    #define ILI9481_DataPortL PortC    'DB[7:0]
```

  
  
The GCBASIC constants for the interface to the controller are shown in
the table below.  
  

<div class="informaltable">

| Constants            | Controls                                                                            | Options  |
|:---------------------|:------------------------------------------------------------------------------------|:---------|
| `GLCD_TYPE`          | `GLCD_TYPE_ILI9481`                                                                 |          |
| `GLCD_ILI9481_16bit` | Specifies 16 bit DBI mode                                                           |          |
| `GLCD_DB0..7`        | Specifies the pin that is connected to DB0..7 IO pin on the GLCD (8 bit DBI).       | Required |
| `ILI9481_DataPortH`  | Specifies the port DB\[15:8\] pins on the GLCD (16 bit DBI).                        | Required |
| `ILI9481_DataPortL`  | Specifies the port DB\[7:0\] pins on the GLCD (16 bit DBI).                         | Required |
| `GLCD_RST`           | Specifies the output pin that is connected to Reset IO pin on the GLCD.             | Required |
| `GLCD_CS`            | Specifies the output pin that is connected to Chip Select (CS) on the GLCD.         | Required |
| `GLCD_RS`            | Specifies the output pin that is connected to Data/Command pin on the GLCD.         | Required |
| `GLCD_WR`            | Specifies the output pin that is connected to Data In (RW or WDR) pin on the GLCD.  | Required |
| `GLCD_RD`            | Specifies the output pin that is connected to Data Out (RD or RDR) pin on the GLCD. | Required |

</div>

  
  
The GCBASIC constants for control display characteristics are shown in
the table below.  
  

<div class="informaltable">

| Constants       | Controls                                          | Default |
|:----------------|:--------------------------------------------------|:--------|
| `GLCD_WIDTH`    | The width parameter of the GLCD                   | `320`   |
| `GLCD_HEIGHT`   | The height parameter of the GLCD                  | `480`   |
| `GLCDFontWidth` | Specifies the font width of the GCBASIC font set. | `6`     |

</div>

  
  

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.  
  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
<td style="text-align: left;"><p>Clear screen of GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDPrint</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar</code></p></td>
<td style="text-align: left;"><p>Print character on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDDrawString</code></p></td>
<td style="text-align: left;"><p>Print characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Box</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size</p></td>
<td style="text-align: left;"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">FilledBox</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td>
<td style="text-align: left;"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Line</code></p></td>
<td style="text-align: left;"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">PSet</code></p></td>
<td style="text-align: left;"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte</code></p></td>
<td style="text-align: left;"><p>Set a byte value to the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDReadByte</code></p></td>
<td style="text-align: left;"><p>Read a byte value from the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDRotate</code></p></td>
<td style="text-align: left;"><p>Rotate the display</p></td>
<td style="text-align: left;"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">ILI9481_[color]</code></p></td>
<td style="text-align: left;"><p>Specify color as a parameter for many GLCD commands</p></td>
<td style="text-align: left;"><p>Color constants for this device are shown in the list below.<br />
</p>
<p>Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td>
</tr>
</tbody>
</table>

</div>

  
  

``` screen
    ILI9481_BLACK   'hexidecimal value 0x0000
    ILI9481_RED     'hexidecimal value 0xF800
    ILI9481_GREEN   'hexidecimal value 0x0400
    ILI9481_BLUE    'hexidecimal value 0x001F
    ILI9481_WHITE   'hexidecimal value 0xFFFF
    ILI9481_PURPLE  'hexidecimal value 0xF11F
    ILI9481_YELLOW  'hexidecimal value 0xFFE0
    ILI9481_CYAN    'hexidecimal value 0x07FF
    ILI9481_D_GRAY  'hexidecimal value 0x528A
    ILI9481_L_GRAY  'hexidecimal value 0x7997
    ILI9481_SILVER  'hexidecimal value 0xC618
    ILI9481_MAROON  'hexidecimal value 0x8000
    ILI9481_OLIVE   'hexidecimal value 0x8400
    ILI9481_LIME    'hexidecimal value 0x07E0
    ILI9481_AQUA    'hexidecimal value 0x07FF
    ILI9481_TEAL    'hexidecimal value 0x0410
    ILI9481_NAVY    'hexidecimal value 0x0010
    ILI9481_FUCHSIA 'hexidecimal value 0xF81F
```

  
  

These examples show how to drive a ILI9481 based Graphic LCD module with
the built in commands of GCBASIC. The 8 bit DBI example uses a UNO
shield, this can easily adapted to Microchip architecture. The 16 bit
DBI example uses a Mega2560 board.

  
  
<span class="strong">**Examples:**</span>

``` screen
    '8 bit DBI
    #include <glcd.h>
    #include <UNO_mega328p.h >

    #define GLCD_TYPE GLCD_TYPE_ILI9481

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line

    #define GLCD_DB0       DIGITAL_8
    #define GLCD_DB1       DIGITAL_9
    #define GLCD_DB2       DIGITAL_2
    #define GLCD_DB3       DIGITAL_3
    #define GLCD_DB4       DIGITAL_4
    #define GLCD_DB5       DIGITAL_5
    #define GLCD_DB6       DIGITAL_6
    #define GLCD_DB7       DIGITAL_7

    GLCDPrint(0, 0, "Test of the ILI9481 Device")
    end
```

  
  
  
  

``` screen
    '16 bit DBI
    #chip mega2560, 16
    #include <glcd.h>

    #define GLCD_TYPE GLCD_TYPE_ILI9481
    #define GLCD_ILI9481_16bit

    #define ILI9481_GLCD_CS PortG.1
    #define ILI9481_GLCD_RS PortD.7
    #define ILI9481_GLCD_WR PortG.2
    #define ILI9481_GLCD_RST PortG.0
    #define ILI9481_DataPortH PortA
    #define ILI9481_DataPortL PortC

    #define ILI9481_YELLOW1   0xFFC1
    #define ILI9481_BlueViolet  0x895C

    GLCDCLS_ILI9481 ILI9481_Black
    wait 1 s
    GLCDCLS_ILI9481 ILI9481_White
    wait 1 s

    GLCDfntDefaultsize = 3
    GLCDBackground = ILI9481_BlueViolet
    GLCDForeground = ILI9481_Yellow1
    GLCDCLS
    wait 1 s

    Start:

    'demonstrate screen rotation
    GLCDRotate (Portrait)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 - 24, "ILI9481 Driver")
    wait 5 s

    GLCDRotate (Landscape)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 -24, "ILI9481 Driver")
    wait 5 s

    GLCDRotate (Portrait_REV)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 - 24, "ILI9481 Driver")
    wait 5 s

    GLCDRotate (Landscape_REV)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 - 24, "ILI9481 Driver")
    wait 5 s

    goto Start
```

  
  

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>  
  
Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ILI9486(L) Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_ili9481_controllers.html" title="ILI9481 Controllers"><link rel="next" href="_ili9488_controllers.html" title="ILI9488 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_ili9486_l_controllers"></a>ILI9486(L) Controllers</h5></div></div></div><p>This section covers GLCD devices that use the ILI9486(L) graphics controller.</p><p>The ILI9486(L) is a 262kcolor single-chip SoC driver for a-Si TFT liquid crystal display with resolution of
320RGBx480 dots, comprising a 960-channel source driver, a 480-channel gate driver, 345,600bytes GRAM for
graphic data of 320RGBx480 dots.</p><p>The GCBASIC constants shown below control the configuration of the ILI9486(L) controller. &nbsp;&nbsp;&nbsp;GCBASIC supports 1) SPI using the SPI hardware module, 2) software SPI, 3) UNO shields and 4) an 8bit port bus - this is detailed in the tables below.</p><p>GCBASIC supports 65K-color mode operations.</p><p>To use the ILI9486(L) driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9486L</pre><p>The GCBASIC constants for the interface to the controller are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Options</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_ILI9486L</code> or <code class="literal">GLCD_TYPE_ILI9486</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DC</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Reset</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DI</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DO</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_SLK</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr></tbody></table></div><p>The GCBASIC constants for the communicaton protocol for the controller are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><code class="literal">Communications Constants</code></th><th align="left" valign="top">Use</th><th align="left" valign="top">Comments</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">ILI9486L_HardwareSPI</code></p></td><td align="left" valign="top"><p>Specifies that hardware SPI will be used</p></td><td align="left" valign="top"><p>SPI ports MUST be defined that match the SPI module for each specific microcontroller
</p><p>    <span class="strong"><strong>#define ILI9486L_HardwareSPI</strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HWSPIMode</code></p></td><td align="left" valign="top"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td><td align="left" valign="top"><p>Optional defaults to MASTERFAST.
</p><p>Options are MASTERSLOW,<br>
MASTER,<br>
MASTERFAST, or<br>
MASTERULTRAFAST for specific AVRs only.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">UNO_8bit_Shield</code></p></td><td align="left" valign="top"><p>Specifies that a UNO shield will be used</p></td><td align="left" valign="top"><p>The shield will use 13 ports.  These ports are pre-defined by the shield. These ports must be specified.
</p><p>    <span class="strong"><strong>#define UNO_8bit_Shield</strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DataPort</code></p></td><td align="left" valign="top"><p>Specifies that a full 8 port will be used</p></td><td align="left" valign="top"><p>The microcontroller will use 13 ports.  These port is defined as 8 contigous bits. These control port and the data port must be specified.
</p><p>    <span class="strong"><strong>#define GLCD_DataPort portb</strong></span></p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Default</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">320</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">480</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="left" valign="top"><p><code class="literal">6</code></p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2  [,Optional In LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDRotate</code></p></td><td align="left" valign="top"><p>Rotate the display</p></td><td align="left" valign="top"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ILI9486L_[color]</code></p></td><td align="left" valign="top"><p>Specify color as a parameter for many GLCD commands</p></td><td align="left" valign="top"><p>Color constants for this device are shown in the list below.<br>
</p><p></p><p> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td></tr></tbody></table></div><pre class="screen">    TFT_BLACK   'hexidecimal value 0x0000
    TFT_RED     'hexidecimal value 0xF800
    TFT_GREEN   'hexidecimal value 0x07E0
    TFT_BLUE    'hexidecimal value 0x001F
    TFT_WHITE   'hexidecimal value 0xFFFF
    TFT_PURPLE  'hexidecimal value 0xF11F
    TFT_YELLOW  'hexidecimal value 0xFFE0
    TFT_CYAN    'hexidecimal value 0x07FF
    TFT_D_GRAY  'hexidecimal value 0x528A
    TFT_L_GRAY  'hexidecimal value 0x7997
    TFT_SILVER  'hexidecimal value 0xC618
    TFT_MAROON  'hexidecimal value 0x8000
    TFT_OLIVE   'hexidecimal value 0x8400
    TFT_LIME    'hexidecimal value 0x07E0
    TFT_AQUA    'hexidecimal value 0x07FF
    TFT_TEAL    'hexidecimal value 0x0410
    TFT_NAVY    'hexidecimal value 0x0010
    TFT_FUCHSIA 'hexidecimal value 0xF81F</pre><p>For a ILI9486L datasheet, please refer to Google.</p><p>This example shows how to drive a ILI9486L based Graphic LCD module with the built in commands of GCBASIC.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #chip mega328p, 16
    #option explicit

    #include &lt;glcd.h&gt;
    #include &lt;UNO_mega328p.h &gt;

    #define GLCD_TYPE GLCD_TYPE_ILI9486L

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       DIGITAL_8           ' Data command line
    #define GLCD_CS       DIGITAL_10          ' Chip select line
    #define GLCD_RST      DIGITAL_9           ' Reset line

    #define GLCD_DI       DIGITAL_13          ' Data in | MISO
    #define GLCD_DO       DIGITAL_11          ' Data out | MOSI
    #define GLCD_SCK      DIGITAL_13          ' Clock Line

    #define ILI9486L_HardwareSPI              ' Remove/comment out if you want to use software SPI.


    GLCDPrint(0, 0, "Test of the ILI9486L Device")
    end</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="ili9486_l_controllers"></span>ILI9486(L) Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the ILI9486(L) graphics
controller.

The ILI9486(L) is a 262kcolor single-chip SoC driver for a-Si TFT liquid
crystal display with resolution of 320RGBx480 dots, comprising a
960-channel source driver, a 480-channel gate driver, 345,600bytes GRAM
for graphic data of 320RGBx480 dots.

The GCBASIC constants shown below control the configuration of the
ILI9486(L) controller.    GCBASIC supports 1) SPI using the SPI hardware
module, 2) software SPI, 3) UNO shields and 4) an 8bit port bus - this
is detailed in the tables below.

GCBASIC supports 65K-color mode operations.

To use the ILI9486(L) driver simply include the following in your user
code. This will initialise the driver.

``` screen
    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9486L
```

The GCBASIC constants for the interface to the controller are shown in
the table below.

<div class="informaltable">

| Constants    | Controls                                                                          | Options  |
|:-------------|:----------------------------------------------------------------------------------|:---------|
| `GLCD_TYPE`  | `GLCD_TYPE_ILI9486L` or `GLCD_TYPE_ILI9486`                                       |          |
| `GLCD_DC`    | Specifies the output pin that is connected to Data/Command IO pin on the GLCD.    | Required |
| `GLCD_CS`    | Specifies the output pin that is connected to Chip Select (CS) on the GLCD.       | Required |
| `GLCD_Reset` | Specifies the output pin that is connected to Reset pin on the GLCD.              | Required |
| `GLCD_DI`    | Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD. | Required |
| `GLCD_DO`    | Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD. | Required |
| `GLCD_SLK`   | Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.        | Required |

</div>

The GCBASIC constants for the communicaton protocol for the controller
are shown in the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><code class="literal">Communications Constants</code></th>
<th style="text-align: left;">Use</th>
<th style="text-align: left;">Comments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">ILI9486L_HardwareSPI</code></p></td>
<td style="text-align: left;"><p>Specifies that hardware SPI will be used</p></td>
<td style="text-align: left;"><p>SPI ports MUST be defined that match the SPI module for each specific microcontroller</p>
<p><span class="strong"><strong>#define ILI9486L_HardwareSPI</strong></span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HWSPIMode</code></p></td>
<td style="text-align: left;"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td>
<td style="text-align: left;"><p>Optional defaults to MASTERFAST.</p>
<p>Options are MASTERSLOW,<br />
MASTER,<br />
MASTERFAST, or<br />
MASTERULTRAFAST for specific AVRs only.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">UNO_8bit_Shield</code></p></td>
<td style="text-align: left;"><p>Specifies that a UNO shield will be used</p></td>
<td style="text-align: left;"><p>The shield will use 13 ports. These ports are pre-defined by the shield. These ports must be specified.</p>
<p><span class="strong"><strong>#define UNO_8bit_Shield</strong></span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DataPort</code></p></td>
<td style="text-align: left;"><p>Specifies that a full 8 port will be used</p></td>
<td style="text-align: left;"><p>The microcontroller will use 13 ports. These port is defined as 8 contigous bits. These control port and the data port must be specified.</p>
<p><span class="strong"><strong>#define GLCD_DataPort portb</strong></span></p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

| Constants       | Controls                                          | Default |
|:----------------|:--------------------------------------------------|:--------|
| `GLCD_WIDTH`    | The width parameter of the GLCD                   | `320`   |
| `GLCD_HEIGHT`   | The height parameter of the GLCD                  | `480`   |
| `GLCDFontWidth` | Specifies the font width of the GCBASIC font set. | `6`     |

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
<td style="text-align: left;"><p>Clear screen of GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDPrint</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar</code></p></td>
<td style="text-align: left;"><p>Print character on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDDrawString</code></p></td>
<td style="text-align: left;"><p>Print characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Box</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size</p></td>
<td style="text-align: left;"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">FilledBox</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td>
<td style="text-align: left;"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Line</code></p></td>
<td style="text-align: left;"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2  [,Optional In LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">PSet</code></p></td>
<td style="text-align: left;"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte</code></p></td>
<td style="text-align: left;"><p>Set a byte value to the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDReadByte</code></p></td>
<td style="text-align: left;"><p>Read a byte value from the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDRotate</code></p></td>
<td style="text-align: left;"><p>Rotate the display</p></td>
<td style="text-align: left;"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">ILI9486L_[color]</code></p></td>
<td style="text-align: left;"><p>Specify color as a parameter for many GLCD commands</p></td>
<td style="text-align: left;"><p>Color constants for this device are shown in the list below.<br />
</p>
<p>Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td>
</tr>
</tbody>
</table>

</div>

``` screen
    TFT_BLACK   'hexidecimal value 0x0000
    TFT_RED     'hexidecimal value 0xF800
    TFT_GREEN   'hexidecimal value 0x07E0
    TFT_BLUE    'hexidecimal value 0x001F
    TFT_WHITE   'hexidecimal value 0xFFFF
    TFT_PURPLE  'hexidecimal value 0xF11F
    TFT_YELLOW  'hexidecimal value 0xFFE0
    TFT_CYAN    'hexidecimal value 0x07FF
    TFT_D_GRAY  'hexidecimal value 0x528A
    TFT_L_GRAY  'hexidecimal value 0x7997
    TFT_SILVER  'hexidecimal value 0xC618
    TFT_MAROON  'hexidecimal value 0x8000
    TFT_OLIVE   'hexidecimal value 0x8400
    TFT_LIME    'hexidecimal value 0x07E0
    TFT_AQUA    'hexidecimal value 0x07FF
    TFT_TEAL    'hexidecimal value 0x0410
    TFT_NAVY    'hexidecimal value 0x0010
    TFT_FUCHSIA 'hexidecimal value 0xF81F
```

For a ILI9486L datasheet, please refer to Google.

This example shows how to drive a ILI9486L based Graphic LCD module with
the built in commands of GCBASIC.

<span class="strong">**Example:**</span>

``` screen
    #chip mega328p, 16
    #option explicit

    #include <glcd.h>
    #include <UNO_mega328p.h >

    #define GLCD_TYPE GLCD_TYPE_ILI9486L

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       DIGITAL_8           ' Data command line
    #define GLCD_CS       DIGITAL_10          ' Chip select line
    #define GLCD_RST      DIGITAL_9           ' Reset line

    #define GLCD_DI       DIGITAL_13          ' Data in | MISO
    #define GLCD_DO       DIGITAL_11          ' Data out | MOSI
    #define GLCD_SCK      DIGITAL_13          ' Clock Line

    #define ILI9486L_HardwareSPI              ' Remove/comment out if you want to use software SPI.


    GLCDPrint(0, 0, "Test of the ILI9486L Device")
    end
```

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ILI9488 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_ili9486_l_controllers.html" title="ILI9486(L) Controllers"><link rel="next" href="_ks0108_controllers.html" title="KS0108 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_ili9488_controllers"></a>ILI9488 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the ILI9488 graphics controller.</p><p>ILI9488 is a 262k-color single-chip SoC driver for a-TFT liquid crystal display with resolution of 320 x 240 resolution, 16.7M-color and with internal GRAM .</p><p>GCBASIC supports 65K-color mode operations.</p><p>The GCBASIC constants shown below control the configuration of the ILI9488 controller.
&nbsp;&nbsp;&nbsp;The GCBASIC constants for control and data line connections are shown
in the table below. Only SPI is available for connectivity:</p><p>To use the ILI9488 driver simply include the following in your user code.  This will initialise the driver.</p><p><br>
<br>
<span class="strong"><strong>SPI mode</strong></span></p><pre class="screen">    'Pin mappings for SPI

    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9488

    #DEFINE GLCD_DC       PORTB.3           ' Data command line
    #DEFINE GLCD_CS       PORTB.5           ' Chip select line
    #DEFINE GLCD_RST      PORTB.4           ' Reset line

    #DEFINE GLCD_DI       PORTB.2          ' Data in | MISO
    #DEFINE GLCD_DO       PORTB.0          ' Data out | MOSI
    #DEFINE GLCD_SCK      PORTB.1          ' Clock Line</pre><p><br>
<br></p><p><br>
<br>
The GCBASIC constants for the interface to the controller are shown in the table below.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Options</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p>GLCD_TYPE_ILI9488</p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">ILI9488_HARDWARESPI</code></p></td><td align="left" valign="top"><p>Specifies to use the microcontrollers SPI module.
For PPS microcontrollers the libary assumes PPS for SPI has been configured.</p></td><td align="left" valign="top"><p>Optional</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HWSPIMODE MASTERFAST</code></p></td><td align="left" valign="top"><p>Specifies the speed of the SPI communications.</p></td><td align="left" valign="top"><p>Optional</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RST</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset IO pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DI</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data In (RW or WDR) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DO</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (RD or RDR) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_SCK</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Clock pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr></tbody></table></div><p><br>
<br>
The GCBASIC constants for control display characteristics are shown in the table below.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Default</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">320</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">480</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="left" valign="top"><p><code class="literal">6</code></p></td></tr></tbody></table></div><p><br>
<br></p><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDRotate</code></p></td><td align="left" valign="top"><p>Rotate the display</p></td><td align="left" valign="top"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ILI9488__TFT_[color]</code></p></td><td align="left" valign="top"><p>Specify color as a parameter for many GLCD commands</p></td><td align="left" valign="top"><p>Color constants for this device are shown in the list below, butm you can use the generic TFT color scheme.<br>
</p><p></p><p> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td></tr></tbody></table></div><p><br>
<br></p><pre class="screen">    ILI9488_TFT_BLACK       //0x000000
    ILI9488_TFT_RED         //0xFC0000
    ILI9488_TFT_GREEN       //0x00FC00
    ILI9488_TFT_BLUE        //0x0000FC
    ILI9488_TFT_WHITE       //0xFFFFFF

    ILI9488_TFT_CYAN        //0x003F3F
    ILI9488_TFT_DARKCYAN    //0x00AFAF
    ILI9488_TFT_DARKGREEN   //0x002100
    ILI9488_TFT_DARKGREY    //0xAAAAAA
    ILI9488_TFT_GREENYELLOW //0x93FC33
    ILI9488_TFT_LIGHTGREY   //0xC9C9C9
    ILI9488_TFT_MAGENTA     //0xCC00CC
    ILI9488_TFT_MAROON      //0x7E007E
    ILI9488_TFT_NAVY        //0x00003E
    ILI9488_TFT_OLIVE       //0x783E00
    ILI9488_TFT_ORANGE      //0xFC2900
    ILI9488_TFT_PINK        //0xFC000F
    ILI9488_TFT_PURPLE      //0xF01F9E
    ILI9488_TFT_YELLOW      //0xFC7E00</pre><p><br>
<br></p><p>These examples show how to drive a ILI9488 based Graphic LCD module with the built in commands of GCBASIC.</p><p><br>
<br>
<span class="strong"><strong>Examples - PPS Enabled</strong></span></p><pre class="screen">    #chip 18F26K83, 64
    #option Explicit

    'Generated by PIC PPS Tool for GCBASIC
    #startup InitPPS, 85
    #DEFINE PPSToolPart 18f26k83

    Sub InitPPS
        'Module: UART pin directions
        Dir PORTC.7 Out    ' Make TX1 pin an output
        'Module: UART1
        RC7PPS = 0x0013    'TX1 &gt; RC7

        #IFDEF ILI9488_HardwareSPI
            UNLOCKPPS
            'Module: SPI1
            RB0PPS = 0x001F    'SDO1 &gt; RB0
            RB1PPS = 0x001E    'SCK1 &gt; RB1
            SPI1SCKPPS = 0x0009    'RB1 &gt; SCK1 (bi-directional)
            SPI1SDIPPS = 0x000A    'RB2 &gt; SDI1
        #ELSE
            RB0PPS = 0
            RB1PPS = 0
        #ENDIF
    End Sub
    // Template comment at the end of the config file

    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9488
    #DEFINE ILI9488_HARDWARESPI
    #DEFINE HWSPIMODE MASTERFAST
    #DEFINE GLCD_DC       PORTB.3           ' Data command line
    #DEFINE GLCD_CS       PORTB.5           ' Chip select line
    #DEFINE GLCD_RST      PORTB.4           ' Reset line

    #DEFINE GLCD_DI       PORTB.2          ' Data in | MISO
    #DEFINE GLCD_DO       PORTB.0          ' Data out | MOSI
    #DEFINE GLCD_SCK      PORTB.1          ' Clock Line

    '''********************************************************************************

    'main program start here

    // Set the background
    #DEFINE DEFAULT_GLCDBACKGROUND TFT_WHITE


    GLCDPrint 0, 0, "Test of the ILI9488 Device", TFT_BLACK
    end</pre><p><br>
<br>
<br>
<br>
<span class="strong"><strong>Examples - Legacy non PPS microcontroller</strong></span></p><pre class="screen">    #chip 16F1939
    #option Explicit



    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9488
    #DEFINE GLCD_DC       PORTB.3           ' Data command line
    #DEFINE GLCD_CS       PORTB.5           ' Chip select line
    #DEFINE GLCD_RST      PORTB.4           ' Reset line

    #DEFINE GLCD_DI       PORTB.2          ' Data in | MISO
    #DEFINE GLCD_DO       PORTB.0          ' Data out | MOSI
    #DEFINE GLCD_SCK      PORTB.1          ' Clock Line

    '''********************************************************************************

    'main program start here

    // Set the background
    #DEFINE DEFAULT_GLCDBACKGROUND TFT_WHITE


    GLCDPrint 0, 0, "Test of the ILI9488 Device", TFT_BLACK
    end</pre><p><br>
<br></p><pre class="screen"></pre><p><br>
<br></p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>,  <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a>
<br>
<br>
Supported in &lt;GLCD.H&gt;</p><p><br>
<br>
<span class="strong"><strong>Developer Notes</strong></span></p><p>The ILI9488 library implemented uses BRG color scheme which is different from other GLCD libraries.</p><p>The ILI9488 library implemented also uses 18bits for color definition where the color scheme is defined as shown below:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/ili9488.png" align="middle" height="360" alt="graphic"></div></div><p>The ILI9488 library implemented there has the following differences from a typical GLCD library.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">The colors are defined as RGB left justified 6 bits.</li><li class="listitem">The colors are defined as Longs ( not Words other GLCDs are Words).</li><li class="listitem">The color information uses a 18bit macro for SPI communications.&nbsp;&nbsp;Color information is sent to the GLCD in three bytes.</li><li class="listitem">The color contraints are based on the SPI constraints specified in the ILI9488 datasheet.</li></ol></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="ili9488_controllers"></span>ILI9488 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the ILI9488 graphics
controller.

ILI9488 is a 262k-color single-chip SoC driver for a-TFT liquid crystal
display with resolution of 320 x 240 resolution, 16.7M-color and with
internal GRAM .

GCBASIC supports 65K-color mode operations.

The GCBASIC constants shown below control the configuration of the
ILI9488 controller.    The GCBASIC constants for control and data line
connections are shown in the table below. Only SPI is available for
connectivity:

To use the ILI9488 driver simply include the following in your user
code. This will initialise the driver.

  
  
<span class="strong">**SPI mode**</span>

``` screen
    'Pin mappings for SPI

    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9488

    #DEFINE GLCD_DC       PORTB.3           ' Data command line
    #DEFINE GLCD_CS       PORTB.5           ' Chip select line
    #DEFINE GLCD_RST      PORTB.4           ' Reset line

    #DEFINE GLCD_DI       PORTB.2          ' Data in | MISO
    #DEFINE GLCD_DO       PORTB.0          ' Data out | MOSI
    #DEFINE GLCD_SCK      PORTB.1          ' Clock Line
```

  
  

  
  
The GCBASIC constants for the interface to the controller are shown in
the table below.  
  

<div class="informaltable">

| Constants              | Controls                                                                                                                       | Options  |
|:-----------------------|:-------------------------------------------------------------------------------------------------------------------------------|:---------|
| `GLCD_TYPE`            | GLCD\_TYPE\_ILI9488                                                                                                            |          |
| `ILI9488_HARDWARESPI`  | Specifies to use the microcontrollers SPI module. For PPS microcontrollers the libary assumes PPS for SPI has been configured. | Optional |
| `HWSPIMODE MASTERFAST` | Specifies the speed of the SPI communications.                                                                                 | Optional |
| `GLCD_RST`             | Specifies the output pin that is connected to Reset IO pin on the GLCD.                                                        | Required |
| `GLCD_CS`              | Specifies the output pin that is connected to Chip Select (CS) on the GLCD.                                                    | Required |
| `GLCD_RS`              | Specifies the output pin that is connected to Data/Command pin on the GLCD.                                                    | Required |
| `GLCD_DI`              | Specifies the output pin that is connected to Data In (RW or WDR) pin on the GLCD.                                             | Required |
| `GLCD_DO`              | Specifies the output pin that is connected to Data Out (RD or RDR) pin on the GLCD.                                            | Required |
| `GLCD_SCK`             | Specifies the output pin that is connected to Clock pin on the GLCD.                                                           | Required |

</div>

  
  
The GCBASIC constants for control display characteristics are shown in
the table below.  
  

<div class="informaltable">

| Constants       | Controls                                          | Default |
|:----------------|:--------------------------------------------------|:--------|
| `GLCD_WIDTH`    | The width parameter of the GLCD                   | `320`   |
| `GLCD_HEIGHT`   | The height parameter of the GLCD                  | `480`   |
| `GLCDFontWidth` | Specifies the font width of the GCBASIC font set. | `6`     |

</div>

  
  

The GCBASIC commands supported for this GLCD are shown in the table
below.  Always review the appropiate library for the latest full set of
supported commands.  
  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
<td style="text-align: left;"><p>Clear screen of GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDPrint</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar</code></p></td>
<td style="text-align: left;"><p>Print character on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDDrawString</code></p></td>
<td style="text-align: left;"><p>Print characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Box</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size</p></td>
<td style="text-align: left;"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">FilledBox</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td>
<td style="text-align: left;"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Line</code></p></td>
<td style="text-align: left;"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">PSet</code></p></td>
<td style="text-align: left;"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDRotate</code></p></td>
<td style="text-align: left;"><p>Rotate the display</p></td>
<td style="text-align: left;"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">ILI9488__TFT_[color]</code></p></td>
<td style="text-align: left;"><p>Specify color as a parameter for many GLCD commands</p></td>
<td style="text-align: left;"><p>Color constants for this device are shown in the list below, butm you can use the generic TFT color scheme.<br />
</p>
<p>Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td>
</tr>
</tbody>
</table>

</div>

  
  

``` screen
    ILI9488_TFT_BLACK       //0x000000
    ILI9488_TFT_RED         //0xFC0000
    ILI9488_TFT_GREEN       //0x00FC00
    ILI9488_TFT_BLUE        //0x0000FC
    ILI9488_TFT_WHITE       //0xFFFFFF

    ILI9488_TFT_CYAN        //0x003F3F
    ILI9488_TFT_DARKCYAN    //0x00AFAF
    ILI9488_TFT_DARKGREEN   //0x002100
    ILI9488_TFT_DARKGREY    //0xAAAAAA
    ILI9488_TFT_GREENYELLOW //0x93FC33
    ILI9488_TFT_LIGHTGREY   //0xC9C9C9
    ILI9488_TFT_MAGENTA     //0xCC00CC
    ILI9488_TFT_MAROON      //0x7E007E
    ILI9488_TFT_NAVY        //0x00003E
    ILI9488_TFT_OLIVE       //0x783E00
    ILI9488_TFT_ORANGE      //0xFC2900
    ILI9488_TFT_PINK        //0xFC000F
    ILI9488_TFT_PURPLE      //0xF01F9E
    ILI9488_TFT_YELLOW      //0xFC7E00
```

  
  

These examples show how to drive a ILI9488 based Graphic LCD module with
the built in commands of GCBASIC.

  
  
<span class="strong">**Examples - PPS Enabled**</span>

``` screen
    #chip 18F26K83, 64
    #option Explicit

    'Generated by PIC PPS Tool for GCBASIC
    #startup InitPPS, 85
    #DEFINE PPSToolPart 18f26k83

    Sub InitPPS
        'Module: UART pin directions
        Dir PORTC.7 Out    ' Make TX1 pin an output
        'Module: UART1
        RC7PPS = 0x0013    'TX1 > RC7

        #IFDEF ILI9488_HardwareSPI
            UNLOCKPPS
            'Module: SPI1
            RB0PPS = 0x001F    'SDO1 > RB0
            RB1PPS = 0x001E    'SCK1 > RB1
            SPI1SCKPPS = 0x0009    'RB1 > SCK1 (bi-directional)
            SPI1SDIPPS = 0x000A    'RB2 > SDI1
        #ELSE
            RB0PPS = 0
            RB1PPS = 0
        #ENDIF
    End Sub
    // Template comment at the end of the config file

    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9488
    #DEFINE ILI9488_HARDWARESPI
    #DEFINE HWSPIMODE MASTERFAST
    #DEFINE GLCD_DC       PORTB.3           ' Data command line
    #DEFINE GLCD_CS       PORTB.5           ' Chip select line
    #DEFINE GLCD_RST      PORTB.4           ' Reset line

    #DEFINE GLCD_DI       PORTB.2          ' Data in | MISO
    #DEFINE GLCD_DO       PORTB.0          ' Data out | MOSI
    #DEFINE GLCD_SCK      PORTB.1          ' Clock Line

    '''********************************************************************************

    'main program start here

    // Set the background
    #DEFINE DEFAULT_GLCDBACKGROUND TFT_WHITE


    GLCDPrint 0, 0, "Test of the ILI9488 Device", TFT_BLACK
    end
```

  
  
  
  
<span class="strong">**Examples - Legacy non PPS
microcontroller**</span>

``` screen
    #chip 16F1939
    #option Explicit



    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9488
    #DEFINE GLCD_DC       PORTB.3           ' Data command line
    #DEFINE GLCD_CS       PORTB.5           ' Chip select line
    #DEFINE GLCD_RST      PORTB.4           ' Reset line

    #DEFINE GLCD_DI       PORTB.2          ' Data in | MISO
    #DEFINE GLCD_DO       PORTB.0          ' Data out | MOSI
    #DEFINE GLCD_SCK      PORTB.1          ' Clock Line

    '''********************************************************************************

    'main program start here

    // Set the background
    #DEFINE DEFAULT_GLCDBACKGROUND TFT_WHITE


    GLCDPrint 0, 0, "Test of the ILI9488 Device", TFT_BLACK
    end
```

  
  

``` screen
```

  
  

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>  
  
Supported in &lt;GLCD.H&gt;

  
  
<span class="strong">**Developer Notes**</span>

The ILI9488 library implemented uses BRG color scheme which is different
from other GLCD libraries.

The ILI9488 library implemented also uses 18bits for color definition
where the color scheme is defined as shown below:

<div class="informalfigure">

<div class="mediaobject" align="center">

<img src="./images/ili9488.png" height="360" alt="graphic" />

</div>

</div>

The ILI9488 library implemented there has the following differences from
a typical GLCD library.

<div class="orderedlist">

1.  The colors are defined as RGB left justified 6 bits.
2.  The colors are defined as Longs ( not Words other GLCDs are Words).
3.  The color information uses a 18bit macro for SPI
    communications.  Color information is sent to the GLCD in three
    bytes.
4.  The color contraints are based on the SPI constraints specified in
    the ILI9488 datasheet.

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Implementing a method with a Pin name as a parameter</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_macros.html" title="Example Macros"><link rel="prev" href="_measuring_a_pulse_width.html" title="Measuring a Pulse Width"><link rel="next" href="_example_programs.html" title="Example Programs"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_implementing_a_method_with_a_pin_name_as_a_parameter"></a>Implementing a method with a Pin name as a parameter</h4></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>A constant such as a Pin name cannot be passed to a sub routine or a function.  This is a constraint of GCBASIC.</p><p>A macro can be used to implement a method of passing a constant to reusable code section.</p><p>The example shown below implements a button press routine and takes an input port constant and prints the result on an LCD display.</p><p><span class="strong"><strong>Note:</strong></span>
A macro will use more program memory as the macro will be compiled as inline code. Therefore, for every use of the macro will use additional program memory - the same amount of program memory for each call to the macro.</p><p><span class="strong"><strong>Demonstration Program:</strong></span></p><pre class="screen">    #chip 16F877a, 16
    #define Button PORTC.1    ' Switch on PIN 14 via 10K pullup resistor
    DIR Button In
    wait 1 sec

    'USART settings
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    ;======== MAIN PROGRAM LOOP ================
    HSerPrint "Button Test"
    HSerPrintCRLF 2
    Do
       Test_button ( button )
    Loop
    ;==========================================

    Macro Test_button (Button)
       if Button = ON then
          wait 10 ms          'debounce
          ButtonCount = 0


           Do While Button = On
               Wait 10 ms
               ButtonCount += 1
           Loop


           if ButtonCount &gt; 5  then
               if ButtonCount &gt; 50 then   'Long push
                   hserprint "Long push"
               else                       'Short push
                   hserprint "Short push"
               end if
               HSerPrintCRLF
           end if
           wait 1 s
       end if
    End Macro</pre><p>Also see <a class="link" href="_macros_overview.html" title="Macros Overview">Macros Overview</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="implementing_a_method_with_a_pin_name_as_a_parameter"></span>Implementing a method with a Pin name as a parameter

</div>

</div>

</div>

<span class="strong">**Introduction**</span>

A constant such as a Pin name cannot be passed to a sub routine or a
function. This is a constraint of GCBASIC.

A macro can be used to implement a method of passing a constant to
reusable code section.

The example shown below implements a button press routine and takes an
input port constant and prints the result on an LCD display.

<span class="strong">**Note:**</span> A macro will use more program
memory as the macro will be compiled as inline code. Therefore, for
every use of the macro will use additional program memory - the same
amount of program memory for each call to the macro.

<span class="strong">**Demonstration Program:**</span>

``` screen
    #chip 16F877a, 16
    #define Button PORTC.1    ' Switch on PIN 14 via 10K pullup resistor
    DIR Button In
    wait 1 sec

    'USART settings
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    ;======== MAIN PROGRAM LOOP ================
    HSerPrint "Button Test"
    HSerPrintCRLF 2
    Do
       Test_button ( button )
    Loop
    ;==========================================

    Macro Test_button (Button)
       if Button = ON then
          wait 10 ms          'debounce
          ButtonCount = 0


           Do While Button = On
               Wait 10 ms
               ButtonCount += 1
           Loop


           if ButtonCount > 5  then
               if ButtonCount > 50 then   'Long push
                   hserprint "Long push"
               else                       'Short push
                   hserprint "Short push"
               end if
               HSerPrintCRLF
           end if
           wait 1 s
       end if
    End Macro
```

Also see
<a href="macros_overview" class="link" title="Macros Overview">Macros Overview</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>IndCall</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_flow_control.html" title="Flow control"><link rel="prev" href="_if.html" title="If"><link rel="next" href="_pause.html" title="Pause"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_indcall"></a>IndCall</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    IndCall <span class="emphasis"><em>Address</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">IndCall</code> provides a basic implementation of function pointers. <code class="literal"><span class="emphasis"><em>Address</em></span></code>
is the program memory location of the subroutine that is to be called.
There are two ways to specify this - either by providing a direct
reference to the subroutine using the @ operator, or by specifying a
word variable that contains the address.</p><p>This command is useful for callbacks. For example, a particular
subroutine might read bytes from a serial connection, but different
actions may need to be taken at different times. A different subroutine
could be created for each action, and then the subroutine for the
appropriate action could be passed to the serial connection reading
routine each time it is called.</p><p><span class="strong"><strong>Note:</strong></span>
Calling subroutines that have parameters using <code class="literal">IndCall</code> is not
supported. Errors may occur. If data needs to be passed, use a variable
instead.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Flash an LED using an indirect call
    #chip 12F683

    'Create a word variable, and set it to the memory location of the
    'Blink subroutine.
    Dim FlashingSub As Word
    FlashingSub = @Blink

    'Main loop
    Do
    'Indirect call to subroutine at location FlashingSub
    	IndCall FlashingSub
    Loop

    'LED flashing subroutine
    Sub Blink
    	PulseOut GPIO.0, 500 ms
    	Wait 500 ms
    End Sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="indcall"></span>IndCall

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    IndCall Address
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

`IndCall` provides a basic implementation of function pointers.
`Address` is the program memory location of the subroutine that is to be
called. There are two ways to specify this - either by providing a
direct reference to the subroutine using the @ operator, or by
specifying a word variable that contains the address.

This command is useful for callbacks. For example, a particular
subroutine might read bytes from a serial connection, but different
actions may need to be taken at different times. A different subroutine
could be created for each action, and then the subroutine for the
appropriate action could be passed to the serial connection reading
routine each time it is called.

<span class="strong">**Note:**</span> Calling subroutines that have
parameters using `IndCall` is not supported. Errors may occur. If data
needs to be passed, use a variable instead.

<span class="strong">**Example:**</span>

``` screen
    'Flash an LED using an indirect call
    #chip 12F683

    'Create a word variable, and set it to the memory location of the
    'Blink subroutine.
    Dim FlashingSub As Word
    FlashingSub = @Blink

    'Main loop
    Do
    'Indirect call to subroutine at location FlashingSub
        IndCall FlashingSub
    Loop

    'LED flashing subroutine
    Sub Blink
        PulseOut GPIO.0, 500 ms
        Wait 500 ms
    End Sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>GCBASIC documentation</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="next" href="_introducing_gcbasic.html" title="Introducing GCBASIC"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="article"><div class="titlepage"><div><div><h1 class="title"><a name="d0e3"></a>GCBASIC documentation</h1></div><div><div class="author"><h3 class="author"><span class="firstname">The GCBASIC development team @ 2024</span></h3></div></div></div><hr></div></div></body></html><html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InfraRed Remote</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_programs.html" title="Example Programs"><link rel="prev" href="_graphical_lcd_demonstration.html" title="Graphical LCD Demonstration"><link rel="next" href="_sonyremote_h.html" title="SonyRemote.h"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_infrared_remote"></a>InfraRed Remote</h3></div></div></div><p><span class="strong"><strong>Explanation:</strong></span></p><p>GCBASIC support interfacing with IR remote controls. The header file contains explanations, for both hardware and software.</p><p>This has been tested on many different IR sensors, and different remote controls.</p><p><span class="strong"><strong>Demonstration program:</strong></span></p><p>The example is expected to work with most any IR sensor running at a 38 kHz carrier frequency.</p><pre class="screen">    ;This demo prints the device number and key number sent by
    ;a Sony compatible IR remote control unit to an LCD

    ;Thomas Henry --- 4/23/2014

    #chip 16F88, 8                    ;PIC16F88 running at 8 MHz
    #config mclr=off                  ;reset handled internally
    #include &lt;SonyRemote.h&gt;           ;include the header file

    ;----- Constants

    #define LCD_IO      4             ;4-bit mode
    #define LCD_WIDTH 20              ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS      PortB.2       ;pin 8 is Register Select
    #define LCD_Enable  PortB.3       ;pin 9 is Enable
    #define LCD_DB4     PortB.4       ;DB4 on pin 10
    #define LCD_DB5     PortB.5       ;DB5 on pin 11
    #define LCD_DB6     PortB.6       ;DB6 on pin 12
    #define LCD_DB7     PortB.7       ;DB7 on pin 13
    #define LCD_NO_RW   1             ;ground RW line on LCD

    #define IR_DATA_PIN PortA.0       ;sensor on pin 17

    ;----- Variables

    dim device, button as byte

    ;----- Program

    dir PortA in                      ;A.0 is IR input
    dir PortB out                     ;B.2 - B.6 for LCD

    do
      readIR_Remote(device, button)   ;wait for button press

      cls                             ;show device code
      print "Device: "
      print device

      locate 1,0
      print "Button: "                ;show button code
      print button

      wait 10 mS                      ;ignore any repeats
    loop                              ;repeat forever</pre><p><span class="strong"><strong>See also <a class="link" href="_sonyremote_h.html" title="SonyRemote.h">SonyRemote.h</a></strong></span>.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="infrared_remote"></span>InfraRed Remote

</div>

</div>

</div>

<span class="strong">**Explanation:**</span>

GCBASIC support interfacing with IR remote controls. The header file
contains explanations, for both hardware and software.

This has been tested on many different IR sensors, and different remote
controls.

<span class="strong">**Demonstration program:**</span>

The example is expected to work with most any IR sensor running at a 38
kHz carrier frequency.

``` screen
    ;This demo prints the device number and key number sent by
    ;a Sony compatible IR remote control unit to an LCD

    ;Thomas Henry --- 4/23/2014

    #chip 16F88, 8                    ;PIC16F88 running at 8 MHz
    #config mclr=off                  ;reset handled internally
    #include <SonyRemote.h>           ;include the header file

    ;----- Constants

    #define LCD_IO      4             ;4-bit mode
    #define LCD_WIDTH 20              ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS      PortB.2       ;pin 8 is Register Select
    #define LCD_Enable  PortB.3       ;pin 9 is Enable
    #define LCD_DB4     PortB.4       ;DB4 on pin 10
    #define LCD_DB5     PortB.5       ;DB5 on pin 11
    #define LCD_DB6     PortB.6       ;DB6 on pin 12
    #define LCD_DB7     PortB.7       ;DB7 on pin 13
    #define LCD_NO_RW   1             ;ground RW line on LCD

    #define IR_DATA_PIN PortA.0       ;sensor on pin 17

    ;----- Variables

    dim device, button as byte

    ;----- Program

    dir PortA in                      ;A.0 is IR input
    dir PortB out                     ;B.2 - B.6 for LCD

    do
      readIR_Remote(device, button)   ;wait for button press

      cls                             ;show device code
      print "Device: "
      print device

      locate 1,0
      print "Button: "                ;show button code
      print button

      wait 10 mS                      ;ignore any repeats
    loop                              ;repeat forever
```

<span class="strong">**See also
<a href="sonyremote_h" class="link" title="SonyRemote.h">SonyRemote.h</a>**</span>.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitSer</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_software.html" title="RS232 (software)"><link rel="prev" href="_rs232_software_overview.html" title="RS232 Software Overview"><link rel="next" href="_sersend.html" title="SerSend"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_initser"></a>InitSer</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">	<code class="literal">InitSer</code> <span class="emphasis"><em>channel, rate, start, data, stop, parity, invert</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will set up the serial communications. The parameters are
as follows:</p><p><code class="literal"><span class="emphasis"><em>channel</em></span></code> is 1, 2 or 3, and refers to the I/O ports that are used for
communication.</p><p><code class="literal"><span class="emphasis"><em>rate</em></span></code> is the bit rate, which is given by the letter r and then the
desiredrate in bps. Acceptable units are r300, r600, r1200, r2400,
r4800, r9600 and r19200.</p><p><code class="literal"><span class="emphasis"><em>start</em></span></code> gives the number of start bits, which is usually 1. To make
the microcontroller wait for the start bit before proceeding with the receive, add
128 to <code class="literal"><span class="emphasis"><em>start</em></span></code>. (Note: it may be desirable to use the <code class="literal">WaitForStart</code>
constant here.)</p><p><code class="literal"><span class="emphasis"><em>data</em></span></code> tells the program how many data bits are to be sent or received.
In most situations t his is 8, but it can range between 1 and 8,
inclusive.</p><p><code class="literal"><span class="emphasis"><em>stop</em></span></code> is the number of stop bits. If <span class="emphasis"><em>start</em></span> bit 7 is on, then this
number will be ignored.</p><p><code class="literal"><span class="emphasis"><em>parity</em></span></code> refers to a system of error checking used by many devices. It
can be odd (in which there must always be an odd number of high bits),
even (where the number of high bits must always be even), or none (for
systems that do not use parity).</p><p><code class="literal"><span class="emphasis"><em>invert</em></span></code> can be either "normal" or "invert". If it in "invert", then
high bits will be changed to low, and low to high.</p><p><span class="strong"><strong>Example:</strong></span></p><p>Please refer to <a class="link" href="_sersend.html" title="SerSend">SerSend</a> for an example of <code class="literal">InitSer</code></p><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_rs232_software_overview.html" title="RS232 Software Overview">RS232 Software Overview</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="initser"></span>InitSer

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
   InitSer channel, rate, start, data, stop, parity, invert
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This command will set up the serial communications. The parameters are
as follows:

`channel` is 1, 2 or 3, and refers to the I/O ports that are used for
communication.

`rate` is the bit rate, which is given by the letter r and then the
desiredrate in bps. Acceptable units are r300, r600, r1200, r2400,
r4800, r9600 and r19200.

`start` gives the number of start bits, which is usually 1. To make the
microcontroller wait for the start bit before proceeding with the
receive, add 128 to `start`. (Note: it may be desirable to use the
`WaitForStart` constant here.)

`data` tells the program how many data bits are to be sent or received.
In most situations t his is 8, but it can range between 1 and 8,
inclusive.

`stop` is the number of stop bits. If <span
class="emphasis">*start*</span> bit 7 is on, then this number will be
ignored.

`parity` refers to a system of error checking used by many devices. It
can be odd (in which there must always be an odd number of high bits),
even (where the number of high bits must always be even), or none (for
systems that do not use parity).

`invert` can be either "normal" or "invert". If it in "invert", then
high bits will be changed to low, and low to high.

<span class="strong">**Example:**</span>

Please refer to
<a href="sersend" class="link" title="SerSend">SerSend</a> for an
example of `InitSer`

<span class="strong">**For more help, see**</span>
<a href="rs232_software_overview" class="link" title="RS232 Software Overview">RS232 Software Overview</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitTimer0</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_cleartimer.html" title="ClearTimer"><link rel="next" href="_inittimer0_8bit_16bit.html" title="InitTimer0 8bit/16bit"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inittimer0"></a>InitTimer0</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    InitTimer0 source, prescaler</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a Timer 0 module.</p><p>See also  see: <a class="link" href="_inittimer0_8bit_16bit.html" title="InitTimer0 8bit/16bit">InitTimer0 8bit/16bit</a> for support for microcontrollers with a 8 bit/16 bit Timer 0 module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">InitTimer0</code> will set up timer 0.</p><p>Parameters are required as detailed in the table below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>source</em></span></code></p></td><td align="left" valign="top"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code> or <code class="literal">Ext</code> where`Osc` is an internal oscillator and <code class="literal">Ext</code> is an external oscillator.
<br>
<br>
<code class="literal">Osc</code> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&nbsp;&nbsp;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</p><p><code class="literal">Ext</code> - Selects the clock source attached to a specific exernal interrupt input port.&nbsp;&nbsp;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer.  See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.</p></td></tr></tbody></table></div><p>When the timer overflows from 255 to 0, a  <code class="literal">Timer0Overflow</code> interrupt will
be generated. This can be used in conjunction with <code class="literal">On Interrupt</code> to run a
section of code when the overflow occurs.
<br>
<br>
<br>
<br></p><p><span class="strong"><strong>Microchip PIC microcontrollers:</strong></span></p><p>On Microchip PIC microcontrollers where the <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> rate select bits are in the range of 2 to 256  you should use one of the following constants.  If the <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> rate select bits are in the range of 1 to 32768 then see the subsequent table.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">PS0_2</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS0_4</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS0_8</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS0_16</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:32</p></td><td align="left" valign="top"><p><code class="literal">PS0_32</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS0_64</code></p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:128</p></td><td align="left" valign="top"><p><code class="literal">PS0_128</code></p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:256</p></td><td align="left" valign="top"><p><code class="literal">PS0_256</code></p></td><td align="center" valign="top"><p>7</p></td></tr></tbody></table></div><p>These correspond to a prescaler of between 1:2 and 1:256 of the oscillator
speed where the oscillator speed is (FOSC/4). The prescaler applies to
both the internal oscillator or the external clock.
<br>
<br>
<br></p><p><span class="strong"><strong>Atmel AVR microcontrollers:</strong></span></p><p>On Atmel AVR microcontrollers <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> must be one of the following constants:</p><p>The prescaler will only apply when the timer is driven from the <code class="literal">Osc</code> the
internal oscillator - the prescaler has no effect when the external clock
source is specified.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Secondary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS_1</code></p></td><td align="left" valign="top"><p><code class="literal">PS_0_1</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS_8</code></p></td><td align="left" valign="top"><p><code class="literal">PS_0_8</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS_64</code></p></td><td align="left" valign="top"><p><code class="literal">PS_0_64</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:256</p></td><td align="left" valign="top"><p><code class="literal">PS_256</code></p></td><td align="left" valign="top"><p><code class="literal">PS_0_256</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:1024</p></td><td align="left" valign="top"><p><code class="literal">PS_1024</code></p></td><td align="left" valign="top"><p><code class="literal">PS_0_1024</code></p></td><td align="center" valign="top"><p>5</p></td></tr></tbody></table></div><p><br>
<br>
<br>
<span class="strong"><strong>Example 1 for 8-bit timer 0:</strong></span></p><p>This code uses Timer 0 and On Interrupt to generate a Pulse Width Modulation
signal, that will allow the speed of a motor to be easily controlled.</p><pre class="screen">    #chip 16F88, 8

    #define MOTOR PORTB.0

    'Call the initialisation routine
    InitMotorControl

    'Main routine
    Do
        'Increase speed to full over 2.5 seconds
        For Speed = 0 to 100
            MotorSpeed = Speed
            Wait 25 ms
        Next
        'Hold speed
        Wait 1 s
        'Decrease speed to zero over 2.5 seconds
        For Speed = 100 to 0
            MotorSpeed = Speed
            Wait 25 ms
        Next
        'Hold speed
        Wait 1 s
    Loop

    'Setup routine
    Sub InitMotorControl
        'Clear variables
        MotorSpeed = 0
        PWMCounter = 0

        'Add a handler for the interrupt
        On Interrupt Timer0Overflow Call PWMHandler

        'Set up the timer using the internal oscillator with a prescaler of 1/2 (Equates to 0)
        'Timer 0 starts automatically on a Microchip PIC microcontroller, therefore, StartTimer is not required.
        InitTimer0 Osc, PS0_2

    End Sub

    'PWM sub
    'This will be called when Timer 0 overflows
    Sub PWMHandler
        If MotorSpeed &gt; PWMCounter Then
            Set MOTOR On
        Else
            Set MOTOR Off
        End If
        PWMCounter += 1
        If PWMCounter = 100 Then PWMCounter = 0
    End Sub</pre><p><span class="strong"><strong>Example 1 for 18-bit timer 0 operating an 8-bit timer:</strong></span></p><p>The same example for a 16-bit timer 0 operating as an 8-bit timer.</p><pre class="screen">#chip 16f18855,32
#option Explicit
'timer test Program

dim speed, MotorSpeed, PWMCounter as byte

#define MOTOR PORTb.0
dir MOTOR out

'Call the initialisation routine
InitMotorControl

'Main routine
Do
    'Increase speed to full over 2.5 seconds
    For Speed = 0 to 100
        MotorSpeed = Speed
        Wait 25 ms
    Next
    'Hold speed
    Wait 1 s
    'Decrease speed to zero over 2.5 seconds
    For Speed = 100 to 0
        MotorSpeed = Speed
        Wait 25 ms
    Next
    'Hold speed
    Wait 1 s
Loop

'Setup routine
Sub InitMotorControl
    'Clear variables
    MotorSpeed = 0
    PWMCounter = 0

    'Add a handler for the interrupt
    On Interrupt Timer0Overflow Call PWMHandler

    InitTimer0(Osc, TMR0_FOSC4 + PRE0_1 , POST0_1)
    StartTimer 0

End Sub

'PWM sub
'This will be called when Timer 0 overflows
Sub PWMHandler

    If MotorSpeed &gt; PWMCounter Then
        Set MOTOR On
    Else
        Set MOTOR Off
    End If
    PWMCounter += 1
    If PWMCounter = 100 Then PWMCounter = 0

End Sub</pre><p><span class="strong"><strong>Supported in &lt;TIMER.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inittimer0"></span>InitTimer0

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    InitTimer0 source, prescaler
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a Timer 0 module.

See also see:
<a href="inittimer0_8bit_16bit" class="link" title="InitTimer0 8bit/16bit">InitTimer0 8bit/16bit</a>
for support for microcontrollers with a 8 bit/16 bit Timer 0 module.

<span class="strong">**Explanation:**</span>

`InitTimer0` will set up timer 0.

Parameters are required as detailed in the table below:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">source</code></p></td>
<td style="text-align: left;"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code> or <code class="literal">Ext</code> where`Osc` is an internal oscillator and <code class="literal">Ext</code> is an external oscillator.<br />
<br />
<code class="literal">Osc</code> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).  This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).</p>
<p><code class="literal">Ext</code> - Selects the clock source attached to a specific exernal interrupt input port.  This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">prescaler</code></p></td>
<td style="text-align: left;"><p>The value of the prescaler for this specific timer. See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.</p></td>
</tr>
</tbody>
</table>

</div>

When the timer overflows from 255 to 0, a `Timer0Overflow` interrupt
will be generated. This can be used in conjunction with `On Interrupt`
to run a section of code when the overflow occurs.  
  
  
  

<span class="strong">**Microchip PIC microcontrollers:**</span>

On Microchip PIC microcontrollers where the `prescaler` rate select bits
are in the range of 2 to 256 you should use one of the following
constants. If the `prescaler` rate select bits are in the range of 1 to
32768 then see the subsequent table.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:2</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_2</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_4</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_8</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_16</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:32</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_32</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_64</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:128</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_128</code></p></td>
<td style="text-align: center;"><p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:256</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_256</code></p></td>
<td style="text-align: center;"><p>7</p></td>
</tr>
</tbody>
</table>

</div>

These correspond to a prescaler of between 1:2 and 1:256 of the
oscillator speed where the oscillator speed is (FOSC/4). The prescaler
applies to both the internal oscillator or the external clock.  
  
  

<span class="strong">**Atmel AVR microcontrollers:**</span>

On Atmel AVR microcontrollers `prescaler` must be one of the following
constants:

The prescaler will only apply when the timer is driven from the `Osc`
the internal oscillator - the prescaler has no effect when the external
clock source is specified.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Secondary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_0_1</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS_8</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_0_8</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS_64</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_0_64</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:256</p></td>
<td style="text-align: left;"><p><code class="literal">PS_256</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_0_256</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:1024</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1024</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_0_1024</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
</tbody>
</table>

</div>

  
  
  
<span class="strong">**Example 1 for 8-bit timer 0:**</span>

This code uses Timer 0 and On Interrupt to generate a Pulse Width
Modulation signal, that will allow the speed of a motor to be easily
controlled.

``` screen
    #chip 16F88, 8

    #define MOTOR PORTB.0

    'Call the initialisation routine
    InitMotorControl

    'Main routine
    Do
        'Increase speed to full over 2.5 seconds
        For Speed = 0 to 100
            MotorSpeed = Speed
            Wait 25 ms
        Next
        'Hold speed
        Wait 1 s
        'Decrease speed to zero over 2.5 seconds
        For Speed = 100 to 0
            MotorSpeed = Speed
            Wait 25 ms
        Next
        'Hold speed
        Wait 1 s
    Loop

    'Setup routine
    Sub InitMotorControl
        'Clear variables
        MotorSpeed = 0
        PWMCounter = 0

        'Add a handler for the interrupt
        On Interrupt Timer0Overflow Call PWMHandler

        'Set up the timer using the internal oscillator with a prescaler of 1/2 (Equates to 0)
        'Timer 0 starts automatically on a Microchip PIC microcontroller, therefore, StartTimer is not required.
        InitTimer0 Osc, PS0_2

    End Sub

    'PWM sub
    'This will be called when Timer 0 overflows
    Sub PWMHandler
        If MotorSpeed > PWMCounter Then
            Set MOTOR On
        Else
            Set MOTOR Off
        End If
        PWMCounter += 1
        If PWMCounter = 100 Then PWMCounter = 0
    End Sub
```

<span class="strong">**Example 1 for 18-bit timer 0 operating an 8-bit
timer:**</span>

The same example for a 16-bit timer 0 operating as an 8-bit timer.

``` screen
#chip 16f18855,32
#option Explicit
'timer test Program

dim speed, MotorSpeed, PWMCounter as byte

#define MOTOR PORTb.0
dir MOTOR out

'Call the initialisation routine
InitMotorControl

'Main routine
Do
    'Increase speed to full over 2.5 seconds
    For Speed = 0 to 100
        MotorSpeed = Speed
        Wait 25 ms
    Next
    'Hold speed
    Wait 1 s
    'Decrease speed to zero over 2.5 seconds
    For Speed = 100 to 0
        MotorSpeed = Speed
        Wait 25 ms
    Next
    'Hold speed
    Wait 1 s
Loop

'Setup routine
Sub InitMotorControl
    'Clear variables
    MotorSpeed = 0
    PWMCounter = 0

    'Add a handler for the interrupt
    On Interrupt Timer0Overflow Call PWMHandler

    InitTimer0(Osc, TMR0_FOSC4 + PRE0_1 , POST0_1)
    StartTimer 0

End Sub

'PWM sub
'This will be called when Timer 0 overflows
Sub PWMHandler

    If MotorSpeed > PWMCounter Then
        Set MOTOR On
    Else
        Set MOTOR Off
    End If
    PWMCounter += 1
    If PWMCounter = 100 Then PWMCounter = 0

End Sub
```

<span class="strong">**Supported in &lt;TIMER.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitTimer0 8bit/16bit</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_inittimer0.html" title="InitTimer0"><link rel="prev" href="_inittimer0.html" title="InitTimer0"><link rel="next" href="_inittimer1.html" title="InitTimer1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_inittimer0_8bit_16bit"></a>InitTimer0 8bit/16bit</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    InitTimer0 source, prescaler + clocksource, postscaler</pre><p>Timer are useful as timers can generate interrupts.
Timers can be used in conjunction with <code class="literal">On Interrupt</code> to run a section of code when a specific timer event occurs.
Example events are when the timer matches a specific value, or, the timer resets to a zero value.
For more details on timer events see <code class="literal">On Interrupt</code>.</p><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on microcontrollers with a Timer 0 where the timer has the capability of operating as an 8 bit or 16 bit timer.&nbsp;&nbsp;
This type of Timer 0 can be found on Microchip PIC 18(L)F, as well as small number of 18C and 16(L)F microcontrollers.&nbsp;&nbsp;
These timers can be configured for either 8-bit or 16-bit operation.</p><p>You may need to refer to the datasheet for your microcontroller to determine if it supports both 8-bit and 16-bit operations.</p><p><span class="strong"><strong>Explanation for 8-bit timer:</strong></span></p><p>The default operation is as an 8-bit timer.&nbsp;&nbsp;
<code class="literal">InitTimer0</code> will set up timer 0.</p><p>Parameters are required as shown in the table below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>source</em></span></code></p></td><td align="left" valign="top"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code> or <code class="literal">Ext</code> where`Osc` is an internal oscillator and <code class="literal">Ext</code> is an external oscillator.
</p><p><br>
<br>
<code class="literal">Osc</code> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&nbsp;&nbsp;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</p><p><code class="literal">Ext</code> - Selects the clock source attached to a specific exernal interrupt input port.&nbsp;&nbsp;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer, <span class="strong"><strong>and</strong></span>, the clocksource
</p><p>See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the postscaler for this specific timer.
</p><p>See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.</p></td></tr></tbody></table></div><p><span class="emphasis"><em>8 bit Example:</em></span></p><p>The example show in the <code class="literal">osc</code> as an internal source, a <code class="literal">prescaler</code> value of 256 witht the HFINTOSC <code class="literal">clocksource</code> and a <code class="literal">postscaler</code> value of 2</p><pre class="screen">    InitTimer0 Osc, PRE0_256 + TMR0_HFINTOSC ,  POST0_2
    'also, note when in 8-bit mode you MUST set the 8bit timer value to the upper byte of a WORD, when setting the `SetTimer`
    SetTimer 0, 0x5800   'Setting the HIGH byte!!!</pre><p><span class="emphasis"><em>16 bit Example:</em></span></p><p>To use the 16 bit timer you need to add the constant <code class="literal">#define TMR0_16bit</code>.</p><p>The example show in the <code class="literal">osc</code> as an internal source, a <code class="literal">prescaler</code> value of 256 witht the HFINTOSC <code class="literal">clocksource</code> and a <code class="literal">postscaler</code> value of 2</p><pre class="screen">    #define TMR0_16bit
    InitTimer0 Osc, PRE0_256 + TMR0_HFINTOSC ,  POST0_2</pre><p><span class="strong"><strong>Differences in Timer0 Operations</strong></span></p><p>The section refers to chips with a 8/16-bit Timer0.</p><p>When these chips are operating in 8-bit mode, Timer0 behaves much like Timers2/4/6. In 8-bit mode the TMR0H register does not increment. It instead becomes the Period or Match register and is aliased as "PR0"  (Period Register 0).</p><p>In 8-bit mode, Timer0 does not technically overflow. Instead when TMR0L increments and matches the value in the PR0 register, TMR0L is reset to 0. The interrupt flag bit (TMR0IF) bit is then set (based upon Postscaler).</p><p>The default value in the PR0 "match register" is 255.  This value can be set/changed in the user program to set/change the timer period. This can be used to fine tune the timer period.
<br>
<br></p><p><span class="strong"><strong>Timer 0 mandated constants:</strong></span></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>source</em></span></code></p></td><td align="left" valign="top"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code> or <code class="literal">Ext</code> where <code class="literal">Osc</code> is an internal oscillator and <code class="literal">Ext</code> is an external oscillator.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer.  See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.
You may also be required to specify one of the following clock sources.<br>
<br>
<code class="literal">TMR0_CLC1</code><br>
<code class="literal">TMR0_SOSC</code><br>
<code class="literal">TMR0_LFINTOSC</code><br>
<code class="literal">TMR0_HFINTOSC</code><br>
<code class="literal">TMR0_FOSC4</code><br>
<code class="literal">TMR0_T0CKIPPS_Inverted</code><br>
<code class="literal">TMR0_T0CKIPPS_True</code><br>
<br>
</p><p>You should use a simple addition to concatenate the prescaler with a specific clock source. For example.
<br>
<br>
<code class="literal">PRE0_16</code> + <code class="literal">TMR0_HFINTOSC</code>
<br>
 <br></p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code></p></td><td align="left" valign="top"><p>See the tables below for permitted values for Microchip.<br>
Also, refer to the specific datasheet <code class="literal"><span class="emphasis"><em>postcaler</em></span></code> values.</p></td></tr></tbody></table></div><p><br>
<br>
Microchip PIC microcontrollers where the <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> rate select bits are in the range of 1 to 32768  you should use one of the following constants.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PRE0_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">PRE0_2</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PRE0_4</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PRE0_8</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PRE0_16</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:32</p></td><td align="left" valign="top"><p><code class="literal">PRE0_32</code></p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PRE0_64</code></p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:128</p></td><td align="left" valign="top"><p><code class="literal">PRE0_128</code></p></td><td align="center" valign="top"><p>7</p></td></tr><tr><td align="center" valign="top"><p>1:256</p></td><td align="left" valign="top"><p><code class="literal">PRE0_256</code></p></td><td align="center" valign="top"><p>8</p></td></tr><tr><td align="center" valign="top"><p>1:512</p></td><td align="left" valign="top"><p><code class="literal">PRE0_512</code></p></td><td align="center" valign="top"><p>9</p></td></tr><tr><td align="center" valign="top"><p>1:1024</p></td><td align="left" valign="top"><p><code class="literal">PRE0_1024</code></p></td><td align="center" valign="top"><p>10</p></td></tr><tr><td align="center" valign="top"><p>1:2048</p></td><td align="left" valign="top"><p><code class="literal">PRE0_2048</code></p></td><td align="center" valign="top"><p>11</p></td></tr><tr><td align="center" valign="top"><p>1:4096</p></td><td align="left" valign="top"><p><code class="literal">PRE0_4096</code></p></td><td align="center" valign="top"><p>12</p></td></tr><tr><td align="center" valign="top"><p>1:8192</p></td><td align="left" valign="top"><p><code class="literal">PRE0_8192</code></p></td><td align="center" valign="top"><p>13</p></td></tr><tr><td align="center" valign="top"><p>1:16384</p></td><td align="left" valign="top"><p><code class="literal">PRE0_16384</code></p></td><td align="center" valign="top"><p>14</p></td></tr><tr><td align="center" valign="top"><p>1:32768</p></td><td align="left" valign="top"><p><code class="literal">PRE0_32768</code></p></td><td align="center" valign="top"><p>15</p></td></tr></tbody></table></div><p>These correspond to a prescaler of between 1:1 and 1:32768 of the oscillator
speed where the oscillator speed is (FOSC/4). The prescaler applies to
both the internal oscillator or the external clock.</p><p><br>
<br></p><p>On Microchip PIC microcontrollers where the <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> rate select bits are in the range of 2 to 256  you should use one of the following constants.  If the <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> rate select bits are in the range of 1 to 32768 then see the subsequent table.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">PS0_2</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS0_4</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS0_8</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS0_16</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:32</p></td><td align="left" valign="top"><p><code class="literal">PS0_32</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS0_64</code></p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:128</p></td><td align="left" valign="top"><p><code class="literal">PS0_128</code></p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:256</p></td><td align="left" valign="top"><p><code class="literal">PS0_256</code></p></td><td align="center" valign="top"><p>7</p></td></tr></tbody></table></div><p>These correspond to a prescaler of between 1:2 and 1:256 of the oscillator
speed where the oscillator speed is (FOSC/4). The prescaler applies to
both the internal oscillator or the external clock.
<br>
<br></p><p>On Microchip PIC microcontroller that require <code class="literal"><span class="emphasis"><em>postscaler</em></span></code> is can be one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Postcaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Use Numeric Constant</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">POST0_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">POST0_2</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:3</p></td><td align="left" valign="top"><p><code class="literal">POST0_3</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">POST0_4</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:5</p></td><td align="left" valign="top"><p><code class="literal">POST0_5</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:6</p></td><td align="left" valign="top"><p><code class="literal">POST0_6</code></p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:7</p></td><td align="left" valign="top"><p><code class="literal">POST0_7</code></p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">POST0_8</code></p></td><td align="center" valign="top"><p>7</p></td></tr><tr><td align="center" valign="top"><p>1:9</p></td><td align="left" valign="top"><p><code class="literal">POST0_9</code></p></td><td align="center" valign="top"><p>8</p></td></tr><tr><td align="center" valign="top"><p>1:10</p></td><td align="left" valign="top"><p><code class="literal">POST0_10</code></p></td><td align="center" valign="top"><p>9</p></td></tr><tr><td align="center" valign="top"><p>1:11</p></td><td align="left" valign="top"><p><code class="literal">POST0_11</code></p></td><td align="center" valign="top"><p>10</p></td></tr><tr><td align="center" valign="top"><p>1:12</p></td><td align="left" valign="top"><p><code class="literal">POST0_12</code></p></td><td align="center" valign="top"><p>11</p></td></tr><tr><td align="center" valign="top"><p>1:13</p></td><td align="left" valign="top"><p><code class="literal">POST0_13</code></p></td><td align="center" valign="top"><p>12</p></td></tr><tr><td align="center" valign="top"><p>1:14</p></td><td align="left" valign="top"><p><code class="literal">POST0_14</code></p></td><td align="center" valign="top"><p>13</p></td></tr><tr><td align="center" valign="top"><p>1:15</p></td><td align="left" valign="top"><p><code class="literal">POST0_15</code></p></td><td align="center" valign="top"><p>14</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">POST0_16</code></p></td><td align="center" valign="top"><p>15</p></td></tr></tbody></table></div><p><br>
<br>
<br></p><p><span class="strong"><strong>Example:</strong></span></p><p>This code uses Timer 0 and On Interrupt to flash an LED.</p><pre class="screen">/*

Remember four things to setup a timer.

1.  InitTimer0 source, prescaler + clocksource, postscaler

2.  SetTimer (byte_value, value ), or
    SetTimer (word_value [where the High byte sets the timer], value )

3.  StartTimer 0

    and, optionally use

4.  ClearTimer 0

*/

    'Chip Settings.
    #CHIP 16f18313, 32

    Dir porta.1 Out

    'Setup the timer.
    '          Source, Prescaler  + Clock Source    , Postscaler
    InitTimer0 Osc,    PRE0_16384 + TMR0_HFINTOSC   , POST0_11

    ' Set the Timer start value.  Use the HIGH byte of the word when using an 8/16bit timer in 8 bit mode
    SetTimer ( 0, 0x5800 )

    ' Start the Timer by writing to TMR0ON bit
    StartTimer 0


    Do
        Wait While TMR0IF = 0
        ' Clearing timer flag
        TMR0IF = 0
        porta.1 = ! porta.1

    Loop</pre><p><span class="strong"><strong>Supported in &lt;TIMER.H&gt;</strong></span></p><p>See also  see: <a class="link" href="_inittimer0.html" title="InitTimer0">InitTimer0</a> for microcontroller with only an 8 bit Timer 0 module.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="inittimer0_8bit_16bit"></span>InitTimer0 8bit/16bit

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    InitTimer0 source, prescaler + clocksource, postscaler
```

Timer are useful as timers can generate interrupts. Timers can be used
in conjunction with `On Interrupt` to run a section of code when a
specific timer event occurs. Example events are when the timer matches a
specific value, or, the timer resets to a zero value. For more details
on timer events see `On Interrupt`.

<span class="strong">**Command Availability:**</span>

Available on microcontrollers with a Timer 0 where the timer has the
capability of operating as an 8 bit or 16 bit timer.   This type of
Timer 0 can be found on Microchip PIC 18(L)F, as well as small number of
18C and 16(L)F microcontrollers.   These timers can be configured for
either 8-bit or 16-bit operation.

You may need to refer to the datasheet for your microcontroller to
determine if it supports both 8-bit and 16-bit operations.

<span class="strong">**Explanation for 8-bit timer:**</span>

The default operation is as an 8-bit timer.   `InitTimer0` will set up
timer 0.

Parameters are required as shown in the table below:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">source</code></p></td>
<td style="text-align: left;"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code> or <code class="literal">Ext</code> where`Osc` is an internal oscillator and <code class="literal">Ext</code> is an external oscillator.</p>
<p><br />
<br />
<code class="literal">Osc</code> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).  This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).</p>
<p><code class="literal">Ext</code> - Selects the clock source attached to a specific exernal interrupt input port.  This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">prescaler</code></p></td>
<td style="text-align: left;"><p>The value of the prescaler for this specific timer, <span class="strong"><strong>and</strong></span>, the clocksource</p>
<p>See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">postscaler</code></p></td>
<td style="text-align: left;"><p>The value of the postscaler for this specific timer.</p>
<p>See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.</p></td>
</tr>
</tbody>
</table>

</div>

<span class="emphasis">*8 bit Example:*</span>

The example show in the `osc` as an internal source, a `prescaler` value
of 256 witht the HFINTOSC `clocksource` and a `postscaler` value of 2

``` screen
    InitTimer0 Osc, PRE0_256 + TMR0_HFINTOSC ,  POST0_2
    'also, note when in 8-bit mode you MUST set the 8bit timer value to the upper byte of a WORD, when setting the `SetTimer`
    SetTimer 0, 0x5800   'Setting the HIGH byte!!!
```

<span class="emphasis">*16 bit Example:*</span>

To use the 16 bit timer you need to add the constant
`#define TMR0_16bit`.

The example show in the `osc` as an internal source, a `prescaler` value
of 256 witht the HFINTOSC `clocksource` and a `postscaler` value of 2

``` screen
    #define TMR0_16bit
    InitTimer0 Osc, PRE0_256 + TMR0_HFINTOSC ,  POST0_2
```

<span class="strong">**Differences in Timer0 Operations**</span>

The section refers to chips with a 8/16-bit Timer0.

When these chips are operating in 8-bit mode, Timer0 behaves much like
Timers2/4/6. In 8-bit mode the TMR0H register does not increment. It
instead becomes the Period or Match register and is aliased as "PR0"
(Period Register 0).

In 8-bit mode, Timer0 does not technically overflow. Instead when TMR0L
increments and matches the value in the PR0 register, TMR0L is reset to
0. The interrupt flag bit (TMR0IF) bit is then set (based upon
Postscaler).

The default value in the PR0 "match register" is 255. This value can be
set/changed in the user program to set/change the timer period. This can
be used to fine tune the timer period.  
  

<span class="strong">**Timer 0 mandated constants:**</span>

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">source</code></p></td>
<td style="text-align: left;"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code> or <code class="literal">Ext</code> where <code class="literal">Osc</code> is an internal oscillator and <code class="literal">Ext</code> is an external oscillator.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">prescaler</code></p></td>
<td style="text-align: left;"><p>The value of the prescaler for this specific timer. See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers. You may also be required to specify one of the following clock sources.<br />
<br />
<code class="literal">TMR0_CLC1</code><br />
<code class="literal">TMR0_SOSC</code><br />
<code class="literal">TMR0_LFINTOSC</code><br />
<code class="literal">TMR0_HFINTOSC</code><br />
<code class="literal">TMR0_FOSC4</code><br />
<code class="literal">TMR0_T0CKIPPS_Inverted</code><br />
<code class="literal">TMR0_T0CKIPPS_True</code><br />
<br />
</p>
<p>You should use a simple addition to concatenate the prescaler with a specific clock source. For example.<br />
<br />
<code class="literal">PRE0_16</code> + <code class="literal">TMR0_HFINTOSC</code><br />
<br />
</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">postscaler</code></p></td>
<td style="text-align: left;"><p>See the tables below for permitted values for Microchip.<br />
Also, refer to the specific datasheet <code class="literal">postcaler</code> values.</p></td>
</tr>
</tbody>
</table>

</div>

  
  
Microchip PIC microcontrollers where the `prescaler` rate select bits
are in the range of 1 to 32768 you should use one of the following
constants.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:2</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_2</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_4</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_8</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_16</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:32</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_32</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_64</code></p></td>
<td style="text-align: center;"><p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:128</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_128</code></p></td>
<td style="text-align: center;"><p>7</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:256</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_256</code></p></td>
<td style="text-align: center;"><p>8</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:512</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_512</code></p></td>
<td style="text-align: center;"><p>9</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:1024</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_1024</code></p></td>
<td style="text-align: center;"><p>10</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:2048</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_2048</code></p></td>
<td style="text-align: center;"><p>11</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:4096</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_4096</code></p></td>
<td style="text-align: center;"><p>12</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:8192</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_8192</code></p></td>
<td style="text-align: center;"><p>13</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16384</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_16384</code></p></td>
<td style="text-align: center;"><p>14</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:32768</p></td>
<td style="text-align: left;"><p><code class="literal">PRE0_32768</code></p></td>
<td style="text-align: center;"><p>15</p></td>
</tr>
</tbody>
</table>

</div>

These correspond to a prescaler of between 1:1 and 1:32768 of the
oscillator speed where the oscillator speed is (FOSC/4). The prescaler
applies to both the internal oscillator or the external clock.

  
  

On Microchip PIC microcontrollers where the `prescaler` rate select bits
are in the range of 2 to 256 you should use one of the following
constants. If the `prescaler` rate select bits are in the range of 1 to
32768 then see the subsequent table.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:2</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_2</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_4</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_8</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_16</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:32</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_32</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_64</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:128</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_128</code></p></td>
<td style="text-align: center;"><p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:256</p></td>
<td style="text-align: left;"><p><code class="literal">PS0_256</code></p></td>
<td style="text-align: center;"><p>7</p></td>
</tr>
</tbody>
</table>

</div>

These correspond to a prescaler of between 1:2 and 1:256 of the
oscillator speed where the oscillator speed is (FOSC/4). The prescaler
applies to both the internal oscillator or the external clock.  
  

On Microchip PIC microcontroller that require `postscaler` is can be one
of the following constants where the Postscaler Rate Select bits are in
the range of 1 to 16.

<div class="informaltable">

| <span class="strong">**Postcaler Value**</span> | <span class="strong">**Primary GCB Constant**</span> | <span class="strong">**Use Numeric Constant**</span> |
|:-----------------------------------------------:|:-----------------------------------------------------|:----------------------------------------------------:|
|                       1:1                       | `POST0_1`                                            |                          0                           |
|                       1:2                       | `POST0_2`                                            |                          1                           |
|                       1:3                       | `POST0_3`                                            |                          2                           |
|                       1:4                       | `POST0_4`                                            |                          3                           |
|                       1:5                       | `POST0_5`                                            |                          4                           |
|                       1:6                       | `POST0_6`                                            |                          5                           |
|                       1:7                       | `POST0_7`                                            |                          6                           |
|                       1:8                       | `POST0_8`                                            |                          7                           |
|                       1:9                       | `POST0_9`                                            |                          8                           |
|                      1:10                       | `POST0_10`                                           |                          9                           |
|                      1:11                       | `POST0_11`                                           |                          10                          |
|                      1:12                       | `POST0_12`                                           |                          11                          |
|                      1:13                       | `POST0_13`                                           |                          12                          |
|                      1:14                       | `POST0_14`                                           |                          13                          |
|                      1:15                       | `POST0_15`                                           |                          14                          |
|                      1:16                       | `POST0_16`                                           |                          15                          |

</div>

  
  
  

<span class="strong">**Example:**</span>

This code uses Timer 0 and On Interrupt to flash an LED.

``` screen
/*

Remember four things to setup a timer.

1.  InitTimer0 source, prescaler + clocksource, postscaler

2.  SetTimer (byte_value, value ), or
    SetTimer (word_value [where the High byte sets the timer], value )

3.  StartTimer 0

    and, optionally use

4.  ClearTimer 0

*/

    'Chip Settings.
    #CHIP 16f18313, 32

    Dir porta.1 Out

    'Setup the timer.
    '          Source, Prescaler  + Clock Source    , Postscaler
    InitTimer0 Osc,    PRE0_16384 + TMR0_HFINTOSC   , POST0_11

    ' Set the Timer start value.  Use the HIGH byte of the word when using an 8/16bit timer in 8 bit mode
    SetTimer ( 0, 0x5800 )

    ' Start the Timer by writing to TMR0ON bit
    StartTimer 0


    Do
        Wait While TMR0IF = 0
        ' Clearing timer flag
        TMR0IF = 0
        porta.1 = ! porta.1

    Loop
```

<span class="strong">**Supported in &lt;TIMER.H&gt;**</span>

See also see:
<a href="inittimer0" class="link" title="InitTimer0">InitTimer0</a>
for microcontroller with only an 8 bit Timer 0 module.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitTimer1</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_inittimer0_8bit_16bit.html" title="InitTimer0 8bit/16bit"><link rel="next" href="_inittimer2.html" title="InitTimer2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inittimer1"></a>InitTimer1</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    InitTimer1 <span class="emphasis"><em>source, prescaler</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a Timer 1 module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">InitTimer1</code> will set up timer 1.</p><p>Parameters are required as detailed in the table below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>source</em></span></code></p></td><td align="left" valign="top"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code>, <code class="literal">Ext</code> or <code class="literal">ExtOsc</code> where:<br>
<code class="literal">Osc</code> is an internal oscillator.<br>
<code class="literal">Ext</code> is an external oscillator.<br>
<br>
<br>
<code class="literal">Osc</code> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&nbsp;&nbsp;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</p><p><code class="literal">Ext</code> - Selects the clock source attached to a specific exernal interrupt input port.&nbsp;&nbsp;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.
<br>
<br>
</p><p><code class="literal">ExtOsc</code> is an external oscillator and only available on a Microchip PIC microcontroller.
</p><p></p><p></p><p>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources.  This includes, but limited to,  the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller  series.  On these devices the clock source can be one of the following:
</p><p><code class="literal">Osc</code> is an internal oscillator which is the same source as <code class="literal">FOSC4</code>.<br>
<code class="literal">Ext</code>  is an external oscillator which is the same source as <code class="literal">TxXKIPPS</code>.<br>
<code class="literal">ExtOsc</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br>
<code class="literal">FOSC</code> is an internal oscillator which is the Frequency of the OSCillator.<br>
<code class="literal">FOSC4</code> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<br>
<code class="literal">SOSC</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br>
<code class="literal">MFINTOSC</code> is an internal 500KHz internal clock oscillator.<br>
<code class="literal">LFINTOSC</code>  is an internal 31Khz internal clock oscillator.<br>
<code class="literal">HFINTOSC</code> is an oscillator as specified within the datasheet for each specific microcontroller.<br>
<code class="literal">TxCKIPPS</code> is an oscillator input on TxCKIPPS Pin.<br></p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer.  See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</p></td></tr></tbody></table></div><p>When the timer overflows an interrupt event will be generated.
This interrupt event can be used in conjunction with <code class="literal">On Interrupt</code> to run a section of code when the interrupt event occurs.
<br>
<br>
<br>
<br>
<span class="strong"><strong>Microchip PIC microcontrollers:</strong></span></p><p>On Microchip PIC microcontrollers <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> must be one of the following constants:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS1_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">PS1_2</code></p></td><td align="center" valign="top"><p>16</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS1_4</code></p></td><td align="center" valign="top"><p>32</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS1_8</code></p></td><td align="center" valign="top"><p>48</p></td></tr></tbody></table></div><p>These correspond to a prescaler of between 1:2 and 1:8 of the oscillator (FOSC/4)
speed. The prescaler will apply to either the oscillator or the external
clock input.
<br>
<br>
<br>
<br>
<span class="strong"><strong>Atmel AVR microcontrollers:</strong></span></p><p>On the majority of Atmel AVR microcontrollers  <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> must be one of the following constants:</p><p>The prescaler will only apply when the timer is driven from the <code class="literal">Osc</code> the internal oscillator - the prescaler has no effect when the external clock source is specified.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Secondary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:0</p></td><td align="left" valign="top"><p><code class="literal">PS_0</code></p></td><td align="left" valign="top"><p><code class="literal">PS_1_0</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS_1</code></p></td><td align="left" valign="top"><p><code class="literal">PS_1_1</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS_8</code></p></td><td align="left" valign="top"><p><code class="literal">PS_1_8</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS_64</code></p></td><td align="left" valign="top"><p><code class="literal">PS_1_64</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:256</p></td><td align="left" valign="top"><p><code class="literal">PS_256</code></p></td><td align="left" valign="top"><p><code class="literal">PS1_256</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:1024</p></td><td align="left" valign="top"><p><code class="literal">PS_1024</code></p></td><td align="left" valign="top"><p><code class="literal">PS_1_1024</code></p></td><td align="center" valign="top"><p>5</p></td></tr></tbody></table></div><p><br>
<br>
<br></p><p>On Atmel AVR ATtiny15/25/45/85/216/461/861 microcontrollers <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> must be one of the following constants:</p><p>The prescaler will only apply when the timer is driven from the <code class="literal">Osc</code> the internal oscillator - the prescaler has no effect when the external clock source is specified.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:0</p></td><td align="left" valign="top"><p><code class="literal">PS_1_0</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS_1_1</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">PS_1_2</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS_1_4</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS_1_8</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS_1_16</code></p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:32</p></td><td align="left" valign="top"><p><code class="literal">PS_1_32</code></p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS_1_64</code></p></td><td align="center" valign="top"><p>7</p></td></tr><tr><td align="center" valign="top"><p>1:128</p></td><td align="left" valign="top"><p><code class="literal">PS_1_128</code></p></td><td align="center" valign="top"><p>8</p></td></tr><tr><td align="center" valign="top"><p>1:256</p></td><td align="left" valign="top"><p><code class="literal">PS_1_256</code></p></td><td align="center" valign="top"><p>9</p></td></tr><tr><td align="center" valign="top"><p>1:512</p></td><td align="left" valign="top"><p><code class="literal">PS_1_512</code></p></td><td align="center" valign="top"><p>10</p></td></tr><tr><td align="center" valign="top"><p>1:1024</p></td><td align="left" valign="top"><p><code class="literal">PS_1_1024</code></p></td><td align="center" valign="top"><p>11</p></td></tr><tr><td align="center" valign="top"><p>1:2048</p></td><td align="left" valign="top"><p><code class="literal">PS_1_2048</code></p></td><td align="center" valign="top"><p>12</p></td></tr><tr><td align="center" valign="top"><p>1:4096</p></td><td align="left" valign="top"><p><code class="literal">PS_1_4096</code></p></td><td align="center" valign="top"><p>13</p></td></tr><tr><td align="center" valign="top"><p>1:8192</p></td><td align="left" valign="top"><p><code class="literal">PS_1_8192</code></p></td><td align="center" valign="top"><p>14</p></td></tr><tr><td align="center" valign="top"><p>1:16384</p></td><td align="left" valign="top"><p><code class="literal">PS_1_16384</code></p></td><td align="center" valign="top"><p>15</p></td></tr></tbody></table></div><p><br>
<br>
<span class="strong"><strong>Example 1 (Microchip):</strong></span></p><p>This example will measure that time that a switch is depressed (or on) and will write the results to the EEPROM.</p><pre class="screen">    #chip 16F819, 20
    #define Switch PORTA.0

    Dir Switch In
    DataCount = 0

    'Initilise Timer 1
    InitTimer1 Osc, PS1_8

    Dim TimerValue As Word

    Do
        ClearTimer 1
        Wait Until Switch = On
        StartTimer 1
        Wait Until Switch = Off
        StopTimer 1

        'Read the timer
        TimerValue = Timer1

        'Log the timer value
        EPWrite(DataCount, TimerValue_H)
        EPWrite(DataCount + 1, TimerValue)
        DataCount += 2
    Loop</pre><p><br>
<br>
<span class="strong"><strong>Example 2 (Atmel AVR):</strong></span></p><p>This example will flash the yellow LED on an Arduino Uno (R3) once every second.</p><pre class="literallayout">#Chip mega328p, 16  'Using Arduino Uno R3</pre><pre class="literallayout">#define LED PORTB.5
Dir LED OUT</pre><pre class="literallayout">Inittimer1  OSC, PS_256
Starttimer 1
Settimer 1, 3200  ;Preload Timer</pre><pre class="literallayout">On Interrupt Timer1Overflow Call Flash_LED</pre><pre class="literallayout">Do
    'Wait for interrupt
loop</pre><pre class="literallayout">Sub Flash_LED
   Settimer 1, 3200   'Preload timer
   pulseout LED, 100 ms
End Sub</pre><p><span class="strong"><strong>Supported in &lt;TIMER.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inittimer1"></span>InitTimer1

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    InitTimer1 source, prescaler
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a Timer 1 module.

<span class="strong">**Explanation:**</span>

`InitTimer1` will set up timer 1.

Parameters are required as detailed in the table below:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">source</code></p></td>
<td style="text-align: left;"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code>, <code class="literal">Ext</code> or <code class="literal">ExtOsc</code> where:<br />
<code class="literal">Osc</code> is an internal oscillator.<br />
<code class="literal">Ext</code> is an external oscillator.<br />
<br />
<br />
<code class="literal">Osc</code> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).  This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).</p>
<p><code class="literal">Ext</code> - Selects the clock source attached to a specific exernal interrupt input port.  This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.<br />
<br />
</p>
<p><code class="literal">ExtOsc</code> is an external oscillator and only available on a Microchip PIC microcontroller.</p>
<p>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources. This includes, but limited to, the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller series. On these devices the clock source can be one of the following:</p>
<p><code class="literal">Osc</code> is an internal oscillator which is the same source as <code class="literal">FOSC4</code>.<br />
<code class="literal">Ext</code> is an external oscillator which is the same source as <code class="literal">TxXKIPPS</code>.<br />
<code class="literal">ExtOsc</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br />
<code class="literal">FOSC</code> is an internal oscillator which is the Frequency of the OSCillator.<br />
<code class="literal">FOSC4</code> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<br />
<code class="literal">SOSC</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br />
<code class="literal">MFINTOSC</code> is an internal 500KHz internal clock oscillator.<br />
<code class="literal">LFINTOSC</code> is an internal 31Khz internal clock oscillator.<br />
<code class="literal">HFINTOSC</code> is an oscillator as specified within the datasheet for each specific microcontroller.<br />
<code class="literal">TxCKIPPS</code> is an oscillator input on TxCKIPPS Pin.<br />
</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">prescaler</code></p></td>
<td style="text-align: left;"><p>The value of the prescaler for this specific timer. See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</p></td>
</tr>
</tbody>
</table>

</div>

When the timer overflows an interrupt event will be generated. This
interrupt event can be used in conjunction with `On Interrupt` to run a
section of code when the interrupt event occurs.  
  
  
  
<span class="strong">**Microchip PIC microcontrollers:**</span>

On Microchip PIC microcontrollers `prescaler` must be one of the
following constants:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS1_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:2</p></td>
<td style="text-align: left;"><p><code class="literal">PS1_2</code></p></td>
<td style="text-align: center;"><p>16</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS1_4</code></p></td>
<td style="text-align: center;"><p>32</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS1_8</code></p></td>
<td style="text-align: center;"><p>48</p></td>
</tr>
</tbody>
</table>

</div>

These correspond to a prescaler of between 1:2 and 1:8 of the oscillator
(FOSC/4) speed. The prescaler will apply to either the oscillator or the
external clock input.  
  
  
  
<span class="strong">**Atmel AVR microcontrollers:**</span>

On the majority of Atmel AVR microcontrollers `prescaler` must be one of
the following constants:

The prescaler will only apply when the timer is driven from the `Osc`
the internal oscillator - the prescaler has no effect when the external
clock source is specified.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Secondary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:0</p></td>
<td style="text-align: left;"><p><code class="literal">PS_0</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_0</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_1</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS_8</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_8</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS_64</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_64</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:256</p></td>
<td style="text-align: left;"><p><code class="literal">PS_256</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS1_256</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:1024</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1024</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_1024</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
</tbody>
</table>

</div>

  
  
  

On Atmel AVR ATtiny15/25/45/85/216/461/861 microcontrollers `prescaler`
must be one of the following constants:

The prescaler will only apply when the timer is driven from the `Osc`
the internal oscillator - the prescaler has no effect when the external
clock source is specified.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:0</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_0</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_1</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:2</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_2</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_4</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_8</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_16</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:32</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_32</code></p></td>
<td style="text-align: center;"><p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_64</code></p></td>
<td style="text-align: center;"><p>7</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:128</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_128</code></p></td>
<td style="text-align: center;"><p>8</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:256</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_256</code></p></td>
<td style="text-align: center;"><p>9</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:512</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_512</code></p></td>
<td style="text-align: center;"><p>10</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:1024</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_1024</code></p></td>
<td style="text-align: center;"><p>11</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:2048</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_2048</code></p></td>
<td style="text-align: center;"><p>12</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:4096</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_4096</code></p></td>
<td style="text-align: center;"><p>13</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:8192</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_8192</code></p></td>
<td style="text-align: center;"><p>14</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:16384</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1_16384</code></p></td>
<td style="text-align: center;"><p>15</p></td>
</tr>
</tbody>
</table>

</div>

  
  
<span class="strong">**Example 1 (Microchip):**</span>

This example will measure that time that a switch is depressed (or on)
and will write the results to the EEPROM.

``` screen
    #chip 16F819, 20
    #define Switch PORTA.0

    Dir Switch In
    DataCount = 0

    'Initilise Timer 1
    InitTimer1 Osc, PS1_8

    Dim TimerValue As Word

    Do
        ClearTimer 1
        Wait Until Switch = On
        StartTimer 1
        Wait Until Switch = Off
        StopTimer 1

        'Read the timer
        TimerValue = Timer1

        'Log the timer value
        EPWrite(DataCount, TimerValue_H)
        EPWrite(DataCount + 1, TimerValue)
        DataCount += 2
    Loop
```

  
  
<span class="strong">**Example 2 (Atmel AVR):**</span>

This example will flash the yellow LED on an Arduino Uno (R3) once every
second.

``` literallayout
#Chip mega328p, 16  'Using Arduino Uno R3
```

``` literallayout
#define LED PORTB.5
Dir LED OUT
```

``` literallayout
Inittimer1  OSC, PS_256
Starttimer 1
Settimer 1, 3200  ;Preload Timer
```

``` literallayout
On Interrupt Timer1Overflow Call Flash_LED
```

``` literallayout
Do
    'Wait for interrupt
loop
```

``` literallayout
Sub Flash_LED
   Settimer 1, 3200   'Preload timer
   pulseout LED, 100 ms
End Sub
```

<span class="strong">**Supported in &lt;TIMER.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitTimer10</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_inittimer8.html" title="InitTimer8"><link rel="next" href="_inittimer12.html" title="InitTimer12"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inittimer10"></a>InitTimer10</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">InitTimer10 <span class="emphasis"><em>prescaler</em></span>, <span class="emphasis"><em>postscaler</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on Microchip microcontrollers with a Timer 10 module.</p><p><br>
<br></p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Parameters for this timer are detailed in the table below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer.  See the tables below for permitted values.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the postscaler for this specific timer.  See the tables below for permitted values.</p></td></tr></tbody></table></div><p><br>
<br></p><p><code class="literal">prescaler</code> can be one of the following settings:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS10_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS10_4</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS10_16</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS10_64</code></p></td><td align="center" valign="top"><p>3</p></td></tr></tbody></table></div><p>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.</p><p><br>
<br></p><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</p><p>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Postcaler Value</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Use Numeric Constant</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1 Postscaler</p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2 Postscaler</p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:3 Postscaler</p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:4 Postscaler</p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:5 Postscaler</p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:6 Postscaler</p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:7 Postscaler</p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:8 Postscaler</p></td><td align="center" valign="top"><p>7</p></td></tr><tr><td align="center" valign="top"><p>1:9 Postscaler</p></td><td align="center" valign="top"><p>8</p></td></tr><tr><td align="center" valign="top"><p>1:10 Postscaler</p></td><td align="center" valign="top"><p>9</p></td></tr><tr><td align="center" valign="top"><p>1:11 Postscaler</p></td><td align="center" valign="top"><p>10</p></td></tr><tr><td align="center" valign="top"><p>1:12 Postscaler</p></td><td align="center" valign="top"><p>11</p></td></tr><tr><td align="center" valign="top"><p>1:13 Postscaler</p></td><td align="center" valign="top"><p>12</p></td></tr><tr><td align="center" valign="top"><p>1:14 Postscaler</p></td><td align="center" valign="top"><p>13</p></td></tr><tr><td align="center" valign="top"><p>1:15 Postscaler</p></td><td align="center" valign="top"><p>14</p></td></tr><tr><td align="center" valign="top"><p>1:16 Postscaler</p></td><td align="center" valign="top"><p>15</p></td></tr></tbody></table></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inittimer10"></span>InitTimer10

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
InitTimer10 prescaler, postscaler
```

<span class="strong">**Command Availability:**</span>

Available on Microchip microcontrollers with a Timer 10 module.

  
  

<span class="strong">**Explanation:**</span>

Parameters for this timer are detailed in the table below:

<div class="informaltable">

| Parameter    | Description                                                                                     |
|:-------------|:------------------------------------------------------------------------------------------------|
| `prescaler`  | The value of the prescaler for this specific timer. See the tables below for permitted values.  |
| `postscaler` | The value of the postscaler for this specific timer. See the tables below for permitted values. |

</div>

  
  

`prescaler` can be one of the following settings:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS10_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS10_4</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS10_16</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS10_64</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
</tbody>
</table>

</div>

Note that a 1:64 prescale is only avaialable on certain midrange
microcontrollers. Please refer to the datasheet to determine if a 1:64
prescale is supported by a spectific microcontroller.

  
  

`postscaler` slows the rate of the interrupt generation (or WDT reset)
from a counter/timer by dividing it down.

On Microchip PIC microcontroller one of the following constants where
the Postscaler Rate Select bits are in the range of 1 to 16.

<div class="informaltable">

| <span class="strong">**Postcaler Value**</span> | <span class="strong">**Use Numeric Constant**</span> |
|:-----------------------------------------------:|:----------------------------------------------------:|
|                 1:1 Postscaler                  |                          0                           |
|                 1:2 Postscaler                  |                          1                           |
|                 1:3 Postscaler                  |                          2                           |
|                 1:4 Postscaler                  |                          3                           |
|                 1:5 Postscaler                  |                          4                           |
|                 1:6 Postscaler                  |                          5                           |
|                 1:7 Postscaler                  |                          6                           |
|                 1:8 Postscaler                  |                          7                           |
|                 1:9 Postscaler                  |                          8                           |
|                 1:10 Postscaler                 |                          9                           |
|                 1:11 Postscaler                 |                          10                          |
|                 1:12 Postscaler                 |                          11                          |
|                 1:13 Postscaler                 |                          12                          |
|                 1:14 Postscaler                 |                          13                          |
|                 1:15 Postscaler                 |                          14                          |
|                 1:16 Postscaler                 |                          15                          |

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitTimer12</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_inittimer10.html" title="InitTimer10"><link rel="next" href="_settimer.html" title="Settimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inittimer12"></a>InitTimer12</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">InitTimer12 <span class="emphasis"><em>prescaler</em></span>, <span class="emphasis"><em>postscaler</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on Microchip microcontrollers with a Timer 12 module.</p><p><br>
<br></p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Parameters for this timer are detailed in the table below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer.  See the tables below for permitted values.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the postscaler for this specific timer.  See the tables below for permitted values.</p></td></tr></tbody></table></div><p><br>
<br></p><p><code class="literal">prescaler</code> can be one of the following settings:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS12_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS12_4</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS12_16</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS12_64</code></p></td><td align="center" valign="top"><p>3</p></td></tr></tbody></table></div><p>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.</p><p><br>
<br></p><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</p><p>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Postcaler Value</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Use Numeric Constant</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1 Postscaler</p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2 Postscaler</p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:3 Postscaler</p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:4 Postscaler</p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:5 Postscaler</p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:6 Postscaler</p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:7 Postscaler</p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:8 Postscaler</p></td><td align="center" valign="top"><p>7</p></td></tr><tr><td align="center" valign="top"><p>1:9 Postscaler</p></td><td align="center" valign="top"><p>8</p></td></tr><tr><td align="center" valign="top"><p>1:10 Postscaler</p></td><td align="center" valign="top"><p>9</p></td></tr><tr><td align="center" valign="top"><p>1:11 Postscaler</p></td><td align="center" valign="top"><p>10</p></td></tr><tr><td align="center" valign="top"><p>1:12 Postscaler</p></td><td align="center" valign="top"><p>11</p></td></tr><tr><td align="center" valign="top"><p>1:13 Postscaler</p></td><td align="center" valign="top"><p>12</p></td></tr><tr><td align="center" valign="top"><p>1:14 Postscaler</p></td><td align="center" valign="top"><p>13</p></td></tr><tr><td align="center" valign="top"><p>1:15 Postscaler</p></td><td align="center" valign="top"><p>14</p></td></tr><tr><td align="center" valign="top"><p>1:16 Postscaler</p></td><td align="center" valign="top"><p>15</p></td></tr></tbody></table></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inittimer12"></span>InitTimer12

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
InitTimer12 prescaler, postscaler
```

<span class="strong">**Command Availability:**</span>

Available on Microchip microcontrollers with a Timer 12 module.

  
  

<span class="strong">**Explanation:**</span>

Parameters for this timer are detailed in the table below:

<div class="informaltable">

| Parameter    | Description                                                                                     |
|:-------------|:------------------------------------------------------------------------------------------------|
| `prescaler`  | The value of the prescaler for this specific timer. See the tables below for permitted values.  |
| `postscaler` | The value of the postscaler for this specific timer. See the tables below for permitted values. |

</div>

  
  

`prescaler` can be one of the following settings:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS12_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS12_4</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS12_16</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS12_64</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
</tbody>
</table>

</div>

Note that a 1:64 prescale is only avaialable on certain midrange
microcontrollers. Please refer to the datasheet to determine if a 1:64
prescale is supported by a spectific microcontroller.

  
  

`postscaler` slows the rate of the interrupt generation (or WDT reset)
from a counter/timer by dividing it down.

On Microchip PIC microcontroller one of the following constants where
the Postscaler Rate Select bits are in the range of 1 to 16.

<div class="informaltable">

| <span class="strong">**Postcaler Value**</span> | <span class="strong">**Use Numeric Constant**</span> |
|:-----------------------------------------------:|:----------------------------------------------------:|
|                 1:1 Postscaler                  |                          0                           |
|                 1:2 Postscaler                  |                          1                           |
|                 1:3 Postscaler                  |                          2                           |
|                 1:4 Postscaler                  |                          3                           |
|                 1:5 Postscaler                  |                          4                           |
|                 1:6 Postscaler                  |                          5                           |
|                 1:7 Postscaler                  |                          6                           |
|                 1:8 Postscaler                  |                          7                           |
|                 1:9 Postscaler                  |                          8                           |
|                 1:10 Postscaler                 |                          9                           |
|                 1:11 Postscaler                 |                          10                          |
|                 1:12 Postscaler                 |                          11                          |
|                 1:13 Postscaler                 |                          12                          |
|                 1:14 Postscaler                 |                          13                          |
|                 1:15 Postscaler                 |                          14                          |
|                 1:16 Postscaler                 |                          15                          |

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitTimer2</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_inittimer1.html" title="InitTimer1"><link rel="next" href="_inittimer3.html" title="InitTimer3"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inittimer2"></a>InitTimer2</h4></div></div></div><p><span class="strong"><strong>Syntax: (MicroChip PIC)</strong></span></p><pre class="screen">    InitTimer2 <span class="emphasis"><em>prescaler</em></span>, <span class="emphasis"><em>postscaler</em></span>

or, where you required to state the clock source, use the following

    InitTimer2 <span class="emphasis"><em>clocksource</em></span>, <span class="emphasis"><em>prescaler</em></span>, <span class="emphasis"><em>postscaler</em></span></pre><p><span class="strong"><strong>Syntax: (Atmel AVR)</strong></span></p><pre class="screen">    InitTimer2 <span class="emphasis"><em>source</em></span>, <span class="emphasis"><em>prescaler</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a Timer 2 module.&nbsp;&nbsp;As shown above a Microchip microcontroller can potentially support two types of methods for initialisation.
<br>
<br>
The first method is:
<br></p><pre class="screen">    InitTimer2 prescaler, postscaler</pre><p>This the most common method to initialise a Microchip microcontroller timer.&nbsp;&nbsp;With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.
<br>
<br>
<br>
The second method is much more flexible in term of the clock source.&nbsp;&nbsp;Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values.&nbsp;&nbsp;The method is shown below:
<br></p><pre class="screen">    InitTimer2 clocksource, prescaler, postscaler</pre><p><span class="strong"><strong>How do you determine which method to use for your specific Microchip microcontroller ?</strong></span>
<br>
<br>
The timer type for a Microchip microcontroller can be determined by checking for the existance of a T2CLKCON register, either in the Datasheet or in the GCBASIC  "dat file" for the specific device.
<br>
<br>
If the Microchip microcontroller <span class="strong"><strong>DOES NOT</strong></span> have a T2CLKCON register then timers 2/4/6/8 for that specific microcontroller chip use the first method, and are configured using:
<br></p><pre class="screen">    InitTimer2 (PreScale, PostScale)</pre><p>If the microcontroller <span class="strong"><strong>DOES</strong></span> have a T2CLKCON register then ALL timers 2/4/6/8 for that specific microcontroller chip use the second method, and are configured using:</p><pre class="screen">    InitTimer2 (Source,PreScale,PostScale)</pre><p>The possible Source, Prescale and Postscale constants for each type are shown in the tables below.&nbsp;&nbsp;These table are summary tables from the Microchip datasheets.
<br>
<br></p><p><span class="strong"><strong>Period of the Timers</strong></span></p><p>The Period of the timer is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&nbsp;&nbsp;The timer period for timer 2 is held in register PR2.&nbsp;&nbsp;
<br></p><p>When the timer is enabled, by starting the timer, it will increment until the TMR2 register matches the value in the PR2 register.&nbsp;&nbsp;At this time the TMR2 register is cleared to 0 and the timer continues to increment until the next match, and so on.
<br></p><p>The lower the value of the PR2 register, the shorter the timer period will be.&nbsp;&nbsp;The default value for the PR2 register at power up is 255.
<br></p><p>The timer interrupt flag (TMR2IF) is set based upon the number of match conditions as determine by the postscaler.&nbsp;&nbsp;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.
<br>
<br></p><p><span class="strong"><strong>Timer constants for the MicroChip microcontrollers</strong></span></p><p>Parameters for this timer are detailed in the tables below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>clocksource</em></span></code></p></td><td align="left" valign="top"><p>This is an optional parameter.  Please review the datasheet for specific usage.<br>
&nbsp;<br>
Source can be one of the following numeric values:<br>
&nbsp;<br>
         1 equates to OSC (FOSC/4). &nbsp;&nbsp;&nbsp;The default clock source<br>
        <br>
         6 equates to EXTOSC same as SOSC<br>
         5 equates to MFINTOSC<br>
         4 equates to LFINTOSC<br>
         3 equates to HFINTOSC<br>
         2 equates to FOSC<br>
         1 equates to FOSC/4 same as OSC<br>
         0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<br>
</p><p>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer.  See the tables below for permitted values.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the postscaler for this specific timer.  See the tables below for permitted values.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 1 shown above</strong></span>
<br>
<br></p><p><code class="literal">prescaler</code> can be one of the following settings, if you MicroChip microcontroller has the T2CKPS4 bit then refer to table 3:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS2_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS2_4</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS2_16</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS2_64</code></p></td><td align="center" valign="top"><p>3</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 2 shown above</strong></span>
<br>
<br>
Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS2_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">PS2_2</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS2_4</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS2_8</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS2_16</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:32</p></td><td align="left" valign="top"><p><code class="literal">PS2_32</code></p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS2_64</code></p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:128</p></td><td align="left" valign="top"><p><code class="literal">PS2_128</code></p></td><td align="center" valign="top"><p>7</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 3 shown above</strong></span>
<br>
<br></p><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</p><p>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Postcaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>GCB Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Eqautes to</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>1:1 Postscaler</p></td><td align="left" valign="top"><p>POST_1</p></td><td align="left" valign="top"><p>0</p></td></tr><tr><td align="left" valign="top"><p>1:2 Postscaler</p></td><td align="left" valign="top"><p>POST_2</p></td><td align="left" valign="top"><p>1</p></td></tr><tr><td align="left" valign="top"><p>1:3 Postscaler</p></td><td align="left" valign="top"><p>POST_3</p></td><td align="left" valign="top"><p>2</p></td></tr><tr><td align="left" valign="top"><p>1:4 Postscaler</p></td><td align="left" valign="top"><p>POST_4</p></td><td align="left" valign="top"><p>3</p></td></tr><tr><td align="left" valign="top"><p>1:5 Postscaler</p></td><td align="left" valign="top"><p>POST_5</p></td><td align="left" valign="top"><p>4</p></td></tr><tr><td align="left" valign="top"><p>1:6 Postscaler</p></td><td align="left" valign="top"><p>POST_6</p></td><td align="left" valign="top"><p>5</p></td></tr><tr><td align="left" valign="top"><p>1:7 Postscaler</p></td><td align="left" valign="top"><p>POST_7</p></td><td align="left" valign="top"><p>6</p></td></tr><tr><td align="left" valign="top"><p>1:8 Postscaler</p></td><td align="left" valign="top"><p>POST_8</p></td><td align="left" valign="top"><p>7</p></td></tr><tr><td align="left" valign="top"><p>1:9 Postscaler</p></td><td align="left" valign="top"><p>POST_9</p></td><td align="left" valign="top"><p>8</p></td></tr><tr><td align="left" valign="top"><p>1:10 Postscaler</p></td><td align="left" valign="top"><p>POST_10</p></td><td align="left" valign="top"><p>9</p></td></tr><tr><td align="left" valign="top"><p>1:11 Postscaler</p></td><td align="left" valign="top"><p>POST_11</p></td><td align="left" valign="top"><p>10</p></td></tr><tr><td align="left" valign="top"><p>1:12 Postscaler</p></td><td align="left" valign="top"><p>POST_12</p></td><td align="left" valign="top"><p>11</p></td></tr><tr><td align="left" valign="top"><p>1:13 Postscaler</p></td><td align="left" valign="top"><p>POST_13</p></td><td align="left" valign="top"><p>12</p></td></tr><tr><td align="left" valign="top"><p>1:14 Postscaler</p></td><td align="left" valign="top"><p>POST_14</p></td><td align="left" valign="top"><p>13</p></td></tr><tr><td align="left" valign="top"><p>1:15 Postscaler</p></td><td align="left" valign="top"><p>POST_15</p></td><td align="left" valign="top"><p>14</p></td></tr><tr><td align="left" valign="top"><p>1:16 Postscaler</p></td><td align="left" valign="top"><p>POST_16</p></td><td align="left" valign="top"><p>15</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 4 shown above</strong></span></p><p><br>
<br></p><p><br>
<br></p><p><span class="strong"><strong>Explanation:(Atmel AVR)</strong></span></p><p><code class="literal">InitTimer2</code> will set up timer 2, according to the settings given.</p><p><code class="literal">source</code> can be one of the following settings:
Parameters for this timer are detailed in the table below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>source</em></span></code></p></td><td align="left" valign="top"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code> or <code class="literal">Ext</code> where`Osc` is an internal oscillator and <code class="literal">Ext</code> is an external oscillator.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 5 shown above</strong></span>
<br>
<br></p><p><code class="literal">prescaler</code> for Atmel AVR Timer 2 is chip specific and can be selected from one of the two
tables shown below.  Please refer to the datasheet determine which table to use and which
prescales within that table are supported by a specific Atmel AVR microcontroller.</p><p>Table1: Prescaler Rate Select bits are in the range of 1 to 1024</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Secondary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:0</p></td><td align="left" valign="top"><p><code class="literal">PS_0</code></p></td><td align="left" valign="top"><p><code class="literal">PS_2_0</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS_1</code></p></td><td align="left" valign="top"><p><code class="literal">PS_2_1</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS_8</code></p></td><td align="left" valign="top"><p><code class="literal">PS_2_8</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS_64</code></p></td><td align="left" valign="top"><p><code class="literal">PS_2_64</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:256</p></td><td align="left" valign="top"><p><code class="literal">PS_256</code></p></td><td align="left" valign="top"><p><code class="literal">PS2_256</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:1024</p></td><td align="left" valign="top"><p><code class="literal">PS_1024</code></p></td><td align="left" valign="top"><p><code class="literal">PS_2_1024</code></p></td><td align="center" valign="top"><p>5</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 6 shown above</strong></span>
<br>
<br>
<br></p><p>Prescaler Rate Select bits are in the range of 1 to 16384</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Secondary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS_2_1</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">PS_2_2</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS_2_4</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS_2_8</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS_2_16</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:32</p></td><td align="left" valign="top"><p><code class="literal">PS_2_32</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS_2_64</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>7</p></td></tr><tr><td align="center" valign="top"><p>1:128</p></td><td align="left" valign="top"><p><code class="literal">PS_2_128</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>8</p></td></tr><tr><td align="center" valign="top"><p>1:256</p></td><td align="left" valign="top"><p><code class="literal">PS_2_256</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>9</p></td></tr><tr><td align="center" valign="top"><p>1:512</p></td><td align="left" valign="top"><p><code class="literal">PS_2_512</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>10</p></td></tr><tr><td align="center" valign="top"><p>1:1024</p></td><td align="left" valign="top"><p><code class="literal">PS_2_1024</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>11</p></td></tr><tr><td align="center" valign="top"><p>1:2048</p></td><td align="left" valign="top"><p><code class="literal">PS_2_2048</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>12</p></td></tr><tr><td align="center" valign="top"><p>1:4096</p></td><td align="left" valign="top"><p><code class="literal">PS_2_4096</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>13</p></td></tr><tr><td align="center" valign="top"><p>1:8192</p></td><td align="left" valign="top"><p><code class="literal">PS_2_8192</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>14</p></td></tr><tr><td align="center" valign="top"><p>1:16384</p></td><td align="left" valign="top"><p><code class="literal">PS_2_16384</code></p></td><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="center" valign="top"><p>15</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 7 shown above</strong></span>
<br>
<br>
<span class="strong"><strong>Example:</strong></span></p><p>This code uses Timer 2 and On Interrupt to flash an LED every 200 timer ticks.</p><pre class="screen">    #chip 16F1788, 8

    #DEFINE LED PORTA.1
    DIR LED OUT

    #Define Match_Val PR2 'PR2 is the timer 2 match register
    Match_Val = 200       'Interrupt afer 200 timer ticks

    On interrupt timer2Match call FlashLED  'Interrupt on match
    Inittimer2 PS2_64, 15 'Prescale 1:64 /Postscale 1:16 (15)
    Starttimer 2

    Do
      ' Wating for interrupt on match val of 100
    Loop

    'This sub will be called when Timer 2 matches "Match_Val" (PR2)
    SUB FlashLED
        pulseout LED, 5 ms
    END SUB</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inittimer2"></span>InitTimer2

</div>

</div>

</div>

<span class="strong">**Syntax: (MicroChip PIC)**</span>

``` screen
    InitTimer2 prescaler, postscaler

or, where you required to state the clock source, use the following

    InitTimer2 clocksource, prescaler, postscaler
```

<span class="strong">**Syntax: (Atmel AVR)**</span>

``` screen
    InitTimer2 source, prescaler
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a Timer 2 module.  As shown above
a Microchip microcontroller can potentially support two types of methods
for initialisation.  
  
The first method is:  

``` screen
    InitTimer2 prescaler, postscaler
```

This the most common method to initialise a Microchip microcontroller
timer.  With this method the timer has only one possible clock source,
this mandated by the microcontrollers architecture, and that clock
source is the System Clock/4 also known as FOSC/4.  
  
  
The second method is much more flexible in term of the clock
source.  Microcontrollers that support this second method enable you to
select different clock sources and to select more prescale values.  The
method is shown below:  

``` screen
    InitTimer2 clocksource, prescaler, postscaler
```

<span class="strong">**How do you determine which method to use for your
specific Microchip microcontroller ?**</span>  
  
The timer type for a Microchip microcontroller can be determined by
checking for the existance of a T2CLKCON register, either in the
Datasheet or in the GCBASIC "dat file" for the specific device.  
  
If the Microchip microcontroller <span class="strong">**DOES
NOT**</span> have a T2CLKCON register then timers 2/4/6/8 for that
specific microcontroller chip use the first method, and are configured
using:  

``` screen
    InitTimer2 (PreScale, PostScale)
```

If the microcontroller <span class="strong">**DOES**</span> have a
T2CLKCON register then ALL timers 2/4/6/8 for that specific
microcontroller chip use the second method, and are configured using:

``` screen
    InitTimer2 (Source,PreScale,PostScale)
```

The possible Source, Prescale and Postscale constants for each type are
shown in the tables below.  These table are summary tables from the
Microchip datasheets.  
  

<span class="strong">**Period of the Timers**</span>

The Period of the timer is determined by the system clock speed, the
prescale value and 8-bit value in the respective timer period
register.  The timer period for timer 2 is held in register PR2.    

When the timer is enabled, by starting the timer, it will increment
until the TMR2 register matches the value in the PR2 register.  At this
time the TMR2 register is cleared to 0 and the timer continues to
increment until the next match, and so on.  

The lower the value of the PR2 register, the shorter the timer period
will be.  The default value for the PR2 register at power up is 255.  

The timer interrupt flag (TMR2IF) is set based upon the number of match
conditions as determine by the postscaler.  The postscaler does not
actually change the timer period, it changes the time between interrupt
conditions.  
  

<span class="strong">**Timer constants for the MicroChip
microcontrollers**</span>

Parameters for this timer are detailed in the tables below:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">clocksource</code></p></td>
<td style="text-align: left;"><p>This is an optional parameter. Please review the datasheet for specific usage.<br />
 <br />
Source can be one of the following numeric values:<br />
 <br />
1 equates to OSC (FOSC/4).    The default clock source<br />
<br />
6 equates to EXTOSC same as SOSC<br />
5 equates to MFINTOSC<br />
4 equates to LFINTOSC<br />
3 equates to HFINTOSC<br />
2 equates to FOSC<br />
1 equates to FOSC/4 same as OSC<br />
0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<br />
</p>
<p>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">prescaler</code></p></td>
<td style="text-align: left;"><p>The value of the prescaler for this specific timer. See the tables below for permitted values.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">postscaler</code></p></td>
<td style="text-align: left;"><p>The value of the postscaler for this specific timer. See the tables below for permitted values.</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Table 1 shown above**</span>  
  

`prescaler` can be one of the following settings, if you MicroChip
microcontroller has the T2CKPS4 bit then refer to table 3:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS2_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS2_4</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS2_16</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS2_64</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Table 2 shown above**</span>  
  
Note that a 1:64 prescale is only avaialable on certain midrange
microcontrollers. Please refer to the datasheet to determine if a 1:64
prescale is supported by a spectific microcontroller.  
  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS2_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:2</p></td>
<td style="text-align: left;"><p><code class="literal">PS2_2</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS2_4</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS2_8</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS2_16</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:32</p></td>
<td style="text-align: left;"><p><code class="literal">PS2_32</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS2_64</code></p></td>
<td style="text-align: center;"><p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:128</p></td>
<td style="text-align: left;"><p><code class="literal">PS2_128</code></p></td>
<td style="text-align: center;"><p>7</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Table 3 shown above**</span>  
  

`postscaler` slows the rate of the interrupt generation (or WDT reset)
from a counter/timer by dividing it down.

On Microchip PIC microcontroller one of the following constants where
the Postscaler Rate Select bits are in the range of 1 to 16.

<div class="informaltable">

| <span class="strong">**Postcaler Value**</span> | <span class="strong">**GCB Constant**</span> | <span class="strong">**Eqautes to**</span> |
|:------------------------------------------------|:---------------------------------------------|:-------------------------------------------|
| 1:1 Postscaler                                  | POST\_1                                      | 0                                          |
| 1:2 Postscaler                                  | POST\_2                                      | 1                                          |
| 1:3 Postscaler                                  | POST\_3                                      | 2                                          |
| 1:4 Postscaler                                  | POST\_4                                      | 3                                          |
| 1:5 Postscaler                                  | POST\_5                                      | 4                                          |
| 1:6 Postscaler                                  | POST\_6                                      | 5                                          |
| 1:7 Postscaler                                  | POST\_7                                      | 6                                          |
| 1:8 Postscaler                                  | POST\_8                                      | 7                                          |
| 1:9 Postscaler                                  | POST\_9                                      | 8                                          |
| 1:10 Postscaler                                 | POST\_10                                     | 9                                          |
| 1:11 Postscaler                                 | POST\_11                                     | 10                                         |
| 1:12 Postscaler                                 | POST\_12                                     | 11                                         |
| 1:13 Postscaler                                 | POST\_13                                     | 12                                         |
| 1:14 Postscaler                                 | POST\_14                                     | 13                                         |
| 1:15 Postscaler                                 | POST\_15                                     | 14                                         |
| 1:16 Postscaler                                 | POST\_16                                     | 15                                         |

</div>

<span class="strong">**Table 4 shown above**</span>

  
  

  
  

<span class="strong">**Explanation:(Atmel AVR)**</span>

`InitTimer2` will set up timer 2, according to the settings given.

`source` can be one of the following settings: Parameters for this timer
are detailed in the table below:

<div class="informaltable">

| Parameter | Description                                                                                                                                        |
|:----------|:---------------------------------------------------------------------------------------------------------------------------------------------------|
| `source`  | The clock source for this specific timer. Can be either `Osc` or `Ext` where\`Osc\` is an internal oscillator and `Ext` is an external oscillator. |

</div>

<span class="strong">**Table 5 shown above**</span>  
  

`prescaler` for Atmel AVR Timer 2 is chip specific and can be selected
from one of the two tables shown below. Please refer to the datasheet
determine which table to use and which prescales within that table are
supported by a specific Atmel AVR microcontroller.

Table1: Prescaler Rate Select bits are in the range of 1 to 1024

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Secondary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:0</p></td>
<td style="text-align: left;"><p><code class="literal">PS_0</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_0</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_1</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS_8</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_8</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS_64</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_64</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:256</p></td>
<td style="text-align: left;"><p><code class="literal">PS_256</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS2_256</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:1024</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1024</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_1024</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Table 6 shown above**</span>  
  
  

Prescaler Rate Select bits are in the range of 1 to 16384

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Secondary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_1</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:2</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_2</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_4</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_8</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_16</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:32</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_32</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>6</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_64</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>7</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:128</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_128</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>8</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:256</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_256</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>9</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:512</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_512</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>10</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:1024</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_1024</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>11</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:2048</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_2048</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>12</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:4096</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_4096</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>13</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:8192</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_8192</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>14</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16384</p></td>
<td style="text-align: left;"><p><code class="literal">PS_2_16384</code></p></td>
<td style="text-align: left;"><p><code class="literal">none</code></p></td>
<td style="text-align: center;"><p>15</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Table 7 shown above**</span>  
  
<span class="strong">**Example:**</span>

This code uses Timer 2 and On Interrupt to flash an LED every 200 timer
ticks.

``` screen
    #chip 16F1788, 8

    #DEFINE LED PORTA.1
    DIR LED OUT

    #Define Match_Val PR2 'PR2 is the timer 2 match register
    Match_Val = 200       'Interrupt afer 200 timer ticks

    On interrupt timer2Match call FlashLED  'Interrupt on match
    Inittimer2 PS2_64, 15 'Prescale 1:64 /Postscale 1:16 (15)
    Starttimer 2

    Do
      ' Wating for interrupt on match val of 100
    Loop

    'This sub will be called when Timer 2 matches "Match_Val" (PR2)
    SUB FlashLED
        pulseout LED, 5 ms
    END SUB
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitTimer3</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_inittimer2.html" title="InitTimer2"><link rel="next" href="_inittimer4.html" title="InitTimer4"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inittimer3"></a>InitTimer3</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">InitTimer3 <span class="emphasis"><em>source</em></span>, <span class="emphasis"><em>prescaler</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a Timer 3 module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">InitTimer3</code> will set up timer 3.</p><p>Parameters are required as detailed in the table below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>source</em></span></code></p></td><td align="left" valign="top"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code>, <code class="literal">Ext</code> or <code class="literal">ExtOsc</code> where:<br>
<code class="literal">Osc</code> is an internal oscillator.<br>
<code class="literal">Ext</code> is an external oscillator.<br>
</p><p><br>
<br>
<code class="literal">Osc</code> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&nbsp;&nbsp;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</p><p><code class="literal">Ext</code> - Selects the clock source attached to a specific exernal interrupt input port.&nbsp;&nbsp;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.
<br>
<br>
</p><p><code class="literal">ExtOsc</code> is an external oscillator and only available on a Microchip PIC microcontroller.
</p><p>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources.  This includes, but limited to,  the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller  series On these devices the clock source can be one of the following:
</p><p><code class="literal">Osc</code> is an internal oscillator which is the same source as <code class="literal">FOSC4</code>.<br>
<code class="literal">Ext</code>  is an external oscillator which is the same source as <code class="literal">TxXKIPPS</code>.<br>
<code class="literal">ExtOsc</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br>
<code class="literal">FOSC</code> is an internal oscillator which is the Frequency of the OSCillator.<br>
<code class="literal">FOSC4</code> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<br>
<code class="literal">SOSC</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br>
<code class="literal">MFINTOSC</code> is an internal 500KHz internal clock oscillator.<br>
<code class="literal">LFINTOSC</code>  is an internal 31Khz internal clock oscillator.<br>
<code class="literal">HFINTOSC</code> is an oscillator as specified within the datasheet for each specific microcontroller.<br>
<code class="literal">TxCKIPPS</code> is an oscillator input on TxCKIPPS Pin.<br></p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer.  See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</p></td></tr></tbody></table></div><p>When the timer overflows an interrupt event will be generated.
This interrupt event can be used in conjunction with <code class="literal">On Interrupt</code> to run a section of code when the interrupt event occurs.
<br>
<br>
<br>
<br>
<span class="strong"><strong>Microchip PIC microcontrollers:</strong></span></p><p>On Microchip PIC microcontrollers <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> must be one of the following constants:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS3_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">PS3_2</code></p></td><td align="center" valign="top"><p>16</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS3_4</code></p></td><td align="center" valign="top"><p>32</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS3_8</code></p></td><td align="center" valign="top"><p>48</p></td></tr></tbody></table></div><p>These correspond to a prescaler of between 1:2 and 1:8 of the oscillator (FOSC/4)
speed. The prescaler will apply to either the oscillator or the external
clock input.
<br>
<br>
<br>
<br>
<span class="strong"><strong>Atmel AVR microcontrollers:</strong></span></p><p>On the majority of Atmel AVR microcontrollers  <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> must be one of the following constants:</p><p>The prescaler will only apply when the timer is driven from the <code class="literal">Osc</code> the internal oscillator - the prescaler has no effect when the external clock source is specified.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Secondary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:0</p></td><td align="left" valign="top"><p><code class="literal">PS_0</code></p></td><td align="left" valign="top"><p><code class="literal">PS_3_0</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS_1</code></p></td><td align="left" valign="top"><p><code class="literal">PS_3_1</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS_8</code></p></td><td align="left" valign="top"><p><code class="literal">PS_3_8</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS_64</code></p></td><td align="left" valign="top"><p><code class="literal">PS_3_64</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:256</p></td><td align="left" valign="top"><p><code class="literal">PS_256</code></p></td><td align="left" valign="top"><p><code class="literal">PS_3_256</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:1024</p></td><td align="left" valign="top"><p><code class="literal">PS_1024</code></p></td><td align="left" valign="top"><p><code class="literal">PS_3_1024</code></p></td><td align="center" valign="top"><p>5</p></td></tr></tbody></table></div><p><span class="strong"><strong>Supported in &lt;TIMER.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inittimer3"></span>InitTimer3

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
InitTimer3 source, prescaler
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a Timer 3 module.

<span class="strong">**Explanation:**</span>

`InitTimer3` will set up timer 3.

Parameters are required as detailed in the table below:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">source</code></p></td>
<td style="text-align: left;"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code>, <code class="literal">Ext</code> or <code class="literal">ExtOsc</code> where:<br />
<code class="literal">Osc</code> is an internal oscillator.<br />
<code class="literal">Ext</code> is an external oscillator.<br />
</p>
<p><br />
<br />
<code class="literal">Osc</code> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).  This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).</p>
<p><code class="literal">Ext</code> - Selects the clock source attached to a specific exernal interrupt input port.  This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.<br />
<br />
</p>
<p><code class="literal">ExtOsc</code> is an external oscillator and only available on a Microchip PIC microcontroller.</p>
<p>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources. This includes, but limited to, the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller series On these devices the clock source can be one of the following:</p>
<p><code class="literal">Osc</code> is an internal oscillator which is the same source as <code class="literal">FOSC4</code>.<br />
<code class="literal">Ext</code> is an external oscillator which is the same source as <code class="literal">TxXKIPPS</code>.<br />
<code class="literal">ExtOsc</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br />
<code class="literal">FOSC</code> is an internal oscillator which is the Frequency of the OSCillator.<br />
<code class="literal">FOSC4</code> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<br />
<code class="literal">SOSC</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br />
<code class="literal">MFINTOSC</code> is an internal 500KHz internal clock oscillator.<br />
<code class="literal">LFINTOSC</code> is an internal 31Khz internal clock oscillator.<br />
<code class="literal">HFINTOSC</code> is an oscillator as specified within the datasheet for each specific microcontroller.<br />
<code class="literal">TxCKIPPS</code> is an oscillator input on TxCKIPPS Pin.<br />
</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">prescaler</code></p></td>
<td style="text-align: left;"><p>The value of the prescaler for this specific timer. See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</p></td>
</tr>
</tbody>
</table>

</div>

When the timer overflows an interrupt event will be generated. This
interrupt event can be used in conjunction with `On Interrupt` to run a
section of code when the interrupt event occurs.  
  
  
  
<span class="strong">**Microchip PIC microcontrollers:**</span>

On Microchip PIC microcontrollers `prescaler` must be one of the
following constants:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS3_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:2</p></td>
<td style="text-align: left;"><p><code class="literal">PS3_2</code></p></td>
<td style="text-align: center;"><p>16</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS3_4</code></p></td>
<td style="text-align: center;"><p>32</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS3_8</code></p></td>
<td style="text-align: center;"><p>48</p></td>
</tr>
</tbody>
</table>

</div>

These correspond to a prescaler of between 1:2 and 1:8 of the oscillator
(FOSC/4) speed. The prescaler will apply to either the oscillator or the
external clock input.  
  
  
  
<span class="strong">**Atmel AVR microcontrollers:**</span>

On the majority of Atmel AVR microcontrollers `prescaler` must be one of
the following constants:

The prescaler will only apply when the timer is driven from the `Osc`
the internal oscillator - the prescaler has no effect when the external
clock source is specified.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Secondary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:0</p></td>
<td style="text-align: left;"><p><code class="literal">PS_0</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_3_0</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_3_1</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS_8</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_3_8</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS_64</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_3_64</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:256</p></td>
<td style="text-align: left;"><p><code class="literal">PS_256</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_3_256</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:1024</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1024</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_3_1024</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Supported in &lt;TIMER.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitTimer4</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_inittimer3.html" title="InitTimer3"><link rel="next" href="_inittimer5.html" title="InitTimer5"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inittimer4"></a>InitTimer4</h4></div></div></div><p><span class="strong"><strong>Syntax: (MicroChip PIC)</strong></span></p><pre class="screen">    InitTimer4 <span class="emphasis"><em>prescaler</em></span>, <span class="emphasis"><em>postscaler</em></span>

or, where you required to state the clock source, use the following

    InitTimer4 <span class="emphasis"><em>clocksource</em></span>, <span class="emphasis"><em>prescaler</em></span>, <span class="emphasis"><em>postscaler</em></span></pre><p><span class="strong"><strong>Syntax: (Atmel AVR)</strong></span></p><pre class="screen">    InitTimer4 <span class="emphasis"><em>source</em></span>, <span class="emphasis"><em>prescaler</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a Timer 4 module.&nbsp;&nbsp;As shown above a Microchip microcontroller can potentially support two types of methods for initialisation.
<br>
<br>
The first method is:
<br></p><pre class="screen">    InitTimer4 prescaler, postscaler</pre><p>This the most common method to initialise a Microchip microcontroller timer.&nbsp;&nbsp;With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.
<br>
<br>
<br>
The second method is much more flexible in term of the clock source.&nbsp;&nbsp;Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values.&nbsp;&nbsp;The method is shown below:
<br></p><pre class="screen">    InitTimer4 clocksource, prescaler, postscaler</pre><p><span class="strong"><strong>How do you determine which method to use for your specific Microchip microcontroller ?</strong></span>
<br>
<br>
The timer type for a Microchip microcontroller can be determined by checking for the existance of a T2CLKCON register, either in the Datasheet or in the GCBASIC  "dat file" for the specific device.
<br>
<br>
If the Microchip microcontroller <span class="strong"><strong>DOES NOT</strong></span> have a T4CLKCON register then timers 2/4/6/8 for that specific microcontroller chip use the first method, and are configured using:
<br></p><pre class="screen">    InitTimer4 (PreScale, PostScale)</pre><p>If the microcontroller <span class="strong"><strong>DOES</strong></span> have a T2CLKCON register then ALL timers 2/4/6/8 for that specific microcontroller chip use the second method, and are configured using:</p><pre class="screen">    InitTimer4 (Source,PreScale,PostScale)</pre><p>The possible Source, Prescale and Postscale constants for each type are shown in the tables below.&nbsp;&nbsp;These table are summary tables from the Microchip datasheets.
<br>
<br></p><p><span class="strong"><strong>Period of the Timers</strong></span></p><p>The Period of the timer is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&nbsp;&nbsp;The timer period for timer 4 is held in register PR4.&nbsp;&nbsp;
<br></p><p>When the timer is enabled, by starting the timer, it will increment until the TMR4 register matches the value in the PR4 register.&nbsp;&nbsp;At this time the TMR4 register is cleared to 0 and the timer continues to increment until the next match, and so on.
<br></p><p>The lower the value of the PR4 register, the shorter the timer period will be.&nbsp;&nbsp;The default value for the PR4 register at power up is 255.
<br></p><p>The timer interrupt flag (TMR4IF) is set based upon the number of match conditions as determine by the postscaler.&nbsp;&nbsp;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.
<br>
<br></p><p><span class="strong"><strong>Timer constants for the MicroChip microcontrollers</strong></span></p><p>Parameters for this timer are detailed in the tables below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>clocksource</em></span></code></p></td><td align="left" valign="top"><p>If required by method select.
&nbsp;<br>
Source can be one of the following numeric values:<br>
&nbsp;<br>
         1 equates to OSC (FOSC/4). &nbsp;&nbsp;&nbsp;The default clock source<br>
        <br>
         6 equates to EXTOSC same as SOSC<br>
         5 equates to MFINTOSC<br>
         4 equates to LFINTOSC<br>
         3 equates to HFINTOSC<br>
         2 equates to FOSC<br>
         1 equates to FOSC/4 same as OSC<br>
         0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<br>
</p><p>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer.  See the tables below for permitted values.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the postscaler for this specific timer.  See the tables below for permitted values.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 1 shown above</strong></span></p><p><br>
<br></p><p><code class="literal">prescaler</code> can be one of the following settings, if you MicroChip microcontroller has the T4CKPS4 bit then refer to table 2:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS4_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS4_4</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS4_16</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS4_64</code></p></td><td align="center" valign="top"><p>3</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 2</strong></span></p><p>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS4_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">PS4_2</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS4_4</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS4_8</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS4_16</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:32</p></td><td align="left" valign="top"><p><code class="literal">PS4_32</code></p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS4_64</code></p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:128</p></td><td align="left" valign="top"><p><code class="literal">PS4_128</code></p></td><td align="center" valign="top"><p>7</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 3</strong></span>
<br>
<br></p><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</p><p>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Postcaler Value</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Use Numeric Constant</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1 Postscaler</p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2 Postscaler</p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:3 Postscaler</p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:4 Postscaler</p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:5 Postscaler</p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:6 Postscaler</p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:7 Postscaler</p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:8 Postscaler</p></td><td align="center" valign="top"><p>7</p></td></tr><tr><td align="center" valign="top"><p>1:9 Postscaler</p></td><td align="center" valign="top"><p>8</p></td></tr><tr><td align="center" valign="top"><p>1:10 Postscaler</p></td><td align="center" valign="top"><p>9</p></td></tr><tr><td align="center" valign="top"><p>1:11 Postscaler</p></td><td align="center" valign="top"><p>10</p></td></tr><tr><td align="center" valign="top"><p>1:12 Postscaler</p></td><td align="center" valign="top"><p>11</p></td></tr><tr><td align="center" valign="top"><p>1:13 Postscaler</p></td><td align="center" valign="top"><p>12</p></td></tr><tr><td align="center" valign="top"><p>1:14 Postscaler</p></td><td align="center" valign="top"><p>13</p></td></tr><tr><td align="center" valign="top"><p>1:15 Postscaler</p></td><td align="center" valign="top"><p>14</p></td></tr><tr><td align="center" valign="top"><p>1:16 Postscaler</p></td><td align="center" valign="top"><p>15</p></td></tr></tbody></table></div><p><br>
<br></p><p><span class="strong"><strong>Explanation:(Atmel AVR)</strong></span></p><p><code class="literal">InitTimer4</code> will set up timer 4, according to the settings given.</p><p><code class="literal">source</code> can be one of the following settings:
Parameters for this timer are detailed in the table below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>source</em></span></code></p></td><td align="left" valign="top"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code> or <code class="literal">Ext</code> where`Osc` is an internal oscillator and <code class="literal">Ext</code> is an external oscillator.</p></td></tr></tbody></table></div><p><br>
<br></p><p><code class="literal">prescaler</code> for Atmel AVR Timer 4 can be selected from the table below.</p><p>Prescaler Rate Select bits are in the range of 1 to 1024</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Secondary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:0</p></td><td align="left" valign="top"><p><code class="literal">PS_0</code></p></td><td align="left" valign="top"><p><code class="literal">PS_4_0</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS_1</code></p></td><td align="left" valign="top"><p><code class="literal">PS_4_1</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS_8</code></p></td><td align="left" valign="top"><p><code class="literal">PS_4_8</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS_64</code></p></td><td align="left" valign="top"><p><code class="literal">PS_4_64</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:256</p></td><td align="left" valign="top"><p><code class="literal">PS_256</code></p></td><td align="left" valign="top"><p><code class="literal">PS4_256</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:1024</p></td><td align="left" valign="top"><p><code class="literal">PS_1024</code></p></td><td align="left" valign="top"><p><code class="literal">PS_4_1024</code></p></td><td align="center" valign="top"><p>5</p></td></tr></tbody></table></div><p><br>
<br>
<br></p><p><span class="strong"><strong>Example:</strong></span></p><p>This code uses Timer 4 and On Interrupt to generate a 1ms pulse 20 ms.</p><pre class="screen">    #chip 18F25K80, 8

    #DEFINE PIN3 PORTA.1
    DIR PIN3 OUT

    #Define Match_Val PR4  'PR4 is the timer 2 match register
    Match_Val = 154        'Interrupt afer 154 Timer ticks (~20ms)

    On interrupt timer4Match call PulsePin3  'Interrupt on match
    Inittimer4 PS4_16, 15 'Prescale 1:64 /Postscale 1:16 (15)
    Starttimer 4

    Do
       'Waiting for interrupt on match val of 154
    Loop

    Sub PulsePin3
       pulseout Pin3, 1 ms
    End Sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inittimer4"></span>InitTimer4

</div>

</div>

</div>

<span class="strong">**Syntax: (MicroChip PIC)**</span>

``` screen
    InitTimer4 prescaler, postscaler

or, where you required to state the clock source, use the following

    InitTimer4 clocksource, prescaler, postscaler
```

<span class="strong">**Syntax: (Atmel AVR)**</span>

``` screen
    InitTimer4 source, prescaler
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a Timer 4 module.  As shown above
a Microchip microcontroller can potentially support two types of methods
for initialisation.  
  
The first method is:  

``` screen
    InitTimer4 prescaler, postscaler
```

This the most common method to initialise a Microchip microcontroller
timer.  With this method the timer has only one possible clock source,
this mandated by the microcontrollers architecture, and that clock
source is the System Clock/4 also known as FOSC/4.  
  
  
The second method is much more flexible in term of the clock
source.  Microcontrollers that support this second method enable you to
select different clock sources and to select more prescale values.  The
method is shown below:  

``` screen
    InitTimer4 clocksource, prescaler, postscaler
```

<span class="strong">**How do you determine which method to use for your
specific Microchip microcontroller ?**</span>  
  
The timer type for a Microchip microcontroller can be determined by
checking for the existance of a T2CLKCON register, either in the
Datasheet or in the GCBASIC "dat file" for the specific device.  
  
If the Microchip microcontroller <span class="strong">**DOES
NOT**</span> have a T4CLKCON register then timers 2/4/6/8 for that
specific microcontroller chip use the first method, and are configured
using:  

``` screen
    InitTimer4 (PreScale, PostScale)
```

If the microcontroller <span class="strong">**DOES**</span> have a
T2CLKCON register then ALL timers 2/4/6/8 for that specific
microcontroller chip use the second method, and are configured using:

``` screen
    InitTimer4 (Source,PreScale,PostScale)
```

The possible Source, Prescale and Postscale constants for each type are
shown in the tables below.  These table are summary tables from the
Microchip datasheets.  
  

<span class="strong">**Period of the Timers**</span>

The Period of the timer is determined by the system clock speed, the
prescale value and 8-bit value in the respective timer period
register.  The timer period for timer 4 is held in register PR4.    

When the timer is enabled, by starting the timer, it will increment
until the TMR4 register matches the value in the PR4 register.  At this
time the TMR4 register is cleared to 0 and the timer continues to
increment until the next match, and so on.  

The lower the value of the PR4 register, the shorter the timer period
will be.  The default value for the PR4 register at power up is 255.  

The timer interrupt flag (TMR4IF) is set based upon the number of match
conditions as determine by the postscaler.  The postscaler does not
actually change the timer period, it changes the time between interrupt
conditions.  
  

<span class="strong">**Timer constants for the MicroChip
microcontrollers**</span>

Parameters for this timer are detailed in the tables below:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">clocksource</code></p></td>
<td style="text-align: left;"><p>If required by method select.  <br />
Source can be one of the following numeric values:<br />
 <br />
1 equates to OSC (FOSC/4).    The default clock source<br />
<br />
6 equates to EXTOSC same as SOSC<br />
5 equates to MFINTOSC<br />
4 equates to LFINTOSC<br />
3 equates to HFINTOSC<br />
2 equates to FOSC<br />
1 equates to FOSC/4 same as OSC<br />
0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<br />
</p>
<p>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">prescaler</code></p></td>
<td style="text-align: left;"><p>The value of the prescaler for this specific timer. See the tables below for permitted values.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">postscaler</code></p></td>
<td style="text-align: left;"><p>The value of the postscaler for this specific timer. See the tables below for permitted values.</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Table 1 shown above**</span>

  
  

`prescaler` can be one of the following settings, if you MicroChip
microcontroller has the T4CKPS4 bit then refer to table 2:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS4_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS4_4</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS4_16</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS4_64</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Table 2**</span>

Note that a 1:64 prescale is only avaialable on certain midrange
microcontrollers. Please refer to the datasheet to determine if a 1:64
prescale is supported by a spectific microcontroller.  
  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS4_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:2</p></td>
<td style="text-align: left;"><p><code class="literal">PS4_2</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS4_4</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS4_8</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS4_16</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:32</p></td>
<td style="text-align: left;"><p><code class="literal">PS4_32</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS4_64</code></p></td>
<td style="text-align: center;"><p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:128</p></td>
<td style="text-align: left;"><p><code class="literal">PS4_128</code></p></td>
<td style="text-align: center;"><p>7</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Table 3**</span>  
  

`postscaler` slows the rate of the interrupt generation (or WDT reset)
from a counter/timer by dividing it down.

On Microchip PIC microcontroller one of the following constants where
the Postscaler Rate Select bits are in the range of 1 to 16.

<div class="informaltable">

| <span class="strong">**Postcaler Value**</span> | <span class="strong">**Use Numeric Constant**</span> |
|:-----------------------------------------------:|:----------------------------------------------------:|
|                 1:1 Postscaler                  |                          0                           |
|                 1:2 Postscaler                  |                          1                           |
|                 1:3 Postscaler                  |                          2                           |
|                 1:4 Postscaler                  |                          3                           |
|                 1:5 Postscaler                  |                          4                           |
|                 1:6 Postscaler                  |                          5                           |
|                 1:7 Postscaler                  |                          6                           |
|                 1:8 Postscaler                  |                          7                           |
|                 1:9 Postscaler                  |                          8                           |
|                 1:10 Postscaler                 |                          9                           |
|                 1:11 Postscaler                 |                          10                          |
|                 1:12 Postscaler                 |                          11                          |
|                 1:13 Postscaler                 |                          12                          |
|                 1:14 Postscaler                 |                          13                          |
|                 1:15 Postscaler                 |                          14                          |
|                 1:16 Postscaler                 |                          15                          |

</div>

  
  

<span class="strong">**Explanation:(Atmel AVR)**</span>

`InitTimer4` will set up timer 4, according to the settings given.

`source` can be one of the following settings: Parameters for this timer
are detailed in the table below:

<div class="informaltable">

| Parameter | Description                                                                                                                                        |
|:----------|:---------------------------------------------------------------------------------------------------------------------------------------------------|
| `source`  | The clock source for this specific timer. Can be either `Osc` or `Ext` where\`Osc\` is an internal oscillator and `Ext` is an external oscillator. |

</div>

  
  

`prescaler` for Atmel AVR Timer 4 can be selected from the table below.

Prescaler Rate Select bits are in the range of 1 to 1024

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Secondary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:0</p></td>
<td style="text-align: left;"><p><code class="literal">PS_0</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_4_0</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_4_1</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS_8</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_4_8</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS_64</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_4_64</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:256</p></td>
<td style="text-align: left;"><p><code class="literal">PS_256</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS4_256</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:1024</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1024</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_4_1024</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
</tbody>
</table>

</div>

  
  
  

<span class="strong">**Example:**</span>

This code uses Timer 4 and On Interrupt to generate a 1ms pulse 20 ms.

``` screen
    #chip 18F25K80, 8

    #DEFINE PIN3 PORTA.1
    DIR PIN3 OUT

    #Define Match_Val PR4  'PR4 is the timer 2 match register
    Match_Val = 154        'Interrupt afer 154 Timer ticks (~20ms)

    On interrupt timer4Match call PulsePin3  'Interrupt on match
    Inittimer4 PS4_16, 15 'Prescale 1:64 /Postscale 1:16 (15)
    Starttimer 4

    Do
       'Waiting for interrupt on match val of 154
    Loop

    Sub PulsePin3
       pulseout Pin3, 1 ms
    End Sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitTimer5</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_inittimer4.html" title="InitTimer4"><link rel="next" href="_inittimer6.html" title="InitTimer6"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inittimer5"></a>InitTimer5</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">InitTimer5 <span class="emphasis"><em>source</em></span>, <span class="emphasis"><em>prescaler</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a Timer 5 module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">InitTimer5</code> will set up timer 5.</p><p>Parameters are required as detailed in the table below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>source</em></span></code></p></td><td align="left" valign="top"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code>, <code class="literal">Ext</code> or <code class="literal">ExtOsc</code> where:<br>
<code class="literal">Osc</code> is an internal oscillator.<br>
<code class="literal">Ext</code> is an external oscillator.<br>
</p><p><br>
<br>
<code class="literal">Osc</code> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&nbsp;&nbsp;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</p><p><code class="literal">Ext</code> - Selects the clock source attached to a specific exernal interrupt input port.&nbsp;&nbsp;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.
<br>
<br>
</p><p><code class="literal">ExtOsc</code> is an external oscillator and only available on a Microchip PIC microcontroller.
</p><p>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources.  This includes, but limited to,  the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller  series  On these devices the clock source can be one of the following:
</p><p><code class="literal">Osc</code> is an internal oscillator which is the same source as <code class="literal">FOSC4</code>.<br>
<code class="literal">Ext</code>  is an external oscillator which is the same source as <code class="literal">TxXKIPPS</code>.<br>
<code class="literal">ExtOsc</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br>
<code class="literal">FOSC</code> is an internal oscillator which is the Frequency of the OSCillator.<br>
<code class="literal">FOSC4</code> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<br>
<code class="literal">SOSC</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br>
<code class="literal">MFINTOSC</code> is an internal 500KHz internal clock oscillator.<br>
<code class="literal">LFINTOSC</code>  is an internal 31Khz internal clock oscillator.<br>
<code class="literal">HFINTOSC</code> is an oscillator as specified within the datasheet for each specific microcontroller.<br>
<code class="literal">TxCKIPPS</code> is an oscillator input on TxCKIPPS Pin.<br></p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer.  See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</p></td></tr></tbody></table></div><p>When the timer overflows an interrupt event will be generated.
This interrupt event can be used in conjunction with <code class="literal">On Interrupt</code> to run a section of code when the interrupt event occurs.
<br>
<br>
<br>
<br>
<span class="strong"><strong>Microchip PIC microcontrollers:</strong></span></p><p>On Microchip PIC microcontrollers <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> must be one of the following constants:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS5_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">PS5_2</code></p></td><td align="center" valign="top"><p>16</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS5_4</code></p></td><td align="center" valign="top"><p>32</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS5_8</code></p></td><td align="center" valign="top"><p>48</p></td></tr></tbody></table></div><p>These correspond to a prescaler of between 1:2 and 1:8 of the oscillator (FOSC/4)
speed. The prescaler will apply to either the oscillator or the external
clock input.
<br>
<br>
<br>
<br>
<span class="strong"><strong>Atmel AVR microcontrollers:</strong></span></p><p>On the majority of Atmel AVR microcontrollers  <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> must be one of the following constants:</p><p>The prescaler will only apply when the timer is driven from the <code class="literal">Osc</code> the internal oscillator - the prescaler has no effect when the external clock source is specified.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Secondary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:0</p></td><td align="left" valign="top"><p><code class="literal">PS_0</code></p></td><td align="left" valign="top"><p><code class="literal">PS_5_0</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS_1</code></p></td><td align="left" valign="top"><p><code class="literal">PS_5_1</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS_8</code></p></td><td align="left" valign="top"><p><code class="literal">PS_5_8</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS_64</code></p></td><td align="left" valign="top"><p><code class="literal">PS_5_64</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:256</p></td><td align="left" valign="top"><p><code class="literal">PS_256</code></p></td><td align="left" valign="top"><p><code class="literal">PS_5_256</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:1024</p></td><td align="left" valign="top"><p><code class="literal">PS_1024</code></p></td><td align="left" valign="top"><p><code class="literal">PS_5_1024</code></p></td><td align="center" valign="top"><p>5</p></td></tr></tbody></table></div><p><span class="strong"><strong>Supported in &lt;TIMER.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inittimer5"></span>InitTimer5

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
InitTimer5 source, prescaler
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a Timer 5 module.

<span class="strong">**Explanation:**</span>

`InitTimer5` will set up timer 5.

Parameters are required as detailed in the table below:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">source</code></p></td>
<td style="text-align: left;"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code>, <code class="literal">Ext</code> or <code class="literal">ExtOsc</code> where:<br />
<code class="literal">Osc</code> is an internal oscillator.<br />
<code class="literal">Ext</code> is an external oscillator.<br />
</p>
<p><br />
<br />
<code class="literal">Osc</code> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).  This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).</p>
<p><code class="literal">Ext</code> - Selects the clock source attached to a specific exernal interrupt input port.  This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.<br />
<br />
</p>
<p><code class="literal">ExtOsc</code> is an external oscillator and only available on a Microchip PIC microcontroller.</p>
<p>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources. This includes, but limited to, the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller series On these devices the clock source can be one of the following:</p>
<p><code class="literal">Osc</code> is an internal oscillator which is the same source as <code class="literal">FOSC4</code>.<br />
<code class="literal">Ext</code> is an external oscillator which is the same source as <code class="literal">TxXKIPPS</code>.<br />
<code class="literal">ExtOsc</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br />
<code class="literal">FOSC</code> is an internal oscillator which is the Frequency of the OSCillator.<br />
<code class="literal">FOSC4</code> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<br />
<code class="literal">SOSC</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br />
<code class="literal">MFINTOSC</code> is an internal 500KHz internal clock oscillator.<br />
<code class="literal">LFINTOSC</code> is an internal 31Khz internal clock oscillator.<br />
<code class="literal">HFINTOSC</code> is an oscillator as specified within the datasheet for each specific microcontroller.<br />
<code class="literal">TxCKIPPS</code> is an oscillator input on TxCKIPPS Pin.<br />
</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">prescaler</code></p></td>
<td style="text-align: left;"><p>The value of the prescaler for this specific timer. See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</p></td>
</tr>
</tbody>
</table>

</div>

When the timer overflows an interrupt event will be generated. This
interrupt event can be used in conjunction with `On Interrupt` to run a
section of code when the interrupt event occurs.  
  
  
  
<span class="strong">**Microchip PIC microcontrollers:**</span>

On Microchip PIC microcontrollers `prescaler` must be one of the
following constants:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS5_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:2</p></td>
<td style="text-align: left;"><p><code class="literal">PS5_2</code></p></td>
<td style="text-align: center;"><p>16</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS5_4</code></p></td>
<td style="text-align: center;"><p>32</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS5_8</code></p></td>
<td style="text-align: center;"><p>48</p></td>
</tr>
</tbody>
</table>

</div>

These correspond to a prescaler of between 1:2 and 1:8 of the oscillator
(FOSC/4) speed. The prescaler will apply to either the oscillator or the
external clock input.  
  
  
  
<span class="strong">**Atmel AVR microcontrollers:**</span>

On the majority of Atmel AVR microcontrollers `prescaler` must be one of
the following constants:

The prescaler will only apply when the timer is driven from the `Osc`
the internal oscillator - the prescaler has no effect when the external
clock source is specified.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Secondary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:0</p></td>
<td style="text-align: left;"><p><code class="literal">PS_0</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_5_0</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_5_1</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS_8</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_5_8</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS_64</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_5_64</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:256</p></td>
<td style="text-align: left;"><p><code class="literal">PS_256</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_5_256</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:1024</p></td>
<td style="text-align: left;"><p><code class="literal">PS_1024</code></p></td>
<td style="text-align: left;"><p><code class="literal">PS_5_1024</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Supported in &lt;TIMER.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitTimer6</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_inittimer5.html" title="InitTimer5"><link rel="next" href="_inittimer7.html" title="InitTimer7"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inittimer6"></a>InitTimer6</h4></div></div></div><p><span class="strong"><strong>Syntax: (MicroChip PIC)</strong></span></p><pre class="screen">    InitTimer6 <span class="emphasis"><em>prescaler</em></span>, <span class="emphasis"><em>postscaler</em></span>

or, where you required to state the clock source, use the following

    InitTimer6 <span class="emphasis"><em>clocksource</em></span>, <span class="emphasis"><em>prescaler</em></span>, <span class="emphasis"><em>postscaler</em></span></pre><p><span class="strong"><strong>Syntax: (Atmel AVR)</strong></span></p><pre class="screen">    InitTimer6 <span class="emphasis"><em>source</em></span>, <span class="emphasis"><em>prescaler</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a Timer 6 module.&nbsp;&nbsp;As shown above a Microchip microcontroller can potentially support two types of methods for initialisation.
<br>
<br>
The first method is:
<br></p><pre class="screen">    InitTimer6 prescaler, postscaler</pre><p>This the most common method to initialise a Microchip microcontroller timer.&nbsp;&nbsp;With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.
<br>
<br>
<br>
The second method is much more flexible in term of the clock source.&nbsp;&nbsp;Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values.&nbsp;&nbsp;The method is shown below:
<br></p><pre class="screen">    InitTimer6 clocksource, prescaler, postscaler</pre><p><span class="strong"><strong>How do you determine which method to use for your specific Microchip microcontroller ?</strong></span>
<br>
<br>
The timer type for a Microchip microcontroller can be determined by checking for the existance of a T2CLKCON register, either in the Datasheet or in the GCBASIC  "dat file" for the specific device.
<br>
<br>
If the Microchip microcontroller <span class="strong"><strong>DOES NOT</strong></span> have a T2CLKCON register then timers 2/4/6/8 for that specific microcontroller chip use the first method, and are configured using:
<br></p><pre class="screen">    InitTimer6 (PreScale, PostScale)</pre><p>If the microcontroller <span class="strong"><strong>DOES</strong></span> have a T2CLKCON register then ALL timers 2/4/6/8 for that specific microcontroller chip use the second method, and are configured using:</p><pre class="screen">    InitTimer6 (Source,PreScale,PostScale)</pre><p>The possible Source, Prescale and Postscale constants for each type are shown in the tables below.&nbsp;&nbsp;These table are summary tables from the Microchip datasheets.
<br>
<br></p><p><span class="strong"><strong>Period of the Timers</strong></span></p><p>The Period of the timer is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&nbsp;&nbsp;The timer period for timer 6 is held in register PR6.&nbsp;&nbsp;
<br></p><p>When the timer is enabled, by starting the timer, it will increment until the TMR6 register matches the value in the PR6 register.&nbsp;&nbsp;At this time the TMR6 register is cleared to 0 and the timer continues to increment until the next match, and so on.
<br></p><p>The lower the value of the PR6 register, the shorter the timer period will be.&nbsp;&nbsp;The default value for the PR6 register at power up is 255.
<br></p><p>The timer interrupt flag (TMR6IF) is set based upon the number of match conditions as determine by the postscaler.&nbsp;&nbsp;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.
<br>
<br></p><p><span class="strong"><strong>Timer constants for the MicroChip microcontrollers</strong></span></p><p>Parameters for this timer are detailed in the tables below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>clocksource</em></span></code></p></td><td align="left" valign="top"><p>This is an optional parameter.  Please review the datasheet for specific usage.<br>
&nbsp;<br>
Source can be one of the following numeric values:<br>
&nbsp;<br>
         1 equates to OSC (FOSC/4). &nbsp;&nbsp;&nbsp;The default clock source<br>
        <br>
         6 equates to EXTOSC same as SOSC<br>
         5 equates to MFINTOSC<br>
         4 equates to LFINTOSC<br>
         3 equates to HFINTOSC<br>
         2 equates to FOSC<br>
         1 equates to FOSC/4 same as OSC<br>
         0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<br>
</p><p>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer.  See the tables below for permitted values.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the postscaler for this specific timer.  See the tables below for permitted values.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 1 shown above</strong></span></p><p><br>
<br></p><p><code class="literal">prescaler</code> can be one of the following settings, if you MicroChip microcontroller has the T6CKPS4 bit then refer to table 3:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS6_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS6_4</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS6_16</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS6_64</code></p></td><td align="center" valign="top"><p>3</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 2</strong></span></p><p>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS6_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">PS6_2</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS6_4</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS6_8</code></p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS6_16</code></p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:32</p></td><td align="left" valign="top"><p><code class="literal">PS6_32</code></p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS6_64</code></p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:128</p></td><td align="left" valign="top"><p><code class="literal">PS6_128</code></p></td><td align="center" valign="top"><p>7</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 3</strong></span>
<br>
<br></p><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</p><p>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Postcaler Value</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Use Numeric Constant</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1 Postscaler</p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2 Postscaler</p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:3 Postscaler</p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:4 Postscaler</p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:5 Postscaler</p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:6 Postscaler</p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:7 Postscaler</p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:8 Postscaler</p></td><td align="center" valign="top"><p>7</p></td></tr><tr><td align="center" valign="top"><p>1:9 Postscaler</p></td><td align="center" valign="top"><p>8</p></td></tr><tr><td align="center" valign="top"><p>1:10 Postscaler</p></td><td align="center" valign="top"><p>9</p></td></tr><tr><td align="center" valign="top"><p>1:11 Postscaler</p></td><td align="center" valign="top"><p>10</p></td></tr><tr><td align="center" valign="top"><p>1:12 Postscaler</p></td><td align="center" valign="top"><p>11</p></td></tr><tr><td align="center" valign="top"><p>1:13 Postscaler</p></td><td align="center" valign="top"><p>12</p></td></tr><tr><td align="center" valign="top"><p>1:14 Postscaler</p></td><td align="center" valign="top"><p>13</p></td></tr><tr><td align="center" valign="top"><p>1:15 Postscaler</p></td><td align="center" valign="top"><p>14</p></td></tr><tr><td align="center" valign="top"><p>1:16 Postscaler</p></td><td align="center" valign="top"><p>15</p></td></tr></tbody></table></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inittimer6"></span>InitTimer6

</div>

</div>

</div>

<span class="strong">**Syntax: (MicroChip PIC)**</span>

``` screen
    InitTimer6 prescaler, postscaler

or, where you required to state the clock source, use the following

    InitTimer6 clocksource, prescaler, postscaler
```

<span class="strong">**Syntax: (Atmel AVR)**</span>

``` screen
    InitTimer6 source, prescaler
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a Timer 6 module.  As shown above
a Microchip microcontroller can potentially support two types of methods
for initialisation.  
  
The first method is:  

``` screen
    InitTimer6 prescaler, postscaler
```

This the most common method to initialise a Microchip microcontroller
timer.  With this method the timer has only one possible clock source,
this mandated by the microcontrollers architecture, and that clock
source is the System Clock/4 also known as FOSC/4.  
  
  
The second method is much more flexible in term of the clock
source.  Microcontrollers that support this second method enable you to
select different clock sources and to select more prescale values.  The
method is shown below:  

``` screen
    InitTimer6 clocksource, prescaler, postscaler
```

<span class="strong">**How do you determine which method to use for your
specific Microchip microcontroller ?**</span>  
  
The timer type for a Microchip microcontroller can be determined by
checking for the existance of a T2CLKCON register, either in the
Datasheet or in the GCBASIC "dat file" for the specific device.  
  
If the Microchip microcontroller <span class="strong">**DOES
NOT**</span> have a T2CLKCON register then timers 2/4/6/8 for that
specific microcontroller chip use the first method, and are configured
using:  

``` screen
    InitTimer6 (PreScale, PostScale)
```

If the microcontroller <span class="strong">**DOES**</span> have a
T2CLKCON register then ALL timers 2/4/6/8 for that specific
microcontroller chip use the second method, and are configured using:

``` screen
    InitTimer6 (Source,PreScale,PostScale)
```

The possible Source, Prescale and Postscale constants for each type are
shown in the tables below.  These table are summary tables from the
Microchip datasheets.  
  

<span class="strong">**Period of the Timers**</span>

The Period of the timer is determined by the system clock speed, the
prescale value and 8-bit value in the respective timer period
register.  The timer period for timer 6 is held in register PR6.    

When the timer is enabled, by starting the timer, it will increment
until the TMR6 register matches the value in the PR6 register.  At this
time the TMR6 register is cleared to 0 and the timer continues to
increment until the next match, and so on.  

The lower the value of the PR6 register, the shorter the timer period
will be.  The default value for the PR6 register at power up is 255.  

The timer interrupt flag (TMR6IF) is set based upon the number of match
conditions as determine by the postscaler.  The postscaler does not
actually change the timer period, it changes the time between interrupt
conditions.  
  

<span class="strong">**Timer constants for the MicroChip
microcontrollers**</span>

Parameters for this timer are detailed in the tables below:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">clocksource</code></p></td>
<td style="text-align: left;"><p>This is an optional parameter. Please review the datasheet for specific usage.<br />
 <br />
Source can be one of the following numeric values:<br />
 <br />
1 equates to OSC (FOSC/4).    The default clock source<br />
<br />
6 equates to EXTOSC same as SOSC<br />
5 equates to MFINTOSC<br />
4 equates to LFINTOSC<br />
3 equates to HFINTOSC<br />
2 equates to FOSC<br />
1 equates to FOSC/4 same as OSC<br />
0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<br />
</p>
<p>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">prescaler</code></p></td>
<td style="text-align: left;"><p>The value of the prescaler for this specific timer. See the tables below for permitted values.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">postscaler</code></p></td>
<td style="text-align: left;"><p>The value of the postscaler for this specific timer. See the tables below for permitted values.</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Table 1 shown above**</span>

  
  

`prescaler` can be one of the following settings, if you MicroChip
microcontroller has the T6CKPS4 bit then refer to table 3:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS6_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS6_4</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS6_16</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS6_64</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Table 2**</span>

Note that a 1:64 prescale is only avaialable on certain midrange
microcontrollers. Please refer to the datasheet to determine if a 1:64
prescale is supported by a spectific microcontroller.  
  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS6_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:2</p></td>
<td style="text-align: left;"><p><code class="literal">PS6_2</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS6_4</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS6_8</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS6_16</code></p></td>
<td style="text-align: center;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:32</p></td>
<td style="text-align: left;"><p><code class="literal">PS6_32</code></p></td>
<td style="text-align: center;"><p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS6_64</code></p></td>
<td style="text-align: center;"><p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:128</p></td>
<td style="text-align: left;"><p><code class="literal">PS6_128</code></p></td>
<td style="text-align: center;"><p>7</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Table 3**</span>  
  

`postscaler` slows the rate of the interrupt generation (or WDT reset)
from a counter/timer by dividing it down.

On Microchip PIC microcontroller one of the following constants where
the Postscaler Rate Select bits are in the range of 1 to 16.

<div class="informaltable">

| <span class="strong">**Postcaler Value**</span> | <span class="strong">**Use Numeric Constant**</span> |
|:-----------------------------------------------:|:----------------------------------------------------:|
|                 1:1 Postscaler                  |                          0                           |
|                 1:2 Postscaler                  |                          1                           |
|                 1:3 Postscaler                  |                          2                           |
|                 1:4 Postscaler                  |                          3                           |
|                 1:5 Postscaler                  |                          4                           |
|                 1:6 Postscaler                  |                          5                           |
|                 1:7 Postscaler                  |                          6                           |
|                 1:8 Postscaler                  |                          7                           |
|                 1:9 Postscaler                  |                          8                           |
|                 1:10 Postscaler                 |                          9                           |
|                 1:11 Postscaler                 |                          10                          |
|                 1:12 Postscaler                 |                          11                          |
|                 1:13 Postscaler                 |                          12                          |
|                 1:14 Postscaler                 |                          13                          |
|                 1:15 Postscaler                 |                          14                          |
|                 1:16 Postscaler                 |                          15                          |

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitTimer7</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_inittimer6.html" title="InitTimer6"><link rel="next" href="_inittimer8.html" title="InitTimer8"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inittimer7"></a>InitTimer7</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">InitTimer7 <span class="emphasis"><em>source</em></span>, <span class="emphasis"><em>prescaler</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on  Microchip microcontrollers with a Timer 7 module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">InitTimer7</code> will set up timer 7.</p><p>Parameters are required as detailed in the table below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>source</em></span></code></p></td><td align="left" valign="top"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code>, <code class="literal">Ext</code> or <code class="literal">ExtOsc</code> where:<br>
<code class="literal">Osc</code> is an internal oscillator.<br>
<code class="literal">Ext</code> is an external oscillator.<br>
</p><p><br>
<br>
<code class="literal">Osc</code> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&nbsp;&nbsp;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</p><p><code class="literal">Ext</code> - Selects the clock source attached to a specific exernal interrupt input port.&nbsp;&nbsp;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.
<br>
<br>
</p><p><code class="literal">ExtOsc</code> is an external oscillator and only available on a Microchip PIC microcontroller.
</p><p>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources.  This includes, but limited to,  the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller  series.  On these devices the clock source can be one of the following:
</p><p><code class="literal">Osc</code> is an internal oscillator which is the same source as <code class="literal">FOSC4</code>.<br>
<code class="literal">Ext</code>  is an external oscillator which is the same source as <code class="literal">TxXKIPPS</code>.<br>
<code class="literal">ExtOsc</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br>
<code class="literal">FOSC</code> is an internal oscillator which is the Frequency of the OSCillator.<br>
<code class="literal">FOSC4</code> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<br>
<code class="literal">SOSC</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br>
<code class="literal">MFINTOSC</code> is an internal 500KHz internal clock oscillator.<br>
<code class="literal">LFINTOSC</code>  is an internal 31Khz internal clock oscillator.<br>
<code class="literal">HFINTOSC</code> is an oscillator as specified within the datasheet for each specific microcontroller.<br>
<code class="literal">TxCKIPPS</code> is an oscillator input on TxCKIPPS Pin.<br></p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer.  See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</p></td></tr></tbody></table></div><p>When the timer overflows an interrupt event will be generated.
This interrupt event can be used in conjunction with <code class="literal">On Interrupt</code> to run a section of code when the interrupt event occurs.
<br>
<br>
<br>
<br>
<span class="strong"><strong>Microchip PIC microcontrollers:</strong></span></p><p>On Microchip PIC microcontrollers <code class="literal"><span class="emphasis"><em>prescaler</em></span></code> must be one of the following constants:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS7_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2</p></td><td align="left" valign="top"><p><code class="literal">PS7_2</code></p></td><td align="center" valign="top"><p>16</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS7_4</code></p></td><td align="center" valign="top"><p>32</p></td></tr><tr><td align="center" valign="top"><p>1:8</p></td><td align="left" valign="top"><p><code class="literal">PS7_8</code></p></td><td align="center" valign="top"><p>48</p></td></tr></tbody></table></div><p>These correspond to a prescaler of between 1:2 and 1:8 of the oscillator (FOSC/4)
speed. The prescaler will apply to either the oscillator or the external
clock input.
<br>
<br>
<br>
<br></p><p><span class="strong"><strong>Supported in &lt;TIMER.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inittimer7"></span>InitTimer7

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
InitTimer7 source, prescaler
```

<span class="strong">**Command Availability:**</span>

Available on Microchip microcontrollers with a Timer 7 module.

<span class="strong">**Explanation:**</span>

`InitTimer7` will set up timer 7.

Parameters are required as detailed in the table below:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">source</code></p></td>
<td style="text-align: left;"><p>The clock source for this specific timer. Can be either <code class="literal">Osc</code>, <code class="literal">Ext</code> or <code class="literal">ExtOsc</code> where:<br />
<code class="literal">Osc</code> is an internal oscillator.<br />
<code class="literal">Ext</code> is an external oscillator.<br />
</p>
<p><br />
<br />
<code class="literal">Osc</code> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).  This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).</p>
<p><code class="literal">Ext</code> - Selects the clock source attached to a specific exernal interrupt input port.  This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.<br />
<br />
</p>
<p><code class="literal">ExtOsc</code> is an external oscillator and only available on a Microchip PIC microcontroller.</p>
<p>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources. This includes, but limited to, the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller series. On these devices the clock source can be one of the following:</p>
<p><code class="literal">Osc</code> is an internal oscillator which is the same source as <code class="literal">FOSC4</code>.<br />
<code class="literal">Ext</code> is an external oscillator which is the same source as <code class="literal">TxXKIPPS</code>.<br />
<code class="literal">ExtOsc</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br />
<code class="literal">FOSC</code> is an internal oscillator which is the Frequency of the OSCillator.<br />
<code class="literal">FOSC4</code> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<br />
<code class="literal">SOSC</code> is an external oscillator which is the same source as <code class="literal">SOSC</code>.<br />
<code class="literal">MFINTOSC</code> is an internal 500KHz internal clock oscillator.<br />
<code class="literal">LFINTOSC</code> is an internal 31Khz internal clock oscillator.<br />
<code class="literal">HFINTOSC</code> is an oscillator as specified within the datasheet for each specific microcontroller.<br />
<code class="literal">TxCKIPPS</code> is an oscillator input on TxCKIPPS Pin.<br />
</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">prescaler</code></p></td>
<td style="text-align: left;"><p>The value of the prescaler for this specific timer. See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</p></td>
</tr>
</tbody>
</table>

</div>

When the timer overflows an interrupt event will be generated. This
interrupt event can be used in conjunction with `On Interrupt` to run a
section of code when the interrupt event occurs.  
  
  
  
<span class="strong">**Microchip PIC microcontrollers:**</span>

On Microchip PIC microcontrollers `prescaler` must be one of the
following constants:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS7_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:2</p></td>
<td style="text-align: left;"><p><code class="literal">PS7_2</code></p></td>
<td style="text-align: center;"><p>16</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS7_4</code></p></td>
<td style="text-align: center;"><p>32</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:8</p></td>
<td style="text-align: left;"><p><code class="literal">PS7_8</code></p></td>
<td style="text-align: center;"><p>48</p></td>
</tr>
</tbody>
</table>

</div>

These correspond to a prescaler of between 1:2 and 1:8 of the oscillator
(FOSC/4) speed. The prescaler will apply to either the oscillator or the
external clock input.  
  
  
  

<span class="strong">**Supported in &lt;TIMER.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InitTimer8</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_inittimer7.html" title="InitTimer7"><link rel="next" href="_inittimer10.html" title="InitTimer10"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inittimer8"></a>InitTimer8</h4></div></div></div><p><span class="strong"><strong>Syntax: (MicroChip PIC)</strong></span></p><pre class="screen">    InitTimer8 <span class="emphasis"><em>prescaler</em></span>, <span class="emphasis"><em>postscaler</em></span>

or, where you required to state the clock source, use the following

    InitTimer8 <span class="emphasis"><em>clocksource</em></span>, <span class="emphasis"><em>prescaler</em></span>, <span class="emphasis"><em>postscaler</em></span></pre><p><span class="strong"><strong>Syntax: (Atmel AVR)</strong></span></p><pre class="screen">    InitTimer8 <span class="emphasis"><em>source</em></span>, <span class="emphasis"><em>prescaler</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a Timer 8 module.&nbsp;&nbsp;As shown above a Microchip microcontroller can potentially support two types of methods for initialisation.
<br>
<br>
The first method is:
<br></p><pre class="screen">    InitTimer8 prescaler, postscaler</pre><p>This the most common method to initialise a Microchip microcontroller timer.&nbsp;&nbsp;With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.
<br>
<br>
<br>
The second method is much more flexible in term of the clock source.&nbsp;&nbsp;Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values.&nbsp;&nbsp;The method is shown below:
<br></p><pre class="screen">    InitTimer8 clocksource, prescaler, postscaler</pre><p><span class="strong"><strong>How do you determine which method to use for your specific Microchip microcontroller ?</strong></span>
<br>
<br>
The timer type for a Microchip microcontroller can be determined by checking for the existance of a T2CLKCON register, either in the Datasheet or in the GCBASIC  "dat file" for the specific device.
<br>
<br>
If the Microchip microcontroller <span class="strong"><strong>DOES NOT</strong></span> have a T2CLKCON register then timers 2/4/6/8 for that specific microcontroller chip use the first method, and are configured using:
<br></p><pre class="screen">    InitTimer8 (PreScale, PostScale)</pre><p>If the microcontroller <span class="strong"><strong>DOES</strong></span> have a T2CLKCON register then ALL timers 2/4/6/8 for that specific microcontroller chip use the second method, and are configured using:</p><pre class="screen">    InitTimer8 (Source,PreScale,PostScale)</pre><p>The possible Source, Prescale and Postscale constants for each type are shown in the tables below.&nbsp;&nbsp;These table are summary tables from the Microchip datasheets.
<br>
<br></p><p><span class="strong"><strong>Period of the Timers</strong></span></p><p>The Period of the timer is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&nbsp;&nbsp;The timer period for timer 8 is held in register PR8.&nbsp;&nbsp;
<br></p><p>When the timer is enabled, by starting the timer, it will increment until the TMR8 register matches the value in the PR8 register.&nbsp;&nbsp;At this time the TMR8 register is cleared to 0 and the timer continues to increment until the next match, and so on.
<br></p><p>The lower the value of the PR8 register, the shorter the timer period will be.&nbsp;&nbsp;The default value for the PR8 register at power up is 255.
<br></p><p>The timer interrupt flag (TMR8IF) is set based upon the number of match conditions as determine by the postscaler.&nbsp;&nbsp;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.
<br>
<br></p><p><span class="strong"><strong>Timer constants for the MicroChip microcontrollers</strong></span></p><p>Parameters for this timer are detailed in the tables below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>clocksource</em></span></code></p></td><td align="left" valign="top"><p>This is an optional parameter.  Please review the datasheet for specific usage.<br>
&nbsp;<br>
Source can be one of the following numeric values:<br>
&nbsp;<br>
         1 equates to OSC (FOSC/4). &nbsp;&nbsp;&nbsp;The default clock source<br>
        <br>
         6 equates to EXTOSC same as SOSC<br>
         5 equates to MFINTOSC<br>
         4 equates to LFINTOSC<br>
         3 equates to HFINTOSC<br>
         2 equates to FOSC<br>
         1 equates to FOSC/4 same as OSC<br>
         0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<br>
</p><p>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>prescaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the prescaler for this specific timer.  See the tables below for permitted values.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code></p></td><td align="left" valign="top"><p>The value of the postscaler for this specific timer.  See the tables below for permitted values.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Table 1 shown above</strong></span></p><p><br>
<br></p><p><code class="literal">prescaler</code> can be one of the following settings:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Prescaler Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Primary GCB Constant</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Equates<br>
to value</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1</p></td><td align="left" valign="top"><p><code class="literal">PS8_1</code></p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:4</p></td><td align="left" valign="top"><p><code class="literal">PS8_4</code></p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:16</p></td><td align="left" valign="top"><p><code class="literal">PS8_16</code></p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:64</p></td><td align="left" valign="top"><p><code class="literal">PS8_64</code></p></td><td align="center" valign="top"><p>3</p></td></tr></tbody></table></div><p>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.</p><p><br>
<br></p><p><code class="literal"><span class="emphasis"><em>postscaler</em></span></code> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</p><p>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Postcaler Value</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Use Numeric Constant</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>1:1 Postscaler</p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1:2 Postscaler</p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>1:3 Postscaler</p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>1:4 Postscaler</p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>1:5 Postscaler</p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>1:6 Postscaler</p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>1:7 Postscaler</p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>1:8 Postscaler</p></td><td align="center" valign="top"><p>7</p></td></tr><tr><td align="center" valign="top"><p>1:9 Postscaler</p></td><td align="center" valign="top"><p>8</p></td></tr><tr><td align="center" valign="top"><p>1:10 Postscaler</p></td><td align="center" valign="top"><p>9</p></td></tr><tr><td align="center" valign="top"><p>1:11 Postscaler</p></td><td align="center" valign="top"><p>10</p></td></tr><tr><td align="center" valign="top"><p>1:12 Postscaler</p></td><td align="center" valign="top"><p>11</p></td></tr><tr><td align="center" valign="top"><p>1:13 Postscaler</p></td><td align="center" valign="top"><p>12</p></td></tr><tr><td align="center" valign="top"><p>1:14 Postscaler</p></td><td align="center" valign="top"><p>13</p></td></tr><tr><td align="center" valign="top"><p>1:15 Postscaler</p></td><td align="center" valign="top"><p>14</p></td></tr><tr><td align="center" valign="top"><p>1:16 Postscaler</p></td><td align="center" valign="top"><p>15</p></td></tr></tbody></table></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inittimer8"></span>InitTimer8

</div>

</div>

</div>

<span class="strong">**Syntax: (MicroChip PIC)**</span>

``` screen
    InitTimer8 prescaler, postscaler

or, where you required to state the clock source, use the following

    InitTimer8 clocksource, prescaler, postscaler
```

<span class="strong">**Syntax: (Atmel AVR)**</span>

``` screen
    InitTimer8 source, prescaler
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a Timer 8 module.  As shown above
a Microchip microcontroller can potentially support two types of methods
for initialisation.  
  
The first method is:  

``` screen
    InitTimer8 prescaler, postscaler
```

This the most common method to initialise a Microchip microcontroller
timer.  With this method the timer has only one possible clock source,
this mandated by the microcontrollers architecture, and that clock
source is the System Clock/4 also known as FOSC/4.  
  
  
The second method is much more flexible in term of the clock
source.  Microcontrollers that support this second method enable you to
select different clock sources and to select more prescale values.  The
method is shown below:  

``` screen
    InitTimer8 clocksource, prescaler, postscaler
```

<span class="strong">**How do you determine which method to use for your
specific Microchip microcontroller ?**</span>  
  
The timer type for a Microchip microcontroller can be determined by
checking for the existance of a T2CLKCON register, either in the
Datasheet or in the GCBASIC "dat file" for the specific device.  
  
If the Microchip microcontroller <span class="strong">**DOES
NOT**</span> have a T2CLKCON register then timers 2/4/6/8 for that
specific microcontroller chip use the first method, and are configured
using:  

``` screen
    InitTimer8 (PreScale, PostScale)
```

If the microcontroller <span class="strong">**DOES**</span> have a
T2CLKCON register then ALL timers 2/4/6/8 for that specific
microcontroller chip use the second method, and are configured using:

``` screen
    InitTimer8 (Source,PreScale,PostScale)
```

The possible Source, Prescale and Postscale constants for each type are
shown in the tables below.  These table are summary tables from the
Microchip datasheets.  
  

<span class="strong">**Period of the Timers**</span>

The Period of the timer is determined by the system clock speed, the
prescale value and 8-bit value in the respective timer period
register.  The timer period for timer 8 is held in register PR8.    

When the timer is enabled, by starting the timer, it will increment
until the TMR8 register matches the value in the PR8 register.  At this
time the TMR8 register is cleared to 0 and the timer continues to
increment until the next match, and so on.  

The lower the value of the PR8 register, the shorter the timer period
will be.  The default value for the PR8 register at power up is 255.  

The timer interrupt flag (TMR8IF) is set based upon the number of match
conditions as determine by the postscaler.  The postscaler does not
actually change the timer period, it changes the time between interrupt
conditions.  
  

<span class="strong">**Timer constants for the MicroChip
microcontrollers**</span>

Parameters for this timer are detailed in the tables below:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">clocksource</code></p></td>
<td style="text-align: left;"><p>This is an optional parameter. Please review the datasheet for specific usage.<br />
 <br />
Source can be one of the following numeric values:<br />
 <br />
1 equates to OSC (FOSC/4).    The default clock source<br />
<br />
6 equates to EXTOSC same as SOSC<br />
5 equates to MFINTOSC<br />
4 equates to LFINTOSC<br />
3 equates to HFINTOSC<br />
2 equates to FOSC<br />
1 equates to FOSC/4 same as OSC<br />
0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<br />
</p>
<p>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">prescaler</code></p></td>
<td style="text-align: left;"><p>The value of the prescaler for this specific timer. See the tables below for permitted values.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">postscaler</code></p></td>
<td style="text-align: left;"><p>The value of the postscaler for this specific timer. See the tables below for permitted values.</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Table 1 shown above**</span>

  
  

`prescaler` can be one of the following settings:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="strong"><strong>Prescaler Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Primary GCB Constant</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Constant Equates<br />
to value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>1:1</p></td>
<td style="text-align: left;"><p><code class="literal">PS8_1</code></p></td>
<td style="text-align: center;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:4</p></td>
<td style="text-align: left;"><p><code class="literal">PS8_4</code></p></td>
<td style="text-align: center;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>1:16</p></td>
<td style="text-align: left;"><p><code class="literal">PS8_16</code></p></td>
<td style="text-align: center;"><p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1:64</p></td>
<td style="text-align: left;"><p><code class="literal">PS8_64</code></p></td>
<td style="text-align: center;"><p>3</p></td>
</tr>
</tbody>
</table>

</div>

Note that a 1:64 prescale is only avaialable on certain midrange
microcontrollers. Please refer to the datasheet to determine if a 1:64
prescale is supported by a spectific microcontroller.

  
  

`postscaler` slows the rate of the interrupt generation (or WDT reset)
from a counter/timer by dividing it down.

On Microchip PIC microcontroller one of the following constants where
the Postscaler Rate Select bits are in the range of 1 to 16.

<div class="informaltable">

| <span class="strong">**Postcaler Value**</span> | <span class="strong">**Use Numeric Constant**</span> |
|:-----------------------------------------------:|:----------------------------------------------------:|
|                 1:1 Postscaler                  |                          0                           |
|                 1:2 Postscaler                  |                          1                           |
|                 1:3 Postscaler                  |                          2                           |
|                 1:4 Postscaler                  |                          3                           |
|                 1:5 Postscaler                  |                          4                           |
|                 1:6 Postscaler                  |                          5                           |
|                 1:7 Postscaler                  |                          6                           |
|                 1:8 Postscaler                  |                          7                           |
|                 1:9 Postscaler                  |                          8                           |
|                 1:10 Postscaler                 |                          9                           |
|                 1:11 Postscaler                 |                          10                          |
|                 1:12 Postscaler                 |                          11                          |
|                 1:13 Postscaler                 |                          12                          |
|                 1:14 Postscaler                 |                          13                          |
|                 1:15 Postscaler                 |                          14                          |
|                 1:16 Postscaler                 |                          15                          |

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>InKey</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_ps_2.html" title="PS/2"><link rel="prev" href="_ps_2_overview.html" title="PS/2 Overview"><link rel="next" href="_ps2setkbleds.html" title="PS2SetKBLeds"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inkey"></a>InKey</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    output = InKey</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">InKey</code> function will read the last pressed key from a PS/2 keyboard,
and return an ASCII value corresponding to the key. If no key is
pressed, then <code class="literal">InKey</code> will return 0.</p><p>It will also monitor Caps Lock, Num Lock and Scroll Lock keys, and
update the status LEDs as appropriate.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">	'A program to accept messages from a standard PS/2 keyboard
	'Any keys pressed will be shown on an LCD screen.

	'Hardware settings
	#chip 18F4620, 20

	'LCD connection settings
	#define LCD_IO 4
	#define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
	#define LCD_DB4 PORTD.4
	#define LCD_DB5 PORTD.5
	#define LCD_DB6 PORTD.6
	#define LCD_DB7 PORTD.7
	#define LCD_RS PORTD.0
	#define LCD_RW PORTD.1
	#define LCD_Enable PORTD.2

	'PS/2 connection settings
	#define PS2Clock PORTC.1
	#define PS2Data PORTC.0
	#define PS2_DELAY 10 ms

	'Set up key log
	Dim KeyLog(32)
	DataCount = 0
	KeyLog(1) = 32

	Main:
		'Read the last pressed key
		KeyIn = INKEY
		'If no key pressed, try reading again
		If KeyIn = 0 Then Goto Main

		'Escape pressed - clear message
		If KeyIn = 27 Then
			DataCount = 0
			For DataPos = 1 to 32
				KeyLog(DataPos) = 32
			Next
			Goto DisplayData
		End If

		'Backspace pressed - delete last character
		If KeyIn = 8 Then
			If DataCount = 0 Then Goto Main
			KeyLog(DataCount) = 32
			DataCount = DataCount - 1
			Goto DisplayData
		End If

		'Otherwise, add the character to the buffer
		If KeyIn &gt;= 31 And KeyIn &lt;= 127 Then
			DataCount = DataCount + 1
			KeyLog(DataCount) = KeyIn
		End If

	DisplayData:
		'Display key buffer
		'LCDWriteChar is used instead of Print for greater control
		CLS
		For DataPos = 1 to DataCount
			If DataPos = 17 then Locate 1, 0
			LCDWriteChar KeyLog(DataPos)
		Next

	Goto Main</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inkey"></span>InKey

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    output = InKey
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `InKey` function will read the last pressed key from a PS/2
keyboard, and return an ASCII value corresponding to the key. If no key
is pressed, then `InKey` will return 0.

It will also monitor Caps Lock, Num Lock and Scroll Lock keys, and
update the status LEDs as appropriate.

<span class="strong">**Example:**</span>

``` screen
  'A program to accept messages from a standard PS/2 keyboard
    'Any keys pressed will be shown on an LCD screen.

    'Hardware settings
    #chip 18F4620, 20

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'PS/2 connection settings
    #define PS2Clock PORTC.1
    #define PS2Data PORTC.0
    #define PS2_DELAY 10 ms

    'Set up key log
    Dim KeyLog(32)
    DataCount = 0
    KeyLog(1) = 32

    Main:
        'Read the last pressed key
        KeyIn = INKEY
        'If no key pressed, try reading again
        If KeyIn = 0 Then Goto Main

        'Escape pressed - clear message
        If KeyIn = 27 Then
            DataCount = 0
            For DataPos = 1 to 32
                KeyLog(DataPos) = 32
            Next
            Goto DisplayData
        End If

        'Backspace pressed - delete last character
        If KeyIn = 8 Then
            If DataCount = 0 Then Goto Main
            KeyLog(DataCount) = 32
            DataCount = DataCount - 1
            Goto DisplayData
        End If

        'Otherwise, add the character to the buffer
        If KeyIn >= 31 And KeyIn <= 127 Then
            DataCount = DataCount + 1
            KeyLog(DataCount) = KeyIn
        End If

    DisplayData:
        'Display key buffer
        'LCDWriteChar is used instead of Print for greater control
        CLS
        For DataPos = 1 to DataCount
            If DataPos = 17 then Locate 1, 0
            LCDWriteChar KeyLog(DataPos)
        Next

    Goto Main
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Inputs/Outputs</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microcontroller_fundamentals.html" title="Microcontroller Fundamentals"><link rel="prev" href="_microcontroller_fundamentals.html" title="Microcontroller Fundamentals"><link rel="next" href="_configuration.html" title="Configuration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_inputs_outputs"></a>Inputs/Outputs</h3></div></div></div><p><span class="strong"><strong>About Inputs and Outputs</strong></span></p><p>Most general purpose pins on a microcontroller can function in one of
two modes: input mode, or output mode.</p><p>When acting as an input, the general purpose input/output pin will be placed in a high impedance state.
The microcontroller will then sense the general purpose input/output pin, and the program can read
the state of the general purpose input/output pin and make decisions based on it.</p><p>When in output mode, the microcontroller will connect the general purpose input/output pin to either
Vcc (the positive supply), or Vss (ground, or the negative supply). The
program can then set the state of the general purpose input/output pin to either high or low.</p><p>GCBASIC will attempt to determine the direction of each general purpose input/output pin, and set it
appropriately, when possible. GCBASIC will try to set the direction of the general purpose input/output pin.
However, if the general purpose input/output pin is read from and written to in your program, then
the general purpose input/output pin must be configured to input or output mode by the program, using
the appropriate <a class="link" href="_dir.html" title="Dir">Dir</a> commands.</p><p>Example of <code class="literal">dir</code> commands.</p><pre class="screen">    'The port address is microcontroller specific.  Portx.x is a general case for PICs and AVRs
    dir portb.0 in
    dir portb.1 out

    'The port address is microcontroller specific.  gpiox.x is a general case for some PICs
    dir gpio.0 in
    dir gpio.1 Out

    'Set the whole port as an output
    dir portb out
    dir gpio out

    'Set the whole port as an input
    dir portc in
    dir gpio in</pre><p><span class="strong"><strong>Microchip specifics for read/write operations</strong></span></p><p>For the specific ports and general purpose input/output pins available for a specific microcontroller please refer to the datasheet.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Port</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>PORTx maps to the microcontrollers digital pins 0 to 7. Where x can be a,b,c,d,e,f or g</p></td><td align="left" valign="top"><p>Read:
</p><p>PORTx the port data register for a  read operation.</p></td><td align="left" valign="top"><p>uservar=PORTA
</p><p>uservar=PORTA.1</p></td></tr><tr><td align="left" valign="top"><p>PORTx maps to microcontrollers digital pins 0 to 7. Where x can be a,b,c,d,e,f or g</p></td><td align="left" valign="top"><p>Write:
</p><p>PORTx the port data register for a  write operation, and, where LATx is not required as GCBASIC will implement LATx when needed.
</p><p>See <a class="link" href="__option_nolatch.html" title="#Option NoLatch">Option NoLatch</a> for more information on LAT registers and how to disable this automatic function.</p></td><td align="left" valign="top"><p>PORTA=255
</p><p>PORTA.1=1</p></td></tr></tbody></table></div><p>To read a general purpose input/output pin, you need to ensure the direction is correct <code class="literal">DIR Portx IN</code> is set (default is IN) or a specific set of port bits.
Where <code class="literal">uservar = PORTx.n</code> can be used.</p><p>Examples:</p><pre class="screen">    uservar = PORTb.0
    uservar = PORTb</pre><p>To write to a general purpose input/output pin, you need to ensure the direction is correct <code class="literal">DIR Portx OUT</code> for port or a specific set of port bits.
Where  <code class="literal">PORTx.n = uservar</code> can be used.</p><p>Examples:</p><pre class="screen">    PORTb.0 = uservar
    PORTb = uservar</pre><p><span class="strong"><strong>ATMEL specifics for read/write operations</strong></span></p><p>Using a Mega328p as a general the following provides insights for the AVR devices.  For the specific ports and general purpose input/output pins available for a specific microcontroller please refer to the datasheet.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Port</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Write operation</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Read operation</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>PORTD maps to Mega328p (and, the AVR microcontrollers) digital pins 0 to 7</p></td><td align="left" valign="top"><p>PORTD - The Port D Data Register - write operation  (a read operation to a port will provide the pull-up status)</p></td><td align="left" valign="top"><p>PIND - The Port D Input Pins Register - read only</p></td></tr><tr><td align="left" valign="top"><p>PORTB maps to Mega328p (and, the AVR microcontrollers) digital pins 8 to 13. The two high bits (6 &amp; 7) map to the crystal pins and are not usable</p></td><td align="left" valign="top"><p>PORTB - The Port B Data Register - write operation  (a read operation to a port will provide the pull-up status)</p></td><td align="left" valign="top"><p>PINB - The Port B Input Pins Register - read only</p></td></tr><tr><td align="left" valign="top"><p>PORTC maps to Mega328p (and, the AVR microcontrollers) analog pins 0 to 5. Pins 6 &amp; 7 are only accessible on the Mega328p (and, the AVR microcontrollers) Mini</p></td><td align="left" valign="top"><p>PORTC - The Port C Data Register - write operation (a read operation to a port will provide the pull-up status)</p></td><td align="left" valign="top"><p>PINC - The Port C Input Pins Register - read only</p></td></tr></tbody></table></div><p>To read a general purpose input/output pin, you need to ensure the direction is correct <code class="literal">DIR Portx IN</code> is set (default is IN) or a specific set of port bits.
Where <code class="literal">uservar = PINx.n</code> can be used and therefore to read data port use <code class="literal">uservar = PINx</code>.</p><p>Examples:</p><pre class="screen">    uservar = PINb.0
    uservar = PINb</pre><p>To write to a general purpose input/output pin you need to ensure the direction is correct <code class="literal">DIR Portx OUT</code> for port or a specific set of port bits.
Where <code class="literal">PORTx.n = uservar</code> can be used and therefore to write to a data port use <code class="literal">PORTx = uservar</code>.</p><p>Examples:</p><pre class="screen">    PORTb.0 = uservar
    PORTb = uservar</pre><p><br>
<br>
<span class="strong"><strong>Setting Ports and Port.bit</strong></span></p><p>You can set a port as shown above with a variable, or, you can set with a constant or any combination using the bitwise and logical operators.</p><pre class="screen">    #define InitStateofPort 0b11110000
    PORTb = InitStateofPort               'will unconditionally set bits 4:7

    PORTb = 0b11110000                    'will unconditionally set bits 4:7

    PORTb = uservar OR 0b11110000         'will OR bits 4:7 to ensure bits 4:7 are set</pre><p>The following is also valid - read a port.bit and then set port.bit with a variable or port value. As shown below.</p><pre class="screen">    dir portb out

    portb.0 = NOT  portb.0</pre><p>The user code above may cause issues with glitches when the read and write operations occurs.  Let us look at the generated assembler.</p><pre class="screen">    ;portb.0 = NOT  portb.0
      banksel SYSTEMP1
      clrf  SysTemp1
      btfsc PORTB,0
      incf  SysTemp1,F
      comf  SysTemp1,F
      bcf PORTB,0
      btfsc SysTemp1,0
      bsf PORTB,0</pre><p>To resolve any glitches add <code class="literal">#option Volatile</code> to your user code.</p><pre class="screen">    #option Volatile portb.0

    dir portb out

    portb.0 = NOT  portb.0</pre><p>This option provides the following assembler resolving the glitch issue.</p><pre class="screen">    ;portb.0 = NOT  portb.0
      banksel SYSTEMP1
      clrf  SysTemp1
      btfsc PORTB,0
      incf  SysTemp1,F
      comf  SysTemp1,F
      btfsc SysTemp1,0
      bsf PORTB,0
      btfss SysTemp1,0
      bcf PORTB,0</pre><p><br>
<br></p><p><span class="strong"><strong>See also</strong></span>  <a class="link" href="_dir.html" title="Dir">Dir</a>, <a class="link" href="__option_volatile.html" title="#Option Volatile">#Option Volatile</a></p><p><br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="inputs_outputs"></span>Inputs/Outputs

</div>

</div>

</div>

<span class="strong">**About Inputs and Outputs**</span>

Most general purpose pins on a microcontroller can function in one of
two modes: input mode, or output mode.

When acting as an input, the general purpose input/output pin will be
placed in a high impedance state. The microcontroller will then sense
the general purpose input/output pin, and the program can read the state
of the general purpose input/output pin and make decisions based on it.

When in output mode, the microcontroller will connect the general
purpose input/output pin to either Vcc (the positive supply), or Vss
(ground, or the negative supply). The program can then set the state of
the general purpose input/output pin to either high or low.

GCBASIC will attempt to determine the direction of each general purpose
input/output pin, and set it appropriately, when possible. GCBASIC will
try to set the direction of the general purpose input/output pin.
However, if the general purpose input/output pin is read from and
written to in your program, then the general purpose input/output pin
must be configured to input or output mode by the program, using the
appropriate <a href="dir" class="link" title="Dir">Dir</a>
commands.

Example of `dir` commands.

``` screen
    'The port address is microcontroller specific.  Portx.x is a general case for PICs and AVRs
    dir portb.0 in
    dir portb.1 out

    'The port address is microcontroller specific.  gpiox.x is a general case for some PICs
    dir gpio.0 in
    dir gpio.1 Out

    'Set the whole port as an output
    dir portb out
    dir gpio out

    'Set the whole port as an input
    dir portc in
    dir gpio in
```

<span class="strong">**Microchip specifics for read/write
operations**</span>

For the specific ports and general purpose input/output pins available
for a specific microcontroller please refer to the datasheet.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Port</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Purpose</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Example</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>PORTx maps to the microcontrollers digital pins 0 to 7. Where x can be a,b,c,d,e,f or g</p></td>
<td style="text-align: left;"><p>Read:</p>
<p>PORTx the port data register for a read operation.</p></td>
<td style="text-align: left;"><p>uservar=PORTA</p>
<p>uservar=PORTA.1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>PORTx maps to microcontrollers digital pins 0 to 7. Where x can be a,b,c,d,e,f or g</p></td>
<td style="text-align: left;"><p>Write:</p>
<p>PORTx the port data register for a write operation, and, where LATx is not required as GCBASIC will implement LATx when needed.</p>
<p>See <a href="_option_nolatch" class="link" title="#Option NoLatch">Option NoLatch</a> for more information on LAT registers and how to disable this automatic function.</p></td>
<td style="text-align: left;"><p>PORTA=255</p>
<p>PORTA.1=1</p></td>
</tr>
</tbody>
</table>

</div>

To read a general purpose input/output pin, you need to ensure the
direction is correct `DIR Portx IN` is set (default is IN) or a specific
set of port bits. Where `uservar = PORTx.n` can be used.

Examples:

``` screen
    uservar = PORTb.0
    uservar = PORTb
```

To write to a general purpose input/output pin, you need to ensure the
direction is correct `DIR Portx OUT` for port or a specific set of port
bits. Where `PORTx.n = uservar` can be used.

Examples:

``` screen
    PORTb.0 = uservar
    PORTb = uservar
```

<span class="strong">**ATMEL specifics for read/write
operations**</span>

Using a Mega328p as a general the following provides insights for the
AVR devices. For the specific ports and general purpose input/output
pins available for a specific microcontroller please refer to the
datasheet.

<div class="informaltable">

| <span class="strong">**Port**</span>                                                                                                                           | <span class="strong">**Write operation**</span>                                                                 | <span class="strong">**Read operation**</span>    |
|:---------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------|:--------------------------------------------------|
| PORTD maps to Mega328p (and, the AVR microcontrollers) digital pins 0 to 7                                                                                     | PORTD - The Port D Data Register - write operation (a read operation to a port will provide the pull-up status) | PIND - The Port D Input Pins Register - read only |
| PORTB maps to Mega328p (and, the AVR microcontrollers) digital pins 8 to 13. The two high bits (6 & 7) map to the crystal pins and are not usable              | PORTB - The Port B Data Register - write operation (a read operation to a port will provide the pull-up status) | PINB - The Port B Input Pins Register - read only |
| PORTC maps to Mega328p (and, the AVR microcontrollers) analog pins 0 to 5. Pins 6 & 7 are only accessible on the Mega328p (and, the AVR microcontrollers) Mini | PORTC - The Port C Data Register - write operation (a read operation to a port will provide the pull-up status) | PINC - The Port C Input Pins Register - read only |

</div>

To read a general purpose input/output pin, you need to ensure the
direction is correct `DIR Portx IN` is set (default is IN) or a specific
set of port bits. Where `uservar = PINx.n` can be used and therefore to
read data port use `uservar = PINx`.

Examples:

``` screen
    uservar = PINb.0
    uservar = PINb
```

To write to a general purpose input/output pin you need to ensure the
direction is correct `DIR Portx OUT` for port or a specific set of port
bits. Where `PORTx.n = uservar` can be used and therefore to write to a
data port use `PORTx = uservar`.

Examples:

``` screen
    PORTb.0 = uservar
    PORTb = uservar
```

  
  
<span class="strong">**Setting Ports and Port.bit**</span>

You can set a port as shown above with a variable, or, you can set with
a constant or any combination using the bitwise and logical operators.

``` screen
    #define InitStateofPort 0b11110000
    PORTb = InitStateofPort               'will unconditionally set bits 4:7

    PORTb = 0b11110000                    'will unconditionally set bits 4:7

    PORTb = uservar OR 0b11110000         'will OR bits 4:7 to ensure bits 4:7 are set
```

The following is also valid - read a port.bit and then set port.bit with
a variable or port value. As shown below.

``` screen
    dir portb out

    portb.0 = NOT  portb.0
```

The user code above may cause issues with glitches when the read and
write operations occurs. Let us look at the generated assembler.

``` screen
    ;portb.0 = NOT  portb.0
      banksel SYSTEMP1
      clrf  SysTemp1
      btfsc PORTB,0
      incf  SysTemp1,F
      comf  SysTemp1,F
      bcf PORTB,0
      btfsc SysTemp1,0
      bsf PORTB,0
```

To resolve any glitches add `#option Volatile` to your user code.

``` screen
    #option Volatile portb.0

    dir portb out

    portb.0 = NOT  portb.0
```

This option provides the following assembler resolving the glitch issue.

``` screen
    ;portb.0 = NOT  portb.0
      banksel SYSTEMP1
      clrf  SysTemp1
      btfsc PORTB,0
      incf  SysTemp1,F
      comf  SysTemp1,F
      btfsc SysTemp1,0
      bsf PORTB,0
      btfss SysTemp1,0
      bcf PORTB,0
```

  
  

<span class="strong">**See also**</span>
<a href="dir" class="link" title="Dir">Dir</a>,
<a href="_option_volatile" class="link" title="#Option Volatile">#Option Volatile</a>

  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Instr</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_hex.html" title="Hex"><link rel="next" href="_lcase.html" title="LCase"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_instr"></a>Instr</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>location</em></span> = Instr(<span class="emphasis"><em>source</em></span>, <span class="emphasis"><em>find</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Instr</code> function will search one string to find the location of another string within it. <code class="literal"><span class="emphasis"><em>source</em></span></code> is the string to search inside, and <code class="literal"><span class="emphasis"><em>find</em></span></code> is the string to find. The function will return the location of <code class="literal"><span class="emphasis"><em>find</em></span></code> within <code class="literal"><span class="emphasis"><em>source</em></span></code>, or 0 if <code class="literal"><span class="emphasis"><em>source</em></span></code> does not contain <code class="literal"><span class="emphasis"><em>find</em></span></code>.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the location of "world" within the string
    'Will return 8, because "w" in world is the 8th character
    'of "Hello, world!"
    HSerPrint Instr(TestData, "world")
    HSerPrintCRLF

    'Display the location of "planet" within the string
    'Will display 0, because "planet" does not occur inside
    'the string "Hello, world!"
    HSerPrint Instr(TestData, "planet")
    HSerPrintCRLF</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="instr"></span>Instr

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    location = Instr(source, find)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Instr` function will search one string to find the location of
another string within it. `source` is the string to search inside, and
`find` is the string to find. The function will return the location of
`find` within `source`, or 0 if `source` does not contain `find`.

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the location of "world" within the string
    'Will return 8, because "w" in world is the 8th character
    'of "Hello, world!"
    HSerPrint Instr(TestData, "world")
    HSerPrintCRLF

    'Display the location of "planet" within the string
    'Will display 0, because "planet" does not occur inside
    'the string "Hello, world!"
    HSerPrint Instr(TestData, "planet")
    HSerPrintCRLF
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>IntegerToBin</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_val.html" title="Val"><link rel="next" href="_longtobin.html" title="LongToBin"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_integertobin"></a>IntegerToBin</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>stringvar</em></span> = IntegerToBin(<span class="emphasis"><em>integervar</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">IntegerToBin</code> function creates a string of a ANSI (signed 15 digit string ) characters.
The function converts a number to a string consisting of ones and zeros that represents the binary value.</p><p><span class="strong"><strong>Note:</strong></span>
Supports Integer variables only.  For BYTE variables use <code class="literal">VarToBin</code>, for Word variables use <code class="literal">WordToBin</code> and for LONG variables use <code class="literal">LongToBin</code></p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    string = IntegerToBin( 1 )   ' Returns "+000000000000001"
    string = IntegerToBin( -1 )  ' Returns "-000000000000001"</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_bytetobin.html" title="ByteToBin">ByteToBin</a>, <a class="link" href="_wordtobin.html" title="WordToBin">WordToBin</a>, <a class="link" href="_longtobin.html" title="LongToBin">LongToBin</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="integertobin"></span>IntegerToBin

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    stringvar = IntegerToBin(integervar)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `IntegerToBin` function creates a string of a ANSI (signed 15 digit
string ) characters. The function converts a number to a string
consisting of ones and zeros that represents the binary value.

<span class="strong">**Note:**</span> Supports Integer variables only.
For BYTE variables use `VarToBin`, for Word variables use `WordToBin`
and for LONG variables use `LongToBin`

<span class="strong">**Example:**</span>

``` screen
    string = IntegerToBin( 1 )   ' Returns "+000000000000001"
    string = IntegerToBin( -1 )  ' Returns "-000000000000001"
```

<span class="strong">**For more help, see**</span>
<a href="bytetobin" class="link" title="ByteToBin">ByteToBin</a>,
<a href="wordtobin" class="link" title="WordToBin">WordToBin</a>,
<a href="longtobin" class="link" title="LongToBin">LongToBin</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Interrupts</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_fvrisoutputready.html" title="FVRIsOutputReady"><link rel="next" href="_interrupts_overview.html" title="Interrupts overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_interrupts"></a>Interrupts</h3></div></div></div><p>This is the Interrupt section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="interrupts"></span>Interrupts

</div>

</div>

</div>

This is the Interrupt section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Interrupts overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_interrupts.html" title="Interrupts"><link rel="prev" href="_interrupts.html" title="Interrupts"><link rel="next" href="_intoff.html" title="IntOff"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_interrupts_overview"></a>Interrupts overview</h4></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>Interrupts are a feature of many microcontrollers. They allow the
microcontroller to temporarily pause (interrupt) the code it is running
and then start running another piece of code when some event occurs.
Once it has dealt with the event, it will return to where it was and
continue running the program.</p><p>Many events can trigger an interrupt, such as a timer reaching its
limit, a serial message being received, or a special pin on the
microcontroller receiving a signal.</p><p><span class="strong"><strong>Using Interrupts</strong></span></p><p>There are two ways to use interrupts in GCBASIC. The first way is to use
the On Interrupt command. This will automatically enable a given
interrupt, and run a particular subroutine when the interrupt occurs.</p><p>The other way to deal with interrupts is to create a subroutine called
Interrupt. GCBASIC will call this subroutine whenever an interrupt
occurs, and then your code can check the "flag" bits to determine which
interrupt has occured, and what should be done about it. If you use this
approach, then you&#8217;ll need to enable the desired interrupts manually. It
is also essential that your code clears the flag bits, or else the
interrupt routine will be called repeatedly.</p><p>Some combination of these two methods is also possible - the code
generated by On Interrupt with check to see if the interrupt is one it
recognises. If the interrupt is recognised, On Interrupt will deal with
it - if not, the Interrupt subroutine will be called to deal with the
interrupt.</p><p>The recommended way is to use On Interrupt, as it is both more efficient
and easier to set up.</p><p>During some sections of code, it is desirable not to have any interrupts
occur. If this is the case, then use the IntOff command to disable
interrupts at the start of the section, and IntOn to re-enable them at
the end. If any interrupt events occur while interrupts are disabled,
then they will be processed as soon as interrupts are re-enabled. If the
program does not use interrupts, IntOn and IntOff will be removed
automatically by GCBASIC.</p><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_intoff.html" title="IntOff">IntOff</a>, <a class="link" href="_inton.html" title="IntOn">IntOn</a>,
<a class="link" href="_on_interrupt.html" title="On Interrupt">On Interrupt</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="interrupts_overview"></span>Interrupts overview

</div>

</div>

</div>

<span class="strong">**Introduction**</span>

Interrupts are a feature of many microcontrollers. They allow the
microcontroller to temporarily pause (interrupt) the code it is running
and then start running another piece of code when some event occurs.
Once it has dealt with the event, it will return to where it was and
continue running the program.

Many events can trigger an interrupt, such as a timer reaching its
limit, a serial message being received, or a special pin on the
microcontroller receiving a signal.

<span class="strong">**Using Interrupts**</span>

There are two ways to use interrupts in GCBASIC. The first way is to use
the On Interrupt command. This will automatically enable a given
interrupt, and run a particular subroutine when the interrupt occurs.

The other way to deal with interrupts is to create a subroutine called
Interrupt. GCBASIC will call this subroutine whenever an interrupt
occurs, and then your code can check the "flag" bits to determine which
interrupt has occured, and what should be done about it. If you use this
approach, then you’ll need to enable the desired interrupts manually. It
is also essential that your code clears the flag bits, or else the
interrupt routine will be called repeatedly.

Some combination of these two methods is also possible - the code
generated by On Interrupt with check to see if the interrupt is one it
recognises. If the interrupt is recognised, On Interrupt will deal with
it - if not, the Interrupt subroutine will be called to deal with the
interrupt.

The recommended way is to use On Interrupt, as it is both more efficient
and easier to set up.

During some sections of code, it is desirable not to have any interrupts
occur. If this is the case, then use the IntOff command to disable
interrupts at the start of the section, and IntOn to re-enable them at
the end. If any interrupt events occur while interrupts are disabled,
then they will be processed as soon as interrupts are re-enabled. If the
program does not use interrupts, IntOn and IntOff will be removed
automatically by GCBASIC.

<span class="strong">**See Also**</span>
<a href="intoff" class="link" title="IntOff">IntOff</a>,
<a href="inton" class="link" title="IntOn">IntOn</a>,
<a href="on_interrupt" class="link" title="On Interrupt">On Interrupt</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>IntOff</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_interrupts.html" title="Interrupts"><link rel="prev" href="_interrupts_overview.html" title="Interrupts overview"><link rel="next" href="_inton.html" title="IntOn"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_intoff"></a>IntOff</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    IntOff</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on Microchip PIC and Atmel AVR microcontrollers with interrupt support. Will
be automatically removed on chips without interrupts.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">IntOff</code> is used to disable interrupts on the microcontroller. It should
be used at the start of code which is timing-sensitive, and which would
not function correctly if paused and restarted.</p><p>It is essential that <code class="literal">IntOn</code> is used to turn interrupts on again after the
timing-sensitive code has finished running. If not, no interrupts will
be handled.</p><p>It is recommended that IntOff be placed before all code that is timing
sensitive, in case interrupts are implemented later.</p><p><code class="literal">IntOff</code> will be removed from the assembler if no interrupts are used.</p><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_inton.html" title="IntOn">IntOn</a>, <a class="link" href="_interrupts.html" title="Interrupts">Interrupts</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="intoff"></span>IntOff

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    IntOff
```

<span class="strong">**Command Availability:**</span>

Available on Microchip PIC and Atmel AVR microcontrollers with interrupt
support. Will be automatically removed on chips without interrupts.

<span class="strong">**Explanation:**</span>

`IntOff` is used to disable interrupts on the microcontroller. It should
be used at the start of code which is timing-sensitive, and which would
not function correctly if paused and restarted.

It is essential that `IntOn` is used to turn interrupts on again after
the timing-sensitive code has finished running. If not, no interrupts
will be handled.

It is recommended that IntOff be placed before all code that is timing
sensitive, in case interrupts are implemented later.

`IntOff` will be removed from the assembler if no interrupts are used.

<span class="strong">**See also**</span>
<a href="inton" class="link" title="IntOn">IntOn</a>,
<a href="interrupts" class="link" title="Interrupts">Interrupts</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>IntOn</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_interrupts.html" title="Interrupts"><link rel="prev" href="_intoff.html" title="IntOff"><link rel="next" href="_on_interrupt.html" title="On Interrupt"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_inton"></a>IntOn</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    IntOn</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on Microchip PIC and Atmel AVR microcontrollers with interrupt support. Will
be automatically removed on chips without interrupts.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">IntOn</code> is used to enable interrupts on the microcontroller after <code class="literal">IntOff</code>
has disabled them. It should be used at the end of code which is
timing-sensitive.</p><p><code class="literal">IntOn</code> will be removed from the assembler if no interrupts are used.</p><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_intoff.html" title="IntOff">IntOff</a>, <a class="link" href="_interrupts_overview.html" title="Interrupts overview">Interrupts</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="inton"></span>IntOn

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    IntOn
```

<span class="strong">**Command Availability:**</span>

Available on Microchip PIC and Atmel AVR microcontrollers with interrupt
support. Will be automatically removed on chips without interrupts.

<span class="strong">**Explanation:**</span>

`IntOn` is used to enable interrupts on the microcontroller after
`IntOff` has disabled them. It should be used at the end of code which
is timing-sensitive.

`IntOn` will be removed from the assembler if no interrupts are used.

<span class="strong">**See also**</span>
<a href="intoff" class="link" title="IntOff">IntOff</a>,
<a href="interrupts_overview" class="link" title="Interrupts overview">Interrupts</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Introducing GCBASIC</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="index.html" title="GCBASIC documentation"><link rel="next" href="_using_gcbasic.html" title="Using GCBASIC"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_introducing_gcbasic"></a>Introducing GCBASIC</h2></div></div></div><p>Hello, and welcome to GCBASIC help. This help file is intended
to provide you insights and knowledge to use GCBASIC.</p><p>For information on installing GCBASIC and several other programs that
may be helpful, please see <span class="strong"><strong>Getting Started with GCBASIC</strong></span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://gcbasic.sourceforge.net/starting.html</p><p>If you are new to programming, you should try the GCBASIC
demonstration programs these explains everything in a step-by-step manner, and assumes
no prior knowledge.</p><p>If you have programmed in another language, then the demonstration files on GitHub ( or within your installation )
and this command reference may be the best place to start.</p><p>If there is anything else that you need help on, please visit the <span class="strong"><strong>GCBASIC forum</strong></span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://sourceforge.net/forum/?group_id=169286</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="introducing_gcbasic"></span>Introducing GCBASIC
----------------------------------------------------------

</div>

</div>

</div>

Hello, and welcome to GCBASIC help. This help file is intended to
provide you insights and knowledge to use GCBASIC.

For information on installing GCBASIC and several other programs that
may be helpful, please see <span class="strong">**Getting Started with
GCBASIC**</span>

        http://gcbasic.sourceforge.net/starting

If you are new to programming, you should try the GCBASIC demonstration
programs these explains everything in a step-by-step manner, and assumes
no prior knowledge.

If you have programmed in another language, then the demonstration files
on GitHub ( or within your installation ) and this command reference may
be the best place to start.

If there is anything else that you need help on, please visit the <span
class="strong">**GCBASIC forum**</span>

        http://sourceforge.net/forum/?group\_id=169286

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Keypad</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_on_interrupt_the_default_handler.html" title="On Interrupt: The default handler"><link rel="next" href="_keypad_overview.html" title="Keypad Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_keypad"></a>Keypad</h3></div></div></div><p>This is the Keypad section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="keypad"></span>Keypad

</div>

</div>

</div>

This is the Keypad section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>KeypadData</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_keypad.html" title="Keypad"><link rel="prev" href="_keypad_overview.html" title="Keypad Overview"><link rel="next" href="_keypadraw.html" title="KeypadRaw"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_keypaddata"></a>KeypadData</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>var</em></span> = KeypadData</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This function will return a value corresponding to the key that is
pressed on the keypad. Note that if two or more keys are pressed, then
only one value will be returned.
<code class="literal"><span class="emphasis"><em>var</em></span></code> can have one of the following values:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Value</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Key Pressed</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>0</p></td><td align="center" valign="top">&nbsp;</td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1</p></td><td align="center" valign="top">&nbsp;</td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>2</p></td><td align="center" valign="top">&nbsp;</td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>3</p></td><td align="center" valign="top">&nbsp;</td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>4</p></td><td align="center" valign="top">&nbsp;</td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>5</p></td><td align="center" valign="top">&nbsp;</td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>6</p></td><td align="center" valign="top">&nbsp;</td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>7</p></td><td align="center" valign="top">&nbsp;</td><td align="center" valign="top"><p>7</p></td></tr><tr><td align="center" valign="top"><p>8</p></td><td align="center" valign="top">&nbsp;</td><td align="center" valign="top"><p>8</p></td></tr><tr><td align="center" valign="top"><p>9</p></td><td align="center" valign="top">&nbsp;</td><td align="center" valign="top"><p>9</p></td></tr><tr><td align="center" valign="top"><p>10</p></td><td align="center" valign="top"><p>KEY_A</p></td><td align="center" valign="top"><p>A</p></td></tr><tr><td align="center" valign="top"><p>11</p></td><td align="center" valign="top"><p>KEY_B</p></td><td align="center" valign="top"><p>B</p></td></tr><tr><td align="center" valign="top"><p>12</p></td><td align="center" valign="top"><p>KEY_C</p></td><td align="center" valign="top"><p>C</p></td></tr><tr><td align="center" valign="top"><p>13</p></td><td align="center" valign="top"><p>KEY_D</p></td><td align="center" valign="top"><p>D</p></td></tr><tr><td align="center" valign="top"><p>14</p></td><td align="center" valign="top"><p>KEY_STAR</p></td><td align="center" valign="top"><p>Asterisk/Star (*)</p></td></tr><tr><td align="center" valign="top"><p>15</p></td><td align="center" valign="top"><p>KEY_HASH</p></td><td align="center" valign="top"><p>Hash (#)</p></td></tr><tr><td align="center" valign="top"><p>255</p></td><td align="center" valign="top"><p>KEY_NONE</p></td><td align="center" valign="top"><p>None</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Program to show the value of the last pressed key on the LCD
    #chip 18F4550, 20

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Keypad connection settings
    #define KeypadPort PORTB

    'Main loop
    Do
        'Get key
        Temp = KeypadData

        'If a key is pressed, then display it
        If Temp &lt;&gt; KEY_NONE Then
            CLS
            Print Temp
            Wait 100 ms
        End If
    Loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_keypad_overview.html" title="Keypad Overview">Keypad Overview</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="keypaddata"></span>KeypadData

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    var = KeypadData
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This function will return a value corresponding to the key that is
pressed on the keypad. Note that if two or more keys are pressed, then
only one value will be returned. `var` can have one of the following
values:

<div class="informaltable">

| <span class="strong">**Value**</span> | <span class="strong">**Constant Name**</span> | <span class="strong">**Key Pressed**</span> |
|:-------------------------------------:|:---------------------------------------------:|:-------------------------------------------:|
|                   0                   |                                               |                      0                      |
|                   1                   |                                               |                      1                      |
|                   2                   |                                               |                      2                      |
|                   3                   |                                               |                      3                      |
|                   4                   |                                               |                      4                      |
|                   5                   |                                               |                      5                      |
|                   6                   |                                               |                      6                      |
|                   7                   |                                               |                      7                      |
|                   8                   |                                               |                      8                      |
|                   9                   |                                               |                      9                      |
|                  10                   |                    KEY\_A                     |                      A                      |
|                  11                   |                    KEY\_B                     |                      B                      |
|                  12                   |                    KEY\_C                     |                      C                      |
|                  13                   |                    KEY\_D                     |                      D                      |
|                  14                   |                   KEY\_STAR                   |             Asterisk/Star (\*)              |
|                  15                   |                   KEY\_HASH                   |                  Hash (\#)                  |
|                  255                  |                   KEY\_NONE                   |                    None                     |

</div>

<span class="strong">**Example:**</span>

``` screen
    'Program to show the value of the last pressed key on the LCD
    #chip 18F4550, 20

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Keypad connection settings
    #define KeypadPort PORTB

    'Main loop
    Do
        'Get key
        Temp = KeypadData

        'If a key is pressed, then display it
        If Temp <> KEY_NONE Then
            CLS
            Print Temp
            Wait 100 ms
        End If
    Loop
```

<span class="strong">**For more help, see**</span>
<a href="keypad_overview" class="link" title="Keypad Overview">Keypad Overview</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>KeypadRaw</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_keypad.html" title="Keypad"><link rel="prev" href="_keypaddata.html" title="KeypadData"><link rel="next" href="_graphical_lcd.html" title="Graphical LCD"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_keypadraw"></a>KeypadRaw</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>largevar</em></span> = KeypadRaw</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This function will return a 16 bit value, in which each bit corresponds
to a key on the keypad. If the key is pressed its bit will hold 1, and
if it is released its bit will contain a 0.</p><p>This table shows the key that each bit corresponds to:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top"><span class="strong"><strong>Bit</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Key Position (row, col)</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Common Key Symbol</strong></span></th></tr></thead><tbody><tr><td align="center" valign="top"><p>15</p></td><td align="center" valign="top"><p>1,1</p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="center" valign="top"><p>14</p></td><td align="center" valign="top"><p>1,2</p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="center" valign="top"><p>13</p></td><td align="center" valign="top"><p>1,3</p></td><td align="center" valign="top"><p>3</p></td></tr><tr><td align="center" valign="top"><p>12</p></td><td align="center" valign="top"><p>1,4</p></td><td align="center" valign="top"><p>A</p></td></tr><tr><td align="center" valign="top"><p>11</p></td><td align="center" valign="top"><p>2,1</p></td><td align="center" valign="top"><p>4</p></td></tr><tr><td align="center" valign="top"><p>10</p></td><td align="center" valign="top"><p>2,2</p></td><td align="center" valign="top"><p>5</p></td></tr><tr><td align="center" valign="top"><p>9</p></td><td align="center" valign="top"><p>2,3</p></td><td align="center" valign="top"><p>6</p></td></tr><tr><td align="center" valign="top"><p>8</p></td><td align="center" valign="top"><p>2,4</p></td><td align="center" valign="top"><p>B</p></td></tr><tr><td align="center" valign="top"><p>7</p></td><td align="center" valign="top"><p>3,1</p></td><td align="center" valign="top"><p>7</p></td></tr><tr><td align="center" valign="top"><p>6</p></td><td align="center" valign="top"><p>3,2</p></td><td align="center" valign="top"><p>8</p></td></tr><tr><td align="center" valign="top"><p>5</p></td><td align="center" valign="top"><p>3,3</p></td><td align="center" valign="top"><p>9</p></td></tr><tr><td align="center" valign="top"><p>4</p></td><td align="center" valign="top"><p>3,4</p></td><td align="center" valign="top"><p>C</p></td></tr><tr><td align="center" valign="top"><p>3</p></td><td align="center" valign="top"><p>4,1</p></td><td align="center" valign="top"><p>*</p></td></tr><tr><td align="center" valign="top"><p>2</p></td><td align="center" valign="top"><p>4,2</p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="center" valign="top"><p>1</p></td><td align="center" valign="top"><p>4,3</p></td><td align="center" valign="top"><p>#</p></td></tr><tr><td align="center" valign="top"><p>0</p></td><td align="center" valign="top"><p>4,4</p></td><td align="center" valign="top"><p>D</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Program to show the keypad status using LEDs
    #chip 16F877A, 20

    'Keypad connection settings
    #define KeypadPort PORTB

    'LEDs
    #define LED1 PORTC
    #define LED2 PORTD
    Dir LED1 Out
    Dir LED2 Out

    'Declare a 16 bit variable for the key value
    Dim KeyStatus As Word

    'Main loop
    Do
        'Get key
        KeyStatus = KeypadRaw

        'Display
        LED1 = KeyStatus_H 'High Byte
        LED2 = KeyStatus 'Low Byte
    Loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_keypad_overview.html" title="Keypad Overview">Keypad Overview</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="keypadraw"></span>KeypadRaw

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    largevar = KeypadRaw
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This function will return a 16 bit value, in which each bit corresponds
to a key on the keypad. If the key is pressed its bit will hold 1, and
if it is released its bit will contain a 0.

This table shows the key that each bit corresponds to:

<div class="informaltable">

| <span class="strong">**Bit**</span> | <span class="strong">**Key Position (row, col)**</span> | <span class="strong">**Common Key Symbol**</span> |
|:-----------------------------------:|:-------------------------------------------------------:|:-------------------------------------------------:|
|                 15                  |                           1,1                           |                         1                         |
|                 14                  |                           1,2                           |                         2                         |
|                 13                  |                           1,3                           |                         3                         |
|                 12                  |                           1,4                           |                         A                         |
|                 11                  |                           2,1                           |                         4                         |
|                 10                  |                           2,2                           |                         5                         |
|                  9                  |                           2,3                           |                         6                         |
|                  8                  |                           2,4                           |                         B                         |
|                  7                  |                           3,1                           |                         7                         |
|                  6                  |                           3,2                           |                         8                         |
|                  5                  |                           3,3                           |                         9                         |
|                  4                  |                           3,4                           |                         C                         |
|                  3                  |                           4,1                           |                        \*                         |
|                  2                  |                           4,2                           |                         0                         |
|                  1                  |                           4,3                           |                        \#                         |
|                  0                  |                           4,4                           |                         D                         |

</div>

<span class="strong">**Example:**</span>

``` screen
    'Program to show the keypad status using LEDs
    #chip 16F877A, 20

    'Keypad connection settings
    #define KeypadPort PORTB

    'LEDs
    #define LED1 PORTC
    #define LED2 PORTD
    Dir LED1 Out
    Dir LED2 Out

    'Declare a 16 bit variable for the key value
    Dim KeyStatus As Word

    'Main loop
    Do
        'Get key
        KeyStatus = KeypadRaw

        'Display
        LED1 = KeyStatus_H 'High Byte
        LED2 = KeyStatus 'Low Byte
    Loop
```

<span class="strong">**For more help, see**</span>
<a href="keypad_overview" class="link" title="Keypad Overview">Keypad Overview</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Keypad Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_keypad.html" title="Keypad"><link rel="prev" href="_keypad.html" title="Keypad"><link rel="next" href="_keypaddata.html" title="KeypadData"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_keypad_overview"></a>Keypad Overview</h4></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>The keypad routines allow for a program to read from a 4 x 4 matrix
keypad.</p><p>There are two ways that the keypad routines can be set up. One option is
to connect the wires from the keypad in a particular order, and then to
set the KeypadPort constant. The other option is to connect the keypad
in whatever way is easiest, and then set the <code class="literal">KEYPAD_ROW_x</code> and
<code class="literal">KEYPAD_COL_x</code> constants. The option (setting <code class="literal">KeypadPort</code>) will
generate slightly more efficient code.</p><p><span class="strong"><strong>Configuration using</strong></span> <code class="literal">KEYPAD_ROW_x</code> <span class="strong"><strong>and</strong></span> <code class="literal">KEYPAD_COL_x</code>:</p><p>These constants must be set:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">KEYPAD_ROW_1</code></p></td><td align="left" valign="top"><p>The pin on the microcontroller that connects to the Row 1 pin on the
keypad</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">KEYPAD_ROW_2</code></p></td><td align="left" valign="top"><p>The pin on the microcontroller that connects to the Row 2 pin on the
keypad</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">KEYPAD_ROW_3</code></p></td><td align="left" valign="top"><p>The pin on the microcontroller that connects to the Row 3 pin on the
keypad</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">KEYPAD_ROW_4</code></p></td><td align="left" valign="top"><p>The pin on the microcontroller that connects to the Row 4 pin on the
keypad</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">KEYPAD_COL_1</code></p></td><td align="left" valign="top"><p>The pin on the microcontroller that connects to the Col 1 pin on the
keypad</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">KEYPAD_COL_2</code></p></td><td align="left" valign="top"><p>The pin on the microcontroller that connects to the Col 2 pin on the
keypad</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">KEYPAD_COL_3</code></p></td><td align="left" valign="top"><p>The pin on the microcontroller that connects to the Col 3 pin on the
keypad</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">KEYPAD_COL_4</code></p></td><td align="left" valign="top"><p>The pin on the microcontroller that connects to the Col 4 pin on the
keypad</p></td><td align="left" valign="top"><p>N/A</p></td></tr></tbody></table></div><p>If using a 3 x 3 keypad, do not set the <code class="literal">KEYPAD_ROW_4</code> or <code class="literal">KEYPAD_COL_4</code>
constants.</p><p><span class="strong"><strong>Configuration using</strong></span> <code class="literal">KeypadPort</code>:</p><p>When setting up the keypad code using the <code class="literal">KeypadPort</code> constant, only
<code class="literal">KeypadPort</code> needs to be set.</p><p>Pull-ups or pull-downs go on the columns only, and are typically 4.7k to
10k in value.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">KeypadPort</code></p></td><td align="left" valign="top"><p>The port on the microcontroller chip that the keypad is connected to.</p></td><td align="left" valign="top"><p>N/A</p></td></tr></tbody></table></div><p><span class="strong"><strong>Configuration when using Pull down resistors</strong></span></p><p>The keypad routine has a feature when using pull-down resistors, simply
add the constant to your program and the and the scan logic will be
inverted appropriately.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">KEYPAD_PULLDOWN</code></p></td><td align="left" valign="top"><p>Support pull down resistors.</p></td><td align="left" valign="top"><p>N/A</p></td></tr></tbody></table></div><p>For this to work, the keypad must be connected as follows:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Microcontroller port pin</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Keypad connector</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>0</p></td><td align="left" valign="top"><p>Row 1</p></td></tr><tr><td align="left" valign="top"><p>1</p></td><td align="left" valign="top"><p>Row 2</p></td></tr><tr><td align="left" valign="top"><p>2</p></td><td align="left" valign="top"><p>Row 3</p></td></tr><tr><td align="left" valign="top"><p>3</p></td><td align="left" valign="top"><p>Row 4</p></td></tr><tr><td align="left" valign="top"><p>4</p></td><td align="left" valign="top"><p>Column 1</p></td></tr><tr><td align="left" valign="top"><p>5</p></td><td align="left" valign="top"><p>Column 2</p></td></tr><tr><td align="left" valign="top"><p>6</p></td><td align="left" valign="top"><p>Column 3</p></td></tr><tr><td align="left" valign="top"><p>7</p></td><td align="left" valign="top"><p>Column 4</p></td></tr></tbody></table></div><p>Note: To use a 3 x 3 keypad in this mode, the pins on the
microcontroller for any unused columns must be pulled up.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="keypad_overview"></span>Keypad Overview

</div>

</div>

</div>

<span class="strong">**Introduction**</span>

The keypad routines allow for a program to read from a 4 x 4 matrix
keypad.

There are two ways that the keypad routines can be set up. One option is
to connect the wires from the keypad in a particular order, and then to
set the KeypadPort constant. The other option is to connect the keypad
in whatever way is easiest, and then set the `KEYPAD_ROW_x` and
`KEYPAD_COL_x` constants. The option (setting `KeypadPort`) will
generate slightly more efficient code.

<span class="strong">**Configuration using**</span> `KEYPAD_ROW_x` <span
class="strong">**and**</span> `KEYPAD_COL_x`:

These constants must be set:

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span>                                    | <span class="strong">**Default Value**</span> |
|:----------------------------------------------|:----------------------------------------------------------------------------|:----------------------------------------------|
| `KEYPAD_ROW_1`                                | The pin on the microcontroller that connects to the Row 1 pin on the keypad | N/A                                           |
| `KEYPAD_ROW_2`                                | The pin on the microcontroller that connects to the Row 2 pin on the keypad | N/A                                           |
| `KEYPAD_ROW_3`                                | The pin on the microcontroller that connects to the Row 3 pin on the keypad | N/A                                           |
| `KEYPAD_ROW_4`                                | The pin on the microcontroller that connects to the Row 4 pin on the keypad | N/A                                           |
| `KEYPAD_COL_1`                                | The pin on the microcontroller that connects to the Col 1 pin on the keypad | N/A                                           |
| `KEYPAD_COL_2`                                | The pin on the microcontroller that connects to the Col 2 pin on the keypad | N/A                                           |
| `KEYPAD_COL_3`                                | The pin on the microcontroller that connects to the Col 3 pin on the keypad | N/A                                           |
| `KEYPAD_COL_4`                                | The pin on the microcontroller that connects to the Col 4 pin on the keypad | N/A                                           |

</div>

If using a 3 x 3 keypad, do not set the `KEYPAD_ROW_4` or `KEYPAD_COL_4`
constants.

<span class="strong">**Configuration using**</span> `KeypadPort`:

When setting up the keypad code using the `KeypadPort` constant, only
`KeypadPort` needs to be set.

Pull-ups or pull-downs go on the columns only, and are typically 4.7k to
10k in value.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span>                              | <span class="strong">**Default Value**</span> |
|:----------------------------------------------|:----------------------------------------------------------------------|:----------------------------------------------|
| `KeypadPort`                                  | The port on the microcontroller chip that the keypad is connected to. | N/A                                           |

</div>

<span class="strong">**Configuration when using Pull down
resistors**</span>

The keypad routine has a feature when using pull-down resistors, simply
add the constant to your program and the and the scan logic will be
inverted appropriately.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Default Value**</span> |
|:----------------------------------------------|:-----------------------------------------|:----------------------------------------------|
| `KEYPAD_PULLDOWN`                             | Support pull down resistors.             | N/A                                           |

</div>

For this to work, the keypad must be connected as follows:

<div class="informaltable">

| <span class="strong">**Microcontroller port pin**</span> | <span class="strong">**Keypad connector**</span> |
|:---------------------------------------------------------|:-------------------------------------------------|
| 0                                                        | Row 1                                            |
| 1                                                        | Row 2                                            |
| 2                                                        | Row 3                                            |
| 3                                                        | Row 4                                            |
| 4                                                        | Column 1                                         |
| 5                                                        | Column 2                                         |
| 6                                                        | Column 3                                         |
| 7                                                        | Column 4                                         |

</div>

Note: To use a 3 x 3 keypad in this mode, the pins on the
microcontroller for any unused columns must be pulled up.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>KS0108 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_ili9488_controllers.html" title="ILI9488 Controllers"><link rel="next" href="_nextion_controllers.html" title="NEXTION Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_ks0108_controllers"></a>KS0108 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the KS0108 graphics controller.</p><p>The KS0108 is an LCD is driven by on-board 5V parallel interface chipset KS0108 and KS0107. They are extremely common and well documented</p><p>The GCBASIC constants shown below control the configuration of the KS0108 controller. &nbsp;&nbsp;&nbsp;The only connectivity option is the 8-bit mode where 8 connections (for the data) are required between the microcontroller and the GLCD to control the data bus.</p><p>The KS0108 is a monochrome device.</p><p>To use the KS0108 driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_KS0108


    #define GLCD_RW       PORTB.1            'chip specific configuration
    #define GLCD_RESET    PORTB.5            'chip specific configuration
    #define GLCD_CS1      PORTB.3            'chip specific configuration
    #define GLCD_CS2      PORTB.4            'chip specific configuration
    #define GLCD_RS       PORTB.0            'chip specific configuration
    #define GLCD_ENABLE   PORTB.2            'chip specific configuration
    #define GLCD_DB0      PORTC.7            'chip specific configuration
    #define GLCD_DB1      PORTC.6            'chip specific configuration
    #define GLCD_DB2      PORTC.5            'chip specific configuration
    #define GLCD_DB3      PORTC.4            'chip specific configuration
    #define GLCD_DB4      PORTC.3            'chip specific configuration
    #define GLCD_DB5      PORTC.2            'chip specific configuration
    #define GLCD_DB6      PORTC.1            'chip specific configuration
    #define GLCD_DB7      PORTC.0            'chip specific configuration</pre><p>The GCBASIC constants for the interface to the controller are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_KS0108</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Register Select on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RW</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Read/Write on the GLCD.
The R/W pin can be disabled.</p></td><td align="left" valign="top"><p><span class="strong"><strong><span class="emphasis"><em>Must be defined</em></span></strong></span> <span class="emphasis"><em>(unless R/W is disabled)<br>
see</em></span> <code class="literal">GLCD_NO_RW</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS1</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">CS1</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS2</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">CS2</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_ENABLE</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">Enable</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DB0</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">DB0</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DB1</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">DB1</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DB2</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">DB2</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DB3</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">DB3</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DB4</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">DB4</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DB5</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">DB5</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DB6</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">DB6</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DB7</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">DB7</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_NO_RW</code></p></td><td align="left" valign="top"><p>Disables read/write inspection of the device during read/write
operations</p></td><td align="left" valign="top"><p>Optional, but recommend NOT to set.
The R/W pin can be disabled by setting the <code class="literal">GLCD_NO_RW</code> constant. If this
is done, there is no need for the R/W to be connected to the chip, and
no need for the <code class="literal">LCD_RW</code> constant to be set. Ensure that the R/W line on
the LCD is connected to ground if not used.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DATA_PORT</code></p></td><td align="left" valign="top"><p>Not Available for this controller.</p></td><td align="left" valign="top"><p>Not applicable.</p></td></tr></tbody></table></div><p>The GCBASIC constants defined for the controller type are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="center" valign="top"><p><code class="literal">128</code>
This constant cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="center" valign="top"><p><code class="literal">64</code>
This constant cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDirection</code></p></td><td align="left" valign="top"><p>Defining this will invert the Y Axis</p></td><td align="center" valign="top"><p>Not defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">KS0108ReadDelay</code></p></td><td align="left" valign="top"><p>Read delay</p></td><td align="center" valign="top"><p>Default is   9
</p><p>Can be set to improve overall performance.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">KS0108WriteDelay</code></p></td><td align="left" valign="top"><p>Write delay</p></td><td align="center" valign="top"><p>Default is   1
</p><p>Can be set to improve performance.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">KS0108ClockDelay</code></p></td><td align="left" valign="top"><p>Clock Delay</p></td><td align="center" valign="top"><p>Default is 1
</p><p>Can be set to improve performance.</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Variables</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Width of the current GLCD font.</p></td><td align="center" valign="top"><p>Default is 6 pixels.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDfntDefault</code></p></td><td align="left" valign="top"><p>Size of the current GLCD font.</p></td><td align="center" valign="top"><p>Default is 0.
</p><p>This equates to the standard GCB font set.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDfntDefaultsize</code></p></td><td align="left" valign="top"><p>Size of the current GLCD font.</p></td><td align="center" valign="top"><p>Default is 1.
</p><p>This equates to the 8 pixel high.</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the
table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr></tbody></table></div><p>For a KS0108 datasheet, please refer
<a class="link" href="http://www.vishay.com/docs/37329/37329.pdf" target="_top">here.</a></p><p>This example shows how to drive a KS0108 based Graphic LCD module with
the built in commands of GCBASIC. See
<a class="link" href="http://www.greatcowbasic.com/sample-projects.html" target="_top">Graphic LCD</a> for
details, this is an external web site.</p><pre class="screen">    ;Chip Settings
    #chip 16F886,16
    '#config MCLRE = on 'enable reset switch on CHIPINO
    #include &lt;GLCD.h&gt;

    ;Defines (Constants)
    #define GLCD_RW PORTB.1  'D9 to pin 5 of LCD
    #define GLCD_RESET PORTB.5 'D13 to pin 17 of LCD
    #define GLCD_CS1 PORTB.3 'D12 to actually since CS1, CS2 can be reversed on some devices
    #define GLCD_CS2 PORTB.4 'D11 to actually since CS1, CS2 can be reversed on some devices
    #define GLCD_RS PORTB.0  'D8 to pin 4 D/I pin on LCD
    #define GLCD_ENABLE PORTB.2 'D10 to Pin 6 on LCD
    #define GLCD_DB0 PORTC.7 'D0 to pin 7 on LCD
    #define GLCD_DB1 PORTC.6 'D1 to pin 8 on LCD
    #define GLCD_DB2 PORTC.5 'D2 to pin 9 on LCD
    #define GLCD_DB3 PORTC.4 'D3 to pin 10 on LCD
    #define GLCD_DB4 PORTC.3 'D4 to pin 11 on LCD
    #define GLCD_DB5 PORTC.2 'D5 to pin 12 on LCD
    #define GLCD_DB6 PORTC.1 'D6 to pin 13 on LCD
    #define GLCD_DB7 PORTC.0 'D7 to pin 14 on LCD

    Do forever
        GLCDCLS
        GLCDPrint 0,10,"Hello" 'Print Hello
        wait 5 s
        GLCDPrint 0,10, "ASCII #:" 'Print ASCII #:
        Box 18,30,28,40                    'Draw Box Around ASCII Character
        for char = 15 to 129            'Print 0 through 9
          GLCDPrint 17, 20 , Str(char)+"  "
          GLCDdrawCHAR 20,30, char
          wait 125 ms
        next
        line 0,50,127,50                'Draw Line using line command
        for xvar = 0 to 80            'draw line using Pset command
            pset xvar,63,on                    '
        next                                        '
        Wait 1 s
        GLCDPrint 0,10,"End  " 'Print Hello
        wait 1 s
    Loop</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="ks0108_controllers"></span>KS0108 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the KS0108 graphics
controller.

The KS0108 is an LCD is driven by on-board 5V parallel interface chipset
KS0108 and KS0107. They are extremely common and well documented

The GCBASIC constants shown below control the configuration of the
KS0108 controller.    The only connectivity option is the 8-bit mode
where 8 connections (for the data) are required between the
microcontroller and the GLCD to control the data bus.

The KS0108 is a monochrome device.

To use the KS0108 driver simply include the following in your user code.
This will initialise the driver.

``` screen
    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_KS0108


    #define GLCD_RW       PORTB.1            'chip specific configuration
    #define GLCD_RESET    PORTB.5            'chip specific configuration
    #define GLCD_CS1      PORTB.3            'chip specific configuration
    #define GLCD_CS2      PORTB.4            'chip specific configuration
    #define GLCD_RS       PORTB.0            'chip specific configuration
    #define GLCD_ENABLE   PORTB.2            'chip specific configuration
    #define GLCD_DB0      PORTC.7            'chip specific configuration
    #define GLCD_DB1      PORTC.6            'chip specific configuration
    #define GLCD_DB2      PORTC.5            'chip specific configuration
    #define GLCD_DB3      PORTC.4            'chip specific configuration
    #define GLCD_DB4      PORTC.3            'chip specific configuration
    #define GLCD_DB5      PORTC.2            'chip specific configuration
    #define GLCD_DB6      PORTC.1            'chip specific configuration
    #define GLCD_DB7      PORTC.0            'chip specific configuration
```

The GCBASIC constants for the interface to the controller are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Options</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE</code></p></td>
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_KS0108</code></p></td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_RS</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Register Select on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_RW</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Read/Write on the GLCD. The R/W pin can be disabled.</p></td>
<td style="text-align: left;"><p><span class="strong"><strong><span class="emphasis"><em>Must be defined</em></span></strong></span> <span class="emphasis"><em>(unless R/W is disabled)<br />
see</em></span> <code class="literal">GLCD_NO_RW</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_CS1</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">CS1</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_CS2</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">CS2</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_ENABLE</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">Enable</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_DB0</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">DB0</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DB1</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">DB1</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_DB2</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">DB2</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DB3</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">DB3</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_DB4</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">DB4</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DB5</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">DB5</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_DB6</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">DB6</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DB7</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">DB7</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_NO_RW</code></p></td>
<td style="text-align: left;"><p>Disables read/write inspection of the device during read/write operations</p></td>
<td style="text-align: left;"><p>Optional, but recommend NOT to set. The R/W pin can be disabled by setting the <code class="literal">GLCD_NO_RW</code> constant. If this is done, there is no need for the R/W to be connected to the chip, and no need for the <code class="literal">LCD_RW</code> constant to be set. Ensure that the R/W line on the LCD is connected to ground if not used.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DATA_PORT</code></p></td>
<td style="text-align: left;"><p>Not Available for this controller.</p></td>
<td style="text-align: left;"><p>Not applicable.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC constants defined for the controller type are shown in the
table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: center;"><p><code class="literal">128</code> This constant cannot be changed</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: center;"><p><code class="literal">64</code> This constant cannot be changed</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDirection</code></p></td>
<td style="text-align: left;"><p>Defining this will invert the Y Axis</p></td>
<td style="text-align: center;"><p>Not defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">KS0108ReadDelay</code></p></td>
<td style="text-align: left;"><p>Read delay</p></td>
<td style="text-align: center;"><p>Default is 9</p>
<p>Can be set to improve overall performance.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">KS0108WriteDelay</code></p></td>
<td style="text-align: left;"><p>Write delay</p></td>
<td style="text-align: center;"><p>Default is 1</p>
<p>Can be set to improve performance.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">KS0108ClockDelay</code></p></td>
<td style="text-align: left;"><p>Clock Delay</p></td>
<td style="text-align: center;"><p>Default is 1</p>
<p>Can be set to improve performance.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Variables</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Width of the current GLCD font.</p></td>
<td style="text-align: center;"><p>Default is 6 pixels.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDfntDefault</code></p></td>
<td style="text-align: left;"><p>Size of the current GLCD font.</p></td>
<td style="text-align: center;"><p>Default is 0.</p>
<p>This equates to the standard GCB font set.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDfntDefaultsize</code></p></td>
<td style="text-align: left;"><p>Size of the current GLCD font.</p></td>
<td style="text-align: center;"><p>Default is 1.</p>
<p>This equates to the 8 pixel high.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**Purpose**</span>                                                  | <span class="strong">**Example**</span>                                                        |
|:----------------------------------------|:-----------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------|
| `GLCDCLS`                               | Clear screen of GLCD                                                                     | `GLCDCLS`                                                                                      |
| `GLCDPrint`                             | Print string of characters on GLCD using GCB font set                                    | `GLCDPrint( Xposition, Yposition, Stringvariable )`                                            |
| `GLCDDrawChar`                          | Print character on GLCD using GCB font set                                               | `GLCDDrawChar( Xposition, Yposition, CharCode )`                                               |
| `GLCDDrawString`                        | Print characters on GLCD using GCB font set                                              | `GLCDDrawString( Xposition, Yposition, Stringvariable )`                                       |
| `Box`                                   | Draw a box on the GLCD to a specific size                                                | `Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )`   |
| `FilledBox`                             | Draw a box on the GLCD to a specific size that is filled with the foreground colour.     | `FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )` |
| `Line`                                  | Draw a line on the GLCD to a specific length that is filled with the specific attribute. | `Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`     |
| `PSet`                                  | Set a pixel on the GLCD at a specific position that is set with the specific attribute.  | `PSet(Xposition, Yposition, Pixel Colour 0 or 1)`                                              |
| `GLCDWriteByte`                         | Set a byte value to the controller, see the datasheet for usage.                         | `GLCDWriteByte ( LCDByte)`                                                                     |
| `GLCDReadByte`                          | Read a byte value from the controller, see the datasheet for usage.                      | `bytevariable = GLCDReadByte`                                                                  |

</div>

For a KS0108 datasheet, please refer
<a href="http://www.vishay.com/docs/37329/37329.pdf" class="link">here.</a>

This example shows how to drive a KS0108 based Graphic LCD module with
the built in commands of GCBASIC. See
<a href="http://www.greatcowbasic.com/sample-projects" class="link">Graphic LCD</a>
for details, this is an external web site.

``` screen
    ;Chip Settings
    #chip 16F886,16
    '#config MCLRE = on 'enable reset switch on CHIPINO
    #include <GLCD.h>

    ;Defines (Constants)
    #define GLCD_RW PORTB.1  'D9 to pin 5 of LCD
    #define GLCD_RESET PORTB.5 'D13 to pin 17 of LCD
    #define GLCD_CS1 PORTB.3 'D12 to actually since CS1, CS2 can be reversed on some devices
    #define GLCD_CS2 PORTB.4 'D11 to actually since CS1, CS2 can be reversed on some devices
    #define GLCD_RS PORTB.0  'D8 to pin 4 D/I pin on LCD
    #define GLCD_ENABLE PORTB.2 'D10 to Pin 6 on LCD
    #define GLCD_DB0 PORTC.7 'D0 to pin 7 on LCD
    #define GLCD_DB1 PORTC.6 'D1 to pin 8 on LCD
    #define GLCD_DB2 PORTC.5 'D2 to pin 9 on LCD
    #define GLCD_DB3 PORTC.4 'D3 to pin 10 on LCD
    #define GLCD_DB4 PORTC.3 'D4 to pin 11 on LCD
    #define GLCD_DB5 PORTC.2 'D5 to pin 12 on LCD
    #define GLCD_DB6 PORTC.1 'D6 to pin 13 on LCD
    #define GLCD_DB7 PORTC.0 'D7 to pin 14 on LCD

    Do forever
        GLCDCLS
        GLCDPrint 0,10,"Hello" 'Print Hello
        wait 5 s
        GLCDPrint 0,10, "ASCII #:" 'Print ASCII #:
        Box 18,30,28,40                    'Draw Box Around ASCII Character
        for char = 15 to 129            'Print 0 through 9
          GLCDPrint 17, 20 , Str(char)+"  "
          GLCDdrawCHAR 20,30, char
          wait 125 ms
        next
        line 0,50,127,50                'Draw Line using line command
        for xvar = 0 to 80            'draw line using Pset command
            pset xvar,63,on                    '
        next                                        '
        Wait 1 s
        GLCDPrint 0,10,"End  " 'Print Hello
        wait 1 s
    Loop
```

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Labels</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_functions.html" title="Functions"><link rel="next" href="_lookup_tables.html" title="Lookup Tables"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_labels"></a>Labels</h3></div></div></div><p><span class="strong"><strong>About Labels</strong></span></p><p>Labels are used as markers throughout the program. Labels are used to
mark a position in the program to &#8216;jump to&#8217; from another position using
a goto, gosub or other command.</p><p>Labels can be any word (that is not already a reserved keyword) and may
contain digits and the underscore character. Labels must start with a
letter or underscore (not digit), and are followed directly by a colon
(:) at the marker position. The colon is not required within the actual
commands.</p><p>The compiler is not case sensitive. Lower and/or upper case may be used
at any time.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will flash the light until the button is pressed
    'off. Notice the label named SWITCH_OFF.

    #chip 16F628A, 4

    #define BUTTON PORTB.0
    #define LIGHT PORTB.1
    Dir BUTTON In
    Dir LIGHT Out

    Do
    PulseOut LIGHT, 500 ms
    If BUTTON = 1 Then Goto SWITCH_OFF
    Wait 500 ms
    If BUTTON = 1 Then Goto SWITCH_OFF
    Loop

    SWITCH_OFF:
    Set LIGHT Off
    'Chip will enter low power mode when program ends</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_goto.html" title="Goto">Goto</a>, <a class="link" href="_gosub.html" title="Gosub">Gosub</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="labels"></span>Labels

</div>

</div>

</div>

<span class="strong">**About Labels**</span>

Labels are used as markers throughout the program. Labels are used to
mark a position in the program to ‘jump to’ from another position using
a goto, gosub or other command.

Labels can be any word (that is not already a reserved keyword) and may
contain digits and the underscore character. Labels must start with a
letter or underscore (not digit), and are followed directly by a colon
(:) at the marker position. The colon is not required within the actual
commands.

The compiler is not case sensitive. Lower and/or upper case may be used
at any time.

<span class="strong">**Example:**</span>

``` screen
    'This program will flash the light until the button is pressed
    'off. Notice the label named SWITCH_OFF.

    #chip 16F628A, 4

    #define BUTTON PORTB.0
    #define LIGHT PORTB.1
    Dir BUTTON In
    Dir LIGHT Out

    Do
    PulseOut LIGHT, 500 ms
    If BUTTON = 1 Then Goto SWITCH_OFF
    Wait 500 ms
    If BUTTON = 1 Then Goto SWITCH_OFF
    Loop

    SWITCH_OFF:
    Set LIGHT Off
    'Chip will enter low power mode when program ends
```

<span class="strong">**For more help, see**</span>
<a href="goto" class="link" title="Goto">Goto</a>,
<a href="gosub" class="link" title="Gosub">Gosub</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCase</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_instr.html" title="Instr"><link rel="next" href="_left.html" title="Left"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcase"></a>LCase</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>output</em></span> = LCase(<span class="emphasis"><em>source</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">LCase</code> function will convert all of the letters in the string <code class="literal"><span class="emphasis"><em>source</em></span></code> to lower case, and return the result.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the string in lower case
    'Will display "hello, world!"
    HSerPrint LCase(TestData)
    HSerPrintCRLF</pre><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_ucase.html" title="UCase">UCase</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcase"></span>LCase

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    output = LCase(source)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `LCase` function will convert all of the letters in the string
`source` to lower case, and return the result.

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the string in lower case
    'Will display "hello, world!"
    HSerPrint LCase(TestData)
    HSerPrintCRLF
```

<span class="strong">**See Also**</span>
<a href="ucase" class="link" title="UCase">UCase</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCDBacklight</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_get.html" title="Get"><link rel="next" href="_lcdcreatechar.html" title="LCDCreateChar"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcdbacklight"></a>LCDBacklight</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    LCDBacklight ( On | Off )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Sets the LCD backlight on or off</p><p>Do not connect the LCD backlight directly to the microcontroller! Always refer to
the datasheet for the correct method to drive the LCD backlight.</p><p>For 0, 4, 8, 404 LCD types you <span class="strong"><strong>must</strong></span> define the controlling port.pin for the LCD backlight.</p><pre class="screen">        'this port.pin is connected to the LCD backlight via a suitable circuit
        #define LCD_Backlight porta.4
        ...
        ...
        ...
        ...
        LCDBacklight ( On )

        .... more user code...
        LCDBacklight ( Off )</pre><p><br>
<br>
<span class="strong"><strong>Inverting the State of the LCD</strong></span></p><p>You may need to invert the state of the LCD backlight control port.  This can be achieved by setting the following constants.</p><pre class="screen">        'Invert the LCD Backlight States to suit the circuit board
        #define LCD_Backlight_On_State  0    'the default constant value is 1
        #define LCD_Backlight_Off_State 1    'the default constant value is 0</pre><p><br>
<br></p><p>The diagram below shows a method to connect the LCD backlight to a microcontroller.</p><p><span class="inlinemediaobject"><img src="./images/lcdbacklightb1.JPG" alt="graphic"></span>
The diagram above was provided by William Roth, January 2015.</p><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcdbacklight"></span>LCDBacklight

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    LCDBacklight ( On | Off )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

Sets the LCD backlight on or off

Do not connect the LCD backlight directly to the microcontroller! Always
refer to the datasheet for the correct method to drive the LCD
backlight.

For 0, 4, 8, 404 LCD types you <span class="strong">**must**</span>
define the controlling port.pin for the LCD backlight.

``` screen
        'this port.pin is connected to the LCD backlight via a suitable circuit
        #define LCD_Backlight porta.4
        ...
        ...
        ...
        ...
        LCDBacklight ( On )

        .... more user code...
        LCDBacklight ( Off )
```

  
  
<span class="strong">**Inverting the State of the LCD**</span>

You may need to invert the state of the LCD backlight control port. This
can be achieved by setting the following constants.

``` screen
        'Invert the LCD Backlight States to suit the circuit board
        #define LCD_Backlight_On_State  0    'the default constant value is 1
        #define LCD_Backlight_Off_State 1    'the default constant value is 0
```

  
  

The diagram below shows a method to connect the LCD backlight to a
microcontroller.

<span
class="inlinemediaobject">![graphic](./images/lcdbacklightb1.JPG)</span>
The diagram above was provided by William Roth, January 2015.

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCDCmd</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_lcdcreategraph.html" title="LCDCreateGraph"><link rel="next" href="_lcdcursor.html" title="LCDCursor"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcdcmd"></a>LCDCmd</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    LCDCMD <span class="emphasis"><em>value</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command set LCD specific instructions to the LCD display. As shown
in the table below.</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>INSTRUCTION</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Decimal</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Hexadecimal</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>Scroll display one character right (all lines)</p></td><td align="center" valign="top"><p>28</p></td><td align="center" valign="top"><p>1E</p></td></tr><tr><td align="left" valign="top"><p>Scroll display one character left (all lines)</p></td><td align="center" valign="top"><p>24</p></td><td align="center" valign="top"><p>18</p></td></tr><tr><td align="left" valign="top"><p>Home (move cursor to top/left character position)</p></td><td align="center" valign="top"><p>2</p></td><td align="center" valign="top"><p>2</p></td></tr><tr><td align="left" valign="top"><p>Move cursor one character left</p></td><td align="center" valign="top"><p>16</p></td><td align="center" valign="top"><p>10</p></td></tr><tr><td align="left" valign="top"><p>Move cursor one character right</p></td><td align="center" valign="top"><p>20</p></td><td align="center" valign="top"><p>14</p></td></tr><tr><td align="left" valign="top"><p>Turn on visible underline cursor</p></td><td align="center" valign="top"><p>14</p></td><td align="center" valign="top"><p>0E</p></td></tr><tr><td align="left" valign="top"><p>Turn on visible blinking-block cursor</p></td><td align="center" valign="top"><p>15</p></td><td align="center" valign="top"><p>0F</p></td></tr><tr><td align="left" valign="top"><p>Make cursor invisible</p></td><td align="center" valign="top"><p>12</p></td><td align="center" valign="top"><p>0C</p></td></tr><tr><td align="left" valign="top"><p>Blank the display (without clearing)</p></td><td align="center" valign="top"><p>8</p></td><td align="center" valign="top"><p>08</p></td></tr><tr><td align="left" valign="top"><p>Restore the display (with cursor hidden)</p></td><td align="center" valign="top"><p>12</p></td><td align="center" valign="top"><p>0C</p></td></tr><tr><td align="left" valign="top"><p>Clear Screen</p></td><td align="center" valign="top"><p>1</p></td><td align="center" valign="top"><p>01</p></td></tr><tr><td align="left" valign="top"><p>Set cursor position (DDRAM address)</p></td><td align="center" valign="top"><p>128 + addr</p></td><td align="center" valign="top"><p>80+ addr</p></td></tr><tr><td align="left" valign="top"><p>Set pointer in character-generator RAM (CG RAM address)</p></td><td align="center" valign="top"><p>64 + addr</p></td><td align="center" valign="top"><p>40+ addr</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    ;Chip Settings
    #chip 16F88,8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Locate 0,0
    Print "Reset"
    wait 1 s
    cls

    LCD_Command_Tests:

    locate 0,8
    print "123456"
    'Scroll display one character right (all lines)       28
    '
    lcdcmd 28
    wait 1 s
    lcdcmd 28
    wait 1 s
    lcdcmd 28
    wait 1 s
    lcdcmd 28
    wait 1 s

    'Scroll display one character left (all lines)        24
    '
    lcdcmd 24
    wait 1 s
    lcdcmd 24
    wait 1 s
    lcdcmd 24
    wait 1 s
    lcdcmd 24
    wait 1 s


    'Home (move cursor to top/left character position)    2
    '
    lcdcursor flash
    lcdcmd 2
    wait 1 s

    'Move cursor one character left                       16
    '
    lcdcursor flash
    locate 0,8

    lcdcmd 16
    wait 1 s
    lcdcmd 16
    wait 1 s
    lcdcmd 16
    wait 1 s
    lcdcmd 16
    wait 1 s

    'Move cursor one character right                      20
    '
    lcdcmd 20
    wait 1 s
    lcdcmd 20
    wait 1 s
    lcdcmd 20
    wait 1 s
    lcdcmd 20
    wait 1 s</pre><p><span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    #chip 16F877A,20
    #option Explicit

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

    ;Here are various LCD commands which can be used.
    ;These are the LCD commands for the HD44780 controller
    #define clrHome = 1     ;clear the display, home the cursor
    #define home    = 2     ;home the cursor only
    #define RtoL    = 4     ;print characters right to left
    #define insR    = 5     ;insert characters to right
    #define LtoR    = 6     ;print characters left to right
    #define insL    = 7     ;insert characters to left
    #define lcdOff  = 8     ;LCD screen off
    #define lcdOn   = 12    ;LCD screen on, no cursor
    #define curOff  = 12    ;an alias for the above
    #define block   = 13    ;LCD screen on, block cursor
    #define under   = 14    ;LCD screen on, underline cursor
    #define undblk  = 15    ;LCD screen on, blinking and underline cursor
    #define CLeft   = 16    ;cursor left
    #define CRight  = 20    ;cursor right
    #define panR    = 24    ;pan viewing window right
    #define panL    = 28    ;pan viewing window left
    #define bus4    = 32    ;4-bit data bus mode
    #define bus8    = 48    ;8-bit data bus mode
    #define mode1   = 32    ;one-line mode (alias)
    #define mode2   = 40    ;two-line mode
    #define line1   = 128   ;go to start of line 1
    #define line2   = 192   ;go to start of line 2
    ;----- Variables
    dim char, msn, lsn, index, ii as byte
    ;----- Main Program
    LoadEeprom              ;load the EEprom with strings

    do forever
        printMsg(0)             ;print first message
        wait 3 S                ;pause 3 seconds
        printMsg(2)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 5                ;blink it five times
          LCDCmd(lcdOff)       ;display off
          wait 500 mS           ;pause
          LCDCmd(lcdOn)        ;display on
          wait 500 mS           ;pause
        end repeat
        wait 1 S                ;pause before next demo
        ;demonstrate panning
        printMsg(4)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 16
          LCDCmd(panL)         ;pan left a step at a time
          wait 300 mS           ;slow down to avoid blur
        end repeat
        repeat 16
          LCDCmd(panR)         ;then pan right
          wait 300 mS
        end repeat
        wait 1 S                ;pause before next demo
                                ;demonstrate moving the cursor
        printMsg(6)             ;print next message
        wait 3 S                ;pause 3 seconds
        LCDHome
        LCDCmd(under)          ;choose underline cursor
        for ii = 0 to 15         ;move cursor across first line
          LCDCmd(line1+ii)
          wait 200 mS
        next i
        for ii = 0 to 15         ;move cursor across second line
          LCDCmd(line2+ii)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over second line
          LCDCmd(line2+ii)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over first line
          LCDCmd(line1+ii)
          wait 200 mS
        next i
        wait 3 S
        ;demonstrate blinking block cursor
        printMsg(8)             ;print next message
        LCDHome                  ;home the cursor
        LCDCmd(block)          ;choose blinking block cursor
        wait 4 S                ;pause 4 seconds
        LCDCmd(mode1)          ;change to one long line mode
        LCDHome                  ;home the cursor again
        LCDCmd(curOff)         ;and disable it


        ;demonstrate scrolling a lengthy one-line marquee
        for ii = 0xd0 to 0xff    ;print next message - the remaining EEPROM
          EPread ii, char        ;fetch directly from eeprom
          print chr(char)
        next i
        wait 1 S
        LCDHome                  ;home cursor once more
        repeat 141               ;scroll message twice
          LCDCmd(panR)
          wait 250 mS
        end repeat
        wait 2 S
        LCDCmd(mode2)          ;change back to two line mode
        CLS                   ;clear the screen
        ;demonstrate all of the characters
        printMsg(11)             ;print next message
        for ii = 33 to 127       ;print first batch of ASCII characters
          LCDCmd(line1+12)       ;overwrite each character displayed
          print chr(ii)          ;this is the ASCII code
          wait 500 mS
        next i
        for ii = 161 to 255      ;print next batch of ASCII characters
          LCDCmd(line1+12)
          print chr(ii)
          wait 500 mS
        next i
        ;say good-bye
        LCDCmd(line2)
        printMsg(11)             ;print next message
        LCDHome                  ;home the cursor
    loop
    end

    ;----- Print a message to the LCD
    ;The parameter 'row' points to the start of the string.
    sub printMsg(in row as byte, in Optional StringLength As Byte = 15)
      Locate 0, 0              ;get set for first line

      for ii = 0 to StringLength
        index = row*16+ii
        EPread index, char        ;fetch next character and
        print chr(char)             ;transmit to the LCD
      next

      Locate 1,0              ;get set for second line
      for ii = 0 to StringLength
        index = (row+1)*16+ii
        EPread index, char        ;fetch next character and
        print chr(char)             ;transmit to the LCD
      next
    end sub

    sub loadEeprom

    ' Strings for EEPROM, Strings should be limited to 16 characters for the first 13 sstrings, then a long string to fill eeprom
    WriteEeprom "First we'll show"
    WriteEeprom "this message.   "
    WriteEeprom "Then we'll blink"
    WriteEeprom "five times.     "
    WriteEeprom "Now lets pan    "
    WriteEeprom "left and right. "
    WriteEeprom "Watch the line  "
    WriteEeprom "cursor move.    "
    WriteEeprom "A block cursor  "
    WriteEeprom "is available.   "
    WriteEeprom "Characters:     "
    WriteEeprom "Bye!            "
    WriteEeprom "in one line mode"
    WriteEeprom "Next well scroll this long message as a marquee"
    end sub


    ; Write to the device eeprom
    sub WriteEeprom ( in Estring() )

        Dim eeLocation as Byte 'if the EEPROM size was larger than 256 bytes then this would need to be a WORD

        for eeLocation = 1 to len ( Estring )
            HSersend Estring( eeLocation )
            epwrite eeLocation, Estring( eeLocation )
        next
    end sub</pre><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcdcmd"></span>LCDCmd

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    LCDCMD value
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This command set LCD specific instructions to the LCD display. As shown
in the table below.

<div class="informaltable">

| <span class="strong">**INSTRUCTION**</span>             | <span class="strong">**Decimal**</span> | <span class="strong">**Hexadecimal**</span> |
|:--------------------------------------------------------|:---------------------------------------:|:-------------------------------------------:|
| Scroll display one character right (all lines)          |                   28                    |                     1E                      |
| Scroll display one character left (all lines)           |                   24                    |                     18                      |
| Home (move cursor to top/left character position)       |                    2                    |                      2                      |
| Move cursor one character left                          |                   16                    |                     10                      |
| Move cursor one character right                         |                   20                    |                     14                      |
| Turn on visible underline cursor                        |                   14                    |                     0E                      |
| Turn on visible blinking-block cursor                   |                   15                    |                     0F                      |
| Make cursor invisible                                   |                   12                    |                     0C                      |
| Blank the display (without clearing)                    |                    8                    |                     08                      |
| Restore the display (with cursor hidden)                |                   12                    |                     0C                      |
| Clear Screen                                            |                    1                    |                     01                      |
| Set cursor position (DDRAM address)                     |               128 + addr                |                  80+ addr                   |
| Set pointer in character-generator RAM (CG RAM address) |                64 + addr                |                  40+ addr                   |

</div>

<span class="strong">**Example 1:**</span>

``` screen
    ;Chip Settings
    #chip 16F88,8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Locate 0,0
    Print "Reset"
    wait 1 s
    cls

    LCD_Command_Tests:

    locate 0,8
    print "123456"
    'Scroll display one character right (all lines)       28
    '
    lcdcmd 28
    wait 1 s
    lcdcmd 28
    wait 1 s
    lcdcmd 28
    wait 1 s
    lcdcmd 28
    wait 1 s

    'Scroll display one character left (all lines)        24
    '
    lcdcmd 24
    wait 1 s
    lcdcmd 24
    wait 1 s
    lcdcmd 24
    wait 1 s
    lcdcmd 24
    wait 1 s


    'Home (move cursor to top/left character position)    2
    '
    lcdcursor flash
    lcdcmd 2
    wait 1 s

    'Move cursor one character left                       16
    '
    lcdcursor flash
    locate 0,8

    lcdcmd 16
    wait 1 s
    lcdcmd 16
    wait 1 s
    lcdcmd 16
    wait 1 s
    lcdcmd 16
    wait 1 s

    'Move cursor one character right                      20
    '
    lcdcmd 20
    wait 1 s
    lcdcmd 20
    wait 1 s
    lcdcmd 20
    wait 1 s
    lcdcmd 20
    wait 1 s
```

<span class="strong">**Example 2:**</span>

``` screen
    #chip 16F877A,20
    #option Explicit

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

    ;Here are various LCD commands which can be used.
    ;These are the LCD commands for the HD44780 controller
    #define clrHome = 1     ;clear the display, home the cursor
    #define home    = 2     ;home the cursor only
    #define RtoL    = 4     ;print characters right to left
    #define insR    = 5     ;insert characters to right
    #define LtoR    = 6     ;print characters left to right
    #define insL    = 7     ;insert characters to left
    #define lcdOff  = 8     ;LCD screen off
    #define lcdOn   = 12    ;LCD screen on, no cursor
    #define curOff  = 12    ;an alias for the above
    #define block   = 13    ;LCD screen on, block cursor
    #define under   = 14    ;LCD screen on, underline cursor
    #define undblk  = 15    ;LCD screen on, blinking and underline cursor
    #define CLeft   = 16    ;cursor left
    #define CRight  = 20    ;cursor right
    #define panR    = 24    ;pan viewing window right
    #define panL    = 28    ;pan viewing window left
    #define bus4    = 32    ;4-bit data bus mode
    #define bus8    = 48    ;8-bit data bus mode
    #define mode1   = 32    ;one-line mode (alias)
    #define mode2   = 40    ;two-line mode
    #define line1   = 128   ;go to start of line 1
    #define line2   = 192   ;go to start of line 2
    ;----- Variables
    dim char, msn, lsn, index, ii as byte
    ;----- Main Program
    LoadEeprom              ;load the EEprom with strings

    do forever
        printMsg(0)             ;print first message
        wait 3 S                ;pause 3 seconds
        printMsg(2)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 5                ;blink it five times
          LCDCmd(lcdOff)       ;display off
          wait 500 mS           ;pause
          LCDCmd(lcdOn)        ;display on
          wait 500 mS           ;pause
        end repeat
        wait 1 S                ;pause before next demo
        ;demonstrate panning
        printMsg(4)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 16
          LCDCmd(panL)         ;pan left a step at a time
          wait 300 mS           ;slow down to avoid blur
        end repeat
        repeat 16
          LCDCmd(panR)         ;then pan right
          wait 300 mS
        end repeat
        wait 1 S                ;pause before next demo
                                ;demonstrate moving the cursor
        printMsg(6)             ;print next message
        wait 3 S                ;pause 3 seconds
        LCDHome
        LCDCmd(under)          ;choose underline cursor
        for ii = 0 to 15         ;move cursor across first line
          LCDCmd(line1+ii)
          wait 200 mS
        next i
        for ii = 0 to 15         ;move cursor across second line
          LCDCmd(line2+ii)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over second line
          LCDCmd(line2+ii)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over first line
          LCDCmd(line1+ii)
          wait 200 mS
        next i
        wait 3 S
        ;demonstrate blinking block cursor
        printMsg(8)             ;print next message
        LCDHome                  ;home the cursor
        LCDCmd(block)          ;choose blinking block cursor
        wait 4 S                ;pause 4 seconds
        LCDCmd(mode1)          ;change to one long line mode
        LCDHome                  ;home the cursor again
        LCDCmd(curOff)         ;and disable it


        ;demonstrate scrolling a lengthy one-line marquee
        for ii = 0xd0 to 0xff    ;print next message - the remaining EEPROM
          EPread ii, char        ;fetch directly from eeprom
          print chr(char)
        next i
        wait 1 S
        LCDHome                  ;home cursor once more
        repeat 141               ;scroll message twice
          LCDCmd(panR)
          wait 250 mS
        end repeat
        wait 2 S
        LCDCmd(mode2)          ;change back to two line mode
        CLS                   ;clear the screen
        ;demonstrate all of the characters
        printMsg(11)             ;print next message
        for ii = 33 to 127       ;print first batch of ASCII characters
          LCDCmd(line1+12)       ;overwrite each character displayed
          print chr(ii)          ;this is the ASCII code
          wait 500 mS
        next i
        for ii = 161 to 255      ;print next batch of ASCII characters
          LCDCmd(line1+12)
          print chr(ii)
          wait 500 mS
        next i
        ;say good-bye
        LCDCmd(line2)
        printMsg(11)             ;print next message
        LCDHome                  ;home the cursor
    loop
    end

    ;----- Print a message to the LCD
    ;The parameter 'row' points to the start of the string.
    sub printMsg(in row as byte, in Optional StringLength As Byte = 15)
      Locate 0, 0              ;get set for first line

      for ii = 0 to StringLength
        index = row*16+ii
        EPread index, char        ;fetch next character and
        print chr(char)             ;transmit to the LCD
      next

      Locate 1,0              ;get set for second line
      for ii = 0 to StringLength
        index = (row+1)*16+ii
        EPread index, char        ;fetch next character and
        print chr(char)             ;transmit to the LCD
      next
    end sub

    sub loadEeprom

    ' Strings for EEPROM, Strings should be limited to 16 characters for the first 13 sstrings, then a long string to fill eeprom
    WriteEeprom "First we'll show"
    WriteEeprom "this message.   "
    WriteEeprom "Then we'll blink"
    WriteEeprom "five times.     "
    WriteEeprom "Now lets pan    "
    WriteEeprom "left and right. "
    WriteEeprom "Watch the line  "
    WriteEeprom "cursor move.    "
    WriteEeprom "A block cursor  "
    WriteEeprom "is available.   "
    WriteEeprom "Characters:     "
    WriteEeprom "Bye!            "
    WriteEeprom "in one line mode"
    WriteEeprom "Next well scroll this long message as a marquee"
    end sub


    ; Write to the device eeprom
    sub WriteEeprom ( in Estring() )

        Dim eeLocation as Byte 'if the EEPROM size was larger than 256 bytes then this would need to be a WORD

        for eeLocation = 1 to len ( Estring )
            HSersend Estring( eeLocation )
            epwrite eeLocation, Estring( eeLocation )
        next
    end sub
```

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCDCreateChar</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_lcdbacklight.html" title="LCDBacklight"><link rel="next" href="_lcdcreategraph.html" title="LCDCreateGraph"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcdcreatechar"></a>LCDCreateChar</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    LCDCreateChar <span class="emphasis"><em>char, chardata()</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The LCDCreateChar command is used to send a custom character to the LCD.</p><p>Each character on the LCD is made up from an 8 row by 5 column (5x8)
matrix of pixels. The data to be sent to the LCD is composed of an 8
element array, where each element corresponds to a row. Inside each
element, the 5 lowest bits make up the data for the corresponding row.
When a bit is set a dot will be drawn at the matching location; when it
is cleared, no dot will appear.</p><p>An array of more than 8 elements may be used, but only the first 8 will
be read.</p><p><code class="literal"><span class="emphasis"><em>char</em></span></code> is the ASCII value of the character to create. ASCII codes 0
through 7 are usually used to store custom characters.<br>
<code class="literal"><span class="emphasis"><em>chardata()</em></span></code> is an array containing the data for the character.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program draws a smiling face character

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Create an array to store the character until it is copied
    Dim CharArray(8)

    'Set the array to hold the character
    'Binary has been used to improve the readability of the code, but is not essential
    CharArray(1) = b'00011011'
    CharArray(2) = b'00011011'
    CharArray(3) = b'00000000'
    CharArray(4) = b'00000100'
    CharArray(5) = b'00000000'
    CharArray(6) = b'00010001'
    CharArray(7) = b'00010001'
    CharArray(8) = b'00001110'

    'Copy the character from the array to the LCD
    LCDCreateChar 0, CharArray()

    'Draw the custom character
    LCDWriteChar 0</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_lcdcreatechar.html" title="LCDCreateChar">LCDWriteChar</a>,
<a class="link" href="_lcd_overview.html" title="LCD Overview">LCD Overview</a></p><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcdcreatechar"></span>LCDCreateChar

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    LCDCreateChar char, chardata()
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The LCDCreateChar command is used to send a custom character to the LCD.

Each character on the LCD is made up from an 8 row by 5 column (5x8)
matrix of pixels. The data to be sent to the LCD is composed of an 8
element array, where each element corresponds to a row. Inside each
element, the 5 lowest bits make up the data for the corresponding row.
When a bit is set a dot will be drawn at the matching location; when it
is cleared, no dot will appear.

An array of more than 8 elements may be used, but only the first 8 will
be read.

`char` is the ASCII value of the character to create. ASCII codes 0
through 7 are usually used to store custom characters.  
`chardata()` is an array containing the data for the character.

<span class="strong">**Example:**</span>

``` screen
    'This program draws a smiling face character

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Create an array to store the character until it is copied
    Dim CharArray(8)

    'Set the array to hold the character
    'Binary has been used to improve the readability of the code, but is not essential
    CharArray(1) = b'00011011'
    CharArray(2) = b'00011011'
    CharArray(3) = b'00000000'
    CharArray(4) = b'00000100'
    CharArray(5) = b'00000000'
    CharArray(6) = b'00010001'
    CharArray(7) = b'00010001'
    CharArray(8) = b'00001110'

    'Copy the character from the array to the LCD
    LCDCreateChar 0, CharArray()

    'Draw the custom character
    LCDWriteChar 0
```

<span class="strong">**For more help, see**</span>
<a href="lcdcreatechar" class="link" title="LCDCreateChar">LCDWriteChar</a>,
<a href="lcd_overview" class="link" title="LCD Overview">LCD Overview</a>

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCDCreateGraph</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_lcdcreatechar.html" title="LCDCreateChar"><link rel="next" href="_lcdcmd.html" title="LCDCmd"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcdcreategraph"></a>LCDCreateGraph</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    LCDCreateGraph <span class="emphasis"><em>value</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The LCDCreateGraph command will create a graph like character which can
then be displayed on the LCD</p><p><span class="strong"><strong>Example :</strong></span></p><pre class="screen">    ;Chip Settings
    #chip 16F88,8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Locate 0,0
    Print "Reset"
    wait 1 s
    cls

    Graph_Tests:

    cls
    'Draw the custom character - fill the LCD
    repeat 64
          LCDWriteChar 0
    end Repeat

    ' Update the characters at high speed without re-printing on LCD
    for graphvalue = 0 to 8
        LCDCreateGraph ( 0 ,  graphvalue )
        wait 100 ms
    next</pre><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcdcreategraph"></span>LCDCreateGraph

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    LCDCreateGraph value
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The LCDCreateGraph command will create a graph like character which can
then be displayed on the LCD

<span class="strong">**Example :**</span>

``` screen
    ;Chip Settings
    #chip 16F88,8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Locate 0,0
    Print "Reset"
    wait 1 s
    cls

    Graph_Tests:

    cls
    'Draw the custom character - fill the LCD
    repeat 64
          LCDWriteChar 0
    end Repeat

    ' Update the characters at high speed without re-printing on LCD
    for graphvalue = 0 to 8
        LCDCreateGraph ( 0 ,  graphvalue )
        wait 100 ms
    next
```

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCDCursor</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_lcdcmd.html" title="LCDCmd"><link rel="next" href="_lcdhex.html" title="LCDHex"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcdcursor"></a>LCDCursor</h4></div></div></div><p><span class="strong"><strong>Syntax</strong></span>:</p><pre class="screen">    LCDCursor value</pre><p><span class="strong"><strong>Command Availability</strong></span>:</p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The LCDCursor command will accept the following parameters:</p><p><code class="literal">LCDON</code>, <code class="literal">LCDOFF</code>, <code class="literal">CURSORON</code>, <code class="literal">CURSOROFF</code>, <code class="literal">FLASHON</code>, <code class="literal">FLASHOFF</code></p><p><code class="literal">FLASH</code>, and <code class="literal">ON/OFF</code> have been retained for backward compatibility with
older releases of GCB.</p><p><code class="literal">LCDON</code>  will turn on (restore) the LCD display.<br>
<code class="literal">LCDOFF</code>  will turn off (hide) the LCD display.<br>
<code class="literal">CURSORON</code>  will turn on the cursor.<br>
<code class="literal">CURSOROFF</code>  will turn off the cursor.<br>
<code class="literal">FLASHON</code>  will flash the cursor.<br>
<code class="literal">FLASHOFF</code>  will stop flashing the cursor.</p><p><span class="strong"><strong>Example :</strong></span>																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												#config osc = intrc</p><pre class="screen">    #chip 16f877a, 8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Start:
    CLS
    WAIT 3 s
    PRINT "START DEMO"
    locate 1,0
    PRINT "DISPLAY ON"

    wait 3 s

    CLS
    Locate 0,0
    Print "Cursor ON"
    Locate 1,0
    LCDcursor CursorOn
    wait 3 S

    CLS
    LCDcursor CursorOFF
    locate 0,0
    Print "Cursor OFF"
    wait 3 s

    CLS
    Locate 0,0
    Print "FLASH ON"
    Locate 1,0
    LCDcursor FLASHON
    wait 3 s

    CLS
    locate 0,0
    Print "FLASH OFF"
    LCDCURSOR FLASHOFF
    wait 3 sec

    Locate 0,0
    Print "CURSOR&amp;FLASH ON" 'Both are on at the same time
    locate 1,0
    LCDCURSOR CURSORON
    LCDCURSOR FLASHON
    Wait 3 sec

    Locate 0,0
    Print "CURSOR FLASH OFF"
    locate 1,0
    LCDCURSOR CursorOFF
    LCDCURSOR FLASHOFF
    Wait 3 sec

    CLS
    Locate 0,4
    PRINT "Flashing"
    Locate 1,4
    Print "Display"
    wait 500 ms

    repeat 5
        LCDCURSOR LCDOFF
        wait 500 ms
        LCDCURSOR LCDON
        wait 500 ms
    end repeat

    CLS
    Locate 0,0
    Print "DISPLAY OFF"
    Locate 1,0
    Print "FOR 5 SEC"
    Wait 2 SEC
    LCDCURSOR LCDOFF
    WAIT 5 s

    CLS
    Locate 0,0
    LCDCURSOR LCDON
    Print "END DEMO"
    wait 3 s
    goto start</pre><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcdcursor"></span>LCDCursor

</div>

</div>

</div>

<span class="strong">**Syntax**</span>:

``` screen
    LCDCursor value
```

<span class="strong">**Command Availability**</span>:

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The LCDCursor command will accept the following parameters:

`LCDON`, `LCDOFF`, `CURSORON`, `CURSOROFF`, `FLASHON`, `FLASHOFF`

`FLASH`, and `ON/OFF` have been retained for backward compatibility with
older releases of GCB.

`LCDON` will turn on (restore) the LCD display.  
`LCDOFF` will turn off (hide) the LCD display.  
`CURSORON` will turn on the cursor.  
`CURSOROFF` will turn off the cursor.  
`FLASHON` will flash the cursor.  
`FLASHOFF` will stop flashing the cursor.

<span class="strong">**Example :**</span> \#config osc = intrc

``` screen
    #chip 16f877a, 8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Start:
    CLS
    WAIT 3 s
    PRINT "START DEMO"
    locate 1,0
    PRINT "DISPLAY ON"

    wait 3 s

    CLS
    Locate 0,0
    Print "Cursor ON"
    Locate 1,0
    LCDcursor CursorOn
    wait 3 S

    CLS
    LCDcursor CursorOFF
    locate 0,0
    Print "Cursor OFF"
    wait 3 s

    CLS
    Locate 0,0
    Print "FLASH ON"
    Locate 1,0
    LCDcursor FLASHON
    wait 3 s

    CLS
    locate 0,0
    Print "FLASH OFF"
    LCDCURSOR FLASHOFF
    wait 3 sec

    Locate 0,0
    Print "CURSOR&FLASH ON" 'Both are on at the same time
    locate 1,0
    LCDCURSOR CURSORON
    LCDCURSOR FLASHON
    Wait 3 sec

    Locate 0,0
    Print "CURSOR FLASH OFF"
    locate 1,0
    LCDCURSOR CursorOFF
    LCDCURSOR FLASHOFF
    Wait 3 sec

    CLS
    Locate 0,4
    PRINT "Flashing"
    Locate 1,4
    Print "Display"
    wait 500 ms

    repeat 5
        LCDCURSOR LCDOFF
        wait 500 ms
        LCDCURSOR LCDON
        wait 500 ms
    end repeat

    CLS
    Locate 0,0
    Print "DISPLAY OFF"
    Locate 1,0
    Print "FOR 5 SEC"
    Wait 2 SEC
    LCDCURSOR LCDOFF
    WAIT 5 s

    CLS
    Locate 0,0
    LCDCURSOR LCDON
    Print "END DEMO"
    wait 3 s
    goto start
```

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCDDisplayOff</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_lcddisplayon.html" title="LCDDisplayOn"><link rel="next" href="_lcdspace.html" title="LCDSpace"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcddisplayoff"></a>LCDDisplayOff</h4></div></div></div><p><span class="strong"><strong>Syntax</strong></span>:</p><pre class="screen">    LCDDisplayOff</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Will turn off (hide) the LCD display.</p><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_lcdcursor.html" title="LCDCursor">LCDCursor</a></p><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcddisplayoff"></span>LCDDisplayOff

</div>

</div>

</div>

<span class="strong">**Syntax**</span>:

``` screen
    LCDDisplayOff
```

<span class="strong">**Explanation:**</span>

Will turn off (hide) the LCD display.

<span class="strong">**See also**</span>
<a href="lcdcursor" class="link" title="LCDCursor">LCDCursor</a>

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCDDisplayOn</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_lcdhome.html" title="LCDHome"><link rel="next" href="_lcddisplayoff.html" title="LCDDisplayOff"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcddisplayon"></a>LCDDisplayOn</h4></div></div></div><p><span class="strong"><strong>Syntax</strong></span>:</p><pre class="screen">    LCDDisplayOn</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Will turn on (restore) the LCD display</p><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_lcdcursor.html" title="LCDCursor">LCDCursor</a></p><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcddisplayon"></span>LCDDisplayOn

</div>

</div>

</div>

<span class="strong">**Syntax**</span>:

``` screen
    LCDDisplayOn
```

<span class="strong">**Explanation:**</span>

Will turn on (restore) the LCD display

<span class="strong">**See also**</span>
<a href="lcdcursor" class="link" title="LCDCursor">LCDCursor</a>

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCDHex</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_lcdcursor.html" title="LCDCursor"><link rel="next" href="_lcdhome.html" title="LCDHome"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcdhex"></a>LCDHex</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    LCDHex value

    LCDHex value, <span class="strong"><strong>LeadingZeroActive</strong></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The LCDHex will display the byte value as a 1 or 2 character HEX string.</p><p><code class="literal">value</code> is a byte value from 0 to 255.</p><p><code class="literal">LeadingZeroActive</code> is a constant or byte value of 2.</p><p><span class="strong"><strong>Example :</strong></span></p><pre class="screen">    ;Set chip model required:
    #chip mega328p, 16
    ;Setup LCD Parameters
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_NO_RW
    #define LCD_Speed MEDIUM 'FAST IS OK ON ARDUINO UNO R3

    'Change as necessary
    #define LCD_RS PortC.0
    #define LCD_Enable PortC.1
    #define LCD_DB4 PortC.2
    #define LCD_DB5 PortC.3
    #define LCD_DB6 PortC.4
    #define LCD_DB7 PortC.5

    '  #chip 16f877a, 8
    '  ;Setup LCD Parameters
    '  #define LCD_IO 4
    '  #define LCD_NO_RW
    '  #define LCD_Speed fast 'FAST IS OK ON 16f877a
    '
    '  ;Change as necessary
    '  #define LCD_RS PortB.2
    '  #define LCD_Enable PortB.3
    '  #define LCD_DB4 PortB.4
    '  #define LCD_DB5 PortB.5
    '  #define LCD_DB6 PortB.6
    '  #define LCD_DB7 PortB.7

    'Program Start
    DO Forever
       CLS
       WAIT 2 s
       PRINT "Test LCDHex "
       wait 3 s
       CLS
       wait 1 s

       for bv = 0 to 255
          locate 0,0
          Print "DEC " : Print BV
          locate 1,0
          Print "HEX "
          LCDHex BV, LeadingZeroActive ; dislay leading Zero
        ' LCDHex BV         ; do not display leading zero
          wait 1 s
       next
       CLS
       wait 1 s
       Print "END TEST"
    LOOP</pre><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcdhex"></span>LCDHex

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    LCDHex value

    LCDHex value, LeadingZeroActive
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The LCDHex will display the byte value as a 1 or 2 character HEX string.

`value` is a byte value from 0 to 255.

`LeadingZeroActive` is a constant or byte value of 2.

<span class="strong">**Example :**</span>

``` screen
    ;Set chip model required:
    #chip mega328p, 16
    ;Setup LCD Parameters
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_NO_RW
    #define LCD_Speed MEDIUM 'FAST IS OK ON ARDUINO UNO R3

    'Change as necessary
    #define LCD_RS PortC.0
    #define LCD_Enable PortC.1
    #define LCD_DB4 PortC.2
    #define LCD_DB5 PortC.3
    #define LCD_DB6 PortC.4
    #define LCD_DB7 PortC.5

    '  #chip 16f877a, 8
    '  ;Setup LCD Parameters
    '  #define LCD_IO 4
    '  #define LCD_NO_RW
    '  #define LCD_Speed fast 'FAST IS OK ON 16f877a
    '
    '  ;Change as necessary
    '  #define LCD_RS PortB.2
    '  #define LCD_Enable PortB.3
    '  #define LCD_DB4 PortB.4
    '  #define LCD_DB5 PortB.5
    '  #define LCD_DB6 PortB.6
    '  #define LCD_DB7 PortB.7

    'Program Start
    DO Forever
       CLS
       WAIT 2 s
       PRINT "Test LCDHex "
       wait 3 s
       CLS
       wait 1 s

       for bv = 0 to 255
          locate 0,0
          Print "DEC " : Print BV
          locate 1,0
          Print "HEX "
          LCDHex BV, LeadingZeroActive ; dislay leading Zero
        ' LCDHex BV         ; do not display leading zero
          wait 1 s
       next
       CLS
       wait 1 s
       Print "END TEST"
    LOOP
```

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCDHome</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_lcdhex.html" title="LCDHex"><link rel="next" href="_lcddisplayon.html" title="LCDDisplayOn"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcdhome"></a>LCDHome</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    LCDHome</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">LCDHome</code> command will return the cursor to home position.</p><p>The currentcontents of the LCD screen will be retained.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    ;Chip Settings
    #chip 16F88,8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Locate 0,0
    Print "Reset"
    wait 1 s
    ClS

    Cursor_Home_Tests:

    cls
    lcdcursor flash
    print "Test Home Cmd"
    LCDHome
    wait 3 s</pre><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcdhome"></span>LCDHome

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    LCDHome
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `LCDHome` command will return the cursor to home position.

The currentcontents of the LCD screen will be retained.

<span class="strong">**Example:**</span>

``` screen
    ;Chip Settings
    #chip 16F88,8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Locate 0,0
    Print "Reset"
    wait 1 s
    ClS

    Cursor_Home_Tests:

    cls
    lcdcursor flash
    print "Test Home Cmd"
    LCDHome
    wait 3 s
```

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCDSpace</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_lcddisplayoff.html" title="LCDDisplayOff"><link rel="next" href="_lcdwritechar.html" title="LCDWriteChar"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcdspace"></a>LCDSpace</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    LCDSpace value</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The LCDSpace command will print the required number of spaces on the LCD
display</p><p><code class="literal">value</code> is a byte value from 1 to 255. Where the <code class="literal">value</code> is the number of spaces required.</p><p><span class="strong"><strong>Example :</strong></span></p><pre class="screen">    Locate 0,0
    Print "Reset"
    wait 1 s
    cls

    LCD_Space_Tests:

    lcdcursor flash

    lcdspace 12

    print "*"</pre><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcdspace"></span>LCDSpace

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    LCDSpace value
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The LCDSpace command will print the required number of spaces on the LCD
display

`value` is a byte value from 1 to 255. Where the `value` is the number
of spaces required.

<span class="strong">**Example :**</span>

``` screen
    Locate 0,0
    Print "Reset"
    wait 1 s
    cls

    LCD_Space_Tests:

    lcdcursor flash

    lcdspace 12

    print "*"
```

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCDWriteChar</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_lcdspace.html" title="LCDSpace"><link rel="next" href="_locate.html" title="Locate"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcdwritechar"></a>LCDWriteChar</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    LCDWriteChar <span class="emphasis"><em>char</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">LCDWriteChar</code> command will show the specified character on the LCD,
at the current cursor position.</p><p><code class="literal"><span class="emphasis"><em>char</em></span></code> is the ASCII value of the character to show. On most LCDs,
characters 0 through 7 are user defined, and can be set using the
<code class="literal">LCDCreateChar</code> command.</p><p><span class="strong"><strong>Example :</strong></span></p><pre class="screen">    'This program draws a smiling face character

    'Create an array to store the character until it is copied
    Dim CharArray(8)

    'Set the array to hold the character
    CharArray(1) = b'00011011'
    CharArray(2) = b'00011011'
    CharArray(3) = b'00000000'
    CharArray(4) = b'00000100'
    CharArray(5) = b'00000000'
    CharArray(6) = b'00010001'
    CharArray(7) = b'00010001'
    CharArray(8) = b'00001110'

    'Copy the character from the array to the LCD
    LCDCreateChar 0, CharArray()

    'Draw the custom character
    LCDWriteChar 0</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_lcdcreatechar.html" title="LCDCreateChar">LCDCreateChar</a>,
<a class="link" href="_lcd_overview.html" title="LCD Overview">LCD Overview</a></p><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcdwritechar"></span>LCDWriteChar

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    LCDWriteChar char
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `LCDWriteChar` command will show the specified character on the LCD,
at the current cursor position.

`char` is the ASCII value of the character to show. On most LCDs,
characters 0 through 7 are user defined, and can be set using the
`LCDCreateChar` command.

<span class="strong">**Example :**</span>

``` screen
    'This program draws a smiling face character

    'Create an array to store the character until it is copied
    Dim CharArray(8)

    'Set the array to hold the character
    CharArray(1) = b'00011011'
    CharArray(2) = b'00011011'
    CharArray(3) = b'00000000'
    CharArray(4) = b'00000100'
    CharArray(5) = b'00000000'
    CharArray(6) = b'00010001'
    CharArray(7) = b'00010001'
    CharArray(8) = b'00001110'

    'Copy the character from the array to the LCD
    LCDCreateChar 0, CharArray()

    'Draw the custom character
    LCDWriteChar 0
```

<span class="strong">**For more help, see**</span>
<a href="lcdcreatechar" class="link" title="LCDCreateChar">LCDCreateChar</a>,
<a href="lcd_overview" class="link" title="LCD Overview">LCD Overview</a>

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 0</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_overview.html" title="LCD Overview"><link rel="next" href="_lcd_io_1.html" title="LCD_IO 1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_0"></a>LCD_IO 0</h5></div></div></div><p><span class="strong"><strong>Using connection mode 0:</strong></span></p><p>To use connection mode 0, a subroutine to write a byte to the LCD <span class="strong"><strong>must</strong></span> be provided.</p><p>Optionally, another subroutine to read a byte from the LCD can also be
defined.  If the LCD was to be read, the function <code class="literal">LCDReadByte</code> would be set to the name of a function that reads the LCD and returns the data byte from the LCD.
If there is no way (or no requirement) to read from the LCD, then the <code class="literal">LCD_NO_RW</code> constant must be set.</p><p>In connection mode 0, the <code class="literal">LCD_RS</code> constant will be set automatically to an unused bit variable.
The higher level LCD commands (such as <code class="literal">Print</code> and <code class="literal">Locate</code>) will set it, and the subroutine is responsible for writing to the LCD.
The subroutine should handle the process and then set the RS pin on the LCD appropriately.</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>Specific constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC.  To set these constants the main program should specific constants to support the connection mode using #define.</p><p>When using connection mode 0 only one constant must be set - all others are optional or can be ignored.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_IO</code></p></td><td align="left" valign="top"><p>The I/O mode.</p></td><td align="left" valign="top"><p><code class="literal">0</code></p></td></tr></tbody></table></div><p>For a code example of connection mode 0 program, download <a class="link" href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%200.gcb" target="_top">here</a>.</p><p>See the separate sections of the Help file for the specifics of each
Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>, <a class="link" href="_lcd_io_2.html" title="LCD_IO 2">LCD_IO 2</a>,
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>, <a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>,<a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a> or <a class="link" href="_lcd_io_12.html" title="LCD_IO 12">LCD_IO 12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_0"></span>LCD\_IO 0

</div>

</div>

</div>

<span class="strong">**Using connection mode 0:**</span>

To use connection mode 0, a subroutine to write a byte to the LCD <span
class="strong">**must**</span> be provided.

Optionally, another subroutine to read a byte from the LCD can also be
defined. If the LCD was to be read, the function `LCDReadByte` would be
set to the name of a function that reads the LCD and returns the data
byte from the LCD. If there is no way (or no requirement) to read from
the LCD, then the `LCD_NO_RW` constant must be set.

In connection mode 0, the `LCD_RS` constant will be set automatically to
an unused bit variable. The higher level LCD commands (such as `Print`
and `Locate`) will set it, and the subroutine is responsible for writing
to the LCD. The subroutine should handle the process and then set the RS
pin on the LCD appropriately.

<span class="strong">**Relevant Constants:**</span>

Specific constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set these constants the main
program should specific constants to support the connection mode using
\#define.

When using connection mode 0 only one constant must be set - all others
are optional or can be ignored.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Value**</span> |
|:----------------------------------------------|:-----------------------------------------|:--------------------------------------|
| `LCD_IO`                                      | The I/O mode.                            | `0`                                   |

</div>

For a code example of connection mode 0 program, download
<a href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%200.gcb" class="link">here</a>.

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2" class="link" title="LCD_IO 2">LCD_IO 2</a>,
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>
or
<a href="lcd_io_12" class="link" title="LCD_IO 12">LCD_IO 12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 1</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_io_0.html" title="LCD_IO 0"><link rel="next" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_1"></a>LCD_IO 1</h5></div></div></div><p><span class="strong"><strong>Using connection mode 1:</strong></span></p><p>This approach uses a single connectivity line that supports a combined data
and clock signal between the microcontroller and the LCD display. This approach
is used when the LCD is connected through a shift register 74HC595, as detailed
at <a class="link" href="http://gcbasic.sourceforge.net/library/DIAGRAMS/1-Wire%20LCD/1-wire%20LCD%2074HC595%20for%20GCB.jpg" target="_top">here</a>.
This connection method is also called a 1-wire connection.</p><p>This solution approach recognises the original work provided in the Elektor Magazine.</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>Specific constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC. To set these constants the main program should specific constants to support the connection mode using #define.</p><p>When using connection mode 1, only two constants must be set - all others are optional or can be ignored.</p><p>How to connect and control the LCD background led: see <a class="link" href="_lcdbacklight.html" title="LCDBacklight">LCDBacklight</a>.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_IO</code></p></td><td align="left" valign="top"><p>The I/O mode.</p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_CD</code></p></td><td align="left" valign="top"><p>The clock/data pin used in 1-bit mode.</p></td><td align="left" valign="top"><p><span class="strong"><strong>Mandated</strong></span></p></td></tr></tbody></table></div><p>LCD.h supports in 1-wire mode the control of pin 4 of the 74HC595 for the background led.</p><p>For a code example download <a class="link" href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%201.gcb" target="_top">One Wire LCD Example</a>.</p><p>See for further code examples see <a class="link" href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" target="_top">0,1 and 2 Wire LCD Solutions</a>.</p><p>See the separate sections of the Help file for the specifics of each Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_0.html" title="LCD_IO 0">LCD_IO 0</a>, <a class="link" href="_lcd_io_2.html" title="LCD_IO 2">LCD_IO 2</a>
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>, <a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>, <a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a> or <a class="link" href="_lcd_io_12.html" title="LCD_IO 12">LCD_IO 12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_1"></span>LCD\_IO 1

</div>

</div>

</div>

<span class="strong">**Using connection mode 1:**</span>

This approach uses a single connectivity line that supports a combined
data and clock signal between the microcontroller and the LCD display.
This approach is used when the LCD is connected through a shift register
74HC595, as detailed at
<a href="http://gcbasic.sourceforge.net/library/DIAGRAMS/1-Wire%20LCD/1-wire%20LCD%2074HC595%20for%20GCB.jpg" class="link">here</a>.
This connection method is also called a 1-wire connection.

This solution approach recognises the original work provided in the
Elektor Magazine.

<span class="strong">**Relevant Constants:**</span>

Specific constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set these constants the main
program should specific constants to support the connection mode using
\#define.

When using connection mode 1, only two constants must be set - all
others are optional or can be ignored.

How to connect and control the LCD background led: see
<a href="lcdbacklight" class="link" title="LCDBacklight">LCDBacklight</a>.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Default Value**</span> |
|:----------------------------------------------|:-----------------------------------------|:----------------------------------------------|
| `LCD_IO`                                      | The I/O mode.                            | `1`                                           |
| `LCD_CD`                                      | The clock/data pin used in 1-bit mode.   | <span class="strong">**Mandated**</span>      |

</div>

LCD.h supports in 1-wire mode the control of pin 4 of the 74HC595 for
the background led.

For a code example download
<a href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%201.gcb" class="link">One Wire LCD Example</a>.

See for further code examples see
<a href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" class="link">0,1 and 2 Wire LCD Solutions</a>.

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_0" class="link" title="LCD_IO 0">LCD_IO 0</a>,
<a href="lcd_io_2" class="link" title="LCD_IO 2">LCD_IO 2</a>
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,
<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>
or
<a href="lcd_io_12" class="link" title="LCD_IO 12">LCD_IO 12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 10</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_io_8.html" title="LCD_IO 8"><link rel="next" href="_lcd_io_10_port_configuration.html" title="LCD_IO 10 Port Configuration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_10"></a>LCD_IO 10</h5></div></div></div><p><span class="strong"><strong>Using connection mode 10:</strong></span></p><p>The LCD is controlled via I2C of a type 10 LCD 12C adapter.
Use LCD_IO 10 for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter.
To use mode 10 you must define the I2C ports as normal in your GCBASIC code.
Then, define the LCD type, set the I2C_address of the LCD adapter and the LCD speed, if required.
Finally, set the backlight control, if required.</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>These constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC. To set them, place a line in the main program file that uses #define to assign a value to the particular constant.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_IO</code></p></td><td align="left" valign="top"><p>The I/O mode. Must be 10</p></td><td align="left" valign="top"><p><code class="literal">10</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_I2C_Address_1</code></p></td><td align="left" valign="top"><p>Address of I2C adapter</p></td><td align="left" valign="top"><p>Default <code class="literal">0x4E</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_I2C_Address_2</code></p></td><td align="left" valign="top"><p>Address of I2C adapter</p></td><td align="left" valign="top"><p>Not set</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_I2C_Address_3</code></p></td><td align="left" valign="top"><p>Address of I2C adapter</p></td><td align="left" valign="top"><p>Not set</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_I2C_Address_4</code></p></td><td align="left" valign="top"><p>Address of I2C adapter</p></td><td align="left" valign="top"><p>Not set</p></td></tr></tbody></table></div><p>For code examples see <a class="link" href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" target="_top">I2C LCD Solutions</a>.</p><p>See the separate sections of the Help file for the specifics of each
Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_0.html" title="LCD_IO 0">LCD_IO 0</a>, <a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>, <a class="link" href="_lcd_io_2.html" title="LCD_IO 2">LCD_IO 2</a>,
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>, <a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>, <a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>, <a class="link" href="_lcd_io_12.html" title="LCD_IO 12">LCD_IO 12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_10"></span>LCD\_IO 10

</div>

</div>

</div>

<span class="strong">**Using connection mode 10:**</span>

The LCD is controlled via I2C of a type 10 LCD 12C adapter. Use LCD\_IO
10 for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD\_PIC I2C adapter.
To use mode 10 you must define the I2C ports as normal in your GCBASIC
code. Then, define the LCD type, set the I2C\_address of the LCD adapter
and the LCD speed, if required. Finally, set the backlight control, if
required.

<span class="strong">**Relevant Constants:**</span>

These constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set them, place a line in the
main program file that uses \#define to assign a value to the particular
constant.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Value**</span> |
|:----------------------------------------------|:-----------------------------------------|:--------------------------------------|
| `LCD_IO`                                      | The I/O mode. Must be 10                 | `10`                                  |
| `LCD_I2C_Address_1`                           | Address of I2C adapter                   | Default `0x4E`                        |
| `LCD_I2C_Address_2`                           | Address of I2C adapter                   | Not set                               |
| `LCD_I2C_Address_3`                           | Address of I2C adapter                   | Not set                               |
| `LCD_I2C_Address_4`                           | Address of I2C adapter                   | Not set                               |

</div>

For code examples see
<a href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" class="link">I2C LCD Solutions</a>.

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_0" class="link" title="LCD_IO 0">LCD_IO 0</a>,
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2" class="link" title="LCD_IO 2">LCD_IO 2</a>,
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,
<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_12" class="link" title="LCD_IO 12">LCD_IO 12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 107</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_io_14_port_configuration.html" title="LCD_IO 14 Port Configuration"><link rel="next" href="_lcd_variant.html" title="LCD_VARIANT"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_107"></a>LCD_IO 107</h5></div></div></div><p><span class="strong"><strong>Using connection mode 107:</strong></span></p><p>The LCD is controlled via the serial port.
A type 107 is a K107 serial adapter.
To use mode 107 you must define the serial port as normal in your GCB code.
Then, serial speed to match the K107 adapter.</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>These constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set them, place a line in the
main program file that uses <code class="literal">#define</code> to assign a value to the particular
constant.</p><p>When using 107 mode only one constants must be set - all others can
be ignored.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_IO</code></p></td><td align="left" valign="top"><p>I/O mode</p></td><td align="left" valign="top"><p><code class="literal">107</code> or <code class="literal">K107</code></p></td></tr></tbody></table></div><p><span class="strong"><strong>Example Code:</strong></span></p><pre class="screen">    #chip 16f18313
    #option Explicit

    'Generated by PIC PPS Tool for GCBASIC
    'Generated for 16f18313
    '
    #startup InitPPS, 85
    #define PPSToolPart 16f18313

    Sub InitPPS

            'Module: EUSART
            RA5PPS = 0x0014    'TX &gt; RA5

    End Sub
    'Template comment at the end of the config file

    'USART settings for USART1
    #define USART_BAUD_RATE 115200
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF

    #define LCD_IO 107   'K107


    do Forever
      CLS
      Print "GCBASIC 2021"
      Locate 1, 0
      Print "Reading ADC ANA0"

      Locate 3, 0
      Print "Scaled = "
      Print Scale( ReadAD( ANA0 ), 0, 236, 0, 100 )
      wait 100 ms
    loop</pre><p>See the separate sections of the Help file for the specifics of each
Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_0.html" title="LCD_IO 0">LCD_IO 0</a>, <a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>, <a class="link" href="_lcd_io_2.html" title="LCD_IO 2">LCD_IO 2</a>
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>, <a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>, <a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_107"></span>LCD\_IO 107

</div>

</div>

</div>

<span class="strong">**Using connection mode 107:**</span>

The LCD is controlled via the serial port. A type 107 is a K107 serial
adapter. To use mode 107 you must define the serial port as normal in
your GCB code. Then, serial speed to match the K107 adapter.

<span class="strong">**Relevant Constants:**</span>

These constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set them, place a line in the
main program file that uses `#define` to assign a value to the
particular constant.

When using 107 mode only one constants must be set - all others can be
ignored.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Value**</span> |
|:----------------------------------------------|:-----------------------------------------|:--------------------------------------|
| `LCD_IO`                                      | I/O mode                                 | `107` or `K107`                       |

</div>

<span class="strong">**Example Code:**</span>

``` screen
    #chip 16f18313
    #option Explicit

    'Generated by PIC PPS Tool for GCBASIC
    'Generated for 16f18313
    '
    #startup InitPPS, 85
    #define PPSToolPart 16f18313

    Sub InitPPS

            'Module: EUSART
            RA5PPS = 0x0014    'TX > RA5

    End Sub
    'Template comment at the end of the config file

    'USART settings for USART1
    #define USART_BAUD_RATE 115200
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF

    #define LCD_IO 107   'K107


    do Forever
      CLS
      Print "GCBASIC 2021"
      Locate 1, 0
      Print "Reading ADC ANA0"

      Locate 3, 0
      Print "Scaled = "
      Print Scale( ReadAD( ANA0 ), 0, 236, 0, 100 )
      wait 100 ms
    loop
```

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_0" class="link" title="LCD_IO 0">LCD_IO 0</a>,
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2" class="link" title="LCD_IO 2">LCD_IO 2</a>
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,
<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 10 Example</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_examples.html" title="Examples"><link rel="prev" href="_lcd_io_8_example.html" title="LCD_IO 8 Example"><link rel="next" href="_pulse_width_modulation.html" title="Pulse width modulation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_10_example"></a>LCD_IO 10 Example</h5></div></div></div><p>This is an connection mode 10 I2C Driver to demonstrate LCD features. This for the 16F877A, but, it can easily be adapted for other microcontrollers.</p><p>A 2 by 16 LCD is assumed with the LCD being driven using an LCD I2C adapter.
Two types are supported the YwRobot LCD1602 IIC V1 / a Sainsmart LCD_PIC I2C adapter or the Ywmjkdz I2C adapter with pot bent over top of chip.</p><p>The demonstrates reading a DS18B20 and showing the results on the LCD.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #chip mega328p, 16
    #include &lt;DS18B20.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings - CHANGE PORTS
     #define I2C_MODE Master
     #define I2C_DATA PORTC.4
     #define I2C_CLOCK PORTC.5
     #define I2C_DISABLE_INTERRUPTS ON

    '''Set up LCD
     #define LCD_IO 10
     #define LCD_I2C_Address_1 0x4E                ; LCD 1
     #define LCD_I2C_Address_2 0x4C                ; LCD 2

    ; ----- Constants
    ' DS18B20 port settings - this is required
       #define DQ PortC.3

    ; ----- Quick Command Reference:

    '''Set LCD_10 to 10 for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter
    '''Set LCD_10 to 12 for the Ywmjkdz I2C adapter with pot bent over top of chip

    ; ----- Variables
    dim TempC_100 as word   ' a variabler to handle the temperature calculations
    dim DSdataRaw as Integer


    ; ----- Main body of program commences here.

    'Change to the correct LCD by setting     LCD_I2C_Address_Current to the correct address then write to LCD.
    LCD_I2C_Address_Current = LCD_I2C_Address_1: DisplayInformation ( 1 )
    LCD_I2C_Address_Current = LCD_I2C_Address_2: DisplayInformation ( 1 )
    wait 4 s
    LCD_I2C_Address_Current = LCD_I2C_Address_1:  CLS
    LCD_I2C_Address_Current = LCD_I2C_Address_2:  CLS

    ccount = 0
    Do forever

        ' The function readtemp12 returns the raw value of the sensor.
        ' The sensor is read as a 12 bit value therefore each unit equates to 0.0625 of a degree
        DSdataRaw = readtemp12    ; save to this variable to prevent the delay bewtween screen up dates
        ' The function readtemp returns the integer value of the sensor
        DSdata = readtemp

        LCD_I2C_Address_Current = LCD_I2C_Address_1: DisplayInformation ( 2 )  ; update LCD1
        LCD_I2C_Address_Current = LCD_I2C_Address_2: DisplayInformation ( 2 )  ; update LCD2
        DSdata = DSdataRaw ; Set the data
        LCD_I2C_Address_Current = LCD_I2C_Address_1: DisplayInformation ( 3 )  ; update LCD1
        DSdata= DSdataRaw ; Set the data
        LCD_I2C_Address_Current = LCD_I2C_Address_2: DisplayInformation ( 3 )  ; update LCD2

        ccount++

        wait 1 s

    loop
    End

    Sub DisplayInformation ( LCDCommand )

        Select case LCDCommand

        Case 1
          CLS
          print "GCBASIC 2021"
          locate 1,0
          print "DS18B20 Demo"

        Case 2
           ' Display the integer value of the sensor on the LCD
           locate 0,0
           print hex(ccount)
           print " Ceil"
           locate 0,8
           print DSdata
           print chr(223)+"C"+"  "

         Case 3

           ' Display the integer and decimal value of the sensor on the LCD

           SignBit = DSdata / 256 / 128
           If SignBit = 0 Then goto Positive
           ' its negative!
           DSdata = ( DSdata # 0xffff ) + 1 ' take twos comp

        Positive:

           ' Convert value * 0.0625. Mulitple value by 6 then add result to multiplication of the value with 25 then divide result by 100.
           TempC_100 =  DSdata * 6
           DSdata = ( DSdata * 25 ) / 100
           TempC_100 = TempC_100 + DSdata

           Whole = TempC_100 / 100
           Fract = TempC_100 % 100
           If SignBit = 0 Then goto DisplayTemp
           Print "-"

        DisplayTemp:
           locate 1,0
           print hex(ccount)
           print " Real"
           locate 1,8
           print str(Whole)
           print "."
          ' To ensure the decimal part is two digits
           Dig = Fract / 10
           print Dig
           Dig = Fract % 10
           print Dig
           print chr(223)
           print "C"+"  "

        End Select

    end sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_10_example"></span>LCD\_IO 10 Example

</div>

</div>

</div>

This is an connection mode 10 I2C Driver to demonstrate LCD features.
This for the 16F877A, but, it can easily be adapted for other
microcontrollers.

A 2 by 16 LCD is assumed with the LCD being driven using an LCD I2C
adapter. Two types are supported the YwRobot LCD1602 IIC V1 / a
Sainsmart LCD\_PIC I2C adapter or the Ywmjkdz I2C adapter with pot bent
over top of chip.

The demonstrates reading a DS18B20 and showing the results on the LCD.

<span class="strong">**Example:**</span>

``` screen
    #chip mega328p, 16
    #include <DS18B20.h>

    ; ----- Define Hardware settings
    ' Define I2C settings - CHANGE PORTS
     #define I2C_MODE Master
     #define I2C_DATA PORTC.4
     #define I2C_CLOCK PORTC.5
     #define I2C_DISABLE_INTERRUPTS ON

    '''Set up LCD
     #define LCD_IO 10
     #define LCD_I2C_Address_1 0x4E                ; LCD 1
     #define LCD_I2C_Address_2 0x4C                ; LCD 2

    ; ----- Constants
    ' DS18B20 port settings - this is required
       #define DQ PortC.3

    ; ----- Quick Command Reference:

    '''Set LCD_10 to 10 for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter
    '''Set LCD_10 to 12 for the Ywmjkdz I2C adapter with pot bent over top of chip

    ; ----- Variables
    dim TempC_100 as word   ' a variabler to handle the temperature calculations
    dim DSdataRaw as Integer


    ; ----- Main body of program commences here.

    'Change to the correct LCD by setting     LCD_I2C_Address_Current to the correct address then write to LCD.
    LCD_I2C_Address_Current = LCD_I2C_Address_1: DisplayInformation ( 1 )
    LCD_I2C_Address_Current = LCD_I2C_Address_2: DisplayInformation ( 1 )
    wait 4 s
    LCD_I2C_Address_Current = LCD_I2C_Address_1:  CLS
    LCD_I2C_Address_Current = LCD_I2C_Address_2:  CLS

    ccount = 0
    Do forever

        ' The function readtemp12 returns the raw value of the sensor.
        ' The sensor is read as a 12 bit value therefore each unit equates to 0.0625 of a degree
        DSdataRaw = readtemp12    ; save to this variable to prevent the delay bewtween screen up dates
        ' The function readtemp returns the integer value of the sensor
        DSdata = readtemp

        LCD_I2C_Address_Current = LCD_I2C_Address_1: DisplayInformation ( 2 )  ; update LCD1
        LCD_I2C_Address_Current = LCD_I2C_Address_2: DisplayInformation ( 2 )  ; update LCD2
        DSdata = DSdataRaw ; Set the data
        LCD_I2C_Address_Current = LCD_I2C_Address_1: DisplayInformation ( 3 )  ; update LCD1
        DSdata= DSdataRaw ; Set the data
        LCD_I2C_Address_Current = LCD_I2C_Address_2: DisplayInformation ( 3 )  ; update LCD2

        ccount++

        wait 1 s

    loop
    End

    Sub DisplayInformation ( LCDCommand )

        Select case LCDCommand

        Case 1
          CLS
          print "GCBASIC 2021"
          locate 1,0
          print "DS18B20 Demo"

        Case 2
           ' Display the integer value of the sensor on the LCD
           locate 0,0
           print hex(ccount)
           print " Ceil"
           locate 0,8
           print DSdata
           print chr(223)+"C"+"  "

         Case 3

           ' Display the integer and decimal value of the sensor on the LCD

           SignBit = DSdata / 256 / 128
           If SignBit = 0 Then goto Positive
           ' its negative!
           DSdata = ( DSdata # 0xffff ) + 1 ' take twos comp

        Positive:

           ' Convert value * 0.0625. Mulitple value by 6 then add result to multiplication of the value with 25 then divide result by 100.
           TempC_100 =  DSdata * 6
           DSdata = ( DSdata * 25 ) / 100
           TempC_100 = TempC_100 + DSdata

           Whole = TempC_100 / 100
           Fract = TempC_100 % 100
           If SignBit = 0 Then goto DisplayTemp
           Print "-"

        DisplayTemp:
           locate 1,0
           print hex(ccount)
           print " Real"
           locate 1,8
           print str(Whole)
           print "."
          ' To ensure the decimal part is two digits
           Dig = Fract / 10
           print Dig
           Dig = Fract % 10
           print Dig
           print chr(223)
           print "C"+"  "

        End Select

    end sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 10 Port Configuration</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_io_10.html" title="LCD_IO 10"><link rel="prev" href="_lcd_io_10.html" title="LCD_IO 10"><link rel="next" href="_lcd_io_12.html" title="LCD_IO 12"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_lcd_io_10_port_configuration"></a>LCD_IO 10 Port Configuration</h6></div></div></div><p><span class="strong"><strong>Using mode 10</strong></span></p><p>When using I2C LCD mode 10 the target I2C device address is setup as
shown below. Each bit of the the variable i2c_lcd_byte is defined to
address the correct LCD display port.</p><pre class="screen">    i2c_lcd_e = i2c_lcd_byte.2
    i2c_lcd_rw = i2c_lcd_byte.1
    i2c_lcd_rs = i2c_lcd_byte.0
    i2c_lcd_bl = i2c_lcd_byte.3
    i2c_lcd_d4 = i2c_lcd_byte.4
    i2c_lcd_d5 = i2c_lcd_byte.5
    i2c_lcd_d6 = i2c_lcd_byte.6
    i2c_lcd_d7 = i2c_lcd_byte.7</pre><p>If you have an I2C LCD display adapter with a different set of
connection of the adapter then change this configuration to suit the
specific of the adapter as follows. This should be done in the your main
program code.</p><pre class="screen">    #define i2c_lcd_e i2c_lcd_byte.1
    #define i2c_lcd_rw i2c_lcd_byte.2
    #define i2c_lcd_rs i2c_lcd_byte.0
    #define i2c_lcd_bl i2c_lcd_byte.3
    #define i2c_lcd_d4 i2c_lcd_byte.7
    #define i2c_lcd_d5 i2c_lcd_byte.6
    #define i2c_lcd_d6 i2c_lcd_byte.5
    #define i2c_lcd_d7 i2c_lcd_byte.4</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="lcd_io_10_port_configuration"></span>LCD\_IO 10 Port Configuration

</div>

</div>

</div>

<span class="strong">**Using mode 10**</span>

When using I2C LCD mode 10 the target I2C device address is setup as
shown below. Each bit of the the variable i2c\_lcd\_byte is defined to
address the correct LCD display port.

``` screen
    i2c_lcd_e = i2c_lcd_byte.2
    i2c_lcd_rw = i2c_lcd_byte.1
    i2c_lcd_rs = i2c_lcd_byte.0
    i2c_lcd_bl = i2c_lcd_byte.3
    i2c_lcd_d4 = i2c_lcd_byte.4
    i2c_lcd_d5 = i2c_lcd_byte.5
    i2c_lcd_d6 = i2c_lcd_byte.6
    i2c_lcd_d7 = i2c_lcd_byte.7
```

If you have an I2C LCD display adapter with a different set of
connection of the adapter then change this configuration to suit the
specific of the adapter as follows. This should be done in the your main
program code.

``` screen
    #define i2c_lcd_e i2c_lcd_byte.1
    #define i2c_lcd_rw i2c_lcd_byte.2
    #define i2c_lcd_rs i2c_lcd_byte.0
    #define i2c_lcd_bl i2c_lcd_byte.3
    #define i2c_lcd_d4 i2c_lcd_byte.7
    #define i2c_lcd_d5 i2c_lcd_byte.6
    #define i2c_lcd_d6 i2c_lcd_byte.5
    #define i2c_lcd_d7 i2c_lcd_byte.4
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 12</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_io_10_port_configuration.html" title="LCD_IO 10 Port Configuration"><link rel="next" href="_lcd_io_12_port_configuration.html" title="LCD_IO 12 Port Configuration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_12"></a>LCD_IO 12</h5></div></div></div><p><span class="strong"><strong>Using connection mode 12:</strong></span></p><p>The LCD is controlled via I2C.
A type 12 is the Ywmjkdz I2C adapter with potentiometer  variable resistor) bent over top of chip.
To use mode 12 you must define the I2C ports as normal in your GCB code.
Then, define the LCD type, set the I2C_address of the LCD adapter and the LCD speed, if required.</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>These constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set them, place a line in the
main program file that uses <code class="literal">#define</code> to assign a value to the particular
constant.</p><p>When using 2-bit mode only three constants must be set - all others can
be ignored.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_IO</code></p></td><td align="left" valign="top"><p>I/O mode</p></td><td align="left" valign="top"><p><code class="literal">12</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_I2C_Address_1</code></p></td><td align="left" valign="top"><p>Address of I2C adapter</p></td><td align="left" valign="top"><p>Default <code class="literal">0x4E</code><br>
 could also be <code class="literal">0x27</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_I2C_Address_2</code></p></td><td align="left" valign="top"><p>Address of I2C adapter</p></td><td align="left" valign="top"><p>Not set</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_I2C_Address_2</code></p></td><td align="left" valign="top"><p>Address of I2C adapter</p></td><td align="left" valign="top"><p>Not set</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_I2C_Address_2</code></p></td><td align="left" valign="top"><p>Address of I2C adapter</p></td><td align="left" valign="top"><p>Not set</p></td></tr></tbody></table></div><p>To set the correct address see the picture below:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/lcd_io12b1.JPG" align="middle" alt="graphic"></div></div><p>For code examples see <a class="link" href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" target="_top">I2C LCD Solutions</a>.</p><p>See the separate sections of the Help file for the specifics of each
Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_0.html" title="LCD_IO 0">LCD_IO 0</a>, <a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>, <a class="link" href="_lcd_io_2.html" title="LCD_IO 2">LCD_IO 2</a>
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>, <a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>, <a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_12"></span>LCD\_IO 12

</div>

</div>

</div>

<span class="strong">**Using connection mode 12:**</span>

The LCD is controlled via I2C. A type 12 is the Ywmjkdz I2C adapter with
potentiometer variable resistor) bent over top of chip. To use mode 12
you must define the I2C ports as normal in your GCB code. Then, define
the LCD type, set the I2C\_address of the LCD adapter and the LCD speed,
if required.

<span class="strong">**Relevant Constants:**</span>

These constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set them, place a line in the
main program file that uses `#define` to assign a value to the
particular constant.

When using 2-bit mode only three constants must be set - all others can
be ignored.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constant Name</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LCD_IO</code></p></td>
<td style="text-align: left;"><p>I/O mode</p></td>
<td style="text-align: left;"><p><code class="literal">12</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">LCD_I2C_Address_1</code></p></td>
<td style="text-align: left;"><p>Address of I2C adapter</p></td>
<td style="text-align: left;"><p>Default <code class="literal">0x4E</code><br />
could also be <code class="literal">0x27</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LCD_I2C_Address_2</code></p></td>
<td style="text-align: left;"><p>Address of I2C adapter</p></td>
<td style="text-align: left;"><p>Not set</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">LCD_I2C_Address_2</code></p></td>
<td style="text-align: left;"><p>Address of I2C adapter</p></td>
<td style="text-align: left;"><p>Not set</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LCD_I2C_Address_2</code></p></td>
<td style="text-align: left;"><p>Address of I2C adapter</p></td>
<td style="text-align: left;"><p>Not set</p></td>
</tr>
</tbody>
</table>

</div>

To set the correct address see the picture below:

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/lcd_io12b1.JPG)

</div>

</div>

For code examples see
<a href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" class="link">I2C LCD Solutions</a>.

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_0" class="link" title="LCD_IO 0">LCD_IO 0</a>,
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2" class="link" title="LCD_IO 2">LCD_IO 2</a>
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,
<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 12 Port Configuration</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_io_12.html" title="LCD_IO 12"><link rel="prev" href="_lcd_io_12.html" title="LCD_IO 12"><link rel="next" href="_lcd_io_14.html" title="LCD_IO 14"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_lcd_io_12_port_configuration"></a>LCD_IO 12 Port Configuration</h6></div></div></div><p><span class="strong"><strong>Using mode 12:</strong></span></p><p>When using I2C LCD mode 12 the target I2C device address is setup as
shown below. Each bit of the the variable <code class="literal">i2c_lcd_byte</code> is defined to
address the correct LCD display port.</p><pre class="screen">    i2c_lcd_e = i2c_lcd_byte.4
    i2c_lcd_rw = i2c_lcd_byte.5
    i2c_lcd_rs = i2c_lcd_byte.6
    i2c_lcd_bl = i2c_lcd_byte.7
    i2c_lcd_d4 = i2c_lcd_byte.0
    i2c_lcd_d5 = i2c_lcd_byte.1
    i2c_lcd_d6 = i2c_lcd_byte.2
    i2c_lcd_d7 = i2c_lcd_byte.3</pre><p>If you have an I2C LCD display adapter with a different set of
connection of the adapter then change this configuration to suit the
specific of the adapter as follows. This should be done in the your main
program code.</p><pre class="screen">    #define i2c_lcd_e i2c_lcd_byte.4
    #define i2c_lcd_rw i2c_lcd_byte.5
    #define i2c_lcd_rs i2c_lcd_byte.6
    #define i2c_lcd_bl i2c_lcd_byte.7
    #define i2c_lcd_d4 i2c_lcd_byte.3
    #define i2c_lcd_d5 i2c_lcd_byte.2
    #define i2c_lcd_d6 i2c_lcd_byte.1
    #define i2c_lcd_d7 i2c_lcd_byte.0</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="lcd_io_12_port_configuration"></span>LCD\_IO 12 Port Configuration

</div>

</div>

</div>

<span class="strong">**Using mode 12:**</span>

When using I2C LCD mode 12 the target I2C device address is setup as
shown below. Each bit of the the variable `i2c_lcd_byte` is defined to
address the correct LCD display port.

``` screen
    i2c_lcd_e = i2c_lcd_byte.4
    i2c_lcd_rw = i2c_lcd_byte.5
    i2c_lcd_rs = i2c_lcd_byte.6
    i2c_lcd_bl = i2c_lcd_byte.7
    i2c_lcd_d4 = i2c_lcd_byte.0
    i2c_lcd_d5 = i2c_lcd_byte.1
    i2c_lcd_d6 = i2c_lcd_byte.2
    i2c_lcd_d7 = i2c_lcd_byte.3
```

If you have an I2C LCD display adapter with a different set of
connection of the adapter then change this configuration to suit the
specific of the adapter as follows. This should be done in the your main
program code.

``` screen
    #define i2c_lcd_e i2c_lcd_byte.4
    #define i2c_lcd_rw i2c_lcd_byte.5
    #define i2c_lcd_rs i2c_lcd_byte.6
    #define i2c_lcd_bl i2c_lcd_byte.7
    #define i2c_lcd_d4 i2c_lcd_byte.3
    #define i2c_lcd_d5 i2c_lcd_byte.2
    #define i2c_lcd_d6 i2c_lcd_byte.1
    #define i2c_lcd_d7 i2c_lcd_byte.0
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 14</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_io_12_port_configuration.html" title="LCD_IO 12 Port Configuration"><link rel="next" href="_lcd_io_14_port_configuration.html" title="LCD_IO 14 Port Configuration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_14"></a>LCD_IO 14</h5></div></div></div><p><span class="strong"><strong>Using connection mode 14:</strong></span></p><p>Using this LCD IO methof the LCD is controlled via an SPI expander.</p><p>To use mode 14 you must define the SPI ports as normal in your GCB code.
Then, define the LCD type, set the SPI address of the SPI expander, and, the LCD speed, if required.</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/lcd_io_14_1.png" align="middle" alt="graphic"></div></div><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>These constants are used to control settings for the LCD routines included with GCBASIC.&nbsp;&nbsp; To set them, place a line in the main program file that uses <code class="literal">#define</code> to assign a value to the particular constant.</p><p>When using this mode only three constants are mandated - all others can be ignored.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_IO</code></p></td><td align="left" valign="top"><p>I/O mode</p></td><td align="left" valign="top"><p><code class="literal">14</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_SPI_DO</code></p></td><td align="left" valign="top"><p>Microcontroller SPI data out port</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_SPI_SCK</code></p></td><td align="left" valign="top"><p>Microcontroller SPI clock out port</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_SPI_CS</code></p></td><td align="left" valign="top"><p>Microcontroller SPI chip select port</p></td><td align="left" valign="top"><p>Required</p></td></tr></tbody></table></div><p><span class="strong"><strong>Connectivity</strong></span></p><p>The connectivity is shown below.&nbsp;&nbsp;The microcontroller connections are as shown below.&nbsp;&nbsp;This is an example using the Microchip Explorer 8 board.</p><pre class="screen">    RC3 &gt; Expander SPI SCK ( clock)
    RC5 &gt; Expander SPI SI (slave in)
    RA2 &gt; Expander SPI CS ( chip select) - could be set to 0v0
    RB5 &gt; Expander Reset ( optional)</pre><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/lcd_io_14_2.png" align="middle" alt="graphic"></div></div><p><span class="strong"><strong>Optional configuration</strong></span></p><p>There are some options you can tweak. See the example setup below. You can play with the use of hardware or software SPI, SPI frequency ( HWSPIMODE MASTERFAST). LED speed, the connectivity between the expander and the LCD and otheroptions.</p><pre class="screen">        //Constants - LCD connectivity type; controls whether to use HW SPI; The inter character delay
        #define LCD_IO 14
        #define LCD_HARDWARESPI
        #define LCD_SPEED FAST
        #define HWSPIMODE MASTERFAST

        //These are the phyiscal connections from the expander to the LCD.  These are automatically set in the library and are shown here purely for clarity.
        #define     LCD_SPI_EXPD_ADDRESS        0x40     // address of the expander
        #define LCD_SPI_EXPANDER_E_ADDRESS      0x40     // GPA6 on the expander
        #define LCD_SPI_EXPANDER_RS_ADDRESS     0x80     // GPA7 on the expander

        //Pin mappings for LCD IO SPI Expander
        #define LCD_SPI_DO          portc.5             // constant is mandated
        #define LCD_SPI_SCK         portc.3             // constant is mandated
        #define LCD_SPI_CS          porta.2             // constant is required.
        // Optional(s) reset Port.Pin connection to expander, select one.
            // #define LCD_SPI_RESET_IN       portb.5
            #define LCD_SPI_RESET_OUT      portb.5</pre><p>For code examples see <a class="link" href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" target="_top">LCD Solutions</a>.</p><p>See the separate sections of the Help file for the specifics of each
Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_0.html" title="LCD_IO 0">LCD_IO 0</a>, <a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>, <a class="link" href="_lcd_io_2.html" title="LCD_IO 2">LCD_IO 2</a>
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>, <a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>, <a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a>, <a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_14"></span>LCD\_IO 14

</div>

</div>

</div>

<span class="strong">**Using connection mode 14:**</span>

Using this LCD IO methof the LCD is controlled via an SPI expander.

To use mode 14 you must define the SPI ports as normal in your GCB code.
Then, define the LCD type, set the SPI address of the SPI expander, and,
the LCD speed, if required.

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/lcd_io_14_1.png)

</div>

</div>

<span class="strong">**Relevant Constants:**</span>

These constants are used to control settings for the LCD routines
included with GCBASIC.   To set them, place a line in the main program
file that uses `#define` to assign a value to the particular constant.

When using this mode only three constants are mandated - all others can
be ignored.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Value**</span> |
|:----------------------------------------------|:-----------------------------------------|:--------------------------------------|
| `LCD_IO`                                      | I/O mode                                 | `14`                                  |
| `LCD_SPI_DO`                                  | Microcontroller SPI data out port        | Required                              |
| `LCD_SPI_SCK`                                 | Microcontroller SPI clock out port       | Required                              |
| `LCD_SPI_CS`                                  | Microcontroller SPI chip select port     | Required                              |

</div>

<span class="strong">**Connectivity**</span>

The connectivity is shown below.  The microcontroller connections are as
shown below.  This is an example using the Microchip Explorer 8 board.

``` screen
    RC3 > Expander SPI SCK ( clock)
    RC5 > Expander SPI SI (slave in)
    RA2 > Expander SPI CS ( chip select) - could be set to 0v0
    RB5 > Expander Reset ( optional)
```

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/lcd_io_14_2.png)

</div>

</div>

<span class="strong">**Optional configuration**</span>

There are some options you can tweak. See the example setup below. You
can play with the use of hardware or software SPI, SPI frequency (
HWSPIMODE MASTERFAST). LED speed, the connectivity between the expander
and the LCD and otheroptions.

``` screen
        //Constants - LCD connectivity type; controls whether to use HW SPI; The inter character delay
        #define LCD_IO 14
        #define LCD_HARDWARESPI
        #define LCD_SPEED FAST
        #define HWSPIMODE MASTERFAST

        //These are the phyiscal connections from the expander to the LCD.  These are automatically set in the library and are shown here purely for clarity.
        #define     LCD_SPI_EXPD_ADDRESS        0x40     // address of the expander
        #define LCD_SPI_EXPANDER_E_ADDRESS      0x40     // GPA6 on the expander
        #define LCD_SPI_EXPANDER_RS_ADDRESS     0x80     // GPA7 on the expander

        //Pin mappings for LCD IO SPI Expander
        #define LCD_SPI_DO          portc.5             // constant is mandated
        #define LCD_SPI_SCK         portc.3             // constant is mandated
        #define LCD_SPI_CS          porta.2             // constant is required.
        // Optional(s) reset Port.Pin connection to expander, select one.
            // #define LCD_SPI_RESET_IN       portb.5
            #define LCD_SPI_RESET_OUT      portb.5
```

For code examples see
<a href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" class="link">LCD Solutions</a>.

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_0" class="link" title="LCD_IO 0">LCD_IO 0</a>,
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2" class="link" title="LCD_IO 2">LCD_IO 2</a>
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,
<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 14 Port Configuration</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_io_14.html" title="LCD_IO 14"><link rel="prev" href="_lcd_io_14.html" title="LCD_IO 14"><link rel="next" href="_lcd_io_107.html" title="LCD_IO 107"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_lcd_io_14_port_configuration"></a>LCD_IO 14 Port Configuration</h6></div></div></div><p><span class="strong"><strong>Using mode 14:</strong></span></p><p>When using LCD mode 14 this is an example program to show a working solution,</p><pre class="screen">        #chip 18F67K40, 8
        #option explicit

            'PPS Tool version: 0.0.6.3
            // Generated for 18f67k40

            #startup InitPPS, 85
            #define PPSToolPart 18f67k40

            Sub InitPPS

                    #ifdef LCD_HARDWARESPI
                        SSP1CLKPPS = 0x13;   //RC3-&gt;MSSP1:SCK1;
                        RC3PPS = 0x19;   //RC3-&gt;MSSP1:SCK1;
                        RC5PPS = 0x1A;   //RC5-&gt;MSSP1:SDO1;
                        SSP1DATPPS = 0x14;   //RC4-&gt;MSSP1:SDI1;
                    #endif

                End Sub

            //Constants - LCD connectivity type
            #define LCD_IO 14

            //Comment out to use software SPI
            #define LCD_HARDWARESPI

            #define LCD_SPEED FAST

            //Optional. Can also select MASTERSLOW or MASTER.  The compiler will set automatically.
            #define HWSPIMODE MASTERFAST

            //These are phyiscal connections from the expander to the LCD.  These are automatically set in the library and are shown here purely for clarity.
                #define     LCD_SPI_EXPD_ADDRESS        0x40
                #define LCD_SPI_EXPANDER_E_ADDRESS      0x40     // GPA6 on the expander
                #define LCD_SPI_EXPANDER_RS_ADDRESS     0x80     // GPA7 on the expander

            //Mandated Pin mappings for LCD IO SPI Expander
            #define LCD_SPI_DO          portc.5
            #define LCD_SPI_SCK         portc.3
            #define LCD_SPI_CS          porta.2
            // Optional(s) reset Port.Pin connection to expander, select one.
                // #define LCD_SPI_RESET_IN       portb.5
                #define LCD_SPI_RESET_OUT      portb.5


        ; ----- Main body of program commences here.

        ClS
        Print "Hello World"</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="lcd_io_14_port_configuration"></span>LCD\_IO 14 Port Configuration

</div>

</div>

</div>

<span class="strong">**Using mode 14:**</span>

When using LCD mode 14 this is an example program to show a working
solution,

``` screen
        #chip 18F67K40, 8
        #option explicit

            'PPS Tool version: 0.0.6.3
            // Generated for 18f67k40

            #startup InitPPS, 85
            #define PPSToolPart 18f67k40

            Sub InitPPS

                    #ifdef LCD_HARDWARESPI
                        SSP1CLKPPS = 0x13;   //RC3->MSSP1:SCK1;
                        RC3PPS = 0x19;   //RC3->MSSP1:SCK1;
                        RC5PPS = 0x1A;   //RC5->MSSP1:SDO1;
                        SSP1DATPPS = 0x14;   //RC4->MSSP1:SDI1;
                    #endif

                End Sub

            //Constants - LCD connectivity type
            #define LCD_IO 14

            //Comment out to use software SPI
            #define LCD_HARDWARESPI

            #define LCD_SPEED FAST

            //Optional. Can also select MASTERSLOW or MASTER.  The compiler will set automatically.
            #define HWSPIMODE MASTERFAST

            //These are phyiscal connections from the expander to the LCD.  These are automatically set in the library and are shown here purely for clarity.
                #define     LCD_SPI_EXPD_ADDRESS        0x40
                #define LCD_SPI_EXPANDER_E_ADDRESS      0x40     // GPA6 on the expander
                #define LCD_SPI_EXPANDER_RS_ADDRESS     0x80     // GPA7 on the expander

            //Mandated Pin mappings for LCD IO SPI Expander
            #define LCD_SPI_DO          portc.5
            #define LCD_SPI_SCK         portc.3
            #define LCD_SPI_CS          porta.2
            // Optional(s) reset Port.Pin connection to expander, select one.
                // #define LCD_SPI_RESET_IN       portb.5
                #define LCD_SPI_RESET_OUT      portb.5


        ; ----- Main body of program commences here.

        ClS
        Print "Hello World"
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 2</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164"><link rel="next" href="_lcd_io_3.html" title="LCD_IO 3"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_2"></a>LCD_IO 2</h5></div></div></div><p><span class="strong"><strong>Using connection mode 2:</strong></span></p><p>This method uses a Data and a Clock line via a shift register to control the LCD display.
This method is used when the LCD is connected through a shift register IC either using a 74HC164 or a 74LS174, as detailed at <a class="link" href="http://gcbasic.sourceforge.net/library/DIAGRAMS/2-Wire%20LCD/" target="_top">here</a>.
This connection method is also called a 2-wire connection.</p><p>This is a <span class="strong"><strong>deprecated</strong></span> method mode to connect an LCD display to a microcontroller via a shift registry either a 74LS174 (or a 74LS164 with diode connected to pin 11).   This method does not support backlight control and has no additional input/output pin.</p><p>If you have used the 2-wire mode prior to August 2015, please choose this method for your existing code.</p><p>See <a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2 74xx164</a> for the preferred method to connect an LCD display to a microcomputer via a shift register.</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>Specific constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC. To set these constants the main program should specific constants to support the connection mode using #define.
When using 2-bit mode only three constants must be set - all others are optional or can be ignored.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_IO</code></p></td><td align="left" valign="top"><p>The I/O mode.</p></td><td align="left" valign="top"><p><code class="literal">2</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_DB</code></p></td><td align="left" valign="top"><p>The data pin used in 2-bit mode.</p></td><td align="left" valign="top"><p><span class="strong"><strong>Mandated</strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_CB</code></p></td><td align="left" valign="top"><p>The clock pin used in 2- bit mode.</p></td><td align="left" valign="top"><p><span class="strong"><strong>Mandated</strong></span></p></td></tr></tbody></table></div><p>For a code example download <a class="link" href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/" target="_top">Two Wire LCD Example</a>.</p><p>See for further code examples see <a class="link" href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" target="_top">Two Wire LCD Solutions</a>.</p><p>See the separate sections of the Help file for the specifics of each
Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_0.html" title="LCD_IO 0">LCD_IO 0</a>, <a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>,
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>, <a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>, <a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a> or <a class="link" href="_lcd_io_12.html" title="LCD_IO 12">LCD_IO 12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_2"></span>LCD\_IO 2

</div>

</div>

</div>

<span class="strong">**Using connection mode 2:**</span>

This method uses a Data and a Clock line via a shift register to control
the LCD display. This method is used when the LCD is connected through a
shift register IC either using a 74HC164 or a 74LS174, as detailed at
<a href="http://gcbasic.sourceforge.net/library/DIAGRAMS/2-Wire%20LCD/" class="link">here</a>.
This connection method is also called a 2-wire connection.

This is a <span class="strong">**deprecated**</span> method mode to
connect an LCD display to a microcontroller via a shift registry either
a 74LS174 (or a 74LS164 with diode connected to pin 11). This method
does not support backlight control and has no additional input/output
pin.

If you have used the 2-wire mode prior to August 2015, please choose
this method for your existing code.

See
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2 74xx164</a>
for the preferred method to connect an LCD display to a microcomputer
via a shift register.

<span class="strong">**Relevant Constants:**</span>

Specific constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set these constants the main
program should specific constants to support the connection mode using
\#define. When using 2-bit mode only three constants must be set - all
others are optional or can be ignored.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Default Value**</span> |
|:----------------------------------------------|:-----------------------------------------|:----------------------------------------------|
| `LCD_IO`                                      | The I/O mode.                            | `2`                                           |
| `LCD_DB`                                      | The data pin used in 2-bit mode.         | <span class="strong">**Mandated**</span>      |
| `LCD_CB`                                      | The clock pin used in 2- bit mode.       | <span class="strong">**Mandated**</span>      |

</div>

For a code example download
<a href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/" class="link">Two Wire LCD Example</a>.

See for further code examples see
<a href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" class="link">Two Wire LCD Solutions</a>.

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_0" class="link" title="LCD_IO 0">LCD_IO 0</a>,
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,
<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>
or
<a href="lcd_io_12" class="link" title="LCD_IO 12">LCD_IO 12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 2_74xx164</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_io_1.html" title="LCD_IO 1"><link rel="next" href="_lcd_io_2.html" title="LCD_IO 2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_2_74xx164"></a>LCD_IO 2_74xx164</h5></div></div></div><p><span class="strong"><strong>Using connection mode 2_74XX164:</strong></span></p><p>Use a Data and a Clock line. This manner is used when the LCD is
connected through a  shift register IC either using a 74HC164 or a 74LS164,
as detailed at <a class="link" href="http://gcbasic.sourceforge.net/library/DIAGRAMS/2-Wire%20LCD/" target="_top">here</a>.
This connection method is also called a 2-wire connection.</p><p>This is the preferred two wire method to connect via a shift register to an LCD display.</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>Specific constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC.  To set these constants the main program should specific constants to support the connection mode using #define.</p><p>When using connection mode 2_74XX164 only three constants must be set - all others are optional or can be ignored.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_IO</code></p></td><td align="left" valign="top"><p>The I/O mode.</p></td><td align="left" valign="top"><p><code class="literal">2</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_DB</code></p></td><td align="left" valign="top"><p>The data pin used in 2-bit mode.</p></td><td align="left" valign="top"><p><span class="strong"><strong>Mandated</strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_CB</code></p></td><td align="left" valign="top"><p>The clock pin used in 2- bit mode.</p></td><td align="left" valign="top"><p><span class="strong"><strong>Mandated</strong></span></p></td></tr></tbody></table></div><p>LCD.h supports in connection mode 2_74XX164 via the control of pin 11 of the 74HC164 / 74LS164 the background led/backlight.</p><p>How to connect and control the LCD background led: see <a class="link" href="http://gcbasic.sourceforge.net/help/_lcdbacklight.html" target="_top">http://gcbasic.sourceforge.net/help/_lcdbacklight.html</a></p><p>For a code example download <a class="link" href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%202.gcb" target="_top">Two Wire LCD Example</a>.</p><p>See for further code examples see <a class="link" href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" target="_top">Two Wire LCD Solutions</a>.</p><p>See the separate sections of the Help file for the specifics of each Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_0.html" title="LCD_IO 0">LCD_IO 0</a>, <a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>, <a class="link" href="_lcd_io_2.html" title="LCD_IO 2">LCD_IO 2</a>,
<a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO 2_74xx74</a>,
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>, <a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a> or <a class="link" href="_lcd_io_12.html" title="LCD_IO 12">LCD_IO 12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_2_74xx164"></span>LCD\_IO 2\_74xx164

</div>

</div>

</div>

<span class="strong">**Using connection mode 2\_74XX164:**</span>

Use a Data and a Clock line. This manner is used when the LCD is
connected through a shift register IC either using a 74HC164 or a
74LS164, as detailed at
<a href="http://gcbasic.sourceforge.net/library/DIAGRAMS/2-Wire%20LCD/" class="link">here</a>.
This connection method is also called a 2-wire connection.

This is the preferred two wire method to connect via a shift register to
an LCD display.

<span class="strong">**Relevant Constants:**</span>

Specific constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set these constants the main
program should specific constants to support the connection mode using
\#define.

When using connection mode 2\_74XX164 only three constants must be set -
all others are optional or can be ignored.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Default Value**</span> |
|:----------------------------------------------|:-----------------------------------------|:----------------------------------------------|
| `LCD_IO`                                      | The I/O mode.                            | `2`                                           |
| `LCD_DB`                                      | The data pin used in 2-bit mode.         | <span class="strong">**Mandated**</span>      |
| `LCD_CB`                                      | The clock pin used in 2- bit mode.       | <span class="strong">**Mandated**</span>      |

</div>

LCD.h supports in connection mode 2\_74XX164 via the control of pin 11
of the 74HC164 / 74LS164 the background led/backlight.

How to connect and control the LCD background led: see
<http://gcbasic.sourceforge.net/help/_lcdbacklight>

For a code example download
<a href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%202.gcb" class="link">Two Wire LCD Example</a>.

See for further code examples see
<a href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" class="link">Two Wire LCD Solutions</a>.

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_0" class="link" title="LCD_IO 0">LCD_IO 0</a>,
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2" class="link" title="LCD_IO 2">LCD_IO 2</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO 2_74xx74</a>,
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,
<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>
or
<a href="lcd_io_12" class="link" title="LCD_IO 12">LCD_IO 12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 2_74xx174</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_io_3.html" title="LCD_IO 3"><link rel="next" href="_lcd_io_4.html" title="LCD_IO 4"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_2_74xx174"></a>LCD_IO 2_74xx174</h5></div></div></div><p>LCD_IO 2_74xx174 has been deprecated as preferred method mode to connect an
LCD display to a microcontroller via a shift register either a 74LS174 (or a 74LS164 with
diode connected to pin 11). This method does not support backlight control and has no additional input/output pin.</p><p>See <a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>  for the preferred method to connect
an LCD display to a microcontroller via a shift register.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>, <a class="link" href="_lcd_io_2.html" title="LCD_IO 2">LCD_IO 2</a>,
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>, <a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a> or <a class="link" href="_lcd_io_12.html" title="LCD_IO 12">LCD_IO 12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_2_74xx174"></span>LCD\_IO 2\_74xx174

</div>

</div>

</div>

LCD\_IO 2\_74xx174 has been deprecated as preferred method mode to
connect an LCD display to a microcontroller via a shift register either
a 74LS174 (or a 74LS164 with diode connected to pin 11). This method
does not support backlight control and has no additional input/output
pin.

See
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>
for the preferred method to connect an LCD display to a microcontroller
via a shift register.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2" class="link" title="LCD_IO 2">LCD_IO 2</a>,
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,
<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>
or
<a href="lcd_io_12" class="link" title="LCD_IO 12">LCD_IO 12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 2 Example</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_examples.html" title="Examples"><link rel="prev" href="_examples.html" title="Examples"><link rel="next" href="_lcd_io_4_example.html" title="LCD_IO 4 Example"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_2_example"></a>LCD_IO 2 Example</h5></div></div></div><p>This a connection mode 2 Serial Driver to demonstrate LCD features. This for the 16F877A, but, it can easily be adapted for other microcontrollers.</p><p>A 2 by 16 LCD is assumed.</p><p>Based on the works by Thomas Henry and then revised Evan R. Venn</p><pre class="screen">    #chip 16F877A,20

    #define LCD_IO 2
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB portb.2
    #define LCD_CB portb.0
    #define LCD_NO_RW
                ;Here are various LCD commands which can be used.
                ;These are the LCD commands for the HD44780 controller

    #define clrHome = 1     ;clear the display, home the cursor
    #define home    = 2     ;home the cursor only
    #define RtoL    = 4     ;print characters right to left
    #define insR    = 5     ;insert characters to right
    #define LtoR    = 6     ;print characters left to right
    #define insL    = 7     ;insert characters to left
    #define lcdOff  = 8     ;LCD screen off
    #define lcdOn   = 12    ;LCD screen on, no cursor
    #define curOff  = 12    ;an alias for the above
    #define block   = 13    ;LCD screen on, block cursor
    #define under   = 14    ;LCD screen on, underline cursor
    #define undblk  = 15    ;LCD screen on, blinking and underline cursor
    #define CLeft   = 16    ;cursor left
    #define CRight  = 20    ;cursor right
    #define panR    = 24    ;pan viewing window right
    #define panL    = 28    ;pan viewing window left
    #define bus4    = 32    ;4-bit data bus mode
    #define bus8    = 48    ;8-bit data bus mode
    #define mode1   = 32    ;one-line mode (alias)
    #define mode2   = 40    ;two-line mode
    #define line1   = 128   ;go to start of line 1
    #define line2   = 192   ;go to start of line 2
    ;----- Variables
    dim char, msn, lsn, index, ii as byte
    ;----- Main Program
    LoadEeprom              ;load the EEprom with strings

    do forever
          printMsg(0)             ;print first message
          wait 3 S                ;pause 3 seconds
          printMsg(2)             ;print next message
          wait 3 S                ;pause 3 seconds
          repeat 5                ;blink it five times
            LCDCmd(lcdOff)       ;display off
            wait 500 mS           ;pause
            LCDCmd(lcdOn)        ;display on
            wait 500 mS           ;pause
          end repeat
          wait 1 S                ;pause before next demo
          ;demonstrate panning
          printMsg(4)             ;print next message
          wait 3 S                ;pause 3 seconds
          repeat 16
            LCDCmd(panL)         ;pan left a step at a time
            wait 300 mS           ;slow down to avoid blur
          end repeat
          repeat 16
            LCDCmd(panR)         ;then pan right
            wait 300 mS
          end repeat
          wait 1 S                ;pause before next demo
                                  ;demonstrate moving the cursor
          printMsg(6)             ;print next message
          wait 3 S                ;pause 3 seconds
          doHome                  ;home cursor
          LCDCmd(under)          ;choose underline cursor
          for ii = 0 to 15         ;move cursor across first line
            LCDCmd(line1+i)
            wait 200 mS
          next i
          for ii = 0 to 15         ;move cursor across second line
            LCDCmd(line2+i)
            wait 200 mS
          next i
          for ii = 15 to 0 step -1 ;move cursor back over second line
            LCDCmd(line2+i)
            wait 200 mS
          next i
          for ii = 15 to 0 step -1 ;move cursor back over first line
            LCDCmd(line1+i)
            wait 200 mS
          next i
          wait 3 S
          ;demonstrate blinking block cursor
          printMsg(8)             ;print next message
          doHome                  ;home the cursor
          LCDCmd(block)          ;choose blinking block cursor
          wait 4 S                ;pause 4 seconds
          LCDCmd(mode1)          ;change to one long line mode
          doHome                  ;home the cursor again
          LCDCmd(curOff)         ;and disable it


          ;demonstrate scrolling a lengthy one-line marquee
          for ii = 0xd0 to 0xff    ;print next message - the remaining EEPROM
            EPread ii, char        ;fetch directly from eeprom
            print chr(char)
          next i
          wait 1 S
          doHome                  ;home cursor once more
          repeat 141              ;scroll message twice
            LCDCmd(panR)
            wait 250 mS
          end repeat
          wait 2 S
          LCDCmd(mode2)          ;change back to two line mode
          doClr                   ;clear the screen
          ;demonstrate all of the characters
          printMsg(11)             ;print next message
          for ii = 33 to 127       ;print first batch of ASCII characters
            LCDCmd(line1+12)     ;overwrite each character displayed
            print chr(ii)            ;this is the ASCII code
            wait 500 mS
          next i
          for ii = 161 to 255      ;print next batch of ASCII characters
            LCDCmd(line1+12)
            print chr(ii)
            wait 500 mS
          next i
          ;say good-bye
          LCDCmd(line2)
          printMsg(11)             ;print next message
          doHome                  ;home the cursor
    loop

    end

    ;----- Clear the screen
    sub doClr
        LCDCmd(clrHome)
        wait 5 mS                   ;this command takes extra time
    end sub

    ;----- Home the cursor
    sub doHome
        LCDCmd(home)
        wait 5 mS                   ;and so does this one
    end sub

    ;----- Print a message to the LCD
    ;The parameter 'row' points to the start of the string.
    sub printMsg(in row as byte, in Optional StringLength As Byte = 15)
        LCDCmd(line1)              ;get set for first line

        for ii = 0 to StringLength
          index = row*16+ii
          EPread index, char        ;fetch next character and
          print chr(char)             ;transmit to the LCD
        next
        LCDCmd(line2)              ;get set for second line
        for ii = 0 to StringLength
          index = (row+1)*16+ii
          EPread index, char        ;fetch next character and
          print chr(char)             ;transmit to the LCD
        next
    end sub

    sub loadEeprom

        ' Strings for EEPROM, Strings should be limited to 16 characters for the first 13 sstrings, then a long string to fill eeprom
        location = 0
        WriteEeprom "First we'll show"
        WriteEeprom "this message.   "
        WriteEeprom "Then we'll blink"
        WriteEeprom "five times.     "
        WriteEeprom "Now lets pan    "
        WriteEeprom "left and right. "
        WriteEeprom "Watch the line  "
        WriteEeprom "cursor move.    "
        WriteEeprom "A block cursor  "
        WriteEeprom "is available.   "
        WriteEeprom "Characters:     "
        WriteEeprom "Bye!            "
        WriteEeprom "in one line mode"
        WriteEeprom "Next well scroll this long message as a marquee"

    end sub

    ; Write to the device eeprom
    sub WriteEeprom ( in Estring() ) as string * 64

        for ee = 1 to len ( Estring )
            HSersend Estring(ee)
            epwrite location, Estring(ee)
            location++
        next

    end sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_2_example"></span>LCD\_IO 2 Example

</div>

</div>

</div>

This a connection mode 2 Serial Driver to demonstrate LCD features. This
for the 16F877A, but, it can easily be adapted for other
microcontrollers.

A 2 by 16 LCD is assumed.

Based on the works by Thomas Henry and then revised Evan R. Venn

``` screen
    #chip 16F877A,20

    #define LCD_IO 2
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB portb.2
    #define LCD_CB portb.0
    #define LCD_NO_RW
                ;Here are various LCD commands which can be used.
                ;These are the LCD commands for the HD44780 controller

    #define clrHome = 1     ;clear the display, home the cursor
    #define home    = 2     ;home the cursor only
    #define RtoL    = 4     ;print characters right to left
    #define insR    = 5     ;insert characters to right
    #define LtoR    = 6     ;print characters left to right
    #define insL    = 7     ;insert characters to left
    #define lcdOff  = 8     ;LCD screen off
    #define lcdOn   = 12    ;LCD screen on, no cursor
    #define curOff  = 12    ;an alias for the above
    #define block   = 13    ;LCD screen on, block cursor
    #define under   = 14    ;LCD screen on, underline cursor
    #define undblk  = 15    ;LCD screen on, blinking and underline cursor
    #define CLeft   = 16    ;cursor left
    #define CRight  = 20    ;cursor right
    #define panR    = 24    ;pan viewing window right
    #define panL    = 28    ;pan viewing window left
    #define bus4    = 32    ;4-bit data bus mode
    #define bus8    = 48    ;8-bit data bus mode
    #define mode1   = 32    ;one-line mode (alias)
    #define mode2   = 40    ;two-line mode
    #define line1   = 128   ;go to start of line 1
    #define line2   = 192   ;go to start of line 2
    ;----- Variables
    dim char, msn, lsn, index, ii as byte
    ;----- Main Program
    LoadEeprom              ;load the EEprom with strings

    do forever
          printMsg(0)             ;print first message
          wait 3 S                ;pause 3 seconds
          printMsg(2)             ;print next message
          wait 3 S                ;pause 3 seconds
          repeat 5                ;blink it five times
            LCDCmd(lcdOff)       ;display off
            wait 500 mS           ;pause
            LCDCmd(lcdOn)        ;display on
            wait 500 mS           ;pause
          end repeat
          wait 1 S                ;pause before next demo
          ;demonstrate panning
          printMsg(4)             ;print next message
          wait 3 S                ;pause 3 seconds
          repeat 16
            LCDCmd(panL)         ;pan left a step at a time
            wait 300 mS           ;slow down to avoid blur
          end repeat
          repeat 16
            LCDCmd(panR)         ;then pan right
            wait 300 mS
          end repeat
          wait 1 S                ;pause before next demo
                                  ;demonstrate moving the cursor
          printMsg(6)             ;print next message
          wait 3 S                ;pause 3 seconds
          doHome                  ;home cursor
          LCDCmd(under)          ;choose underline cursor
          for ii = 0 to 15         ;move cursor across first line
            LCDCmd(line1+i)
            wait 200 mS
          next i
          for ii = 0 to 15         ;move cursor across second line
            LCDCmd(line2+i)
            wait 200 mS
          next i
          for ii = 15 to 0 step -1 ;move cursor back over second line
            LCDCmd(line2+i)
            wait 200 mS
          next i
          for ii = 15 to 0 step -1 ;move cursor back over first line
            LCDCmd(line1+i)
            wait 200 mS
          next i
          wait 3 S
          ;demonstrate blinking block cursor
          printMsg(8)             ;print next message
          doHome                  ;home the cursor
          LCDCmd(block)          ;choose blinking block cursor
          wait 4 S                ;pause 4 seconds
          LCDCmd(mode1)          ;change to one long line mode
          doHome                  ;home the cursor again
          LCDCmd(curOff)         ;and disable it


          ;demonstrate scrolling a lengthy one-line marquee
          for ii = 0xd0 to 0xff    ;print next message - the remaining EEPROM
            EPread ii, char        ;fetch directly from eeprom
            print chr(char)
          next i
          wait 1 S
          doHome                  ;home cursor once more
          repeat 141              ;scroll message twice
            LCDCmd(panR)
            wait 250 mS
          end repeat
          wait 2 S
          LCDCmd(mode2)          ;change back to two line mode
          doClr                   ;clear the screen
          ;demonstrate all of the characters
          printMsg(11)             ;print next message
          for ii = 33 to 127       ;print first batch of ASCII characters
            LCDCmd(line1+12)     ;overwrite each character displayed
            print chr(ii)            ;this is the ASCII code
            wait 500 mS
          next i
          for ii = 161 to 255      ;print next batch of ASCII characters
            LCDCmd(line1+12)
            print chr(ii)
            wait 500 mS
          next i
          ;say good-bye
          LCDCmd(line2)
          printMsg(11)             ;print next message
          doHome                  ;home the cursor
    loop

    end

    ;----- Clear the screen
    sub doClr
        LCDCmd(clrHome)
        wait 5 mS                   ;this command takes extra time
    end sub

    ;----- Home the cursor
    sub doHome
        LCDCmd(home)
        wait 5 mS                   ;and so does this one
    end sub

    ;----- Print a message to the LCD
    ;The parameter 'row' points to the start of the string.
    sub printMsg(in row as byte, in Optional StringLength As Byte = 15)
        LCDCmd(line1)              ;get set for first line

        for ii = 0 to StringLength
          index = row*16+ii
          EPread index, char        ;fetch next character and
          print chr(char)             ;transmit to the LCD
        next
        LCDCmd(line2)              ;get set for second line
        for ii = 0 to StringLength
          index = (row+1)*16+ii
          EPread index, char        ;fetch next character and
          print chr(char)             ;transmit to the LCD
        next
    end sub

    sub loadEeprom

        ' Strings for EEPROM, Strings should be limited to 16 characters for the first 13 sstrings, then a long string to fill eeprom
        location = 0
        WriteEeprom "First we'll show"
        WriteEeprom "this message.   "
        WriteEeprom "Then we'll blink"
        WriteEeprom "five times.     "
        WriteEeprom "Now lets pan    "
        WriteEeprom "left and right. "
        WriteEeprom "Watch the line  "
        WriteEeprom "cursor move.    "
        WriteEeprom "A block cursor  "
        WriteEeprom "is available.   "
        WriteEeprom "Characters:     "
        WriteEeprom "Bye!            "
        WriteEeprom "in one line mode"
        WriteEeprom "Next well scroll this long message as a marquee"

    end sub

    ; Write to the device eeprom
    sub WriteEeprom ( in Estring() ) as string * 64

        for ee = 1 to len ( Estring )
            HSersend Estring(ee)
            epwrite location, Estring(ee)
            location++
        next

    end sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 3</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_io_2.html" title="LCD_IO 2"><link rel="next" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_3"></a>LCD_IO 3</h5></div></div></div><p><span class="strong"><strong>Using connection mode 3:</strong></span></p><p>This method uses a Data and a Clock line via a shift register to control the LCD display plus an Enable line.
This method is used when the LCD is connected through a shift register IC using a LS74574.</p><p>This connection method is also called a 3-wire connection.</p><p>The diagram below shows a method to connect the LCD  to a microcontroller.</p><p><span class="inlinemediaobject"><img src="./images/lcd_io3.jpg" alt="graphic"></span></p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>Specific constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC. To set these constants the main program should specific constants to support the connection mode using #define.
When using 3-bit mode only three constants must be set.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_IO</code></p></td><td align="left" valign="top"><p>The I/O mode.</p></td><td align="left" valign="top"><p><code class="literal">3</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_DB</code></p></td><td align="left" valign="top"><p>The data pin used in 3-bit mode.</p></td><td align="left" valign="top"><p><span class="strong"><strong>Mandated</strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_CB</code></p></td><td align="left" valign="top"><p>The clock pin used in 3- bit mode.</p></td><td align="left" valign="top"><p><span class="strong"><strong>Mandated</strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_EB</code></p></td><td align="left" valign="top"><p>The enable pin used in 3- bit mode.</p></td><td align="left" valign="top"><p><span class="strong"><strong>Mandated</strong></span></p></td></tr></tbody></table></div><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #chip 16f628a, 4
    #option explicit

    ;Setup LCD Parameters
    #define LCD_IO 3

    'Change ports as necessary
    #define LCD_DB     PORTb.3            ; databit
    #define LCD_CB     PORTb.4            ; clockbit
    #define LCD_EB     PORTa.0            ; enable bit

      Dim BV as Byte


    'Program Start

     PRINT "GCBASIC"
     Locate 1,0
     PRINT "@2021"
     Wait 4 s

      DO Forever
           CLS
           WAIT 2 s
           PRINT "Test LCDHex "
           wait 3 s
           CLS
           wait 1 s


       for bv = 0 to 16
         locate 0,0
         Print "DEC " : Print BV
         locate 1,0
         Print "HEX "
         LCDHex BV
         Locate 1, 8
         LCDHEX BV, LeadingZeroActive

         wait 500 ms
       next
           CLS
           wait 1 s
           Print "END TEST"
      LOOP</pre><p>See the separate sections of the Help file for the specifics of each
Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_0.html" title="LCD_IO 0">LCD_IO 0</a>, <a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>,
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>, <a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>, <a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a> or <a class="link" href="_lcd_io_12.html" title="LCD_IO 12">LCD_IO 12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_3"></span>LCD\_IO 3

</div>

</div>

</div>

<span class="strong">**Using connection mode 3:**</span>

This method uses a Data and a Clock line via a shift register to control
the LCD display plus an Enable line. This method is used when the LCD is
connected through a shift register IC using a LS74574.

This connection method is also called a 3-wire connection.

The diagram below shows a method to connect the LCD to a
microcontroller.

<span class="inlinemediaobject">![graphic](./images/lcd_io3.jpg)</span>

<span class="strong">**Relevant Constants:**</span>

Specific constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set these constants the main
program should specific constants to support the connection mode using
\#define. When using 3-bit mode only three constants must be set.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Default Value**</span> |
|:----------------------------------------------|:-----------------------------------------|:----------------------------------------------|
| `LCD_IO`                                      | The I/O mode.                            | `3`                                           |
| `LCD_DB`                                      | The data pin used in 3-bit mode.         | <span class="strong">**Mandated**</span>      |
| `LCD_CB`                                      | The clock pin used in 3- bit mode.       | <span class="strong">**Mandated**</span>      |
| `LCD_EB`                                      | The enable pin used in 3- bit mode.      | <span class="strong">**Mandated**</span>      |

</div>

<span class="strong">**Example:**</span>

``` screen
    #chip 16f628a, 4
    #option explicit

    ;Setup LCD Parameters
    #define LCD_IO 3

    'Change ports as necessary
    #define LCD_DB     PORTb.3            ; databit
    #define LCD_CB     PORTb.4            ; clockbit
    #define LCD_EB     PORTa.0            ; enable bit

      Dim BV as Byte


    'Program Start

     PRINT "GCBASIC"
     Locate 1,0
     PRINT "@2021"
     Wait 4 s

      DO Forever
           CLS
           WAIT 2 s
           PRINT "Test LCDHex "
           wait 3 s
           CLS
           wait 1 s


       for bv = 0 to 16
         locate 0,0
         Print "DEC " : Print BV
         locate 1,0
         Print "HEX "
         LCDHex BV
         Locate 1, 8
         LCDHEX BV, LeadingZeroActive

         wait 500 ms
       next
           CLS
           wait 1 s
           Print "END TEST"
      LOOP
```

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_0" class="link" title="LCD_IO 0">LCD_IO 0</a>,
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,
<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>
or
<a href="lcd_io_12" class="link" title="LCD_IO 12">LCD_IO 12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 4</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174"><link rel="next" href="_lcd_io_8.html" title="LCD_IO 8"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_4"></a>LCD_IO 4</h5></div></div></div><p><span class="strong"><strong>Using connection mode 4:</strong></span></p><p>To use connection mode 4 the R/W, RS, Enable control lines and the highest 4 data lines (DB4 through DB7) must be connected to the microcontroller.</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>Specific constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC.  To set these constants the main program should specific constants to support the connection mode using #define.
Constants required for connection mode 4.</p><p>Constants are required for 4-bit mode as follows.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_SPEED</code></p></td><td align="left" valign="top"><p><code class="literal">FAST</code>, <code class="literal">MEDIUM</code> or <code class="literal">SLOW</code>.</p></td><td align="left" valign="top"><p><code class="literal">MEDIUM</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_IO</code></p></td><td align="left" valign="top"><p>Must be <span class="strong"><strong>4</strong></span></p></td><td align="left" valign="top"><p><code class="literal">4</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_RS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Register Select on the
LCD.</p></td><td align="left" valign="top"><p>Must be defined as <code class="literal">port.bit</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_RW</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Read/Write on the LCD. The
R/W pin can be disabled*.</p></td><td align="left" valign="top"><p>Must be defined as <code class="literal">port.bit</code> <span class="emphasis"><em>(unless R/W is disabled)</em></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_Enable</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Read/Write on the LCD.</p></td><td align="left" valign="top"><p>Must be defined as <code class="literal">port.bit</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_DB4</code></p></td><td align="left" valign="top"><p>Output pin used to interface with bit 4 of the LCD data bus</p></td><td align="left" valign="top"><p>Must be defined as <code class="literal">port.bit</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_DB5</code></p></td><td align="left" valign="top"><p>Output pin used to interface with bit 5 of the LCD data bus</p></td><td align="left" valign="top"><p>Must be defined as <code class="literal">port.bit</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_DB6</code></p></td><td align="left" valign="top"><p>Output pin used to interface with bit 6 of the LCD data bus</p></td><td align="left" valign="top"><p>Must be defined as <code class="literal">port.bit</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_DB7</code></p></td><td align="left" valign="top"><p>Output pin used to interface with bit 7 of the LCD data bus</p></td><td align="left" valign="top"><p>Must be defined as <code class="literal">port.bit</code></p></td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_VFD_DELAY</code></p></td><td align="left" valign="top"><p>Specifies a delay between transmission of data nibbles to LCD or VFD.
</p><p>Usage must include number value and unit of time.
</p><p><code class="literal">#DEFINE LCD_VFD_DELAY 1 ms</code>
</p><p>Only applicable when using LCD_IO 4</p></td><td align="left" valign="top"><p>None.</p></td></tr></tbody></table></div><p>The <code class="literal">R/W</code> pin can be disabled by setting the <code class="literal">LCD_NO_RW</code> constant. If this
is done, there is no need for the <code class="literal">R/W</code> to be connected to the chip, and
no need for the <code class="literal">LCD_RW</code> constant to be set. Ensure that the <code class="literal">R/W</code> line on
the LCD is connected to ground if not used.</p><p>For a code example download <a class="link" href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%204.gcb" target="_top">Four Wire LCD Example</a>.</p><p>Also see for further code examples see <a class="link" href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" target="_top">Four Wire LCD Solutions</a>.</p><p>See the separate sections of the Help file for the specifics of each
Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_0.html" title="LCD_IO 0">LCD_IO 0</a>, <a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>, <a class="link" href="_lcd_io_2.html" title="LCD_IO 2">LCD_IO 2</a>,
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>, <a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a> or <a class="link" href="_lcd_io_12.html" title="LCD_IO 12">LCD_IO 12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_4"></span>LCD\_IO 4

</div>

</div>

</div>

<span class="strong">**Using connection mode 4:**</span>

To use connection mode 4 the R/W, RS, Enable control lines and the
highest 4 data lines (DB4 through DB7) must be connected to the
microcontroller.

<span class="strong">**Relevant Constants:**</span>

Specific constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set these constants the main
program should specific constants to support the connection mode using
\#define. Constants required for connection mode 4.

Constants are required for 4-bit mode as follows.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constant Name</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Default Value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LCD_SPEED</code></p></td>
<td style="text-align: left;"><p><code class="literal">FAST</code>, <code class="literal">MEDIUM</code> or <code class="literal">SLOW</code>.</p></td>
<td style="text-align: left;"><p><code class="literal">MEDIUM</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">LCD_IO</code></p></td>
<td style="text-align: left;"><p>Must be <span class="strong"><strong>4</strong></span></p></td>
<td style="text-align: left;"><p><code class="literal">4</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LCD_RS</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Register Select on the LCD.</p></td>
<td style="text-align: left;"><p>Must be defined as <code class="literal">port.bit</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">LCD_RW</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Read/Write on the LCD. The R/W pin can be disabled*.</p></td>
<td style="text-align: left;"><p>Must be defined as <code class="literal">port.bit</code> <span class="emphasis"><em>(unless R/W is disabled)</em></span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LCD_Enable</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Read/Write on the LCD.</p></td>
<td style="text-align: left;"><p>Must be defined as <code class="literal">port.bit</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">LCD_DB4</code></p></td>
<td style="text-align: left;"><p>Output pin used to interface with bit 4 of the LCD data bus</p></td>
<td style="text-align: left;"><p>Must be defined as <code class="literal">port.bit</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LCD_DB5</code></p></td>
<td style="text-align: left;"><p>Output pin used to interface with bit 5 of the LCD data bus</p></td>
<td style="text-align: left;"><p>Must be defined as <code class="literal">port.bit</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">LCD_DB6</code></p></td>
<td style="text-align: left;"><p>Output pin used to interface with bit 6 of the LCD data bus</p></td>
<td style="text-align: left;"><p>Must be defined as <code class="literal">port.bit</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LCD_DB7</code></p></td>
<td style="text-align: left;"><p>Output pin used to interface with bit 7 of the LCD data bus</p></td>
<td style="text-align: left;"><p>Must be defined as <code class="literal">port.bit</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LCD_VFD_DELAY</code></p></td>
<td style="text-align: left;"><p>Specifies a delay between transmission of data nibbles to LCD or VFD.</p>
<p>Usage must include number value and unit of time.</p>
<p><code class="literal">#DEFINE LCD_VFD_DELAY 1 ms</code></p>
<p>Only applicable when using LCD_IO 4</p></td>
<td style="text-align: left;"><p>None.</p></td>
</tr>
</tbody>
</table>

</div>

The `R/W` pin can be disabled by setting the `LCD_NO_RW` constant. If
this is done, there is no need for the `R/W` to be connected to the
chip, and no need for the `LCD_RW` constant to be set. Ensure that the
`R/W` line on the LCD is connected to ground if not used.

For a code example download
<a href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%204.gcb" class="link">Four Wire LCD Example</a>.

Also see for further code examples see
<a href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" class="link">Four Wire LCD Solutions</a>.

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_0" class="link" title="LCD_IO 0">LCD_IO 0</a>,
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2" class="link" title="LCD_IO 2">LCD_IO 2</a>,
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>
or
<a href="lcd_io_12" class="link" title="LCD_IO 12">LCD_IO 12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 4 Example</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_examples.html" title="Examples"><link rel="prev" href="_lcd_io_2_example.html" title="LCD_IO 2 Example"><link rel="next" href="_lcd_io_8_example.html" title="LCD_IO 8 Example"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_4_example"></a>LCD_IO 4 Example</h5></div></div></div><p>This is a connection mode 4 Driver to demonstrate LCD features. This for the 16F877A, but, it can easily be adapted for other microcontrollers.</p><p>A 2 by 16 LCD is assumed.</p><pre class="screen">    #chip 16F877A,20

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width

    ;----- Main Program

    do forever

            Print "GCBASIC 2021"
            wait 3 s
            CLS

    loop
    end</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_4_example"></span>LCD\_IO 4 Example

</div>

</div>

</div>

This is a connection mode 4 Driver to demonstrate LCD features. This for
the 16F877A, but, it can easily be adapted for other microcontrollers.

A 2 by 16 LCD is assumed.

``` screen
    #chip 16F877A,20

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width

    ;----- Main Program

    do forever

            Print "GCBASIC 2021"
            wait 3 s
            CLS

    loop
    end
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 8</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_io_4.html" title="LCD_IO 4"><link rel="next" href="_lcd_io_10.html" title="LCD_IO 10"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_8"></a>LCD_IO 8</h5></div></div></div><p><span class="strong"><strong>Using connection mode 8:</strong></span></p><p>Using connection mode will require <code class="literal">R/W</code>, <code class="literal">RS</code>, <code class="literal">Enable</code> and all 8 data
lines.</p><p>The data lines must all be connected to the same I/O port, in sequential
order. For example, <code class="literal">DB0</code> to <code class="literal">PORTB.0</code>, <code class="literal">DB1</code> to <code class="literal">PORTB.1</code> and so on, with <code class="literal">DB7</code>
going to <code class="literal">PORTB.7</code>.</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>These constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set them, place a line in the
main program file that uses <code class="literal">#define</code> to assign a value to the particular
constant.</p><p>Constants are required for 8-bit mode as follows.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_SPEED</code></p></td><td align="left" valign="top"><p><code class="literal">FAST</code>, <code class="literal">MEDIUM</code> or <code class="literal">SLOW</code>.</p></td><td align="left" valign="top"><p><code class="literal">MEDIUM</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_IO</code></p></td><td align="left" valign="top"><p>The I/O mode. Can be 2, 4 or 8.</p></td><td align="left" valign="top"><p><code class="literal">8</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_RS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Register Select on the
LCD.</p></td><td align="left" valign="top"><p><span class="strong"><strong><span class="emphasis"><em>Must be defined</em></span></strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_RW</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Read/Write on the LCD. The
R/W pin can be disabled*.</p></td><td align="left" valign="top"><p><span class="strong"><strong><span class="emphasis"><em>Must be defined</em></span></strong></span> <span class="emphasis"><em>(unless R/W is disabled)</em></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_Enable</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Read/Write on the LCD.</p></td><td align="left" valign="top"><p><span class="strong"><strong><span class="emphasis"><em>Must be defined</em></span></strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_DATA_PORT</code></p></td><td align="left" valign="top"><p>Output port used to interface with LCD data bus</p></td><td align="left" valign="top"><p><span class="strong"><strong><span class="emphasis"><em>Must be defined</em></span></strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LCD_LAT</code></p></td><td align="left" valign="top"><p>Drives the port with <code class="literal">LATx</code> support. Resolves issues with faster Mhz and
the Microchip PIC read/write/modify feature. See example below.</p></td><td align="left" valign="top"><p>Optional</p></td></tr></tbody></table></div><p>The <code class="literal">R/W</code> pin can be disabled by setting the <code class="literal">LCD_NO_RW</code> constant. If this
is done, there is no need for the <code class="literal">R/W</code> to be connected to the chip, and
no need for the <code class="literal">LCD_RW</code> constant to be set. Ensure that the R/W line on
the LCD is connected to ground if not used.</p><p>For a code example download <a class="link" href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%208.gcb" target="_top">Eight Wire LCD example</a>.</p><p>For code examples see <a class="link" href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" target="_top">Eight Wire Examples</a>.</p><p>See the separate sections of the Help file for the specifics of each
Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_0.html" title="LCD_IO 0">LCD_IO 0</a>, <a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>, <a class="link" href="_lcd_io_2.html" title="LCD_IO 2">LCD_IO 2</a>,
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>, <a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a> or <a class="link" href="_lcd_io_12.html" title="LCD_IO 12">LCD_IO 12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_8"></span>LCD\_IO 8

</div>

</div>

</div>

<span class="strong">**Using connection mode 8:**</span>

Using connection mode will require `R/W`, `RS`, `Enable` and all 8 data
lines.

The data lines must all be connected to the same I/O port, in sequential
order. For example, `DB0` to `PORTB.0`, `DB1` to `PORTB.1` and so on,
with `DB7` going to `PORTB.7`.

<span class="strong">**Relevant Constants:**</span>

These constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set them, place a line in the
main program file that uses `#define` to assign a value to the
particular constant.

Constants are required for 8-bit mode as follows.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span>                                                                                                 | <span class="strong">**Default Value**</span>                                                                                            |
|:----------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------|
| `LCD_SPEED`                                   | `FAST`, `MEDIUM` or `SLOW`.                                                                                                              | `MEDIUM`                                                                                                                                 |
| `LCD_IO`                                      | The I/O mode. Can be 2, 4 or 8.                                                                                                          | `8`                                                                                                                                      |
| `LCD_RS`                                      | Specifies the output pin that is connected to Register Select on the LCD.                                                                | <span class="strong">**<span class="emphasis">*Must be defined*</span>**</span>                                                          |
| `LCD_RW`                                      | Specifies the output pin that is connected to Read/Write on the LCD. The R/W pin can be disabled\*.                                      | <span class="strong">**<span class="emphasis">*Must be defined*</span>**</span> <span class="emphasis">*(unless R/W is disabled)*</span> |
| `LCD_Enable`                                  | Specifies the output pin that is connected to Read/Write on the LCD.                                                                     | <span class="strong">**<span class="emphasis">*Must be defined*</span>**</span>                                                          |
| `LCD_DATA_PORT`                               | Output port used to interface with LCD data bus                                                                                          | <span class="strong">**<span class="emphasis">*Must be defined*</span>**</span>                                                          |
| `LCD_LAT`                                     | Drives the port with `LATx` support. Resolves issues with faster Mhz and the Microchip PIC read/write/modify feature. See example below. | Optional                                                                                                                                 |

</div>

The `R/W` pin can be disabled by setting the `LCD_NO_RW` constant. If
this is done, there is no need for the `R/W` to be connected to the
chip, and no need for the `LCD_RW` constant to be set. Ensure that the
R/W line on the LCD is connected to ground if not used.

For a code example download
<a href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%208.gcb" class="link">Eight Wire LCD example</a>.

For code examples see
<a href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions" class="link">Eight Wire Examples</a>.

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_0" class="link" title="LCD_IO 0">LCD_IO 0</a>,
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2" class="link" title="LCD_IO 2">LCD_IO 2</a>,
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>
or
<a href="lcd_io_12" class="link" title="LCD_IO 12">LCD_IO 12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_IO 8 Example</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_examples.html" title="Examples"><link rel="prev" href="_lcd_io_4_example.html" title="LCD_IO 4 Example"><link rel="next" href="_lcd_io_10_example.html" title="LCD_IO 10 Example"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_io_8_example"></a>LCD_IO 8 Example</h5></div></div></div><p>This is an connection mode 8 Driver to demonstrate LCD features. This for the 16F877A, but, it can easily be adapted for other microcontrollers.</p><p>A 2 by 16 LCD is assumed.</p><p>Based on the works by Thomas Henry and then revised Evan R. Venn</p><pre class="screen">    #chip 16F877A,20


    'Use LCD in 8 pin mode and define LCD pins
    #define LCD_IO 8
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_Data_Port PORTD
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width

    ;Here are various LCD commands which can be used.
    ;These are the LCD commands for the HD44780 controller
    #define clrHome = 1     ;clear the display, home the cursor
    #define home    = 2     ;home the cursor only
    #define RtoL    = 4     ;print characters right to left
    #define insR    = 5     ;insert characters to right
    #define LtoR    = 6     ;print characters left to right
    #define insL    = 7     ;insert characters to left
    #define lcdOff  = 8     ;LCD screen off
    #define lcdOn   = 12    ;LCD screen on, no cursor
    #define curOff  = 12    ;an alias for the above
    #define block   = 13    ;LCD screen on, block cursor
    #define under   = 14    ;LCD screen on, underline cursor
    #define undblk  = 15    ;LCD screen on, blinking and underline cursor
    #define CLeft   = 16    ;cursor left
    #define CRight  = 20    ;cursor right
    #define panR    = 24    ;pan viewing window right
    #define panL    = 28    ;pan viewing window left
    #define bus4    = 32    ;4-bit data bus mode
    #define bus8    = 48    ;8-bit data bus mode
    #define mode1   = 32    ;one-line mode (alias)
    #define mode2   = 40    ;two-line mode
    #define line1   = 128   ;go to start of line 1
    #define line2   = 192   ;go to start of line 2
    ;----- Variables
    dim char, msn, lsn, index, ii as byte
    ;----- Main Program
    LoadEeprom              ;load the EEprom with strings

    do forever
        printMsg(0)             ;print first message
        wait 3 S                ;pause 3 seconds
        printMsg(2)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 5                ;blink it five times
          LCDCmd(lcdOff)       ;display off
          wait 500 mS           ;pause
          LCDCmd(lcdOn)        ;display on
          wait 500 mS           ;pause
        end repeat
        wait 1 S                ;pause before next demo
        ;demonstrate panning
        printMsg(4)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 16
          LCDCmd(panL)         ;pan left a step at a time
          wait 300 mS           ;slow down to avoid blur
        end repeat
        repeat 16
          LCDCmd(panR)         ;then pan right
          wait 300 mS
        end repeat
        wait 1 S                ;pause before next demo
                                ;demonstrate moving the cursor
        printMsg(6)             ;print next message
        wait 3 S                ;pause 3 seconds
        doHome                  ;home cursor
        LCDCmd(under)          ;choose underline cursor
        for ii = 0 to 15         ;move cursor across first line
          LCDCmd(line1+i)
          wait 200 mS
        next i
        for ii = 0 to 15         ;move cursor across second line
          LCDCmd(line2+i)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over second line
          LCDCmd(line2+i)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over first line
          LCDCmd(line1+i)
          wait 200 mS
        next i
        wait 3 S
        ;demonstrate blinking block cursor
        printMsg(8)             ;print next message
        doHome                  ;home the cursor
        LCDCmd(block)          ;choose blinking block cursor
        wait 4 S                ;pause 4 seconds
        LCDCmd(mode1)          ;change to one long line mode
        doHome                  ;home the cursor again
        LCDCmd(curOff)         ;and disable it


        ;demonstrate scrolling a lengthy one-line marquee
        for ii = 0xd0 to 0xff    ;print next message - the remaining EEPROM
          EPread ii, char        ;fetch directly from eeprom
          print chr(char)
        next i
        wait 1 S
        doHome                  ;home cursor once more
        repeat 141              ;scroll message twice
          LCDCmd(panR)
          wait 250 mS
        end repeat
        wait 2 S
        LCDCmd(mode2)          ;change back to two line mode
        doClr                   ;clear the screen
        ;demonstrate all of the characters
        printMsg(11)             ;print next message
        for ii = 33 to 127       ;print first batch of ASCII characters
          LCDCmd(line1+12)     ;overwrite each character displayed
          print chr(ii)            ;this is the ASCII code
          wait 500 mS
        next i
        for ii = 161 to 255      ;print next batch of ASCII characters
          LCDCmd(line1+12)
          print chr(ii)
          wait 500 mS
        next i
        ;say good-bye
        LCDCmd(line2)
        printMsg(11)             ;print next message
        doHome                  ;home the cursor
    loop
    end

    ;----- Clear the screen
    sub doClr
        LCDCmd(clrHome)
        wait 5 mS                   ;this command takes extra time
    end sub

    ;----- Home the cursor
    sub doHome
        LCDCmd(home)
        wait 5 mS                   ;and so does this one
    end sub

    ;----- Print a message to the LCD
    ;The parameter 'row' points to the start of the string.
    sub printMsg(in row as byte, in Optional StringLength As Byte = 15)
          LCDCmd(line1)              ;get set for first line

          for ii = 0 to StringLength
            index = row*16+ii
            EPread index, char        ;fetch next character and
            print chr(char)             ;transmit to the LCD
          next
          LCDCmd(line2)              ;get set for second line
          for ii = 0 to StringLength
            index = (row+1)*16+ii
            EPread index, char        ;fetch next character and
            print chr(char)             ;transmit to the LCD
          next
    end sub

    sub loadEeprom

        ' Strings for EEPROM, Strings should be limited to 16 characters for the first 13 sstrings, then a long string to fill eeprom
        location = 0
        WriteEeprom "First we'll show"
        WriteEeprom "this message.   "
        WriteEeprom "Then we'll blink"
        WriteEeprom "five times.     "
        WriteEeprom "Now lets pan    "
        WriteEeprom "left and right. "
        WriteEeprom "Watch the line  "
        WriteEeprom "cursor move.    "
        WriteEeprom "A block cursor  "
        WriteEeprom "is available.   "
        WriteEeprom "Characters:     "
        WriteEeprom "Bye!            "
        WriteEeprom "in one line mode"
        WriteEeprom "Next well scroll this long message as a marquee"
    end sub


    ; Write to the device eeprom
    sub WriteEeprom ( in Estring() ) as string * 64
        for ee = 1 to len ( Estring )
            HSersend Estring(ee)
            epwrite location, Estring(ee)
            location++
        next
    end sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_io_8_example"></span>LCD\_IO 8 Example

</div>

</div>

</div>

This is an connection mode 8 Driver to demonstrate LCD features. This
for the 16F877A, but, it can easily be adapted for other
microcontrollers.

A 2 by 16 LCD is assumed.

Based on the works by Thomas Henry and then revised Evan R. Venn

``` screen
    #chip 16F877A,20


    'Use LCD in 8 pin mode and define LCD pins
    #define LCD_IO 8
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_Data_Port PORTD
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width

    ;Here are various LCD commands which can be used.
    ;These are the LCD commands for the HD44780 controller
    #define clrHome = 1     ;clear the display, home the cursor
    #define home    = 2     ;home the cursor only
    #define RtoL    = 4     ;print characters right to left
    #define insR    = 5     ;insert characters to right
    #define LtoR    = 6     ;print characters left to right
    #define insL    = 7     ;insert characters to left
    #define lcdOff  = 8     ;LCD screen off
    #define lcdOn   = 12    ;LCD screen on, no cursor
    #define curOff  = 12    ;an alias for the above
    #define block   = 13    ;LCD screen on, block cursor
    #define under   = 14    ;LCD screen on, underline cursor
    #define undblk  = 15    ;LCD screen on, blinking and underline cursor
    #define CLeft   = 16    ;cursor left
    #define CRight  = 20    ;cursor right
    #define panR    = 24    ;pan viewing window right
    #define panL    = 28    ;pan viewing window left
    #define bus4    = 32    ;4-bit data bus mode
    #define bus8    = 48    ;8-bit data bus mode
    #define mode1   = 32    ;one-line mode (alias)
    #define mode2   = 40    ;two-line mode
    #define line1   = 128   ;go to start of line 1
    #define line2   = 192   ;go to start of line 2
    ;----- Variables
    dim char, msn, lsn, index, ii as byte
    ;----- Main Program
    LoadEeprom              ;load the EEprom with strings

    do forever
        printMsg(0)             ;print first message
        wait 3 S                ;pause 3 seconds
        printMsg(2)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 5                ;blink it five times
          LCDCmd(lcdOff)       ;display off
          wait 500 mS           ;pause
          LCDCmd(lcdOn)        ;display on
          wait 500 mS           ;pause
        end repeat
        wait 1 S                ;pause before next demo
        ;demonstrate panning
        printMsg(4)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 16
          LCDCmd(panL)         ;pan left a step at a time
          wait 300 mS           ;slow down to avoid blur
        end repeat
        repeat 16
          LCDCmd(panR)         ;then pan right
          wait 300 mS
        end repeat
        wait 1 S                ;pause before next demo
                                ;demonstrate moving the cursor
        printMsg(6)             ;print next message
        wait 3 S                ;pause 3 seconds
        doHome                  ;home cursor
        LCDCmd(under)          ;choose underline cursor
        for ii = 0 to 15         ;move cursor across first line
          LCDCmd(line1+i)
          wait 200 mS
        next i
        for ii = 0 to 15         ;move cursor across second line
          LCDCmd(line2+i)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over second line
          LCDCmd(line2+i)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over first line
          LCDCmd(line1+i)
          wait 200 mS
        next i
        wait 3 S
        ;demonstrate blinking block cursor
        printMsg(8)             ;print next message
        doHome                  ;home the cursor
        LCDCmd(block)          ;choose blinking block cursor
        wait 4 S                ;pause 4 seconds
        LCDCmd(mode1)          ;change to one long line mode
        doHome                  ;home the cursor again
        LCDCmd(curOff)         ;and disable it


        ;demonstrate scrolling a lengthy one-line marquee
        for ii = 0xd0 to 0xff    ;print next message - the remaining EEPROM
          EPread ii, char        ;fetch directly from eeprom
          print chr(char)
        next i
        wait 1 S
        doHome                  ;home cursor once more
        repeat 141              ;scroll message twice
          LCDCmd(panR)
          wait 250 mS
        end repeat
        wait 2 S
        LCDCmd(mode2)          ;change back to two line mode
        doClr                   ;clear the screen
        ;demonstrate all of the characters
        printMsg(11)             ;print next message
        for ii = 33 to 127       ;print first batch of ASCII characters
          LCDCmd(line1+12)     ;overwrite each character displayed
          print chr(ii)            ;this is the ASCII code
          wait 500 mS
        next i
        for ii = 161 to 255      ;print next batch of ASCII characters
          LCDCmd(line1+12)
          print chr(ii)
          wait 500 mS
        next i
        ;say good-bye
        LCDCmd(line2)
        printMsg(11)             ;print next message
        doHome                  ;home the cursor
    loop
    end

    ;----- Clear the screen
    sub doClr
        LCDCmd(clrHome)
        wait 5 mS                   ;this command takes extra time
    end sub

    ;----- Home the cursor
    sub doHome
        LCDCmd(home)
        wait 5 mS                   ;and so does this one
    end sub

    ;----- Print a message to the LCD
    ;The parameter 'row' points to the start of the string.
    sub printMsg(in row as byte, in Optional StringLength As Byte = 15)
          LCDCmd(line1)              ;get set for first line

          for ii = 0 to StringLength
            index = row*16+ii
            EPread index, char        ;fetch next character and
            print chr(char)             ;transmit to the LCD
          next
          LCDCmd(line2)              ;get set for second line
          for ii = 0 to StringLength
            index = (row+1)*16+ii
            EPread index, char        ;fetch next character and
            print chr(char)             ;transmit to the LCD
          next
    end sub

    sub loadEeprom

        ' Strings for EEPROM, Strings should be limited to 16 characters for the first 13 sstrings, then a long string to fill eeprom
        location = 0
        WriteEeprom "First we'll show"
        WriteEeprom "this message.   "
        WriteEeprom "Then we'll blink"
        WriteEeprom "five times.     "
        WriteEeprom "Now lets pan    "
        WriteEeprom "left and right. "
        WriteEeprom "Watch the line  "
        WriteEeprom "cursor move.    "
        WriteEeprom "A block cursor  "
        WriteEeprom "is available.   "
        WriteEeprom "Characters:     "
        WriteEeprom "Bye!            "
        WriteEeprom "in one line mode"
        WriteEeprom "Next well scroll this long message as a marquee"
    end sub


    ; Write to the device eeprom
    sub WriteEeprom ( in Estring() ) as string * 64
        for ee = 1 to len ( Estring )
            HSersend Estring(ee)
            epwrite location, Estring(ee)
            location++
        next
    end sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="next" href="_lcd_io_0.html" title="LCD_IO 0"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lcd_overview"></a>LCD Overview</h4></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>The LCD routines in this section allow GCBASIC programs to control an
alphanumeric Liquid Crystal Displays based on the <span class="strong"><strong>HD44780</strong></span> IC. This
covers most 16 x 1, 16 x 2, 20 x 4 and 40 x 4 LCD displays.</p><p>The GCBASIC methods allow the displays to be connected to the microcontroller</p><p><span class="strong"><strong>Connection Modes:</strong></span></p><p>The table below shows the connection modes.  These modes support the connection to the LCD using differing methods.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="center" valign="top">Connection Mode</th><th align="left" valign="top">Required Connections</th></tr></thead><tbody><tr><td align="center" valign="top"><p>0</p></td><td align="left" valign="top"><p>No configuration is required directly by this method. The LCD routines
<span class="strong"><strong>must</strong></span> be provided with other subroutines which will handle the
communication. This is useful for communicating with LCDs connected
through RS232 or I2C.
<br>
This is an advanced method of driving an LCD.</p></td></tr><tr><td align="center" valign="top"><p>1</p></td><td align="left" valign="top"><p>Uses a combined data and clock line. This mode is used when the LCD is connected through a
shift register 74HC595, as detailed at <a class="link" href="http://gcbasic.sourceforge.net/library/DIAGRAMS/1-Wire%20LCD/" target="_top"><span class="strong"><strong>here</strong></span></a>.
<br>
This method of driving an LCD requires an additional integrated circuit and other passive components.
This is not recommended for the beginner.</p></td></tr><tr><td align="center" valign="top"><p>2</p></td><td align="left" valign="top"><p>Uses separated Data and Clock lines. This mode is used when the LCD is connected
through a 74LS174 shift register IC, as detailed at
<a class="link" href="http://gcbasic.sourceforge.net/library/DIAGRAMS/2-Wire%20LCD/" target="_top"><span class="strong"><strong>here</strong></span></a>
<br>
This method of driving an LCD requires additional integrated circuits
and other passive components. This is not recommended for the beginner.</p></td></tr><tr><td align="center" valign="top"><p>3</p></td><td align="left" valign="top"><p><code class="literal">DB</code>, <code class="literal">CB</code>, <code class="literal">EB</code> are connected to the microcontroller as the Data, Clock and Enable Bits.
<br>
This a common method to connect a microcontroller to an LCD. This
requires 3 data ports on the microcontroller.</p></td></tr><tr><td align="center" valign="top"><p>4</p></td><td align="left" valign="top"><p><code class="literal">R/W</code>, <code class="literal">RS</code>, <code class="literal">Enable</code> and the highest 4 data lines (<code class="literal">DB4</code> through <code class="literal">DB7</code>) are
connected to the microcontroller. The use of the R/W line is optional.
<br>
This a common method to connect a microcontroller to an LCD. This
requires 7(6) data ports on the microcontroller.</p></td></tr><tr><td align="center" valign="top"><p>8</p></td><td align="left" valign="top"><p><code class="literal">R/W</code>, <code class="literal">RS</code>, <code class="literal">Enable</code> and all 8 data lines. The data lines must all be
connected to the same I/O port, in sequential order. For example, <code class="literal">DB0</code> to
<code class="literal">PORTB.0</code>, <code class="literal">DB1</code> to <code class="literal">PORTB.1</code> and so on, with`DB7` going to <code class="literal">PORTB.7</code>.
<br>
This is a common method to connect a microcontroller to a LCD. This
requires 11(10) data ports on the microcontroller.</p></td></tr><tr><td align="center" valign="top"><p>10</p></td><td align="left" valign="top"><p>The LCD is controlled via I2C. A type 10 LCD 12C adapter. Set <code class="literal">LCD_IO</code> to
<code class="literal">10</code> for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter
<br>
This is a common method and requires two data ports on the microcontroller.</p></td></tr><tr><td align="center" valign="top"><p>12</p></td><td align="left" valign="top"><p>The LCD is controlled via I2C. A type 12 LCD 12C adapter. Set <code class="literal">LCD_IO</code> to
`12`for the Ywmjkdz I2C adapter with a potentiometer (variable resistance) bent over top of chip.
<br>
This is a common method and requires two data ports on the microcontroller.</p></td></tr><tr><td align="center" valign="top"><p>107</p></td><td align="left" valign="top"><p>The LCD is controlled via serial. Set <code class="literal">LCD_IO</code> to
<code class="literal">107</code> or <code class="literal">K107</code>.
<br>
The K107 requires one serial data ports on the microcontroller.</p></td></tr></tbody></table></div><p><br>
<br></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Supported LCDs mapped to Connection Mode</h3><p>The support of various types of LCD displays are shown in the following table.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Supported LCD Type<br>
number of characters x number of lines</th><th align="left" valign="top">Connection Mode</th></tr></thead><tbody><tr><td align="left" valign="top"><p>16 x 1, 16 x 2, 20 x 2, 20 x 4 type LCD displays,<br>
also known as 1601, 1602, 2002, 2004 type LCD displays.</p></td><td align="left" valign="top"><p>0,1,2,4,8,10 and 12</p></td></tr><tr><td align="left" valign="top"><p>40 x 4 LCD displays,<br>
also known as 4004 type LCD displays.</p></td><td align="left" valign="top"><p>4</p></td></tr><tr><td align="left" valign="top"><p>16 x 1 LCD displays, with a non-standard/non-consective memory map.<br>
</p><p>This LCD sub type is supported using a specific constant.
</p><p>Use <code class="literal"><span class="strong"><strong>#define LCD_VARIANT 1601a</strong></span></code> to use this sub variant.
</p><p>Also known as 1601 type LCD displays.</p></td><td align="left" valign="top"><p>Supports any LCD_IO mode.</p></td></tr></tbody></table></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Communication Performance</h3><p>There may be a need to change the communication performance for a specific LCD as some LCD&#8217;s are slower to operate.  GCBASIC supports change the communications speed.</p><p>To change the performance (communications speed) of the LCD use <code class="literal">#DEFINE LCD_SPEED</code>.  This method allows the timing to be optimised.</p><p><span class="emphasis"><em>Example</em></span></p><pre class="screen"> #DEFINE LCD_SPEED  FAST</pre><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Define</th><th align="left" valign="top">Performance Characteristics</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_SPEED</code></p></td><td align="left" valign="top"><p><code class="literal">FAST</code>     - The speed is approximately 20,000 CPS.<br>
<code class="literal">MEDIUM</code>   - The speed is approximately 15,000 CPS.<br>
<code class="literal">SLOW</code>     - The speed is approximately 10,000 CPS.<br>
<code class="literal">OPTIMAL</code>  - The speed is approximately 30,000 CPS.<br></p></td></tr></tbody></table></div><p>If <code class="literal">LCD_SPEED</code> is not defined, the speed defaults to <code class="literal">SLOW</code>
<br>
<br>
&nbsp;&nbsp;
&nbsp;&nbsp;</p></div><p><b>Using LCD_Speed OPTIMAL<br>.&nbsp;</b>&nbsp;&nbsp;</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>&nbsp;&nbsp;
<code class="literal">OPTIMAL</code> disables fixed delays and allows the LCD operate as fast as it can.&nbsp;&nbsp;In this mode, The the busy flag is polled before each byte is sent to the HD44780 controller. &nbsp;&nbsp;This not only optimizes speed, but also assures that data is not sent to the diplay controler until it is ready to receive the data.</p><p>With most displays this equates to a speed of about 30,000 characters per second.&nbsp;&nbsp;For comparision about 10 times faster than I2C using a PC8574 Expander (See LCD_IO 10 or  See LCD_IO 112)</p><p><code class="literal">OPTIMAL</code> is only supported in LCD_IO 4,8 and only when LCD_NO_RW is not defined  (RW Mode).&nbsp;&nbsp;When <code class="literal">#DEFINE LCD_NO_RW</code> is defined, reading data from the HD44780 is not possible since this disables Read Mode on the controller.&nbsp;&nbsp;In this case busy flag checking is not available and the GET subroutine is not avaiable.</p><p>In order to enable busy flag checking, and, therefore to use the <code class="literal">GET</code> command the following criteria must be true.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">LCD I/O Mode must be either 4-wire or 8-wire</li><li class="listitem"><code class="literal">#DEFINE LCD_NO_RW</code> is not defined</li><li class="listitem">An I\O pin is connected between the microcontroller and the RW connection on the LCD Display</li><li class="listitem"><code class="literal">'DEFINE LCD_RW  port.pin</code> is defined in the GCBASIC source code</li></ol></div><p>Example:</p><pre class="screen">  #DEFINE LCD_IO 4
  #DEFINE LCD_SPEED OPTIMAL

  #DEFINE LCD_DB7 PORTB.5
  #DEFINE LCD_DB6 PORTB.4
  #DEFINE LCD_DB5 PORTB.3
  #DEFINE LCD_DB4 PORTB.2

  #DEFINE LCD_RW PORTA.3    'Must be defined for RW Mode
  #DEFINE LCD_RS PORTA.2
  #DEFINE LCD_ENABLE PORTA.1</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Changing the LCD Width</h3><p>To change the LCD width characteristics use <code class="literal">#define LCD_WIDTH</code></p></div><p><br>
<br></p><p>See the separate sections of the Help file for the specifics of each Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_0.html" title="LCD_IO 0">LCD_IO 0</a>, <a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>, <a class="link" href="_lcd_io_2.html" title="LCD_IO 2">LCD_IO 2</a>, <a class="link" href="_lcd_io_3.html" title="LCD_IO 3">LCD_IO 3</a>,
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO_2 74xx164</a>, <a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO_2 74xx174</a>,
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>, <a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a> or <a class="link" href="_lcd_io_12.html" title="LCD_IO 12">LCD_IO 12</a></p><p><span class="strong"><strong>and,</strong></span></p><p><a class="link" href="_lcd_width.html" title="LCD_WIDTH">LCD_Width</a>, <a class="link" href="_lcd_speed.html" title="LCD_SPEED">LCD_Speed</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lcd_overview"></span>LCD Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

The LCD routines in this section allow GCBASIC programs to control an
alphanumeric Liquid Crystal Displays based on the <span
class="strong">**HD44780**</span> IC. This covers most 16 x 1, 16 x 2,
20 x 4 and 40 x 4 LCD displays.

The GCBASIC methods allow the displays to be connected to the
microcontroller

<span class="strong">**Connection Modes:**</span>

The table below shows the connection modes. These modes support the
connection to the LCD using differing methods.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: center;">Connection Mode</th>
<th style="text-align: left;">Required Connections</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><p>0</p></td>
<td style="text-align: left;"><p>No configuration is required directly by this method. The LCD routines <span class="strong"><strong>must</strong></span> be provided with other subroutines which will handle the communication. This is useful for communicating with LCDs connected through RS232 or I2C.<br />
This is an advanced method of driving an LCD.</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>1</p></td>
<td style="text-align: left;"><p>Uses a combined data and clock line. This mode is used when the LCD is connected through a shift register 74HC595, as detailed at <a href="http://gcbasic.sourceforge.net/library/DIAGRAMS/1-Wire%20LCD/" class="link"><span class="strong"><strong>here</strong></span></a>.<br />
This method of driving an LCD requires an additional integrated circuit and other passive components. This is not recommended for the beginner.</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>2</p></td>
<td style="text-align: left;"><p>Uses separated Data and Clock lines. This mode is used when the LCD is connected through a 74LS174 shift register IC, as detailed at <a href="http://gcbasic.sourceforge.net/library/DIAGRAMS/2-Wire%20LCD/" class="link"><span class="strong"><strong>here</strong></span></a><br />
This method of driving an LCD requires additional integrated circuits and other passive components. This is not recommended for the beginner.</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>3</p></td>
<td style="text-align: left;"><p><code class="literal">DB</code>, <code class="literal">CB</code>, <code class="literal">EB</code> are connected to the microcontroller as the Data, Clock and Enable Bits.<br />
This a common method to connect a microcontroller to an LCD. This requires 3 data ports on the microcontroller.</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>4</p></td>
<td style="text-align: left;"><p><code class="literal">R/W</code>, <code class="literal">RS</code>, <code class="literal">Enable</code> and the highest 4 data lines (<code class="literal">DB4</code> through <code class="literal">DB7</code>) are connected to the microcontroller. The use of the R/W line is optional.<br />
This a common method to connect a microcontroller to an LCD. This requires 7(6) data ports on the microcontroller.</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>8</p></td>
<td style="text-align: left;"><p><code class="literal">R/W</code>, <code class="literal">RS</code>, <code class="literal">Enable</code> and all 8 data lines. The data lines must all be connected to the same I/O port, in sequential order. For example, <code class="literal">DB0</code> to <code class="literal">PORTB.0</code>, <code class="literal">DB1</code> to <code class="literal">PORTB.1</code> and so on, with`DB7` going to <code class="literal">PORTB.7</code>.<br />
This is a common method to connect a microcontroller to a LCD. This requires 11(10) data ports on the microcontroller.</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>10</p></td>
<td style="text-align: left;"><p>The LCD is controlled via I2C. A type 10 LCD 12C adapter. Set <code class="literal">LCD_IO</code> to <code class="literal">10</code> for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter<br />
This is a common method and requires two data ports on the microcontroller.</p></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p>12</p></td>
<td style="text-align: left;"><p>The LCD is controlled via I2C. A type 12 LCD 12C adapter. Set <code class="literal">LCD_IO</code> to `12`for the Ywmjkdz I2C adapter with a potentiometer (variable resistance) bent over top of chip.<br />
This is a common method and requires two data ports on the microcontroller.</p></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p>107</p></td>
<td style="text-align: left;"><p>The LCD is controlled via serial. Set <code class="literal">LCD_IO</code> to <code class="literal">107</code> or <code class="literal">K107</code>.<br />
The K107 requires one serial data ports on the microcontroller.</p></td>
</tr>
</tbody>
</table>

</div>

  
  

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

### Supported LCDs mapped to Connection Mode

The support of various types of LCD displays are shown in the following
table.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Supported LCD Type<br />
number of characters x number of lines</th>
<th style="text-align: left;">Connection Mode</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>16 x 1, 16 x 2, 20 x 2, 20 x 4 type LCD displays,<br />
also known as 1601, 1602, 2002, 2004 type LCD displays.</p></td>
<td style="text-align: left;"><p>0,1,2,4,8,10 and 12</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>40 x 4 LCD displays,<br />
also known as 4004 type LCD displays.</p></td>
<td style="text-align: left;"><p>4</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>16 x 1 LCD displays, with a non-standard/non-consective memory map.<br />
</p>
<p>This LCD sub type is supported using a specific constant.</p>
<p>Use <code class="literal">#define LCD_VARIANT 1601a</code> to use this sub variant.</p>
<p>Also known as 1601 type LCD displays.</p></td>
<td style="text-align: left;"><p>Supports any LCD_IO mode.</p></td>
</tr>
</tbody>
</table>

</div>

</div>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

### Communication Performance

There may be a need to change the communication performance for a
specific LCD as some LCD’s are slower to operate. GCBASIC supports
change the communications speed.

To change the performance (communications speed) of the LCD use
`#DEFINE LCD_SPEED`. This method allows the timing to be optimised.

<span class="emphasis">*Example*</span>

``` screen
 #DEFINE LCD_SPEED  FAST
```

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Define</th>
<th style="text-align: left;">Performance Characteristics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LCD_SPEED</code></p></td>
<td style="text-align: left;"><p><code class="literal">FAST</code> - The speed is approximately 20,000 CPS.<br />
<code class="literal">MEDIUM</code> - The speed is approximately 15,000 CPS.<br />
<code class="literal">SLOW</code> - The speed is approximately 10,000 CPS.<br />
<code class="literal">OPTIMAL</code> - The speed is approximately 30,000 CPS.<br />
</p></td>
</tr>
</tbody>
</table>

</div>

If `LCD_SPEED` is not defined, the speed defaults to `SLOW`  
  
     

</div>

**Using LCD\_Speed OPTIMAL  
. **  

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

### Note

   `OPTIMAL` disables fixed delays and allows the LCD operate as fast as
it can.  In this mode, The the busy flag is polled before each byte is
sent to the HD44780 controller.   This not only optimizes speed, but
also assures that data is not sent to the diplay controler until it is
ready to receive the data.

With most displays this equates to a speed of about 30,000 characters
per second.  For comparision about 10 times faster than I2C using a
PC8574 Expander (See LCD\_IO 10 or See LCD\_IO 112)

`OPTIMAL` is only supported in LCD\_IO 4,8 and only when LCD\_NO\_RW is
not defined (RW Mode).  When `#DEFINE LCD_NO_RW` is defined, reading
data from the HD44780 is not possible since this disables Read Mode on
the controller.  In this case busy flag checking is not available and
the GET subroutine is not avaiable.

In order to enable busy flag checking, and, therefore to use the `GET`
command the following criteria must be true.

<div class="orderedlist">

1.  LCD I/O Mode must be either 4-wire or 8-wire
2.  `#DEFINE LCD_NO_RW` is not defined
3.  An I\\O pin is connected between the microcontroller and the RW
    connection on the LCD Display
4.  `'DEFINE LCD_RW  port.pin` is defined in the GCBASIC source code

</div>

Example:

``` screen
  #DEFINE LCD_IO 4
  #DEFINE LCD_SPEED OPTIMAL

  #DEFINE LCD_DB7 PORTB.5
  #DEFINE LCD_DB6 PORTB.4
  #DEFINE LCD_DB5 PORTB.3
  #DEFINE LCD_DB4 PORTB.2

  #DEFINE LCD_RW PORTA.3    'Must be defined for RW Mode
  #DEFINE LCD_RS PORTA.2
  #DEFINE LCD_ENABLE PORTA.1
```

</div>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

### Changing the LCD Width

To change the LCD width characteristics use `#define LCD_WIDTH`

</div>

  
  

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_0" class="link" title="LCD_IO 0">LCD_IO 0</a>,
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2" class="link" title="LCD_IO 2">LCD_IO 2</a>,
<a href="lcd_io_3" class="link" title="LCD_IO 3">LCD_IO 3</a>,
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO_2 74xx164</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO_2 74xx174</a>,
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,
<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>
or
<a href="lcd_io_12" class="link" title="LCD_IO 12">LCD_IO 12</a>

<span class="strong">**and,**</span>

<a href="lcd_width" class="link" title="LCD_WIDTH">LCD_Width</a>,
<a href="lcd_speed" class="link" title="LCD_SPEED">LCD_Speed</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_SPEED</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_variant.html" title="LCD_VARIANT"><link rel="next" href="_lcd_width.html" title="LCD_WIDTH"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_speed"></a>LCD_SPEED</h5></div></div></div><p><span class="strong"><strong>Using LCD_SPEED:</strong></span></p><p>The communication performance of a LCD display can be controlled via a <code class="literal">#DEFINE</code>.
This method allows the timing to be optimised.</p><p><span class="strong"><strong>Example</strong></span></p><pre class="literallayout">#DEFINE LCD_SPEED  FAST</pre><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Define</th><th align="left" valign="top">Required Connections</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_SPEED</code></p></td><td align="left" valign="top"><p>Options are:<br>
<code class="literal">FAST</code>     - The speed is approximately 20,000 CPS.<br>
<code class="literal">MEDIUM</code>   - The speed is approximately 15,000 CPS.<br>
<code class="literal">SLOW</code>     - The speed is approximately 10,000 CPS.<br>
<code class="literal">OPTIMAL</code>  - The speed is approximately 30,000 CPS.<br></p></td></tr></tbody></table></div><p>If <code class="literal">LCD_SPEED</code> is not defined, the speed defaults to <code class="literal">SLOW</code>
<br>
<br>
To change the performance (communications speed) of the LCD use <code class="literal">#DEFINE LCD_SPEED</code>.  This method allows the timing to be optimised.</p><p><span class="strong"><strong>Example</strong></span></p><pre class="screen">  #DEFINE LCD_SPEED  FAST</pre><p>If <code class="literal">LCD_SPEED</code> is not defined, the speed defaults to <code class="literal">SLOW</code></p><p><span class="strong"><strong>Speed Parameter  OPTIMAL</strong></span></p><p>WHEN LCD_NO_RW is not defined,  OPTIMAL disables fixed delays and allows the LCD operate as fast as it can.</p><p>In this mode, The the busy flag is polled before each byte is sent to the HD44780 controller. &nbsp;&nbsp;This not only optimizes speed, but also assures that data is not sent to the diplay controler until it is ready to receive the data.</p><p>With most displays this equates to a speed of about 30,000 characters per second.  For comparision about 10 times faster than I2C using a PC8574 Expander (See LCD_IO 10 or  See LCD_IO 112)</p><p><code class="literal">OPTIMAL</code> is only supported in LCD_IO 4,8 and only when LCD_NO_RW is not defined  (RW Mode)</p><p>When <code class="literal">#DEFINE LCD_NO_RW</code> is defined, reading data from the HD44780 is not possible since this disables Read Mode on the controller.&nbsp;&nbsp;In this case busy flag checking is not available and the GET subroutine is not avaiable.</p><p>In order to enable busy flag checking, and, therefore to use the <code class="literal">GET</code> command the following criteria must be true.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">LCD I/O Mode must be either 4-wire or 8-wire</li><li class="listitem"><code class="literal">#DEFINE LCD_NO_RW</code> is not defined</li><li class="listitem">An I\O pin is connected between the microcontroller and the RW connection on the LCD Display</li><li class="listitem"><code class="literal">'DEFINE LCD_RW  port.pin</code> is defined in the GCBASIC source code</li></ol></div><p>Example:</p><pre class="screen">  #DEFINE LCD_IO 4
  #DEFINE LCD_SPEED OPTIMAL
  #DEFINE LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
  #DEFINE LCD_DB7 PORTB.5
  #DEFINE LCD_DB6 PORTB.4
  #DEFINE LCD_DB7 PORTB.3
  #DEFINE LCD_DB6 PORTB.2

  #DEFINE LCD_RW PORTA.3    'Must be defined for RW Mode
  #DEFINE LCD_RS PORTA.2
  #DEFINE LCD_ENABLE PORTA.1</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_speed"></span>LCD\_SPEED

</div>

</div>

</div>

<span class="strong">**Using LCD\_SPEED:**</span>

The communication performance of a LCD display can be controlled via a
`#DEFINE`. This method allows the timing to be optimised.

<span class="strong">**Example**</span>

``` literallayout
#DEFINE LCD_SPEED  FAST
```

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Define</th>
<th style="text-align: left;">Required Connections</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LCD_SPEED</code></p></td>
<td style="text-align: left;"><p>Options are:<br />
<code class="literal">FAST</code> - The speed is approximately 20,000 CPS.<br />
<code class="literal">MEDIUM</code> - The speed is approximately 15,000 CPS.<br />
<code class="literal">SLOW</code> - The speed is approximately 10,000 CPS.<br />
<code class="literal">OPTIMAL</code> - The speed is approximately 30,000 CPS.<br />
</p></td>
</tr>
</tbody>
</table>

</div>

If `LCD_SPEED` is not defined, the speed defaults to `SLOW`  
  
To change the performance (communications speed) of the LCD use
`#DEFINE LCD_SPEED`. This method allows the timing to be optimised.

<span class="strong">**Example**</span>

``` screen
  #DEFINE LCD_SPEED  FAST
```

If `LCD_SPEED` is not defined, the speed defaults to `SLOW`

<span class="strong">**Speed Parameter OPTIMAL**</span>

WHEN LCD\_NO\_RW is not defined, OPTIMAL disables fixed delays and
allows the LCD operate as fast as it can.

In this mode, The the busy flag is polled before each byte is sent to
the HD44780 controller.   This not only optimizes speed, but also
assures that data is not sent to the diplay controler until it is ready
to receive the data.

With most displays this equates to a speed of about 30,000 characters
per second. For comparision about 10 times faster than I2C using a
PC8574 Expander (See LCD\_IO 10 or See LCD\_IO 112)

`OPTIMAL` is only supported in LCD\_IO 4,8 and only when LCD\_NO\_RW is
not defined (RW Mode)

When `#DEFINE LCD_NO_RW` is defined, reading data from the HD44780 is
not possible since this disables Read Mode on the controller.  In this
case busy flag checking is not available and the GET subroutine is not
avaiable.

In order to enable busy flag checking, and, therefore to use the `GET`
command the following criteria must be true.

<div class="orderedlist">

1.  LCD I/O Mode must be either 4-wire or 8-wire
2.  `#DEFINE LCD_NO_RW` is not defined
3.  An I\\O pin is connected between the microcontroller and the RW
    connection on the LCD Display
4.  `'DEFINE LCD_RW  port.pin` is defined in the GCBASIC source code

</div>

Example:

``` screen
  #DEFINE LCD_IO 4
  #DEFINE LCD_SPEED OPTIMAL
  #DEFINE LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
  #DEFINE LCD_DB7 PORTB.5
  #DEFINE LCD_DB6 PORTB.4
  #DEFINE LCD_DB7 PORTB.3
  #DEFINE LCD_DB6 PORTB.2

  #DEFINE LCD_RW PORTA.3    'Must be defined for RW Mode
  #DEFINE LCD_RS PORTA.2
  #DEFINE LCD_ENABLE PORTA.1
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_VARIANT</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_io_107.html" title="LCD_IO 107"><link rel="next" href="_lcd_speed.html" title="LCD_SPEED"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_variant"></a>LCD_VARIANT</h5></div></div></div><p><span class="strong"><strong>Using LCD_VARIANT:</strong></span></p><p>Some LCDs are non-standard.&nbsp;&nbsp;
The non-standard LCDs may have a different memory architecture where the memory is non-consective or different delay timing is required  for the LCD IC.&nbsp;&nbsp;
Use <code class="literal">LCD_VARIANT</code> to change the operating behaviour of GCBASIC with respect to LCD operations.&nbsp;&nbsp;
If a <code class="literal">LCD_VARIANT</code> adaption has been created in the library then the non-standard LCD can be supported.</p><p><span class="strong"><strong>#DEFINE LCD_VARIANT 1601a</strong></span></p><p>Use <code class="literal">#define LCD_VARIANT 1601a</code> to use this sub variant. Requires a LCD_IO then this sub type modifier.&nbsp;&nbsp;
This variant has a non consective memory as shown in the diagram below.</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/Variant_1601a_LCD_Solution-Memory_Map.png" align="middle" alt="graphic"></div></div><p><span class="strong"><strong>Example:</strong></span></p><p>This example shows how to use the LCD_VARIANT constant.&nbsp;&nbsp;
This example shows the use of software I2C - any LCD mode can be used not just software I2C.&nbsp;&nbsp;</p><pre class="screen">    #chip tiny84,1

    'Set up LCD
    #define LCD_IO 10
    #define LCD_VARIANT 1601a
    #define LCD_WIDTH 16

    'You may need to use SLOW or MEDIUM if your LCD is a slower device.
    #define LCD_SPEED FAST

    ' ----- Define Hardware settings
    ' Define I2C settings - CHANGE PORTS FOR YOUR NEEDS
    #define LCD_I2C_Address 0x0E
    #define I2C_MODE Master
    #define I2C_DATA PORTA.4
    #define I2C_CLOCK PORTA.5
    #define I2C_DISABLE_INTERRUPTS ON

    'You may need to invert these states. Dependent of LCD I2C adapter.
    #define LCD_Backlight_On_State  1
    #define LCD_Backlight_Off_State 0

    ; ----- Main body of program commences here.
    Locate 0,0
    PRINT "GCBASIC"


    Do
    Loop</pre><p>For code examples see <a class="link" href="https://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions/Variant1601a_LCD_Solutions" target="_top">I2C Variants LCD Solutions</a>.</p><p>See the separate sections of the Help file for the specifics of each
Connection Mode.</p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_lcd_io_0.html" title="LCD_IO 0">LCD_IO 0</a>, <a class="link" href="_lcd_io_1.html" title="LCD_IO 1">LCD_IO 1</a>, <a class="link" href="_lcd_io_2.html" title="LCD_IO 2">LCD_IO 2</a>
<a class="link" href="_lcd_io_2_74xx164.html" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>, <a class="link" href="_lcd_io_2_74xx174.html" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a class="link" href="_lcd_io_4.html" title="LCD_IO 4">LCD_IO 4</a>, <a class="link" href="_lcd_io_8.html" title="LCD_IO 8">LCD_IO 8</a>,
<a class="link" href="_lcd_io_10.html" title="LCD_IO 10">LCD_IO 10</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_variant"></span>LCD\_VARIANT

</div>

</div>

</div>

<span class="strong">**Using LCD\_VARIANT:**</span>

Some LCDs are non-standard.   The non-standard LCDs may have a different
memory architecture where the memory is non-consective or different
delay timing is required for the LCD IC.   Use `LCD_VARIANT` to change
the operating behaviour of GCBASIC with respect to LCD operations.   If
a `LCD_VARIANT` adaption has been created in the library then the
non-standard LCD can be supported.

<span class="strong">**\#DEFINE LCD\_VARIANT 1601a**</span>

Use `#define LCD_VARIANT 1601a` to use this sub variant. Requires a
LCD\_IO then this sub type modifier.   This variant has a non consective
memory as shown in the diagram below.

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/Variant_1601a_LCD_Solution-Memory_Map.png)

</div>

</div>

<span class="strong">**Example:**</span>

This example shows how to use the LCD\_VARIANT constant.   This example
shows the use of software I2C - any LCD mode can be used not just
software I2C.  

``` screen
    #chip tiny84,1

    'Set up LCD
    #define LCD_IO 10
    #define LCD_VARIANT 1601a
    #define LCD_WIDTH 16

    'You may need to use SLOW or MEDIUM if your LCD is a slower device.
    #define LCD_SPEED FAST

    ' ----- Define Hardware settings
    ' Define I2C settings - CHANGE PORTS FOR YOUR NEEDS
    #define LCD_I2C_Address 0x0E
    #define I2C_MODE Master
    #define I2C_DATA PORTA.4
    #define I2C_CLOCK PORTA.5
    #define I2C_DISABLE_INTERRUPTS ON

    'You may need to invert these states. Dependent of LCD I2C adapter.
    #define LCD_Backlight_On_State  1
    #define LCD_Backlight_Off_State 0

    ; ----- Main body of program commences here.
    Locate 0,0
    PRINT "GCBASIC"


    Do
    Loop
```

For code examples see
<a href="https://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions/Variant1601a_LCD_Solutions" class="link">I2C Variants LCD Solutions</a>.

See the separate sections of the Help file for the specifics of each
Connection Mode.

<span class="strong">**For more help, see**</span>
<a href="lcd_io_0" class="link" title="LCD_IO 0">LCD_IO 0</a>,
<a href="lcd_io_1" class="link" title="LCD_IO 1">LCD_IO 1</a>,
<a href="lcd_io_2" class="link" title="LCD_IO 2">LCD_IO 2</a>
<a href="lcd_io_2_74xx164" class="link" title="LCD_IO 2_74xx164">LCD_IO 2_74xx164</a>,
<a href="lcd_io_2_74xx174" class="link" title="LCD_IO 2_74xx174">LCD_IO 2_74xx174</a>,
<a href="lcd_io_4" class="link" title="LCD_IO 4">LCD_IO 4</a>,
<a href="lcd_io_8" class="link" title="LCD_IO 8">LCD_IO 8</a>,
<a href="lcd_io_10" class="link" title="LCD_IO 10">LCD_IO 10</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LCD_WIDTH</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_lcd_overview.html" title="LCD Overview"><link rel="prev" href="_lcd_speed.html" title="LCD_SPEED"><link rel="next" href="_cls.html" title="CLS"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_lcd_width"></a>LCD_WIDTH</h5></div></div></div><p><span class="strong"><strong>Using LCD_WIDTH:</strong></span></p><p>This constant changes the width characteristics of a LCD display.  &nbsp;&nbsp;&nbsp;The standard width is assumed to be 20 characters.</p><p>This constant allows the width to be optimised for specific LCD chipsets.</p><p><span class="strong"><strong>Example</strong></span></p><pre class="literallayout">#DEFINE LCD_WIDTH  16</pre><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Define</th><th align="left" valign="top">Required Connections</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">LCD_WIDTH</code></p></td><td align="left" valign="top"><p>Default is 20<br>
<code class="literal">16</code>   - Set the WIDTH 16 characters<br></p></td></tr></tbody></table></div><p>If <code class="literal">LCD_WIDTH</code> is not defined, the WIDTH defaults to <code class="literal">20</code></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="lcd_width"></span>LCD\_WIDTH

</div>

</div>

</div>

<span class="strong">**Using LCD\_WIDTH:**</span>

This constant changes the width characteristics of a LCD display.    The
standard width is assumed to be 20 characters.

This constant allows the width to be optimised for specific LCD
chipsets.

<span class="strong">**Example**</span>

``` literallayout
#DEFINE LCD_WIDTH  16
```

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Define</th>
<th style="text-align: left;">Required Connections</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>Default is 20<br />
<code class="literal">16</code> - Set the WIDTH 16 characters<br />
</p></td>
</tr>
</tbody>
</table>

</div>

If `LCD_WIDTH` is not defined, the WIDTH defaults to `20`

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Left</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_lcase.html" title="LCase"><link rel="next" href="_leftpad.html" title="LeftPad"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_left"></a>Left</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>output</em></span> = Left(<span class="emphasis"><em>source</em></span>, <span class="emphasis"><em>count</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Left</code> function will extract the leftmost <code class="literal"><span class="emphasis"><em>count</em></span></code> characters from the input string <code class="literal"><span class="emphasis"><em>source</em></span></code>, and return them in a new string.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the leftmost 5 characters
    'Will display "Hello"
    HSerPrint Left(TestData, 5)
    HSerPrintCRLF</pre><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_mid.html" title="Mid">Mid</a>, <a class="link" href="_right.html" title="Right">Right</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="left"></span>Left

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    output = Left(source, count)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Left` function will extract the leftmost `count` characters from
the input string `source`, and return them in a new string.

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the leftmost 5 characters
    'Will display "Hello"
    HSerPrint Left(TestData, 5)
    HSerPrintCRLF
```

<span class="strong">**See Also**</span>
<a href="mid" class="link" title="Mid">Mid</a>,
<a href="right" class="link" title="Right">Right</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LeftPad</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_left.html" title="Left"><link rel="next" href="_len.html" title="Len"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_leftpad"></a>LeftPad</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    LeftPad(<span class="emphasis"><em>string_variable</em></span>,<span class="emphasis"><em>byte_value_of_the_new_length</em></span>,<span class="emphasis"><em>pad_character</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The LeftPad function is used to create string to a specific length that is extended with a specific character to the left hand side of the string.</p><p>The length of the string is specified by the second parameter.</p><p>The character used to pad the string is specified by the third parameter.</p><p>A typical use is to pad a string to be displayed on a serial terminal or LCD.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
 'Set chip model
    #chip 16f877a


    DIR PORTA 0x03


    ' make port C as output
    Dir PortC 0x0


    'Defines (Constants)
    #define LCD_SPEED slow
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_NO_RW
    #define LCD_Enable PORTc.0
    #define LCD_RS PORTc.1
    #define LCD_DB4 PORTa.5
    #define LCD_DB5 PORTa.4
    #define LCD_DB6 PORTa.3
    #define LCD_DB7 PORTa.2
    '''--------------------------------------------
    '''-------End of board-specific settings-------
    '''--------------------------------------------


    '''DEMO for padding strings left with
    '''1st character of a given string.
    '''if no string is given, blanks are used


    ; ---- variables
    DIM inString as string * 5
    DIM outString1 as String
    DIM outString2 as String

    ; ---- main body of program begins here

    inString = "12345"

    outString1 = leftpad(inString, 9, "*")
    outString2 = leftpad(inString, 9)

    'show results on LCD-Display
    cls

    print instring
    print " "
    print outstring1
    locate 1,0
    print instring
    print " "
    print outstring2

    end</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="leftpad"></span>LeftPad

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    LeftPad(string_variable,byte_value_of_the_new_length,pad_character)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The LeftPad function is used to create string to a specific length that
is extended with a specific character to the left hand side of the
string.

The length of the string is specified by the second parameter.

The character used to pad the string is specified by the third
parameter.

A typical use is to pad a string to be displayed on a serial terminal or
LCD.

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
 'Set chip model
    #chip 16f877a


    DIR PORTA 0x03


    ' make port C as output
    Dir PortC 0x0


    'Defines (Constants)
    #define LCD_SPEED slow
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_NO_RW
    #define LCD_Enable PORTc.0
    #define LCD_RS PORTc.1
    #define LCD_DB4 PORTa.5
    #define LCD_DB5 PORTa.4
    #define LCD_DB6 PORTa.3
    #define LCD_DB7 PORTa.2
    '''--------------------------------------------
    '''-------End of board-specific settings-------
    '''--------------------------------------------


    '''DEMO for padding strings left with
    '''1st character of a given string.
    '''if no string is given, blanks are used


    ; ---- variables
    DIM inString as string * 5
    DIM outString1 as String
    DIM outString2 as String

    ; ---- main body of program begins here

    inString = "12345"

    outString1 = leftpad(inString, 9, "*")
    outString2 = leftpad(inString, 9)

    'show results on LCD-Display
    cls

    print instring
    print " "
    print outstring1
    locate 1,0
    print instring
    print " "
    print outstring2

    end
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Len</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_leftpad.html" title="LeftPad"><link rel="next" href="_ltrim.html" title="Ltrim"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_len"></a>Len</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>output</em></span>= Len( string )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Len</code> function returns an byte value which is the length of a phrase or a sentence, including the empty spaces. The format is:</p><pre class="screen">    target_byte_variable = Len("Phrase")</pre><p>or another example. This code will loop through the for-next loop 12 times as determined by the length of the string:<br></p><pre class="screen">    ' create a test string of 12 characters
    dim teststring as string * 12

    teststring = "0123456789AB"
    for loopthrustring = 1 to len(teststring)
       hserprint mid(teststring, loopthrustring , 1)
    next</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="len"></span>Len

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    output= Len( string )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Len` function returns an byte value which is the length of a phrase
or a sentence, including the empty spaces. The format is:

``` screen
    target_byte_variable = Len("Phrase")
```

or another example. This code will loop through the for-next loop 12
times as determined by the length of the string:  

``` screen
    ' create a test string of 12 characters
    dim teststring as string * 12

    teststring = "0123456789AB"
    for loopthrustring = 1 to len(teststring)
       hserprint mid(teststring, loopthrustring , 1)
    next
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Libraries Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_compiler_insights.html" title="Compiler Insights"><link rel="next" href="_acknowledgements.html" title="Acknowledgements"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_libraries_overview"></a>Libraries Overview</h2></div></div></div><p><span class="strong"><strong>About Libraries</strong></span></p><p>GCBASIC (as with most other microcontroller programming languages) supports libraries.</p><p>You can create you own device specific library, you are not limited to those shown below.  If you create a new device specific library - please submit for inclusion in the next release via the GCBASIC forum.</p><p>Maintenance of these libraries is completed by the GCBASIC development team.  If you wish to adapt these libraries you should create a local copy, edit and save within your development file structure.  The development team may update these libraries as part of a release and we do not want you to lose your local changes.</p><p>To use a library, simple inlcude the following in your user code</p><pre class="screen">    #include &lt;3PI.H&gt;    'this will include the 3PI capabilities within your program</pre><p>To use a local copy of a library, simple inlcude the following in your user code</p><pre class="screen">    #include "C:\mydev\library\3pi.h"    'this will include a local copy of the the 3PI capabilities within your program</pre><p>GCBASIC supports the following device libraries.</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Library</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Class</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Usage</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>3PI</p></td><td align="left" valign="top"><p>Polulu 3pi robot</p></td><td align="left" valign="top"><p>A library that interfaces the switch and the motors.</p></td></tr><tr><td align="left" valign="top"><p>47XXX_EERAM.H</p></td><td align="left" valign="top"><p>I2C EERAM memory</p></td><td align="left" valign="top"><p>A device specific library for the Microchip EERAM device classs</p></td></tr><tr><td align="left" valign="top"><p>ALPS-EC11</p></td><td align="left" valign="top"><p>Rotary Encoder</p></td><td align="left" valign="top"><p>A device specific library for a rotary encoder.</p></td></tr><tr><td align="left" valign="top"><p>ADS7843</p></td><td align="left" valign="top"><p>Touch Shield</p></td><td align="left" valign="top"><p>A library that interfaces with the ADS7843 touch screen.</p></td></tr><tr><td align="left" valign="top"><p>BME280</p></td><td align="left" valign="top"><p>Temp, Humidity and Pressure sensor</p></td><td align="left" valign="top"><p>A library that interfaces with the BME280 and the BMP280 sensor.</p></td></tr><tr><td align="left" valign="top"><p>CHIPINO</p></td><td align="left" valign="top"><p>Shield</p></td><td align="left" valign="top"><p>A library that interfaces the Chipino board with Arduino like port addresses.</p></td></tr><tr><td align="left" valign="top"><p>DHT</p></td><td align="left" valign="top"><p>Temperature and Humidity</p></td><td align="left" valign="top"><p>A library that supports the DHT22 and the DHT11 Temperature and Humidity sensors.</p></td></tr><tr><td align="left" valign="top"><p>DS1307</p></td><td align="left" valign="top"><p>Clock</p></td><td align="left" valign="top"><p>A library that supports the timer clock and NVRAM functions.</p></td></tr><tr><td align="left" valign="top"><p>DS1672</p></td><td align="left" valign="top"><p>Clock</p></td><td align="left" valign="top"><p>A library that supports the timer clock and NVRAM functions.</p></td></tr><tr><td align="left" valign="top"><p>DS18B20</p></td><td align="left" valign="top"><p>Temperature</p></td><td align="left" valign="top"><p>A library that supports the temperature functions.</p></td></tr><tr><td align="left" valign="top"><p>DS18SB0MultiPort</p></td><td align="left" valign="top"><p>Temperature</p></td><td align="left" valign="top"><p>A library that supports the temperature functions with devices attached to multiple ports.</p></td></tr><tr><td align="left" valign="top"><p>DS18S20</p></td><td align="left" valign="top"><p>Temperature</p></td><td align="left" valign="top"><p>A library that supports the temperature functions.</p></td></tr><tr><td align="left" valign="top"><p>DS2482</p></td><td align="left" valign="top"><p>Clock</p></td><td align="left" valign="top"><p>A library that supports the I2C to Dallas OneWire functions.</p></td></tr><tr><td align="left" valign="top"><p>DS3231</p></td><td align="left" valign="top"><p>Clock</p></td><td align="left" valign="top"><p>A library that supports the timer clock and NVRAM functions.</p></td></tr><tr><td align="left" valign="top"><p>DUEMILANOVE</p></td><td align="left" valign="top"><p>Shield</p></td><td align="left" valign="top"><p>A library that interfaces the Duemilanove board with Arduino like port addresses.</p></td></tr><tr><td align="left" valign="top"><p>EMC1001</p></td><td align="left" valign="top"><p>Temperature</p></td><td align="left" valign="top"><p>A library that supports the temperature functions and the other device capabilities.</p></td></tr><tr><td align="left" valign="top"><p>FRAM</p></td><td align="left" valign="top"><p>I2C Eeprom</p></td><td align="left" valign="top"><p>A library that supports memory functions.</p></td></tr><tr><td align="left" valign="top"><p>GETUSERID</p></td><td align="left" valign="top"><p>Microchip read ID</p></td><td align="left" valign="top"><p>A library that supports the identification of Microchip microcontrollers.</p></td></tr><tr><td align="left" valign="top"><p>EPD_EPD2In13</p></td><td align="left" valign="top"><p>Graphical e-Paper display</p></td><td align="left" valign="top"><p>A core library for Graphical LCD support.</p></td></tr><tr><td align="left" valign="top"><p>EPD_EPD7in5</p></td><td align="left" valign="top"><p>Graphical e-Paper display</p></td><td align="left" valign="top"><p>A core library for Graphical LCD support.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_HX8347</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_ILI9340</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_ILI9341</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_ILI9481</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_ILI9486L</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_NT7108C</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_IMAGESANDFONTS_ADDIN3</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A library to increase the capabilities of the Graphical LCDs.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_KS0108</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_NEXTION</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_PCD8544</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_SH1106</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_SSD1289</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_SSD1306</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_SSD1331</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_ST7735</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_ST7920</p></td><td align="left" valign="top"><p>Graphical LCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_T6963_64</p></td><td align="left" valign="top"><p>Graphical T6963 LCD with 240 x 64 pixels</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>GLCD_T6963_128</p></td><td align="left" valign="top"><p>Graphical T6963 LCD with 240 x 64 pixels</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>HEFLASH</p></td><td align="left" valign="top"><p>HEF Memory Driver</p></td><td align="left" valign="top"><p>A library that supports the HEF memory functions.</p></td></tr><tr><td align="left" valign="top"><p>HMC5883L</p></td><td align="left" valign="top"><p>Triple-axis Magnetometer</p></td><td align="left" valign="top"><p>A library that supports the magnetometer functions.</p></td></tr><tr><td align="left" valign="top"><p>HWI2C_ISR_HANDLER</p></td><td align="left" valign="top"><p>I2C Slave Driver</p></td><td align="left" valign="top"><p>A library that supports the use of a Microchip microcontroller as an I2C slave.</p></td></tr><tr><td align="left" valign="top"><p>HWI2C_MESSAGEINTERFACE</p></td><td align="left" valign="top"><p>I2C Slave</p></td><td align="left" valign="top"><p>A support library that supports the use of a Microchip microcontroller as an I2C slave.</p></td></tr><tr><td align="left" valign="top"><p>HWI2C_ISR_HANDLERKMODE</p></td><td align="left" valign="top"><p>I2C Slave Driver</p></td><td align="left" valign="top"><p>A library that supports the use of a Microchip microcontroller as an I2C slave.</p></td></tr><tr><td align="left" valign="top"><p>HWI2C_MESSAGEINTERFACEKMODE</p></td><td align="left" valign="top"><p>I2C Slave</p></td><td align="left" valign="top"><p>A support library that supports the use of a Microchip microcontroller as an I2C slave.</p></td></tr><tr><td align="left" valign="top"><p>I2CEEPROM</p></td><td align="left" valign="top"><p>I2C EEProm memory</p></td><td align="left" valign="top"><p>A library that supports memory functions.</p></td></tr><tr><td align="left" valign="top"><p>LCD2SERIALREDIRECT</p></td><td align="left" valign="top"><p>LCD to Serial Handler</p></td><td align="left" valign="top"><p>A library that supports the use of a serial and PC terminal as a psuedo LCD.</p></td></tr><tr><td align="left" valign="top"><p>LEGO-PF</p></td><td align="left" valign="top"><p>Lego Mindstorms shield</p></td><td align="left" valign="top"><p>A library that supports the Lego Mindstorms robot</p></td></tr><tr><td align="left" valign="top"><p>LEGO</p></td><td align="left" valign="top"><p>Lego Mindstorms shield</p></td><td align="left" valign="top"><p>A library that supports the Lego Mindstorms robot</p></td></tr><tr><td align="left" valign="top"><p>MATHS</p></td><td align="left" valign="top"><p>Maths routines</p></td><td align="left" valign="top"><p>A library that supports maths functions such as logs, power and atan.</p></td></tr><tr><td align="left" valign="top"><p>MAX6675</p></td><td align="left" valign="top"><p>Temperature</p></td><td align="left" valign="top"><p>A library that supports the temperature functions.</p></td></tr><tr><td align="left" valign="top"><p>MAX7219_ledmatrix_driver</p></td><td align="left" valign="top"><p>LED 8*8 Matrix driver</p></td><td align="left" valign="top"><p>A library that supports the MAX7219 8*8 LED matrixes</p></td></tr><tr><td align="left" valign="top"><p>MCP23008</p></td><td align="left" valign="top"><p>i2C to serial</p></td><td align="left" valign="top"><p>A library that supports the I2C to serial functions.</p></td></tr><tr><td align="left" valign="top"><p>MCP23017</p></td><td align="left" valign="top"><p>i2C to serial</p></td><td align="left" valign="top"><p>A library that supports the I2C to serial functions.</p></td></tr><tr><td align="left" valign="top"><p>MCP4XXXDIGITALPOT</p></td><td align="left" valign="top"><p>Digital Pot</p></td><td align="left" valign="top"><p>A library that supports the MCPxxxx range of digital potentiometers.</p></td></tr><tr><td align="left" valign="top"><p>MCP7940N</p></td><td align="left" valign="top"><p>Clock</p></td><td align="left" valign="top"><p>A library that supports the timer clock and NVRAM functions.</p></td></tr><tr><td align="left" valign="top"><p>MILLIS</p></td><td align="left" valign="top"><p>Clock</p></td><td align="left" valign="top"><p>A library that supports the 1000ms timer event cycle.</p></td></tr><tr><td align="left" valign="top"><p>NUNCHUCK</p></td><td align="left" valign="top"><p>Game controller</p></td><td align="left" valign="top"><p>A library that supports the NunChuck game controller.</p></td></tr><tr><td align="left" valign="top"><p>PCA9685</p></td><td align="left" valign="top"><p>PWM</p></td><td align="left" valign="top"><p>A device specific library for the 16channel PWM driver.  See the demonstrations for example on usage.
Support up to four devices via the I2C bus.</p></td></tr><tr><td align="left" valign="top"><p>PCF8574</p></td><td align="left" valign="top"><p>GLCD</p></td><td align="left" valign="top"><p>A device specific library for an Graphical LCD.</p></td></tr><tr><td align="left" valign="top"><p>PCF85X3</p></td><td align="left" valign="top"><p>Clock</p></td><td align="left" valign="top"><p>A library that supports the timer clock and alarms.</p></td></tr><tr><td align="left" valign="top"><p>SD</p></td><td align="left" valign="top"><p>SD Card</p></td><td align="left" valign="top"><p>A device specific library for an SD Card.</p></td></tr><tr><td align="left" valign="top"><p>SMT_Timers</p></td><td align="left" valign="top"><p>Signal Measurment Timer</p></td><td align="left" valign="top"><p>A library for Signal Measurment Timer for specific Microchip microcontrollers.</p></td></tr><tr><td align="left" valign="top"><p>SOFTSERIAL</p></td><td align="left" valign="top"><p>Serial</p></td><td align="left" valign="top"><p>A library for software serial.</p></td></tr><tr><td align="left" valign="top"><p>SOFTSERIALCH1</p></td><td align="left" valign="top"><p>Serial</p></td><td align="left" valign="top"><p>A library for software serial.</p></td></tr><tr><td align="left" valign="top"><p>SOFTSERIALCH2</p></td><td align="left" valign="top"><p>Serial</p></td><td align="left" valign="top"><p>A library for software serial.</p></td></tr><tr><td align="left" valign="top"><p>SOFTSERIALCH3</p></td><td align="left" valign="top"><p>Serial</p></td><td align="left" valign="top"><p>A library for software serial.</p></td></tr><tr><td align="left" valign="top"><p>SONGLAY</p></td><td align="left" valign="top"><p>Music</p></td><td align="left" valign="top"><p>A library for play music. Supports QBASIC and RTTTL format.</p></td></tr><tr><td align="left" valign="top"><p>SONYREMOTE</p></td><td align="left" valign="top"><p>Infrared</p></td><td align="left" valign="top"><p>A library that supports the functions of a Sony remote control.</p></td></tr><tr><td align="left" valign="top"><p>SRF02</p></td><td align="left" valign="top"><p>Distance Sensor</p></td><td align="left" valign="top"><p>A library that supports the SRF02 ultrasonic sensor.</p></td></tr><tr><td align="left" valign="top"><p>SRAM</p></td><td align="left" valign="top"><p>Memory devices</p></td><td align="left" valign="top"><p>A library that supports 23LC1024, 23LCV1024, 23LC1024,  23A1024,  23LCV512,  23LC512,  23A512,  23K256,  23A256,  23A640 or 23K640 devices</p></td></tr><tr><td align="left" valign="top"><p>SRF04</p></td><td align="left" valign="top"><p>Distance Sensor</p></td><td align="left" valign="top"><p>A library that supports the SRF04 ultrasonic sensor.</p></td></tr><tr><td align="left" valign="top"><p>TEA5767</p></td><td align="left" valign="top"><p>I2C Radio</p></td><td align="left" valign="top"><p>A library that supports the TEA5767 radio.</p></td></tr><tr><td align="left" valign="top"><p>TM1637</p></td><td align="left" valign="top"><p>7 Segment LED display</p></td><td align="left" valign="top"><p>A library that supports the TM1637 7-Segment LED displays</p></td></tr><tr><td align="left" valign="top"><p>TRIG2PLACES</p></td><td align="left" valign="top"><p>Maths functions</p></td><td align="left" valign="top"><p>A maths library that supports trignometry to two places.</p></td></tr><tr><td align="left" valign="top"><p>TRIG3PLACES</p></td><td align="left" valign="top"><p>Maths functions</p></td><td align="left" valign="top"><p>A maths library that supports trignometry to three places</p></td></tr><tr><td align="left" valign="top"><p>TRIG4PLACES</p></td><td align="left" valign="top"><p>Maths functions</p></td><td align="left" valign="top"><p>A maths library that supports trignometry to four places</p></td></tr><tr><td align="left" valign="top"><p>UNO_MEGA328P</p></td><td align="left" valign="top"><p>Shield</p></td><td align="left" valign="top"><p>A library that interfaces the shield with Arduino like port addresses.</p></td></tr><tr><td align="left" valign="top"><p>USB</p></td><td align="left" valign="top"><p>USB Supoort</p></td><td align="left" valign="top"><p>A library that interfaces the USB for 16f and 18f microcontrollers.</p></td></tr></tbody></table></div><p><br></p><p><br>
GCBASIC supports the following core libraries.   These libraries are automatically included in your user program therefore you do not need to use '#include' to access the libraries capabilities.</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Library</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Class</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Usage</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>7SEGMENT</p></td><td align="left" valign="top"><p>7 Segment LED display</p></td><td align="left" valign="top"><p>A library that interfaces the device. See also TM1637a library.</p></td></tr><tr><td align="left" valign="top"><p>A-D</p></td><td align="left" valign="top"><p>Analog to Digital</p></td><td align="left" valign="top"><p>A library that supports the ADC functionality.</p></td></tr><tr><td align="left" valign="top"><p>EEPROM</p></td><td align="left" valign="top"><p>EEProm</p></td><td align="left" valign="top"><p>A library that supports I2C eeprom devices.</p></td></tr><tr><td align="left" valign="top"><p>HWI2C</p></td><td align="left" valign="top"><p>I2C</p></td><td align="left" valign="top"><p>A library that supports the MSSP and TWI hardware modules of I2C</p></td></tr><tr><td align="left" valign="top"><p>HWI2C2</p></td><td align="left" valign="top"><p>I2C</p></td><td align="left" valign="top"><p>A library that supports the MSSP and TWI hardware modules of I2C on channel two</p></td></tr><tr><td align="left" valign="top"><p>HWSPI</p></td><td align="left" valign="top"><p>SPI</p></td><td align="left" valign="top"><p>A library that supports the MSSP and TWI hardware modules of SPI</p></td></tr><tr><td align="left" valign="top"><p>I2C</p></td><td align="left" valign="top"><p>I2C</p></td><td align="left" valign="top"><p>A library that supports software I2C</p></td></tr><tr><td align="left" valign="top"><p>KEYPAD</p></td><td align="left" valign="top"><p>KeyPad</p></td><td align="left" valign="top"><p>A library that supports a keypad.</p></td></tr><tr><td align="left" valign="top"><p>PS2</p></td><td align="left" valign="top"><p>I2C</p></td><td align="left" valign="top"><p>A library that supports keyboard functionality</p></td></tr><tr><td align="left" valign="top"><p>LCD</p></td><td align="left" valign="top"><p>LCD</p></td><td align="left" valign="top"><p>A library that supports LCD functionality, library supports many different communications methods.</p></td></tr><tr><td align="left" valign="top"><p>PWM</p></td><td align="left" valign="top"><p>Pulse Width Modulation</p></td><td align="left" valign="top"><p>A library supports PWM functionality.</p></td></tr><tr><td align="left" valign="top"><p>RANDOM</p></td><td align="left" valign="top"><p>Random Numbers</p></td><td align="left" valign="top"><p>A library supports random number functionality.</p></td></tr><tr><td align="left" valign="top"><p>REMOTE</p></td><td align="left" valign="top"><p>Infrared</p></td><td align="left" valign="top"><p>A library that supports the functions of a NEC remote control.</p></td></tr><tr><td align="left" valign="top"><p>RS232</p></td><td align="left" valign="top"><p>Serial</p></td><td align="left" valign="top"><p>A library for serial communications.</p></td></tr><tr><td align="left" valign="top"><p>SOUND</p></td><td align="left" valign="top"><p>Tones</p></td><td align="left" valign="top"><p>A library for sound and tone generation</p></td></tr><tr><td align="left" valign="top"><p>STDBASIC</p></td><td align="left" valign="top"><p>Utility Functions</p></td><td align="left" valign="top"><p>The library that contains many of the utility methods.</p></td></tr><tr><td align="left" valign="top"><p>STRING</p></td><td align="left" valign="top"><p>String</p></td><td align="left" valign="top"><p>The library that contains the string methods.</p></td></tr><tr><td align="left" valign="top"><p>SYSTEM</p></td><td align="left" valign="top"><p>System</p></td><td align="left" valign="top"><p>The library that contains the system methods.</p></td></tr><tr><td align="left" valign="top"><p>TIMER</p></td><td align="left" valign="top"><p>Timers</p></td><td align="left" valign="top"><p>The library that contains the timer methods.</p></td></tr><tr><td align="left" valign="top"><p>USART</p></td><td align="left" valign="top"><p>Serial</p></td><td align="left" valign="top"><p>The library that contains the hardware serial methods that use the MSSP or AVR equivilent hardware module.</p></td></tr><tr><td align="left" valign="top"><p>XPT2046</p></td><td align="left" valign="top"><p>Touch Shield</p></td><td align="left" valign="top"><p>A library that interfaces with the APT2026 and the ADS7843 touch sensors.</p></td></tr></tbody></table></div><p><br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="libraries_overview"></span>Libraries Overview
--------------------------------------------------------

</div>

</div>

</div>

<span class="strong">**About Libraries**</span>

GCBASIC (as with most other microcontroller programming languages)
supports libraries.

You can create you own device specific library, you are not limited to
those shown below. If you create a new device specific library - please
submit for inclusion in the next release via the GCBASIC forum.

Maintenance of these libraries is completed by the GCBASIC development
team. If you wish to adapt these libraries you should create a local
copy, edit and save within your development file structure. The
development team may update these libraries as part of a release and we
do not want you to lose your local changes.

To use a library, simple inlcude the following in your user code

``` screen
    #include <3PI.H>    'this will include the 3PI capabilities within your program
```

To use a local copy of a library, simple inlcude the following in your
user code

``` screen
    #include "C:\mydev\library\3pi.h"    'this will include a local copy of the the 3PI capabilities within your program
```

GCBASIC supports the following device libraries.

<div class="informaltable">

| <span class="strong">**Library**</span> | <span class="strong">**Class**</span>    | <span class="strong">**Usage**</span>                                                                                                            |
|:----------------------------------------|:-----------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|
| 3PI                                     | Polulu 3pi robot                         | A library that interfaces the switch and the motors.                                                                                             |
| 47XXX\_EERAM.H                          | I2C EERAM memory                         | A device specific library for the Microchip EERAM device classs                                                                                  |
| ALPS-EC11                               | Rotary Encoder                           | A device specific library for a rotary encoder.                                                                                                  |
| ADS7843                                 | Touch Shield                             | A library that interfaces with the ADS7843 touch screen.                                                                                         |
| BME280                                  | Temp, Humidity and Pressure sensor       | A library that interfaces with the BME280 and the BMP280 sensor.                                                                                 |
| CHIPINO                                 | Shield                                   | A library that interfaces the Chipino board with Arduino like port addresses.                                                                    |
| DHT                                     | Temperature and Humidity                 | A library that supports the DHT22 and the DHT11 Temperature and Humidity sensors.                                                                |
| DS1307                                  | Clock                                    | A library that supports the timer clock and NVRAM functions.                                                                                     |
| DS1672                                  | Clock                                    | A library that supports the timer clock and NVRAM functions.                                                                                     |
| DS18B20                                 | Temperature                              | A library that supports the temperature functions.                                                                                               |
| DS18SB0MultiPort                        | Temperature                              | A library that supports the temperature functions with devices attached to multiple ports.                                                       |
| DS18S20                                 | Temperature                              | A library that supports the temperature functions.                                                                                               |
| DS2482                                  | Clock                                    | A library that supports the I2C to Dallas OneWire functions.                                                                                     |
| DS3231                                  | Clock                                    | A library that supports the timer clock and NVRAM functions.                                                                                     |
| DUEMILANOVE                             | Shield                                   | A library that interfaces the Duemilanove board with Arduino like port addresses.                                                                |
| EMC1001                                 | Temperature                              | A library that supports the temperature functions and the other device capabilities.                                                             |
| FRAM                                    | I2C Eeprom                               | A library that supports memory functions.                                                                                                        |
| GETUSERID                               | Microchip read ID                        | A library that supports the identification of Microchip microcontrollers.                                                                        |
| EPD\_EPD2In13                           | Graphical e-Paper display                | A core library for Graphical LCD support.                                                                                                        |
| EPD\_EPD7in5                            | Graphical e-Paper display                | A core library for Graphical LCD support.                                                                                                        |
| GLCD\_                                  | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_HX8347                            | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_ILI9340                           | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_ILI9341                           | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_ILI9481                           | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_ILI9486L                          | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_NT7108C                           | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_IMAGESANDFONTS\_ADDIN3            | Graphical LCD                            | A library to increase the capabilities of the Graphical LCDs.                                                                                    |
| GLCD\_KS0108                            | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_NEXTION                           | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_PCD8544                           | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_SH1106                            | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_SSD1289                           | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_SSD1306                           | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_SSD1331                           | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_ST7735                            | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_ST7920                            | Graphical LCD                            | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_T6963\_64                         | Graphical T6963 LCD with 240 x 64 pixels | A device specific library for an Graphical LCD.                                                                                                  |
| GLCD\_T6963\_128                        | Graphical T6963 LCD with 240 x 64 pixels | A device specific library for an Graphical LCD.                                                                                                  |
| HEFLASH                                 | HEF Memory Driver                        | A library that supports the HEF memory functions.                                                                                                |
| HMC5883L                                | Triple-axis Magnetometer                 | A library that supports the magnetometer functions.                                                                                              |
| HWI2C\_ISR\_HANDLER                     | I2C Slave Driver                         | A library that supports the use of a Microchip microcontroller as an I2C slave.                                                                  |
| HWI2C\_MESSAGEINTERFACE                 | I2C Slave                                | A support library that supports the use of a Microchip microcontroller as an I2C slave.                                                          |
| HWI2C\_ISR\_HANDLERKMODE                | I2C Slave Driver                         | A library that supports the use of a Microchip microcontroller as an I2C slave.                                                                  |
| HWI2C\_MESSAGEINTERFACEKMODE            | I2C Slave                                | A support library that supports the use of a Microchip microcontroller as an I2C slave.                                                          |
| I2CEEPROM                               | I2C EEProm memory                        | A library that supports memory functions.                                                                                                        |
| LCD2SERIALREDIRECT                      | LCD to Serial Handler                    | A library that supports the use of a serial and PC terminal as a psuedo LCD.                                                                     |
| LEGO-PF                                 | Lego Mindstorms shield                   | A library that supports the Lego Mindstorms robot                                                                                                |
| LEGO                                    | Lego Mindstorms shield                   | A library that supports the Lego Mindstorms robot                                                                                                |
| MATHS                                   | Maths routines                           | A library that supports maths functions such as logs, power and atan.                                                                            |
| MAX6675                                 | Temperature                              | A library that supports the temperature functions.                                                                                               |
| MAX7219\_ledmatrix\_driver              | LED 8\*8 Matrix driver                   | A library that supports the MAX7219 8\*8 LED matrixes                                                                                            |
| MCP23008                                | i2C to serial                            | A library that supports the I2C to serial functions.                                                                                             |
| MCP23017                                | i2C to serial                            | A library that supports the I2C to serial functions.                                                                                             |
| MCP4XXXDIGITALPOT                       | Digital Pot                              | A library that supports the MCPxxxx range of digital potentiometers.                                                                             |
| MCP7940N                                | Clock                                    | A library that supports the timer clock and NVRAM functions.                                                                                     |
| MILLIS                                  | Clock                                    | A library that supports the 1000ms timer event cycle.                                                                                            |
| NUNCHUCK                                | Game controller                          | A library that supports the NunChuck game controller.                                                                                            |
| PCA9685                                 | PWM                                      | A device specific library for the 16channel PWM driver. See the demonstrations for example on usage. Support up to four devices via the I2C bus. |
| PCF8574                                 | GLCD                                     | A device specific library for an Graphical LCD.                                                                                                  |
| PCF85X3                                 | Clock                                    | A library that supports the timer clock and alarms.                                                                                              |
| SD                                      | SD Card                                  | A device specific library for an SD Card.                                                                                                        |
| SMT\_Timers                             | Signal Measurment Timer                  | A library for Signal Measurment Timer for specific Microchip microcontrollers.                                                                   |
| SOFTSERIAL                              | Serial                                   | A library for software serial.                                                                                                                   |
| SOFTSERIALCH1                           | Serial                                   | A library for software serial.                                                                                                                   |
| SOFTSERIALCH2                           | Serial                                   | A library for software serial.                                                                                                                   |
| SOFTSERIALCH3                           | Serial                                   | A library for software serial.                                                                                                                   |
| SONGLAY                                 | Music                                    | A library for play music. Supports QBASIC and RTTTL format.                                                                                      |
| SONYREMOTE                              | Infrared                                 | A library that supports the functions of a Sony remote control.                                                                                  |
| SRF02                                   | Distance Sensor                          | A library that supports the SRF02 ultrasonic sensor.                                                                                             |
| SRAM                                    | Memory devices                           | A library that supports 23LC1024, 23LCV1024, 23LC1024, 23A1024, 23LCV512, 23LC512, 23A512, 23K256, 23A256, 23A640 or 23K640 devices              |
| SRF04                                   | Distance Sensor                          | A library that supports the SRF04 ultrasonic sensor.                                                                                             |
| TEA5767                                 | I2C Radio                                | A library that supports the TEA5767 radio.                                                                                                       |
| TM1637                                  | 7 Segment LED display                    | A library that supports the TM1637 7-Segment LED displays                                                                                        |
| TRIG2PLACES                             | Maths functions                          | A maths library that supports trignometry to two places.                                                                                         |
| TRIG3PLACES                             | Maths functions                          | A maths library that supports trignometry to three places                                                                                        |
| TRIG4PLACES                             | Maths functions                          | A maths library that supports trignometry to four places                                                                                         |
| UNO\_MEGA328P                           | Shield                                   | A library that interfaces the shield with Arduino like port addresses.                                                                           |
| USB                                     | USB Supoort                              | A library that interfaces the USB for 16f and 18f microcontrollers.                                                                              |

</div>

  

  
GCBASIC supports the following core libraries. These libraries are
automatically included in your user program therefore you do not need to
use '\#include' to access the libraries capabilities.

<div class="informaltable">

| <span class="strong">**Library**</span> | <span class="strong">**Class**</span> | <span class="strong">**Usage**</span>                                                                      |
|:----------------------------------------|:--------------------------------------|:-----------------------------------------------------------------------------------------------------------|
| 7SEGMENT                                | 7 Segment LED display                 | A library that interfaces the device. See also TM1637a library.                                            |
| A-D                                     | Analog to Digital                     | A library that supports the ADC functionality.                                                             |
| EEPROM                                  | EEProm                                | A library that supports I2C eeprom devices.                                                                |
| HWI2C                                   | I2C                                   | A library that supports the MSSP and TWI hardware modules of I2C                                           |
| HWI2C2                                  | I2C                                   | A library that supports the MSSP and TWI hardware modules of I2C on channel two                            |
| HWSPI                                   | SPI                                   | A library that supports the MSSP and TWI hardware modules of SPI                                           |
| I2C                                     | I2C                                   | A library that supports software I2C                                                                       |
| KEYPAD                                  | KeyPad                                | A library that supports a keypad.                                                                          |
| PS2                                     | I2C                                   | A library that supports keyboard functionality                                                             |
| LCD                                     | LCD                                   | A library that supports LCD functionality, library supports many different communications methods.         |
| PWM                                     | Pulse Width Modulation                | A library supports PWM functionality.                                                                      |
| RANDOM                                  | Random Numbers                        | A library supports random number functionality.                                                            |
| REMOTE                                  | Infrared                              | A library that supports the functions of a NEC remote control.                                             |
| RS232                                   | Serial                                | A library for serial communications.                                                                       |
| SOUND                                   | Tones                                 | A library for sound and tone generation                                                                    |
| STDBASIC                                | Utility Functions                     | The library that contains many of the utility methods.                                                     |
| STRING                                  | String                                | The library that contains the string methods.                                                              |
| SYSTEM                                  | System                                | The library that contains the system methods.                                                              |
| TIMER                                   | Timers                                | The library that contains the timer methods.                                                               |
| USART                                   | Serial                                | The library that contains the hardware serial methods that use the MSSP or AVR equivilent hardware module. |
| XPT2046                                 | Touch Shield                          | A library that interfaces with the APT2026 and the ADS7843 touch sensors.                                  |

</div>

  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Line</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_glcdwritebyte.html" title="GLCDWriteByte"><link rel="next" href="_hyperbole.html" title="Hyperbole"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_line"></a>Line</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Line(LineX1,LineY1, LineX2, LineY2, Optional LineColour = 1)</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Draws a line on a GLCD from pixel X1, Y1 location to pixel X2,Y2 location.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #include &lt;glcd.h&gt;

    line 0,0,127,63
    line 0,63,127,0
    line 40,0,87,63
    line 40,63,87,0</pre><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/lineb1.PNG" align="middle" alt="graphic"></div></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="line"></span>Line

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Line(LineX1,LineY1, LineX2, LineY2, Optional LineColour = 1)
```

<span class="strong">**Explanation:**</span>

Draws a line on a GLCD from pixel X1, Y1 location to pixel X2,Y2
location.

<span class="strong">**Example:**</span>

``` screen
    #include <glcd.h>

    line 0,0,127,63
    line 0,63,127,0
    line 40,0,87,63
    line 40,63,87,0
```

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/lineb1.PNG)

</div>

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Line Continuation</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_comments.html" title="Comments"><link rel="next" href="_conditions.html" title="Conditions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_line_continuation"></a>Line Continuation</h3></div></div></div><p><span class="strong"><strong>About Line Continuation</strong></span></p><p>A single _ (underscore) character at the end of a line of code tells the compiler that the line continues in the next line.  This allows a single statement (line of code) to be spread across multiple lines in the input file, which can provide nice formatting.</p><p>Be careful when adding the _ line continuation character right behind an identifier or keyword. It MUST be separated with at least <span class="strong"><strong>one space</strong></span> character, otherwise it would be treated as part of the identifier or keyword.</p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    #CHIP 18f27k42

    Dim sMyString As String
        sMyString ="one _
                   two _
                   three _
                   four _
                   five _
                   six _
                   seven _
                   eight _
                   nine _
                   ten _
                   eleven _
                   twelve _
                   thirteen _
                   fourteen _
                   fifteen _
                   sixteen _
                   seventeen _
                   eighteen _
                   nineteen _
                   twenty _
                   twentyOne _
                   twentyTwo _
                   twentyThree _
                   twentyFour _
                   twentyFive"

    HSerPrint sMyString</pre><p>This example will print on the serial terminal the string "one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty twentyOne twentyTwo twentyThree twentyFour twentyFive"</p><p><span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    Sub Aiguillages (In voie_principale As Byte, _
                     In voie_marchandises As Byte, _
                     In voie_gravier As Byte)

        ' code segment
        ' code segment
        ' code segment

    End Sub</pre><p>This example improves the layout of definition of the sub-routine.</p><p><span class="strong"><strong>Example 3:</strong></span></p><pre class="screen"> #DEFINE Ouvrir_voie_marchandises Aiguillages _
              (0, Marche_avant, Marche_arriere)</pre><p>This example creates a constants over two lines.  This improves readability.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="line_continuation"></span>Line Continuation

</div>

</div>

</div>

<span class="strong">**About Line Continuation**</span>

A single \_ (underscore) character at the end of a line of code tells
the compiler that the line continues in the next line. This allows a
single statement (line of code) to be spread across multiple lines in
the input file, which can provide nice formatting.

Be careful when adding the \_ line continuation character right behind
an identifier or keyword. It MUST be separated with at least <span
class="strong">**one space**</span> character, otherwise it would be
treated as part of the identifier or keyword.

<span class="strong">**Example 1:**</span>

``` screen
    #CHIP 18f27k42

    Dim sMyString As String
        sMyString ="one _
                   two _
                   three _
                   four _
                   five _
                   six _
                   seven _
                   eight _
                   nine _
                   ten _
                   eleven _
                   twelve _
                   thirteen _
                   fourteen _
                   fifteen _
                   sixteen _
                   seventeen _
                   eighteen _
                   nineteen _
                   twenty _
                   twentyOne _
                   twentyTwo _
                   twentyThree _
                   twentyFour _
                   twentyFive"

    HSerPrint sMyString
```

This example will print on the serial terminal the string "one two three
four five six seven eight nine ten eleven twelve thirteen fourteen
fifteen sixteen seventeen eighteen nineteen twenty twentyOne twentyTwo
twentyThree twentyFour twentyFive"

<span class="strong">**Example 2:**</span>

``` screen
    Sub Aiguillages (In voie_principale As Byte, _
                     In voie_marchandises As Byte, _
                     In voie_gravier As Byte)

        ' code segment
        ' code segment
        ' code segment

    End Sub
```

This example improves the layout of definition of the sub-routine.

<span class="strong">**Example 3:**</span>

``` screen
 #DEFINE Ouvrir_voie_marchandises Aiguillages _
              (0, Marche_avant, Marche_arriere)
```

This example creates a constants over two lines. This improves
readability.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Liquid Crystal Display</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_ads_7843_serial_driver.html" title="ADS 7843 Serial Driver"><link rel="next" href="_lcd_overview.html" title="LCD Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_liquid_crystal_display"></a>Liquid Crystal Display</h3></div></div></div><p>This is the LCD section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="liquid_crystal_display"></span>Liquid Crystal Display

</div>

</div>

</div>

This is the LCD section of the Help file. Please refer the sub-sections
for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Locate</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_lcdwritechar.html" title="LCDWriteChar"><link rel="next" href="_print.html" title="Print"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_locate"></a>Locate</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Locate <span class="emphasis"><em>Line, Column</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The Locate command is used to move the cursor on the LCD to the given
location.</p><p><code class="literal">Line</code> is line number on the LCD display. A byte value from 0 to 255.</p><p><code class="literal">Column</code> is column number on the LCD display. A byte value from 0 to 255.</p><p><span class="strong"><strong>Example :</strong></span></p><pre class="screen">    'A Hello World program for GCBASIC.
    'Uses Locate to show "World" on the second line

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Main routine
    Print "Hello"
    Locate 1, 5
    Print "World"</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_lcd_overview.html" title="LCD Overview">LCD Overview</a></p><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="locate"></span>Locate

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Locate Line, Column
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The Locate command is used to move the cursor on the LCD to the given
location.

`Line` is line number on the LCD display. A byte value from 0 to 255.

`Column` is column number on the LCD display. A byte value from 0 to
255.

<span class="strong">**Example :**</span>

``` screen
    'A Hello World program for GCBASIC.
    'Uses Locate to show "World" on the second line

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Main routine
    Print "Hello"
    Locate 1, 5
    Print "World"
```

<span class="strong">**For more help, see**</span>
<a href="lcd_overview" class="link" title="LCD Overview">LCD Overview</a>

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LockPPS</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_peripheral_pin_select.html" title="Peripheral Pin Select"><link rel="prev" href="_unlockpps.html" title="UnLockPPS"><link rel="next" href="_compiler_directives.html" title="Compiler Directives"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_lockpps"></a>LockPPS</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    LOCKPSS</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Peripheral Pin Select (PPS) has an operation mode in which all input and output selections can be prevented to stop  inadvertent changes.</p><p>PPS selections are locked by setting by the use of the <code class="literal">LockPPS</code> command.</p><p>Using this command will ensure the special sequence of Microchip assembler is handled correctly.</p><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip microcontrollers only.</p><pre class="screen">    #chip 16f18855,32
    #option explicit

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      UNLOCKPPS
        RC0PPS = 0x0010       'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011       'RC1-&gt;EUSART:RX;

        SSP1CLKPPS = 0x14     'RC3-&gt;MSSP1:SCL1;
        SSP1DATPPS = 0x13     'RC4-&gt;MSSP1:SDA1;
        RC3PPS = 0x15         'RC3-&gt;MSSP1:SCL1;
        RC4PPS = 0x14         'RC4-&gt;MSSP1:SDA1;
      LOCKPPS
    End Sub</pre><p><span class="strong"><strong>For more help, see: <a class="link" href="_unlockpps.html" title="UnLockPPS">UnlockPPS</a>.</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="lockpps"></span>LockPPS

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    LOCKPSS
```

<span class="strong">**Explanation:**</span>

Peripheral Pin Select (PPS) has an operation mode in which all input and
output selections can be prevented to stop inadvertent changes.

PPS selections are locked by setting by the use of the `LockPPS`
command.

Using this command will ensure the special sequence of Microchip
assembler is handled correctly.

<span class="strong">**Command Availability:**</span>

Available on all Microchip microcontrollers only.

``` screen
    #chip 16f18855,32
    #option explicit

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      UNLOCKPPS
        RC0PPS = 0x0010       'RC0->EUSART:TX;
        RXPPS  = 0x0011       'RC1->EUSART:RX;

        SSP1CLKPPS = 0x14     'RC3->MSSP1:SCL1;
        SSP1DATPPS = 0x13     'RC4->MSSP1:SDA1;
        RC3PPS = 0x15         'RC3->MSSP1:SCL1;
        RC4PPS = 0x14         'RC4->MSSP1:SDA1;
      LOCKPPS
    End Sub
```

<span class="strong">**For more help, see:
<a href="unlockpps" class="link" title="UnLockPPS">UnlockPPS</a>.**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Log10</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_logarithms.html" title="Logarithms"><link rel="prev" href="_loge.html" title="Loge"><link rel="next" href="_power.html" title="Power"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_log10"></a>Log10</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    returned_word_variable = Log10 (<span class="emphasis"><em>word_value</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Log10</code> command will return the base-10 logarithm, to 2 decimal places.</p><p>The values returned are fixed-point numbers, with two decimal places assumed on the right. or if you prefer, think of the values as being scaled up by 100.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    dim log_value as word
    log_value = log10 ( 10 )      'return 230 equate to 2.30</pre><p><span class="strong"><strong>Supported in &lt;MATHS.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="log10"></span>Log10

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    returned_word_variable = Log10 (word_value)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Log10` command will return the base-10 logarithm, to 2 decimal
places.

The values returned are fixed-point numbers, with two decimal places
assumed on the right. or if you prefer, think of the values as being
scaled up by 100.

<span class="strong">**Example:**</span>

``` screen
    dim log_value as word
    log_value = log10 ( 10 )      'return 230 equate to 2.30
```

<span class="strong">**Supported in &lt;MATHS.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Log2</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_logarithms.html" title="Logarithms"><link rel="prev" href="_logarithms.html" title="Logarithms"><link rel="next" href="_loge.html" title="Loge"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_log2"></a>Log2</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    returned_word_variable = Log2 ( <span class="emphasis"><em>word_value</em></span> )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Log2</code> command will return the base-2 logarithm, to 2 decimal places.</p><p>The values returned are fixed-point numbers, with two decimal places assumed on the right. or if you prefer, think of the values as being scaled up by 100.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    dim log_value as word
    log_value = log2 ( 10 )   'return 3321 equate to 3.321</pre><p><span class="strong"><strong>Supported in &lt;MATHS.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="log2"></span>Log2

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    returned_word_variable = Log2 ( word_value )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Log2` command will return the base-2 logarithm, to 2 decimal
places.

The values returned are fixed-point numbers, with two decimal places
assumed on the right. or if you prefer, think of the values as being
scaled up by 100.

<span class="strong">**Example:**</span>

``` screen
    dim log_value as word
    log_value = log2 ( 10 )   'return 3321 equate to 3.321
```

<span class="strong">**Supported in &lt;MATHS.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Logarithms</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_maths.html" title="Maths"><link rel="prev" href="_difference.html" title="Difference"><link rel="next" href="_log2.html" title="Log2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_logarithms"></a>Logarithms</h4></div></div></div><p><span class="strong"><strong>Explanation:</strong></span></p><p>GCBASIC support logarithmic functions through the include file &lt;maths.h&gt;.</p><p>These functions compute base 2, base e and base 10 logarithms accurate to 2 decimal places, +/- 0.01.</p><p>The values returned are fixed-point numbers, with two decimal places assumed on the right. Or if you prefer, think of the values as being scaled up by 100.</p><p>The input arguments are word-sized integers, 1 to 65535. Remember, logarithms are not defined for non-positive numbers. It is the calling program&#8217;s responsibility to avoid these. Output values are also word-sized.</p><p>Local variables consume 9 bytes, while the function parameters consume another 4 bytes, for a grand total of 13 bytes of RAM used. The lookup table takes 35 words of program memory.</p><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_log10.html" title="Log10">Log10</a>, <a class="link" href="_log2.html" title="Log2">Log2</a>, <a class="link" href="_loge.html" title="Loge">Loge</a></p><p><span class="strong"><strong>Supported in &lt;MATHS.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="logarithms"></span>Logarithms

</div>

</div>

</div>

<span class="strong">**Explanation:**</span>

GCBASIC support logarithmic functions through the include file
&lt;maths.h&gt;.

These functions compute base 2, base e and base 10 logarithms accurate
to 2 decimal places, +/- 0.01.

The values returned are fixed-point numbers, with two decimal places
assumed on the right. Or if you prefer, think of the values as being
scaled up by 100.

The input arguments are word-sized integers, 1 to 65535. Remember,
logarithms are not defined for non-positive numbers. It is the calling
program’s responsibility to avoid these. Output values are also
word-sized.

Local variables consume 9 bytes, while the function parameters consume
another 4 bytes, for a grand total of 13 bytes of RAM used. The lookup
table takes 35 words of program memory.

<span class="strong">**For more help, see**</span>
<a href="log10" class="link" title="Log10">Log10</a>,
<a href="log2" class="link" title="Log2">Log2</a>,
<a href="loge" class="link" title="Loge">Loge</a>

<span class="strong">**Supported in &lt;MATHS.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Loge</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_logarithms.html" title="Logarithms"><link rel="prev" href="_log2.html" title="Log2"><link rel="next" href="_log10.html" title="Log10"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_loge"></a>Loge</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    returned_word_variable = Loge ( <span class="emphasis"><em>word_value</em></span> )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Loge</code> command will return the base-e logarithm, to 2 decimal places.</p><p>The values returned are fixed-point numbers, with two decimal places assumed on the right. or if you prefer, think of the values as being scaled up by 100.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    dim log_value as word
    log_value = loge ( 10 )</pre><p><span class="strong"><strong>Supported in &lt;MATHS.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="loge"></span>Loge

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    returned_word_variable = Loge ( word_value )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Loge` command will return the base-e logarithm, to 2 decimal
places.

The values returned are fixed-point numbers, with two decimal places
assumed on the right. or if you prefer, think of the values as being
scaled up by 100.

<span class="strong">**Example:**</span>

``` screen
    dim log_value as word
    log_value = loge ( 10 )
```

<span class="strong">**Supported in &lt;MATHS.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>LongToBin</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_integertobin.html" title="IntegerToBin"><link rel="next" href="_wordtobin.html" title="WordToBin"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_longtobin"></a>LongToBin</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>stringvar</em></span> = LongToBin(<span class="emphasis"><em>longvar</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">LongToBin</code> function creates a string of a ANSI (32) characters.
The function converts a number to a string consisting of ones and zeros that represents the binary value.</p><p><span class="strong"><strong>Note:</strong></span>
Supports LONG variables only.  For BYTE variables use <code class="literal">VarToBin</code>, for WORD variables use <code class="literal">VarWToBinand</code> for INTEGER variables use <code class="literal">VarIntegerToBin</code></p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    string = LongToBin( 1 )   ' Returns "0000000000000001"

    string = LongToBin( 254 ) ' Returns "0000000011111110"</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="">VarToBin</a>, <a class="link" href="">VarWToBin</a>, <a class="link" href="">VarIntegerToBin</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="longtobin"></span>LongToBin

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    stringvar = LongToBin(longvar)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `LongToBin` function creates a string of a ANSI (32) characters. The
function converts a number to a string consisting of ones and zeros that
represents the binary value.

<span class="strong">**Note:**</span> Supports LONG variables only. For
BYTE variables use `VarToBin`, for WORD variables use `VarWToBinand` for
INTEGER variables use `VarIntegerToBin`

<span class="strong">**Example:**</span>

``` screen
    string = LongToBin( 1 )   ' Returns "0000000000000001"

    string = LongToBin( 254 ) ' Returns "0000000011111110"
```

<span class="strong">**For more help, see**</span>
<a href="" class="link">VarToBin</a>,
<a href="" class="link">VarWToBin</a>,
<a href="" class="link">VarIntegerToBin</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Lookup Tables</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_labels.html" title="Labels"><link rel="next" href="_miscellaneous.html" title="Miscellaneous"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_lookup_tables"></a>Lookup Tables</h3></div></div></div><p><span class="strong"><strong>About Lookup Tables</strong></span></p><p>A lookup table is a list of values that are stored in the memory of the microcontroller, which then can be accessed using the <code class="literal">ReadTable</code> command.</p><p>The advantage of lookup tables is that they are memory efficient,
compared to an equivalent set of alternative command statements.</p><p>Data tables are defined as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">a single value on each line</li><li class="listitem">byte, word, longs and integer values are valid.&nbsp;&nbsp;</li><li class="listitem">Strings must be expressed as ASCII byte value(s)</li><li class="listitem">multiple elements on a single line separated by commas</li><li class="listitem">constants and calculations within the single line data table entries are permitted</li><li class="listitem">an external data source file</li><li class="listitem">decimal values are NOT supported
<br>
<br></li></ol></div><p><span class="strong"><strong>Defining Tables</strong></span></p><p><span class="emphasis"><em>Single data values</em></span></p><p>A single value on each line with in the table.&nbsp;&nbsp;The example table, shown below, has the data on different line in within the table.</p><pre class="screen">    Table TestDataSource
        12
        24
        36
        48
        60
        72
    End Table

    Dim TableCounter, Invalue as byte

    CLS
    For TableCounter = 1 to 6
      ReadTable  TestDataSource, TableCounter, Invalue
      Print InValue
      Print ","
    Next</pre><p><span class="emphasis"><em>Multiple data values of the same line</em></span></p><p>Multiple elements on a single line separated by commas.&nbsp;&nbsp;The example table, shown below, has the data separated by <code class="literal">,</code> and on different line in within the table.</p><pre class="screen">    Table TestDataSource
        12,  24, 36
        48,  60, 72
    End Table

    Dim TableCounter, Invalue as byte

    CLS
    For TableCounter = 1 to 6
      ReadTable  TestDataSource, TableCounter, Invalue
      Print InValue
      Print ","
    Next</pre><p><span class="emphasis"><em>Data values as constants, and, with data transformation</em></span></p><p>Constants and calculations within the single line.  &nbsp;&nbsp;The example table, shown below, uses a defined constant to multiple the data with the table.</p><pre class="screen">#define calculation_constant 2

    Table TestDataSource
      1 * calculation_constant
      2 * calculation_constant
      3 * calculation_constant
      8 * calculation_constant
      4 * calculation_constant
      5 * calculation_constant
    End Table

    Dim TableCounter, Invalue as byte

    CLS
    For TableCounter = 1 to 6
      ReadTable  TestDataSource, TableCounter, Invalue
      Print InValue
      Print ","
    Next</pre><p>&nbsp;&nbsp;
&nbsp;&nbsp;</p><p><span class="emphasis"><em>Data values as Strings</em></span></p><p>Strings can be defined.&nbsp;&nbsp;Strings are delimited by double quotes. &nbsp;&nbsp; The following examples show the methods.</p><p>Any ASCII characters between any two "    " (double quotes) will be converted to table data.&nbsp;&nbsp; Also see ASCII escape codes.</p><p>A source string can be one string per line or comma separated strings, therefore, on the same line.</p><p>Simple Example 1.</p><pre class="screen">    Table Test_1
     "ABCDEFGHIJ"
    End Table</pre><p>Simple Example 2.</p><pre class="screen">    '
    Table  MnuTxt_1  'Home disp
       "  Display_1    Display_2    Display_3  "
    End Table

    Table MnuTxt_2   'Main Menu
     "1: Display"       ' Main1
     "2: System Setup"  ' Main2
     "3: Config 1"      ' Main3
     "4: Config 2"      ' Main4
     "5: Data Log"      ' Main5
     "6: Diagnostic"    ' Main6
     "7: Help+"         ' Main7
    End Table</pre><p>The following 2 table lines produce the same table data.</p><pre class="screen">    "String1","String2", "String3"
    "String1String2String3"</pre><p>And, the following 3 table lines produce the same table data.</p><pre class="screen">    "String1"
    "String2"
    "String3"</pre><p><span class="emphasis"><em>ASCII Escape code</em></span></p><p>Accepted escape strings are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Escape sequence</th><th align="left" valign="top">Meaning</th></tr></thead><tbody><tr><td align="left" valign="top"><p>\a</p></td><td align="left" valign="top"><p>beep</p></td></tr><tr><td align="left" valign="top"><p>\b</p></td><td align="left" valign="top"><p>backspace</p></td></tr><tr><td align="left" valign="top"><p>\f</p></td><td align="left" valign="top"><p>formfeed</p></td></tr><tr><td align="left" valign="top"><p>\l or \n</p></td><td align="left" valign="top"><p>newline</p></td></tr><tr><td align="left" valign="top"><p>\r</p></td><td align="left" valign="top"><p>carriage return</p></td></tr><tr><td align="left" valign="top"><p>\t</p></td><td align="left" valign="top"><p>tab</p></td></tr><tr><td align="left" valign="top"><p>\0</p></td><td align="left" valign="top"><p>Nul value, equates to ASCII 0. Same as \&amp;000</p></td></tr><tr><td align="left" valign="top"><p>\&amp;nnn</p></td><td align="left" valign="top"><p>ascii char in decimal</p></td></tr><tr><td align="left" valign="top"><p>\\</p></td><td align="left" valign="top"><p>backslash</p></td></tr><tr><td align="left" valign="top"><p>\"</p></td><td align="left" valign="top"><p>double quote</p></td></tr><tr><td align="left" valign="top"><p>\'</p></td><td align="left" valign="top"><p>single quote</p></td></tr></tbody></table></div><p><span class="strong"><strong>Using Lookup Tables</strong></span></p><p>First, the table must be created. The code to create a lookup table is
simple - a line that has <code class="literal">Table</code> and then the name of the table, a list
of numbers (up to 10,000 elements), and then <code class="literal">End Table</code>.</p><p>For tables with more than 255 elements it is mandated to used a WORD variable to read the size of the table. See below for an example.</p><p>Once the table is created, the <code class="literal">ReadTable</code> command is used to read data
from it. The <code class="literal">ReadTable</code> command requires the name of the table it is to
read, the location of the item to retrieve, and a variable to store the
retrieved number in.</p><p>Lookup tables can store byte, word, longs and integer values.&nbsp;&nbsp;
GCBASIC will try automatically detect the type of the table depending on the values in it.&nbsp;&nbsp;
GCBASIC can be explicitly instructed to cast the table to a variable type, as follows:</p><pre class="screen">    Table TestDataSource as [Byte | Word | Integer | Long ]
        12
        24
        36
        48
        60
        72
    End Table</pre><p><span class="emphasis"><em>Addresssing the Table Data</em></span></p><p>Item 0 of a lookup table stores the size of the table.
If the <code class="literal">ReadTable</code> command attempts to read beyond the end (number of data items) of the table, the value 0 will be returned.
For tables with more than 255 elements it is <span class="strong"><strong>mandatory</strong></span> to use a WORD variable to read the size of the table. See example below.</p><pre class="screen">    dim lengthoftable as word

    readtable TestDataSource , 0, lengthoftable
    print lengthoftable  ; will print the size as a word

    table TestDataSource
    'a table with more than 255 elements
    ... 'item 1
    ...
    ...
    ...  'item 1027
    end table</pre><p><span class="emphasis"><em>Importing External Text File for table conversion</em></span></p><p>An external file can be used as the table data source.&nbsp;&nbsp;
The file will be read into the specified table name from the external file.&nbsp;&nbsp;
The source file will be treated as a byte value file.</p><p>An example file is shown below:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/lookuptablesb1.PNG" align="middle" alt="graphic"></div></div><p>The following program will import the external data file.</p><pre class="screen">    #chip 16f877a

    Table TestDataSource from "sourcefile.raw"

    for nn = 1 to 10
      ReadTable TestDataSource, nn, inc
      Print inc
    next</pre><p>And the program will out the following:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/lookuptablesb2.PNG" align="middle" alt="graphic"></div></div><p><br>
<br></p><p><span class="emphasis"><em>Advanced use of Lookup Tables - using EEPROM for Table data storage</em></span></p><p>You can use the <code class="literal">Table</code> statement to store the data table in EEPROM. If
the compiler is told to store a data table in "Data" memory, it will
store it in the EEPROM.</p><p><span class="strong"><strong>NOTE</strong></span>
The limitation of of using EPPROM tables is that you can only
store BYTEs. You cannot store WORD values in the EEPROM tables.</p><p>Example code:</p><pre class="screen">    #chip 16F628

    'Read table item
    'Must use ReadTable and a variable for the index, or the table will not be downloaded to EEPROM

    TableLoc = 2
    ReadTable TestDataSource, TableLoc, SomeVar

    'Write to table , this is not required
    EPWrite 1, 45

    'Table of values to write to EEPROM
    'EEPROM location 0 will store length of table
    'Subsequent locations will each store a value

    Table TestDataSource Store Data
        12
        24
        36
        48
        60
        72
    End Table</pre><p><br>
<br></p><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_readtable.html" title="ReadTable">ReadTable</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="lookup_tables"></span>Lookup Tables

</div>

</div>

</div>

<span class="strong">**About Lookup Tables**</span>

A lookup table is a list of values that are stored in the memory of the
microcontroller, which then can be accessed using the `ReadTable`
command.

The advantage of lookup tables is that they are memory efficient,
compared to an equivalent set of alternative command statements.

Data tables are defined as follows:

<div class="orderedlist">

1.  a single value on each line
2.  byte, word, longs and integer values are valid.  
3.  Strings must be expressed as ASCII byte value(s)
4.  multiple elements on a single line separated by commas
5.  constants and calculations within the single line data table entries
    are permitted
6.  an external data source file
7.  decimal values are NOT supported  
      

</div>

<span class="strong">**Defining Tables**</span>

<span class="emphasis">*Single data values*</span>

A single value on each line with in the table.  The example table, shown
below, has the data on different line in within the table.

``` screen
    Table TestDataSource
        12
        24
        36
        48
        60
        72
    End Table

    Dim TableCounter, Invalue as byte

    CLS
    For TableCounter = 1 to 6
      ReadTable  TestDataSource, TableCounter, Invalue
      Print InValue
      Print ","
    Next
```

<span class="emphasis">*Multiple data values of the same line*</span>

Multiple elements on a single line separated by commas.  The example
table, shown below, has the data separated by `,` and on different line
in within the table.

``` screen
    Table TestDataSource
        12,  24, 36
        48,  60, 72
    End Table

    Dim TableCounter, Invalue as byte

    CLS
    For TableCounter = 1 to 6
      ReadTable  TestDataSource, TableCounter, Invalue
      Print InValue
      Print ","
    Next
```

<span class="emphasis">*Data values as constants, and, with data
transformation*</span>

Constants and calculations within the single line.   The example table,
shown below, uses a defined constant to multiple the data with the
table.

``` screen
#define calculation_constant 2

    Table TestDataSource
      1 * calculation_constant
      2 * calculation_constant
      3 * calculation_constant
      8 * calculation_constant
      4 * calculation_constant
      5 * calculation_constant
    End Table

    Dim TableCounter, Invalue as byte

    CLS
    For TableCounter = 1 to 6
      ReadTable  TestDataSource, TableCounter, Invalue
      Print InValue
      Print ","
    Next
```

     

<span class="emphasis">*Data values as Strings*</span>

Strings can be defined.  Strings are delimited by double quotes.    The
following examples show the methods.

Any ASCII characters between any two " " (double quotes) will be
converted to table data.   Also see ASCII escape codes.

A source string can be one string per line or comma separated strings,
therefore, on the same line.

Simple Example 1.

``` screen
    Table Test_1
     "ABCDEFGHIJ"
    End Table
```

Simple Example 2.

``` screen
    '
    Table  MnuTxt_1  'Home disp
       "  Display_1    Display_2    Display_3  "
    End Table

    Table MnuTxt_2   'Main Menu
     "1: Display"       ' Main1
     "2: System Setup"  ' Main2
     "3: Config 1"      ' Main3
     "4: Config 2"      ' Main4
     "5: Data Log"      ' Main5
     "6: Diagnostic"    ' Main6
     "7: Help+"         ' Main7
    End Table
```

The following 2 table lines produce the same table data.

``` screen
    "String1","String2", "String3"
    "String1String2String3"
```

And, the following 3 table lines produce the same table data.

``` screen
    "String1"
    "String2"
    "String3"
```

<span class="emphasis">*ASCII Escape code*</span>

Accepted escape strings are shown in the table below.

<div class="informaltable">

| Escape sequence | Meaning                                       |
|:----------------|:----------------------------------------------|
| \\a             | beep                                          |
| \\b             | backspace                                     |
| \\f             | formfeed                                      |
| \\l or \\n      | newline                                       |
| \\r             | carriage return                               |
| \\t             | tab                                           |
| \\0             | Nul value, equates to ASCII 0. Same as \\&000 |
| \\&nnn          | ascii char in decimal                         |
| \\\\            | backslash                                     |
| \\"             | double quote                                  |
| \\'             | single quote                                  |

</div>

<span class="strong">**Using Lookup Tables**</span>

First, the table must be created. The code to create a lookup table is
simple - a line that has `Table` and then the name of the table, a list
of numbers (up to 10,000 elements), and then `End Table`.

For tables with more than 255 elements it is mandated to used a WORD
variable to read the size of the table. See below for an example.

Once the table is created, the `ReadTable` command is used to read data
from it. The `ReadTable` command requires the name of the table it is to
read, the location of the item to retrieve, and a variable to store the
retrieved number in.

Lookup tables can store byte, word, longs and integer values.   GCBASIC
will try automatically detect the type of the table depending on the
values in it.   GCBASIC can be explicitly instructed to cast the table
to a variable type, as follows:

``` screen
    Table TestDataSource as [Byte | Word | Integer | Long ]
        12
        24
        36
        48
        60
        72
    End Table
```

<span class="emphasis">*Addresssing the Table Data*</span>

Item 0 of a lookup table stores the size of the table. If the
`ReadTable` command attempts to read beyond the end (number of data
items) of the table, the value 0 will be returned. For tables with more
than 255 elements it is <span class="strong">**mandatory**</span> to use
a WORD variable to read the size of the table. See example below.

``` screen
    dim lengthoftable as word

    readtable TestDataSource , 0, lengthoftable
    print lengthoftable  ; will print the size as a word

    table TestDataSource
    'a table with more than 255 elements
    ... 'item 1
    ...
    ...
    ...  'item 1027
    end table
```

<span class="emphasis">*Importing External Text File for table
conversion*</span>

An external file can be used as the table data source.   The file will
be read into the specified table name from the external file.   The
source file will be treated as a byte value file.

An example file is shown below:

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/lookuptablesb1.PNG)

</div>

</div>

The following program will import the external data file.

``` screen
    #chip 16f877a

    Table TestDataSource from "sourcefile.raw"

    for nn = 1 to 10
      ReadTable TestDataSource, nn, inc
      Print inc
    next
```

And the program will out the following:

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/lookuptablesb2.PNG)

</div>

</div>

  
  

<span class="emphasis">*Advanced use of Lookup Tables - using EEPROM for
Table data storage*</span>

You can use the `Table` statement to store the data table in EEPROM. If
the compiler is told to store a data table in "Data" memory, it will
store it in the EEPROM.

<span class="strong">**NOTE**</span> The limitation of of using EPPROM
tables is that you can only store BYTEs. You cannot store WORD values in
the EEPROM tables.

Example code:

``` screen
    #chip 16F628

    'Read table item
    'Must use ReadTable and a variable for the index, or the table will not be downloaded to EEPROM

    TableLoc = 2
    ReadTable TestDataSource, TableLoc, SomeVar

    'Write to table , this is not required
    EPWrite 1, 45

    'Table of values to write to EEPROM
    'EEPROM location 0 will store length of table
    'Subsequent locations will each store a value

    Table TestDataSource Store Data
        12
        24
        36
        48
        60
        72
    End Table
```

  
  

<span class="strong">**For more help, see**</span>
<a href="readtable" class="link" title="ReadTable">ReadTable</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Ltrim</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_len.html" title="Len"><link rel="next" href="_mid.html" title="Mid"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_ltrim"></a>Ltrim</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>stringvar</em></span> = LTRIM(<span class="emphasis"><em>stringvar</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Ltrim</code> function will trim the 7-bit ASCII space character (value 32) from the LEFT hand side of a string.</p><p>Use <code class="literal">Ltrim</code> on text that you have received from another source that may have irregular spacing at the left hand end of the string.</p><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_trim.html" title="Trim">Trim</a>, <a class="link" href="_rtrim.html" title="Rtrim">Rtrim</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="ltrim"></span>Ltrim

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    stringvar = LTRIM(stringvar)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Ltrim` function will trim the 7-bit ASCII space character (value
32) from the LEFT hand side of a string.

Use `Ltrim` on text that you have received from another source that may
have irregular spacing at the left hand end of the string.

<span class="strong">**See Also**</span>
<a href="trim" class="link" title="Trim">Trim</a>,
<a href="rtrim" class="link" title="Rtrim">Rtrim</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Macros</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_assembler_overview.html" title="Assembler Overview"><link rel="next" href="_macros_overview.html" title="Macros Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_macros"></a>Macros</h2></div></div></div><p>This is the Macros section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="macros"></span>Macros
--------------------------------

</div>

</div>

</div>

This is the Macros section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Macros Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_macros.html" title="Macros"><link rel="prev" href="_macros.html" title="Macros"><link rel="next" href="_example_macros.html" title="Example Macros"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_macros_overview"></a>Macros Overview</h3></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>You can use macros within your GCBASIC code.</p><p>Macros are similar to subroutines. But during compilation, everything is inserted inline. This may increase the code size slightly, but it also reduces stack usage.</p><p>Parameters are handled in a similar way to how constants are handled, so there is a lot more freedom when passing things in to a macro. (Unlike subs or functions, where everything must be stored in a variable.)</p><p>For example, for <code class="literal">PulseOut</code> one parameter is a pin, and the other is a time length like "500 ms". Neither of those parameters could be stored in a variable, but passing them in as macro parameters is possible.</p><p><span class="strong"><strong>Demonstration Program:</strong></span></p><pre class="screen">    'PulseOut Macro
    macro Pulseout (Pin, Time)
        Set Pin On
        Wait Time
        Set Pin Off
    end macro</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="macros_overview"></span>Macros Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

You can use macros within your GCBASIC code.

Macros are similar to subroutines. But during compilation, everything is
inserted inline. This may increase the code size slightly, but it also
reduces stack usage.

Parameters are handled in a similar way to how constants are handled, so
there is a lot more freedom when passing things in to a macro. (Unlike
subs or functions, where everything must be stored in a variable.)

For example, for `PulseOut` one parameter is a pin, and the other is a
time length like "500 ms". Neither of those parameters could be stored
in a variable, but passing them in as macro parameters is possible.

<span class="strong">**Demonstration Program:**</span>

``` screen
    'PulseOut Macro
    macro Pulseout (Pin, Time)
        Set Pin On
        Wait Time
        Set Pin Off
    end macro
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Make ASM, Make HEX and Programming Operations using the provided Linux scripts</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_gcbasic_for_linux.html" title="GCBASIC for Linux"><link rel="prev" href="_overview_linux_operating_system.html" title="Overview - Linux Operating System"><link rel="next" href="_gcbasic_for_arm_pi.html" title="GCBASIC for ARM &amp; Pi"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_make_asm_make_hex_and_programming_operations_using_the_provided_linux_scripts"></a>Make ASM, Make HEX and Programming Operations using the provided Linux scripts</h3></div></div></div><p>The scripts provided are intended to assist in the creation of the ASM file ( from a GCBASIC source file ), creation of the HEX file ( also from a GCBASIC source file ) and to support programming operations ( often called `FLASH`ing the microcontroller ).</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Script</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Usage</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">makeasm.sh</code></p></td><td align="left" valign="top"><p>To compile the GCBASIC source program to create the ASM.</p></td><td align="left" valign="top"><p><code class="literal">makeasm.sh sourcefile.gcb</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">makehex.sh</code></p></td><td align="left" valign="top"><p>To compile and asseble the GCBASIC source program to create the ASM and a microcontroller specific HEX file.</p></td><td align="left" valign="top"><p><code class="literal">makehex.sh sourcefile.gcb</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">flash.sh</code></p></td><td align="left" valign="top"><p>To compile,asseble the GCBASIC source program to create the ASM and a microcontroller specific HEX file, and, then to program the microcontroller</p></td><td align="left" valign="top"><p><code class="literal">flash.sh sourcefile.gcb</code></p></td></tr></tbody></table></div><p><span class="strong"><strong>Examples</strong></span></p><p>There are multiple constructs to run multiple programs on a single command line.&nbsp;&nbsp;The most common are ';' and '&amp;&amp;'</p><p>To run another command immadiately after running makehex.sh.&nbsp;&nbsp;Use the following:</p><pre class="screen">   makehex.sh sourcefile.gcb; anothercommand</pre><p>To run another command only if makehex.sh does not exit with an error such as a compiler error.&nbsp;&nbsp;Use the following:</p><pre class="screen">   makehex.sh sourcefile.gcb &amp;&amp; anothercommand</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="make_asm_make_hex_and_programming_operations_using_the_provided_linux_scripts"></span>Make ASM, Make HEX and Programming Operations using the provided Linux scripts

</div>

</div>

</div>

The scripts provided are intended to assist in the creation of the ASM
file ( from a GCBASIC source file ), creation of the HEX file ( also
from a GCBASIC source file ) and to support programming operations (
often called \`FLASH\`ing the microcontroller ).

<div class="informaltable">

| <span class="strong">**Script**</span> | <span class="strong">**Usage**</span>                                                                                                             | <span class="strong">**Example**</span> |
|:---------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------|
| `makeasm.sh`                           | To compile the GCBASIC source program to create the ASM.                                                                                          | `makeasm.sh sourcefile.gcb`             |
| `makehex.sh`                           | To compile and asseble the GCBASIC source program to create the ASM and a microcontroller specific HEX file.                                      | `makehex.sh sourcefile.gcb`             |
| `flash.sh`                             | To compile,asseble the GCBASIC source program to create the ASM and a microcontroller specific HEX file, and, then to program the microcontroller | `flash.sh sourcefile.gcb`               |

</div>

<span class="strong">**Examples**</span>

There are multiple constructs to run multiple programs on a single
command line.  The most common are ';' and '&&'

To run another command immadiately after running makehex.sh.  Use the
following:

``` screen
   makehex.sh sourcefile.gcb; anothercommand
```

To run another command only if makehex.sh does not exit with an error
such as a compiler error.  Use the following:

``` screen
   makehex.sh sourcefile.gcb && anothercommand
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Maths</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_weak_pullups.html" title="Weak Pullups"><link rel="next" href="_abs.html" title="Abs"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_maths"></a>Maths</h3></div></div></div><p>This is the Maths section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="maths"></span>Maths

</div>

</div>

</div>

This is the Maths section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>MCU EEPROM ( DFM )</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_memory.html" title="Memory"><link rel="prev" href="_memory.html" title="Memory"><link rel="next" href="_epread.html" title="EPRead"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_mcu_eeprom_dfm"></a>MCU EEPROM ( DFM )</h4></div></div></div><p>This is the EEPROM  ( PFM ) section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="mcu_eeprom_dfm"></span>MCU EEPROM ( DFM )

</div>

</div>

</div>

This is the EEPROM ( PFM ) section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Measuring a Pulse Width</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_macros.html" title="Example Macros"><link rel="prev" href="_example_macros.html" title="Example Macros"><link rel="next" href="_implementing_a_method_with_a_pin_name_as_a_parameter.html" title="Implementing a method with a Pin name as a parameter"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_measuring_a_pulse_width"></a>Measuring a Pulse Width</h4></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>The demonstration shows how a macro can be used to optimised code by compiling code inline.</p><p>When the measurement of a pulse width to sub-microsecond resolution is required for instance measuring the high or low pulse width of an incoming analog signal a comparator can be combined with a timer to provide the pulse width.</p><p>Microchip PIC has published a "Compiled Tips 'N Tricks Guide" that explains how to do certain tasks with Microchip PIC 8-bit microcontrollers.</p><p>This guide provides the steps that need to be taken to perform the task of measuring a pulse width.  The guide provides guidance on measuring a pulse width using Timer 1 and the CCP module.  This guidance was used as the basis for the GCBASIC port the shown below.  The guidance was generic and in this example polling the CCP flag bit was more convenient than using an interrupt.</p><p>In this demonstration shown below, a 16F1829 microcontroller operating at 32 Mhz uses the internal oscillator. The demonstration code is based on a macro that uses Timer1 and CCP4. However, any of the four CCP modules could be used, the 16F1829 microcontroller has four CCP module.</p><p>The timer resolution of this method uses a timer Prescaler of 1:8 and a microcontroller frequency of 32 MHz giving a pulse width resolution is 1ms.  With the timer Prescaler of 1:2 and the microcontroller frequency of 32MHz the resolution is 250 ns.</p><p>The accuracy is dependent upon the accuracy of the system clock, but oscilliscope measurements have show an accuracy of +- 1us from 3us to 1000us.</p><p>In this demonstration the following was implemented</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Using GCBASIC a macro to ensure the generated assembler is inline to ensure the timing is consistent and no sub routines are called.</li><li class="listitem">Another microcontroller was used to generate the pulses to be measured</li><li class="listitem">A TEK THS730A oscilliscope was used to measure/verify pulse widths</li><li class="listitem">A 4x20 LDC module with an I2C Backpack was used to display the results. However, as an alternative, a serial output<br>
to a terminal program to view the data could be used</li></ul></div><p>This demonstration could be improved by adding code to poll the TIMER1 overflow flag. If the timer overflows, then either no
pulse was detected or the pulse was longer than allowed by the prescaler/OSC settings. In this case, return a value of zero for pulse width.</p><p><span class="strong"><strong>Usage:</strong></span></p><p>To get positive pulse width use:</p><pre class="screen">    PULSE_IN</pre><p><code class="literal">PULSE_IN</code> returns a global word variable Pulse_Width</p><p><span class="strong"><strong>Demonstration Program:</strong></span></p><pre class="screen">    #Chip 16F1829, 32
    #CONFIG MCLRE = OFF

    'Setup Software I2C
    #define I2C_MODE Master
    #define I2C_DATA PORTA.2
    #define I2C_CLOCK PORTC.0
    #define I2C_DISABLE_INTERRUPTS ON

    'Set up LCD
    #define LCD_IO 10
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_SPEED FAST
    #define LCD_Backlight_On_State  1
    #define LCD_Backlight_Off_State 0

    'Note: This example can be improved by adding code to poll the 'TIMER1 overflow flag. IF the timer overflows, then either no 'pulse was detected or the pulse was longer than allowed by the 'prescaler/OSC settings. In this case, return a value of zero 'for pulse width.

    CLS
    PRINT "Pulse Width Test"
    DIM PULSE_WIDTH AS WORD
    DIR PORTC.6 IN

    'Setup timer
    'Set timer1 using PS1_2 gives 250ns resolution
    InitTimer1 OSC, PS1_8
    wait 1 s
    CLS

    'MAIN PROGRAM LOOP
    DO
      PULSE_IN    'Call the Macro to get positive pulse width.
      Locate 0,0
      PRINT Pulse_Width
      PRINT "    "
      wait 1 s
    Loop

    MACRO PULSE_IN  'Measure Pulse Width
      'Configure CCP4  to Capture rising edge
       CCP4CON = 5   'Set to 00000101
       StartTimer 1
       CCP4IF = 0

       do while CCP4IF = 0    'Wait for rising edge
       loop

       TMR1H = 0: TMR1L = 0   'Clear timer to zero
       CCP4IF = 0             'Clear flag


       'Configure CCP4 to Capture Falling Edge
       CCP4CON = 4  '00000100'

       do while CCP4IF = 0   'Wait for falling edge
       loop

       StopTimer 1            'Stop the time
       Pulse_Width = TIMER1   'Save the timer value
       CCP4IF = 0             'Clear the CCP4 flag
    End MACRO</pre><p>Also see <a class="link" href="_macros_overview.html" title="Macros Overview">Macros Overview</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="measuring_a_pulse_width"></span>Measuring a Pulse Width

</div>

</div>

</div>

<span class="strong">**Introduction**</span>

The demonstration shows how a macro can be used to optimised code by
compiling code inline.

When the measurement of a pulse width to sub-microsecond resolution is
required for instance measuring the high or low pulse width of an
incoming analog signal a comparator can be combined with a timer to
provide the pulse width.

Microchip PIC has published a "Compiled Tips 'N Tricks Guide" that
explains how to do certain tasks with Microchip PIC 8-bit
microcontrollers.

This guide provides the steps that need to be taken to perform the task
of measuring a pulse width. The guide provides guidance on measuring a
pulse width using Timer 1 and the CCP module. This guidance was used as
the basis for the GCBASIC port the shown below. The guidance was generic
and in this example polling the CCP flag bit was more convenient than
using an interrupt.

In this demonstration shown below, a 16F1829 microcontroller operating
at 32 Mhz uses the internal oscillator. The demonstration code is based
on a macro that uses Timer1 and CCP4. However, any of the four CCP
modules could be used, the 16F1829 microcontroller has four CCP module.

The timer resolution of this method uses a timer Prescaler of 1:8 and a
microcontroller frequency of 32 MHz giving a pulse width resolution is
1ms. With the timer Prescaler of 1:2 and the microcontroller frequency
of 32MHz the resolution is 250 ns.

The accuracy is dependent upon the accuracy of the system clock, but
oscilliscope measurements have show an accuracy of +- 1us from 3us to
1000us.

In this demonstration the following was implemented

<div class="itemizedlist">

-   Using GCBASIC a macro to ensure the generated assembler is inline to
    ensure the timing is consistent and no sub routines are called.
-   Another microcontroller was used to generate the pulses to be
    measured
-   A TEK THS730A oscilliscope was used to measure/verify pulse widths
-   A 4x20 LDC module with an I2C Backpack was used to display the
    results. However, as an alternative, a serial output  
    to a terminal program to view the data could be used

</div>

This demonstration could be improved by adding code to poll the TIMER1
overflow flag. If the timer overflows, then either no pulse was detected
or the pulse was longer than allowed by the prescaler/OSC settings. In
this case, return a value of zero for pulse width.

<span class="strong">**Usage:**</span>

To get positive pulse width use:

``` screen
    PULSE_IN
```

`PULSE_IN` returns a global word variable Pulse\_Width

<span class="strong">**Demonstration Program:**</span>

``` screen
    #Chip 16F1829, 32
    #CONFIG MCLRE = OFF

    'Setup Software I2C
    #define I2C_MODE Master
    #define I2C_DATA PORTA.2
    #define I2C_CLOCK PORTC.0
    #define I2C_DISABLE_INTERRUPTS ON

    'Set up LCD
    #define LCD_IO 10
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_SPEED FAST
    #define LCD_Backlight_On_State  1
    #define LCD_Backlight_Off_State 0

    'Note: This example can be improved by adding code to poll the 'TIMER1 overflow flag. IF the timer overflows, then either no 'pulse was detected or the pulse was longer than allowed by the 'prescaler/OSC settings. In this case, return a value of zero 'for pulse width.

    CLS
    PRINT "Pulse Width Test"
    DIM PULSE_WIDTH AS WORD
    DIR PORTC.6 IN

    'Setup timer
    'Set timer1 using PS1_2 gives 250ns resolution
    InitTimer1 OSC, PS1_8
    wait 1 s
    CLS

    'MAIN PROGRAM LOOP
    DO
      PULSE_IN    'Call the Macro to get positive pulse width.
      Locate 0,0
      PRINT Pulse_Width
      PRINT "    "
      wait 1 s
    Loop

    MACRO PULSE_IN  'Measure Pulse Width
      'Configure CCP4  to Capture rising edge
       CCP4CON = 5   'Set to 00000101
       StartTimer 1
       CCP4IF = 0

       do while CCP4IF = 0    'Wait for rising edge
       loop

       TMR1H = 0: TMR1L = 0   'Clear timer to zero
       CCP4IF = 0             'Clear flag


       'Configure CCP4 to Capture Falling Edge
       CCP4CON = 4  '00000100'

       do while CCP4IF = 0   'Wait for falling edge
       loop

       StopTimer 1            'Stop the time
       Pulse_Width = TIMER1   'Save the timer value
       CCP4IF = 0             'Clear the CCP4 flag
    End MACRO
```

Also see
<a href="macros_overview" class="link" title="Macros Overview">Macros Overview</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Memory</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_setwith.html" title="SetWith"><link rel="next" href="_mcu_eeprom_dfm.html" title="MCU EEPROM ( DFM )"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_memory"></a>Memory</h3></div></div></div><p>This is the Memory section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="memory"></span>Memory

</div>

</div>

</div>

This is the Memory section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Microchip PIC PWM Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_pulse_width_modulation.html" title="Pulse width modulation"><link rel="prev" href="_pulse_width_modulation.html" title="Pulse width modulation"><link rel="next" href="_pwm_software_mode.html" title="PWM Software Mode"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_microchip_pic_pwm_overview"></a>Microchip PIC PWM Overview</h4></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>The methods described in this section allow the generation of Pulse
Width Modulation (PWM) signals. PWM signals enables the microcontroller to control
items like the speed of a motor, or the brightness of a LED or lamp.<br></p><p>The methods can also be used to generate the appropriate frequency signal to drive an
infrared LED for remote control applications.<br></p><p>GCBASIC support the four different method shown below:<br>
&nbsp;&nbsp;&nbsp; - Two methods use the microcontroller CCP module<br>
&nbsp;&nbsp;&nbsp; - One method uses the microcontroller PWM module, and<br>
&nbsp;&nbsp;&nbsp; - One method is a software emulation of PWM.<br></p><p><span class="strong"><strong><span class="emphasis"><em>Hardware PWM using a CCP module</em></span></strong></span></p><p>Using PWM with the CCP module:  This option requires a CCP module within the microcontroller.<br></p><p>Hardware PWM is only available through the "CCP" or "CCPx" pin. This is a hardware limitation of Microchip PIC microcontrollers.<br></p><p>Microcontrollers with PPS can change the pin - use the PPS tool to set the desired output pin.<br></p><p>This method uses three parameters to setup the PWM.</p><pre class="screen">    'HPWM channel, frequency, duty cycle
    HPWM 1, 76, 80</pre><p><span class="strong"><strong><span class="emphasis"><em>Hardware PWM using a PWM module</em></span></strong></span></p><p>Using microcontroller PWM module.  This option requires a PWM module within the microcontroller
Microcontrollers with PPS can change the pin - use the PPS tool to set the desired output pin.<br></p><p>This method uses four parameters to setup the PWM.</p><pre class="screen">    'HPWM channel, frequency, duty cycle, timer
    HPWM 5, 76, 80, 2</pre><p><span class="strong"><strong><span class="emphasis"><em>Hardware PWM using the CCP1 in fixed mode</em></span></strong></span></p><p>Using Hardware PWM on fixed mode PWM requires a CCP1 module.</p><p>The fixed mode can use CCP1 only, and, the parameters of the PWM cannot be dynamically changed in the user program.&nbsp;&nbsp;&nbsp;The parameters are fixed by the definition of two constants.</p><pre class="screen">    #define PWM_Freq 76    'Set frequency in KHz
    #define PWM_Duty 80    'Set duty cycle to 80 %

    HPWMOn

    wait 5 s

    HPWMOff</pre><p><span class="strong"><strong><span class="emphasis"><em>Software PWM</em></span></strong></span></p><p>Using Software PWM on requires no specific modules with the microcontroller.<br></p><p>The PWM parameters for duty and the number of pulses can be changed dynamically in the user program.<br></p><p>The PWM is <span class="strong"><strong>only</strong></span> operational for the number of cycles stated in the calling method.<br></p><pre class="screen">    'A call to use the software PWM on the specific port, with a duty of 127 for 100 cycles

    ; ----- Constants
    'PWM constant. This is a required constant.
    #define PWM_Out1 portb.0

  ; ----- Define Hardware settings
    'PWM port out.  This is not required but a good practice.
    dir PWM_Out1 out

    'Pulse the PWM
    PWMOut 1, 127, 100</pre><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>A number of constants are used to control settings for the PWM hardware module of the microcontroller.
To set them, place a line in the main program file that uses #define to assign a value to the particular
constant.<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="microchip_pic_pwm_overview"></span>Microchip PIC PWM Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

The methods described in this section allow the generation of Pulse
Width Modulation (PWM) signals. PWM signals enables the microcontroller
to control items like the speed of a motor, or the brightness of a LED
or lamp.  

The methods can also be used to generate the appropriate frequency
signal to drive an infrared LED for remote control applications.  

GCBASIC support the four different method shown below:  
    - Two methods use the microcontroller CCP module  
    - One method uses the microcontroller PWM module, and  
    - One method is a software emulation of PWM.  

<span class="strong">**<span class="emphasis">*Hardware PWM using a CCP
module*</span>**</span>

Using PWM with the CCP module: This option requires a CCP module within
the microcontroller.  

Hardware PWM is only available through the "CCP" or "CCPx" pin. This is
a hardware limitation of Microchip PIC microcontrollers.  

Microcontrollers with PPS can change the pin - use the PPS tool to set
the desired output pin.  

This method uses three parameters to setup the PWM.

``` screen
    'HPWM channel, frequency, duty cycle
    HPWM 1, 76, 80
```

<span class="strong">**<span class="emphasis">*Hardware PWM using a PWM
module*</span>**</span>

Using microcontroller PWM module. This option requires a PWM module
within the microcontroller Microcontrollers with PPS can change the pin
- use the PPS tool to set the desired output pin.  

This method uses four parameters to setup the PWM.

``` screen
    'HPWM channel, frequency, duty cycle, timer
    HPWM 5, 76, 80, 2
```

<span class="strong">**<span class="emphasis">*Hardware PWM using the
CCP1 in fixed mode*</span>**</span>

Using Hardware PWM on fixed mode PWM requires a CCP1 module.

The fixed mode can use CCP1 only, and, the parameters of the PWM cannot
be dynamically changed in the user program.   The parameters are fixed
by the definition of two constants.

``` screen
    #define PWM_Freq 76    'Set frequency in KHz
    #define PWM_Duty 80    'Set duty cycle to 80 %

    HPWMOn

    wait 5 s

    HPWMOff
```

<span class="strong">**<span class="emphasis">*Software
PWM*</span>**</span>

Using Software PWM on requires no specific modules with the
microcontroller.  

The PWM parameters for duty and the number of pulses can be changed
dynamically in the user program.  

The PWM is <span class="strong">**only**</span> operational for the
number of cycles stated in the calling method.  

``` screen
    'A call to use the software PWM on the specific port, with a duty of 127 for 100 cycles

    ; ----- Constants
    'PWM constant. This is a required constant.
    #define PWM_Out1 portb.0

  ; ----- Define Hardware settings
    'PWM port out.  This is not required but a good practice.
    dir PWM_Out1 out

    'Pulse the PWM
    PWMOut 1, 127, 100
```

<span class="strong">**Relevant Constants:**</span>

A number of constants are used to control settings for the PWM hardware
module of the microcontroller. To set them, place a line in the main
program file that uses \#define to assign a value to the particular
constant.  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Microcontroller Fundamentals</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_uno_as_isp_programmer.html" title="UNO as ISP programmer"><link rel="next" href="_inputs_outputs.html" title="Inputs/Outputs"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_microcontroller_fundamentals"></a>Microcontroller Fundamentals</h2></div></div></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="microcontroller_fundamentals"></span>Microcontroller Fundamentals
----------------------------------------------------------------------------

</div>

</div>

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Mid</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_ltrim.html" title="Ltrim"><link rel="next" href="_pad.html" title="Pad"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_mid"></a>Mid</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>output</em></span> = Mid(<span class="emphasis"><em>source</em></span>, <span class="emphasis"><em>start</em></span>[, <span class="emphasis"><em>count</em></span>])</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Mid</code> function returns a string variable containing a specified number of characters from a source string.</p><p><code class="literal"><span class="emphasis"><em>source</em></span></code> is the variable to extract from.  If <code class="literal"><span class="emphasis"><em>source</em></span></code> is a zero length string - a zero length string is returned equating to "".
<br>
<code class="literal"><span class="emphasis"><em>start</em></span></code> is the position of the first character to extract. If <code class="literal"><span class="emphasis"><em>start</em></span></code> is greater than the number of characters in string, Mid returns a zero-length string equating to "".
<br>
<code class="literal"><span class="emphasis"><em>count</em></span></code> is the number of characters to extract. If <code class="literal"><span class="emphasis"><em>count</em></span></code> is not specified, all characters from <code class="literal"><span class="emphasis"><em>start</em></span></code> to the end of the source string will be returned.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "The cat sat on the mat"

    'Extract "cat". The c is at position 5, and 3 letters are needed
    HSerPrint "The animal is a "
    HSerPrint Mid(TestData, 5, 3)

    'Extract the action. "sat" starts at position 9.
    HSerPrint "The animal "
    HSerPrint Mid(TestData, 9)
    HSerPrintCRLF</pre><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_left.html" title="Left">Left</a>, <a class="link" href="_right.html" title="Right">Right</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="mid"></span>Mid

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    output = Mid(source, start[, count])
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Mid` function returns a string variable containing a specified
number of characters from a source string.

`source` is the variable to extract from. If `source` is a zero length
string - a zero length string is returned equating to "".  
`start` is the position of the first character to extract. If `start` is
greater than the number of characters in string, Mid returns a
zero-length string equating to "".  
`count` is the number of characters to extract. If `count` is not
specified, all characters from `start` to the end of the source string
will be returned.

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "The cat sat on the mat"

    'Extract "cat". The c is at position 5, and 3 letters are needed
    HSerPrint "The animal is a "
    HSerPrint Mid(TestData, 5, 3)

    'Extract the action. "sat" starts at position 9.
    HSerPrint "The animal "
    HSerPrint Mid(TestData, 9)
    HSerPrintCRLF
```

<span class="strong">**See Also**</span>
<a href="left" class="link" title="Left">Left</a>,
<a href="right" class="link" title="Right">Right</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Midpoint Circle Algorithm</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_programs.html" title="Example Programs"><link rel="prev" href="_sonyremote_h.html" title="SonyRemote.h"><link rel="next" href="_i2c_master_hardware.html" title="I2C Master Hardware"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_midpoint_circle_algorithm"></a>Midpoint Circle Algorithm</h3></div></div></div><p><span class="strong"><strong>Explanation:</strong></span></p><p>GCBASIC can draw circles using the midpoint circle algorithm. The midpoint circle algorithm determines the points needed for drawing a circle.
The algorithm is a variant of <a class="link" href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm" target="_top">Bresenham&#8217;s line algorithm</a>, and is thus sometimes known as Bresenham&#8217;s circle algorithm, although not actually invented by <a class="link" href="https://en.wikipedia.org/wiki/Jack_Elton_Bresenham" target="_top">Jack E. Bresenham</a>.</p><p>The example program below show the midpoint circle algorithm within GCBASIC.</p><p><span class="strong"><strong>Example Output on GLCD Device:</strong></span></p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/midpointcirclealgorithmb1.PNG" align="middle" alt="graphic"></div></div><pre class="screen">    'Midpoint Circle algorithm
    'Chip model
    #chip 16F886, 8             ;PIC16F88 running at 8 MHz
    #config mclr=off            ;reset handled internally

    #include &lt;glcd.h&gt;

    ;----- Constants

    ;Pinout is shown for the LCM12864H-FSB-FBW
    ;graphical LCD available from Amazon.

    ;       +5V                 ;LCD pin 1
    ;       ground              ;LCD pin 2
    ;       Vo = wiper of pot   ;LCD pin 3
    #define GLCD_DB0 PORTB.0    ;LCD pin 4
    #define GLCD_DB1 PORTB.1    ;LCD pin 5
    #define GLCD_DB2 PORTB.2    ;LCD pin 6
    #define GLCD_DB3 PORTB.3    ;LCD pin 7
    #define GLCD_DB4 PORTB.4    ;LCD pin 8
    #define GLCD_DB5 PORTB.5    ;LCD pin 9
    #define GLCD_DB6 PORTB.6    ;LCD pin 10
    #define GLCD_DB7 PORTB.7    ;LCD pin 11
    #define GLCD_CS2 PORTA.0    ;LCD pin 12
    #define GLCD_CS1 PORTA.1    ;LCD pin 13
    #define GLCD_RESET PORTA.2  ;LCD pin 14
    #define GLCD_RW PORTA.3     ;LCD pin 15
    #define GLCD_RS PORTA.4     ;LCD pin 16
    #define GLCD_ENABLE PORTA.6 ;LCD pin 17
    ;       Vee = pot low side  ;LCD pin 18
    ;       backlight anode     ;LCD pin 19
    ;       backlight cathode   ;LCD pin 20

    #define GLCD_TYPE GLCD_TYPE_KS0108
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 64

    ;----- Program

    Do forever

        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        Circle(10,10,10,0)            ;upper left
        Circle(117,10,10,0)           ;upper right
        Circle(63,31,10,0)            ;center
        Circle(63,31,20,0)            ;center
        Circle(10,53,10,0)            ;lower left
        Circle(117,53,10,0)           ;lower right
        GLCDDrawString 30,54,"PIC16F886"

    loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="midpoint_circle_algorithm"></span>Midpoint Circle Algorithm

</div>

</div>

</div>

<span class="strong">**Explanation:**</span>

GCBASIC can draw circles using the midpoint circle algorithm. The
midpoint circle algorithm determines the points needed for drawing a
circle. The algorithm is a variant of
<a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm" class="link">Bresenham’s line algorithm</a>,
and is thus sometimes known as Bresenham’s circle algorithm, although
not actually invented by
<a href="https://en.wikipedia.org/wiki/Jack_Elton_Bresenham" class="link">Jack E. Bresenham</a>.

The example program below show the midpoint circle algorithm within
GCBASIC.

<span class="strong">**Example Output on GLCD Device:**</span>

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/midpointcirclealgorithmb1.PNG)

</div>

</div>

``` screen
    'Midpoint Circle algorithm
    'Chip model
    #chip 16F886, 8             ;PIC16F88 running at 8 MHz
    #config mclr=off            ;reset handled internally

    #include <glcd.h>

    ;----- Constants

    ;Pinout is shown for the LCM12864H-FSB-FBW
    ;graphical LCD available from Amazon.

    ;       +5V                 ;LCD pin 1
    ;       ground              ;LCD pin 2
    ;       Vo = wiper of pot   ;LCD pin 3
    #define GLCD_DB0 PORTB.0    ;LCD pin 4
    #define GLCD_DB1 PORTB.1    ;LCD pin 5
    #define GLCD_DB2 PORTB.2    ;LCD pin 6
    #define GLCD_DB3 PORTB.3    ;LCD pin 7
    #define GLCD_DB4 PORTB.4    ;LCD pin 8
    #define GLCD_DB5 PORTB.5    ;LCD pin 9
    #define GLCD_DB6 PORTB.6    ;LCD pin 10
    #define GLCD_DB7 PORTB.7    ;LCD pin 11
    #define GLCD_CS2 PORTA.0    ;LCD pin 12
    #define GLCD_CS1 PORTA.1    ;LCD pin 13
    #define GLCD_RESET PORTA.2  ;LCD pin 14
    #define GLCD_RW PORTA.3     ;LCD pin 15
    #define GLCD_RS PORTA.4     ;LCD pin 16
    #define GLCD_ENABLE PORTA.6 ;LCD pin 17
    ;       Vee = pot low side  ;LCD pin 18
    ;       backlight anode     ;LCD pin 19
    ;       backlight cathode   ;LCD pin 20

    #define GLCD_TYPE GLCD_TYPE_KS0108
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 64

    ;----- Program

    Do forever

        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        Circle(10,10,10,0)            ;upper left
        Circle(117,10,10,0)           ;upper right
        Circle(63,31,10,0)            ;center
        Circle(63,31,20,0)            ;center
        Circle(10,53,10,0)            ;lower left
        Circle(117,53,10,0)           ;lower right
        GLCDDrawString 30,54,"PIC16F886"

    loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Miscellaneous</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_lookup_tables.html" title="Lookup Tables"><link rel="next" href="_readtable.html" title="ReadTable"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_miscellaneous"></a>Miscellaneous</h3></div></div></div><p><span class="strong"><strong>About Miscellaneous things&#8230;&#8203;.</strong></span></p><p>It is possible to combine multiple instructions on a single line, by
separating them with a colon. For example, this code:</p><pre class="screen">    Set PORTB.0 On
    Set PORTB.1 On
    Wait 1 sec
    Set PORTB.0 Off
    Set PORTB.0 Off</pre><p>could also be written as:</p><pre class="screen">    Set PORTB.0 On: Set PORTB.1 On
    Wait 1 sec
    Set PORTB.0 Off: Set PORTB.0 Off</pre><p>In most cases, it will make no difference if commands share a line or
not. However, special care should be taken with If commands, as this
code:</p><pre class="screen">    Set PORTB.0 Off
    Set PORTB.1 Off
    If Temp &gt; 10 Then Set PORTB.0 On: Set PORTB.1 On
    Wait 1 s</pre><p>Will be equivalent to this:</p><pre class="screen">    Set PORTB.0 Off
    Set PORTB.1 Off
    If Temp &gt; 10 Then
    Set PORTB.0 On
    Set PORTB.1 On
    End If
    Wait 1 s</pre><p>Also, the commands used to start and end subroutines, data tables and
functions must be alone on a line. For example, this is WRONG:</p><pre class="screen">    Sub Something: Set PORTB.0 Off: End Sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="miscellaneous"></span>Miscellaneous

</div>

</div>

</div>

<span class="strong">**About Miscellaneous things…​.**</span>

It is possible to combine multiple instructions on a single line, by
separating them with a colon. For example, this code:

``` screen
    Set PORTB.0 On
    Set PORTB.1 On
    Wait 1 sec
    Set PORTB.0 Off
    Set PORTB.0 Off
```

could also be written as:

``` screen
    Set PORTB.0 On: Set PORTB.1 On
    Wait 1 sec
    Set PORTB.0 Off: Set PORTB.0 Off
```

In most cases, it will make no difference if commands share a line or
not. However, special care should be taken with If commands, as this
code:

``` screen
    Set PORTB.0 Off
    Set PORTB.1 Off
    If Temp > 10 Then Set PORTB.0 On: Set PORTB.1 On
    Wait 1 s
```

Will be equivalent to this:

``` screen
    Set PORTB.0 Off
    Set PORTB.1 Off
    If Temp > 10 Then
    Set PORTB.0 On
    Set PORTB.1 On
    End If
    Wait 1 s
```

Also, the commands used to start and end subroutines, data tables and
functions must be alone on a line. For example, this is WRONG:

``` screen
    Sub Something: Set PORTB.0 Off: End Sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Miscellaneous Commands</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_concatenation.html" title="Concatenation"><link rel="next" href="_dir.html" title="Dir"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_miscellaneous_commands"></a>Miscellaneous Commands</h3></div></div></div><p>This is the Miscellaneous Commands section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="miscellaneous_commands"></span>Miscellaneous Commands

</div>

</div>

</div>

This is the Miscellaneous Commands section of the Help file. Please
refer the sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>More on setting Variables and Constants</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_using_variables.html" title="Using Variables"><link rel="next" href="_setting_variables.html" title="Setting Variables"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_more_on_setting_variables_and_constants"></a>More on setting Variables and Constants</h4></div></div></div><p><span class="strong"><strong>Explanation</strong></span></p><p>Within GCBASIC you can use regular variable assignments. But, you can also use C like maths assignments.</p><p>The following methods are also supported.</p><pre class="screen">    GLCDPrintLoc += 6
    CharCode -= 15
    CharCode++
    CharCode---</pre><p>Within GCBASIC you can define binary, hexidecimal and decimal constants, see <a class="link" href="_constants.html" title="Constants">Constants</a>. Please note what is and what is not support with respect to assigning numbers to constants. An example program examines what is supported.</p><pre class="screen">    #chip 16F88, 4
    #config Osc = MCLRE_OFF

    ' All these work
    #define Test1 0b11111111
    #define Test2 0B11111111
    #define Test3 255
    #define Test4 0xFF
    #define Test5 0xff
    #define Test6 0Xff

    # Proof - select each option one in turn
    dir porta Out

    porta = test1
    porta = test2
    porta = test3
    porta = test4
    porta = test5
    porta = test6</pre><p>You can assigned values/numbers with all the methods shown above (for constants and variables) but please be aware that you must Use '0' not '00'. One zero equates to zero and two zeros will give you an unassigned variable.</p><p><span class="strong"><strong>Constants:</strong></span></p><p>A few critical constants are defined within GCBASIC , you can re-use these constants. They include:</p><pre class="screen">    #define ON 1       ' These are defined in System.h
    #define OFF 0
    #define TRUE 255
    #define FALSE 0

    #define OSC = 1    ' These are defined in TIMER.H
    #define EXT = 2    ' and, are used by InitTimer0 command
    #define EXTOSC = 3</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="more_on_setting_variables_and_constants"></span>More on setting Variables and Constants

</div>

</div>

</div>

<span class="strong">**Explanation**</span>

Within GCBASIC you can use regular variable assignments. But, you can
also use C like maths assignments.

The following methods are also supported.

``` screen
    GLCDPrintLoc += 6
    CharCode -= 15
    CharCode++
    CharCode---
```

Within GCBASIC you can define binary, hexidecimal and decimal constants,
see
<a href="constants" class="link" title="Constants">Constants</a>.
Please note what is and what is not support with respect to assigning
numbers to constants. An example program examines what is supported.

``` screen
    #chip 16F88, 4
    #config Osc = MCLRE_OFF

    ' All these work
    #define Test1 0b11111111
    #define Test2 0B11111111
    #define Test3 255
    #define Test4 0xFF
    #define Test5 0xff
    #define Test6 0Xff

    # Proof - select each option one in turn
    dir porta Out

    porta = test1
    porta = test2
    porta = test3
    porta = test4
    porta = test5
    porta = test6
```

You can assigned values/numbers with all the methods shown above (for
constants and variables) but please be aware that you must Use '0' not
'00'. One zero equates to zero and two zeros will give you an unassigned
variable.

<span class="strong">**Constants:**</span>

A few critical constants are defined within GCBASIC , you can re-use
these constants. They include:

``` screen
    #define ON 1       ' These are defined in System.h
    #define OFF 0
    #define TRUE 255
    #define FALSE 0

    #define OSC = 1    ' These are defined in TIMER.H
    #define EXT = 2    ' and, are used by InitTimer0 command
    #define EXTOSC = 3
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>NEXTION Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_ks0108_controllers.html" title="KS0108 Controllers"><link rel="next" href="_nt7108c_controllers.html" title="NT7108C Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_nextion_controllers"></a>NEXTION Controllers</h5></div></div></div><p>This section covers GLCD devices that use the serially attached Nextion graphics displays.</p><p>Nextion includes hardware part (a series of TFT boards) and software part (the Nextion
editor (<a class="link" href="http://nextion.itead.cc/)" target="_top">http://nextion.itead.cc/)</a>).</p><p>The Nextion TFT board uses only one serial port to communicate. &nbsp;&nbsp;It lets you avoid the hassle of wiring.&nbsp;&nbsp;Nextion
editor has mass components such as button, text, progress bar, slider, instrument panel etc.
to enrich your interface design.&nbsp;&nbsp; And, the drag-and-drop function ensures that you spend less
time in programming</p><p>The Nextion displays are 2.4 to 7.0 inches and range from 320*240 to 800*480 pixels.&nbsp;&nbsp; The connections are 5v, 0v, SerialIn and SerialOut.&nbsp;&nbsp; GCBASIC supports hardware and software serial connectivity.</p><p>See GITHUB for the set of GCBASIC demonstrations fro the Nextion displays.  See <a class="link" href="https://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/GLCD%20%20Solutions/GLCD%20Nextion%20Solutions" target="_top">Nextion demonstrations on GITHUB</a>.</p><p><br>
<br>
<br>
<br>
To use the Nextion driver simply include the following in your user code.  This will initialise the driver.
<br>
<br>
<span class="strong"><strong>Setup for Hardware Serial</strong></span></p><pre class="screen">' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #option explicit

' ----- Set up the Nextion GLCD
    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_Nextion


    ;VERY IMPORTANT!!
    ;Change the width and height to match the rotation in the Nextion Editor
    #define GLCD_WIDTH  320   'could be 320 | 400 | 272 | 480 but any valid dimension will work.
    #define GLCD_HEIGHT 240  'could be 240 | 480 | 800 but any valid dimension will work.


    ;VERY IMPORTANT!!
    ;Fonts installed in the Nextion MUST match the fonts parameters loading to the GLCD.
    ;Obtain parameters from Nextion Editor/Font dialog.
    #define NextionFont0      0, 8, 16    'Arial 8x16
    #define NextionFont1      1, 12, 24   '24point 12x24 charset
    #define NextionFont2      2, 16, 32   '32point 16x32 charset

' ----- End of set up for Nextion GLCD

' ----- Set up for Hardware Serial
    ;VERY IMPORTANT!!
    ;The Nextion MUST be setup for 9600 bps.
    #define USART_BAUD_RATE 9600
    #define USART_BLOCKING

    ;VERY IMPORTANT!!
    ;These two are optional. These constants are set in the library.
    #define GLCD_NextionSerialPrint HSerPrint
    #define GLCD_NextionSerialSend  HSerSend

' ----- End of set up for Serial


    'Generated by PIC PPS Tool for GCBASIC
    'PPS Tool version: 0.0.5.11
    'PinManager data: v1.55
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: EUSART
            RXPPS = 0x0016    'RC6 &gt; RX

            'Module: EUSART
            RC0PPS = 0x0010    'TX &gt; RC0
            TXPPS = 0x0010    'RC0 &gt; TX (bi-directional)
            RC5PPS = 0x0010    'TX &gt; RC5
            TXPPS = 0x0015    'RC5 &gt; TX (bi-directional)

    End Sub
    'Template comment at the end of the config file


' ----- Main program starts
....</pre><p><br>
<br>
<span class="strong"><strong>Setup for Software Serial</strong></span></p><pre class="screen">' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #option explicit

' ----- Set up the Nextion GLCD
    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_Nextion


    ;VERY IMPORTANT!!
    ;Change the width and height to match the rotation in the Nextion Editor
    #define GLCD_WIDTH  320   'could be 320 | 400 | 272 | 480 but any valid dimension will work.
    #define GLCD_HEIGHT 240  'could be 240 | 480 | 800 but any valid dimension will work.


    ;VERY IMPORTANT!!
    ;Fonts installed in the Nextion MUST match the fonts parameters loading to the GLCD.
    ;Obtain parameters from Nextion Editor/Font dialog.
    #define NextionFont0      0, 8, 16    'Arial 8x16
    #define NextionFont1      1, 12, 24   '24point 12x24 charset
    #define NextionFont2      2, 16, 32   '32point 16x32 charset

' ----- End of set up for Nextion GLCD

' ----- Set up for Software Serial - this is optional - shown to explain the method.
    ;Remove Hardware Serial before using Software serial
    ;You MUST also remove PPS setup, for hardware serial, when using Software serial
    #include &lt;SoftSerial.h&gt;

    ; ----- Config Serial UART for sending:
    #define SER1_BAUD 9600     ; baudrate must be defined
    #define SER1_TXPORT PORTC ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 5       ; portbit  must be defined

    ;VERY IMPORTANT!!
    ;These two constants are required to support the the library.
    #define GLCD_NextionSerialPrint        Ser1Print
    #define GLCD_NextionSerialSend         Ser1Send
'
' ----- End of set up for Serial

' ----- Main program starts</pre><p><br>
<br></p><p>The GCBASIC constants shown below control the configuration of the Nextion controller.
&nbsp;&nbsp;&nbsp;The GCBASIC constants for control and data line connections are shown
in the table below.</p><p><br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Options</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_Nextion</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_NextionSerialPrint</code></p></td><td align="left" valign="top"><p>Default is <code class="literal">HSerPrint</code> for hardware serial can be <code class="literal">SernPrint</code> when using software serial.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_NextionSerialSend</code></p></td><td align="left" valign="top"><p>Default is <code class="literal">HSerSend</code> for hardware serial can be <code class="literal">SernSend</code> when using software serial.</p></td><td align="left" valign="top"><p>Required</p></td></tr></tbody></table></div><p><br>
<br>
The GCBASIC constants for control display characteristics are shown in the table below.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Default</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>Mandated. The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">320</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>Mandated. The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">480</code></p></td></tr></tbody></table></div><p><br>
<br></p><p>The GCBASIC Nextion specific commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint_Nextion</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using Nextion font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable [,NextionFont] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDLocateString_Nextion</code></p></td><td align="left" valign="top"><p>Locate the screen coordinates at a specific location.</p></td><td align="left" valign="top"><p><code class="literal">GLCDLocateString_Nextion( Xposition, Yposition)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrintString_Nextion</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using Nextion font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrintString_Nextion( Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrintStringLn_Nextion</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using Nextion font set adding a newline and carriage return to move cursort to start of next line.</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrintStringLn_Nextion( Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDSendOpInstruction_Nextion</code></p></td><td align="left" valign="top"><p>Send the Nextion display a specific command and a specific value</p></td><td align="left" valign="top"><p><code class="literal">GLCDSendOpInstruction_Nextion( Nextion_command, command_value )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDUpdateObject_Nextion</code></p></td><td align="left" valign="top"><p>Update a Nextion display object with a specific value</p></td><td align="left" valign="top"><p><code class="literal">GLCDUpdateObject_Nextion( Nextion_object, object_value )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">myReturnedWordValue  = GLCDGetTouch_Nextion( "nextion_command_string" )</code></p></td><td align="left" valign="top"><p>A function that returns a long, that can be treated as word variable, value of the Touch event..&nbsp;&nbsp;As follows:
<br>
<br>
"tch0" for current x co-ordinate touched
</p><p>"tch1" for current y co-ordinate touched
</p><p>"tch2" for last x co-ordinate touched
</p><p>"tch3" for last y co-ordinate touched
<br>
<br>
The function is non-blocking.
</p><p>1. Checks for three bytes of 0xFF. If Four 0xff are received then exit = non-block.
</p><p>2. If at any time a 0x71 is recieved then we have data for the event.
</p><p>3. If seven bytes arrive, but the method did not receive a 0x71  then exit = non-block.
</p><p>4. The method supports software and hardware serial. As does all the other methods.
</p><p>5. The method uses a function to receive the data not a sub-routine.
</p><p>6. The method returns 0xBEEF if there is an invalid read, and, functional value for GLCDGetTouch_Nextion will also be set to 0xDEADBEEF</p></td><td align="left" valign="top"><p>myReturnedWordValue  = GLCDGetTouch_Nextion( "tch2")
</p><p>or,
</p><p>myReturnedWordValue  = GLCDGetTouch_Nextion( "tch3")</p></td></tr></tbody></table></div><p><br>
<br></p><p>The GCBASIC commonn commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr></tbody></table></div><p><br>
<br></p><pre class="screen">    TFT_BLACK   'hexidecimal value 0x0000
    TFT_RED     'hexidecimal value 0xF800
    TFT_GREEN   'hexidecimal value 0x0400
    TFT_BLUE    'hexidecimal value 0x001F
    TFT_WHITE   'hexidecimal value 0xFFFF
    TFT_PURPLE  'hexidecimal value 0xF11F
    TFT_YELLOW  'hexidecimal value 0xFFE0
    TFT_CYAN    'hexidecimal value 0x07FF
    TFT_D_GRAY  'hexidecimal value 0x528A
    TFT_L_GRAY  'hexidecimal value 0x7997
    TFT_SILVER  'hexidecimal value 0xC618
    TFT_MAROON  'hexidecimal value 0x8000
    TFT_OLIVE   'hexidecimal value 0x8400
    TFT_LIME    'hexidecimal value 0x07E0
    TFT_AQUA    'hexidecimal value 0x07FF
    TFT_TEAL    'hexidecimal value 0x0410
    TFT_NAVY    'hexidecimal value 0x0010
    TFT_FUCHSIA 'hexidecimal value 0xF81F</pre><p><br>
<br></p><p><br>
<br></p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>
<br>
<br>
Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="nextion_controllers"></span>NEXTION Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the serially attached Nextion
graphics displays.

Nextion includes hardware part (a series of TFT boards) and software
part (the Nextion editor (<http://nextion.itead.cc/)>).

The Nextion TFT board uses only one serial port to communicate.   It
lets you avoid the hassle of wiring.  Nextion editor has mass components
such as button, text, progress bar, slider, instrument panel etc. to
enrich your interface design.   And, the drag-and-drop function ensures
that you spend less time in programming

The Nextion displays are 2.4 to 7.0 inches and range from 320\*240 to
800\*480 pixels.   The connections are 5v, 0v, SerialIn and SerialOut.  
GCBASIC supports hardware and software serial connectivity.

See GITHUB for the set of GCBASIC demonstrations fro the Nextion
displays. See
<a href="https://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/GLCD%20%20Solutions/GLCD%20Nextion%20Solutions" class="link">Nextion demonstrations on GITHUB</a>.

  
  
  
  
To use the Nextion driver simply include the following in your user
code. This will initialise the driver.  
  
<span class="strong">**Setup for Hardware Serial**</span>

``` screen
' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #option explicit

' ----- Set up the Nextion GLCD
    #include <glcd.h>
    #define GLCD_TYPE GLCD_TYPE_Nextion


    ;VERY IMPORTANT!!
    ;Change the width and height to match the rotation in the Nextion Editor
    #define GLCD_WIDTH  320   'could be 320 | 400 | 272 | 480 but any valid dimension will work.
    #define GLCD_HEIGHT 240  'could be 240 | 480 | 800 but any valid dimension will work.


    ;VERY IMPORTANT!!
    ;Fonts installed in the Nextion MUST match the fonts parameters loading to the GLCD.
    ;Obtain parameters from Nextion Editor/Font dialog.
    #define NextionFont0      0, 8, 16    'Arial 8x16
    #define NextionFont1      1, 12, 24   '24point 12x24 charset
    #define NextionFont2      2, 16, 32   '32point 16x32 charset

' ----- End of set up for Nextion GLCD

' ----- Set up for Hardware Serial
    ;VERY IMPORTANT!!
    ;The Nextion MUST be setup for 9600 bps.
    #define USART_BAUD_RATE 9600
    #define USART_BLOCKING

    ;VERY IMPORTANT!!
    ;These two are optional. These constants are set in the library.
    #define GLCD_NextionSerialPrint HSerPrint
    #define GLCD_NextionSerialSend  HSerSend

' ----- End of set up for Serial


    'Generated by PIC PPS Tool for GCBASIC
    'PPS Tool version: 0.0.5.11
    'PinManager data: v1.55
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: EUSART
            RXPPS = 0x0016    'RC6 > RX

            'Module: EUSART
            RC0PPS = 0x0010    'TX > RC0
            TXPPS = 0x0010    'RC0 > TX (bi-directional)
            RC5PPS = 0x0010    'TX > RC5
            TXPPS = 0x0015    'RC5 > TX (bi-directional)

    End Sub
    'Template comment at the end of the config file


' ----- Main program starts
....
```

  
  
<span class="strong">**Setup for Software Serial**</span>

``` screen
' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #option explicit

' ----- Set up the Nextion GLCD
    #include <glcd.h>
    #define GLCD_TYPE GLCD_TYPE_Nextion


    ;VERY IMPORTANT!!
    ;Change the width and height to match the rotation in the Nextion Editor
    #define GLCD_WIDTH  320   'could be 320 | 400 | 272 | 480 but any valid dimension will work.
    #define GLCD_HEIGHT 240  'could be 240 | 480 | 800 but any valid dimension will work.


    ;VERY IMPORTANT!!
    ;Fonts installed in the Nextion MUST match the fonts parameters loading to the GLCD.
    ;Obtain parameters from Nextion Editor/Font dialog.
    #define NextionFont0      0, 8, 16    'Arial 8x16
    #define NextionFont1      1, 12, 24   '24point 12x24 charset
    #define NextionFont2      2, 16, 32   '32point 16x32 charset

' ----- End of set up for Nextion GLCD

' ----- Set up for Software Serial - this is optional - shown to explain the method.
    ;Remove Hardware Serial before using Software serial
    ;You MUST also remove PPS setup, for hardware serial, when using Software serial
    #include <SoftSerial.h>

    ; ----- Config Serial UART for sending:
    #define SER1_BAUD 9600     ; baudrate must be defined
    #define SER1_TXPORT PORTC ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 5       ; portbit  must be defined

    ;VERY IMPORTANT!!
    ;These two constants are required to support the the library.
    #define GLCD_NextionSerialPrint        Ser1Print
    #define GLCD_NextionSerialSend         Ser1Send
'
' ----- End of set up for Serial

' ----- Main program starts
```

  
  

The GCBASIC constants shown below control the configuration of the
Nextion controller.    The GCBASIC constants for control and data line
connections are shown in the table below.

  
  

<div class="informaltable">

| Constants                 | Controls                                                                                  | Options  |
|:--------------------------|:------------------------------------------------------------------------------------------|:---------|
| `GLCD_TYPE`               | `GLCD_TYPE_Nextion`                                                                       |          |
| `GLCD_NextionSerialPrint` | Default is `HSerPrint` for hardware serial can be `SernPrint` when using software serial. | Required |
| `GLCD_NextionSerialSend`  | Default is `HSerSend` for hardware serial can be `SernSend` when using software serial.   | Required |

</div>

  
  
The GCBASIC constants for control display characteristics are shown in
the table below.  
  

<div class="informaltable">

| Constants     | Controls                                   | Default |
|:--------------|:-------------------------------------------|:--------|
| `GLCD_WIDTH`  | Mandated. The width parameter of the GLCD  | `320`   |
| `GLCD_HEIGHT` | Mandated. The height parameter of the GLCD | `480`   |

</div>

  
  

The GCBASIC Nextion specific commands supported for this GLCD are shown
in the table below.   Always review the appropiate library for the
latest full set of supported commands.  
  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDPrint_Nextion</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using Nextion font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable [,NextionFont] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDLocateString_Nextion</code></p></td>
<td style="text-align: left;"><p>Locate the screen coordinates at a specific location.</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDLocateString_Nextion( Xposition, Yposition)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDPrintString_Nextion</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using Nextion font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrintString_Nextion( Stringvariable )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDPrintStringLn_Nextion</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using Nextion font set adding a newline and carriage return to move cursort to start of next line.</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrintStringLn_Nextion( Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDSendOpInstruction_Nextion</code></p></td>
<td style="text-align: left;"><p>Send the Nextion display a specific command and a specific value</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDSendOpInstruction_Nextion( Nextion_command, command_value )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDUpdateObject_Nextion</code></p></td>
<td style="text-align: left;"><p>Update a Nextion display object with a specific value</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDUpdateObject_Nextion( Nextion_object, object_value )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">myReturnedWordValue  = GLCDGetTouch_Nextion( "nextion_command_string" )</code></p></td>
<td style="text-align: left;"><p>A function that returns a long, that can be treated as word variable, value of the Touch event..  As follows:<br />
<br />
"tch0" for current x co-ordinate touched</p>
<p>"tch1" for current y co-ordinate touched</p>
<p>"tch2" for last x co-ordinate touched</p>
<p>"tch3" for last y co-ordinate touched<br />
<br />
The function is non-blocking.</p>
<p>1. Checks for three bytes of 0xFF. If Four 0xff are received then exit = non-block.</p>
<p>2. If at any time a 0x71 is recieved then we have data for the event.</p>
<p>3. If seven bytes arrive, but the method did not receive a 0x71 then exit = non-block.</p>
<p>4. The method supports software and hardware serial. As does all the other methods.</p>
<p>5. The method uses a function to receive the data not a sub-routine.</p>
<p>6. The method returns 0xBEEF if there is an invalid read, and, functional value for GLCDGetTouch_Nextion will also be set to 0xDEADBEEF</p></td>
<td style="text-align: left;"><p>myReturnedWordValue = GLCDGetTouch_Nextion( "tch2")</p>
<p>or,</p>
<p>myReturnedWordValue = GLCDGetTouch_Nextion( "tch3")</p></td>
</tr>
</tbody>
</table>

</div>

  
  

The GCBASIC commonn commands supported for this GLCD are shown in the
table below.   Always review the appropiate library for the latest full
set of supported commands.  
  

<div class="informaltable">

| Command          | Purpose                                                                                  | Example                                                                               |
|:-----------------|:-----------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------|
| `GLCDCLS`        | Clear screen of GLCD                                                                     | `GLCDCLS  [,Optional LineColour]`                                                     |
| `GLCDPrint`      | Print string of characters on GLCD using GCB font set                                    | `GLCDPrint( Xposition, Yposition, Stringvariable )`                                   |
| `GLCDDrawChar`   | Print character on GLCD using GCB font set                                               | `GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )`               |
| `GLCDDrawString` | Print characters on GLCD using GCB font set                                              | `GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )`       |
| `Box`            | Draw a box on the GLCD to a specific size                                                | `Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]`         |
| `FilledBox`      | Draw a box on the GLCD to a specific size that is filled with the foreground colour.     | `FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )` |
| `Line`           | Draw a line on the GLCD to a specific length that is filled with the specific attribute. | `Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )`      |

</div>

  
  

``` screen
    TFT_BLACK   'hexidecimal value 0x0000
    TFT_RED     'hexidecimal value 0xF800
    TFT_GREEN   'hexidecimal value 0x0400
    TFT_BLUE    'hexidecimal value 0x001F
    TFT_WHITE   'hexidecimal value 0xFFFF
    TFT_PURPLE  'hexidecimal value 0xF11F
    TFT_YELLOW  'hexidecimal value 0xFFE0
    TFT_CYAN    'hexidecimal value 0x07FF
    TFT_D_GRAY  'hexidecimal value 0x528A
    TFT_L_GRAY  'hexidecimal value 0x7997
    TFT_SILVER  'hexidecimal value 0xC618
    TFT_MAROON  'hexidecimal value 0x8000
    TFT_OLIVE   'hexidecimal value 0x8400
    TFT_LIME    'hexidecimal value 0x07E0
    TFT_AQUA    'hexidecimal value 0x07FF
    TFT_TEAL    'hexidecimal value 0x0410
    TFT_NAVY    'hexidecimal value 0x0010
    TFT_FUCHSIA 'hexidecimal value 0xF81F
```

  
  

  
  

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>  
  
Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>NT7108C Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_nextion_controllers.html" title="NEXTION Controllers"><link rel="next" href="_pcd8544_controllers.html" title="PCD8544 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_nt7108c_controllers"></a>NT7108C Controllers</h5></div></div></div><p>This section covers GLCD devices that use the NT7108C graphics controller.
<br>
<br>
The NT7108C is an GLCD is driven by on-board 5V parallel interface chipset NT7108C.&nbsp;&nbsp;&nbsp;They are similar to the KS0108.
<br>
<br>
The GLCD controller is the Winstar WDG0151-TMI module, which is a 128&times;64 pixel monochromatic display.&nbsp;&nbsp;&nbsp;
It uses two Neotic display controller chips: NT7108C and NT7107C, which are similar with Samsung KS0108B and KS0107B controllers.&nbsp;&nbsp;&nbsp;
The controller uses a dot matrix LCD segment driver with 64 channel output, and therefore, the WDG0151 module contains two sets of it to drive 128 segments.
<br>
<br>
The GCBASIC constants shown below control the configuration of the NT7108C controller.&nbsp;&nbsp;&nbsp;
The connectivity options are as follows, This is required between the microcontroller and the GLCD to control the data bus.:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">A  full port mode.&nbsp;&nbsp; Where a full data port therefore eight contiguous port.bits.&nbsp;&nbsp;  The port is used the data communications.</li><li class="listitem">Eight port.bits mode.&nbsp;&nbsp;  This option allows for greater flexibility with the configuration but will operate slower then the full port mode.&nbsp;&nbsp;    These port.bits are used the data communications.
<br>
To use the NT7108C driver simply include the following in your user code.  This will initialise the driver.
<br>
<br></li></ul></div><pre class="screen">    ;Full port mode
    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_NT7108C


   #define GLCD_DATA_PORT PORTD       'Data Port

   #define GLCD_CS1 PORTC.1           'CS1 control line
   #define GLCD_CS2 PORTC.0           'CS2 control line
   #define GLCD_RS PORTe.0            'RS control line
   #define GLCD_Enable PORTe.2        'Enable control line
   #define GLCD_RW PORTc.3            'RW control line
   #define GLCD_RESET PORTC.2         'Reset control line</pre><p>or</p><pre class="screen">    ;Eight port.bits mode
    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_NT7108C


    ;Defines (Constants)
    ;Define port as 8 port,bit(s)
    #define GLCD_DB0 PORTA.2    'Data Port.bit 0
    #define GLCD_DB1 PORTC.0    'Data Port.bit 1
    #define GLCD_DB2 PORTC.1    'Data Port.bit 2
    #define GLCD_DB3 PORTC.2    'Data Port.bit 3
    #define GLCD_DB4 PORTB.4    'Data Port.bit 4
    #define GLCD_DB5 PORTB.5    'Data Port.bit 5
    #define GLCD_DB6 PORTB.6    'Data Port.bit 6
    #define GLCD_DB7 PORTB.7    'Data Port.bit 7
    ;End of define as 8 port,bit(s)

    #define GLCD_CS1 PORTC.7    'CS1 control line
    #define GLCD_CS2 PORTC.6    'CS2 control line
    #define GLCD_RS PORTC.5     'RS control line
    #define GLCD_ENABLE PORTA.4 'Enable control line
    #define GLCD_RW PORTC.4     'RW control line
    #define GLCD_RESET PORTC.3  'Reset control line</pre><p>The GCBASIC constants for the interface to the controller are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_NT7108C</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Register Select on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RW</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Read/Write on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS1</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">CS1</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS2</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">CS2</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_ENABLE</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to <code class="literal">Enable</code> on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p>Full port mode</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DATA_PORT</code></p></td><td align="left" valign="top"><p>Specifies the port that is connected to 8 connections on the GLCD.</p></td><td align="left" valign="top"><p>Required when using full port mode</p></td></tr><tr><td align="left" valign="top"><p>Eight port.bits mode</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DB0</code><br>
<code class="literal">GLCD_DB1</code><br>
..<br>
<code class="literal">GLCD_DB7</code></p></td><td align="left" valign="top"><p>Specifies the port.bit that is connected to a single connection on the GLCD.</p></td><td align="left" valign="top"><p>Required when using eight port.bits mode</p></td></tr></tbody></table></div><p>The GCBASIC constants defined for the controller type are shown in the table below.  The NT7108C is very sensitive to clock timings.&nbsp;&nbsp;&nbsp;You may to adjust the clock timing to ensure the display operates correctly.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="center" valign="top"><p><code class="literal">128</code>
This constant cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="center" valign="top"><p><code class="literal">64</code>
This constant cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDirection</code></p></td><td align="left" valign="top"><p>Defining this will invert the Y Axis</p></td><td align="center" valign="top"><p>Not defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">NT7108CReadDelay</code></p></td><td align="left" valign="top"><p>Read delay</p></td><td align="center" valign="top"><p>Default is 7
</p><p>Can be set to improve overall performance.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">NT7108CWriteDelay</code></p></td><td align="left" valign="top"><p>Write delay</p></td><td align="center" valign="top"><p>Default is 7
</p><p>Can be set to improve performance.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">NT7108CClockDelay</code></p></td><td align="left" valign="top"><p>Clock Delay</p></td><td align="center" valign="top"><p>Default is 7
</p><p>Can be set to improve performance.</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Variables</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Width of the current GLCD font.</p></td><td align="center" valign="top"><p>Default is 6 pixels.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDfntDefault</code></p></td><td align="left" valign="top"><p>Size of the current GLCD font.</p></td><td align="center" valign="top"><p>Default is 0.
</p><p>This equates to the standard GCB font set.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDfntDefaultsize</code></p></td><td align="left" valign="top"><p>Size of the current GLCD font.</p></td><td align="center" valign="top"><p>Default is 1.
</p><p>This equates to the 8 pixel high.</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the
table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr></tbody></table></div><p>For a NT7108C datasheet, please refer
<a class="link" href="http://www.farnell.com/datasheets/1878006.pdf" target="_top">here.</a></p><p>This example shows how to drive a NT7108C based Graphic LCD module with
the built in commands of GCBASIC. See <a class="link" href="https://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/" target="_top">Graphic LCD</a> for
details, this is an external web site.</p><pre class="screen">  ;Chip Settings
  #chip 16F1939,32
  #option explicit
  #config MCLRE_On

   #include &lt;glcd.h&gt;
   #define GLCD_TYPE GLCD_TYPE_NT7108C               ' Specify the GLCD type
   #define GLCDDirection 0                           ' Flip the GLCD   0 do not flip, 1 flip

   'Setup the device
   #define GLCD_CS1 PORTC.1    'D12 to actually since CS1, CS2 can be reversed on some devices
   #define GLCD_CS2 PORTC.0
   #define GLCD_DATA_PORT PORTD
   #define GLCD_RS PORTe.0
   #define GLCD_Enable PORTe.2
   #define GLCD_RW PORTc.3
   #define GLCD_RESET PORTC.2

   GLCDPrint ( 4,   1, "GCBASIC 2021")                                ; Print some text

   Box  0, 0, 127, 10
   Line 63, 10, 63, 63
   Line 0, 37, 127, 37
   Circle 63, 37, 15

   End</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="nt7108c_controllers"></span>NT7108C Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the NT7108C graphics
controller.  
  
The NT7108C is an GLCD is driven by on-board 5V parallel interface
chipset NT7108C.   They are similar to the KS0108.  
  
The GLCD controller is the Winstar WDG0151-TMI module, which is a 128×64
pixel monochromatic display.    It uses two Neotic display controller
chips: NT7108C and NT7107C, which are similar with Samsung KS0108B and
KS0107B controllers.    The controller uses a dot matrix LCD segment
driver with 64 channel output, and therefore, the WDG0151 module
contains two sets of it to drive 128 segments.  
  
The GCBASIC constants shown below control the configuration of the
NT7108C controller.    The connectivity options are as follows, This is
required between the microcontroller and the GLCD to control the data
bus.:

<div class="itemizedlist">

-   A full port mode.   Where a full data port therefore eight
    contiguous port.bits.   The port is used the data communications.
-   Eight port.bits mode.   This option allows for greater flexibility
    with the configuration but will operate slower then the full port
    mode.   These port.bits are used the data communications.  
    To use the NT7108C driver simply include the following in your user
    code. This will initialise the driver.  
      

</div>

``` screen
    ;Full port mode
    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_NT7108C


   #define GLCD_DATA_PORT PORTD       'Data Port

   #define GLCD_CS1 PORTC.1           'CS1 control line
   #define GLCD_CS2 PORTC.0           'CS2 control line
   #define GLCD_RS PORTe.0            'RS control line
   #define GLCD_Enable PORTe.2        'Enable control line
   #define GLCD_RW PORTc.3            'RW control line
   #define GLCD_RESET PORTC.2         'Reset control line
```

or

``` screen
    ;Eight port.bits mode
    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_NT7108C


    ;Defines (Constants)
    ;Define port as 8 port,bit(s)
    #define GLCD_DB0 PORTA.2    'Data Port.bit 0
    #define GLCD_DB1 PORTC.0    'Data Port.bit 1
    #define GLCD_DB2 PORTC.1    'Data Port.bit 2
    #define GLCD_DB3 PORTC.2    'Data Port.bit 3
    #define GLCD_DB4 PORTB.4    'Data Port.bit 4
    #define GLCD_DB5 PORTB.5    'Data Port.bit 5
    #define GLCD_DB6 PORTB.6    'Data Port.bit 6
    #define GLCD_DB7 PORTB.7    'Data Port.bit 7
    ;End of define as 8 port,bit(s)

    #define GLCD_CS1 PORTC.7    'CS1 control line
    #define GLCD_CS2 PORTC.6    'CS2 control line
    #define GLCD_RS PORTC.5     'RS control line
    #define GLCD_ENABLE PORTA.4 'Enable control line
    #define GLCD_RW PORTC.4     'RW control line
    #define GLCD_RESET PORTC.3  'Reset control line
```

The GCBASIC constants for the interface to the controller are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Options</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE</code></p></td>
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_NT7108C</code></p></td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_RS</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Register Select on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_RW</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Read/Write on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_CS1</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">CS1</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_CS2</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">CS2</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_ENABLE</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to <code class="literal">Enable</code> on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Full port mode</p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DATA_PORT</code></p></td>
<td style="text-align: left;"><p>Specifies the port that is connected to 8 connections on the GLCD.</p></td>
<td style="text-align: left;"><p>Required when using full port mode</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Eight port.bits mode</p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DB0</code><br />
<code class="literal">GLCD_DB1</code><br />
..<br />
<code class="literal">GLCD_DB7</code></p></td>
<td style="text-align: left;"><p>Specifies the port.bit that is connected to a single connection on the GLCD.</p></td>
<td style="text-align: left;"><p>Required when using eight port.bits mode</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC constants defined for the controller type are shown in the
table below. The NT7108C is very sensitive to clock timings.   You may
to adjust the clock timing to ensure the display operates correctly.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: center;"><p><code class="literal">128</code> This constant cannot be changed</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: center;"><p><code class="literal">64</code> This constant cannot be changed</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDirection</code></p></td>
<td style="text-align: left;"><p>Defining this will invert the Y Axis</p></td>
<td style="text-align: center;"><p>Not defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">NT7108CReadDelay</code></p></td>
<td style="text-align: left;"><p>Read delay</p></td>
<td style="text-align: center;"><p>Default is 7</p>
<p>Can be set to improve overall performance.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">NT7108CWriteDelay</code></p></td>
<td style="text-align: left;"><p>Write delay</p></td>
<td style="text-align: center;"><p>Default is 7</p>
<p>Can be set to improve performance.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">NT7108CClockDelay</code></p></td>
<td style="text-align: left;"><p>Clock Delay</p></td>
<td style="text-align: center;"><p>Default is 7</p>
<p>Can be set to improve performance.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Variables</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Width of the current GLCD font.</p></td>
<td style="text-align: center;"><p>Default is 6 pixels.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDfntDefault</code></p></td>
<td style="text-align: left;"><p>Size of the current GLCD font.</p></td>
<td style="text-align: center;"><p>Default is 0.</p>
<p>This equates to the standard GCB font set.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDfntDefaultsize</code></p></td>
<td style="text-align: left;"><p>Size of the current GLCD font.</p></td>
<td style="text-align: center;"><p>Default is 1.</p>
<p>This equates to the 8 pixel high.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**Purpose**</span>                                                  | <span class="strong">**Example**</span>                                                        |
|:----------------------------------------|:-----------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------|
| `GLCDCLS`                               | Clear screen of GLCD                                                                     | `GLCDCLS`                                                                                      |
| `GLCDPrint`                             | Print string of characters on GLCD using GCB font set                                    | `GLCDPrint( Xposition, Yposition, Stringvariable )`                                            |
| `GLCDDrawChar`                          | Print character on GLCD using GCB font set                                               | `GLCDDrawChar( Xposition, Yposition, CharCode )`                                               |
| `GLCDDrawString`                        | Print characters on GLCD using GCB font set                                              | `GLCDDrawString( Xposition, Yposition, Stringvariable )`                                       |
| `Box`                                   | Draw a box on the GLCD to a specific size                                                | `Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )`   |
| `FilledBox`                             | Draw a box on the GLCD to a specific size that is filled with the foreground colour.     | `FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )` |
| `Line`                                  | Draw a line on the GLCD to a specific length that is filled with the specific attribute. | `Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`     |
| `PSet`                                  | Set a pixel on the GLCD at a specific position that is set with the specific attribute.  | `PSet(Xposition, Yposition, Pixel Colour 0 or 1)`                                              |
| `GLCDWriteByte`                         | Set a byte value to the controller, see the datasheet for usage.                         | `GLCDWriteByte ( LCDByte)`                                                                     |
| `GLCDReadByte`                          | Read a byte value from the controller, see the datasheet for usage.                      | `bytevariable = GLCDReadByte`                                                                  |

</div>

For a NT7108C datasheet, please refer
<a href="http://www.farnell.com/datasheets/1878006.pdf" class="link">here.</a>

This example shows how to drive a NT7108C based Graphic LCD module with
the built in commands of GCBASIC. See
<a href="https://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/" class="link">Graphic LCD</a>
for details, this is an external web site.

``` screen
  ;Chip Settings
  #chip 16F1939,32
  #option explicit
  #config MCLRE_On

   #include <glcd.h>
   #define GLCD_TYPE GLCD_TYPE_NT7108C               ' Specify the GLCD type
   #define GLCDDirection 0                           ' Flip the GLCD   0 do not flip, 1 flip

   'Setup the device
   #define GLCD_CS1 PORTC.1    'D12 to actually since CS1, CS2 can be reversed on some devices
   #define GLCD_CS2 PORTC.0
   #define GLCD_DATA_PORT PORTD
   #define GLCD_RS PORTe.0
   #define GLCD_Enable PORTe.2
   #define GLCD_RW PORTc.3
   #define GLCD_RESET PORTC.2

   GLCDPrint ( 4,   1, "GCBASIC 2021")                                ; Print some text

   Box  0, 0, 127, 10
   Line 63, 10, 63, 63
   Line 0, 37, 127, 37
   Circle 63, 37, 15

   End
```

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>One Wire Devices</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_tm_point.html" title="TM_Point"><link rel="next" href="_ds18b20.html" title="DS18B20"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_one_wire_devices"></a>One Wire Devices</h3></div></div></div><p>This is the One Wire Devices section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="one_wire_devices"></span>One Wire Devices

</div>

</div>

</div>

This is the One Wire Devices section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>On Interrupt</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_interrupts.html" title="Interrupts"><link rel="prev" href="_inton.html" title="IntOn"><link rel="next" href="_on_interrupt_the_default_handler.html" title="On Interrupt: The default handler"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_on_interrupt"></a>On Interrupt</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    On Interrupt event Call handler
    On Interrupt event Ignore</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on Microchip PIC and Atmel AVR microcontrollers with interrupt support.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>On Interrupt will add code to call the subroutine <span class="emphasis"><em>handler</em></span> whenever the
interrupt <span class="emphasis"><em>event</em></span> occurs. When Call is specified, GCBASIC will enable
the interrupt, and call the interrupt handler when it occurs. When
Ignore is specified, GCBASIC will disable the interrupt handler and
prevent it from being called when the event occurs. If the event occurs
while the handler is disabled, then the handler will be called as soon
as it is re-enabled. The only way to prevent this from happening is to
manually clear the flag bit for the interrupt.</p><p>There are many possible interrupt events that can occur, and the events
vary greatly from chip to chip. GCBASIC will display an error if a given
chip cannot support the specified event.</p><p>On Interrupt may require the setting or clearing of the interrupt register bit(s), and, On Interrupt may require setting of explicit enable register bits. You should always consult the device datasheet for these On Interrupt additional specific settings of register bits.  Typically, you will need define the 1) source event register bit(s) in the main program, and, 2) clear or set the register bit at the start of the of the interrupt handler subroutine.</p><p>GCBASIC has many demonstrations showing how to set and enable appropiate interrupt register bits to support the On Interrupt method.</p><p>If On Interrupt is used to handle an event, then the Interrupt()
subroutine will not be called for that event. However, it will still be
called for any events not dealt with by On Interrupt.</p><p><span class="strong"><strong>Events:</strong></span></p><p>GCBASIC supports the events shown on the table below. Some events are
only implemented on a few specialised chips. Events in <span class="gray"><span class="strong"><strong>grey</strong></span></span> are
supported by Microchip PIC and Atmel AVR microcontrollers, events in <span class="blue"><span class="strong"><strong>blue</strong></span></span> are only supported by some
Microchip PIC microcontrollers, and events in <span class="red"><span class="strong"><strong>red</strong></span></span> are only supported by Atmel AVR microcontrollers.</p><p>Note that GCBASIC doesn&#8217;t fully support all of the hardware which can
generate interrupts - some work may be required with various system
variables to control the unsupported peripherals.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Event Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Description</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Supported</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>ADCReady</strong></span></span></p></td><td align="left" valign="top"><p>The analog/digital converter has finished a conversion</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>BatteryFail</strong></span></span></p></td><td align="left" valign="top"><p>The battery has failed in some way. This is only implemented on the ATmega406</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CANActivity</strong></span></span></p></td><td align="left" valign="top"><p>CAN bus activity is taking place</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CANBadMessage</strong></span></span></p></td><td align="left" valign="top"><p>A bad CAN message has been received</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>CANError</strong></span></span></p></td><td align="left" valign="top"><p>Some CAN error has occured</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CANHighWatermark</strong></span></span></p></td><td align="left" valign="top"><p>CAN high watermark reached</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CANRx0Ready</strong></span></span></p></td><td align="left" valign="top"><p>New message present in buffer 0</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CANRx1Ready</strong></span></span></p></td><td align="left" valign="top"><p>New message present in buffer 1</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CANRx2Ready</strong></span></span></p></td><td align="left" valign="top"><p>New message present in buffer 2</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CANRxReady</strong></span></span></p></td><td align="left" valign="top"><p>New message present</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>CANTransferComplete</strong></span></span></p></td><td align="left" valign="top"><p>Transfer of data has been completed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CANTx0Ready</strong></span></span></p></td><td align="left" valign="top"><p>Buffer 0 has been sent</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CANTx1Ready</strong></span></span></p></td><td align="left" valign="top"><p>Buffer 1 has been sent</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CANTx2Ready</strong></span></span></p></td><td align="left" valign="top"><p>Buffer 2 has been sent</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CANTxReady</strong></span></span></p></td><td align="left" valign="top"><p>Sending has completed</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>CCADCAccReady</strong></span></span></p></td><td align="left" valign="top"><p>CC ADC accumulate conversion finished (ATmega406 only)</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>CCADCReady</strong></span></span></p></td><td align="left" valign="top"><p>CC ADC instantaneous conversion finished (ATmega406 only)</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>CCADCRegular</strong></span></span></p></td><td align="left" valign="top"><p>CC ADC regular conversion finished (ATmega406 only)</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CCP1</strong></span></span></p></td><td align="left" valign="top"><p>The CCP1 module has captured an event</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CCP2</strong></span></span></p></td><td align="left" valign="top"><p>The CCP2 module has captured an event</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CCP3</strong></span></span></p></td><td align="left" valign="top"><p>The CCP3 module has captured an event</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CCP4</strong></span></span></p></td><td align="left" valign="top"><p>The CCP4 module has captured an event</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>CCP5</strong></span></span></p></td><td align="left" valign="top"><p>The CCP5 module has captured an event</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>Comp0Change</strong></span></span></p></td><td align="left" valign="top"><p>The output of comparator 0 has changed</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>Comp1Change</strong></span></span></p></td><td align="left" valign="top"><p>The output of comparator 1 has changed</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>Comp2Change</strong></span></span></p></td><td align="left" valign="top"><p>The output of comparator 2 has changed</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>Crypto</strong></span></span></p></td><td align="left" valign="top"><p>The KEELOQ module has generated an interrupt</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>EEPROMReady</strong></span></span></p></td><td align="left" valign="top"><p>An EEPROM write has finished</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>Ethernet</strong></span></span></p></td><td align="left" valign="top"><p>The Ethernet module has generated an interrupt. This must be dealt within the handler.</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>ExtInt0</strong></span></span></p></td><td align="left" valign="top"><p>External Interrupt pin 0 has been detected</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>ExtInt1</strong></span></span></p></td><td align="left" valign="top"><p>External Interrupt pin 1 has been detected</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>ExtInt2</strong></span></span></p></td><td align="left" valign="top"><p>External Interrupt pin 2 has been detected</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>ExtInt3</strong></span></span></p></td><td align="left" valign="top"><p>External Interrupt pin 3 has been detected</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>ExtInt4</strong></span></span></p></td><td align="left" valign="top"><p>External Interrupt pin 4 has been detected</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>ExtInt5</strong></span></span></p></td><td align="left" valign="top"><p>External Interrupt pin 5 has been detected</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>ExtInt6</strong></span></span></p></td><td align="left" valign="top"><p>External Interrupt pin 6 has been detected</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>ExtInt7</strong></span></span></p></td><td align="left" valign="top"><p>External Interrupt pin 7 has been detected</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>GPIOChange</strong></span></span></p></td><td align="left" valign="top"><p>The pins on port GPIO have changed</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>LCDReady</strong></span></span></p></td><td align="left" valign="top"><p>The LCD is about to draw a segment</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>LPWU</strong></span></span></p></td><td align="left" valign="top"><p>The Low Power Wake Up has been detected</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>OscillatorFail</strong></span></span></p></td><td align="left" valign="top"><p>The external oscillator has failed, and the microcontroller is running from an internal oscillator.</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PinChange</strong></span></span></p></td><td align="left" valign="top"><p>Logic level of PCINT pin has changed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PinChange0</strong></span></span></p></td><td align="left" valign="top"><p>Logic level of PCINT0 pin has changed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PinChange1</strong></span></span></p></td><td align="left" valign="top"><p>Logic level of PCINT1 pin has changed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PinChange2</strong></span></span></p></td><td align="left" valign="top"><p>Logic level of PCINT2 pin has changed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PinChange3</strong></span></span></p></td><td align="left" valign="top"><p>Logic level of PCINT3 pin has changed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PinChange4</strong></span></span></p></td><td align="left" valign="top"><p>Logic level of PCINT4 pin has changed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PinChange5</strong></span></span></p></td><td align="left" valign="top"><p>Logic level of PCINT5 pin has changed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PinChange6</strong></span></span></p></td><td align="left" valign="top"><p>Logic level of PCINT6 pin has changed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PinChange7</strong></span></span></p></td><td align="left" valign="top"><p>Logic level of PCINT7 pin has changed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>PMPReady</strong></span></span></p></td><td align="left" valign="top"><p>A Parallel Master Port read or write has finished</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>PORTChange</strong></span></span></p></td><td align="left" valign="top"><p>The pins on ports ABCEDEF have changed.  This is generic port change interrupt.  You must inspect the source to ensure you are handlign the correct interrupt.</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>PORTAChange</strong></span></span></p></td><td align="left" valign="top"><p>The pins on port A have changed</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>PORTABChange</strong></span></span></p></td><td align="left" valign="top"><p>The pins on port A and/or B have changed</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>PORTBChange</strong></span></span></p></td><td align="left" valign="top"><p>The pins on port B have changed</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PSC0Capture</strong></span></span></p></td><td align="left" valign="top"><p>The counter for Power Stage Controller 0 matches the value in a compare
register, the value of the counter has been captured, or a
synchronisation error has occurred</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PSC0EndCycle</strong></span></span></p></td><td align="left" valign="top"><p>Power Stage Controller 0 has reached the end of its cycle</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PSC1Capture</strong></span></span></p></td><td align="left" valign="top"><p>The counter for Power Stage Controller 1 matches the value in a compare
register, the value of the counter has been captured, or a
synchronisation error has occurred</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PSC1EndCycle</strong></span></span></p></td><td align="left" valign="top"><p>Power Stage Controller 1 has reached the end of its cycle</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PSC2Capture</strong></span></span></p></td><td align="left" valign="top"><p>The counter for Power Stage Controller 2 matches the value in a compare
register, the value of the counter has been captured, or a
synchronisation error has occurred</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>PSC2EndCycle</strong></span></span></p></td><td align="left" valign="top"><p>Power Stage Controller 2 has reached the end of its cycle</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>PSPReady</strong></span></span></p></td><td align="left" valign="top"><p>A Parallel Slave Port read or write has finished</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>PWMTimeBase</strong></span></span></p></td><td align="left" valign="top"><p>The PWM time base matches the PWM Time Base Period register (PTPER)</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>SPIReady</strong></span></span></p></td><td align="left" valign="top"><p>The SPI module has finished the previous transfer</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>SPMReady</strong></span></span></p></td><td align="left" valign="top"><p>A write to program memory by the spm instruction has finished</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>SPPReady</strong></span></span></p></td><td align="left" valign="top"><p>A SPP read or write has finished</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>SSP1Collision</strong></span></span></p></td><td align="left" valign="top"><p>SSP1 has detected a bus collision</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>SSP1Ready</strong></span></span></p></td><td align="left" valign="top"><p>The SSP/SSP1/MSSP1 module has finished sending or receiving</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>SSP2Collision</strong></span></span></p></td><td align="left" valign="top"><p>SSP2 has detected a bus collision</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>SSP2Ready</strong></span></span></p></td><td align="left" valign="top"><p>The SSP2/MSSP2 module has finished sending or receiving</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer0Capture</strong></span></span></p></td><td align="left" valign="top"><p>An input event on the pin ICP0 has caused the value of Timer 0 to be
captured in the ICR0 register</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer0Match1</strong></span></span></p></td><td align="left" valign="top"><p>Timer 0 matches the Timer 0 output compare register A (OCR0A)</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer0Match2</strong></span></span></p></td><td align="left" valign="top"><p>Timer 0 matches the Timer 0 output compare register B (OCR0B)</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>Timer0Overflow</strong></span></span></p></td><td align="left" valign="top"><p>Timer 0 has overflowed</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer1Capture</strong></span></span></p></td><td align="left" valign="top"><p>An input event on the pin ICP1 has caused the value of Timer 1 to be
captured in the ICR1 register</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer1Error</strong></span></span></p></td><td align="left" valign="top"><p>The Timer 1 Fault Protection unit has been detected by an input on the INT0
pin</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer1Match1</strong></span></span></p></td><td align="left" valign="top"><p>Timer 1 matches the Timer 1 output compare register A (OCR1A)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer1Match2</strong></span></span></p></td><td align="left" valign="top"><p>Timer 1 matches the Timer 1 output compare register B (OCR1B)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer1Match3</strong></span></span></p></td><td align="left" valign="top"><p>Timer 1 matches the Timer 1 output compare register C (OCR1C)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer1Match4</strong></span></span></p></td><td align="left" valign="top"><p>Timer 1 matches the Timer 1 output compare register D (OCR1D)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>Timer1Overflow</strong></span></span></p></td><td align="left" valign="top"><p>Timer 1 has overflowed</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>Timer2Match</strong></span></span></p></td><td align="left" valign="top"><p>Timer 2 matches the Timer 2 output compare register (PR2)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer2Match1</strong></span></span></p></td><td align="left" valign="top"><p>Timer 2 matches the Timer 2 output compare register A (OCR2A)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer2Match2</strong></span></span></p></td><td align="left" valign="top"><p>Timer 2 matches the Timer 2 output compare register B (OCR2B)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer2Overflow</strong></span></span></p></td><td align="left" valign="top"><p>Timer 2 has overflowed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer3Capture</strong></span></span></p></td><td align="left" valign="top"><p>An input event on the pin ICP3 has caused the value of Timer 3 to be
captured in the ICR3 register</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer3Match1</strong></span></span></p></td><td align="left" valign="top"><p>Timer 3 matches the Timer 3 output compare register A (OCR3A)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer3Match2</strong></span></span></p></td><td align="left" valign="top"><p>Timer 3 matches the Timer 3 output compare register B (OCR3B)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer3Match3</strong></span></span></p></td><td align="left" valign="top"><p>Timer 3 matches the Timer 3 output compare register C (OCR3C)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>Timer3Overflow</strong></span></span></p></td><td align="left" valign="top"><p>Timer 3 has overflowed</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer4Capture</strong></span></span></p></td><td align="left" valign="top"><p>An input event on the pin ICP4 has caused the value of Timer 4 to be
captured in the ICR4 register</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>Timer4Match</strong></span></span></p></td><td align="left" valign="top"><p>Timer 4 matches the Timer 4 output compare register (PR4)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer4Match1</strong></span></span></p></td><td align="left" valign="top"><p>Timer 4 matches the Timer 4 output compare register A (OCR4A)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer4Match2</strong></span></span></p></td><td align="left" valign="top"><p>Timer 4 matches the Timer 4 output compare register B (OCR4B)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer4Match3</strong></span></span></p></td><td align="left" valign="top"><p>Timer 4 matches the Timer 4 output compare register C (OCR4C)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer4Overflow</strong></span></span></p></td><td align="left" valign="top"><p>Timer 4 has overflowed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>Timer5CAP1</strong></span></span></p></td><td align="left" valign="top"><p>An input on the CAP1 pin has caused the value of Timer 5 to be captured
in CAP1BUF</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>Timer5CAP2</strong></span></span></p></td><td align="left" valign="top"><p>An input on the CAP2 pin has caused the value of Timer 5 to be captured
in CAP2BUF</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>Timer5CAP3</strong></span></span></p></td><td align="left" valign="top"><p>An input on the CAP3 pin has caused the value of Timer 5 to be captured
in CAP3BUF</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer5Capture</strong></span></span></p></td><td align="left" valign="top"><p>An input event on the pin ICP5 has caused the value of Timer 5 to be
captured in the ICR5 register</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer5Match1</strong></span></span></p></td><td align="left" valign="top"><p>Timer 5 matches the Timer 5 output compare register A (OCR5A)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer5Match2</strong></span></span></p></td><td align="left" valign="top"><p>Timer 5 matches the Timer 5 output compare register B (OCR5B)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>Timer5Match3</strong></span></span></p></td><td align="left" valign="top"><p>Timer 5 matches the Timer 5 output compare register C (OCR5C)<br>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>Timer5Overflow</strong></span></span></p></td><td align="left" valign="top"><p>Timer 5 has overflowed</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>Timer6Match</strong></span></span></p></td><td align="left" valign="top"><p>Timer 6 matches the Timer 6 output compare register (PR6)</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>Timer7Overflow</strong></span></span></p></td><td align="left" valign="top"><p>Timer 7 has overflowed</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>Timer8Match</strong></span></span></p></td><td align="left" valign="top"><p>Timer 8 matches the Timer 8 output compare register (PR8)</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>Timer10Match</strong></span></span></p></td><td align="left" valign="top"><p>Timer 10 matches the Timer 10 output compare register (PR10)</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>Timer12Match</strong></span></span></p></td><td align="left" valign="top"><p>Timer 12 matches the Timer 12 output compare register (PR12)</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>TWIConnect</strong></span></span></p></td><td align="left" valign="top"><p>The Atmel AVR has been connected to or disconnected from the TWI (I2C) bus</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>TWIReady</strong></span></span></p></td><td align="left" valign="top"><p>The TWI has finished the previous transmission and is ready to send or
receive more data</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>UsartRX1Ready</strong></span></span></p></td><td align="left" valign="top"><p>UART/USART 1 has received data</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>UsartRX2Ready</strong></span></span></p></td><td align="left" valign="top"><p>UART/USART 2 has received data</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>UsartRX3Ready</strong></span></span></p></td><td align="left" valign="top"><p>UART/USART 3 has received data</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>UsartRX4Ready</strong></span></span></p></td><td align="left" valign="top"><p>UART/USART 4 has received data</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>UsartTX1Ready</strong></span></span></p></td><td align="left" valign="top"><p>UART/USART 1 is ready to send data</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>UsartTX1Sent</strong></span></span></p></td><td align="left" valign="top"><p>UART/USART 1 has finished sending data</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>UsartTX2Ready</strong></span></span></p></td><td align="left" valign="top"><p>UART/USART 2 is ready to send data</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>UsartTX2Sent</strong></span></span></p></td><td align="left" valign="top"><p>UART/USART 2 has finished sending data</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>UsartTX3Ready</strong></span></span></p></td><td align="left" valign="top"><p>UART/USART 3 is ready to send data</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>UsartTX3Sent</strong></span></span></p></td><td align="left" valign="top"><p>UART/USART 3 has finished sending data</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>UsartTX4Ready</strong></span></span></p></td><td align="left" valign="top"><p>UART/USART 4 is ready to send data</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>UsartTX4Sent</strong></span></span></p></td><td align="left" valign="top"><p>UART/USART 4 has finished sending data</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>USBEndpoint</strong></span></span></p></td><td align="left" valign="top"><p>A USB endpoint has generated an interrupt</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="gray"><span class="strong"><strong>USB</strong></span></span></p></td><td align="left" valign="top"><p>The USB module has generated an interrupt. This must be dealt with in
the handler.</p></td><td align="left" valign="top"><p>Microchip&amp;AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>USIOverflow</strong></span></span></p></td><td align="left" valign="top"><p>The USI counter has overflowed from 15 to 0</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>USIStart</strong></span></span></p></td><td align="left" valign="top"><p>The USI module has detected a start condition</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="blue"><span class="strong"><strong>VoltageFail</strong></span></span></p></td><td align="left" valign="top"><p>The input voltage has dropped too low</p></td><td align="left" valign="top"><p>Microchip</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>VoltageRegulator</strong></span></span></p></td><td align="left" valign="top"><p>An interrupt has been generated by the voltage regulator (ATmega16HVA only)</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>WakeUp</strong></span></span></p></td><td align="left" valign="top"><p>The Wake-Up timer has overflowed</p></td><td align="left" valign="top"><p>AVR</p></td></tr><tr><td align="left" valign="top"><p><span class="red"><span class="strong"><strong>WDT</strong></span></span></p></td><td align="left" valign="top"><p>An interrupt has been generated by the Watchdog Timer</p></td><td align="left" valign="top"><p>AVR</p></td></tr></tbody></table></div><p><br>
<br>
<span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    'This program increments a counter every time Timer1 overflows
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    InitTimer1 Osc, PS1_1/8
    StartTimer 1
    CounterValue = 0

    Wait 100 ms
    Print "Int Test"

    On Interrupt Timer1Overflow Call IncCounter

    Do
        CLS
        Print CounterValue
        Wait 100 ms
    Loop

    Sub IncCounter
        CounterValue ++
    End Sub</pre><p><br>
<br>
<span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    'This example reflects the input signal on the output port.
    #chip mega328p, 16
    #option explicit

    'set out SOURCE interrupt port as an output
    dir portb.0 in

    'set/enable the mask for the specific input port
    'this is crutial - for a lot of the On Interrupt methods you will need to specify the interrupt source via a mask.bit.
    PCINT0 = 1

    'set out signal port as an output
    dir portB.5 out

    'setup the On Interrupt method
    On Interrupt PinChange0 Call TogglePin

    'maintain a loop
    do

    loop

    'handle the output signal
    'Note. The AVR automatically clears the Interrupt. Please study the datasheet for each specific microcontroller

    sub togglePin
        portb.5 =  !pinb.5
    end sub</pre><p><br>
<br>
<span class="strong"><strong>Example 3:</strong></span></p><pre class="screen">    'This example reflects the input signal on the output port from the external interrupt port.
    #Chip mega328p, 16
    #option explicit

    'Set external interrupt INTO input pin as an input
    dir portd.2 in

    'set out signal port as an output
    dir portB.5 out

    'hardware interrupt on Port D2
    INT0 = 1

    'set interrupt to a failing or rising edge
    'interrupt on falling edge
    EICRA = b'00000010'
        'or, alternatively you can set to a rising edge
    'EICRA = b'00000011'

    'set out signal port as an output
    dir portB.5 out

    'setup the On Interrupt method on external interrupt 0
    On Interrupt EXTINT0 Call togglePin

    'maintain a loop
    do

    loop

    'handle the output signal
    'Note. The AVR automatically clears the Interrupt. Please study the datasheet for each specific microcontroller

    sub togglePin
        portb.5 =  !pinb.5
    end sub</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_inittimer0.html" title="InitTimer0">InitTimer0</a> article contains
an example of using Timer 0 and On Interrupt to generate a Pulse Width
Modulation signal to control a motor.</p><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_intoff.html" title="IntOff">IntOff</a>, <a class="link" href="_inton.html" title="IntOn">IntOn</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="on_interrupt"></span>On Interrupt

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    On Interrupt event Call handler
    On Interrupt event Ignore
```

<span class="strong">**Command Availability:**</span>

Available on Microchip PIC and Atmel AVR microcontrollers with interrupt
support.

<span class="strong">**Explanation:**</span>

On Interrupt will add code to call the subroutine <span
class="emphasis">*handler*</span> whenever the interrupt <span
class="emphasis">*event*</span> occurs. When Call is specified, GCBASIC
will enable the interrupt, and call the interrupt handler when it
occurs. When Ignore is specified, GCBASIC will disable the interrupt
handler and prevent it from being called when the event occurs. If the
event occurs while the handler is disabled, then the handler will be
called as soon as it is re-enabled. The only way to prevent this from
happening is to manually clear the flag bit for the interrupt.

There are many possible interrupt events that can occur, and the events
vary greatly from chip to chip. GCBASIC will display an error if a given
chip cannot support the specified event.

On Interrupt may require the setting or clearing of the interrupt
register bit(s), and, On Interrupt may require setting of explicit
enable register bits. You should always consult the device datasheet for
these On Interrupt additional specific settings of register bits.
Typically, you will need define the 1) source event register bit(s) in
the main program, and, 2) clear or set the register bit at the start of
the of the interrupt handler subroutine.

GCBASIC has many demonstrations showing how to set and enable appropiate
interrupt register bits to support the On Interrupt method.

If On Interrupt is used to handle an event, then the Interrupt()
subroutine will not be called for that event. However, it will still be
called for any events not dealt with by On Interrupt.

<span class="strong">**Events:**</span>

GCBASIC supports the events shown on the table below. Some events are
only implemented on a few specialised chips. Events in <span
class="gray"><span class="strong">**grey**</span></span> are supported
by Microchip PIC and Atmel AVR microcontrollers, events in <span
class="blue"><span class="strong">**blue**</span></span> are only
supported by some Microchip PIC microcontrollers, and events in <span
class="red"><span class="strong">**red**</span></span> are only
supported by Atmel AVR microcontrollers.

Note that GCBASIC doesn’t fully support all of the hardware which can
generate interrupts - some work may be required with various system
variables to control the unsupported peripherals.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Event Name</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Description</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Supported</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>ADCReady</strong></span></span></p></td>
<td style="text-align: left;"><p>The analog/digital converter has finished a conversion</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>BatteryFail</strong></span></span></p></td>
<td style="text-align: left;"><p>The battery has failed in some way. This is only implemented on the ATmega406</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CANActivity</strong></span></span></p></td>
<td style="text-align: left;"><p>CAN bus activity is taking place</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CANBadMessage</strong></span></span></p></td>
<td style="text-align: left;"><p>A bad CAN message has been received</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>CANError</strong></span></span></p></td>
<td style="text-align: left;"><p>Some CAN error has occured</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CANHighWatermark</strong></span></span></p></td>
<td style="text-align: left;"><p>CAN high watermark reached</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CANRx0Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>New message present in buffer 0</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CANRx1Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>New message present in buffer 1</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CANRx2Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>New message present in buffer 2</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CANRxReady</strong></span></span></p></td>
<td style="text-align: left;"><p>New message present</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>CANTransferComplete</strong></span></span></p></td>
<td style="text-align: left;"><p>Transfer of data has been completed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CANTx0Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>Buffer 0 has been sent</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CANTx1Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>Buffer 1 has been sent</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CANTx2Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>Buffer 2 has been sent</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CANTxReady</strong></span></span></p></td>
<td style="text-align: left;"><p>Sending has completed</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>CCADCAccReady</strong></span></span></p></td>
<td style="text-align: left;"><p>CC ADC accumulate conversion finished (ATmega406 only)</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>CCADCReady</strong></span></span></p></td>
<td style="text-align: left;"><p>CC ADC instantaneous conversion finished (ATmega406 only)</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>CCADCRegular</strong></span></span></p></td>
<td style="text-align: left;"><p>CC ADC regular conversion finished (ATmega406 only)</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CCP1</strong></span></span></p></td>
<td style="text-align: left;"><p>The CCP1 module has captured an event</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CCP2</strong></span></span></p></td>
<td style="text-align: left;"><p>The CCP2 module has captured an event</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CCP3</strong></span></span></p></td>
<td style="text-align: left;"><p>The CCP3 module has captured an event</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CCP4</strong></span></span></p></td>
<td style="text-align: left;"><p>The CCP4 module has captured an event</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>CCP5</strong></span></span></p></td>
<td style="text-align: left;"><p>The CCP5 module has captured an event</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>Comp0Change</strong></span></span></p></td>
<td style="text-align: left;"><p>The output of comparator 0 has changed</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>Comp1Change</strong></span></span></p></td>
<td style="text-align: left;"><p>The output of comparator 1 has changed</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>Comp2Change</strong></span></span></p></td>
<td style="text-align: left;"><p>The output of comparator 2 has changed</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>Crypto</strong></span></span></p></td>
<td style="text-align: left;"><p>The KEELOQ module has generated an interrupt</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>EEPROMReady</strong></span></span></p></td>
<td style="text-align: left;"><p>An EEPROM write has finished</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>Ethernet</strong></span></span></p></td>
<td style="text-align: left;"><p>The Ethernet module has generated an interrupt. This must be dealt within the handler.</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>ExtInt0</strong></span></span></p></td>
<td style="text-align: left;"><p>External Interrupt pin 0 has been detected</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>ExtInt1</strong></span></span></p></td>
<td style="text-align: left;"><p>External Interrupt pin 1 has been detected</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>ExtInt2</strong></span></span></p></td>
<td style="text-align: left;"><p>External Interrupt pin 2 has been detected</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>ExtInt3</strong></span></span></p></td>
<td style="text-align: left;"><p>External Interrupt pin 3 has been detected</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>ExtInt4</strong></span></span></p></td>
<td style="text-align: left;"><p>External Interrupt pin 4 has been detected</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>ExtInt5</strong></span></span></p></td>
<td style="text-align: left;"><p>External Interrupt pin 5 has been detected</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>ExtInt6</strong></span></span></p></td>
<td style="text-align: left;"><p>External Interrupt pin 6 has been detected</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>ExtInt7</strong></span></span></p></td>
<td style="text-align: left;"><p>External Interrupt pin 7 has been detected</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>GPIOChange</strong></span></span></p></td>
<td style="text-align: left;"><p>The pins on port GPIO have changed</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>LCDReady</strong></span></span></p></td>
<td style="text-align: left;"><p>The LCD is about to draw a segment</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>LPWU</strong></span></span></p></td>
<td style="text-align: left;"><p>The Low Power Wake Up has been detected</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>OscillatorFail</strong></span></span></p></td>
<td style="text-align: left;"><p>The external oscillator has failed, and the microcontroller is running from an internal oscillator.</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PinChange</strong></span></span></p></td>
<td style="text-align: left;"><p>Logic level of PCINT pin has changed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PinChange0</strong></span></span></p></td>
<td style="text-align: left;"><p>Logic level of PCINT0 pin has changed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PinChange1</strong></span></span></p></td>
<td style="text-align: left;"><p>Logic level of PCINT1 pin has changed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PinChange2</strong></span></span></p></td>
<td style="text-align: left;"><p>Logic level of PCINT2 pin has changed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PinChange3</strong></span></span></p></td>
<td style="text-align: left;"><p>Logic level of PCINT3 pin has changed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PinChange4</strong></span></span></p></td>
<td style="text-align: left;"><p>Logic level of PCINT4 pin has changed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PinChange5</strong></span></span></p></td>
<td style="text-align: left;"><p>Logic level of PCINT5 pin has changed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PinChange6</strong></span></span></p></td>
<td style="text-align: left;"><p>Logic level of PCINT6 pin has changed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PinChange7</strong></span></span></p></td>
<td style="text-align: left;"><p>Logic level of PCINT7 pin has changed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>PMPReady</strong></span></span></p></td>
<td style="text-align: left;"><p>A Parallel Master Port read or write has finished</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>PORTChange</strong></span></span></p></td>
<td style="text-align: left;"><p>The pins on ports ABCEDEF have changed. This is generic port change interrupt. You must inspect the source to ensure you are handlign the correct interrupt.</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>PORTAChange</strong></span></span></p></td>
<td style="text-align: left;"><p>The pins on port A have changed</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>PORTABChange</strong></span></span></p></td>
<td style="text-align: left;"><p>The pins on port A and/or B have changed</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>PORTBChange</strong></span></span></p></td>
<td style="text-align: left;"><p>The pins on port B have changed</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PSC0Capture</strong></span></span></p></td>
<td style="text-align: left;"><p>The counter for Power Stage Controller 0 matches the value in a compare register, the value of the counter has been captured, or a synchronisation error has occurred</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PSC0EndCycle</strong></span></span></p></td>
<td style="text-align: left;"><p>Power Stage Controller 0 has reached the end of its cycle</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PSC1Capture</strong></span></span></p></td>
<td style="text-align: left;"><p>The counter for Power Stage Controller 1 matches the value in a compare register, the value of the counter has been captured, or a synchronisation error has occurred</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PSC1EndCycle</strong></span></span></p></td>
<td style="text-align: left;"><p>Power Stage Controller 1 has reached the end of its cycle</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PSC2Capture</strong></span></span></p></td>
<td style="text-align: left;"><p>The counter for Power Stage Controller 2 matches the value in a compare register, the value of the counter has been captured, or a synchronisation error has occurred</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>PSC2EndCycle</strong></span></span></p></td>
<td style="text-align: left;"><p>Power Stage Controller 2 has reached the end of its cycle</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>PSPReady</strong></span></span></p></td>
<td style="text-align: left;"><p>A Parallel Slave Port read or write has finished</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>PWMTimeBase</strong></span></span></p></td>
<td style="text-align: left;"><p>The PWM time base matches the PWM Time Base Period register (PTPER)</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>SPIReady</strong></span></span></p></td>
<td style="text-align: left;"><p>The SPI module has finished the previous transfer</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>SPMReady</strong></span></span></p></td>
<td style="text-align: left;"><p>A write to program memory by the spm instruction has finished</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>SPPReady</strong></span></span></p></td>
<td style="text-align: left;"><p>A SPP read or write has finished</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>SSP1Collision</strong></span></span></p></td>
<td style="text-align: left;"><p>SSP1 has detected a bus collision</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>SSP1Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>The SSP/SSP1/MSSP1 module has finished sending or receiving</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>SSP2Collision</strong></span></span></p></td>
<td style="text-align: left;"><p>SSP2 has detected a bus collision</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>SSP2Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>The SSP2/MSSP2 module has finished sending or receiving</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer0Capture</strong></span></span></p></td>
<td style="text-align: left;"><p>An input event on the pin ICP0 has caused the value of Timer 0 to be captured in the ICR0 register</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer0Match1</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 0 matches the Timer 0 output compare register A (OCR0A)</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer0Match2</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 0 matches the Timer 0 output compare register B (OCR0B)</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>Timer0Overflow</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 0 has overflowed</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer1Capture</strong></span></span></p></td>
<td style="text-align: left;"><p>An input event on the pin ICP1 has caused the value of Timer 1 to be captured in the ICR1 register</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer1Error</strong></span></span></p></td>
<td style="text-align: left;"><p>The Timer 1 Fault Protection unit has been detected by an input on the INT0 pin</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer1Match1</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 1 matches the Timer 1 output compare register A (OCR1A)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer1Match2</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 1 matches the Timer 1 output compare register B (OCR1B)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer1Match3</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 1 matches the Timer 1 output compare register C (OCR1C)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer1Match4</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 1 matches the Timer 1 output compare register D (OCR1D)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>Timer1Overflow</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 1 has overflowed</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>Timer2Match</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 2 matches the Timer 2 output compare register (PR2)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer2Match1</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 2 matches the Timer 2 output compare register A (OCR2A)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer2Match2</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 2 matches the Timer 2 output compare register B (OCR2B)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer2Overflow</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 2 has overflowed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer3Capture</strong></span></span></p></td>
<td style="text-align: left;"><p>An input event on the pin ICP3 has caused the value of Timer 3 to be captured in the ICR3 register</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer3Match1</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 3 matches the Timer 3 output compare register A (OCR3A)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer3Match2</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 3 matches the Timer 3 output compare register B (OCR3B)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer3Match3</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 3 matches the Timer 3 output compare register C (OCR3C)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>Timer3Overflow</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 3 has overflowed</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer4Capture</strong></span></span></p></td>
<td style="text-align: left;"><p>An input event on the pin ICP4 has caused the value of Timer 4 to be captured in the ICR4 register</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>Timer4Match</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 4 matches the Timer 4 output compare register (PR4)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer4Match1</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 4 matches the Timer 4 output compare register A (OCR4A)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer4Match2</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 4 matches the Timer 4 output compare register B (OCR4B)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer4Match3</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 4 matches the Timer 4 output compare register C (OCR4C)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer4Overflow</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 4 has overflowed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>Timer5CAP1</strong></span></span></p></td>
<td style="text-align: left;"><p>An input on the CAP1 pin has caused the value of Timer 5 to be captured in CAP1BUF</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>Timer5CAP2</strong></span></span></p></td>
<td style="text-align: left;"><p>An input on the CAP2 pin has caused the value of Timer 5 to be captured in CAP2BUF</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>Timer5CAP3</strong></span></span></p></td>
<td style="text-align: left;"><p>An input on the CAP3 pin has caused the value of Timer 5 to be captured in CAP3BUF</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer5Capture</strong></span></span></p></td>
<td style="text-align: left;"><p>An input event on the pin ICP5 has caused the value of Timer 5 to be captured in the ICR5 register</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer5Match1</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 5 matches the Timer 5 output compare register A (OCR5A)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer5Match2</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 5 matches the Timer 5 output compare register B (OCR5B)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>Timer5Match3</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 5 matches the Timer 5 output compare register C (OCR5C)<br />
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>Timer5Overflow</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 5 has overflowed</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>Timer6Match</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 6 matches the Timer 6 output compare register (PR6)</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>Timer7Overflow</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 7 has overflowed</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>Timer8Match</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 8 matches the Timer 8 output compare register (PR8)</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>Timer10Match</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 10 matches the Timer 10 output compare register (PR10)</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>Timer12Match</strong></span></span></p></td>
<td style="text-align: left;"><p>Timer 12 matches the Timer 12 output compare register (PR12)</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>TWIConnect</strong></span></span></p></td>
<td style="text-align: left;"><p>The Atmel AVR has been connected to or disconnected from the TWI (I2C) bus</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>TWIReady</strong></span></span></p></td>
<td style="text-align: left;"><p>The TWI has finished the previous transmission and is ready to send or receive more data</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>UsartRX1Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>UART/USART 1 has received data</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>UsartRX2Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>UART/USART 2 has received data</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>UsartRX3Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>UART/USART 3 has received data</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>UsartRX4Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>UART/USART 4 has received data</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>UsartTX1Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>UART/USART 1 is ready to send data</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>UsartTX1Sent</strong></span></span></p></td>
<td style="text-align: left;"><p>UART/USART 1 has finished sending data</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>UsartTX2Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>UART/USART 2 is ready to send data</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>UsartTX2Sent</strong></span></span></p></td>
<td style="text-align: left;"><p>UART/USART 2 has finished sending data</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>UsartTX3Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>UART/USART 3 is ready to send data</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>UsartTX3Sent</strong></span></span></p></td>
<td style="text-align: left;"><p>UART/USART 3 has finished sending data</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>UsartTX4Ready</strong></span></span></p></td>
<td style="text-align: left;"><p>UART/USART 4 is ready to send data</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>UsartTX4Sent</strong></span></span></p></td>
<td style="text-align: left;"><p>UART/USART 4 has finished sending data</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>USBEndpoint</strong></span></span></p></td>
<td style="text-align: left;"><p>A USB endpoint has generated an interrupt</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="gray"><span class="strong"><strong>USB</strong></span></span></p></td>
<td style="text-align: left;"><p>The USB module has generated an interrupt. This must be dealt with in the handler.</p></td>
<td style="text-align: left;"><p>Microchip&amp;AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>USIOverflow</strong></span></span></p></td>
<td style="text-align: left;"><p>The USI counter has overflowed from 15 to 0</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>USIStart</strong></span></span></p></td>
<td style="text-align: left;"><p>The USI module has detected a start condition</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="blue"><span class="strong"><strong>VoltageFail</strong></span></span></p></td>
<td style="text-align: left;"><p>The input voltage has dropped too low</p></td>
<td style="text-align: left;"><p>Microchip</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>VoltageRegulator</strong></span></span></p></td>
<td style="text-align: left;"><p>An interrupt has been generated by the voltage regulator (ATmega16HVA only)</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>WakeUp</strong></span></span></p></td>
<td style="text-align: left;"><p>The Wake-Up timer has overflowed</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="red"><span class="strong"><strong>WDT</strong></span></span></p></td>
<td style="text-align: left;"><p>An interrupt has been generated by the Watchdog Timer</p></td>
<td style="text-align: left;"><p>AVR</p></td>
</tr>
</tbody>
</table>

</div>

  
  
<span class="strong">**Example 1:**</span>

``` screen
    'This program increments a counter every time Timer1 overflows
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    InitTimer1 Osc, PS1_1/8
    StartTimer 1
    CounterValue = 0

    Wait 100 ms
    Print "Int Test"

    On Interrupt Timer1Overflow Call IncCounter

    Do
        CLS
        Print CounterValue
        Wait 100 ms
    Loop

    Sub IncCounter
        CounterValue ++
    End Sub
```

  
  
<span class="strong">**Example 2:**</span>

``` screen
    'This example reflects the input signal on the output port.
    #chip mega328p, 16
    #option explicit

    'set out SOURCE interrupt port as an output
    dir portb.0 in

    'set/enable the mask for the specific input port
    'this is crutial - for a lot of the On Interrupt methods you will need to specify the interrupt source via a mask.bit.
    PCINT0 = 1

    'set out signal port as an output
    dir portB.5 out

    'setup the On Interrupt method
    On Interrupt PinChange0 Call TogglePin

    'maintain a loop
    do

    loop

    'handle the output signal
    'Note. The AVR automatically clears the Interrupt. Please study the datasheet for each specific microcontroller

    sub togglePin
        portb.5 =  !pinb.5
    end sub
```

  
  
<span class="strong">**Example 3:**</span>

``` screen
    'This example reflects the input signal on the output port from the external interrupt port.
    #Chip mega328p, 16
    #option explicit

    'Set external interrupt INTO input pin as an input
    dir portd.2 in

    'set out signal port as an output
    dir portB.5 out

    'hardware interrupt on Port D2
    INT0 = 1

    'set interrupt to a failing or rising edge
    'interrupt on falling edge
    EICRA = b'00000010'
        'or, alternatively you can set to a rising edge
    'EICRA = b'00000011'

    'set out signal port as an output
    dir portB.5 out

    'setup the On Interrupt method on external interrupt 0
    On Interrupt EXTINT0 Call togglePin

    'maintain a loop
    do

    loop

    'handle the output signal
    'Note. The AVR automatically clears the Interrupt. Please study the datasheet for each specific microcontroller

    sub togglePin
        portb.5 =  !pinb.5
    end sub
```

<span class="strong">**For more help, see**</span>
<a href="inittimer0" class="link" title="InitTimer0">InitTimer0</a>
article contains an example of using Timer 0 and On Interrupt to
generate a Pulse Width Modulation signal to control a motor.

<span class="strong">**See also**</span>
<a href="intoff" class="link" title="IntOff">IntOff</a>,
<a href="inton" class="link" title="IntOn">IntOn</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>On Interrupt: The default handler</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_interrupts.html" title="Interrupts"><link rel="prev" href="_on_interrupt.html" title="On Interrupt"><link rel="next" href="_keypad.html" title="Keypad"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_on_interrupt_the_default_handler"></a>On Interrupt: The default handler</h4></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>GCBASIC supports a default interrupt handler in two modes:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">You can define the interrupt flags and the default handler (a sub routine) will executed</li><li class="listitem">You can define an On Interrupt  event Call handler  where the handler is executed that matches the event
and where all other define/valid events are handled by the default handler (a sub routine),
The easiest way to write an interrupt handler is to write it in GCBASIC in conjunction with the On Interrupt statement.
On Interrupt tells microcontroller to activate its internal interrupt handling and to jump to a predetermined interrupt
handler (a sub routine that has been defined) when the interrupt handler (the sub routine) has completed processing returns
to correct address in the program.  See <a class="link" href="_on_interrupt.html" title="On Interrupt">On Interrupt</a>.</li></ol></div><p>This method of supports the handling interrupts by enabling a default interrupt subroutine.</p><p><span class="strong"><strong>Example 1</strong></span></p><p>This example shows if an event occurs the microcontroller will be program to jump to the interrupt vector and the program will not know the event type, it will simple execute the Interrupt subroutine.
This code is not intended as a meaningful solution and intended to show the functionality only.
An LED is attached to PORTB.1 via a suitable resistor.  It will light up when the Interrupt event has occurred.</p><pre class="screen">    #chip 16f877a, 4
    dir PORTB.1 out
    Set PORTB.1 Off

    'Note: there is NO On Interrupt handler
    InitTimer1 Osc, PS1_8
    SetTimer 1, 1
    StartTimer 1
    'Manually set Timer1Overflow to the overflow event
    'this will event will be handled by the Interrupt sub routine
    TMR1IE = 1
    end

    Sub Interrupt
      Set PORTB.1 On
      TMR1IF = 0
    End Sub</pre><p><span class="strong"><strong>Example 2</strong></span></p><p>Any events that are not dealt with by On Interrupt will result in the code in the Interrupt subroutine executing.
This example shows the operation of two interrupt handlers - is not intended as a meaningful solution.</p><p>LEDs are attached to PORTB.1 and PORTB.2 via suitable resistors.  They will light up when the Interrupt events occur.</p><pre class="screen">    #chip 16f877a, 4
    On Interrupt Timer1Overflow call Overflowed

    dir PORTB.1 out
    Set PORTB.1 Off

    dir PORTB.2 out
    Set PORTB.2 Off

    InitTimer1 Osc, PS1_8
    SetTimer 1, 1
    StartTimer 1

    InitTimer2 PS2_16, PS2_16
    SetTimer 2, 255
    StartTimer 2

    'Manually set Timer2Overflow to create a second event
    'this will event will be handled by the Interrupt sub routine
    TMR2IE = 1
    end

    Sub Interrupt
      Set PORTB.2 On
      TMR2IF = 0
    End Sub

    Sub Overflowed
      Set PORTB.1 On
      TMR1IF = 0
    End Sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="on_interrupt_the_default_handler"></span>On Interrupt: The default handler

</div>

</div>

</div>

<span class="strong">**Introduction**</span>

GCBASIC supports a default interrupt handler in two modes:

<div class="orderedlist">

1.  You can define the interrupt flags and the default handler (a sub
    routine) will executed
2.  You can define an On Interrupt event Call handler where the handler
    is executed that matches the event and where all other define/valid
    events are handled by the default handler (a sub routine), The
    easiest way to write an interrupt handler is to write it in GCBASIC
    in conjunction with the On Interrupt statement. On Interrupt tells
    microcontroller to activate its internal interrupt handling and to
    jump to a predetermined interrupt handler (a sub routine that has
    been defined) when the interrupt handler (the sub routine) has
    completed processing returns to correct address in the program. See
    <a href="on_interrupt" class="link" title="On Interrupt">On Interrupt</a>.

</div>

This method of supports the handling interrupts by enabling a default
interrupt subroutine.

<span class="strong">**Example 1**</span>

This example shows if an event occurs the microcontroller will be
program to jump to the interrupt vector and the program will not know
the event type, it will simple execute the Interrupt subroutine. This
code is not intended as a meaningful solution and intended to show the
functionality only. An LED is attached to PORTB.1 via a suitable
resistor. It will light up when the Interrupt event has occurred.

``` screen
    #chip 16f877a, 4
    dir PORTB.1 out
    Set PORTB.1 Off

    'Note: there is NO On Interrupt handler
    InitTimer1 Osc, PS1_8
    SetTimer 1, 1
    StartTimer 1
    'Manually set Timer1Overflow to the overflow event
    'this will event will be handled by the Interrupt sub routine
    TMR1IE = 1
    end

    Sub Interrupt
      Set PORTB.1 On
      TMR1IF = 0
    End Sub
```

<span class="strong">**Example 2**</span>

Any events that are not dealt with by On Interrupt will result in the
code in the Interrupt subroutine executing. This example shows the
operation of two interrupt handlers - is not intended as a meaningful
solution.

LEDs are attached to PORTB.1 and PORTB.2 via suitable resistors. They
will light up when the Interrupt events occur.

``` screen
    #chip 16f877a, 4
    On Interrupt Timer1Overflow call Overflowed

    dir PORTB.1 out
    Set PORTB.1 Off

    dir PORTB.2 out
    Set PORTB.2 Off

    InitTimer1 Osc, PS1_8
    SetTimer 1, 1
    StartTimer 1

    InitTimer2 PS2_16, PS2_16
    SetTimer 2, 255
    StartTimer 2

    'Manually set Timer2Overflow to create a second event
    'this will event will be handled by the Interrupt sub routine
    TMR2IE = 1
    end

    Sub Interrupt
      Set PORTB.2 On
      TMR2IF = 0
    End Sub

    Sub Overflowed
      Set PORTB.1 On
      TMR1IF = 0
    End Sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Other directives</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__mem.html" title="#mem"><link rel="next" href="_compiler_options.html" title="Compiler Options"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_other_directives"></a>Other directives</h3></div></div></div><p>The built-in <code class="literal">#defines</code> are used to support the <code class="literal">#IFDEF</code> command set are as follows. The table also shows which <code class="literal">#defines</code> are supported as string in HSerPrint, SerPrint and other string related commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Type</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Usage</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Decription</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">CHIPADC</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Conditional compilation  or output commands</p></td><td align="left" valign="top"><p>The number of A/D inputs on the current chip</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPASSEMBLER</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Conditional compilation  or output commands</p></td><td align="left" valign="top"><p>The select assemble GCASM/MPASM/PICAS etc</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPEEPROM</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Conditional compilation  or output commands</p></td><td align="left" valign="top"><p>The number of Bytes in EEPROM memmory</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPIO</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Conditional compilation  or output commands</p></td><td align="left" valign="top"><p>The number of general purpose IO pins</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPMHZ</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Conditional compilation  or output commands</p></td><td align="left" valign="top"><p>The microcontroller clock speed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPNAME</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Conditional compilation only</p></td><td align="left" valign="top"><p>The microcontroller type</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPNAMESTR</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Conditional compilation  or output commands</p></td><td align="left" valign="top"><p>The microcontroller name</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPPINS</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Conditional compilation  or output commands</p></td><td align="left" valign="top"><p>The number of microcontroller pins.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPRESERVEHIGHPROG</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Scripts, Conditional compilation, and  output commands</p></td><td align="left" valign="top"><p>The value of the words reserved</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPOSC</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Scripts, Conditional compilation, and  output commands</p></td><td align="left" valign="top"><p>The frequency selected</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPUSINGINTOSC</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Scripts, Conditional compilation, and  output commands</p></td><td align="left" valign="top"><p>The constant exists if the compiler has deternined the program is using the internal oscillator</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPPROGRAMMERNAMESTR</code></p></td><td align="left" valign="top"><p>String constant</p></td><td align="left" valign="top"><p>Name of the chip type to be used by a programmer</p></td><td align="left" valign="top"><p>The psuedo microcontroller type</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPRAM</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Conditional compilation  or output commands</p></td><td align="left" valign="top"><p>The RAM size</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPSHAREDRAM</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Conditional compilation  or output commands</p></td><td align="left" valign="top"><p>The first RAM location</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPFAMILY</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Conditional compilation  or output commands</p></td><td align="left" valign="top"><p>See the table below</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPWORDS</code></p></td><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Conditional compilation  or output commands</p></td><td align="left" valign="top"><p>The number of WORDS in Flash memmory</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SOURCEFILE</code></p></td><td align="left" valign="top"><p>Constant string</p></td><td align="left" valign="top"><p>Conditional compilation  or output commands</p></td><td align="left" valign="top"><p>The name of the source GCB file</p></td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Function</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Type</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Usage</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Var()</code></p></td><td align="left" valign="top"><p>Function</p></td><td align="left" valign="top"><p>Conditional compilation only</p></td><td align="left" valign="top"><p>True if a register is declared (or false if not declared) in the currently specficied microcontroller&#8217;s .dat file.
</p><p>Var(register_name)</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">NoVar()</code></p></td><td align="left" valign="top"><p>Function</p></td><td align="left" valign="top"><p>Conditional compilation only</p></td><td align="left" valign="top"><p>True if a register is NOT declared (or false if declared) in the currently specficied microcontroller&#8217;s .dat file.
</p><p>NoVar(register_name)</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Bit()</code></p></td><td align="left" valign="top"><p>Function</p></td><td align="left" valign="top"><p>Conditional compilation only</p></td><td align="left" valign="top"><p>True if a bit is declared (or false if not declared) in the currently specficied microcontroller&#8217;s .dat file.
</p><p>Bit(bit_name)</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">NoBit()</code></p></td><td align="left" valign="top"><p>Function</p></td><td align="left" valign="top"><p>Conditional compilation only</p></td><td align="left" valign="top"><p>True if a bit is NOT declared (or false if declared) in the currently specficied microcontroller&#8217;s .dat file.
</p><p>NoBit(bit_name)</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Allof()</code></p></td><td align="left" valign="top"><p>Function</p></td><td align="left" valign="top"><p>Conditional compilation only</p></td><td align="left" valign="top"><p>True if all defines are declared:
</p><p><code class="literal">AllOf(define1, define2, &#8230;)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">OneOf()</code></p></td><td align="left" valign="top"><p>Function</p></td><td align="left" valign="top"><p>Conditional compilation only</p></td><td align="left" valign="top"><p>True if one of the defines is declared:
</p><p><code class="literal">OneOf(define1, define2, &#8230;)</code></p></td></tr></tbody></table></div><p><br>
<br>
The table below shows two special directives that support the mapping for one variable or bit to anoher variable or bit.  This is useful when creating portable code or libraries to ensure GCBASIC
<br>
<br>
<br>
<br></p><div class="informaltable"><table border="1" width="100%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Directive</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Explanation</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Usage</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>#samebit</p></td><td align="left" valign="top"><p>The compiler checks each item in the list to see which ones are implemented on the current microcontroller.
<br>
If any of the bits do not exist, the compiler will create a constant mapping to the  name of the first parameter in the list of parameters that does exist.
 + If none of the bits exist the no constant is created.</p></td><td align="left" valign="top"><p>&nbsp;&nbsp;#samebit PLLEN, SPLLEN, SPLLMULT
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Set SPLLEN On
<br></p></td></tr><tr><td align="left" valign="top"><p>#samevar</p></td><td align="left" valign="top"><p>The compiler checks each item in the list to see which ones are implemented on the current microcontroller.
<br>
If any of the variables do not exist, the compiler will create a constant mapping to the  name of the first parameter in the list of parameters that does exist.
 + If none of the variables exist the no constant is created.</p></td><td align="left" valign="top"><p>&nbsp;&nbsp;#samevar CMCON, CMCON0, CMCONbob<br>
&nbsp;&nbsp;#ifdef Var(CMCONbob)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CMCONbob = 7<br>
&nbsp;&nbsp;#endif<br>
<br>
&nbsp;&nbsp;Compiles to:<br>
&nbsp;&nbsp;;CMCONbob = 7<br>
&nbsp;&nbsp;movlw 7<br>
&nbsp;&nbsp;movwf CMCON,ACCESS<br>
<br></p></td></tr></tbody></table></div><p><br>
<br></p><p>This table shows the ChipFamily constants mapped to the microcontroller architecture.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>ChipFamily Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Microcontroller Characteristics</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>PIC</strong></span></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p>100</p></td><td align="left" valign="top"><p>AVR core version V0E class microcontrollers</p></td></tr><tr><td align="left" valign="top"><p>110</p></td><td align="left" valign="top"><p>AVR core version V1E class microcontrollers</p></td></tr><tr><td align="left" valign="top"><p>120</p></td><td align="left" valign="top"><p>AVR core version V2E class microcontrollers</p></td></tr><tr><td align="left" valign="top"><p>-120 Subtype: 121</p></td><td align="left" valign="top"><p>AVR core version AVR8L, also called AVRrc, reduced core class microcontrollers.  ATTiny4-5-9-10 and ATTiny102-104 with only 16 GPR&#8217;s from r16-r31 and only 54 instructions.</p></td></tr><tr><td align="left" valign="top"><p>-120 Subtype: 122</p></td><td align="left" valign="top"><p>LGT microcontrollers.</p></td></tr><tr><td align="left" valign="top"><p>-120 Subtype: 123</p></td><td align="left" valign="top"><p>AVR core version V2E class microcontrollers with one USART like the mega32u4, mega16u4 - they have different registers for the usart.</p></td></tr><tr><td align="left" valign="top"><p>121</p></td><td align="left" valign="top"><p>Tiny4-5-9-10 and tiny102-104. Only 16 GPR&#8217;s from r16-r31 and only 54 instructions.</p></td></tr><tr><td align="left" valign="top"><p>130</p></td><td align="left" valign="top"><p>AVR core version V3E class microcontrollers but essentially the mega32u6 only</p></td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>AVR</strong></span></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p>12</p></td><td align="left" valign="top"><p>Baseline devices. 12 Bit instruction set</p></td></tr><tr><td align="left" valign="top"><p>15</p></td><td align="left" valign="top"><p>Mid-range core devices. 14 Bit instruction set with enhanced instruction set class</p></td></tr><tr><td align="left" valign="top"><p>15 plus familyVariant=1</p></td><td align="left" valign="top"><p>Mid-range core devices. 14 Bit instruction set with enhanced instruction set  and with large memory capability class</p></td></tr><tr><td align="left" valign="top"><p>16</p></td><td align="left" valign="top"><p>High end core devices. 16 Bit instruction set, memory addressing architecture and an extended instruction set.
</p><p>Chip family 16 also have a sub chip family Constant.&nbsp;&nbsp; These constants are shown below:
</p><p>    &nbsp;&nbsp;&nbsp;&nbsp;ChipFamily18FxxQ10 = 16100
</p><p>    &nbsp;&nbsp;&nbsp;&nbsp;ChipFamily18FxxQ43 = 16101
</p><p>    &nbsp;&nbsp;&nbsp;&nbsp;ChipFamily18FxxQ41 = 16102
</p><p>    &nbsp;&nbsp;&nbsp;&nbsp;ChipFamily18FxxK42 = 16103
</p><p>    &nbsp;&nbsp;&nbsp;&nbsp;ChipFamily18FxxK40 = 16104
</p><p>    &nbsp;&nbsp;&nbsp;&nbsp;ChipFamily18FxxQ40 = 16105
</p><p>    &nbsp;&nbsp;&nbsp;&nbsp;ChipFamily18FxxQ84 = 16106
</p><p>    &nbsp;&nbsp;&nbsp;&nbsp;ChipFamily18FxxK83 = 16107
</p><p>    &nbsp;&nbsp;&nbsp;&nbsp;ChipFamily18FxxQ83 = 16108</p></td></tr></tbody></table></div><p><br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="other_directives"></span>Other directives

</div>

</div>

</div>

The built-in `#defines` are used to support the `#IFDEF` command set are
as follows. The table also shows which `#defines` are supported as
string in HSerPrint, SerPrint and other string related commands.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Type</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Usage</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Decription</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">CHIPADC</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Conditional compilation or output commands</p></td>
<td style="text-align: left;"><p>The number of A/D inputs on the current chip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">CHIPASSEMBLER</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Conditional compilation or output commands</p></td>
<td style="text-align: left;"><p>The select assemble GCASM/MPASM/PICAS etc</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">CHIPEEPROM</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Conditional compilation or output commands</p></td>
<td style="text-align: left;"><p>The number of Bytes in EEPROM memmory</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">CHIPIO</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Conditional compilation or output commands</p></td>
<td style="text-align: left;"><p>The number of general purpose IO pins</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">CHIPMHZ</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Conditional compilation or output commands</p></td>
<td style="text-align: left;"><p>The microcontroller clock speed</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">CHIPNAME</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Conditional compilation only</p></td>
<td style="text-align: left;"><p>The microcontroller type</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">CHIPNAMESTR</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Conditional compilation or output commands</p></td>
<td style="text-align: left;"><p>The microcontroller name</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">CHIPPINS</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Conditional compilation or output commands</p></td>
<td style="text-align: left;"><p>The number of microcontroller pins.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">CHIPRESERVEHIGHPROG</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Scripts, Conditional compilation, and output commands</p></td>
<td style="text-align: left;"><p>The value of the words reserved</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">CHIPOSC</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Scripts, Conditional compilation, and output commands</p></td>
<td style="text-align: left;"><p>The frequency selected</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">CHIPUSINGINTOSC</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Scripts, Conditional compilation, and output commands</p></td>
<td style="text-align: left;"><p>The constant exists if the compiler has deternined the program is using the internal oscillator</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">CHIPPROGRAMMERNAMESTR</code></p></td>
<td style="text-align: left;"><p>String constant</p></td>
<td style="text-align: left;"><p>Name of the chip type to be used by a programmer</p></td>
<td style="text-align: left;"><p>The psuedo microcontroller type</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">CHIPRAM</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Conditional compilation or output commands</p></td>
<td style="text-align: left;"><p>The RAM size</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">CHIPSHAREDRAM</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Conditional compilation or output commands</p></td>
<td style="text-align: left;"><p>The first RAM location</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">CHIPFAMILY</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Conditional compilation or output commands</p></td>
<td style="text-align: left;"><p>See the table below</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">CHIPWORDS</code></p></td>
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Conditional compilation or output commands</p></td>
<td style="text-align: left;"><p>The number of WORDS in Flash memmory</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">SOURCEFILE</code></p></td>
<td style="text-align: left;"><p>Constant string</p></td>
<td style="text-align: left;"><p>Conditional compilation or output commands</p></td>
<td style="text-align: left;"><p>The name of the source GCB file</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>Function</strong></span></p></td>
<td style="text-align: left;"><p><span class="strong"><strong>Type</strong></span></p></td>
<td style="text-align: left;"><p><span class="strong"><strong>Usage</strong></span></p></td>
<td style="text-align: left;"><p><span class="strong"><strong>Description</strong></span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">Var()</code></p></td>
<td style="text-align: left;"><p>Function</p></td>
<td style="text-align: left;"><p>Conditional compilation only</p></td>
<td style="text-align: left;"><p>True if a register is declared (or false if not declared) in the currently specficied microcontroller’s .dat file.</p>
<p>Var(register_name)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">NoVar()</code></p></td>
<td style="text-align: left;"><p>Function</p></td>
<td style="text-align: left;"><p>Conditional compilation only</p></td>
<td style="text-align: left;"><p>True if a register is NOT declared (or false if declared) in the currently specficied microcontroller’s .dat file.</p>
<p>NoVar(register_name)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">Bit()</code></p></td>
<td style="text-align: left;"><p>Function</p></td>
<td style="text-align: left;"><p>Conditional compilation only</p></td>
<td style="text-align: left;"><p>True if a bit is declared (or false if not declared) in the currently specficied microcontroller’s .dat file.</p>
<p>Bit(bit_name)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">NoBit()</code></p></td>
<td style="text-align: left;"><p>Function</p></td>
<td style="text-align: left;"><p>Conditional compilation only</p></td>
<td style="text-align: left;"><p>True if a bit is NOT declared (or false if declared) in the currently specficied microcontroller’s .dat file.</p>
<p>NoBit(bit_name)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">Allof()</code></p></td>
<td style="text-align: left;"><p>Function</p></td>
<td style="text-align: left;"><p>Conditional compilation only</p></td>
<td style="text-align: left;"><p>True if all defines are declared:</p>
<p><code class="literal">AllOf(define1, define2, …)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">OneOf()</code></p></td>
<td style="text-align: left;"><p>Function</p></td>
<td style="text-align: left;"><p>Conditional compilation only</p></td>
<td style="text-align: left;"><p>True if one of the defines is declared:</p>
<p><code class="literal">OneOf(define1, define2, …)</code></p></td>
</tr>
</tbody>
</table>

</div>

  
  
The table below shows two special directives that support the mapping
for one variable or bit to anoher variable or bit. This is useful when
creating portable code or libraries to ensure GCBASIC  
  
  
  

<div class="informaltable">

<table data-border="1" width="100%">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Directive</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Explanation</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Usage</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>#samebit</p></td>
<td style="text-align: left;"><p>The compiler checks each item in the list to see which ones are implemented on the current microcontroller.<br />
If any of the bits do not exist, the compiler will create a constant mapping to the name of the first parameter in the list of parameters that does exist. + If none of the bits exist the no constant is created.</p></td>
<td style="text-align: left;"><p>  #samebit PLLEN, SPLLEN, SPLLMULT<br />
    Set SPLLEN On<br />
</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>#samevar</p></td>
<td style="text-align: left;"><p>The compiler checks each item in the list to see which ones are implemented on the current microcontroller.<br />
If any of the variables do not exist, the compiler will create a constant mapping to the name of the first parameter in the list of parameters that does exist. + If none of the variables exist the no constant is created.</p></td>
<td style="text-align: left;"><p>  #samevar CMCON, CMCON0, CMCONbob<br />
  #ifdef Var(CMCONbob)<br />
      CMCONbob = 7<br />
  #endif<br />
<br />
  Compiles to:<br />
  ;CMCONbob = 7<br />
  movlw 7<br />
  movwf CMCON,ACCESS<br />
<br />
</p></td>
</tr>
</tbody>
</table>

</div>

  
  

This table shows the ChipFamily constants mapped to the microcontroller
architecture.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>ChipFamily Value</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Microcontroller Characteristics</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>PIC</strong></span></p></td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>100</p></td>
<td style="text-align: left;"><p>AVR core version V0E class microcontrollers</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>110</p></td>
<td style="text-align: left;"><p>AVR core version V1E class microcontrollers</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>120</p></td>
<td style="text-align: left;"><p>AVR core version V2E class microcontrollers</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>-120 Subtype: 121</p></td>
<td style="text-align: left;"><p>AVR core version AVR8L, also called AVRrc, reduced core class microcontrollers. ATTiny4-5-9-10 and ATTiny102-104 with only 16 GPR’s from r16-r31 and only 54 instructions.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>-120 Subtype: 122</p></td>
<td style="text-align: left;"><p>LGT microcontrollers.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>-120 Subtype: 123</p></td>
<td style="text-align: left;"><p>AVR core version V2E class microcontrollers with one USART like the mega32u4, mega16u4 - they have different registers for the usart.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>121</p></td>
<td style="text-align: left;"><p>Tiny4-5-9-10 and tiny102-104. Only 16 GPR’s from r16-r31 and only 54 instructions.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>130</p></td>
<td style="text-align: left;"><p>AVR core version V3E class microcontrollers but essentially the mega32u6 only</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>AVR</strong></span></p></td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>12</p></td>
<td style="text-align: left;"><p>Baseline devices. 12 Bit instruction set</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>15</p></td>
<td style="text-align: left;"><p>Mid-range core devices. 14 Bit instruction set with enhanced instruction set class</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>15 plus familyVariant=1</p></td>
<td style="text-align: left;"><p>Mid-range core devices. 14 Bit instruction set with enhanced instruction set and with large memory capability class</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>16</p></td>
<td style="text-align: left;"><p>High end core devices. 16 Bit instruction set, memory addressing architecture and an extended instruction set.</p>
<p>Chip family 16 also have a sub chip family Constant.   These constants are shown below:</p>
<p>    ChipFamily18FxxQ10 = 16100</p>
<p>    ChipFamily18FxxQ43 = 16101</p>
<p>    ChipFamily18FxxQ41 = 16102</p>
<p>    ChipFamily18FxxK42 = 16103</p>
<p>    ChipFamily18FxxK40 = 16104</p>
<p>    ChipFamily18FxxQ40 = 16105</p>
<p>    ChipFamily18FxxQ84 = 16106</p>
<p>    ChipFamily18FxxK83 = 16107</p>
<p>    ChipFamily18FxxQ83 = 16108</p></td>
</tr>
</tbody>
</table>

</div>

  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_random_numbers.html" title="Random Numbers"><link rel="prev" href="_random_numbers.html" title="Random Numbers"><link rel="next" href="_random.html" title="Random"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_overview"></a>Overview</h4></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>These routines allow GCBASIC to generate pseudo-random numbers.</p><p>The generator uses a 16 bit linear feedback shift register to produce
pseudo-random numbers.  The most significant 8 bits of the LFSR are used
to provide an 8 bit random number.</p><p>When compiling a program, GCBASIC will generate an initial seed for the
generator. However, this seed will be the same every time the program
runs, so the sequence of numbers produced by a given program will always
be the same. To work around this, there is a Randomize subroutine. It
can be provided with a new seed for the generator (which will cause the
generator to move to a different point in the sequence). Alternatively,
Randomize can be set to obtain a seed from some other source such as a
timer every time it is run.</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>These constants are used to control settings for the random number generation.
To set them, place a line in the main program file that uses
<code class="literal">#define</code> to assign a value to the particular constant.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>RANDOMIZE_SEED</p></td><td align="left" valign="top"><p>Source of the random seed if Randomize is called without a parameter</p></td><td align="left" valign="top"><p>Timer0</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #define RANDOMIZE_SEED Timer2</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="overview"></span>Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

These routines allow GCBASIC to generate pseudo-random numbers.

The generator uses a 16 bit linear feedback shift register to produce
pseudo-random numbers. The most significant 8 bits of the LFSR are used
to provide an 8 bit random number.

When compiling a program, GCBASIC will generate an initial seed for the
generator. However, this seed will be the same every time the program
runs, so the sequence of numbers produced by a given program will always
be the same. To work around this, there is a Randomize subroutine. It
can be provided with a new seed for the generator (which will cause the
generator to move to a different point in the sequence). Alternatively,
Randomize can be set to obtain a seed from some other source such as a
timer every time it is run.

<span class="strong">**Relevant Constants:**</span>

These constants are used to control settings for the random number
generation. To set them, place a line in the main program file that uses
`#define` to assign a value to the particular constant.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span>                             | <span class="strong">**Default Value**</span> |
|:----------------------------------------------|:---------------------------------------------------------------------|:----------------------------------------------|
| RANDOMIZE\_SEED                               | Source of the random seed if Randomize is called without a parameter | Timer0                                        |

</div>

<span class="strong">**Example:**</span>

``` screen
    #define RANDOMIZE_SEED Timer2
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Overview - Apple macOS GCBASIC</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_gcbasic_for_apple_macos.html" title="GCBASIC for Apple macOS"><link rel="prev" href="_gcbasic_for_apple_macos.html" title="GCBASIC for Apple macOS"><link rel="next" href="_gcbasic_for_freebsd.html" title="GCBASIC for FreeBSD"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_overview_apple_macos_gcbasic"></a>Overview - Apple macOS GCBASIC</h3></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>The GCBASIC compiler can be used with the Apple macOS operating system. It should run on any version from Snow Leopard 10.6 and above. It is guaranteed to run on both High Sierra 10.13 and Mojave 10.14 which have been extensively tested.</p><p>You have a choice to make. You can either:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">download a macOS installer which will install a precompiled 64 bit binary for the GCBASIC compiler along with support files and some optional components; or</li><li class="listitem">download, compile and install the GCBASIC compiler from the source files.</li></ol></div><p>There are instructions below for both choices. If I was you, I would use the macOS GCBASIC Installer and save valuable programming time :-)</p><p><span class="strong"><strong>Instructions for using the GCBASIC Installer</strong></span></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Download the GCBASIC - macOS Installer disk image (.dmg) file from <a class="link" href="https://sourceforge.net/projects/gcbasic/files/GCBasic-macOS-Installer.dmg/download" target="_top">https://sourceforge.net/projects/gcbasic/files/GCBasic-macOS-Installer.dmg/download</a></li><li class="listitem">Double click the .dmg file to mount it on your Desktop and a window will open which contains the Installer.</li><li class="listitem">Double click the REAME_FIRST.txt file and read it for any important information you may need before proceeding.</li><li class="listitem">Double click the GCBASIC icon and follow the installer prompts.</li></ol></div><p><span class="strong"><strong>Instructions for building your own GCBASIC binary</strong></span></p><p>Complete the following steps to compile and install the GCBASIC compiler:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Download the FreeBASIC 1.06 macOS binary compilation from: <a class="link" href="http://tmc.castleparadox.com/temp/fbc-1.06-darwin-wip20160505.tar.bz2" target="_top">http://tmc.castleparadox.com/temp/fbc-1.06-darwin-wip20160505.tar.bz2</a></li><li class="listitem">Download the GCBASIC UNIX Source Distribution from SourceForge at <a class="link" href="http://gcbasic.sourceforge.net/Typesetter/index.php/Download" target="_top">http://gcbasic.sourceforge.net/Typesetter/index.php/Download</a></li><li class="listitem">Note: the following instructions assume the distribution file is named GCBASIC-UNIX-v0_98_05.rar however the version number (v0_98_05) may change before these instructions are updated, so you may have to adjust the filename to match the version you have downloaded.</li><li class="listitem">Unfortunately Apple replaced the gcc compiler with the clang compiler and FreeBASIC needs the real gcc due to a certain use of goto&#8230;&#8203; so, you can compile your own version of gcc following the instructions at <a class="link" href="https://solarianprogrammer.com/2017/05/21/compiling-gcc-macos/" target="_top">https://solarianprogrammer.com/2017/05/21/compiling-gcc-macos/</a> or you can take the low road and just download the pre-compiled binary version from <a class="link" href="https://github.com/sol-prog/macos-gcc-binary/releases/download/v8.3/gcc-8.3.macos.tar.bz2" target="_top">https://github.com/sol-prog/macos-gcc-binary/releases/download/v8.3/gcc-8.3.macos.tar.bz2</a></li><li class="listitem">Open a Terminal window (Terminal can be found in Applications &gt; Utilities).</li><li class="listitem">Move gcc-8.3.tar.bz2 from your Downloads directory to your Home directory by typing the following command in your Terminal window:</li></ol></div><pre class="screen">   mv ~/Downloads/gcc-8.3.tar.bz2 ~/</pre><div class="orderedlist"><ol class="orderedlist" start="6" type="1"><li class="listitem">Unpack the gcc-8.3.tar.bz2 compressed tar file by typing the following command into your Terminal window:</li></ol></div><pre class="screen">   gzcat gcc-8.3.tar.bz2 | tar xvf -</pre><p>This will produce a new directory called gcc-8.3.</p><div class="orderedlist"><ol class="orderedlist" start="7" type="1"><li class="listitem">You now need to link the binary gcc-8.3 to just gcc by typing the following commands into your Terminal window:</li></ol></div><pre class="screen">   cd gcc-8.3
   ln -s gcc-8.3 gcc
   cd ..</pre><div class="orderedlist"><ol class="orderedlist" start="8" type="1"><li class="listitem">Move the gcc-8.3 directory to the /usr/local/ directory by typing the following commands into your Terminal window:</li></ol></div><pre class="screen">   sudo mv gcc-8.3 /usr/local</pre><p>Note: You will be asked for your password to execute the above command.</p><div class="orderedlist"><ol class="orderedlist" start="9" type="1"><li class="listitem">Ensure that the Apple Developer Xcode app is installed. Xcode can be downloaded and installed from the App Store for free.</li></ol></div><div class="orderedlist"><ol class="orderedlist" start="10" type="1"><li class="listitem">Ensure that the Xcode command line tools are installed by typing the following command in your Terminal window:</li></ol></div><pre class="screen">   xcode-select --install.</pre><div class="orderedlist"><ol class="orderedlist" start="11" type="1"><li class="listitem">Move the FreeBASIC compressed tar file from your Downloads directory to your home directory by typing the following command in your Terminal window:</li></ol></div><pre class="screen">   mv ~/Downloads/fbc-1.06-darwin-wip20160505.tar.bz2 ~/</pre><div class="orderedlist"><ol class="orderedlist" start="12" type="1"><li class="listitem">Unpack the FreeBASIC compressed tar file by typing these commands in your Terminal window:</li></ol></div><pre class="screen">   gzcat fbc-1.06-darwin-wip20160505.tar.bz2 | tar xvf -</pre><p>This will produce a new directory called fbc-1.06.</p><div class="orderedlist"><ol class="orderedlist" start="13" type="1"><li class="listitem">Move the GCBASIC compressed tar file from your Downloads directory to your home directory by typing the following command in your Terminal window:</li></ol></div><pre class="screen">   mv ~/Downloads/GCBASIC-UNIX-v0_98_05.rar ~/</pre><div class="orderedlist"><ol class="orderedlist" start="14" type="1"><li class="listitem">Unpack the GCBASIC compressed tar file by typing these commands in your Terminal window:</li></ol></div><pre class="screen">   unrar x GCBASIC-UNIX-v0_98_05.rar</pre><p>This will produce a new directory called GCBASIC. <span class="strong"><strong>Note:</strong></span> If you do not currently have the unrar program which can extract rar file archives you can download and install it for free from the App Store.</p><div class="orderedlist"><ol class="orderedlist" start="15" type="1"><li class="listitem">Change to the GCBASIC/Sources directory by typing this command in your Terminal window:</li></ol></div><pre class="screen">   cd ~/GCBASIC/Sources</pre><div class="orderedlist"><ol class="orderedlist" start="16" type="1"><li class="listitem">Compile the GCBASIC binary (gcbasic) by typing the following command into your Terminal window:</li></ol></div><pre class="screen">  sh DarwinBuild/build.sh</pre><p>Note 1: If you did not install the various files with the same names as in the instructions above into your Home directory, you will need to edit the build.sh script file and change the file paths and filenames to the appropriate values.</p><p>Note 2: You may need to alter the library and include paths in the build.sh script depending on your version of macOS (it is currently setup for the Xcode High Sierra 10.13 and Mojave 10.14 versions of macOS).</p><div class="orderedlist"><ol class="orderedlist" start="17" type="1"><li class="listitem">Confirm the proper execution, and the version, of GCBASIC by typing the following command in the Terminal window:</li></ol></div><pre class="screen">   gcbasic</pre><p>Now you should be able create GCB source files with your favourite editor and compile those files with the gcbasic compiler.</p><p><span class="strong"><strong>Programming microcontrollers</strong></span></p><p>To program your microcontroller with your GCBASIC-created hex file, you will need additional hardware and software.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">For Microchip PIC microcontroller programming, you might find what you need at: <a class="link" href="https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120" target="_top">https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120</a> and the macOS version of the <code class="literal">pk2cmd</code> v1.2 command line programming software.</li><li class="listitem">For Atmel AVR microcontroller programming, you will need the <code class="literal">avrdude</code> programming software. Check here: <a class="link" href="http://www.nongnu.org/avrdude/" target="_top">http://www.nongnu.org/avrdude/</a> for it.</li></ol></div><p>Alternatively, if you use Virtual Machine software such as <span class="emphasis"><em>Parallels</em></span> or <span class="emphasis"><em>VMWare Fusion</em></span> to run Windows programs, you can use Windows GUI programming software.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">For Microchip, the PICKit 2 and PICkit 3 standalone GUI software or even better the PICkitPlus software (<a class="link" href="https://sourceforge.net/projects/pickit3plus/" target="_top">https://sourceforge.net/projects/pickit3plus/</a>) for both the PICkit 2 (<a class="link" href="https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120" target="_top">https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120</a>) and PICkit 3 (<a class="link" href="https://www.microchip.com/Developmenttools/ProductDetails/PG164130" target="_top">https://www.microchip.com/Developmenttools/ProductDetails/PG164130</a>) which has fixed various bugs in those programs and been updated to program the latest Microchip 8 bit microcontrollers.</li></ul></div><p><span class="strong"><strong>Help</strong></span></p><p>GCBASIC Help documentation is installed in the Documentation subdirectory in your GCBASIC directory.</p><p>If at any time you encounter an issue and need help, you will find it over at the friendly GCBASIC discussion forums at <a class="link" href="https://sourceforge.net/p/gcbasic/discussion/" target="_top">https://sourceforge.net/p/gcbasic/discussion/</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="overview_apple_macos_gcbasic"></span>Overview - Apple macOS GCBASIC

</div>

</div>

</div>

<span class="strong">**Introduction**</span>

The GCBASIC compiler can be used with the Apple macOS operating system.
It should run on any version from Snow Leopard 10.6 and above. It is
guaranteed to run on both High Sierra 10.13 and Mojave 10.14 which have
been extensively tested.

You have a choice to make. You can either:

<div class="orderedlist">

1.  download a macOS installer which will install a precompiled 64 bit
    binary for the GCBASIC compiler along with support files and some
    optional components; or
2.  download, compile and install the GCBASIC compiler from the source
    files.

</div>

There are instructions below for both choices. If I was you, I would use
the macOS GCBASIC Installer and save valuable programming time :-)

<span class="strong">**Instructions for using the GCBASIC
Installer**</span>

<div class="orderedlist">

1.  Download the GCBASIC - macOS Installer disk image (.dmg) file from
    <https://sourceforge.net/projects/gcbasic/files/GCBasic-macOS-Installer.dmg/download>
2.  Double click the .dmg file to mount it on your Desktop and a window
    will open which contains the Installer.
3.  Double click the REAME\_FIRST.txt file and read it for any important
    information you may need before proceeding.
4.  Double click the GCBASIC icon and follow the installer prompts.

</div>

<span class="strong">**Instructions for building your own GCBASIC
binary**</span>

Complete the following steps to compile and install the GCBASIC
compiler:

<div class="orderedlist">

1.  Download the FreeBASIC 1.06 macOS binary compilation from:
    <http://tmc.castleparadox.com/temp/fbc-1.06-darwin-wip20160505.tar.bz2>
2.  Download the GCBASIC UNIX Source Distribution from SourceForge at
    <http://gcbasic.sourceforge.net/Typesetter/index.php/Download>
3.  Note: the following instructions assume the distribution file is
    named GCBASIC-UNIX-v0\_98\_05.rar however the version number
    (v0\_98\_05) may change before these instructions are updated, so
    you may have to adjust the filename to match the version you have
    downloaded.
4.  Unfortunately Apple replaced the gcc compiler with the clang
    compiler and FreeBASIC needs the real gcc due to a certain use of
    goto…​ so, you can compile your own version of gcc following the
    instructions at
    <https://solarianprogrammer.com/2017/05/21/compiling-gcc-macos/> or
    you can take the low road and just download the pre-compiled binary
    version from
    <https://github.com/sol-prog/macos-gcc-binary/releases/download/v8.3/gcc-8.3.macos.tar.bz2>
5.  Open a Terminal window (Terminal can be found in Applications &gt;
    Utilities).
6.  Move gcc-8.3.tar.bz2 from your Downloads directory to your Home
    directory by typing the following command in your Terminal window:

</div>

``` screen
   mv ~/Downloads/gcc-8.3.tar.bz2 ~/
```

<div class="orderedlist">

1.  Unpack the gcc-8.3.tar.bz2 compressed tar file by typing the
    following command into your Terminal window:

</div>

``` screen
   gzcat gcc-8.3.tar.bz2 | tar xvf -
```

This will produce a new directory called gcc-8.3.

<div class="orderedlist">

1.  You now need to link the binary gcc-8.3 to just gcc by typing the
    following commands into your Terminal window:

</div>

``` screen
   cd gcc-8.3
   ln -s gcc-8.3 gcc
   cd ..
```

<div class="orderedlist">

1.  Move the gcc-8.3 directory to the /usr/local/ directory by typing
    the following commands into your Terminal window:

</div>

``` screen
   sudo mv gcc-8.3 /usr/local
```

Note: You will be asked for your password to execute the above command.

<div class="orderedlist">

1.  Ensure that the Apple Developer Xcode app is installed. Xcode can be
    downloaded and installed from the App Store for free.

</div>

<div class="orderedlist">

1.  Ensure that the Xcode command line tools are installed by typing the
    following command in your Terminal window:

</div>

``` screen
   xcode-select --install.
```

<div class="orderedlist">

1.  Move the FreeBASIC compressed tar file from your Downloads directory
    to your home directory by typing the following command in your
    Terminal window:

</div>

``` screen
   mv ~/Downloads/fbc-1.06-darwin-wip20160505.tar.bz2 ~/
```

<div class="orderedlist">

1.  Unpack the FreeBASIC compressed tar file by typing these commands in
    your Terminal window:

</div>

``` screen
   gzcat fbc-1.06-darwin-wip20160505.tar.bz2 | tar xvf -
```

This will produce a new directory called fbc-1.06.

<div class="orderedlist">

1.  Move the GCBASIC compressed tar file from your Downloads directory
    to your home directory by typing the following command in your
    Terminal window:

</div>

``` screen
   mv ~/Downloads/GCBASIC-UNIX-v0_98_05.rar ~/
```

<div class="orderedlist">

1.  Unpack the GCBASIC compressed tar file by typing these commands in
    your Terminal window:

</div>

``` screen
   unrar x GCBASIC-UNIX-v0_98_05.rar
```

This will produce a new directory called GCBASIC. <span
class="strong">**Note:**</span> If you do not currently have the unrar
program which can extract rar file archives you can download and install
it for free from the App Store.

<div class="orderedlist">

1.  Change to the GCBASIC/Sources directory by typing this command in
    your Terminal window:

</div>

``` screen
   cd ~/GCBASIC/Sources
```

<div class="orderedlist">

1.  Compile the GCBASIC binary (gcbasic) by typing the following command
    into your Terminal window:

</div>

``` screen
  sh DarwinBuild/build.sh
```

Note 1: If you did not install the various files with the same names as
in the instructions above into your Home directory, you will need to
edit the build.sh script file and change the file paths and filenames to
the appropriate values.

Note 2: You may need to alter the library and include paths in the
build.sh script depending on your version of macOS (it is currently
setup for the Xcode High Sierra 10.13 and Mojave 10.14 versions of
macOS).

<div class="orderedlist">

1.  Confirm the proper execution, and the version, of GCBASIC by typing
    the following command in the Terminal window:

</div>

``` screen
   gcbasic
```

Now you should be able create GCB source files with your favourite
editor and compile those files with the gcbasic compiler.

<span class="strong">**Programming microcontrollers**</span>

To program your microcontroller with your GCBASIC-created hex file, you
will need additional hardware and software.

<div class="orderedlist">

1.  For Microchip PIC microcontroller programming, you might find what
    you need at:
    <https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120>
    and the macOS version of the `pk2cmd` v1.2 command line programming
    software.
2.  For Atmel AVR microcontroller programming, you will need the
    `avrdude` programming software. Check here:
    <http://www.nongnu.org/avrdude/> for it.

</div>

Alternatively, if you use Virtual Machine software such as <span
class="emphasis">*Parallels*</span> or <span class="emphasis">*VMWare
Fusion*</span> to run Windows programs, you can use Windows GUI
programming software.

<div class="itemizedlist">

-   For Microchip, the PICKit 2 and PICkit 3 standalone GUI software or
    even better the PICkitPlus software
    (<https://sourceforge.net/projects/pickit3plus/>) for both the
    PICkit 2
    (<https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120>)
    and PICkit 3
    (<https://www.microchip.com/Developmenttools/ProductDetails/PG164130>)
    which has fixed various bugs in those programs and been updated to
    program the latest Microchip 8 bit microcontrollers.

</div>

<span class="strong">**Help**</span>

GCBASIC Help documentation is installed in the Documentation
subdirectory in your GCBASIC directory.

If at any time you encounter an issue and need help, you will find it
over at the friendly GCBASIC discussion forums at
<https://sourceforge.net/p/gcbasic/discussion/>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Overview - FreeBSD GCBASIC</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_gcbasic_for_freebsd.html" title="GCBASIC for FreeBSD"><link rel="prev" href="_gcbasic_for_freebsd.html" title="GCBASIC for FreeBSD"><link rel="next" href="_gcbasic_maintenance_and_development.html" title="GCBASIC Maintenance and Development"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_overview_freebsd_gcbasic"></a>Overview - FreeBSD GCBASIC</h3></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>The GCBASIC compiler can be used with the FreeBSD operating system.</p><p><span class="strong"><strong>Instructions for using the GCBASIC install.sh script</strong></span></p><p>Complete the following steps to compile and install the GCBASIC compiler for FreeBSD:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Download one of the nightly builds of FreeBASIC 1.06 for the FreeBSD 32 bit or 64 bit binary compilation from: <a class="link" href="http://users.freebasic-portal.de/stw/builds/freebsd32/" target="_top">http://users.freebasic-portal.de/stw/builds/freebsd32/</a> (32 bit) or <a class="link" href="http://users.freebasic-portal.de/stw/builds/freebsd64/" target="_top">http://users.freebasic-portal.de/stw/builds/freebsd64/</a> (64 bit) The filenames are in the format fbc_freebsd[32|64]_[BuildNumber]_[Date].zip.</li><li class="listitem">Download the GCBASIC UNIX Source Distribution from SourceForge at <a class="link" href="https://gcbasic.sourceforge.net/Typesetter/index.php/Download" target="_top">https://gcbasic.sourceforge.net/Typesetter/index.php/Download</a></li><li class="listitem">Move the FreeBASIC ZIP file from your download directory to your home directory.</li><li class="listitem">Unzip the FreeBASIC ZIP file which will produce a new directory called <code class="literal">fbc_freebsd[32|64]</code>. The FreeBASIC compiler <code class="literal">fbc</code> is in the <code class="literal">bin</code> subdirectory. You should add the path to <code class="literal">fbc</code> to your path so that the installation script can find it.</li><li class="listitem">Move the GCBASIC compressed tar file from your download directory to your home directory.</li><li class="listitem">Unpack the GCBASIC compressed tar file by typing the command below. <span class="strong"><strong>Note</strong></span>: the version number (v0_98_05) in the filename may change before these instructions are updated - adjust depending on the version number of the file you downloaded.</li></ol></div><pre class="screen">   unrar x GCBASIC-UNIX-v0_98_05.rar</pre><p>This will produce a new directory called GCBASIC. <span class="strong"><strong>Note:</strong></span> If you do not already have the unrar program installed you can either compile it from the ports collection or use the pkg command to install the binary and any required dependancies.</p><div class="orderedlist"><ol class="orderedlist" start="7" type="1"><li class="listitem">Change to the <code class="literal">GCBASIC/Sources</code> directory.</li><li class="listitem">Execute the FreeBSDBuild/install.sh shell script from the Sources directory.</li></ol></div><pre class="screen">  sh FreeBSDBuild/install.sh [all | build | install]</pre><p>The build script arguments are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="emphasis"><em>all</em></span> - will compile <span class="strong"><strong>and</strong></span> install the GCBASIC compiler and its support files.</li><li class="listitem"><span class="emphasis"><em>build</em></span> - will just compile the binary for the GCBASIC compiler.</li><li class="listitem"><span class="emphasis"><em>install</em></span> - will install the GCBASIC compiler and its support files.</li></ul></div><p>When choosing <span class="emphasis"><em>all</em></span> or <span class="emphasis"><em>install</em></span> you will be prompted for an installation directory. The default is <code class="literal">/usr/local/gcb-[version]</code> for which you will need to run the installation script as root. Alternatively, you can choose to install in your home directory (eg <code class="literal">`~/bin/gcb</code>). The installation script will automatically append the GCBASIC version so that directory would become <code class="literal">~/bin/gcb-[version]</code></p><div class="orderedlist"><ol class="orderedlist" start="9" type="1"><li class="listitem">Add the directory where you installed <code class="literal">gcbasic</code> to your path, or use the full path to the <code class="literal">gcbasic</code> installation directory and confirm the proper execution, and the version, of GCBASIC by executing <code class="literal">gcbasic</code>.</li></ol></div><p>Now you should be able create GCB source files with your favourite editor and compile those files with the GCBASIC compiler.</p><p><span class="strong"><strong>Programming microcontrollers</strong></span></p><p>To program your microcontroller with your GCBASIC-created hex file, you will need additional hardware and software.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">For Microchip PIC microcontroller programming, you might find what you need at: <a class="link" href="https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120" target="_top">https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120</a> and the FreeBSD version of the <code class="literal">pk2cmd</code> v1.2 command line programming software.</li><li class="listitem">For Atmel AVR microcontroller programming, you will need the <code class="literal">avrdude</code> programming software. avrdude can be compiled and installed from the FreeBSD ports directory or the precompiled binary and any missing dependancies can be installed using <code class="literal">pkg install avrdude</code>.</li></ol></div><p>Alternatively, if you use Virtual Machine software such as <span class="emphasis"><em>Virtual Box</em></span> to run Windows programs, you may be able to use Windows GUI programming software.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">For Microchip, the PICKit 2 and PICkit 3 standalone GUI software or even better the PICkitPlus software (<a class="link" href="https://sourceforge.net/projects/pickit3plus/" target="_top">https://sourceforge.net/projects/pickit3plus/</a>) for both the PICkit 2 (<a class="link" href="https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120" target="_top">https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120</a>) and PICkit 3 (<a class="link" href="https://www.microchip.com/Developmenttools/ProductDetails/PG164130" target="_top">https://www.microchip.com/Developmenttools/ProductDetails/PG164130</a>) which has fixed various bugs in those programs and been updated to program the latest Microchip 8 bit microcontrollers.</li></ul></div><p><span class="strong"><strong>Help</strong></span></p><p>GCBASIC Help documentation is installed in the Documentation subdirectory in your GCBASIC directory.</p><p>If at any time you encounter an issue and need help, you will find it over at the friendly GCBASIC discussion forums at <a class="link" href="https://sourceforge.net/p/gcbasic/discussion/" target="_top">https://sourceforge.net/p/gcbasic/discussion/</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="overview_freebsd_gcbasic"></span>Overview - FreeBSD GCBASIC

</div>

</div>

</div>

<span class="strong">**Introduction**</span>

The GCBASIC compiler can be used with the FreeBSD operating system.

<span class="strong">**Instructions for using the GCBASIC install.sh
script**</span>

Complete the following steps to compile and install the GCBASIC compiler
for FreeBSD:

<div class="orderedlist">

1.  Download one of the nightly builds of FreeBASIC 1.06 for the FreeBSD
    32 bit or 64 bit binary compilation from:
    <http://users.freebasic-portal.de/stw/builds/freebsd32/> (32 bit) or
    <http://users.freebasic-portal.de/stw/builds/freebsd64/> (64 bit)
    The filenames are in the format
    fbc\_freebsd\[32\|64\]\_\[BuildNumber\]\_\[Date\].zip.
2.  Download the GCBASIC UNIX Source Distribution from SourceForge at
    <https://gcbasic.sourceforge.net/Typesetter/index.php/Download>
3.  Move the FreeBASIC ZIP file from your download directory to your
    home directory.
4.  Unzip the FreeBASIC ZIP file which will produce a new directory
    called `fbc_freebsd[32|64]`. The FreeBASIC compiler `fbc` is in the
    `bin` subdirectory. You should add the path to `fbc` to your path so
    that the installation script can find it.
5.  Move the GCBASIC compressed tar file from your download directory to
    your home directory.
6.  Unpack the GCBASIC compressed tar file by typing the command below.
    <span class="strong">**Note**</span>: the version number
    (v0\_98\_05) in the filename may change before these instructions
    are updated - adjust depending on the version number of the file you
    downloaded.

</div>

``` screen
   unrar x GCBASIC-UNIX-v0_98_05.rar
```

This will produce a new directory called GCBASIC. <span
class="strong">**Note:**</span> If you do not already have the unrar
program installed you can either compile it from the ports collection or
use the pkg command to install the binary and any required dependancies.

<div class="orderedlist">

1.  Change to the `GCBASIC/Sources` directory.
2.  Execute the FreeBSDBuild/install.sh shell script from the Sources
    directory.

</div>

``` screen
  sh FreeBSDBuild/install.sh [all | build | install]
```

The build script arguments are:

<div class="itemizedlist">

-   <span class="emphasis">*all*</span> - will compile <span
    class="strong">**and**</span> install the GCBASIC compiler and its
    support files.
-   <span class="emphasis">*build*</span> - will just compile the binary
    for the GCBASIC compiler.
-   <span class="emphasis">*install*</span> - will install the GCBASIC
    compiler and its support files.

</div>

When choosing <span class="emphasis">*all*</span> or <span
class="emphasis">*install*</span> you will be prompted for an
installation directory. The default is `/usr/local/gcb-[version]` for
which you will need to run the installation script as root.
Alternatively, you can choose to install in your home directory (eg
`` `~/bin/gcb ``). The installation script will automatically append the
GCBASIC version so that directory would become `~/bin/gcb-[version]`

<div class="orderedlist">

1.  Add the directory where you installed `gcbasic` to your path, or use
    the full path to the `gcbasic` installation directory and confirm
    the proper execution, and the version, of GCBASIC by executing
    `gcbasic`.

</div>

Now you should be able create GCB source files with your favourite
editor and compile those files with the GCBASIC compiler.

<span class="strong">**Programming microcontrollers**</span>

To program your microcontroller with your GCBASIC-created hex file, you
will need additional hardware and software.

<div class="orderedlist">

1.  For Microchip PIC microcontroller programming, you might find what
    you need at:
    <https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120>
    and the FreeBSD version of the `pk2cmd` v1.2 command line
    programming software.
2.  For Atmel AVR microcontroller programming, you will need the
    `avrdude` programming software. avrdude can be compiled and
    installed from the FreeBSD ports directory or the precompiled binary
    and any missing dependancies can be installed using
    `pkg install avrdude`.

</div>

Alternatively, if you use Virtual Machine software such as <span
class="emphasis">*Virtual Box*</span> to run Windows programs, you may
be able to use Windows GUI programming software.

<div class="itemizedlist">

-   For Microchip, the PICKit 2 and PICkit 3 standalone GUI software or
    even better the PICkitPlus software
    (<https://sourceforge.net/projects/pickit3plus/>) for both the
    PICkit 2
    (<https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120>)
    and PICkit 3
    (<https://www.microchip.com/Developmenttools/ProductDetails/PG164130>)
    which has fixed various bugs in those programs and been updated to
    program the latest Microchip 8 bit microcontrollers.

</div>

<span class="strong">**Help**</span>

GCBASIC Help documentation is installed in the Documentation
subdirectory in your GCBASIC directory.

If at any time you encounter an issue and need help, you will find it
over at the friendly GCBASIC discussion forums at
<https://sourceforge.net/p/gcbasic/discussion/>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Overview - Linux Operating System</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_gcbasic_for_linux.html" title="GCBASIC for Linux"><link rel="prev" href="_gcbasic_for_linux.html" title="GCBASIC for Linux"><link rel="next" href="_make_asm_make_hex_and_programming_operations_using_the_provided_linux_scripts.html" title="Make ASM, Make HEX and Programming Operations using the provided Linux scripts"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_overview_linux_operating_system"></a>Overview - Linux Operating System</h3></div></div></div><p><span class="strong"><strong>Introduction:</strong></span>
GCBASIC can be used when using the Linux Operating System.</p><p>This instructions are not distribution specific, but are for Linux only (not Windows).</p><p><span class="strong"><strong>Instructions:</strong></span>
Complete the following steps to compile and install GCBASIC for Linux:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Install FreeBasic from your distributions repository or <a class="link" href="http://www.freebasic.net/wiki/CompilerInstalling" target="_top">http://www.freebasic.net/wiki/CompilerInstalling</a></li><li class="listitem">Download the "GCBASIC - Linux Distribution" from SourceForge at <a class="link" href="https://sourceforge.net/projects/gcbasic/files/" target="_top">https://sourceforge.net/projects/gcbasic/files/</a></li><li class="listitem">Unrar/unpack GCBASIC.rar to a location of your choice within your home directory (eg. within Downloads) with either a file manager or from a console.</li><li class="listitem">From a console, change to the GCBASIC Sources in the unpacked directory:</li></ol></div><pre class="screen">   eg. cd ~/Downloads/sources/linuxbuild/</pre><div class="orderedlist"><ol class="orderedlist" start="5" type="1"><li class="listitem">Make sure that <code class="literal">install.sh</code> is set as executable (ie. <code class="literal">chmod +x install.sh</code>), and then execute: ./install.sh build</li><li class="listitem">You will need root privileges for this step. You can switch user (su) to root, or optionally use <code class="literal">sudo</code>.</li></ol></div><pre class="screen">   Execute: [sudo] ./install.sh install</pre><div class="orderedlist"><ol class="orderedlist" start="7" type="1"><li class="listitem">If you su&#8217;d to root, use <code class="literal">exit</code> to drop back to your normal user. Then, be sure to follow the instructions given by the script for updating your path.</li><li class="listitem">Confirm proper execution, and the version, of GCBASIC by executing: gcbasic /version</li></ol></div><p>Now you can create and compile GCBASIC source files.</p><p><span class="strong"><strong>Programming microcontrollers:</strong></span></p><p>To program your microcontroller with your GCBASIC created hex file, you will need additional programming and programmer software.</p><p>For Microchip PIC microcontroller programming, you might find what you need at: www.pickitplus.co.uk  The PICKitPlus Team provide programmers and Linux software.</p><p>For Atmel AVR microcontroller programming, you will need <code class="literal">avrdude</code>. It should be available in your distributions repository. If not, check here: <a class="link" href="http://www.nongnu.org/avrdude/" target="_top">http://www.nongnu.org/avrdude/</a></p><p><br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="overview_linux_operating_system"></span>Overview - Linux Operating System

</div>

</div>

</div>

<span class="strong">**Introduction:**</span> GCBASIC can be used when
using the Linux Operating System.

This instructions are not distribution specific, but are for Linux only
(not Windows).

<span class="strong">**Instructions:**</span> Complete the following
steps to compile and install GCBASIC for Linux:

<div class="orderedlist">

1.  Install FreeBasic from your distributions repository or
    <http://www.freebasic.net/wiki/CompilerInstalling>
2.  Download the "GCBASIC - Linux Distribution" from SourceForge at
    <https://sourceforge.net/projects/gcbasic/files/>
3.  Unrar/unpack GCBASIC.rar to a location of your choice within your
    home directory (eg. within Downloads) with either a file manager or
    from a console.
4.  From a console, change to the GCBASIC Sources in the unpacked
    directory:

</div>

``` screen
   eg. cd ~/Downloads/sources/linuxbuild/
```

<div class="orderedlist">

1.  Make sure that `install.sh` is set as executable (ie.
    `chmod +x install.sh`), and then execute: ./install.sh build
2.  You will need root privileges for this step. You can switch user
    (su) to root, or optionally use `sudo`.

</div>

``` screen
   Execute: [sudo] ./install.sh install
```

<div class="orderedlist">

1.  If you su’d to root, use `exit` to drop back to your normal user.
    Then, be sure to follow the instructions given by the script for
    updating your path.
2.  Confirm proper execution, and the version, of GCBASIC by executing:
    gcbasic /version

</div>

Now you can create and compile GCBASIC source files.

<span class="strong">**Programming microcontrollers:**</span>

To program your microcontroller with your GCBASIC created hex file, you
will need additional programming and programmer software.

For Microchip PIC microcontroller programming, you might find what you
need at: www.pickitplus.co.uk The PICKitPlus Team provide programmers
and Linux software.

For Atmel AVR microcontroller programming, you will need `avrdude`. It
should be available in your distributions repository. If not, check
here: <http://www.nongnu.org/avrdude/>

  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Overview - Raspberry Pi</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_gcbasic_for_arm_pi.html" title="GCBASIC for ARM &amp; Pi"><link rel="prev" href="_gcbasic_for_arm_pi.html" title="GCBASIC for ARM &amp; Pi"><link rel="next" href="_gcbasic_for_apple_macos.html" title="GCBASIC for Apple macOS"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_overview_raspberry_pi"></a>Overview - Raspberry Pi</h3></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>GCBASIC can be used when using the Raspberry Pi.</p><p>You can install the command-line version of GCBASIC on a Raspberry Pi (and similar single-board computers) and use it to compile your GCBASIC programs.</p><p>You can also program most PICs and AVRs using only the Pi&#8217;s GPIO pins (see <a class="xref" href="">???</a>), as well as communicate with your device over the Pi&#8217;s serial port.  This makes it easy to program, modify, and communicate with a PIC or AVR using just a Pi and an SSH connection.</p><p>GCBASIC is not published for ARM-based computers, there is currently no pre-compiled version for ARM-based computers, so you will have to compile it from source.  The GCBASIC compiler is written in <a class="link" href="https://www.freebasic.net/" target="_top">FreeBASIC</a> (an open-source version of BASIC), so you will need to first install the FreeBASIC compiler on your Pi, then use it to compile the GCBASIC compiler from its source code.  This is relatively simple.</p><p>FreeBASIC is not included in any of the major Linux repositories, but there is a customized version for ARMv7 boards like the Raspberry Pi on their <a class="link" href="https://users.freebasic-portal.de/stw/builds/linux-armv7a-hf-debian/" target="_top">web site</a>.</p><p>The following procedure will work with any ARMv7 single-board computer running a Debian derivative like <a class="link" href="https://www.raspberrypi.org/downloads/raspberry-pi-os/" target="_top">Raspberry Pi OS </a> or <a class="link" href="https://www.armbian.com/" target="_top">Armbian</a>.  This includes the Raspberry Pi 2 and 3, and all single board computers with an Allwinner H2+ or H3 microprocessor (Orange Pi PC, Orange Pi Zero, Nano Pi R1, etc).  It has not been tested with a Raspberry Pi 4.</p><p><span class="strong"><strong>Instructions:</strong></span></p><p>All commands should be performed on your Pi board, either through a remote SSH terminal or using a keyboard and monitor connected to your Pi.</p><p><span class="emphasis"><em>Installing FreeBASIC</em></span></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Install FreeBASIC dependencies</li></ol></div><pre class="screen">    $ sudo apt-get install libx11-dev libxext-dev libxpm-dev libxrandr-dev libncurses5 libncurses5-dev</pre><div class="orderedlist"><ol class="orderedlist" start="2" type="1"><li class="listitem">Download the latest version FreeBASIC for ARMv7 from <a class="link" href="https://users.freebasic-portal.de/stw/builds/linux-armv7a-hf-debian/" target="_top">https://users.freebasic-portal.de/stw/builds/linux-armv7a-hf-debian/</a> :</li></ol></div><pre class="screen">    $ cd ~
    $ wget https://users.freebasic-portal.de/stw/builds/linux-armv7a-hf-debian/fbc_linux_armv7a_hf_debian_0376_2020-09-17.zip
    $ unzip fbc_linux_armv7a_hf_debian_0376_2020-09-17.zip</pre><div class="orderedlist"><ol class="orderedlist" start="3" type="1"><li class="listitem">Install FreeBASIC</li></ol></div><pre class="screen">  $ cd fbc_linux_armv7a_hf_debian/
  $ chmod +x install.sh
  $ sudo ./install.sh -i</pre><p><span class="emphasis"><em>Installing GCBASIC</em></span></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Download and extract the GCBASIC sources:</li></ol></div><pre class="screen">    $ wget "https://downloads.sourceforge.net/project/gcbasic/GCBasic%20-%20Linux%20Distribution/GCB%40Syn.rar"
    $ sudo apt install unar
    # the password when requested in the next step is "GCB"
    $ unar GCBASIC.rar
    $ cd GCBASIC/sources/linuxbuild/</pre><div class="orderedlist"><ol class="orderedlist" start="2" type="1"><li class="listitem">Build and install the compiler:</li></ol></div><pre class="screen">    $ chmod +x install.sh
    $ ./install.sh build
    $ sudo ./install.sh install</pre><div class="orderedlist"><ol class="orderedlist" start="3" type="1"><li class="listitem">Verify the compiler is properly installed and view the full list of compiler options</li></ol></div><pre class="screen">    $ gcbasic</pre><p>Now you can create and compile GCBASIC source files. For example, to compile a program you created named <code class="literal">myprogram.bas</code> into <code class="literal">myprogram.hex</code>, you could run:</p><pre class="screen">    $ gcbasic -A:GCASM -R:none -K:A -WX -V myprogram.bas</pre><p>This will:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">use GCBASIC&#8217;s internal assembler,</li><li class="listitem">turn off report creation,</li><li class="listitem">preserve all code in the assembly file output (useful for debugging)</li><li class="listitem">treat warnings as errors, and</li><li class="listitem">print compiler messages in verbose mode</li></ul></div><p><span class="strong"><strong>Programming</strong></span></p><p>To transfer your compiled .hex program files from your Pi to your microcontroller, you will need additional software.</p><p>For most PIC microcontrollers, you should use <a class="link" href="https://pickitplus.co.uk/Typesetter/index.php/PKCMD-Pi-Application" target="_top">PICkitPlus for Pi</a>.  PICKitPlus support the widest range of PICs including the latest PICs. It is fully supported application.</p><p>For AVR microcontrollers, you will need <code class="literal">avrdude</code>. It should be available in your distribution&#8217;s repository. If not, check here: <a class="link" href="http://www.nongnu.org/avrdude/" target="_top">http://www.nongnu.org/avrdude/</a> .  Instructions on how to use it can be found <a class="link" href="https://learn.adafruit.com/program-an-avr-or-arduino-using-raspberry-pi-gpio-pins/overview" target="_top">here</a>.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="overview_raspberry_pi"></span>Overview - Raspberry Pi

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

GCBASIC can be used when using the Raspberry Pi.

You can install the command-line version of GCBASIC on a Raspberry Pi
(and similar single-board computers) and use it to compile your GCBASIC
programs.

You can also program most PICs and AVRs using only the Pi’s GPIO pins
(see <a href="" class="xref">???</a>), as well as communicate with your
device over the Pi’s serial port. This makes it easy to program, modify,
and communicate with a PIC or AVR using just a Pi and an SSH connection.

GCBASIC is not published for ARM-based computers, there is currently no
pre-compiled version for ARM-based computers, so you will have to
compile it from source. The GCBASIC compiler is written in
<a href="https://www.freebasic.net/" class="link">FreeBASIC</a> (an
open-source version of BASIC), so you will need to first install the
FreeBASIC compiler on your Pi, then use it to compile the GCBASIC
compiler from its source code. This is relatively simple.

FreeBASIC is not included in any of the major Linux repositories, but
there is a customized version for ARMv7 boards like the Raspberry Pi on
their
<a href="https://users.freebasic-portal.de/stw/builds/linux-armv7a-hf-debian/" class="link">web site</a>.

The following procedure will work with any ARMv7 single-board computer
running a Debian derivative like
<a href="https://www.raspberrypi.org/downloads/raspberry-pi-os/" class="link">Raspberry Pi OS</a>
or <a href="https://www.armbian.com/" class="link">Armbian</a>. This
includes the Raspberry Pi 2 and 3, and all single board computers with
an Allwinner H2+ or H3 microprocessor (Orange Pi PC, Orange Pi Zero,
Nano Pi R1, etc). It has not been tested with a Raspberry Pi 4.

<span class="strong">**Instructions:**</span>

All commands should be performed on your Pi board, either through a
remote SSH terminal or using a keyboard and monitor connected to your
Pi.

<span class="emphasis">*Installing FreeBASIC*</span>

<div class="orderedlist">

1.  Install FreeBASIC dependencies

</div>

``` screen
    $ sudo apt-get install libx11-dev libxext-dev libxpm-dev libxrandr-dev libncurses5 libncurses5-dev
```

<div class="orderedlist">

1.  Download the latest version FreeBASIC for ARMv7 from
    <https://users.freebasic-portal.de/stw/builds/linux-armv7a-hf-debian/>
    :

</div>

``` screen
    $ cd ~
    $ wget https://users.freebasic-portal.de/stw/builds/linux-armv7a-hf-debian/fbc_linux_armv7a_hf_debian_0376_2020-09-17.zip
    $ unzip fbc_linux_armv7a_hf_debian_0376_2020-09-17.zip
```

<div class="orderedlist">

1.  Install FreeBASIC

</div>

``` screen
  $ cd fbc_linux_armv7a_hf_debian/
  $ chmod +x install.sh
  $ sudo ./install.sh -i
```

<span class="emphasis">*Installing GCBASIC*</span>

<div class="orderedlist">

1.  Download and extract the GCBASIC sources:

</div>

``` screen
    $ wget "https://downloads.sourceforge.net/project/gcbasic/GCBasic%20-%20Linux%20Distribution/GCB%40Syn.rar"
    $ sudo apt install unar
    # the password when requested in the next step is "GCB"
    $ unar GCBASIC.rar
    $ cd GCBASIC/sources/linuxbuild/
```

<div class="orderedlist">

1.  Build and install the compiler:

</div>

``` screen
    $ chmod +x install.sh
    $ ./install.sh build
    $ sudo ./install.sh install
```

<div class="orderedlist">

1.  Verify the compiler is properly installed and view the full list of
    compiler options

</div>

``` screen
    $ gcbasic
```

Now you can create and compile GCBASIC source files. For example, to
compile a program you created named `myprogram.bas` into
`myprogram.hex`, you could run:

``` screen
    $ gcbasic -A:GCASM -R:none -K:A -WX -V myprogram.bas
```

This will:

<div class="itemizedlist">

-   use GCBASIC’s internal assembler,
-   turn off report creation,
-   preserve all code in the assembly file output (useful for debugging)
-   treat warnings as errors, and
-   print compiler messages in verbose mode

</div>

<span class="strong">**Programming**</span>

To transfer your compiled .hex program files from your Pi to your
microcontroller, you will need additional software.

For most PIC microcontrollers, you should use
<a href="https://pickitplus.co.uk/Typesetter/index.php/PKCMD-Pi-Application" class="link">PICkitPlus for Pi</a>.
PICKitPlus support the widest range of PICs including the latest PICs.
It is fully supported application.

For AVR microcontrollers, you will need `avrdude`. It should be
available in your distribution’s repository. If not, check here:
<http://www.nongnu.org/avrdude/> . Instructions on how to use it can be
found
<a href="https://learn.adafruit.com/program-an-avr-or-arduino-using-raspberry-pi-gpio-pins/overview" class="link">here</a>.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Pad</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_mid.html" title="Mid"><link rel="next" href="_right.html" title="Right"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_pad"></a>Pad</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    out_string = Pad( <span class="emphasis"><em>string_variable</em></span>, <span class="emphasis"><em>byte_value_of_the_new_length</em></span>, <span class="emphasis"><em>pad_character</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Pad</code> function is used to create string to a specific length that is extended with a specific character.</p><p>The length of the string is specified by the second parameter.  The character used to pad the string is specified by the third parameter.</p><p>A typical use is to pad a string to be displayed on a LCD display.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen"> 'Set chip model
    #chip 16f877a


    DIR PORTA 0x03


    ' make port C as output
    Dir PortC 0x0


    'Defines (Constants)
    #define LCD_SPEED slow
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_NO_RW
    #define LCD_Enable PORTc.0
    #define LCD_RS PORTc.1
    #define LCD_DB4 PORTa.5
    #define LCD_DB5 PORTa.4
    #define LCD_DB6 PORTa.3
    #define LCD_DB7 PORTa.2
    '''--------------------------------------------
    '''-------End of board-specific settings-------
    '''--------------------------------------------


    '''DEMO for pad strings to a length
    '''1st character of a given string.
    '''if no string is given, blanks are used


    ; ---- variables
    'Define the string
    Dim TestData As String * 16
    TestData = "Location"

    'show results on LCD-Display
    cls
    Print Pad ( TestData, 16, "*" )
    Locate 1,0
    Print Pad ( TestData, 16, )


    end</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="pad"></span>Pad

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    out_string = Pad( string_variable, byte_value_of_the_new_length, pad_character)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Pad` function is used to create string to a specific length that is
extended with a specific character.

The length of the string is specified by the second parameter. The
character used to pad the string is specified by the third parameter.

A typical use is to pad a string to be displayed on a LCD display.

<span class="strong">**Example:**</span>

``` screen
 'Set chip model
    #chip 16f877a


    DIR PORTA 0x03


    ' make port C as output
    Dir PortC 0x0


    'Defines (Constants)
    #define LCD_SPEED slow
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_NO_RW
    #define LCD_Enable PORTc.0
    #define LCD_RS PORTc.1
    #define LCD_DB4 PORTa.5
    #define LCD_DB5 PORTa.4
    #define LCD_DB6 PORTa.3
    #define LCD_DB7 PORTa.2
    '''--------------------------------------------
    '''-------End of board-specific settings-------
    '''--------------------------------------------


    '''DEMO for pad strings to a length
    '''1st character of a given string.
    '''if no string is given, blanks are used


    ; ---- variables
    'Define the string
    Dim TestData As String * 16
    TestData = "Location"

    'show results on LCD-Display
    cls
    Print Pad ( TestData, 16, "*" )
    Locate 1,0
    Print Pad ( TestData, 16, )


    end
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Parabola</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_hyperbole.html" title="Hyperbole"><link rel="next" href="_pset.html" title="Pset"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_parabola"></a>Parabola</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Parabola (x,  y,  p_factor,  type, modestop, optional LineColour=GLCDForeground)</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Draws on a GLCD a parabola with equation y^2=2*p_factor*x, centered at  pixel positions (x, y) .</p><p>The parabola is an unbounded curve.</p><p>The parabola can be alined either along the x axis or along the y axis.</p><p>Drawing parabola on the screen can be constrained by following two different criteria:
  - a branch has reached a border of the display.
  - both branches have reached the display border.</p><p>For a parabola centered on the display these criteria are equivalent.</p><p><span class="strong"><strong>Input parameters:</strong></span></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Parameter</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">x, y</code></p></td><td align="left" valign="top"><p>X, Y coordinates of the parabola vertex.  X is the minimum x value of the parabola when alined along X.
             Y is the minimum y value of the parabola when alined along y &nbsp;&nbsp;in pixel positions
</p><p></p><p></p><p>The x or y coordinates are Word value, p_factor is word value, type and ModeStop are byte values .</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">p_factor</code></p></td><td align="left" valign="top"><p>The factor such that y^2=2*p_factor*x is the equation of the parabola</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">type</code></p></td><td align="left" valign="top"><p>type=1 the parabola is aligned along x axis
<br>
type=2 the parabola is aligned along y axis</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">modestop</code></p></td><td align="left" valign="top"><p>modestop=1 drawing stops when a display border is encountered by a parabola branch.
<br>
modestop=2 drawing stops when all the parabolla branches encountered a border</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">LineColour</code></p></td><td align="left" valign="top"><p>Color of the parabola</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Example for a 240x320 pixels GLCD

    #include &lt;glcd.h&gt;

    Parabola(120, 160, 20, 1, 2, GLCDForeground)   ;  centered, p_factor=20, x_axis alined, stops when all branches have reached a a border
    Parabola(120, 160 ,20, 1, 1, GLCDForeground)   ; centered, p_factor=20, x_axis alined, stops when a border is reached
    Parabola(120, 160, 20, 2, 1, GLCDForeground)   ; centered, p_factor=20, y_axis alined, stops when a border is reached,

    Parabola(180, 80, 20, 1, 1, GLCDForeground)   ; upper right, p_factor=20, x_axis alined, stops when a border is touched,
    Parabola(60, 240, 20, 1, 2, GLCDForeground)   ; lower left, p_factor=20, x_axis alined, stops when all branches have reached a border

    Parabola(180, 80, 20, 2, 1, GLCDForeground)   ; upper right, p_factor=20, y_axis alined, stops when a border is touched,
    Parabola(60, 240, 20, 2, 2, GLCDForeground)   ; lower left, p_factor=20, y_axis alined, stops when all branches have reached a border</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="parabola"></span>Parabola

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Parabola (x,  y,  p_factor,  type, modestop, optional LineColour=GLCDForeground)
```

<span class="strong">**Explanation:**</span>

Draws on a GLCD a parabola with equation y^2=2\*p\_factor\*x, centered
at pixel positions (x, y) .

The parabola is an unbounded curve.

The parabola can be alined either along the x axis or along the y axis.

Drawing parabola on the screen can be constrained by following two
different criteria: - a branch has reached a border of the display. -
both branches have reached the display border.

For a parabola centered on the display these criteria are equivalent.

<span class="strong">**Input parameters:**</span>

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Parameter</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">x, y</code></p></td>
<td style="text-align: left;"><p>X, Y coordinates of the parabola vertex. X is the minimum x value of the parabola when alined along X. Y is the minimum y value of the parabola when alined along y   in pixel positions</p>
<p>The x or y coordinates are Word value, p_factor is word value, type and ModeStop are byte values .</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">p_factor</code></p></td>
<td style="text-align: left;"><p>The factor such that y^2=2*p_factor*x is the equation of the parabola</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">type</code></p></td>
<td style="text-align: left;"><p>type=1 the parabola is aligned along x axis<br />
type=2 the parabola is aligned along y axis</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">modestop</code></p></td>
<td style="text-align: left;"><p>modestop=1 drawing stops when a display border is encountered by a parabola branch.<br />
modestop=2 drawing stops when all the parabolla branches encountered a border</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">LineColour</code></p></td>
<td style="text-align: left;"><p>Color of the parabola</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Example:**</span>

``` screen
    'Example for a 240x320 pixels GLCD

    #include <glcd.h>

    Parabola(120, 160, 20, 1, 2, GLCDForeground)   ;  centered, p_factor=20, x_axis alined, stops when all branches have reached a a border
    Parabola(120, 160 ,20, 1, 1, GLCDForeground)   ; centered, p_factor=20, x_axis alined, stops when a border is reached
    Parabola(120, 160, 20, 2, 1, GLCDForeground)   ; centered, p_factor=20, y_axis alined, stops when a border is reached,

    Parabola(180, 80, 20, 1, 1, GLCDForeground)   ; upper right, p_factor=20, x_axis alined, stops when a border is touched,
    Parabola(60, 240, 20, 1, 2, GLCDForeground)   ; lower left, p_factor=20, x_axis alined, stops when all branches have reached a border

    Parabola(180, 80, 20, 2, 1, GLCDForeground)   ; upper right, p_factor=20, y_axis alined, stops when a border is touched,
    Parabola(60, 240, 20, 2, 2, GLCDForeground)   ; lower left, p_factor=20, y_axis alined, stops when all branches have reached a border
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Pause</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_flow_control.html" title="Flow control"><link rel="prev" href="_indcall.html" title="IndCall"><link rel="next" href="_repeat.html" title="Repeat"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_pause"></a>Pause</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen"><span class="strong"><strong><span class="emphasis"><em>Fixed Length Delay:</em></span></strong></span>
    Pause time_ms</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The Pause command will cause the program to pause for a specified time in milliseconds.
The only unit of time permitted is milliseconds.</p><p>Please use the <code class="literal">wait</code> command to use other units of time.</p><p><span class="strong"><strong>For more help, see <a class="link" href="_wait.html" title="Wait">Wait</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="pause"></span>Pause

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
Fixed Length Delay:
    Pause time_ms
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The Pause command will cause the program to pause for a specified time
in milliseconds. The only unit of time permitted is milliseconds.

Please use the `wait` command to use other units of time.

<span class="strong">**For more help, see
<a href="wait" class="link" title="Wait">Wait</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PCD8544 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_nt7108c_controllers.html" title="NT7108C Controllers"><link rel="next" href="_sdd1289_controllers.html" title="SDD1289 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_pcd8544_controllers"></a>PCD8544 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the PCD844 graphics controller.<br></p><p>The PCD8544 is a low power CMOS LCD controller/driver,
designed to drive a graphic display of 48 rows and
84 columns.  All necessary functions for the display are
provided in a single chip, including on-chip generation of
LCD supply and bias voltages, resulting in a minimum of
external components and low power consumption.
The PCD8544 interfaces to microcontrollers through a
serial bus interface.</p><p>The GCBASIC constants shown below control the configuration of the PCD844 controller. &nbsp;&nbsp;&nbsp;GCBASIC supports SPI software connectivity only - this is shown in the tables below.</p><p>The PCD8544 is a monochrome device.</p><p>The PCD844can operate in two modes. Full GLCD mode and Text/JPG mode the full GLCD mode requires a minimum of 512 bytes.  For microcontrollers with limited memory the text only can be selected by setting the correct constant.</p><p>To use the PCD844 driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_PCD8544

    ' Pin mappings for software SPI for Nokia 3310 Device
    #define GLCD_DO     portc.5              'example port setting
    #define GLCD_SCK    portc.3              'example port setting
    #define GLCD_DC     portc.2              'example port setting
    #define GLCD_CS     portc.1              'example port setting
    #define GLCD_RESET  portc.0              'example port setting</pre><p>The GCBASIC constants for the interface to the controller are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_PCD8544</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DC</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command IO pin on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS) on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Reset</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_D0</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on
the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_SCK</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Clock (CLK) pin on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_PCD8544_CHARACTER_MODE_ONLY</code></p></td><td align="left" valign="top"><p>Specifies that the display controller will operate in text mode and BMP
draw mode only.<br>
For microcontrollers with less then 1kb of RAM this will be set be
default.</p></td><td align="center" valign="top"><p>Optional</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PCD8544ClockDelay</code></p></td><td align="left" valign="top"><p>Specifies the clock delay, if required for slower microcontroller,</p></td><td align="center" valign="top"><p>Optional. Set to 0 as the default value</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PCD8544WriteDelay</code></p></td><td align="left" valign="top"><p>Specifies the write delay, if required for slower microcontroller,</p></td><td align="center" valign="top"><p>Optional. Set to 0 as the default value</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="center" valign="top"><p>160<br>
This cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="center" valign="top"><p>128<br>
This cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="center" valign="top"><p>6</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr></tbody></table></div><p>*For a PCD8544 datasheet, please refer
<a class="link" href="https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CCMQFjAA&amp;url=https%3A%2F%2Fwww.sparkfun.com%2Fdatasheets%2FLCD%2FMonochrome%2FNokia5110.pdf&amp;ei=bmjDVKePM83datDIgYgH&amp;usg=AFQjCNFa7N9WMhSg849oXejlfP3FRvQqpA&amp;sig2=ZFpG-ubTxvrBRAV4dRvhVw" target="_top">here</a><br></p><p>This example shows how to drive a PCD8544 based Graphic LCD module with the built in commands of GCBASIC.</p><p>Example:</p><pre class="screen">      #chip 16lf1939,32
      #option Explicit
      #config MCLRE_ON

      #include &lt;glcd.h&gt;

      #DEFINE GLCD_TYPE GLCD_TYPE_PCD8544

      ' Pin mappings for software SPI for Nokia 3310 Device
      #define GLCD_DO portc.5
      #define GLCD_SCK portc.3
      #define GLCD_DC portc.2
      #define GLCD_CS portc.1
      #define GLCD_RESET portc.0

      Dim outString as string
      Dim ccount, byteNumber as Byte
      Dim longNumber as Long
      Dim wordNumber as Word
      GLCDCLS

      DO forever
         for CCount = 31 to 127
              GLCDPrint (0, 0, "PrintStr")
              GLCDDrawString (0, 9, "DrawStr")
              GLCDPrint ( 44 ,  21, "     ")
              GLCDPrint ( 44 ,  29, "     ") ' word value
              GLCDPrint ( 44 ,  37, "   ") ' Byte value

              outstring = hex( longNumber_U)
              GLCDPrint ( 44 , 21,outstring )
              outstring = hex( longNumber_H)
              GLCDPrint ( 55 , 21, outstring)
              outstring = hex( longNumber)
              GLCDPrint ( 67 , 21,  outstring )
              GLCDPrint ( 44 , 29, mid( str(wordNumber),1, 6))
              GLCDPrint ( 44 , 37, byteNumber)

              box 46,9,57,19
              GLCDDrawChar(48, 9, CCount )
              outString = str( CCount )
              ' draw a box to overwrite existing strings
              FilledBox(58,9,GLCD_WIDTH-1,17,GLCDBackground )
              GLCDDrawString(58, 9, outString )

               box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1
               box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH- 1, GLCD_HEIGHT-1
               filledbox 2,30,6,38, wordNumber
               Circle( 25,30,8,1)            ;center
               FilledCircle( 25,30,4,longNumber xor 1) ;center

               line 0,  GLCD_HEIGHT-1 , GLCD_WIDTH/2, (GLCD_HEIGHT /2) +1
               line  GLCD_WIDTH/2, (GLCD_HEIGHT /2) +1 ,0, (GLCD_HEIGHT /2) +1


              longNumber = longNumber + 7
              wordNumber = wordNumber + 3
              byteNumber++
          NEXT
      LOOP

      end</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt; and &lt;glcd_PCD8544.h&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="pcd8544_controllers"></span>PCD8544 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the PCD844 graphics
controller.  

The PCD8544 is a low power CMOS LCD controller/driver, designed to drive
a graphic display of 48 rows and 84 columns. All necessary functions for
the display are provided in a single chip, including on-chip generation
of LCD supply and bias voltages, resulting in a minimum of external
components and low power consumption. The PCD8544 interfaces to
microcontrollers through a serial bus interface.

The GCBASIC constants shown below control the configuration of the
PCD844 controller.    GCBASIC supports SPI software connectivity only -
this is shown in the tables below.

The PCD8544 is a monochrome device.

The PCD844can operate in two modes. Full GLCD mode and Text/JPG mode the
full GLCD mode requires a minimum of 512 bytes. For microcontrollers
with limited memory the text only can be selected by setting the correct
constant.

To use the PCD844 driver simply include the following in your user code.
This will initialise the driver.

``` screen
    #include <glcd.h>
    #define GLCD_TYPE GLCD_TYPE_PCD8544

    ' Pin mappings for software SPI for Nokia 3310 Device
    #define GLCD_DO     portc.5              'example port setting
    #define GLCD_SCK    portc.3              'example port setting
    #define GLCD_DC     portc.2              'example port setting
    #define GLCD_CS     portc.1              'example port setting
    #define GLCD_RESET  portc.0              'example port setting
```

The GCBASIC constants for the interface to the controller are shown in
the table below.

<div class="informaltable">

| <span class="strong">**Constants**</span> | <span class="strong">**Controls**</span>                                          | <span class="strong">**Options**</span> |
|:------------------------------------------|:----------------------------------------------------------------------------------|:----------------------------------------|
| `GLCD_TYPE`                               | `GLCD_TYPE_PCD8544`                                                               |                                         |
| `GLCD_DC`                                 | Specifies the output pin that is connected to Data/Command IO pin on the GLCD.    | Required                                |
| `GLCD_CS`                                 | Specifies the output pin that is connected to Chip Select (CS) on the GLCD.       | Required                                |
| `GLCD_Reset`                              | Specifies the output pin that is connected to Reset pin on the GLCD.              | Required                                |
| `GLCD_D0`                                 | Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD. | Required                                |
| `GLCD_SCK`                                | Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.        | Required                                |

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_PCD8544_CHARACTER_MODE_ONLY</code></p></td>
<td style="text-align: left;"><p>Specifies that the display controller will operate in text mode and BMP draw mode only.<br />
For microcontrollers with less then 1kb of RAM this will be set be default.</p></td>
<td style="text-align: center;"><p>Optional</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">PCD8544ClockDelay</code></p></td>
<td style="text-align: left;"><p>Specifies the clock delay, if required for slower microcontroller,</p></td>
<td style="text-align: center;"><p>Optional. Set to 0 as the default value</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">PCD8544WriteDelay</code></p></td>
<td style="text-align: left;"><p>Specifies the write delay, if required for slower microcontroller,</p></td>
<td style="text-align: center;"><p>Optional. Set to 0 as the default value</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: center;"><p>160<br />
This cannot be changed</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: center;"><p>128<br />
This cannot be changed</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Specifies the font width of the GCBASIC font set.</p></td>
<td style="text-align: center;"><p>6</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**Purpose**</span>                                                  | <span class="strong">**Example**</span>                                                        |
|:----------------------------------------|:-----------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------|
| `GLCDCLS`                               | Clear screen of GLCD                                                                     | `GLCDCLS`                                                                                      |
| `GLCDPrint`                             | Print string of characters on GLCD using GCB font set                                    | `GLCDPrint( Xposition, Yposition, Stringvariable )`                                            |
| `GLCDDrawChar`                          | Print character on GLCD using GCB font set                                               | `GLCDDrawChar( Xposition, Yposition, CharCode )`                                               |
| `GLCDDrawString`                        | Print characters on GLCD using GCB font set                                              | `GLCDDrawString( Xposition, Yposition, Stringvariable )`                                       |
| `Box`                                   | Draw a box on the GLCD to a specific size                                                | `Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )`   |
| `FilledBox`                             | Draw a box on the GLCD to a specific size that is filled with the foreground colour.     | `FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )` |
| `Line`                                  | Draw a line on the GLCD to a specific length that is filled with the specific attribute. | `Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`     |
| `PSet`                                  | Set a pixel on the GLCD at a specific position that is set with the specific attribute.  | `PSet(Xposition, Yposition, Pixel Colour 0 or 1)`                                              |
| `GLCDWriteByte`                         | Set a byte value to the controller, see the datasheet for usage.                         | `GLCDWriteByte ( LCDByte)`                                                                     |
| `GLCDReadByte`                          | Read a byte value from the controller, see the datasheet for usage.                      | `bytevariable = GLCDReadByte`                                                                  |

</div>

\*For a PCD8544 datasheet, please refer
<a href="https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CCMQFjAA&amp;url=https%3A%2F%2Fwww.sparkfun.com%2Fdatasheets%2FLCD%2FMonochrome%2FNokia5110.pdf&amp;ei=bmjDVKePM83datDIgYgH&amp;usg=AFQjCNFa7N9WMhSg849oXejlfP3FRvQqpA&amp;sig2=ZFpG-ubTxvrBRAV4dRvhVw" class="link">here</a>  

This example shows how to drive a PCD8544 based Graphic LCD module with
the built in commands of GCBASIC.

Example:

``` screen
      #chip 16lf1939,32
      #option Explicit
      #config MCLRE_ON

      #include <glcd.h>

      #DEFINE GLCD_TYPE GLCD_TYPE_PCD8544

      ' Pin mappings for software SPI for Nokia 3310 Device
      #define GLCD_DO portc.5
      #define GLCD_SCK portc.3
      #define GLCD_DC portc.2
      #define GLCD_CS portc.1
      #define GLCD_RESET portc.0

      Dim outString as string
      Dim ccount, byteNumber as Byte
      Dim longNumber as Long
      Dim wordNumber as Word
      GLCDCLS

      DO forever
         for CCount = 31 to 127
              GLCDPrint (0, 0, "PrintStr")
              GLCDDrawString (0, 9, "DrawStr")
              GLCDPrint ( 44 ,  21, "     ")
              GLCDPrint ( 44 ,  29, "     ") ' word value
              GLCDPrint ( 44 ,  37, "   ") ' Byte value

              outstring = hex( longNumber_U)
              GLCDPrint ( 44 , 21,outstring )
              outstring = hex( longNumber_H)
              GLCDPrint ( 55 , 21, outstring)
              outstring = hex( longNumber)
              GLCDPrint ( 67 , 21,  outstring )
              GLCDPrint ( 44 , 29, mid( str(wordNumber),1, 6))
              GLCDPrint ( 44 , 37, byteNumber)

              box 46,9,57,19
              GLCDDrawChar(48, 9, CCount )
              outString = str( CCount )
              ' draw a box to overwrite existing strings
              FilledBox(58,9,GLCD_WIDTH-1,17,GLCDBackground )
              GLCDDrawString(58, 9, outString )

               box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1
               box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH- 1, GLCD_HEIGHT-1
               filledbox 2,30,6,38, wordNumber
               Circle( 25,30,8,1)            ;center
               FilledCircle( 25,30,4,longNumber xor 1) ;center

               line 0,  GLCD_HEIGHT-1 , GLCD_WIDTH/2, (GLCD_HEIGHT /2) +1
               line  GLCD_WIDTH/2, (GLCD_HEIGHT /2) +1 ,0, (GLCD_HEIGHT /2) +1


              longNumber = longNumber + 7
              wordNumber = wordNumber + 3
              byteNumber++
          NEXT
      LOOP

      end
```

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt; and &lt;glcd\_PCD8544.h&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Peek</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_miscellaneous_commands.html" title="Miscellaneous Commands"><link rel="prev" href="_pulseininv.html" title="PulseInInv"><link rel="next" href="_poke.html" title="Poke"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_peek"></a>Peek</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>OutputVariable</em></span> = Peek (<span class="emphasis"><em>location</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Peek</code> function is used to read information from the on-chip RAM of the microcontroller.</p><p><code class="literal"><span class="emphasis"><em>location</em></span></code> is a word variable that gives the address to read. The exact range of valid values varies from chip to chip.</p><p>This command should not normally be used, as it will make the porting of code to another chip very difficult.</p><p><span class="strong"><strong>Example #1 :</strong></span></p><pre class="screen">    'This program will read and check a value from PORTA
    'This specific peek will only work on some microcontrollers
    Temp = Peek(5)
    IF Temp.2 ON THEN SET green ON
IF Temp.2 OFF THEN SET red ON</pre><p><span class="strong"><strong>Example #2</strong></span></p><pre class="screen">    ' This subroutine will toggle the pin state.
    ' You must change the parameters for your specific chip.
    ' Usage as show in examples below.
    '
    '      Toggle @PORTE, 2 ' equates to RE1.
    '      Wait 100  ms
    '      Toggle @PORTE, 2
    '      Wait 100 ms


    ' Port , Pin address in Binary
    ' Pin0 = 1
    ' Pin1 = 2
    ' Pin2 = 4
    ' Pin3 = 8
    '
    ' You can toggle any number of pins.
    ' Toggle @PORTE, 0x55
    Sub Toggle ( In DestPort As word, In DestBit )
          Poke DestPort, Peek(DestPort) xor DestBit
    End sub</pre><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_poke.html" title="Poke">Poke</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="peek"></span>Peek

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    OutputVariable = Peek (location)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Peek` function is used to read information from the on-chip RAM of
the microcontroller.

`location` is a word variable that gives the address to read. The exact
range of valid values varies from chip to chip.

This command should not normally be used, as it will make the porting of
code to another chip very difficult.

<span class="strong">**Example \#1 :**</span>

``` screen
    'This program will read and check a value from PORTA
    'This specific peek will only work on some microcontrollers
    Temp = Peek(5)
    IF Temp.2 ON THEN SET green ON
IF Temp.2 OFF THEN SET red ON
```

<span class="strong">**Example \#2**</span>

``` screen
    ' This subroutine will toggle the pin state.
    ' You must change the parameters for your specific chip.
    ' Usage as show in examples below.
    '
    '      Toggle @PORTE, 2 ' equates to RE1.
    '      Wait 100  ms
    '      Toggle @PORTE, 2
    '      Wait 100 ms


    ' Port , Pin address in Binary
    ' Pin0 = 1
    ' Pin1 = 2
    ' Pin2 = 4
    ' Pin3 = 8
    '
    ' You can toggle any number of pins.
    ' Toggle @PORTE, 0x55
    Sub Toggle ( In DestPort As word, In DestBit )
          Poke DestPort, Peek(DestPort) xor DestBit
    End sub
```

<span class="strong">**See Also**</span>
<a href="poke" class="link" title="Poke">Poke</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Peripheral Pin Select</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_trigonometry_atan.html" title="Trigonometry ATAN"><link rel="next" href="_peripheral_pin_select_for_microchip_microcontrollers.html" title="Peripheral Pin Select for Microchip microcontrollers."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_peripheral_pin_select"></a>Peripheral Pin Select</h3></div></div></div><p>This is the Peripheral Pin Select section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="peripheral_pin_select"></span>Peripheral Pin Select

</div>

</div>

</div>

This is the Peripheral Pin Select section of the Help file. Please refer
the sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Peripheral Pin Select for Microchip microcontrollers.</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_peripheral_pin_select.html" title="Peripheral Pin Select"><link rel="prev" href="_peripheral_pin_select.html" title="Peripheral Pin Select"><link rel="next" href="_unlockpps.html" title="UnLockPPS"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_peripheral_pin_select_for_microchip_microcontrollers"></a>Peripheral Pin Select for Microchip microcontrollers.</h4></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>Peripheral Pin Select (PPS) enables the digital peripheral I/O pins to be changed to support mapping of external pins to different pins.</p><p>In older 8-bit Microchip devices, a peripheral was hard-wired to a specific pin (example: PWM1 output on pin RC5).</p><p>PPS allows you to choose from a number of output and input pins to connect to the digital peripheral.</p><p>This can be extremely useful for routing circuit boards.</p><p>There are cases where a change of I/O position can make a circuit board easier to route Sometimes mistakes are found too late to fix so having the option to change a pinout mapping in software rather than creating a new printed circuit board can be very helpful.</p><p>You <span class="strong"><strong>must</strong></span> use the command <code class="literal">UnLockPPS</code> to enable setting of the PPS if the PPS have been previously locked, and, you can, optionally,  use <code class="literal">LockPPS</code> to prevent unintentional change to PPS settings.</p><p>GCBASIC includes these two macros to ensure this process is handled correctly.</p><p>Also, see <a class="link" href="http://microchip.wikidot.com/8bit:pps" target="_top">http://microchip.wikidot.com/8bit:pps</a> for more information.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Please check configuration before using on an alternative microcontroller.

    #chip 16f18855,32
    #option explicit

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      LOCKPPS
        RC0PPS = 0x0010       'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011       'RC1-&gt;EUSART:RX;

        SSP1CLKPPS = 0x14     'RC3-&gt;MSSP1:SCL1;
        SSP1DATPPS = 0x13     'RC4-&gt;MSSP1:SDA1;
        RC3PPS = 0x15         'RC3-&gt;MSSP1:SCL1;
        RC4PPS = 0x14         'RC4-&gt;MSSP1:SDA1;
      UnLockPPS
    End Sub</pre><p><span class="strong"><strong>For more help, see: <a class="link" href="_unlockpps.html" title="UnLockPPS">UnlockPPS</a> and <a class="link" href="_lockpps.html" title="LockPPS">LockPPS</a>.</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="peripheral_pin_select_for_microchip_microcontrollers"></span>Peripheral Pin Select for Microchip microcontrollers.

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

Peripheral Pin Select (PPS) enables the digital peripheral I/O pins to
be changed to support mapping of external pins to different pins.

In older 8-bit Microchip devices, a peripheral was hard-wired to a
specific pin (example: PWM1 output on pin RC5).

PPS allows you to choose from a number of output and input pins to
connect to the digital peripheral.

This can be extremely useful for routing circuit boards.

There are cases where a change of I/O position can make a circuit board
easier to route Sometimes mistakes are found too late to fix so having
the option to change a pinout mapping in software rather than creating a
new printed circuit board can be very helpful.

You <span class="strong">**must**</span> use the command `UnLockPPS` to
enable setting of the PPS if the PPS have been previously locked, and,
you can, optionally, use `LockPPS` to prevent unintentional change to
PPS settings.

GCBASIC includes these two macros to ensure this process is handled
correctly.

Also, see <http://microchip.wikidot.com/8bit:pps> for more information.

<span class="strong">**Example:**</span>

``` screen
    'Please check configuration before using on an alternative microcontroller.

    #chip 16f18855,32
    #option explicit

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      LOCKPPS
        RC0PPS = 0x0010       'RC0->EUSART:TX;
        RXPPS  = 0x0011       'RC1->EUSART:RX;

        SSP1CLKPPS = 0x14     'RC3->MSSP1:SCL1;
        SSP1DATPPS = 0x13     'RC4->MSSP1:SDA1;
        RC3PPS = 0x15         'RC3->MSSP1:SCL1;
        RC4PPS = 0x14         'RC4->MSSP1:SDA1;
      UnLockPPS
    End Sub
```

<span class="strong">**For more help, see:
<a href="unlockpps" class="link" title="UnLockPPS">UnlockPPS</a>
and
<a href="lockpps" class="link" title="LockPPS">LockPPS</a>.**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PFMRead</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_progmem_pfm.html" title="PROGMEM ( PFM )"><link rel="prev" href="_progmem_pfm.html" title="PROGMEM ( PFM )"><link rel="next" href="_pfmwrite.html" title="PFMWrite"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_pfmread"></a>PFMRead</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PFMRead (<span class="emphasis"><em>location, store</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip PIC microcontrollers with PFM self write capability.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">PFMRead</code> reads information from the program memory on chips that
support this feature. <code class="literal"><span class="emphasis"><em>location</em></span></code> is a word variable, and <code class="literal"><span class="emphasis"><em>store</em></span></code> can be a byte of word.</p><p>The largest value possible for <code class="literal"><span class="emphasis"><em>location</em></span></code> depends on the amount of
program memory on the Microchip PIC microcontroller.</p><p>This is an advanced command which should only be used by advanced
developers.</p><p><span class="strong"><strong>For more help, see <a class="link" href="_pfmwrite.html" title="PFMWrite">PFMWrite</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="pfmread"></span>PFMRead

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PFMRead (location, store)
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip PIC microcontrollers with PFM self write
capability.

<span class="strong">**Explanation:**</span>

`PFMRead` reads information from the program memory on chips that
support this feature. `location` is a word variable, and `store` can be
a byte of word.

The largest value possible for `location` depends on the amount of
program memory on the Microchip PIC microcontroller.

This is an advanced command which should only be used by advanced
developers.

<span class="strong">**For more help, see
<a href="pfmwrite" class="link" title="PFMWrite">PFMWrite</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PFMWrite</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_progmem_pfm.html" title="PROGMEM ( PFM )"><link rel="prev" href="_pfmread.html" title="PFMRead"><link rel="next" href="_programerase.html" title="ProgramErase"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_pfmwrite"></a>PFMWrite</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PFMWrite (<span class="emphasis"><em>location</em></span>, <span class="emphasis"><em>value</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip PIC microcontrollers with PFM self write capability.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">PFMWrite</code> writes information to the program memory on chips that
support this feature. <code class="literal"><span class="emphasis"><em>location</em></span></code> is a word variable, and <code class="literal"><span class="emphasis"><em>store</em></span></code> can be a byte of word.</p><p>The largest value possible for <code class="literal"><span class="emphasis"><em>location</em></span></code> depends on the amount of
program memory on the microcontroller.</p><p>This is an advanced command which should only be used by advanced
developers.</p><p><span class="strong"><strong>Example:</strong></span></p><p><span class="strong"><strong>For more help, see *<a class="link" href="_pfmread.html" title="PFMRead">PFMRead</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="pfmwrite"></span>PFMWrite

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PFMWrite (location, value)
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip PIC microcontrollers with PFM self write
capability.

<span class="strong">**Explanation:**</span>

`PFMWrite` writes information to the program memory on chips that
support this feature. `location` is a word variable, and `store` can be
a byte of word.

The largest value possible for `location` depends on the amount of
program memory on the microcontroller.

This is an advanced command which should only be used by advanced
developers.

<span class="strong">**Example:**</span>

<span class="strong">**For more help, see
\*<a href="pfmread" class="link" title="PFMRead">PFMRead</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PIC users and Beginners: Start Here</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_using_gcbasic.html" title="Using GCBASIC"><link rel="next" href="_changes.html" title="Changes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_pic_users_and_beginners_start_here"></a>PIC users and Beginners: Start Here</h2></div></div></div><p>Welcome to GCBASIC.&nbsp;&nbsp;This document is especially important for experienced PIC users moving from MPASM or C so please spend a few seconds here before you start.&nbsp;&nbsp; It could save you hours of frustration.</p><p>As a PIC user most of us are conditioned, regardless of the Assembler or Compiler, to reach for the devices data sheet first and try to work out how to setup the Oscillator, interrupt vectors and Configuration bits.</p><p><span class="strong"><strong>Do not DO IT</strong></span>.&nbsp;&nbsp; read this document first as it will give you some great insights. &nbsp;&nbsp; For the basic operation the only setup and configuration required for a GCBASIC program is the name of the target Device i.e. <code class="literal">#Chip 16f1619</code>.  &nbsp;&nbsp;   That is it, honestly, GCBASIC will do the rest and will determine the optimal Oscillator settings, interrupt vectors, Configuration bits etc</p><p>Next we would  start deciding on and including the Device files and libraries that we intend to use.&nbsp;&nbsp;<span class="strong"><strong>STOP</strong></span>.&nbsp;&nbsp; Let GCBASIC decide. &nbsp;&nbsp; GCBASIC is creating Portable Code, it doesn&#8217;t care if you use a PIC12, PIC18 or an ATmega328.&nbsp;&nbsp;  You write in BASIC and at compile time GCBASIC will decide which core libraries to include based on the instructions you have used and the target device you specified in the #chip statement.</p><p>Finally we would decide on the pins to use, their port names, which register bits are needed to make them inputs or outputs and override any Analog function if a digital function is desired.</p><p>Again,  I say let GCBASIC DO IT&#8230;&#8203;&#8230;&#8203;&#8230;&#8203; <code class="literal">Dir PortC.0 In</code> - Will set Pin RC0 to a Digital Input. &nbsp;&nbsp; There is no need to manually set the TRIS register or see if there is an associated ADCON bit to set or clear.</p><p>Putting it all together: An example GCBASIC program.</p><pre class="screen">    #Chip 16f1619

    #Define LED PortC.0

    Dir LED Out

    Do
      LED = !LED
      Wait 500 ms
    Loop</pre><p>That is it. If you have an LED attached to PortC.0 (LED DS1 on the Low Pin Count Board that shipped with the PICKit 2 or PICKit 3 programmer).&nbsp;&nbsp;  It will start to Blink confirming that you have a working microcontroller and hardware.</p><p>To change target device or family just change the #Chip Entry along with the Pin you have the LED on and recompile.&nbsp;&nbsp; it Really IS as Simple as that to get started in GCBASIC.</p><p>You can manually override GCBASIC and set every register, every flag, every BIT, every Configuration &#8216;Fuse&#8217; and every vector if you wish, but why bother doing it upfront? &nbsp;&nbsp;Rather get your code working with the default settings and then adjust from there, if needed, as your confidence grows.</p><p>One final bit of advice, the IDE tool bar has a &#8220;View Demos&#8221; button, use it, there are examples of all of the most common programming challenges and many different devices which, along with the Help files, will answer most of your questions. The Forum is a friendly place too, so do not be shy to introduce yourself and ask for help.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="pic_users_and_beginners_start_here"></span>PIC users and Beginners: Start Here
-----------------------------------------------------------------------------------------

</div>

</div>

</div>

Welcome to GCBASIC.  This document is especially important for
experienced PIC users moving from MPASM or C so please spend a few
seconds here before you start.   It could save you hours of frustration.

As a PIC user most of us are conditioned, regardless of the Assembler or
Compiler, to reach for the devices data sheet first and try to work out
how to setup the Oscillator, interrupt vectors and Configuration bits.

<span class="strong">**Do not DO IT**</span>.   read this document first
as it will give you some great insights.    For the basic operation the
only setup and configuration required for a GCBASIC program is the name
of the target Device i.e. `#Chip 16f1619`.    That is it, honestly,
GCBASIC will do the rest and will determine the optimal Oscillator
settings, interrupt vectors, Configuration bits etc

Next we would start deciding on and including the Device files and
libraries that we intend to use.  <span
class="strong">**STOP**</span>.   Let GCBASIC decide.    GCBASIC is
creating Portable Code, it doesn’t care if you use a PIC12, PIC18 or an
ATmega328.   You write in BASIC and at compile time GCBASIC will decide
which core libraries to include based on the instructions you have used
and the target device you specified in the \#chip statement.

Finally we would decide on the pins to use, their port names, which
register bits are needed to make them inputs or outputs and override any
Analog function if a digital function is desired.

Again, I say let GCBASIC DO IT…​…​…​ `Dir PortC.0 In` - Will set Pin RC0
to a Digital Input.    There is no need to manually set the TRIS
register or see if there is an associated ADCON bit to set or clear.

Putting it all together: An example GCBASIC program.

``` screen
    #Chip 16f1619

    #Define LED PortC.0

    Dir LED Out

    Do
      LED = !LED
      Wait 500 ms
    Loop
```

That is it. If you have an LED attached to PortC.0 (LED DS1 on the Low
Pin Count Board that shipped with the PICKit 2 or PICKit 3
programmer).   It will start to Blink confirming that you have a working
microcontroller and hardware.

To change target device or family just change the \#Chip Entry along
with the Pin you have the LED on and recompile.   it Really IS as Simple
as that to get started in GCBASIC.

You can manually override GCBASIC and set every register, every flag,
every BIT, every Configuration ‘Fuse’ and every vector if you wish, but
why bother doing it upfront?   Rather get your code working with the
default settings and then adjust from there, if needed, as your
confidence grows.

One final bit of advice, the IDE tool bar has a “View Demos” button, use
it, there are examples of all of the most common programming challenges
and many different devices which, along with the Help files, will answer
most of your questions. The Forum is a friendly place too, so do not be
shy to introduce yourself and ask for help.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Play</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_sound.html" title="Sound"><link rel="prev" href="_shorttone.html" title="ShortTone"><link rel="next" href="_play_rtttl.html" title="Play RTTTL"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_play"></a>Play</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Play SoundPlayDataString</pre><p>You must specify the following include and the port of the sound device.</p><pre class="screen">    #include &lt;songplay.h&gt;
    #define SOUNDOUT PORTN.N</pre><p><span class="strong"><strong>Command Availability::</strong></span>
Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span>
This command will plays a QBASIC sequence of notes. The SoundPlayDataString is a string representing a musical note or notes to play where Notes are A to G.</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>A - G</p></td><td align="left" valign="top"><p>May be followed by length: 2 = half note, 4 = quarter, also may be followed by # or + (sharp) or - (flat).</p></td></tr><tr><td align="left" valign="top"><p>On</p></td><td align="left" valign="top"><p>Sets current octave. n is octave from 0 to 6</p></td></tr><tr><td align="left" valign="top"><p>Pn</p></td><td align="left" valign="top"><p>Pause playing. n is length of rest</p></td></tr><tr><td align="left" valign="top"><p>Ln:</p></td><td align="left" valign="top"><p>Set default note length. n = 1 to 8.</p></td></tr><tr><td align="left" valign="top"><p>&lt; or &gt;</p></td><td align="left" valign="top"><p>Change down or up an octave</p></td></tr><tr><td align="left" valign="top"><p>Tn:</p></td><td align="left" valign="top"><p>Sets tempo in L4s/minute. n = 32 to 255, default 120.</p></td></tr><tr><td align="left" valign="top"><p>Nn</p></td><td align="left" valign="top"><p>Play note n. n = 0 to 84, 0 = rest.</p></td></tr></tbody></table></div><p>Unsupported QBASIC commands are</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>M</p></td><td align="left" valign="top"><p>Play mode</p></td></tr><tr><td align="left" valign="top"><p>.</p></td><td align="left" valign="top"><p>Changes note length</p></td></tr></tbody></table></div><p>For more information on the QBASIC PLAY command set, see <a class="link" href="https://en.wikibooks.org/wiki/QBasic/Appendix" target="_top">https://en.wikibooks.org/wiki/QBasic/Appendix</a></p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Sample program to play a string
    'on PORTB bit 1.
    #chip 16F877A, 20
    #include &lt;songplay.h&gt;
    #define SoundOut PORTB.1


    play "C C# C C#"</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_sound_overview.html" title="Sound Overview">Sound Overview</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="play"></span>Play

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Play SoundPlayDataString
```

You must specify the following include and the port of the sound device.

``` screen
    #include <songplay.h>
    #define SOUNDOUT PORTN.N
```

<span class="strong">**Command Availability::**</span> Available on all
microcontrollers.

<span class="strong">**Explanation:**</span> This command will plays a
QBASIC sequence of notes. The SoundPlayDataString is a string
representing a musical note or notes to play where Notes are A to G.

<div class="informaltable">

| Command      | Description                                                                                                 |
|:-------------|:------------------------------------------------------------------------------------------------------------|
| A - G        | May be followed by length: 2 = half note, 4 = quarter, also may be followed by \# or + (sharp) or - (flat). |
| On           | Sets current octave. n is octave from 0 to 6                                                                |
| Pn           | Pause playing. n is length of rest                                                                          |
| Ln:          | Set default note length. n = 1 to 8.                                                                        |
| &lt; or &gt; | Change down or up an octave                                                                                 |
| Tn:          | Sets tempo in L4s/minute. n = 32 to 255, default 120.                                                       |
| Nn           | Play note n. n = 0 to 84, 0 = rest.                                                                         |

</div>

Unsupported QBASIC commands are

<div class="informaltable">

| Command | Description         |
|:--------|:--------------------|
| M       | Play mode           |
| .       | Changes note length |

</div>

For more information on the QBASIC PLAY command set, see
<https://en.wikibooks.org/wiki/QBasic/Appendix>

<span class="strong">**Example:**</span>

``` screen
    'Sample program to play a string
    'on PORTB bit 1.
    #chip 16F877A, 20
    #include <songplay.h>
    #define SoundOut PORTB.1


    play "C C# C C#"
```

<span class="strong">**For more help, see**</span>
<a href="sound_overview" class="link" title="Sound Overview">Sound Overview</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Play RTTTL</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_sound.html" title="Sound"><link rel="prev" href="_play.html" title="Play"><link rel="next" href="_timers.html" title="Timers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_play_rtttl"></a>Play RTTTL</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PlayRTTTL SoundPlayRTTTLDataString</pre><p>You must specify the following include and the port of the sound device.</p><pre class="screen">    #include &lt;songplay.h&gt;
    #define SOUNDOUT PORTN.N</pre><p><span class="strong"><strong>Command Availability::</strong></span>
Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span>
This command will play a sequence of notes in the Nokia RTTTL string format.</p><p>The SoundPlayRTTTLDataString is a string representing a musical note or notes to play where Notes are A to G. This format and information below is credited to WikiPedia, see here.
To be recognized by ringtone programs, an RTTTL/Nokring format ringtone must contain three specific elements: name, settings, and notes.   For example, here is the RTTTL ringtone for Haunted House:</p><p>HauntHouse: d=4,o=5,b=108: 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4, 1p, 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4</p><p>The three parts are separated by a colon.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Part 1: name of the ringtone (here: "HauntHouse"), a string of characters represents the name of the ringtone</li><li class="listitem">Part 2: settings (here: d=4,o=5,b=108), where "d=" is the default duration of a note. In this case, the "4" means that each note with no duration specifier (see below) is by default considered a quarter note. "8" would mean an eighth note, and so on. Accordingly, "o=" is the default octave. There are four octaves in the Nokring/RTTTL format. And "b=" is the tempo, in "beats per minute".</li><li class="listitem">Part 3: the notes. Each note is separated by a comma and includes, in sequence: a duration specifier, a standard music note, either a, b, c, d, e, f or g, and an octave specifier. If no duration or octave specifier are present, the default applies.</li></ul></div><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    #chip 16f877a
    #include &lt;songplay.h&gt;


    #define SOUNDOUT PORTA.4
    PlayRTTTL "HauntHouse: d=4,o=5,b=108: 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4, 1p, 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4"</pre><p><span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">		#chip 16f877a
    #include &lt;songplay.h&gt;

    'Defines
    #define SoundOut PORTC.0


    Dir SoundOut Out
    Dim SoundPlayRTTTLDataString as String


    wait 1 s
    SoundPlayRTTTLDataString = "Thegood,:d=4,o=6,b=63:32c,32f,32c,32f,c,8g_5,8a_5,f5,8p,32c,32f,32c,32f,c,8g_5,8a_5,d_"
    PlayRTTTL(SoundPlayRTTTLDataString)


    wait 1 s
    SoundPlayRTTTLDataString ="LedZeppel:d=4,o=6,b=80:8g,16p,8f_,16p,8f,16p,8e,16p,8d,8a5,8c,16p,8b5,16p,a_5,8a5,16f5,16e5,16d5,8p,16p,16a_5,16a_5,16a_5,8p,16p,16b5,16b5,16b5,8p,16p,16b5,16b5,16b5,8p,16p,16c,16c,16c,8p,16p,16c,16c,16c"
    PlayRTTTL(SoundPlayRTTTLDataString)


    Do Forever
    Loop
    End</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_sound_overview.html" title="Sound Overview">Sound Overview</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="play_rtttl"></span>Play RTTTL

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PlayRTTTL SoundPlayRTTTLDataString
```

You must specify the following include and the port of the sound device.

``` screen
    #include <songplay.h>
    #define SOUNDOUT PORTN.N
```

<span class="strong">**Command Availability::**</span> Available on all
microcontrollers.

<span class="strong">**Explanation:**</span> This command will play a
sequence of notes in the Nokia RTTTL string format.

The SoundPlayRTTTLDataString is a string representing a musical note or
notes to play where Notes are A to G. This format and information below
is credited to WikiPedia, see here. To be recognized by ringtone
programs, an RTTTL/Nokring format ringtone must contain three specific
elements: name, settings, and notes. For example, here is the RTTTL
ringtone for Haunted House:

HauntHouse: d=4,o=5,b=108: 2a4, 2e, 2d\#, 2b4, 2a4, 2c, 2d, 2a\#4, 2e.,
e, 1f4, 1a4, 1d\#, 2e., d, 2c., b4, 1a4, 1p, 2a4, 2e, 2d\#, 2b4, 2a4,
2c, 2d, 2a\#4, 2e., e, 1f4, 1a4, 1d\#, 2e., d, 2c., b4, 1a4

The three parts are separated by a colon.

<div class="itemizedlist">

-   Part 1: name of the ringtone (here: "HauntHouse"), a string of
    characters represents the name of the ringtone
-   Part 2: settings (here: d=4,o=5,b=108), where "d=" is the default
    duration of a note. In this case, the "4" means that each note with
    no duration specifier (see below) is by default considered a quarter
    note. "8" would mean an eighth note, and so on. Accordingly, "o=" is
    the default octave. There are four octaves in the Nokring/RTTTL
    format. And "b=" is the tempo, in "beats per minute".
-   Part 3: the notes. Each note is separated by a comma and includes,
    in sequence: a duration specifier, a standard music note, either a,
    b, c, d, e, f or g, and an octave specifier. If no duration or
    octave specifier are present, the default applies.

</div>

<span class="strong">**Example 1:**</span>

``` screen
    #chip 16f877a
    #include <songplay.h>


    #define SOUNDOUT PORTA.4
    PlayRTTTL "HauntHouse: d=4,o=5,b=108: 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4, 1p, 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4"
```

<span class="strong">**Example 2:**</span>

``` screen
     #chip 16f877a
    #include <songplay.h>

    'Defines
    #define SoundOut PORTC.0


    Dir SoundOut Out
    Dim SoundPlayRTTTLDataString as String


    wait 1 s
    SoundPlayRTTTLDataString = "Thegood,:d=4,o=6,b=63:32c,32f,32c,32f,c,8g_5,8a_5,f5,8p,32c,32f,32c,32f,c,8g_5,8a_5,d_"
    PlayRTTTL(SoundPlayRTTTLDataString)


    wait 1 s
    SoundPlayRTTTLDataString ="LedZeppel:d=4,o=6,b=80:8g,16p,8f_,16p,8f,16p,8e,16p,8d,8a5,8c,16p,8b5,16p,a_5,8a5,16f5,16e5,16d5,8p,16p,16a_5,16a_5,16a_5,8p,16p,16b5,16b5,16b5,8p,16p,16b5,16b5,16b5,8p,16p,16c,16c,16c,8p,16p,16c,16c,16c"
    PlayRTTTL(SoundPlayRTTTLDataString)


    Do Forever
    Loop
    End
```

<span class="strong">**For more help, see**</span>
<a href="sound_overview" class="link" title="Sound Overview">Sound Overview</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Poke</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_miscellaneous_commands.html" title="Miscellaneous Commands"><link rel="prev" href="_peek.html" title="Peek"><link rel="next" href="_weak_pullups.html" title="Weak Pullups"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_poke"></a>Poke</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Poke(<span class="emphasis"><em>location</em></span>, <span class="emphasis"><em>value</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Poke</code> command is used to write information to the on-chip RAM of the microcontroller.</p><p><code class="literal"><span class="emphasis"><em>location</em></span></code> is a word variable that gives the address to write. The exact range of valid values varies from chip to chip.
<code class="literal"><span class="emphasis"><em>value</em></span></code> is the data to write to the location.</p><p>This command should not normally be used, as it will make the porting of code to another chip very difficult.</p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    'This program will set all of the PORTB pins high
    POKE (6, 255)</pre><p><span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    ;Chip Settings
    #chip 16F88

    Dir PORTB out

    Do Forever
        FlashPin @PORTB, 8
        Wait 1 s
    Loop

    Sub FlashPin (In DestVar As word, In DestBit)
        Poke DestVar, Peek(DestVar) Or DestBit
        Wait 1 s
        Poke DestVar, Peek(DestVar) And Not DestBit
    End Sub</pre><p>Using @ before the name of a variable (including a special function register) will give you the address of that variable, which can then be stored in a word variable and used by <code class="literal">Peek</code> and <code class="literal">Poke</code> to indirectly access the location.</p><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_peek.html" title="Peek">Peek</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="poke"></span>Poke

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Poke(location, value)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Poke` command is used to write information to the on-chip RAM of
the microcontroller.

`location` is a word variable that gives the address to write. The exact
range of valid values varies from chip to chip. `value` is the data to
write to the location.

This command should not normally be used, as it will make the porting of
code to another chip very difficult.

<span class="strong">**Example 1:**</span>

``` screen
    'This program will set all of the PORTB pins high
    POKE (6, 255)
```

<span class="strong">**Example 2:**</span>

``` screen
    ;Chip Settings
    #chip 16F88

    Dir PORTB out

    Do Forever
        FlashPin @PORTB, 8
        Wait 1 s
    Loop

    Sub FlashPin (In DestVar As word, In DestBit)
        Poke DestVar, Peek(DestVar) Or DestBit
        Wait 1 s
        Poke DestVar, Peek(DestVar) And Not DestBit
    End Sub
```

Using @ before the name of a variable (including a special function
register) will give you the address of that variable, which can then be
stored in a word variable and used by `Peek` and `Poke` to indirectly
access the location.

<span class="strong">**See Also**</span>
<a href="peek" class="link" title="Peek">Peek</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Pot</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_miscellaneous_commands.html" title="Miscellaneous Commands"><link rel="prev" href="_getuserid.html" title="GetUserID"><link rel="next" href="_pulseout.html" title="PulseOut"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_pot"></a>Pot</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Pot <span class="emphasis"><em>pin, output</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">Pot</code> makes it possible to measure an analog resistance with a digital port, with the addition of a small capacitor. This is the required circuit:</p><p><span class="inlinemediaobject"><img src="./images/potb1.JPG" alt="graphic"></span></p><p>The command works by using the microcontroller pin to discharge the capacitor, then measuring the time taken for the capacitor to charge again through the resistor.</p><p>The value for the capacitor must be adjusted depending on the size of the variable resistor. The charging time needs to be approximately 2.5 ms when the resistor is at its maximum value. For a typical 50 k potentiometer or LDR, a 50 nf capacitor is required.</p><p>This command should be used carefully. Each time it is inserted, 20 words of program memory are used on the chip, which as a rough guide is more than 15 times the size of the Set command.</p><p><code class="literal"><span class="emphasis"><em>pin</em></span></code> is the port connected to the circuit. The direction of the pin will be dealt with by the <code class="literal">Pot</code> command.</p><p><code class="literal"><span class="emphasis"><em>output</em></span></code> is the name of the variable that will receive the value.</p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    'This program will beep whenever a shadow is detected
    'A potentiometer is used to adjust the threshold

    #chip 16F628A, 4

    #define ADJUST PORTB.0
    #define LDR PORTB.1
    #define SoundOut PORTB.2

    Dir SoundOut Out

    Do
        Pot ADJUST, Threshold
        Pot LDR, LightLevel
        If LightLevel &gt; Threshold Then
            Tone 1000, 100
        End If
    Loop</pre><p><span class="strong"><strong>Example 2:</strong></span></p><p>This program is an implementation of the capacitor and resistor principle using the chips internal capacitor and the internal pullup resistor.</p><p>The will test the state of the GPIO.3 port by using these internal components, and, after the charge state has been complete the LED PWM will represent the detected value of signal on the GPIO.3 port.</p><p>It should be note that GCBASIC will set the DIRection of GPIO.2 and GPIO.3 automatically.  And, this solution is specific to the 12F509 and therefore the 12F509 register called <code class="literal">NOT_GPPU</code> may be different on another chip.</p><pre class="screen">    #chip 12F509
    #option Explicit

      ;Defines (Constants)
      #define PWM_Out1 GPIO.2

      ;Variables
      Dim TimeCount As byte
      Dim OPTION_REG as byte

      Do Forever

          NOT_GPPU = Off
          Wait 1 ms
          NOT_GPPU = On
          TimeCount = 0

          'Do while held high by the internal capacitance
          Do While GPIO.3 = 1

            TimeCount = TimeCount + 1
            If TimeCount = 255 Then
                Exit Do
            End If

          Loop

          PWMout 1, TimeCount, 5

      Loop</pre><p><span class="strong"><strong>See also</strong></span>  <a class="link" href="http://ladyada.net/library/rccalc.html" target="_top">ladyada.net/library/rccalc.html</a> or <a class="link" href="http://web.archive.org/web/20100818230450/http://www.cvs1.uklinux.net/cgi-bin/calculators/time_const.cgi" target="_top">cvs1.uklinux.net/cgi-bin/calculators/time_const.cgi</a>
for calculating capacitor value. These sites are not associated with GCBASIC.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="pot"></span>Pot

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Pot pin, output
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

`Pot` makes it possible to measure an analog resistance with a digital
port, with the addition of a small capacitor. This is the required
circuit:

<span class="inlinemediaobject">![graphic](./images/potb1.JPG)</span>

The command works by using the microcontroller pin to discharge the
capacitor, then measuring the time taken for the capacitor to charge
again through the resistor.

The value for the capacitor must be adjusted depending on the size of
the variable resistor. The charging time needs to be approximately 2.5
ms when the resistor is at its maximum value. For a typical 50 k
potentiometer or LDR, a 50 nf capacitor is required.

This command should be used carefully. Each time it is inserted, 20
words of program memory are used on the chip, which as a rough guide is
more than 15 times the size of the Set command.

`pin` is the port connected to the circuit. The direction of the pin
will be dealt with by the `Pot` command.

`output` is the name of the variable that will receive the value.

<span class="strong">**Example 1:**</span>

``` screen
    'This program will beep whenever a shadow is detected
    'A potentiometer is used to adjust the threshold

    #chip 16F628A, 4

    #define ADJUST PORTB.0
    #define LDR PORTB.1
    #define SoundOut PORTB.2

    Dir SoundOut Out

    Do
        Pot ADJUST, Threshold
        Pot LDR, LightLevel
        If LightLevel > Threshold Then
            Tone 1000, 100
        End If
    Loop
```

<span class="strong">**Example 2:**</span>

This program is an implementation of the capacitor and resistor
principle using the chips internal capacitor and the internal pullup
resistor.

The will test the state of the GPIO.3 port by using these internal
components, and, after the charge state has been complete the LED PWM
will represent the detected value of signal on the GPIO.3 port.

It should be note that GCBASIC will set the DIRection of GPIO.2 and
GPIO.3 automatically. And, this solution is specific to the 12F509 and
therefore the 12F509 register called `NOT_GPPU` may be different on
another chip.

``` screen
    #chip 12F509
    #option Explicit

      ;Defines (Constants)
      #define PWM_Out1 GPIO.2

      ;Variables
      Dim TimeCount As byte
      Dim OPTION_REG as byte

      Do Forever

          NOT_GPPU = Off
          Wait 1 ms
          NOT_GPPU = On
          TimeCount = 0

          'Do while held high by the internal capacitance
          Do While GPIO.3 = 1

            TimeCount = TimeCount + 1
            If TimeCount = 255 Then
                Exit Do
            End If

          Loop

          PWMout 1, TimeCount, 5

      Loop
```

<span class="strong">**See also**</span>
<a href="http://ladyada.net/library/rccalc" class="link">ladyada.net/library/rccalc</a>
or
<a href="http://web.archive.org/web/20100818230450/http://www.cvs1.uklinux.net/cgi-bin/calculators/time_const.cgi" class="link">cvs1.uklinux.net/cgi-bin/calculators/time_const.cgi</a>
for calculating capacitor value. These sites are not associated with
GCBASIC.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Power</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_maths.html" title="Maths"><link rel="prev" href="_log10.html" title="Log10"><link rel="next" href="_scale.html" title="Scale"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_power"></a>Power</h4></div></div></div><p><span class="strong"><strong>Syntax</strong></span>:</p><pre class="screen">    power( base, exponent )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This function raises a base to an exponent, i.e, <code class="literal">power(base,exponent)</code>. Calculation powers will become large, in terms of long numbers, you must ensure the program manage numbers remain within range of the defined variables.</p><p>The <code class="literal">base</code> and <code class="literal">exponent</code> are Byte sized numbers in this method.<br>
The returned result is a Long.<br>
Non-negative numbers are assumed throughout.</p><p><span class="strong"><strong>Note:</strong></span>
0 raised to 0 is meaningless and should be avoided, but, any other non-zero base raised to 0 is handled correctly.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    ;Thomas Henry -- 5/2/2014

    ;----- Configuration

    #chip 16F88, 8              ;PIC16F88 running at 8 MHz
    #config mclr=off            ;reset handled internally

    #include &lt;maths.h&gt;          ;required maths.h

    ;----- Constants

    #define LCD_IO 4            ;4-bit mode
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PortB.2      ;pin 8 is LCD Register Select
    #define LCD_Enable PortB.3  ;pin 9 is LCD Enable
    #define LCD_DB4 PortB.4     ;DB4 on pin 10
    #define LCD_DB5 PortB.5     ;DB5 on pin 11
    #define LCD_DB6 PortB.6     ;DB6 on pin 12
    #define LCD_DB7 PortB.7     ;DB7 on pin 13
    #define LCD_NO_RW 1         ;Ground the RW line on LCD

    ;----- Variables

    dim i, j as byte

    ;----- Program

    dir PortB out               ;all outputs to the LCD
    for i = 1 to 10             ;do all the way from
      for j = 0 to 9            ;1^0 on up to 10^9
        cls
        print i
        print "^"
        print j
        print "="
        locate 1,0
        print power(i,j)        ;here's the invocation
        wait 1 S
      next j
    next i</pre><p><span class="strong"><strong>Supported in &lt;MATHS.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="power"></span>Power

</div>

</div>

</div>

<span class="strong">**Syntax**</span>:

``` screen
    power( base, exponent )
```

<span class="strong">**Explanation:**</span>

This function raises a base to an exponent, i.e, `power(base,exponent)`.
Calculation powers will become large, in terms of long numbers, you must
ensure the program manage numbers remain within range of the defined
variables.

The `base` and `exponent` are Byte sized numbers in this method.  
The returned result is a Long.  
Non-negative numbers are assumed throughout.

<span class="strong">**Note:**</span> 0 raised to 0 is meaningless and
should be avoided, but, any other non-zero base raised to 0 is handled
correctly.

<span class="strong">**Example:**</span>

``` screen
    ;Thomas Henry -- 5/2/2014

    ;----- Configuration

    #chip 16F88, 8              ;PIC16F88 running at 8 MHz
    #config mclr=off            ;reset handled internally

    #include <maths.h>          ;required maths.h

    ;----- Constants

    #define LCD_IO 4            ;4-bit mode
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PortB.2      ;pin 8 is LCD Register Select
    #define LCD_Enable PortB.3  ;pin 9 is LCD Enable
    #define LCD_DB4 PortB.4     ;DB4 on pin 10
    #define LCD_DB5 PortB.5     ;DB5 on pin 11
    #define LCD_DB6 PortB.6     ;DB6 on pin 12
    #define LCD_DB7 PortB.7     ;DB7 on pin 13
    #define LCD_NO_RW 1         ;Ground the RW line on LCD

    ;----- Variables

    dim i, j as byte

    ;----- Program

    dir PortB out               ;all outputs to the LCD
    for i = 1 to 10             ;do all the way from
      for j = 0 to 9            ;1^0 on up to 10^9
        cls
        print i
        print "^"
        print j
        print "="
        locate 1,0
        print power(i,j)        ;here's the invocation
        wait 1 S
      next j
    next i
```

<span class="strong">**Supported in &lt;MATHS.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Print</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_locate.html" title="Locate"><link rel="next" href="_put.html" title="Put"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_print"></a>Print</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Print <span class="emphasis"><em>string</em></span>
    Print <span class="emphasis"><em>byte</em></span>
    Print <span class="emphasis"><em>word</em></span>
    Print <span class="emphasis"><em>long</em></span>
    Print <span class="emphasis"><em>integer</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The Print command will show the contents of a variable on the LCD. It
can display string, word, byte, long or integer variables.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'A Light Meter program.

    'General hardware configuration
    #chip 16F877A, 20
    #define LightSensor AN0

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    CLS
    Print "Light Meter"
    Locate 1,2
    Print "A GCBASIC Demo"
    Wait 2 s

    Do
        CLS
        Print "Light Level: "
        Print ReadAD(LightSensor)
        Wait 250 ms
    Loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_lcd_overview.html" title="LCD Overview">LCD Overview</a></p><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="print"></span>Print

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Print string
    Print byte
    Print word
    Print long
    Print integer
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The Print command will show the contents of a variable on the LCD. It
can display string, word, byte, long or integer variables.

<span class="strong">**Example:**</span>

``` screen
    'A Light Meter program.

    'General hardware configuration
    #chip 16F877A, 20
    #define LightSensor AN0

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    CLS
    Print "Light Meter"
    Locate 1,2
    Print "A GCBASIC Demo"
    Wait 2 s

    Do
        CLS
        Print "Light Level: "
        Print ReadAD(LightSensor)
        Wait 250 ms
    Loop
```

<span class="strong">**For more help, see**</span>
<a href="lcd_overview" class="link" title="LCD Overview">LCD Overview</a>

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PROGMEM ( MCU Configuration )</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_memory.html" title="Memory"><link rel="prev" href="_programwrite.html" title="ProgramWrite"><link rel="next" href="_deviceconfigurationread.html" title="DeviceConfigurationRead"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_progmem_mcu_configuration"></a>PROGMEM ( MCU Configuration )</h4></div></div></div><p>This is the PROGMEM ( MCU Configuration ) section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="progmem_mcu_configuration"></span>PROGMEM ( MCU Configuration )

</div>

</div>

</div>

This is the PROGMEM ( MCU Configuration ) section of the Help file.
Please refer the sub-sections for details using the contents/folder
view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PROGMEM ( PFM )</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_memory.html" title="Memory"><link rel="prev" href="_heferaseblock.html" title="HEFEraseBlock"><link rel="next" href="_pfmread.html" title="PFMRead"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_progmem_pfm"></a>PROGMEM ( PFM )</h4></div></div></div><p>This is the PROGMEM ( PFM ) section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="progmem_pfm"></span>PROGMEM ( PFM )

</div>

</div>

</div>

This is the PROGMEM ( PFM ) section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ProgramErase</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_progmem_pfm.html" title="PROGMEM ( PFM )"><link rel="prev" href="_pfmwrite.html" title="PFMWrite"><link rel="next" href="_programread.html" title="ProgramRead"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_programerase"></a>ProgramErase</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ProgramErase (<span class="emphasis"><em>location</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip PIC microcontrollers with self write capability. Not available on
Atmel AVR at present.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">ProgramErase</code> erases information from the program memory on chips that
support this feature. The largest value possible for <code class="literal"><span class="emphasis"><em>location</em></span></code> depends
on the amount of program memory on the Microchip PIC microcontroller, which is given on the
datasheet.</p><p>This command must be called before writing to a block of memory. It is
slow in comparison to other GCBASIC commands. Note that it erases memory
in 32-byte blocks - see the relevant Microchip PIC microcontroller datasheet for more information.</p><p>This is an advanced command which should only be used by advanced
developers. Care must be taken with this command, as it can easily erase
the program that is running on the microcontroller.</p><p><span class="strong"><strong>For more help, see <a class="link" href="_programread.html" title="ProgramRead">ProgramRead</a></strong></span> and <span class="strong"><strong><a class="link" href="_programwrite.html" title="ProgramWrite">ProgramWrite</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="programerase"></span>ProgramErase

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ProgramErase (location)
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip PIC microcontrollers with self write
capability. Not available on Atmel AVR at present.

<span class="strong">**Explanation:**</span>

`ProgramErase` erases information from the program memory on chips that
support this feature. The largest value possible for `location` depends
on the amount of program memory on the Microchip PIC microcontroller,
which is given on the datasheet.

This command must be called before writing to a block of memory. It is
slow in comparison to other GCBASIC commands. Note that it erases memory
in 32-byte blocks - see the relevant Microchip PIC microcontroller
datasheet for more information.

This is an advanced command which should only be used by advanced
developers. Care must be taken with this command, as it can easily erase
the program that is running on the microcontroller.

<span class="strong">**For more help, see
<a href="programread" class="link" title="ProgramRead">ProgramRead</a>**</span>
and <span
class="strong">**<a href="programwrite" class="link" title="ProgramWrite">ProgramWrite</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ProgramRead</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_progmem_pfm.html" title="PROGMEM ( PFM )"><link rel="prev" href="_programerase.html" title="ProgramErase"><link rel="next" href="_programwrite.html" title="ProgramWrite"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_programread"></a>ProgramRead</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ProgramRead (<span class="emphasis"><em>location, store</em></span>)

    or for the 18FxxQ41 family of chips use:
    PFMRead (<span class="emphasis"><em>location, store</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip PIC microcontrollers with self write capability. Not available on
Atmel AVR at present.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">ProgramRead</code> reads information from the program memory on chips that
support this feature. <code class="literal"><span class="emphasis"><em>location</em></span></code> and <code class="literal"><span class="emphasis"><em>store</em></span></code> are both word variables,
meaning that they can store values over 255.</p><p>The largest value possible for <code class="literal"><span class="emphasis"><em>location</em></span></code> depends on the amount of
program memory on the Microchip PIC microcontroller, which is given on the datasheet. <code class="literal"><span class="emphasis"><em>store</em></span></code> is
14 bits wide, and thus can store values up to <code class="literal">16383</code>.</p><p>This is an advanced command which should only be used by advanced
developers.</p><p><span class="strong"><strong>For more help, see <a class="link" href="_programerase.html" title="ProgramErase">ProgramErase</a></strong></span> and <span class="strong"><strong><a class="link" href="_programwrite.html" title="ProgramWrite">ProgramWrite</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="programread"></span>ProgramRead

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ProgramRead (location, store)

    or for the 18FxxQ41 family of chips use:
    PFMRead (location, store)
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip PIC microcontrollers with self write
capability. Not available on Atmel AVR at present.

<span class="strong">**Explanation:**</span>

`ProgramRead` reads information from the program memory on chips that
support this feature. `location` and `store` are both word variables,
meaning that they can store values over 255.

The largest value possible for `location` depends on the amount of
program memory on the Microchip PIC microcontroller, which is given on
the datasheet. `store` is 14 bits wide, and thus can store values up to
`16383`.

This is an advanced command which should only be used by advanced
developers.

<span class="strong">**For more help, see
<a href="programerase" class="link" title="ProgramErase">ProgramErase</a>**</span>
and <span
class="strong">**<a href="programwrite" class="link" title="ProgramWrite">ProgramWrite</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ProgramWrite</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_progmem_pfm.html" title="PROGMEM ( PFM )"><link rel="prev" href="_programread.html" title="ProgramRead"><link rel="next" href="_progmem_mcu_configuration.html" title="PROGMEM ( MCU Configuration )"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_programwrite"></a>ProgramWrite</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ProgramWrite (<span class="emphasis"><em>location</em></span>, <span class="emphasis"><em>value</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip PIC microcontrollers with self write capability. Not available on
Atmel AVR at present.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">ProgramWrite</code> writes information to the program memory on chips that
support this feature. <code class="literal"><span class="emphasis"><em>location</em></span></code> and <code class="literal"><span class="emphasis"><em>value</em></span></code> are both word variables.</p><p>The largest value possible for <code class="literal"><span class="emphasis"><em>location</em></span></code> depends on the amount of
program memory on the microcontroller , which is given on the datasheet. <code class="literal"><span class="emphasis"><em>value</em></span></code> is
14 bits wide, and thus can store values up to 16383.</p><p>This is an advanced command which should only be used by advanced
developers. ProgramErase must be used to clear a block of memory BEFORE
<code class="literal">ProgramWrite</code> is called.</p><p><span class="strong"><strong>Example:</strong></span></p><p><span class="strong"><strong>For more help, see <a class="link" href="_programerase.html" title="ProgramErase">ProgramErase</a></strong></span> and <span class="strong"><strong><a class="link" href="_programread.html" title="ProgramRead">ProgramRead</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="programwrite"></span>ProgramWrite

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ProgramWrite (location, value)
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip PIC microcontrollers with self write
capability. Not available on Atmel AVR at present.

<span class="strong">**Explanation:**</span>

`ProgramWrite` writes information to the program memory on chips that
support this feature. `location` and `value` are both word variables.

The largest value possible for `location` depends on the amount of
program memory on the microcontroller , which is given on the datasheet.
`value` is 14 bits wide, and thus can store values up to 16383.

This is an advanced command which should only be used by advanced
developers. ProgramErase must be used to clear a block of memory BEFORE
`ProgramWrite` is called.

<span class="strong">**Example:**</span>

<span class="strong">**For more help, see
<a href="programerase" class="link" title="ProgramErase">ProgramErase</a>**</span>
and <span
class="strong">**<a href="programread" class="link" title="ProgramRead">ProgramRead</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PS2ReadByte</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_ps_2.html" title="PS/2"><link rel="prev" href="_ps2setkbleds.html" title="PS2SetKBLeds"><link rel="next" href="_ps2writebyte.html" title="PS2WriteByte"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_ps2readbyte"></a>PS2ReadByte</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    output = PS2ReadByte</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">PS2ReadByte</code> will read a byte from the PS/2 bus. It will return the byte,
or 0 if no data was returned by the PS/2 device.</p><p>The PS/2 bus will normally be held in the inhibit state. <code class="literal">PS2ReadByte</code>
will uninhibit the bus for 25 ms. If a response is received, it will be
read. Then, the bus will be placed back in the inhibit state.</p><p><span class="strong"><strong>Example:</strong></span></p><p>For an example, please refer to the <code class="literal">InKey</code> function.
<a class="link" href="_inkey.html" title="InKey">PS2 Inkey</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="ps2readbyte"></span>PS2ReadByte

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    output = PS2ReadByte
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

`PS2ReadByte` will read a byte from the PS/2 bus. It will return the
byte, or 0 if no data was returned by the PS/2 device.

The PS/2 bus will normally be held in the inhibit state. `PS2ReadByte`
will uninhibit the bus for 25 ms. If a response is received, it will be
read. Then, the bus will be placed back in the inhibit state.

<span class="strong">**Example:**</span>

For an example, please refer to the `InKey` function.
<a href="inkey" class="link" title="InKey">PS2 Inkey</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PS2SetKBLeds</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_ps_2.html" title="PS/2"><link rel="prev" href="_inkey.html" title="InKey"><link rel="next" href="_ps2readbyte.html" title="PS2ReadByte"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_ps2setkbleds"></a>PS2SetKBLeds</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PS2SetKBLeds (<span class="emphasis"><em>LedStatus</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This routine will turn the status LEDs on a keyboard on or off.
<code class="literal"><span class="emphasis"><em>LedStatus</em></span></code> is a variable, of which the lower 3 bits correspond to the 3
LEDs. Bit 0 is for Scroll Lock, bit 1 controls Num Lock and bit 2
controls Caps Lock.</p><p>Note that this routine does not alter the status variables within the
INKEY routine - so even if the Caps Lock LED is turned on, Caps Lock
will stay off.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">	'A spinning LED program for a keyboard
	'Will flash Num Lock, then Caps Lock, then Scroll Lock.

	'Hardware settings
	#chip 16F88, 8

	#define PS2Clock PORTB.2
	#define PS2Data PORTB.3
	#define PS2_DELAY 10 ms

	'Main Loop
	Do

		'Turn on only Num Lock (bit 1)
		PS2SetKBLeds b'00000010'
		Wait 250 ms

		'Turn on only Caps Lock (bit 2)
		PS2SetKBLeds b'00000100'
		Wait 250 ms

		'Turn on only Scroll Lock (bit 0)
		PS2SetKBLeds b'00000001'
		Wait 250 ms

	Loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="ps2setkbleds"></span>PS2SetKBLeds

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PS2SetKBLeds (LedStatus)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This routine will turn the status LEDs on a keyboard on or off.
`LedStatus` is a variable, of which the lower 3 bits correspond to the 3
LEDs. Bit 0 is for Scroll Lock, bit 1 controls Num Lock and bit 2
controls Caps Lock.

Note that this routine does not alter the status variables within the
INKEY routine - so even if the Caps Lock LED is turned on, Caps Lock
will stay off.

<span class="strong">**Example:**</span>

``` screen
  'A spinning LED program for a keyboard
    'Will flash Num Lock, then Caps Lock, then Scroll Lock.

    'Hardware settings
    #chip 16F88, 8

    #define PS2Clock PORTB.2
    #define PS2Data PORTB.3
    #define PS2_DELAY 10 ms

    'Main Loop
    Do

        'Turn on only Num Lock (bit 1)
        PS2SetKBLeds b'00000010'
        Wait 250 ms

        'Turn on only Caps Lock (bit 2)
        PS2SetKBLeds b'00000100'
        Wait 250 ms

        'Turn on only Scroll Lock (bit 0)
        PS2SetKBLeds b'00000001'
        Wait 250 ms

    Loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PS2WriteByte</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_ps_2.html" title="PS/2"><link rel="prev" href="_ps2readbyte.html" title="PS2ReadByte"><link rel="next" href="_spi.html" title="SPI"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_ps2writebyte"></a>PS2WriteByte</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PS2WriteByte <span class="emphasis"><em>user_data</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">PS2WriteByte</code> will send a byte to a PS/2 device. Once the byte has been
written, the PS/2 bus will be placed in the inhibit state.</p><p><span class="strong"><strong>Example:</strong></span></p><p>For an example, please refer to the <code class="literal">PS2SetKBLeds</code> function.<br>
<a class="link" href="_ps2setkbleds.html" title="PS2SetKBLeds">PS2 Set Keyboard Leds</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="ps2writebyte"></span>PS2WriteByte

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PS2WriteByte user_data
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

`PS2WriteByte` will send a byte to a PS/2 device. Once the byte has been
written, the PS/2 bus will be placed in the inhibit state.

<span class="strong">**Example:**</span>

For an example, please refer to the `PS2SetKBLeds` function.  
<a href="ps2setkbleds" class="link" title="PS2SetKBLeds">PS2 Set Keyboard Leds</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Pset</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_parabola.html" title="Parabola"><link rel="next" href="_triangle.html" title="Triangle"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_pset"></a>Pset</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PSet(XPosition, YPosition, GLCDState)</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Sets or Clears a Pixel at the specified XPosition, YPosition.  Use
GLCDState set to 1 to set the pixel and a 0 clears the pixel.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="pset"></span>Pset

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PSet(XPosition, YPosition, GLCDState)
```

<span class="strong">**Explanation:**</span>

Sets or Clears a Pixel at the specified XPosition, YPosition. Use
GLCDState set to 1 to set the pixel and a 0 clears the pixel.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PS/2</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_hserprintcrlf.html" title="HserPrintCRLF"><link rel="next" href="_ps_2_overview.html" title="PS/2 Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_ps_2"></a>PS/2</h3></div></div></div><p>This is the PS/2 section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="ps_2"></span>PS/2

</div>

</div>

</div>

This is the PS/2 section of the Help file. Please refer the sub-sections
for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PS/2 Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_ps_2.html" title="PS/2"><link rel="prev" href="_ps_2.html" title="PS/2"><link rel="next" href="_inkey.html" title="InKey"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_ps_2_overview"></a>PS/2 Overview</h4></div></div></div><p><span class="strong"><strong>PS2 Overview</strong></span></p><p>These routines make it easier to communicate with a PS/2 device,
particularly an external keyboard.</p><p><span class="strong"><strong>Relevant Constants</strong></span></p><p>These constants affect the operation of the PS/2 routines:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">PS2Data</code></p></td><td align="left" valign="top"><p>Pin connected to PS/2 data line</p></td><td align="left" valign="top"><p>Must be specified</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PS2Clock</code></p></td><td align="left" valign="top"><p>Pin connected to PS/2 clock line.</p></td><td align="left" valign="top"><p>Must be specified</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PS2_DELAY</code></p></td><td align="left" valign="top"><p>This constant can be set to a delay, such as 10 ms. If set, a delay will
be added at the end of every byte sent or received.</p></td><td align="left" valign="top"><p>Not set</p></td></tr></tbody></table></div><p><span class="strong"><strong>Connections between the Keyboard and the Microcontroller</strong></span>
The following diagram show a typical connection between the keyboard and the microcontroller.  The value of R1 and R2 is typically 4.7k for a 5v system.</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/overview_ps21.PNG" align="middle" alt="[graphic"></div></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="ps_2_overview"></span>PS/2 Overview

</div>

</div>

</div>

<span class="strong">**PS2 Overview**</span>

These routines make it easier to communicate with a PS/2 device,
particularly an external keyboard.

<span class="strong">**Relevant Constants**</span>

These constants affect the operation of the PS/2 routines:

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span>                                                                                     | <span class="strong">**Default Value**</span> |
|:----------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------|
| `PS2Data`                                     | Pin connected to PS/2 data line                                                                                              | Must be specified                             |
| `PS2Clock`                                    | Pin connected to PS/2 clock line.                                                                                            | Must be specified                             |
| `PS2_DELAY`                                   | This constant can be set to a delay, such as 10 ms. If set, a delay will be added at the end of every byte sent or received. | Not set                                       |

</div>

<span class="strong">**Connections between the Keyboard and the
Microcontroller**</span> The following diagram show a typical connection
between the keyboard and the microcontroller. The value of R1 and R2 is
typically 4.7k for a 5v system.

<div class="informalfigure">

<div class="mediaobject" align="center">

![\[graphic](./images/overview_ps21.PNG)

</div>

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PulseIn</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_miscellaneous_commands.html" title="Miscellaneous Commands"><link rel="prev" href="_pulseoutinv.html" title="PulseOutInv"><link rel="next" href="_pulseininv.html" title="PulseInInv"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_pulsein"></a>PulseIn</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PulseIn <span class="emphasis"><em>pin</em></span>, <span class="emphasis"><em>user_variable</em></span>, <span class="emphasis"><em>time units</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">PulseIn</code> command will monitor the specified pin when the pin is high, and then measure the high time. It will store the time in the user variable.
The user variable must be a WORD if returned units are expected to be &gt; 255  (Example: Pulse is 500 ms)</p><p>PulseIn is not recommended for accurate measurement of microsecond pulses</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #chip 12F629, 4

    Dir GPIO.0 In
    Dim TimeResult as WORD

    Do while GPIO.0 = Off        'Wait for next positive edge to start measuring
    Loop

    Pulsein GPIO.0, TimeResult, ms</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="pulsein"></span>PulseIn

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PulseIn pin, user_variable, time units
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `PulseIn` command will monitor the specified pin when the pin is
high, and then measure the high time. It will store the time in the user
variable. The user variable must be a WORD if returned units are
expected to be &gt; 255 (Example: Pulse is 500 ms)

PulseIn is not recommended for accurate measurement of microsecond
pulses

<span class="strong">**Example:**</span>

``` screen
    #chip 12F629, 4

    Dir GPIO.0 In
    Dim TimeResult as WORD

    Do while GPIO.0 = Off        'Wait for next positive edge to start measuring
    Loop

    Pulsein GPIO.0, TimeResult, ms
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PulseInInv</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_miscellaneous_commands.html" title="Miscellaneous Commands"><link rel="prev" href="_pulsein.html" title="PulseIn"><link rel="next" href="_peek.html" title="Peek"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_pulseininv"></a>PulseInInv</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PulseInInv <span class="emphasis"><em>pin</em></span>, <span class="emphasis"><em>user_variable</em></span>, <span class="emphasis"><em>time units</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">PulseIn</code> command will monitor the specified pin when the pin is low, and then measure the low time. It will store the time in the user variable.
The user variable must be a WORD if returned units are expected to be &gt; 255  (Example: Pulse is 500 ms)</p><p>PulseInInv is not recommended for accurate measurement of microsecond pulses.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #chip 12F629, 4

    Dir GPIO.0 In
    Dim TimeResult as WORD

    Do while GPIO.0 = On        'Wait for next negative edge to start measuring
    Loop

    PulseinInv GPIO.0, TimeResult, ms</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="pulseininv"></span>PulseInInv

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PulseInInv pin, user_variable, time units
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `PulseIn` command will monitor the specified pin when the pin is
low, and then measure the low time. It will store the time in the user
variable. The user variable must be a WORD if returned units are
expected to be &gt; 255 (Example: Pulse is 500 ms)

PulseInInv is not recommended for accurate measurement of microsecond
pulses.

<span class="strong">**Example:**</span>

``` screen
    #chip 12F629, 4

    Dir GPIO.0 In
    Dim TimeResult as WORD

    Do while GPIO.0 = On        'Wait for next negative edge to start measuring
    Loop

    PulseinInv GPIO.0, TimeResult, ms
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PulseOut</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_miscellaneous_commands.html" title="Miscellaneous Commands"><link rel="prev" href="_pot.html" title="Pot"><link rel="next" href="_pulseoutinv.html" title="PulseOutInv"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_pulseout"></a>PulseOut</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PulseOut <span class="emphasis"><em>pin</em></span>, <span class="emphasis"><em>time units</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">PulseOut</code> command will set the specified pin high, wait for the specified amount of time, and then set the pin low again. The pin is specified in the same way as it is for the Set command, and the time is the same as for the <code class="literal">Wait</code> command.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program flashes an LED on GPIO.0 using PulseOut
    #chip 12F629, 4

    'The DIRection of the port is set to show the command.  It is not required to set the DIRection when using the PulseOut command.
    Dir GPIO.0 Out
    Do
        PulseOut GPIO.0, 1 sec 'Turn LED on for 1 sec
        Wait 1 sec             'Wait 1 sec with LED off
    Loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="pulseout"></span>PulseOut

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PulseOut pin, time units
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `PulseOut` command will set the specified pin high, wait for the
specified amount of time, and then set the pin low again. The pin is
specified in the same way as it is for the Set command, and the time is
the same as for the `Wait` command.

<span class="strong">**Example:**</span>

``` screen
    'This program flashes an LED on GPIO.0 using PulseOut
    #chip 12F629, 4

    'The DIRection of the port is set to show the command.  It is not required to set the DIRection when using the PulseOut command.
    Dir GPIO.0 Out
    Do
        PulseOut GPIO.0, 1 sec 'Turn LED on for 1 sec
        Wait 1 sec             'Wait 1 sec with LED off
    Loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PulseOutInv</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_miscellaneous_commands.html" title="Miscellaneous Commands"><link rel="prev" href="_pulseout.html" title="PulseOut"><link rel="next" href="_pulsein.html" title="PulseIn"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_pulseoutinv"></a>PulseOutInv</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PulseOutInv <span class="emphasis"><em>pin,</em></span> <span class="emphasis"><em>time units</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">PulseOutInv</code> command will set the specified pin low, wait for the specified amount of time, and then set the pin high. The pin is specified in the same way as it is for the <code class="literal">Set</code> command, and the time is the same as for the <code class="literal">Wait</code> command.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program flashes an LED on GPIO.0 using PulseOutInv
    #chip 12F629, 4

    Dir GPIO.0 Out
    Do
        PulseOutInv GPIO.0, 1 sec     'Turn LED off for 1 sec
        Wait 1 sec                    'Wait 1 sec with LED on
    Loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="pulseoutinv"></span>PulseOutInv

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PulseOutInv pin, time units
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `PulseOutInv` command will set the specified pin low, wait for the
specified amount of time, and then set the pin high. The pin is
specified in the same way as it is for the `Set` command, and the time
is the same as for the `Wait` command.

<span class="strong">**Example:**</span>

``` screen
    'This program flashes an LED on GPIO.0 using PulseOutInv
    #chip 12F629, 4

    Dir GPIO.0 Out
    Do
        PulseOutInv GPIO.0, 1 sec     'Turn LED off for 1 sec
        Wait 1 sec                    'Wait 1 sec with LED on
    Loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Pulse width modulation</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_lcd_io_10_example.html" title="LCD_IO 10 Example"><link rel="next" href="_microchip_pic_pwm_overview.html" title="Microchip PIC PWM Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_pulse_width_modulation"></a>Pulse width modulation</h3></div></div></div><p>This is the Pulse width modulation section of the Help file.  Please refer the sub-sections for details using the contents/folder view for the MicroChip PIC PWM capabilities and the ATMEL AVR PWM capabilities.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="pulse_width_modulation"></span>Pulse width modulation

</div>

</div>

</div>

This is the Pulse width modulation section of the Help file. Please
refer the sub-sections for details using the contents/folder view for
the MicroChip PIC PWM capabilities and the ATMEL AVR PWM capabilities.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Put</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_liquid_crystal_display.html" title="Liquid Crystal Display"><link rel="prev" href="_print.html" title="Print"><link rel="next" href="_examples.html" title="Examples"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_put"></a>Put</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Put <span class="emphasis"><em>Line</em></span>, <span class="emphasis"><em>Column</em></span>, <span class="emphasis"><em>Character</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The Put command writes the given ASCII character code to the current location on
the LCD.</p><p><code class="literal">Line</code> is line number on the LCD display. A byte value from 0 to 255.</p><p><code class="literal">Column</code> is column number on the LCD display. A byte value from 0 to 255.</p><p><code class="literal">Character</code> is the requried ASCII code.  A byte value from 0 to 255.</p><p><span class="strong"><strong>Example :</strong></span></p><pre class="screen">    'A scrolling star for GCBASIC

    'Misc Settings
    #define SCROLL_DELAY 250 ms

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Main routine
    For StarPos = 0 To 16
        If StarPos = 0 Then
            Put 0, 16, 32
            Put 0, 0, 42
        Else
            Put 0, StarPos - 1, 32
            Put 0, StarPos, 42
        End If
        Wait SCROLL_DELAY
    Next</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_lcd_overview.html" title="LCD Overview">LCD Overview</a></p><p><span class="strong"><strong>Supported in &lt;LCD.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="put"></span>Put

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Put Line, Column, Character
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The Put command writes the given ASCII character code to the current
location on the LCD.

`Line` is line number on the LCD display. A byte value from 0 to 255.

`Column` is column number on the LCD display. A byte value from 0 to
255.

`Character` is the requried ASCII code. A byte value from 0 to 255.

<span class="strong">**Example :**</span>

``` screen
    'A scrolling star for GCBASIC

    'Misc Settings
    #define SCROLL_DELAY 250 ms

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Main routine
    For StarPos = 0 To 16
        If StarPos = 0 Then
            Put 0, 16, 32
            Put 0, 0, 42
        Else
            Put 0, StarPos - 1, 32
            Put 0, StarPos, 42
        End If
        Wait SCROLL_DELAY
    Next
```

<span class="strong">**For more help, see**</span>
<a href="lcd_overview" class="link" title="LCD Overview">LCD Overview</a>

<span class="strong">**Supported in &lt;LCD.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PWMOff</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hpwm_fixed_mode.html" title="HPWM Fixed Mode"><link rel="prev" href="_pwmon.html" title="PWMOn"><link rel="next" href="_hardware_pwm_code_optimisation.html" title="Hardware PWM Code Optimisation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_pwmoff"></a>PWMOff</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PWMOff</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available on Microchip PIC microcontrollers with Capture/Compare/PWM
module CCP1.</p><p>This command does not operate on any other CCP channel.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will disable the output of the CCP1/PWM module on the Microchip PIC chip.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will enable a 76 Khz PWM signal, with a duty cycle
    'of 80%. It will emit the signal for 10 seconds, then stop.
    #define PWM_Freq 76    'Set frequency in KHz
    #define PWM_Duty 80    'Set duty cycle to 80 %
    PWMOn                  'Turn on the PWM
    WAIT 10 s              'Wait 10 seconds
    PWMOff                 'Turn off the PWM</pre><p><br>
<br>
<span class="strong"><strong>For more help, also see</strong></span> <a class="link" href="_pwmon.html" title="PWMOn">PWMOn</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="pwmoff"></span>PWMOff

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PWMOff
```

<span class="strong">**Command Availability:**</span>

Only available on Microchip PIC microcontrollers with
Capture/Compare/PWM module CCP1.

This command does not operate on any other CCP channel.

<span class="strong">**Explanation:**</span>

This command will disable the output of the CCP1/PWM module on the
Microchip PIC chip.

<span class="strong">**Example:**</span>

``` screen
    'This program will enable a 76 Khz PWM signal, with a duty cycle
    'of 80%. It will emit the signal for 10 seconds, then stop.
    #define PWM_Freq 76    'Set frequency in KHz
    #define PWM_Duty 80    'Set duty cycle to 80 %
    PWMOn                  'Turn on the PWM
    WAIT 10 s              'Wait 10 seconds
    PWMOff                 'Turn off the PWM
```

  
  
<span class="strong">**For more help, also see**</span>
<a href="pwmon" class="link" title="PWMOn">PWMOn</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PWMOff for AVR</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hpwm_fixed_mode_for_avr.html" title="HPWM Fixed Mode for AVR"><link rel="prev" href="_pwmon_for_avr.html" title="PWMOn for AVR"><link rel="next" href="_random_numbers.html" title="Random Numbers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_pwmoff_for_avr"></a>PWMOff for AVR</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  PWMOff</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>This command is only available on the Atmel AVR microcontrollers with a Timer/Counter0 OC0B register.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The PWMOff command will only disable the output of the OC0B/PWM module of the Atmel AVR microcontrollers.</p><p>This command is not available for any other OCnx/PWM modules.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program demonstrates the PWMOn and PWMOff commands
    'of the fixed mode HPWM on OC0B pin.

    #chip mega328p,16

    'activate appropriate PWM output pins
    dir PortD.5 Out     'OC0B

    'define PWM_Freq in kHz
    'define PWM_Duty in %

    #define PWM_Freq 40
    #define PWM_Duty 50

    do

      'turn on/off single channel 40 KHz PWM on OC0B pin
      PWMON
      wait 5 s
      PWMOFF
      wait 5 s

    loop</pre><p><br>
<br></p><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_pwmon_for_avr.html" title="PWMOn for AVR">PWMOn</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="pwmoff_for_avr"></span>PWMOff for AVR

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  PWMOff
```

<span class="strong">**Command Availability:**</span>

This command is only available on the Atmel AVR microcontrollers with a
Timer/Counter0 OC0B register.

<span class="strong">**Explanation:**</span>

The PWMOff command will only disable the output of the OC0B/PWM module
of the Atmel AVR microcontrollers.

This command is not available for any other OCnx/PWM modules.

<span class="strong">**Example:**</span>

``` screen
    'This program demonstrates the PWMOn and PWMOff commands
    'of the fixed mode HPWM on OC0B pin.

    #chip mega328p,16

    'activate appropriate PWM output pins
    dir PortD.5 Out     'OC0B

    'define PWM_Freq in kHz
    'define PWM_Duty in %

    #define PWM_Freq 40
    #define PWM_Duty 50

    do

      'turn on/off single channel 40 KHz PWM on OC0B pin
      PWMON
      wait 5 s
      PWMOFF
      wait 5 s

    loop
```

  
  

<span class="strong">**For more help, see**</span>
<a href="pwmon_for_avr" class="link" title="PWMOn for AVR">PWMOn</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PWMOn</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hpwm_fixed_mode.html" title="HPWM Fixed Mode"><link rel="prev" href="_hpwm_fixed_mode.html" title="HPWM Fixed Mode"><link rel="next" href="_pwmoff.html" title="PWMOff"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_pwmon"></a>PWMOn</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PWMOn</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Only available on Microchip PIC microcontrollers with Capture/Compare/PWM
module CCP1.</p><p>This command does not operate on any other CCP channel.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><span class="strong"><strong>Example 1:</strong></span></p><p>This command will enable the output of the CCP1/PWM module on the Microchip PIC microcontroller.</p><pre class="screen">    'This program will enable a 76 Khz PWM signal, with a duty cycle
    'of 80%. It will emit the signal for 10 seconds, then stop.
    #define PWM_Freq 76    'Set frequency in KHz
    #define PWM_Duty 80    'Set duty cycle to 80 %
    PWMOn                  'Turn on the PWM
    WAIT 10 s              'Wait 10 seconds
    PWMOff                 'Turn off the PWM</pre><p><br>
<br></p><p><span class="strong"><strong>Example 2:</strong></span></p><p>This command will enable the output of the CCP1/PWM module on the Microchip PIC microcontroller.</p><p>Note the chip frequency.</p><pre class="screen">    'This program will enable a 62Hz PWM signal, with a duty cycle
    'of 50%.


    #Chip 12F1840, 1

    dir porta.2 out
    #define PWM_Freq .0625    'Set frequency in Hz equates to 62Hz
    #define PWM_Duty 50       'Set duty cycle to 80 %
    PWMON

    Do
    loop</pre><p><br>
<br>
<span class="strong"><strong>Example 3:</strong></span></p><p>This command will enable the output of the CCP1/PWM module on the Microchip PIC microcontroller.</p><p>Note the chip frequency.</p><pre class="screen">    'This program will enable a 7.7Hz PWM signal, with a duty cycle
    'of 50%.


    #Chip 12F1840, 0.125

    dir porta.2 out
    #define PWM_Freq .0077   'Set frequency in Hz equates to 7.7Hz
    #define PWM_Duty 50       'Set duty cycle to 50 %
    PWMON

    Do
    loop</pre><p><br>
<br></p><p><span class="strong"><strong>For more help, also see</strong></span> <a class="link" href="_pwmoff.html" title="PWMOff">PWMOff</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="pwmon"></span>PWMOn

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PWMOn
```

<span class="strong">**Command Availability:**</span>

Only available on Microchip PIC microcontrollers with
Capture/Compare/PWM module CCP1.

This command does not operate on any other CCP channel.

<span class="strong">**Explanation:**</span>

<span class="strong">**Example 1:**</span>

This command will enable the output of the CCP1/PWM module on the
Microchip PIC microcontroller.

``` screen
    'This program will enable a 76 Khz PWM signal, with a duty cycle
    'of 80%. It will emit the signal for 10 seconds, then stop.
    #define PWM_Freq 76    'Set frequency in KHz
    #define PWM_Duty 80    'Set duty cycle to 80 %
    PWMOn                  'Turn on the PWM
    WAIT 10 s              'Wait 10 seconds
    PWMOff                 'Turn off the PWM
```

  
  

<span class="strong">**Example 2:**</span>

This command will enable the output of the CCP1/PWM module on the
Microchip PIC microcontroller.

Note the chip frequency.

``` screen
    'This program will enable a 62Hz PWM signal, with a duty cycle
    'of 50%.


    #Chip 12F1840, 1

    dir porta.2 out
    #define PWM_Freq .0625    'Set frequency in Hz equates to 62Hz
    #define PWM_Duty 50       'Set duty cycle to 80 %
    PWMON

    Do
    loop
```

  
  
<span class="strong">**Example 3:**</span>

This command will enable the output of the CCP1/PWM module on the
Microchip PIC microcontroller.

Note the chip frequency.

``` screen
    'This program will enable a 7.7Hz PWM signal, with a duty cycle
    'of 50%.


    #Chip 12F1840, 0.125

    dir porta.2 out
    #define PWM_Freq .0077   'Set frequency in Hz equates to 7.7Hz
    #define PWM_Duty 50       'Set duty cycle to 50 %
    PWMON

    Do
    loop
```

  
  

<span class="strong">**For more help, also see**</span>
<a href="pwmoff" class="link" title="PWMOff">PWMOff</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PWMOn for AVR</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hpwm_fixed_mode_for_avr.html" title="HPWM Fixed Mode for AVR"><link rel="prev" href="_hpwm_fixed_mode_for_avr.html" title="HPWM Fixed Mode for AVR"><link rel="next" href="_pwmoff_for_avr.html" title="PWMOff for AVR"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_pwmon_for_avr"></a>PWMOn for AVR</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  PWMOn</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>This command is only available on the Atmel AVR microcontrollers with a Timer/Counter0 OC0B register.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The PWMOn command will only enable the output of the OC0B/PWM module of the Atmel AVR microcontroller.</p><p>This command is not available for any other OCnx/PWM modules.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program demonstrates the PWMOn and PWMOff commands
    'of the fixed mode HPWM on OC0B pin.

    #chip mega328p,16

    'activate appropriate PWM output pins
    dir PortD.5 Out     'OC0B

    'define PWM_Freq in kHz
    'define PWM_Duty in %

    #define PWM_Freq 40
    #define PWM_Duty 50

    do

      'turn on/off single channel 40 KHz PWM on OC0B pin
      PWMON
      wait 5 s
      PWMOFF
      wait 5 s

    loop</pre><p><br>
<br></p><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_pwmoff_for_avr.html" title="PWMOff for AVR">PWMOff</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="pwmon_for_avr"></span>PWMOn for AVR

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  PWMOn
```

<span class="strong">**Command Availability:**</span>

This command is only available on the Atmel AVR microcontrollers with a
Timer/Counter0 OC0B register.

<span class="strong">**Explanation:**</span>

The PWMOn command will only enable the output of the OC0B/PWM module of
the Atmel AVR microcontroller.

This command is not available for any other OCnx/PWM modules.

<span class="strong">**Example:**</span>

``` screen
    'This program demonstrates the PWMOn and PWMOff commands
    'of the fixed mode HPWM on OC0B pin.

    #chip mega328p,16

    'activate appropriate PWM output pins
    dir PortD.5 Out     'OC0B

    'define PWM_Freq in kHz
    'define PWM_Duty in %

    #define PWM_Freq 40
    #define PWM_Duty 50

    do

      'turn on/off single channel 40 KHz PWM on OC0B pin
      PWMON
      wait 5 s
      PWMOFF
      wait 5 s

    loop
```

  
  

<span class="strong">**For more help, see**</span>
<a href="pwmoff_for_avr" class="link" title="PWMOff for AVR">PWMOff</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PWMOut</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_pwm_software_mode.html" title="PWM Software Mode"><link rel="prev" href="_pwm_software_mode.html" title="PWM Software Mode"><link rel="next" href="_hpwm_ccp.html" title="HPWM CCP"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_pwmout"></a>PWMOut</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PWMOut <span class="emphasis"><em>channel, duty cycle, cycles</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.  This method does NOT require a PWM module within the microcontroller.</p><p>This command uses a software PWM routine within GCBASIC to produce
a PWM signal on the selected port of the chip.</p><p>The method <code class="literal">PWMOut</code> does not make use of any special hardware within the microcontroller.
The PWM signal is generated only while the <code class="literal">PWMOut</code> command is executing - therefore, when the <code class="literal">PWMOut</code> is not executing
by moving onto the next command, the PWM signal will stop.</p><p><span class="strong"><strong>Explanation :</strong></span></p><p><code class="literal"><span class="emphasis"><em>channel</em></span></code> sets the channel that the PWM is to be generated on. This must
have been defined previously by setting the constants <code class="literal">PWM_Out1</code><br></p><p><code class="literal">PWM_Out2</code>, <code class="literal">PWM_Out3</code> or <code class="literal">PWM_Out4</code>. The maximum number of channels available
is 4.<br></p><p><code class="literal"><span class="emphasis"><em>duty cycle</em></span></code> specifies the PWM duty cycle, and ranges from 0 to 255. 255
corresponds to 100%, 127 to 50%, 63 to 25%, and so on.<br></p><p><code class="literal"><span class="emphasis"><em>cycles</em></span></code> is used to set the amount of PWM pulses to supply. This is
useful for situations in which a pulse of a specific length is required.<br></p><p>The formula for calculating the time taken for one cycle is:<br></p><pre class="screen">    T<sub>CYCLE</sub> = (28 + 10C)T<sub>OSC</sub>+ (255 * PWM_Delay)</pre><p>where: <br></p><p>&nbsp;&nbsp;&nbsp;-C is the number of channels used<br>
&nbsp;&nbsp;&nbsp;-T<sub>OSC</sub> is the length of time taken to execute 1 instruction on the chip (0.2 us on a 20 MHz chip, 1
us on a 4 Mhz chip)<br>
&nbsp;&nbsp;&nbsp;-PWM_Delay is a length of time specified using the <code class="literal">PWM_Delay</code> constant<br></p><p><span class="strong"><strong>Example 1 :</strong></span></p><pre class="screen">    'This program controls the brightness of an LED on PORTB.0
    'using the software PWM routine and a potentiometer.
    #chip 16f877a, 20

    ; ----- Constants
    'PWM constant. This is a required constant.
    #define PWM_Out1 portb.0

    ; ---- Optional Constant to add an delay after PWM pulse
    ''#Define PWM_Delay 1 us


    ; ----- Define Hardware settings
    'PWM port out.  This is not required but good practice.
    dir PWM_Out1 out

    'A potentiometer is attached to ANO

    ; ----- Variables
    ' No Variables specified in this example.

    ; ----- Main body of program commences here.
      do
          '100 cycles is a purely arbitrary value as the loop will maintain a relatively constant PWM
          PWMOut 1, ReadAD(AN0), 100
      loop

end</pre><p><span class="strong"><strong>Example 2 :</strong></span></p><pre class="screen">    'This program controls the brightness of an LED on gpio.1
    'using the software PWM routine and a potentiometer.
    #chip 12f675, 4

    ; ----- Constants
      'PWM constant. This is a required constant.
      #define PWM_Out1 gpio.1

    ; ----- Define Hardware settings
      'PWM port out.  This is not required but good practice.
      dir PWM_Out1 out

      'A potentiometer is attached to ANO

    ; ----- Variables
      ' No Variables specified in this example.

    ; ----- Main body of program commences here.
        do
          '100 cycles is a purely arbitrary value
            PWMOut 1, ReadAD(AN0), 100
        loop
    end</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="pwmout"></span>PWMOut

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PWMOut channel, duty cycle, cycles
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers. This method does NOT require a PWM
module within the microcontroller.

This command uses a software PWM routine within GCBASIC to produce a PWM
signal on the selected port of the chip.

The method `PWMOut` does not make use of any special hardware within the
microcontroller. The PWM signal is generated only while the `PWMOut`
command is executing - therefore, when the `PWMOut` is not executing by
moving onto the next command, the PWM signal will stop.

<span class="strong">**Explanation :**</span>

`channel` sets the channel that the PWM is to be generated on. This must
have been defined previously by setting the constants `PWM_Out1`  

`PWM_Out2`, `PWM_Out3` or `PWM_Out4`. The maximum number of channels
available is 4.  

`duty cycle` specifies the PWM duty cycle, and ranges from 0 to 255. 255
corresponds to 100%, 127 to 50%, 63 to 25%, and so on.  

`cycles` is used to set the amount of PWM pulses to supply. This is
useful for situations in which a pulse of a specific length is
required.  

The formula for calculating the time taken for one cycle is:  

``` screen
    TCYCLE = (28 + 10C)TOSC+ (255 * PWM_Delay)
```

where:  

   -C is the number of channels used  
   -T<sub>OSC</sub> is the length of time taken to execute 1 instruction
on the chip (0.2 us on a 20 MHz chip, 1 us on a 4 Mhz chip)  
   -PWM\_Delay is a length of time specified using the `PWM_Delay`
constant  

<span class="strong">**Example 1 :**</span>

``` screen
    'This program controls the brightness of an LED on PORTB.0
    'using the software PWM routine and a potentiometer.
    #chip 16f877a, 20

    ; ----- Constants
    'PWM constant. This is a required constant.
    #define PWM_Out1 portb.0

    ; ---- Optional Constant to add an delay after PWM pulse
    ''#Define PWM_Delay 1 us


    ; ----- Define Hardware settings
    'PWM port out.  This is not required but good practice.
    dir PWM_Out1 out

    'A potentiometer is attached to ANO

    ; ----- Variables
    ' No Variables specified in this example.

    ; ----- Main body of program commences here.
      do
          '100 cycles is a purely arbitrary value as the loop will maintain a relatively constant PWM
          PWMOut 1, ReadAD(AN0), 100
      loop

end
```

<span class="strong">**Example 2 :**</span>

``` screen
    'This program controls the brightness of an LED on gpio.1
    'using the software PWM routine and a potentiometer.
    #chip 12f675, 4

    ; ----- Constants
      'PWM constant. This is a required constant.
      #define PWM_Out1 gpio.1

    ; ----- Define Hardware settings
      'PWM port out.  This is not required but good practice.
      dir PWM_Out1 out

      'A potentiometer is attached to ANO

    ; ----- Variables
      ' No Variables specified in this example.

    ; ----- Main body of program commences here.
        do
          '100 cycles is a purely arbitrary value
            PWMOut 1, ReadAD(AN0), 100
        loop
    end
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PWM Software Mode</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microchip_pic_pwm_overview.html" title="Microchip PIC PWM Overview"><link rel="prev" href="_microchip_pic_pwm_overview.html" title="Microchip PIC PWM Overview"><link rel="next" href="_pwmout.html" title="PWMOut"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_pwm_software_mode"></a>PWM Software Mode</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    PWMOut <span class="emphasis"><em>channel, duty cycle, cycles</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.  This method does NOT require a PWM module within the microcontroller.</p><p>This command uses a software PWM routine within GCBASIC to produce
a PWM signal on the selected port of the chip.</p><p>The method <code class="literal">PWMOut</code> does not make use of any special hardware within the microcontroller.
The PWM signal is generated only while the <code class="literal">PWMOut</code> command is executing - therefore, when the <code class="literal">PWMOut</code> is not executing
by moving onto the next command, the PWM signal will stop.</p><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_pwmout.html" title="PWMOut">PWMOut</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="pwm_software_mode"></span>PWM Software Mode

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    PWMOut channel, duty cycle, cycles
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers. This method does NOT require a PWM
module within the microcontroller.

This command uses a software PWM routine within GCBASIC to produce a PWM
signal on the selected port of the chip.

The method `PWMOut` does not make use of any special hardware within the
microcontroller. The PWM signal is generated only while the `PWMOut`
command is executing - therefore, when the `PWMOut` is not executing by
moving onto the next command, the PWM signal will stop.

<span class="strong">**For more help, see**</span>
<a href="pwmout" class="link" title="PWMOut">PWMOut</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Random</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_random_numbers.html" title="Random Numbers"><link rel="prev" href="_overview.html" title="Overview"><link rel="next" href="_randomize.html" title="Randomize"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_random"></a>Random</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    var = Random</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Random</code> function will generate a pseudo-random number between 0 and 255 inclusive.</p><p>The numbers generated by <code class="literal">Random</code> will follow the same sequence every time, until <code class="literal">Randomize</code> is used.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip tiny2313, 1

    'Use randomize, with the value on PORTD as the seed
    Randomize PORTD

    'Generate random numbers, and output on PORTB
    Do
        PORTB = Random
        Wait 1 s
    Loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="random"></span>Random

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    var = Random
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Random` function will generate a pseudo-random number between 0 and
255 inclusive.

The numbers generated by `Random` will follow the same sequence every
time, until `Randomize` is used.

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip tiny2313, 1

    'Use randomize, with the value on PORTD as the seed
    Randomize PORTD

    'Generate random numbers, and output on PORTB
    Do
        PORTB = Random
        Wait 1 s
    Loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Randomize</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_random_numbers.html" title="Random Numbers"><link rel="prev" href="_random.html" title="Random"><link rel="next" href="_7_segment_displays.html" title="7-Segment Displays"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_randomize"></a>Randomize</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Randomize
    Randomize <span class="emphasis"><em>seed</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Randomize is used to seed the pseudo random number generator, so that it
will produce a different sequence of numbers each time it is used.</p><p>The random number generator in GCBASIC is a 16 bit linear feedback shift register,
which is explained here: <a class="link" href="http://en.wikipedia.org/wiki/Linear_feedback_shift_register" target="_top">http://en.wikipedia.org/wiki/Linear_feedback_shift_register</a></p><p>Generally, you will get the same sequence every time it is used.&nbsp;&nbsp;However, you can seed it so that it will start at a different point at the sequence using the Randomize command.</p><p>If you wanted to use an analog reading to seed the generator, this would work:</p><pre class="literallayout">Randomize ReadAD10(AN0)</pre><p>If no <span class="emphasis"><em>seed</em></span> is specified, then the RANDOMIZE_SEED constant will be used
as the seed.&nbsp;&nbsp;If <span class="emphasis"><em>seed</em></span> is specified, then it will be used to seed the
generator.</p><p>It is important that the seed is different every time that Randomize is
used. If the seed is always the same, then the sequence of numbers will
always be the same.&nbsp;&nbsp; It is best to use a running timer, an input port, or
the analog to digital converter as the source of the seed, since these
will normally provide a different value each time the program runs.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip tiny2313, 1

    'Use randomize, with the value on PORTD as the seed
    Randomize PORTD

    'Generate random numbers, and output on PORTB
    Do
        PORTB = Random
        Wait 1 s
    Loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="randomize"></span>Randomize

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Randomize
    Randomize seed
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

Randomize is used to seed the pseudo random number generator, so that it
will produce a different sequence of numbers each time it is used.

The random number generator in GCBASIC is a 16 bit linear feedback shift
register, which is explained here:
<http://en.wikipedia.org/wiki/Linear_feedback_shift_register>

Generally, you will get the same sequence every time it is
used.  However, you can seed it so that it will start at a different
point at the sequence using the Randomize command.

If you wanted to use an analog reading to seed the generator, this would
work:

``` literallayout
Randomize ReadAD10(AN0)
```

If no <span class="emphasis">*seed*</span> is specified, then the
RANDOMIZE\_SEED constant will be used as the seed.  If <span
class="emphasis">*seed*</span> is specified, then it will be used to
seed the generator.

It is important that the seed is different every time that Randomize is
used. If the seed is always the same, then the sequence of numbers will
always be the same.   It is best to use a running timer, an input port,
or the analog to digital converter as the source of the seed, since
these will normally provide a different value each time the program
runs.

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip tiny2313, 1

    'Use randomize, with the value on PORTD as the seed
    Randomize PORTD

    'Generate random numbers, and output on PORTB
    Do
        PORTB = Random
        Wait 1 s
    Loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Random Numbers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_pwmoff_for_avr.html" title="PWMOff for AVR"><link rel="next" href="_overview.html" title="Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_random_numbers"></a>Random Numbers</h3></div></div></div><p>This is the Random Numbers section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="random_numbers"></span>Random Numbers

</div>

</div>

</div>

This is the Random Numbers section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ReadAD</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_analog_digital_conversion.html" title="Analog/Digital conversion"><link rel="prev" href="_adoff.html" title="ADOff"><link rel="next" href="_readad10.html" title="ReadAD10"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_readad"></a>ReadAD</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><p>For a normal ( also called a Single Channel )  read use.</p><pre class="screen">    byte_variable = ReadAD( ANX )</pre><p>For a Differential Channel read use the following.&nbsp;&nbsp;Where ANpX is the positive port, and ANnY is the negative port.</p><pre class="screen">    byte_variable = ReadAD( ANpX , ANnY )</pre><p>To obtain a byte value from an AD Channel use the following to force an 8 bit AD Channel to respond with a byte value [0 to 255].</p><pre class="screen">    byte_variable = ReadAD( ANX , TRUE )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>When using <span class="strong"><strong>ReadAD</strong></span> ( ANx ) the returned value is an 8 bit number [0- 255].&nbsp;&nbsp;The byte variable assigned by the function can be a byte, word, integer or long.</p><p>When using <span class="strong"><strong>ReadAD</strong></span> ( ANpX , ANnY ) the returned value is an integer, as negative values can be returned.</p><p>When using <span class="strong"><strong>ReadAD</strong></span> ( ANpX , TRUE ) the returned value is an integer, but you should treat as a byte.</p><p>ReadAD is a function that can be used to read the built-in analog to digital converter that many microcontroller chips include.&nbsp;&nbsp;port should be specified as AN0, AN1, AN2, etc., up to the number of analog inputs available on the chip that is in use.&nbsp;&nbsp;Those familiar with Atmel AVR microcontrollers can also refer to the ports as ADC0, ADC1, etc.&nbsp;&nbsp;Refer to the datasheet for the microcontroller chip to find the number of ports available.&nbsp;&nbsp;(Note: it&#8217;s perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller)</p><p>Other functions that are similar are <span class="strong"><strong>ReadAD10</strong></span> and <span class="strong"><strong>ReadAD12</strong></span>.&nbsp;&nbsp;See the relevant Help page for the specific usage of each function.</p><p>The constant <span class="strong"><strong>AD_Delay</strong></span> controls is the acquisition delay.&nbsp;&nbsp;The default value is 20 us.&nbsp;&nbsp;This can be changed by adding the following constant.</p><pre class="screen">    #define AD_Delay 2 10us</pre><p><span class="strong"><strong>ADSpeed</strong></span> controls the source of the clock for the ADC module.&nbsp;&nbsp; It varies from one chip to another.&nbsp;&nbsp; InternalClock is a Microchip PIC microcontroller only option that will drive the ADC from an internal RC oscillator.&nbsp;&nbsp;The default value is 128.</p><p>Using ADSPEED</p><pre class="screen">    'default value
    #define ADSpeed MediumSpeed


    'pre-defined constants
    #define HighSpeed 255
    #define MediumSpeed 128
    #define LowSpeed 0</pre><p><span class="strong"><strong>AD_VREF_DELAY</strong></span> controls the charging time for VRef capacitor on Atmel AVR microcontrollers only.&nbsp;&nbsp;This therefore controls the charge from internal VRef.&nbsp;&nbsp; ReadAD will not be accurate for internal reference without this.</p><p><span class="strong"><strong>AD_Acquisition_Time_Select_bits</strong></span> also controls the Acquisition Time Select bits.&nbsp;&nbsp; Acquisition time is the duration that the AD charge
holding capacitor remains connected to AD channel from the instant the read is commenced is set until conversions begins.</p><p>The default value of AD_Acquisition_Time_Select_bits is 0b100 or decimal 4, where all three ACQT bits will be set.&nbsp;&nbsp;To change use the following.</p><pre class="screen">    'change the default value
    #define AD_Acquisition_Time_Select_bits 0b001    'this will only set ACQT bit 0, ACQT bits 1 and 2 will be cleared.</pre><p><span class="strong"><strong>Example 1</strong></span></p><p>This example reads the ADC port and writes the output to the EEPROM.</p><pre class="screen">    #chip 16F819, 8

    'Set the input pin direction
    Dir PORTA.0 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        EPWrite CurrentAddress, ReadAD(AN0)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</pre><p><span class="strong"><strong>Example 2</strong></span></p><p>This example reads the ADC port and writes the output to the EEPROM.&nbsp;&nbsp;The output value will be in the range of [0-255].</p><pre class="screen">    #chip 16F1789, 8


    'Set the input pin direction
    Dir PORTA.0 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        EPWrite CurrentAddress, ReadAD(AN0, TRUE)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</pre><p><span class="strong"><strong>Example 3</strong></span></p><p>This example used the diffential capabilities of ADC port and writes the output to the EEPROM.&nbsp;&nbsp;The output value will be in the range of [-255 to 255].</p><p>AN0 and AN2 are used for the diffential ADC reading.</p><pre class="screen">    #chip 16F1789, 8


    'Set the input pin direction
    Dir PORTA.0 In
    Dir PORTA.2 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        EPWrite CurrentAddress, ReadAD( AN0, AN2 )

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</pre><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_readad10.html" title="ReadAD10">ReadAD10</a>, <a class="link" href="_readad12.html" title="ReadAD12">ReadAD12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="readad"></span>ReadAD

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

For a normal ( also called a Single Channel ) read use.

``` screen
    byte_variable = ReadAD( ANX )
```

For a Differential Channel read use the following.  Where ANpX is the
positive port, and ANnY is the negative port.

``` screen
    byte_variable = ReadAD( ANpX , ANnY )
```

To obtain a byte value from an AD Channel use the following to force an
8 bit AD Channel to respond with a byte value \[0 to 255\].

``` screen
    byte_variable = ReadAD( ANX , TRUE )
```

<span class="strong">**Command Availability:**</span>

When using <span class="strong">**ReadAD**</span> ( ANx ) the returned
value is an 8 bit number \[0- 255\].  The byte variable assigned by the
function can be a byte, word, integer or long.

When using <span class="strong">**ReadAD**</span> ( ANpX , ANnY ) the
returned value is an integer, as negative values can be returned.

When using <span class="strong">**ReadAD**</span> ( ANpX , TRUE ) the
returned value is an integer, but you should treat as a byte.

ReadAD is a function that can be used to read the built-in analog to
digital converter that many microcontroller chips include.  port should
be specified as AN0, AN1, AN2, etc., up to the number of analog inputs
available on the chip that is in use.  Those familiar with Atmel AVR
microcontrollers can also refer to the ports as ADC0, ADC1, etc.  Refer
to the datasheet for the microcontroller chip to find the number of
ports available.  (Note: it’s perfectly acceptable to use ANx on AVR, or
ADCx on the microcontroller)

Other functions that are similar are <span
class="strong">**ReadAD10**</span> and <span
class="strong">**ReadAD12**</span>.  See the relevant Help page for the
specific usage of each function.

The constant <span class="strong">**AD\_Delay**</span> controls is the
acquisition delay.  The default value is 20 us.  This can be changed by
adding the following constant.

``` screen
    #define AD_Delay 2 10us
```

<span class="strong">**ADSpeed**</span> controls the source of the clock
for the ADC module.   It varies from one chip to another.  
InternalClock is a Microchip PIC microcontroller only option that will
drive the ADC from an internal RC oscillator.  The default value is 128.

Using ADSPEED

``` screen
    'default value
    #define ADSpeed MediumSpeed


    'pre-defined constants
    #define HighSpeed 255
    #define MediumSpeed 128
    #define LowSpeed 0
```

<span class="strong">**AD\_VREF\_DELAY**</span> controls the charging
time for VRef capacitor on Atmel AVR microcontrollers only.  This
therefore controls the charge from internal VRef.   ReadAD will not be
accurate for internal reference without this.

<span class="strong">**AD\_Acquisition\_Time\_Select\_bits**</span> also
controls the Acquisition Time Select bits.   Acquisition time is the
duration that the AD charge holding capacitor remains connected to AD
channel from the instant the read is commenced is set until conversions
begins.

The default value of AD\_Acquisition\_Time\_Select\_bits is 0b100 or
decimal 4, where all three ACQT bits will be set.  To change use the
following.

``` screen
    'change the default value
    #define AD_Acquisition_Time_Select_bits 0b001    'this will only set ACQT bit 0, ACQT bits 1 and 2 will be cleared.
```

<span class="strong">**Example 1**</span>

This example reads the ADC port and writes the output to the EEPROM.

``` screen
    #chip 16F819, 8

    'Set the input pin direction
    Dir PORTA.0 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        EPWrite CurrentAddress, ReadAD(AN0)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next
```

<span class="strong">**Example 2**</span>

This example reads the ADC port and writes the output to the
EEPROM.  The output value will be in the range of \[0-255\].

``` screen
    #chip 16F1789, 8


    'Set the input pin direction
    Dir PORTA.0 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        EPWrite CurrentAddress, ReadAD(AN0, TRUE)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next
```

<span class="strong">**Example 3**</span>

This example used the diffential capabilities of ADC port and writes the
output to the EEPROM.  The output value will be in the range of \[-255
to 255\].

AN0 and AN2 are used for the diffential ADC reading.

``` screen
    #chip 16F1789, 8


    'Set the input pin direction
    Dir PORTA.0 In
    Dir PORTA.2 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        EPWrite CurrentAddress, ReadAD( AN0, AN2 )

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next
```

<span class="strong">**See Also**</span>
<a href="readad10" class="link" title="ReadAD10">ReadAD10</a>,
<a href="readad12" class="link" title="ReadAD12">ReadAD12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ReadAD10</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_analog_digital_conversion.html" title="Analog/Digital conversion"><link rel="prev" href="_readad.html" title="ReadAD"><link rel="next" href="_readad12.html" title="ReadAD12"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_readad10"></a>ReadAD10</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><p>For a normal ( also called a Single Channel )  read use.</p><pre class="screen">    word_variable = ReadAD10( ANX )</pre><p>For a Differential Channel read use the following.&nbsp;&nbsp;Where ANpX is the positive port, and ANnY is the negative port.</p><pre class="screen">    integer_variable = ReadAD10( ANpX , ANnY )</pre><p>To obtain a 10-bit value from an AD Channel use the following to force a 10 bit AD Channel to respond with the correct value, in terms of the range [0 to 1023]</p><pre class="screen">    integer_variable = ReadAD10( ANX , TRUE )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>ReadAD10 is a function that can be used to read the built-in analog to digital converter that many microcontroller chips include.&nbsp;&nbsp;The port should be specified as AN0, AN1, AN2, etc., up to the number of analog inputs available on the chip that is in use.&nbsp;&nbsp;Those familiar with Atmel AVR microcontrollers can also refer to the ports as ADC0, ADC1, etc.&nbsp;&nbsp;Refer to the datasheet for the microcontroller chip to find the number of ports available.&nbsp;&nbsp;(Note: it&#8217;s perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller.)</p><p>When using <span class="strong"><strong>ReadAD10</strong></span> ( ANX ) the returned value is the <span class="strong"><strong>full range</strong></span> of the ADC module.&nbsp;&nbsp;Therefore, the method will return an 8 bit value [0-255], or an 10 bit value [0-1023] or an 12 bit value [0-4095].&nbsp;&nbsp; This is dependent on the microcontrollers capabilities.&nbsp;&nbsp;  For a 10 bit value [0-1023] always to be returned use  user_variable = ReadAD10( ANX , TRUE ).&nbsp;&nbsp; The user variable can be a byte, word, integer or long but typically a word is recommnended.</p><p>When using <span class="strong"><strong>ReadAD10</strong></span> ( ANpX , ANnY ), for differential ADC reading, the returned value is an integer as negative values will be returned.</p><p>When using <span class="strong"><strong>ReadAD10</strong></span> ( ANpX , TRUE ), to force a 10 bit ADC reading, the returned value is an integer.</p><p>Other functions that are similar are <span class="strong"><strong>ReadAD</strong></span> and <span class="strong"><strong>ReadAD12</strong></span>.&nbsp;&nbsp;See the relevant Help page for the specific usage of each function.</p><p><span class="strong"><strong>AD_Delay</strong></span> controls is the acquisition delay.&nbsp;&nbsp; The default value is 20 us.&nbsp;&nbsp;This can be changed to a longer acquisition delay by adding the following constant.</p><pre class="screen">    #define AD_Delay 4 10us</pre><p><span class="strong"><strong>ADSpeed</strong></span>( controls the source of the clock for the ADC module.&nbsp;&nbsp; It varies from one chip to another.&nbsp;&nbsp; InternalClock is a microcontroller only option that will drive the ADC from an internal RC oscillator.&nbsp;&nbsp;The default value is 128.</p><pre class="screen">    'default value
    #define ADSpeed MediumSpeed


    'pre-defined constants
    #define HighSpeed 255
    #define MediumSpeed 128
    #define LowSpeed 0</pre><p><span class="strong"><strong>AD_Acquisition_Time_Select_bits</strong></span> also controls the Acquisition Time Select bits.&nbsp;&nbsp; Acquisition time is the duration that the AD charge
holding capacitor remains connected to AD channel from the instant the read is commenced is set until conversions begins.</p><p>The default value of AD_Acquisition_Time_Select_bits is 0b100 or decimal 4, where all three ACQT bits will be set.&nbsp;&nbsp;To change use the following.</p><pre class="screen">    'change the default value
    #define AD_Acquisition_Time_Select_bits 0b001    'this will only set ACQT bit 0, ACQT bits 1 and 2 will be cleared.</pre><p><span class="strong"><strong>Example 1 - Read 10-bit ADC</strong></span></p><pre class="screen">    #chip 16F819, 8

    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 reading
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD10(AN0))

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</pre><p><span class="strong"><strong>Example 2 - Reading Reference Voltages:</strong></span></p><p>When selecting the  reference source for ADC on ATmega328 GCBASIC will overwrite anything that you put into te ADMUX register - but this option allow you change the ADC reference source on Atmel AVR microcontrollers.&nbsp;&nbsp; You can set the AD_REF_SOURCE constant to whatever you want to use.&nbsp;&nbsp; It defaults to the VCC pin, as example you can set the Atmel AVR to use the 1.1V reference with this:
<span class="strong"><strong>#define AD_REF_SOURCE AD_REF_256</strong></span> where 256 refers to the 2.56V reference on some older AVRs, but the same code will select the 1.1V reference on an ATmega328p</p><pre class="screen">    ' Dynamically switching reference.
    #define AD_REF_SOURCE ADRefSource
    #define AD_VREF_DELAY 5 ms
    AdRefSource = AD_REF_AVCC
    HSerPrint ReadAD10(AN1)
    HSerPrint ", "
    AdRefSource = AD_REF_256
    HSerPrint ReadAD10(AN1)</pre><p>The example above sets the AD_REF_SOURCE to a variable, and then changes the value of the variable to select the source.&nbsp;&nbsp; With this approach, we also need to allow time to charge the reference capacitor to the correct voltage.</p><p><span class="strong"><strong>Example 3 - Read 10-bit ADC forcing a 10-bit value to be returned</strong></span></p><pre class="screen">    #chip 16F1789, 8

    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 reading
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD10(AN0), TRUE)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</pre><p><span class="strong"><strong>Example 4</strong></span></p><p>This example used the diffential capabilities of ADC port and writes the output to the EEPROM.&nbsp;&nbsp;The output value will be in the range of [-1023 to 1023].</p><p>AN0 and AN2 are used for the diffential ADC reading.</p><pre class="screen">    #chip 16F1789, 8

    'USART settings
    #define USART_BAUD_RATE 9600  'Initializes USART port with 9600 baud
    #define USART_TX_BLOCKING ' wait for tx register to be empty
    wait 100 ms

    'Set the input pin direction
    Dir PORTA.0 In
    Dir PORTA.2 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        HSerPrint ReadAD10( AN0, AN2 )
        HserPrintCRLF
        'Wait 10 minutes before getting another reading
        Wait 10 min

    Next</pre><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_readad.html" title="ReadAD">ReadAD</a>, <a class="link" href="_readad12.html" title="ReadAD12">ReadAD12</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="readad10"></span>ReadAD10

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

For a normal ( also called a Single Channel ) read use.

``` screen
    word_variable = ReadAD10( ANX )
```

For a Differential Channel read use the following.  Where ANpX is the
positive port, and ANnY is the negative port.

``` screen
    integer_variable = ReadAD10( ANpX , ANnY )
```

To obtain a 10-bit value from an AD Channel use the following to force a
10 bit AD Channel to respond with the correct value, in terms of the
range \[0 to 1023\]

``` screen
    integer_variable = ReadAD10( ANX , TRUE )
```

<span class="strong">**Command Availability:**</span>

ReadAD10 is a function that can be used to read the built-in analog to
digital converter that many microcontroller chips include.  The port
should be specified as AN0, AN1, AN2, etc., up to the number of analog
inputs available on the chip that is in use.  Those familiar with Atmel
AVR microcontrollers can also refer to the ports as ADC0, ADC1,
etc.  Refer to the datasheet for the microcontroller chip to find the
number of ports available.  (Note: it’s perfectly acceptable to use ANx
on AVR, or ADCx on the microcontroller.)

When using <span class="strong">**ReadAD10**</span> ( ANX ) the returned
value is the <span class="strong">**full range**</span> of the ADC
module.  Therefore, the method will return an 8 bit value \[0-255\], or
an 10 bit value \[0-1023\] or an 12 bit value \[0-4095\].   This is
dependent on the microcontrollers capabilities.   For a 10 bit value
\[0-1023\] always to be returned use user\_variable = ReadAD10( ANX ,
TRUE ).   The user variable can be a byte, word, integer or long but
typically a word is recommnended.

When using <span class="strong">**ReadAD10**</span> ( ANpX , ANnY ), for
differential ADC reading, the returned value is an integer as negative
values will be returned.

When using <span class="strong">**ReadAD10**</span> ( ANpX , TRUE ), to
force a 10 bit ADC reading, the returned value is an integer.

Other functions that are similar are <span
class="strong">**ReadAD**</span> and <span
class="strong">**ReadAD12**</span>.  See the relevant Help page for the
specific usage of each function.

<span class="strong">**AD\_Delay**</span> controls is the acquisition
delay.   The default value is 20 us.  This can be changed to a longer
acquisition delay by adding the following constant.

``` screen
    #define AD_Delay 4 10us
```

<span class="strong">**ADSpeed**</span>( controls the source of the
clock for the ADC module.   It varies from one chip to another.  
InternalClock is a microcontroller only option that will drive the ADC
from an internal RC oscillator.  The default value is 128.

``` screen
    'default value
    #define ADSpeed MediumSpeed


    'pre-defined constants
    #define HighSpeed 255
    #define MediumSpeed 128
    #define LowSpeed 0
```

<span class="strong">**AD\_Acquisition\_Time\_Select\_bits**</span> also
controls the Acquisition Time Select bits.   Acquisition time is the
duration that the AD charge holding capacitor remains connected to AD
channel from the instant the read is commenced is set until conversions
begins.

The default value of AD\_Acquisition\_Time\_Select\_bits is 0b100 or
decimal 4, where all three ACQT bits will be set.  To change use the
following.

``` screen
    'change the default value
    #define AD_Acquisition_Time_Select_bits 0b001    'this will only set ACQT bit 0, ACQT bits 1 and 2 will be cleared.
```

<span class="strong">**Example 1 - Read 10-bit ADC**</span>

``` screen
    #chip 16F819, 8

    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 reading
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD10(AN0))

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next
```

<span class="strong">**Example 2 - Reading Reference Voltages:**</span>

When selecting the reference source for ADC on ATmega328 GCBASIC will
overwrite anything that you put into te ADMUX register - but this option
allow you change the ADC reference source on Atmel AVR
microcontrollers.   You can set the AD\_REF\_SOURCE constant to whatever
you want to use.   It defaults to the VCC pin, as example you can set
the Atmel AVR to use the 1.1V reference with this: <span
class="strong">**\#define AD\_REF\_SOURCE AD\_REF\_256**</span> where
256 refers to the 2.56V reference on some older AVRs, but the same code
will select the 1.1V reference on an ATmega328p

``` screen
    ' Dynamically switching reference.
    #define AD_REF_SOURCE ADRefSource
    #define AD_VREF_DELAY 5 ms
    AdRefSource = AD_REF_AVCC
    HSerPrint ReadAD10(AN1)
    HSerPrint ", "
    AdRefSource = AD_REF_256
    HSerPrint ReadAD10(AN1)
```

The example above sets the AD\_REF\_SOURCE to a variable, and then
changes the value of the variable to select the source.   With this
approach, we also need to allow time to charge the reference capacitor
to the correct voltage.

<span class="strong">**Example 3 - Read 10-bit ADC forcing a 10-bit
value to be returned**</span>

``` screen
    #chip 16F1789, 8

    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 reading
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD10(AN0), TRUE)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next
```

<span class="strong">**Example 4**</span>

This example used the diffential capabilities of ADC port and writes the
output to the EEPROM.  The output value will be in the range of \[-1023
to 1023\].

AN0 and AN2 are used for the diffential ADC reading.

``` screen
    #chip 16F1789, 8

    'USART settings
    #define USART_BAUD_RATE 9600  'Initializes USART port with 9600 baud
    #define USART_TX_BLOCKING ' wait for tx register to be empty
    wait 100 ms

    'Set the input pin direction
    Dir PORTA.0 In
    Dir PORTA.2 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        HSerPrint ReadAD10( AN0, AN2 )
        HserPrintCRLF
        'Wait 10 minutes before getting another reading
        Wait 10 min

    Next
```

<span class="strong">**See Also**</span>
<a href="readad" class="link" title="ReadAD">ReadAD</a>,
<a href="readad12" class="link" title="ReadAD12">ReadAD12</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ReadAD12</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_analog_digital_conversion.html" title="Analog/Digital conversion"><link rel="prev" href="_readad10.html" title="ReadAD10"><link rel="next" href="_analog_digital_conversion_code_optimisation.html" title="Analog/Digital Conversion Code Optimisation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_readad12"></a>ReadAD12</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><p>For a normal ( also called a Single Channel )  read use.</p><pre class="screen">    user_variable = ReadAD12( ANX )</pre><p>For a Differential Channel read use the following.&nbsp;&nbsp;Where ANpX is the positive port, and ANnY is the negative port.</p><pre class="screen">    user_variable = ReadAD12( ANpX , ANnY )</pre><p>To obtain a 12-bit value from an AD Channel use the following to force a 12 bit AD Channel to respond with the correct value, in terms of the range of [0 to 4095]</p><pre class="screen">    user_variable = ReadAD12( ANX , TRUE )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>When using <span class="strong"><strong>ReadAD12</strong></span> ( ANX ) the returned value is an 12 bit number [0-4095].&nbsp;&nbsp;The user variable can be a word, integer or long.</p><p>When using <span class="strong"><strong>ReadAD12</strong></span> ( ANpX , ANnY ) the returned value is an integer as negative values can be returned.</p><p><span class="strong"><strong>ReadAD12</strong></span>  is a function that can be used to read the built-in analog to digital converter that many microcontroller chips include.&nbsp;&nbsp;Port should be specified as AN0, AN1, AN2, etc., up to the number of analog inputs available on the chip that is in use.&nbsp;&nbsp;Those familiar with Atmel AVR microcontrollers can also refer to the ports as ADC0, ADC1, etc.&nbsp;&nbsp;Refer to the datasheet for the microcontroller chip to find the number of ports available.&nbsp;&nbsp;(Note: it&#8217;s perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller.)</p><p>Other functions that are similar are <span class="strong"><strong>ReadAD</strong></span> and <span class="strong"><strong>ReadAD10</strong></span>.&nbsp;&nbsp;See the relevant Help page for the specific usage of each function.</p><p><span class="strong"><strong>AD_Delay</strong></span> controls is the acquisition delay.&nbsp;&nbsp; The default value is 20 us.&nbsp;&nbsp;This can be changed to a longer acquisition delay by adding the following constant.</p><pre class="screen">    #define AD_Delay 4 10us</pre><p><span class="strong"><strong>ADSpeed</strong></span>( controls the source of the clock for the ADC module.&nbsp;&nbsp; It varies from one microcontroller to another.&nbsp;&nbsp; InternalClock is a Microchip PIC microcontroller only option that will drive the ADC from an internal RC oscillator.&nbsp;&nbsp;The default value is 128.</p><pre class="screen">    'default value
    #define ADSpeed MediumSpeed


    'pre-defined constants
    #define HighSpeed 255
    #define MediumSpeed 128
    #define LowSpeed 0</pre><p><span class="strong"><strong>AD_Acquisition_Time_Select_bits</strong></span> also controls the Acquisition Time Select bits.&nbsp;&nbsp; Acquisition time is the duration that the AD charge
holding capacitor remains connected to AD channel from the instant the read is commenced is set until conversions begins.</p><p>The default value of AD_Acquisition_Time_Select_bits is 0b100 or decimal 4, where all three ACQT bits will be set.&nbsp;&nbsp;To change use the following.</p><pre class="screen">    'change the default value
    #define AD_Acquisition_Time_Select_bits 0b001    'this will only set ACQT bit 0, ACQT bits 1 and 2 will be cleared.</pre><p><span class="strong"><strong>Example 1  - Read 12-bit ADC</strong></span></p><pre class="screen">    #chip 16F1788, 8

    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 readings
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD12(AN0))

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</pre><p><span class="strong"><strong>Example 2  - Force a 12-bit value to be returned</strong></span></p><pre class="screen">    #chip 16F1788, 8


    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 readings
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD12(AN0), TRUE)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</pre><p><span class="strong"><strong>Example 3</strong></span></p><p>This example used the diffential capabilities of ADC port and writes the output to the EEPROM.&nbsp;&nbsp;The output value will be in the range of [-4095 to 4095].</p><p>AN0 and AN2 are used for the diffential ADC reading.</p><pre class="screen">    #chip 16F1789, 8

    'USART settings
    #define USART_BAUD_RATE 9600  'Initializes USART port with 9600 baud
    #define USART_TX_BLOCKING ' wait for tx register to be empty
    wait 100 ms

    'Set the input pin direction
    Dir PORTA.0 In
    Dir PORTA.2 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        HSerPrint ReadAD12( AN0, AN2 )
        HserPrintCRLF
        'Wait 10 minutes before getting another reading
        Wait 10 min

    Next</pre><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_readad.html" title="ReadAD">ReadAD</a>, <a class="link" href="_readad10.html" title="ReadAD10">ReadAD10</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="readad12"></span>ReadAD12

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

For a normal ( also called a Single Channel ) read use.

``` screen
    user_variable = ReadAD12( ANX )
```

For a Differential Channel read use the following.  Where ANpX is the
positive port, and ANnY is the negative port.

``` screen
    user_variable = ReadAD12( ANpX , ANnY )
```

To obtain a 12-bit value from an AD Channel use the following to force a
12 bit AD Channel to respond with the correct value, in terms of the
range of \[0 to 4095\]

``` screen
    user_variable = ReadAD12( ANX , TRUE )
```

<span class="strong">**Command Availability:**</span>

When using <span class="strong">**ReadAD12**</span> ( ANX ) the returned
value is an 12 bit number \[0-4095\].  The user variable can be a word,
integer or long.

When using <span class="strong">**ReadAD12**</span> ( ANpX , ANnY ) the
returned value is an integer as negative values can be returned.

<span class="strong">**ReadAD12**</span> is a function that can be used
to read the built-in analog to digital converter that many
microcontroller chips include.  Port should be specified as AN0, AN1,
AN2, etc., up to the number of analog inputs available on the chip that
is in use.  Those familiar with Atmel AVR microcontrollers can also
refer to the ports as ADC0, ADC1, etc.  Refer to the datasheet for the
microcontroller chip to find the number of ports available.  (Note: it’s
perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller.)

Other functions that are similar are <span
class="strong">**ReadAD**</span> and <span
class="strong">**ReadAD10**</span>.  See the relevant Help page for the
specific usage of each function.

<span class="strong">**AD\_Delay**</span> controls is the acquisition
delay.   The default value is 20 us.  This can be changed to a longer
acquisition delay by adding the following constant.

``` screen
    #define AD_Delay 4 10us
```

<span class="strong">**ADSpeed**</span>( controls the source of the
clock for the ADC module.   It varies from one microcontroller to
another.   InternalClock is a Microchip PIC microcontroller only option
that will drive the ADC from an internal RC oscillator.  The default
value is 128.

``` screen
    'default value
    #define ADSpeed MediumSpeed


    'pre-defined constants
    #define HighSpeed 255
    #define MediumSpeed 128
    #define LowSpeed 0
```

<span class="strong">**AD\_Acquisition\_Time\_Select\_bits**</span> also
controls the Acquisition Time Select bits.   Acquisition time is the
duration that the AD charge holding capacitor remains connected to AD
channel from the instant the read is commenced is set until conversions
begins.

The default value of AD\_Acquisition\_Time\_Select\_bits is 0b100 or
decimal 4, where all three ACQT bits will be set.  To change use the
following.

``` screen
    'change the default value
    #define AD_Acquisition_Time_Select_bits 0b001    'this will only set ACQT bit 0, ACQT bits 1 and 2 will be cleared.
```

<span class="strong">**Example 1 - Read 12-bit ADC**</span>

``` screen
    #chip 16F1788, 8

    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 readings
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD12(AN0))

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next
```

<span class="strong">**Example 2 - Force a 12-bit value to be
returned**</span>

``` screen
    #chip 16F1788, 8


    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 readings
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD12(AN0), TRUE)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next
```

<span class="strong">**Example 3**</span>

This example used the diffential capabilities of ADC port and writes the
output to the EEPROM.  The output value will be in the range of \[-4095
to 4095\].

AN0 and AN2 are used for the diffential ADC reading.

``` screen
    #chip 16F1789, 8

    'USART settings
    #define USART_BAUD_RATE 9600  'Initializes USART port with 9600 baud
    #define USART_TX_BLOCKING ' wait for tx register to be empty
    wait 100 ms

    'Set the input pin direction
    Dir PORTA.0 In
    Dir PORTA.2 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        HSerPrint ReadAD12( AN0, AN2 )
        HserPrintCRLF
        'Wait 10 minutes before getting another reading
        Wait 10 min

    Next
```

<span class="strong">**See Also**</span>
<a href="readad" class="link" title="ReadAD">ReadAD</a>,
<a href="readad10" class="link" title="ReadAD10">ReadAD10</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ReadDigitalTemp</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_one_wire_devices.html" title="One Wire Devices"><link rel="prev" href="_ds18b20.html" title="DS18B20"><link rel="next" href="_readtemp.html" title="ReadTemp"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_readdigitaltemp"></a>ReadDigitalTemp</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ReadDigitalTemp</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Return the value of the sensor in two global variables. The following two lines must be included in the GCBASIC source file.</p><pre class="screen">    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required</pre><p>This method returns whole part of the sensor value in the byte variable <code class="literal">DSint</code>, the method also returns decimal part of the sensor value in the byte variable <code class="literal">DSdec</code>.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Chip Settings. Assumes the development board with with a 16F877A
    #chip 16F877A,1

    *#include &lt;DS18B20.h&gt;*

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

    ' DS18B20 port settings
    #define DQ PortC.3

    do forever

        ReadDigitalTemp

        ' Display the integer value of the sensor on the LCD
        cls
        print "Temp"
        locate 0,8
        print DSInt
        print "."
        print DSdec
        print chr(223)+"C"
        wait 2 s

    loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="readdigitaltemp"></span>ReadDigitalTemp

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ReadDigitalTemp
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

Return the value of the sensor in two global variables. The following
two lines must be included in the GCBASIC source file.

``` screen
    #include <DS18B20.h>
    #define DQ PortC.3 ; change port configuration as required
```

This method returns whole part of the sensor value in the byte variable
`DSint`, the method also returns decimal part of the sensor value in the
byte variable `DSdec`.

<span class="strong">**Example:**</span>

``` screen
    'Chip Settings. Assumes the development board with with a 16F877A
    #chip 16F877A,1

    *#include <DS18B20.h>*

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

    ' DS18B20 port settings
    #define DQ PortC.3

    do forever

        ReadDigitalTemp

        ' Display the integer value of the sensor on the LCD
        cls
        print "Temp"
        locate 0,8
        print DSInt
        print "."
        print DSdec
        print chr(223)+"C"
        wait 2 s

    loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Reading Timers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_stoptimer.html" title="StopTimer"><link rel="next" href="_smt_timers.html" title="SMT Timers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_reading_timers"></a>Reading Timers</h4></div></div></div><p>GCBASIC has the following functions to read the current timer value. They
are:</p><pre class="screen">    Timer0()
    Timer1()
    Timer2()
    Timer3()
    Timer4()
    Timer5()
    Timer6()
    Timer7()
    Timer8()
    Timer10()
    Timer12()</pre><p>Note that these functions should only be used to read the timer value.  To write the timer value, <code class="literal">settimer</code> should be used.</p><p>Not all of these functions are available on all microcontrollers. For example, if a microcontrollers has three timers, then typically only <code class="literal">Timer0</code>, <code class="literal">Timer1</code> and <code class="literal">Timer2</code> will be available.</p><p>Please refer to the datasheet for your microcontroller to determine the supported timer numbers, and if a specific timer is 8-bit or 16-bit.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="reading_timers"></span>Reading Timers

</div>

</div>

</div>

GCBASIC has the following functions to read the current timer value.
They are:

``` screen
    Timer0()
    Timer1()
    Timer2()
    Timer3()
    Timer4()
    Timer5()
    Timer6()
    Timer7()
    Timer8()
    Timer10()
    Timer12()
```

Note that these functions should only be used to read the timer value.
To write the timer value, `settimer` should be used.

Not all of these functions are available on all microcontrollers. For
example, if a microcontrollers has three timers, then typically only
`Timer0`, `Timer1` and `Timer2` will be available.

Please refer to the datasheet for your microcontroller to determine the
supported timer numbers, and if a specific timer is 8-bit or 16-bit.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ReadTable</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_miscellaneous.html" title="Miscellaneous"><link rel="next" href="_scripts.html" title="Scripts"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_readtable"></a>ReadTable</h3></div></div></div><p><span class="strong"><strong>About ReadTable</strong></span></p><p>The <code class="literal">ReadTable</code> command is used to read information from lookup tables.
<code class="literal"><span class="emphasis"><em>TableName</em></span></code> is the name of the table that is to be read, <code class="literal"><span class="emphasis"><em>Item</em></span></code> is the
line of the table to read, and <code class="literal"><span class="emphasis"><em>Output</em></span></code> is the variable to write the
retrieved value in to.</p><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ReadTable <span class="emphasis"><em>TableName, Item, Output</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal"><span class="emphasis"><em>Item</em></span></code> is 1 for the first line of the table, 2 for the second, and so on.
If the Table is more than 256 elements then <code class="literal"><span class="emphasis"><em>Item</em></span></code> must be WORD variable.
Care must be taken to ensure that the program is not instructed to read beyond the end of the table as Zero will be returned.</p><p>The type of <code class="literal"><span class="emphasis"><em>Output</em></span></code> should match the type of data stored in the table.
For example, if the table contains Word values then <code class="literal"><span class="emphasis"><em>Output</em></span></code> should be a
Word variable. If the type does not match, GCBASIC will attempt to
convert the value.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Chip Settings
    #chip 16F88, 20

    'Hardware Settings
    #define LED PORTB.0
    Dir LED Out

    'Main Routine
    ReadTable TimesTwelve, 4, Temp
    Set LED Off
    If Temp = 48 Then Set LED On

    'Lookup table named "TimesTwelve"
    Table TimesTwelve
    12
    24
    36
    48
    60
    72
    84
    96
    108
    120
    132
    144
    End Table</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_lookup_tables.html" title="Lookup Tables">Lookup Tables</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="readtable"></span>ReadTable

</div>

</div>

</div>

<span class="strong">**About ReadTable**</span>

The `ReadTable` command is used to read information from lookup tables.
`TableName` is the name of the table that is to be read, `Item` is the
line of the table to read, and `Output` is the variable to write the
retrieved value in to.

<span class="strong">**Syntax:**</span>

``` screen
    ReadTable TableName, Item, Output
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

`Item` is 1 for the first line of the table, 2 for the second, and so
on. If the Table is more than 256 elements then `Item` must be WORD
variable. Care must be taken to ensure that the program is not
instructed to read beyond the end of the table as Zero will be returned.

The type of `Output` should match the type of data stored in the table.
For example, if the table contains Word values then `Output` should be a
Word variable. If the type does not match, GCBASIC will attempt to
convert the value.

<span class="strong">**Example:**</span>

``` screen
    'Chip Settings
    #chip 16F88, 20

    'Hardware Settings
    #define LED PORTB.0
    Dir LED Out

    'Main Routine
    ReadTable TimesTwelve, 4, Temp
    Set LED Off
    If Temp = 48 Then Set LED On

    'Lookup table named "TimesTwelve"
    Table TimesTwelve
    12
    24
    36
    48
    60
    72
    84
    96
    108
    120
    132
    144
    End Table
```

<span class="strong">**For more help, see**</span>
<a href="lookup_tables" class="link" title="Lookup Tables">Lookup Tables</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ReadTemp</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_one_wire_devices.html" title="One Wire Devices"><link rel="prev" href="_readdigitaltemp.html" title="ReadDigitalTemp"><link rel="next" href="_readtemp12.html" title="ReadTemp12"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_readtemp"></a>ReadTemp</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    byte_var = ReadTemp</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">ReadTemp</code> is a  function that returns the raw value of the sensor. The following two lines must be included in the GCBASIC source file.</p><pre class="screen">    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required</pre><p><code class="literal">ReadTemp</code> reads the sensor and stores in output variable. The conversion takes up to 750ms. Readtemp carries out a full 12 bit conversion and then rounds the result to the nearest full degree Celsius.</p><p>To read the full 12 bit value of the sensor use the <code class="literal">readtemp12</code> command.</p><p>The temperature is read back in whole degree steps, and the sensor operates from -55 to + 125 degrees Celsius. Note that bit 7 is 0 for positive temperature values and 1 for negative values (ie negative values will appear as 128 + numeric value).</p><p>Note the <code class="literal">Readtemp</code> command does not work with the older DS1820 or DS18S20 as they have a different internal resolution. This command is not designed to be used with parasitically powered DS18B20 sensors, the 5V pin of the sensor must be connected.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Chip Settings. Assumes the development board with with a 16F877A
    #chip 16F877A,1

    #include &lt;DS18B20.h&gt;

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

    ' DS18B20 port settings
    #define DQ PortC.3

      ccount = 0
      CLS

    do forever
       ' The function readtemp returns the integer value of the sensor
       DSdata = readtemp

       ' Display the integer value of the sensor on the LCD
       locate 0,0
       print hex(ccount)
       print " Ceil"
       locate 0,8
       print DSdata
       print chr(223)+"C"

       wait 2 s
       ccount++

    loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="readtemp"></span>ReadTemp

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    byte_var = ReadTemp
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

`ReadTemp` is a function that returns the raw value of the sensor. The
following two lines must be included in the GCBASIC source file.

``` screen
    #include <DS18B20.h>
    #define DQ PortC.3 ; change port configuration as required
```

`ReadTemp` reads the sensor and stores in output variable. The
conversion takes up to 750ms. Readtemp carries out a full 12 bit
conversion and then rounds the result to the nearest full degree
Celsius.

To read the full 12 bit value of the sensor use the `readtemp12`
command.

The temperature is read back in whole degree steps, and the sensor
operates from -55 to + 125 degrees Celsius. Note that bit 7 is 0 for
positive temperature values and 1 for negative values (ie negative
values will appear as 128 + numeric value).

Note the `Readtemp` command does not work with the older DS1820 or
DS18S20 as they have a different internal resolution. This command is
not designed to be used with parasitically powered DS18B20 sensors, the
5V pin of the sensor must be connected.

<span class="strong">**Example:**</span>

``` screen
    'Chip Settings. Assumes the development board with with a 16F877A
    #chip 16F877A,1

    #include <DS18B20.h>

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

    ' DS18B20 port settings
    #define DQ PortC.3

      ccount = 0
      CLS

    do forever
       ' The function readtemp returns the integer value of the sensor
       DSdata = readtemp

       ' Display the integer value of the sensor on the LCD
       locate 0,0
       print hex(ccount)
       print " Ceil"
       locate 0,8
       print DSdata
       print chr(223)+"C"

       wait 2 s
       ccount++

    loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ReadTemp12</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_one_wire_devices.html" title="One Wire Devices"><link rel="prev" href="_readtemp.html" title="ReadTemp"><link rel="next" href="_ds18b20setresolution.html" title="DS18B20SetResolution"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_readtemp12"></a>ReadTemp12</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    byte_var = ReadTemp12</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">ReadTemp12</code> is a  function that returns the raw value of the sensor. The following two lines must be included in the GCBASIC source file.</p><pre class="screen">    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required</pre><p>Reads sensor and stores in output variable. The conversion takes up to 750ms. <code class="literal">Readtemp12</code> carries out a full 12 bit conversion.</p><p>This command is for advanced users only. For standard &#8216;whole degree&#8217; data use the <code class="literal">Readtemp</code> command.</p><p>The temperature is read back as the raw 12 bit data into a word variable (0.0625 degree resolution). The user must interpret the data through mathematical manipulation. See the DS18B20 datasheet for more information on the 12 bit temperature/data information construct.</p><p>The function <code class="literal">readtemp12</code> does not work with the older DS1820 or DS18S20 as they have a different internal resolution. This command is not designed to be used with parasitically powered DS18B20 sensors, the 5V pin of the sensor must be connected.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Chip Settings. Assumes the development board with with a 16F877A
    #chip 16F877A,1

    <span class="strong"><strong>#include &lt;DS18B20.h&gt;</strong></span>

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

; ----- DS18B20 port settings
    #define DQ PortC.3

; ----- Variables
    Dim TempC_100 as word   ' a variabler to handle the temperature calculations
    Dim CCOUNT, SIGNBIT, WHOLE, FRACT, DIG as Byte
    Dim TempC_100 as word   ' a variable to handle the temperature calculations

    ccount = 0
    CLS

    do forever

       'Display the integer and decimal value of the sensor on the LCD

       ' The function readtemp12 returns the raw value of the sensor.
       ' The sensor is read as a 12 bit value. Each unit equates to 0.0625 of a degree
       DSdata = readtemp12
       SignBit = DSdata / 256 / 128
       If SignBit = 0 Then goto Positive
       ' its negative!
       DSdata = ( DSdata # 0xffff ) + 1 ' take twos comp

    Positive:

       ' Convert value * 0.0625. Mulitple value by 6 then add result to multiplication of the value with 25 then divide result by 100.
       TempC_100 =  DSdata * 6
       DSdata = ( DSdata * 25 ) / 100
       TempC_100 = TempC_100 + DSdata

       Whole = TempC_100 / 100
       Fract = TempC_100 % 100
       If SignBit = 0 Then goto DisplayTemp
       Print "-"

    DisplayTemp:
       locate 1,0
       print hex(ccount)
       print " Real"
       locate 1,8
       print str(Whole)
       print "."
      ' To ensure the decimal part is two digits
       Dig = Fract / 10
       print Dig
       Dig = Fract % 10
       print Dig
       print chr(223)
       print "C"
       wait 2 s
       ccount++

    loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="readtemp12"></span>ReadTemp12

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    byte_var = ReadTemp12
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

`ReadTemp12` is a function that returns the raw value of the sensor. The
following two lines must be included in the GCBASIC source file.

``` screen
    #include <DS18B20.h>
    #define DQ PortC.3 ; change port configuration as required
```

Reads sensor and stores in output variable. The conversion takes up to
750ms. `Readtemp12` carries out a full 12 bit conversion.

This command is for advanced users only. For standard ‘whole degree’
data use the `Readtemp` command.

The temperature is read back as the raw 12 bit data into a word variable
(0.0625 degree resolution). The user must interpret the data through
mathematical manipulation. See the DS18B20 datasheet for more
information on the 12 bit temperature/data information construct.

The function `readtemp12` does not work with the older DS1820 or DS18S20
as they have a different internal resolution. This command is not
designed to be used with parasitically powered DS18B20 sensors, the 5V
pin of the sensor must be connected.

<span class="strong">**Example:**</span>

``` screen
    'Chip Settings. Assumes the development board with with a 16F877A
    #chip 16F877A,1

    #include <DS18B20.h>

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

; ----- DS18B20 port settings
    #define DQ PortC.3

; ----- Variables
    Dim TempC_100 as word   ' a variabler to handle the temperature calculations
    Dim CCOUNT, SIGNBIT, WHOLE, FRACT, DIG as Byte
    Dim TempC_100 as word   ' a variable to handle the temperature calculations

    ccount = 0
    CLS

    do forever

       'Display the integer and decimal value of the sensor on the LCD

       ' The function readtemp12 returns the raw value of the sensor.
       ' The sensor is read as a 12 bit value. Each unit equates to 0.0625 of a degree
       DSdata = readtemp12
       SignBit = DSdata / 256 / 128
       If SignBit = 0 Then goto Positive
       ' its negative!
       DSdata = ( DSdata # 0xffff ) + 1 ' take twos comp

    Positive:

       ' Convert value * 0.0625. Mulitple value by 6 then add result to multiplication of the value with 25 then divide result by 100.
       TempC_100 =  DSdata * 6
       DSdata = ( DSdata * 25 ) / 100
       TempC_100 = TempC_100 + DSdata

       Whole = TempC_100 / 100
       Fract = TempC_100 % 100
       If SignBit = 0 Then goto DisplayTemp
       Print "-"

    DisplayTemp:
       locate 1,0
       print hex(ccount)
       print " Real"
       locate 1,8
       print str(Whole)
       print "."
      ' To ensure the decimal part is two digits
       Dig = Fract / 10
       print Dig
       Dig = Fract % 10
       print Dig
       print chr(223)
       print "C"
       wait 2 s
       ccount++

    loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Repeat</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_flow_control.html" title="Flow control"><link rel="prev" href="_pause.html" title="Pause"><link rel="next" href="_select.html" title="Select"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_repeat"></a>Repeat</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Repeat <span class="emphasis"><em>times</em></span>
    ...
    <span class="emphasis"><em>program code</em></span>
    ...
    &lt;<span class="emphasis"><em>condition</em></span>&gt; Exit Repeat
    ...
    End Repeat</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Repeat</code> command is ideal for situations where a piece of code needs
to be run a set number of times. It uses less memory and runs faster
than the <code class="literal">For</code> command, and should be used wherever it is not necessary to
count how many times the code has run.</p><p>Optionally, you can specify a condition to <code class="literal">Exit</code> the Repeat-Loop
immediately.</p><p>Repeat has a maximum repeat value of 65535.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This code will flash a green light 6 times.

    #chip 16F88, 20

    #define LED PORTB.0
    dir LED out

    Repeat 6
    PulseOut LED, 1 s
    Wait 1 s
    End Repeat</pre><p><span class="strong"><strong>See Also <a class="link" href="_for.html" title="For">For</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="repeat"></span>Repeat

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Repeat times
    ...
    program code
    ...
    <condition> Exit Repeat
    ...
    End Repeat
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Repeat` command is ideal for situations where a piece of code needs
to be run a set number of times. It uses less memory and runs faster
than the `For` command, and should be used wherever it is not necessary
to count how many times the code has run.

Optionally, you can specify a condition to `Exit` the Repeat-Loop
immediately.

Repeat has a maximum repeat value of 65535.

<span class="strong">**Example:**</span>

``` screen
    'This code will flash a green light 6 times.

    #chip 16F88, 20

    #define LED PORTB.0
    dir LED out

    Repeat 6
    PulseOut LED, 1 s
    Wait 1 s
    End Repeat
```

<span class="strong">**See Also
<a href="for" class="link" title="For">For</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>RGB LED Control</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_programs.html" title="Example Programs"><link rel="prev" href="_i2c_slave_hardware.html" title="I2C Slave Hardware"><link rel="next" href="_serial_rs232_buffer_ring.html" title="Serial/RS232 Buffer Ring"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_rgb_led_control"></a>RGB LED Control</h3></div></div></div><p><span class="strong"><strong>Explanation:</strong></span></p><p>This program demonstrates how to drive an RGB LED to create 4096 different colors. Each of the three elements (red, green and blue) responds to 16 different levels. A value of 0 means the element never turns on, while a value of 15 means the element never shuts off. Values in between these two extremes vary the pulse width.</p><p>This program is an interrupt driven three channel PWM implementation.</p><p>The basic carrier frequency depends upon the microcontroller clock speed. For example, with an 8 MHz clock, the LED elements are modulated at about 260 Hz. The interrupts are generated by Timer 0. With an 8 MHz clock they occur about every 256 uS. The interrupt routine consumes about 20 uS.</p><p>Do not forget the current limiting resistors to the LED elements. A value of around 470 ohms is typical, but you may want to adjust the individual values, to balance the color response.</p><p>In this demonstration, three potentiometers are used to set the color levels using the slalom technique.</p><p><span class="strong"><strong>Demonstration program:</strong></span></p><pre class="screen">    ;----- Configuration
    #chip 16F88, 8                ;PIC16F88 running at 8 MHz
    #config mclr=off              ;reset handled internally

    ;----- Constants
    #define LED_R PortB.0         ;pin to red element
    #define LED_G PortB.1         ;pin to green element
    #define LED_B PortB.2         ;pin to blue element
    ;----- Variables
    dim redValue, greenValue, blueValue, ticks as byte
    ;----- Program
    dir PortA in                  ;three pots for inputs
    dir PortB out                 ;the LED outputs
    on interrupt Timer0Overflow call update
    initTimer0 Osc, PS0_1/2
    do
      redValue = readAD(AN0)/16   ;red -- 0 to 15
      greenValue = readAD(AN1)/16 ;green -- 0 to 15
      blueValue = readAD(AN2)/16  ;blue -- 0 to 15
    loop

    Sub update                    ;interrupt routine
      ticks++                     ;increment master timekeeper
      if ticks = 15 then          ;start of the count
        ticks = 0
        if redValue &lt;&gt; 0 then     ;only turn on if nonzero
          set LED_R on
        end if
        if greenValue &lt;&gt; 0 then
          set LED_G on
        end if
        if blueValue &lt;&gt; 0 then
          set LED_B on
        end if
      end if
      if ticks = redValue then    ;time to turn off red?
        set LED_R off
      end if
      if ticks = greenValue then  ;time to turn off green?
        set LED_G off
      end if
      if ticks = blueValue then   ;time to turn off blue?
        set LED_B off
      end if
    end sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="rgb_led_control"></span>RGB LED Control

</div>

</div>

</div>

<span class="strong">**Explanation:**</span>

This program demonstrates how to drive an RGB LED to create 4096
different colors. Each of the three elements (red, green and blue)
responds to 16 different levels. A value of 0 means the element never
turns on, while a value of 15 means the element never shuts off. Values
in between these two extremes vary the pulse width.

This program is an interrupt driven three channel PWM implementation.

The basic carrier frequency depends upon the microcontroller clock
speed. For example, with an 8 MHz clock, the LED elements are modulated
at about 260 Hz. The interrupts are generated by Timer 0. With an 8 MHz
clock they occur about every 256 uS. The interrupt routine consumes
about 20 uS.

Do not forget the current limiting resistors to the LED elements. A
value of around 470 ohms is typical, but you may want to adjust the
individual values, to balance the color response.

In this demonstration, three potentiometers are used to set the color
levels using the slalom technique.

<span class="strong">**Demonstration program:**</span>

``` screen
    ;----- Configuration
    #chip 16F88, 8                ;PIC16F88 running at 8 MHz
    #config mclr=off              ;reset handled internally

    ;----- Constants
    #define LED_R PortB.0         ;pin to red element
    #define LED_G PortB.1         ;pin to green element
    #define LED_B PortB.2         ;pin to blue element
    ;----- Variables
    dim redValue, greenValue, blueValue, ticks as byte
    ;----- Program
    dir PortA in                  ;three pots for inputs
    dir PortB out                 ;the LED outputs
    on interrupt Timer0Overflow call update
    initTimer0 Osc, PS0_1/2
    do
      redValue = readAD(AN0)/16   ;red -- 0 to 15
      greenValue = readAD(AN1)/16 ;green -- 0 to 15
      blueValue = readAD(AN2)/16  ;blue -- 0 to 15
    loop

    Sub update                    ;interrupt routine
      ticks++                     ;increment master timekeeper
      if ticks = 15 then          ;start of the count
        ticks = 0
        if redValue <> 0 then     ;only turn on if nonzero
          set LED_R on
        end if
        if greenValue <> 0 then
          set LED_G on
        end if
        if blueValue <> 0 then
          set LED_B on
        end if
      end if
      if ticks = redValue then    ;time to turn off red?
        set LED_R off
      end if
      if ticks = greenValue then  ;time to turn off green?
        set LED_G off
      end if
      if ticks = blueValue then   ;time to turn off blue?
        set LED_B off
      end if
    end sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Right</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_pad.html" title="Pad"><link rel="next" href="_rtrim.html" title="Rtrim"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_right"></a>Right</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>output</em></span> = Right(<span class="emphasis"><em>source</em></span>, <span class="emphasis"><em>count</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Right</code> function will extract the rightmost <code class="literal"><span class="emphasis"><em>count</em></span></code> characters from the input string <code class="literal"><span class="emphasis"><em>source</em></span></code>, and return them in a new string.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_BLOCKING

    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the rightmost 6 characters
    'Will display "world!"
    HSerPrint Right(TestData, 6)
    HSerPrintCRLF</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="right"></span>Right

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    output = Right(source, count)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Right` function will extract the rightmost `count` characters from
the input string `source`, and return them in a new string.

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_BLOCKING

    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the rightmost 6 characters
    'Will display "world!"
    HSerPrint Right(TestData, 6)
    HSerPrintCRLF
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Rotate</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_dectobcd_gcb.html" title="DecToBcd_GCB"><link rel="next" href="_set.html" title="Set"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rotate"></a>Rotate</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Rotate <span class="emphasis"><em>variable</em></span> {Left | Right} [Simple]</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Rotate</code> command will rotate <code class="literal"><span class="emphasis"><em>variable</em></span></code> one bit in a specified direction. The bit shifted will be placed in the Carry bit of the Status register (<code class="literal">STATUS.C</code>). <code class="literal">STATUS.C</code> acts as a ninth bit of the variable that is being rotated.</p><p><code class="literal"><span class="emphasis"><em>variable</em></span></code> supports Bytes, Word and Long variables.</p><p>When a variable is <span class="strong"><strong>rotated right</strong></span>, the bit in the <code class="literal">STATUS.C</code> location is placed into the MSB of the variable being rotated, and the LSB of the variable is placed into STATUS.C location.</p><p>When <span class="strong"><strong>rotated left</strong></span> the opposite occurs. The MSB of the variable is shifted to the <code class="literal">STATUS.C</code> bit and the LSB of the variable will contain what was previously in the <code class="literal">STATUS.C</code> bit location.</p><p>This table shows the operation of the <code class="literal">Rotate Left</code> command</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong><span class="emphasis"><em>variable</em></span></strong></span></th><th align="center" valign="top"><span class="strong"><strong>STATUS.C</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>Values at start:</p></td><td align="left" valign="top"><p>b'01110011'</p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="left" valign="top"><p>Rotate Left</p></td><td align="left" valign="top"><p>b'11100110'</p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="left" valign="top"><p>Rotate Left again</p></td><td align="left" valign="top"><p>b'11001100'</p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="left" valign="top"><p>Rotate Left third time</p></td><td align="left" valign="top"><p>b'10011001'</p></td><td align="center" valign="top"><p>1</p></td></tr></tbody></table></div><p>As you may notice the STATUS.C bit added a 0 to the rotation. So this will take 9 shifts left to get back to the original value.</p><p><span class="strong"><strong>Simple option</strong></span></p><p>Many times you want to rotate the variable around like the STATUS.C bit wasn&#8217;t there so the MSB of the variable fills the LSB of the variable on Rotate Left or the LSB fills the MSB on Rotate Right. That is where the SIMPLE option comes in. It adds a hidden step that shifts the STATUS.C bit twice so the bit moves from one end of the variable to the other.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong><span class="emphasis"><em>variable</em></span></strong></span></th><th align="center" valign="top"><span class="strong"><strong>STATUS.C</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>Values at start:</p></td><td align="left" valign="top"><p>b'01110011'</p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="left" valign="top"><p>Rotate Left</p></td><td align="left" valign="top"><p>b'11100110'</p></td><td align="center" valign="top"><p>0</p></td></tr><tr><td align="left" valign="top"><p>Rotate Left again</p></td><td align="left" valign="top"><p>b'11001101'</p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="left" valign="top"><p>Rotate Left third time</p></td><td align="left" valign="top"><p>b'10011011'</p></td><td align="center" valign="top"><p>1</p></td></tr></tbody></table></div><p>Notes:
The carry is also called SREG bit C, or simply C flag on AVR.</p><p>In some cases the Status.C or C flag may already be set because of prior operations in your program.
Therefore, it may be necessary to clear the C flag before using <code class="literal">Rotate</code>.
Use <code class="literal">Set C Off</code> before using the <code class="literal">Rotate</code> command to clear the flag.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will use Rotate to show a chasing LED.
    '8 LEDs should be connected to PORTB, one on each pin.

    #chip 16F819, 8

    'Set port direction
    Dir PORTB Out

    'Set initial state of port (bits 0 and 4 on)
    PORTB = b'00010001'

    'Chase
    C = 0
    Do
        Rotate PORTB Right Simple
        Wait 250 ms
    Loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="rotate"></span>Rotate

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Rotate variable {Left | Right} [Simple]
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Rotate` command will rotate `variable` one bit in a specified
direction. The bit shifted will be placed in the Carry bit of the Status
register (`STATUS.C`). `STATUS.C` acts as a ninth bit of the variable
that is being rotated.

`variable` supports Bytes, Word and Long variables.

When a variable is <span class="strong">**rotated right**</span>, the
bit in the `STATUS.C` location is placed into the MSB of the variable
being rotated, and the LSB of the variable is placed into STATUS.C
location.

When <span class="strong">**rotated left**</span> the opposite occurs.
The MSB of the variable is shifted to the `STATUS.C` bit and the LSB of
the variable will contain what was previously in the `STATUS.C` bit
location.

This table shows the operation of the `Rotate Left` command

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**<span class="emphasis">*variable*</span>**</span> | <span class="strong">**STATUS.C**</span> |
|:----------------------------------------|:-------------------------------------------------------------------------|:----------------------------------------:|
| Values at start:                        | b'01110011'                                                              |                    0                     |
| Rotate Left                             | b'11100110'                                                              |                    0                     |
| Rotate Left again                       | b'11001100'                                                              |                    1                     |
| Rotate Left third time                  | b'10011001'                                                              |                    1                     |

</div>

As you may notice the STATUS.C bit added a 0 to the rotation. So this
will take 9 shifts left to get back to the original value.

<span class="strong">**Simple option**</span>

Many times you want to rotate the variable around like the STATUS.C bit
wasn’t there so the MSB of the variable fills the LSB of the variable on
Rotate Left or the LSB fills the MSB on Rotate Right. That is where the
SIMPLE option comes in. It adds a hidden step that shifts the STATUS.C
bit twice so the bit moves from one end of the variable to the other.

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**<span class="emphasis">*variable*</span>**</span> | <span class="strong">**STATUS.C**</span> |
|:----------------------------------------|:-------------------------------------------------------------------------|:----------------------------------------:|
| Values at start:                        | b'01110011'                                                              |                    0                     |
| Rotate Left                             | b'11100110'                                                              |                    0                     |
| Rotate Left again                       | b'11001101'                                                              |                    1                     |
| Rotate Left third time                  | b'10011011'                                                              |                    1                     |

</div>

Notes: The carry is also called SREG bit C, or simply C flag on AVR.

In some cases the Status.C or C flag may already be set because of prior
operations in your program. Therefore, it may be necessary to clear the
C flag before using `Rotate`. Use `Set C Off` before using the `Rotate`
command to clear the flag.

<span class="strong">**Example:**</span>

``` screen
    'This program will use Rotate to show a chasing LED.
    '8 LEDs should be connected to PORTB, one on each pin.

    #chip 16F819, 8

    'Set port direction
    Dir PORTB Out

    'Set initial state of port (bits 0 and 4 on)
    PORTB = b'00010001'

    'Chase
    C = 0
    Do
        Rotate PORTB Right Simple
        Wait 250 ms
    Loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>RS232 (hardware)</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_serial_communications.html" title="Serial Communications"><link rel="prev" href="_sernreceive.html" title="SerNReceive"><link rel="next" href="_rs232_hardware_overview.html" title="RS232 Hardware Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rs232_hardware"></a>RS232 (hardware)</h4></div></div></div><p>This is the RS232 (hardware) section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="rs232_hardware"></span>RS232 (hardware)

</div>

</div>

</div>

This is the RS232 (hardware) section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>RS232 Hardware Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_hardware.html" title="RS232 (hardware)"><link rel="prev" href="_rs232_hardware.html" title="RS232 (hardware)"><link rel="next" href="_hsergetnum.html" title="HSerGetNum"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_rs232_hardware_overview"></a>RS232 Hardware Overview</h5></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>GCBASIC support programs to communicate easily using RS232.</p><p>GCBASIC included microcontroller hardware-based serial routines are intended for use on microcontrollers with built in serial communications modules - normally referred to in datasheets as USART or UART modules.  Check the microcontroller data sheet for the defined transmit and receive (TX/Rx) pins.  Make sure your program sets the Tx pin direction to Out and the Rx pin direction to In respectively.  If the RS232 lines are connected elsewhere, or the microcontroller has no USART module, then the GCBASIC software based RS232 routines must be used.</p><p>Initialization of the USART module is handled automatically from your program by defining the chip, speed, and the baudrate.  The baudrate generator values are calculated and set,  usart is set to asynchronous, usart is enabled , the receive and transmit  are enabled. See the table below.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  #chip mega328p, 16
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a USART or UART module.<br>
Microchip PIC supports USART1 and 2.<br>
Atmel AVR supports USART 1,2,3 and 4.</p><p>The following table explains the methods that can be implemented when using the GCBASIC serial routines.</p><p><span class="strong"><strong>Commands:</strong></span></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Parameters</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>Serially print numbers (byte, word, long) or  strings.</strong></span></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HSerPrint</code></p></td><td align="left" valign="top"><p>Number_constant or number_variable or string [,optional usart address]
</p><p>The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</p></td><td align="left" valign="top"><p>This subroutine prints a variable value to usart 1. No additional parameter for the usart number is used.
</p><p><code class="literal">HSerprint</code> ( mynum )
</p><p>To print a variable value to usart 2. Note the additional parameter for the usart address.
</p><p><code class="literal">HSerprint</code> ( mynum, 2 )</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Serially receive ascii number characters and assign to a word variable.</strong></span></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HSerGetNum</code></p></td><td align="left" valign="top"><p>Number_variable [,optional usart address]
</p><p>The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</p></td><td align="left" valign="top"><p>This subroutine ensures that the characters received are numbers.  When a carriage return (CR or ASCII code 13) is received this signifies the end of the character stream. Defaults to usart1.
</p><p>To receive number characters use.
</p><p><code class="literal">HSerGetNum</code> ( mynum   )
</p><p>To receive number characters via usart2 use.
</p><p><code class="literal">HSerGetNum</code> ( mynum, 2 )</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Serially receive characters as a string.</strong></span></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HSerGetString</code></p></td><td align="left" valign="top"><p>User_string_variable [,optional usart address]
</p><p>The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</p></td><td align="left" valign="top"><p>This subroutine ensures that the characters treated as a string.  When a carriage return (CR or ASCII code 13) is received this signifies the end of the character stream. GCBASIC will determine the default buffering size for strings. See here for more help on string sizes. Defaults to usart1.
</p><p>To receive a string use.<br>
<code class="literal">HserGetString</code> ( mystring )
</p><p>To a string via usart2 use.<br>
<code class="literal">HserGetString</code> ( mystring, 2 )</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Serially receive a character using a subroutine.</strong></span></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HSerReceive</code></p></td><td align="left" valign="top"><p>byte_variable</p></td><td align="left" valign="top"><p>This subroutine handles the incoming characters as raw ASCII values.
</p><p>The subroutine receives a single byte value in the range of 0 to 255.
</p><p>The subroutine can receive a byte from usart 1, 2, 3 or 4.
</p><p>The public variable comport  can be set before the use of this method to select the desired usart address.
</p><p>If &#8216;#define USART_BLOCKING&#8217; is defined then this methods will wait until it a byte is received.
</p><p>If &#8216;#define USART_BLOCKING&#8217; is NOT defined then the method will returns ASCII value received or the method will return the value of 255 to indicate not ASCII data was received.  You can change the value returned by setting redefining &#8216;#define DefaultUsartReturnValue = [0-255]&#8217;.  When &#8216;#define USART_BLOCKING&#8217; is NOT defined  this method becomes a non- blocking method which allows for the testing and handling of incoming ASCII data within the user program.
</p><p>To receive an ASCII byte value in blocking mode use. Defaults to usart1
</p><p>#define USART_BLOCKING<br>
&#8230;<br>
&#8230;<br>
<code class="literal">HSerReceive</code> (user_byte_variable)
</p><p>To receive an ASCII byte value via usart 3 using blocking mode use
</p><p>#define USART_BLOCKING<br>
&#8230;<br>
&#8230;<br>
Comport = 3<br>
<code class="literal">HSerReceive</code> ( user_byte_variable)
</p><p>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined. This method fefaults to usart1
</p><p><code class="literal">HSerReceive</code> (user_byte_variable)
</p><p>To receive an ASCII byte value via usart 4 using non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.
</p><p>Comport = 4<br>
<code class="literal">HSerReceive</code> ( user_byte_variable )</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Serially receive a character using a function specifically via usart1.</strong></span></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HSerReceive1</code></p></td><td align="left" valign="top"><p>none</p></td><td align="left" valign="top"><p>This function handles the incoming characters as raw ASCII values.
</p><p>The function receives a single byte value in the range of 0 to 255.
</p><p>The function can return only a byte value from usart 1.
</p><p>The blocking and non-blocking mode and the methods are the same as shown in the previous method.
</p><p>To receive an ASCII byte value via usart 1 using blocking mode use
</p><p>#define USART_BLOCKING<br>
&#8230;<br>
&#8230;<br>
user_number_variable = <code class="literal">HSerReceive1</code>
</p><p>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.
</p><p>user_number_variable = <code class="literal">HSerReceive1</code></p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Serially receive a character using a function specifically via usart2</strong></span></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HSerReceive2</code></p></td><td align="left" valign="top"><p>none</p></td><td align="left" valign="top"><p>This function handles the incoming characters as raw ASCII values.
</p><p>The function receives a single byte value in the range of 0 to 255.
</p><p>The function can receive only a byte value from usart 2.
</p><p>The blocking and non-blocking mode and the methods are the same as shown in the previous method.
</p><p>To receive an ASCII byte value via usart 2 using blocking mode use
</p><p>#define USART_BLOCKING<br>
&#8230;<br>
&#8230;<br>
user_byte_variable = <code class="literal">HSerReceive2</code>
</p><p>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.
</p><p>user_byte_variable = <code class="literal">HSerReceive2</code></p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Serially receive a character using a function from either usart ports using a parameter to select the usart.</strong></span></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HSerReceiveFrom</code></p></td><td align="left" valign="top"><p>Usart_number,<br>
 Default is 1</p></td><td align="left" valign="top"><p>This function handles the incoming characters as raw ASCII values.
</p><p>The function return a single byte value in the range of 0 to 255.
</p><p>The function can receive only a byte value from usart 1 and usart 2
</p><p>The blocking and non-blocking mode and the methods are the same as shown in the previous method.
</p><p>To receive an ASCII byte value via usart 1 using blocking mode use
</p><p>#define USART_BLOCKING<br>
&#8230;<br>
&#8230;<br>
user_byte_variable = <code class="literal">HSerReceiveFrom</code>
</p><p>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.
</p><p>'Chosen_usart = 2<br>
user_byte_variable = <code class="literal">HSerReceiveFrom</code> (2)</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Serially send a byte using any of the usart ports.</strong></span></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HSerSend</code></p></td><td align="left" valign="top"><p>Byte or byte_variable   [,optional usart address]  + The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</p></td><td align="left" valign="top"><p>This subroutine sends a byte value to usart 1. No additional parameter for the usart number is used.
</p><p><code class="literal">HSerSend</code>( user_byte )
</p><p>To print a variable value to usart 2. Note the additional parameter for the usart address.
</p><p><code class="literal">HSerSend</code> ( user_byte, 2 )</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Serially send a byte and a CR&amp;LF using any of the usart ports</strong></span></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HSerPrintByteCRLF</code></p></td><td align="left" valign="top"><p>Byte or byte_variable +  [,optional usart address] The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</p></td><td align="left" valign="top"><p>This subroutine sends a byte value to usart 1.
</p><p><code class="literal">HserPrintCRLF</code> users_byte,2</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Serially send  CR&amp;LF (can be multiple) using any of the usart ports</strong></span></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HSerPrintCRLF</code></p></td><td align="left" valign="top"><p>Number of CR&amp;LF to be sent + [,optional usart address] The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</p></td><td align="left" valign="top"><p>This subroutine sends a CR&amp;LF to port 2.
</p><p></p><p><code class="literal">HserPrintCRLF</code> 1,2    ' Will send a CR &amp; LF out of comport 2 to the terminal</p></td></tr></tbody></table></div><p><span class="strong"><strong>Constants</strong></span>
These constants affect the operation of the hardware RS232 routines:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">USART_BAUD_RATE</code></p></td><td align="left" valign="top"><p>Baud rate (in bps) for the routines to operate at.</p></td><td align="left" valign="top"><p>No default, user must enter a baud. Doesn&#8217;t have to be a standard baud.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USART_BLOCKING</code></p></td><td align="left" valign="top"><p>If defined, this constant will cause the USART routines to wait until data
can be sent or received.</p></td><td align="left" valign="top"><p>No parameter needed. Use &#8220;#defining&#8221; it implement the action.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USART_TX_BLOCKING</code></p></td><td align="left" valign="top"><p>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</p></td><td align="left" valign="top"><p>No parameter needed. Use &#8220;#defining&#8221; it implement the action.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USART2_BAUD_RATE</code></p></td><td align="left" valign="top"><p>Baud rate (in bps) for the routines to operate at.</p></td><td align="left" valign="top"><p>No default, user must enter a baud. Doesn&#8217;t have to be a standard baud.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USART2_BLOCKING</code></p></td><td align="left" valign="top"><p>If defined, this constant will cause the USART routines to wait until data
can be sent or received.</p></td><td align="left" valign="top"><p>No parameter needed. Use &#8220;#defining&#8221; it implement the action.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USART2_TX_BLOCKING</code></p></td><td align="left" valign="top"><p>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</p></td><td align="left" valign="top"><p>No parameter needed. Use &#8220;#defining&#8221; it implement the action.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USART3_BAUD_RATE</code></p></td><td align="left" valign="top"><p>Baud rate (in bps) for the routines to operate at.</p></td><td align="left" valign="top"><p>No default, user must enter a baud. Doesn&#8217;t have to be a standard baud.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USART3_BLOCKING</code></p></td><td align="left" valign="top"><p>If defined, this constant will cause the USART routines to wait until data
can be sent or received.</p></td><td align="left" valign="top"><p>No parameter needed. Use &#8220;#defining&#8221; it implement the action.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USART3_TX_BLOCKING</code></p></td><td align="left" valign="top"><p>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</p></td><td align="left" valign="top"><p>No parameter needed. Use &#8220;#defining&#8221; it implement the action.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USART4_BAUD_RATE</code></p></td><td align="left" valign="top"><p>Baud rate (in bps) for the routines to operate at.</p></td><td align="left" valign="top"><p>No default, user must enter a baud. Doesn&#8217;t have to be a standard baud.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USART4_BLOCKING</code></p></td><td align="left" valign="top"><p>If defined, this constant will cause the USART routines to wait until data
can be sent or received.</p></td><td align="left" valign="top"><p>No parameter needed. Use &#8220;#defining&#8221; it implement the action.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USART4_TX_BLOCKING</code></p></td><td align="left" valign="top"><p>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</p></td><td align="left" valign="top"><p>No parameter needed. Use &#8220;#defining&#8221; it implement the action.
<br>
<br></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">USART_DELAY</code></p></td><td align="left" valign="top"><p>This is the delay between characters.</p></td><td align="left" valign="top"><p><code class="literal">1 ms</code>
</p><p>To disable this delay between characters &#8230;&#8203;  Use #define  <code class="literal">USART_DELAY  0 MS</code>, or,
To disable this delay between characters &#8230;&#8203;  Use #define  <code class="literal">USART_DELAY  OFF</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHECK_USART_BAUD_RATE</code></p></td><td align="left" valign="top"><p>Instruct the compiler to show the real BPS to be used</p></td><td align="left" valign="top"><p>Not the default operation</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ISSUE_CHECK_USART_BAUD_RATE_WARNING</code></p></td><td align="left" valign="top"><p>Instruct the compiler to show BPS calculation errors</p></td><td align="left" valign="top"><p>Not the default operation</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SerPrintCR</code></p></td><td align="left" valign="top"><p>Causes a Carriage return to be sent after every HserPrint automatically.</p></td><td align="left" valign="top"><p>No parameter needed. User &#8220;#defining&#8221; it implements the action</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SerPrintLF</code></p></td><td align="left" valign="top"><p>Causes a LineFeed to be sent after every HserPrint. Some communications require both CR and LF</p></td><td align="left" valign="top"><p>No parameter needed. User &#8220;#defining&#8221; it implements the action</p></td></tr></tbody></table></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="rs232_hardware_overview"></span>RS232 Hardware Overview

</div>

</div>

</div>

<span class="strong">**Introduction**</span>

GCBASIC support programs to communicate easily using RS232.

GCBASIC included microcontroller hardware-based serial routines are
intended for use on microcontrollers with built in serial communications
modules - normally referred to in datasheets as USART or UART modules.
Check the microcontroller data sheet for the defined transmit and
receive (TX/Rx) pins. Make sure your program sets the Tx pin direction
to Out and the Rx pin direction to In respectively. If the RS232 lines
are connected elsewhere, or the microcontroller has no USART module,
then the GCBASIC software based RS232 routines must be used.

Initialization of the USART module is handled automatically from your
program by defining the chip, speed, and the baudrate. The baudrate
generator values are calculated and set, usart is set to asynchronous,
usart is enabled , the receive and transmit are enabled. See the table
below.

<span class="strong">**Example:**</span>

``` screen
  #chip mega328p, 16
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a USART or UART module.  
Microchip PIC supports USART1 and 2.  
Atmel AVR supports USART 1,2,3 and 4.

The following table explains the methods that can be implemented when
using the GCBASIC serial routines.

<span class="strong">**Commands:**</span>

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Command</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Parameters</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Example</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>Serially print numbers (byte, word, long) or strings.</strong></span></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HSerPrint</code></p></td>
<td style="text-align: left;"><p>Number_constant or number_variable or string [,optional usart address]</p>
<p>The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</p></td>
<td style="text-align: left;"><p>This subroutine prints a variable value to usart 1. No additional parameter for the usart number is used.</p>
<p><code class="literal">HSerprint</code> ( mynum )</p>
<p>To print a variable value to usart 2. Note the additional parameter for the usart address.</p>
<p><code class="literal">HSerprint</code> ( mynum, 2 )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>Serially receive ascii number characters and assign to a word variable.</strong></span></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HSerGetNum</code></p></td>
<td style="text-align: left;"><p>Number_variable [,optional usart address]</p>
<p>The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</p></td>
<td style="text-align: left;"><p>This subroutine ensures that the characters received are numbers. When a carriage return (CR or ASCII code 13) is received this signifies the end of the character stream. Defaults to usart1.</p>
<p>To receive number characters use.</p>
<p><code class="literal">HSerGetNum</code> ( mynum )</p>
<p>To receive number characters via usart2 use.</p>
<p><code class="literal">HSerGetNum</code> ( mynum, 2 )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>Serially receive characters as a string.</strong></span></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HSerGetString</code></p></td>
<td style="text-align: left;"><p>User_string_variable [,optional usart address]</p>
<p>The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</p></td>
<td style="text-align: left;"><p>This subroutine ensures that the characters treated as a string. When a carriage return (CR or ASCII code 13) is received this signifies the end of the character stream. GCBASIC will determine the default buffering size for strings. See here for more help on string sizes. Defaults to usart1.</p>
<p>To receive a string use.<br />
<code class="literal">HserGetString</code> ( mystring )</p>
<p>To a string via usart2 use.<br />
<code class="literal">HserGetString</code> ( mystring, 2 )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>Serially receive a character using a subroutine.</strong></span></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HSerReceive</code></p></td>
<td style="text-align: left;"><p>byte_variable</p></td>
<td style="text-align: left;"><p>This subroutine handles the incoming characters as raw ASCII values.</p>
<p>The subroutine receives a single byte value in the range of 0 to 255.</p>
<p>The subroutine can receive a byte from usart 1, 2, 3 or 4.</p>
<p>The public variable comport can be set before the use of this method to select the desired usart address.</p>
<p>If ‘#define USART_BLOCKING’ is defined then this methods will wait until it a byte is received.</p>
<p>If ‘#define USART_BLOCKING’ is NOT defined then the method will returns ASCII value received or the method will return the value of 255 to indicate not ASCII data was received. You can change the value returned by setting redefining ‘#define DefaultUsartReturnValue = [0-255]’. When ‘#define USART_BLOCKING’ is NOT defined this method becomes a non- blocking method which allows for the testing and handling of incoming ASCII data within the user program.</p>
<p>To receive an ASCII byte value in blocking mode use. Defaults to usart1</p>
<p>#define USART_BLOCKING<br />
…<br />
…<br />
<code class="literal">HSerReceive</code> (user_byte_variable)</p>
<p>To receive an ASCII byte value via usart 3 using blocking mode use</p>
<p>#define USART_BLOCKING<br />
…<br />
…<br />
Comport = 3<br />
<code class="literal">HSerReceive</code> ( user_byte_variable)</p>
<p>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined. This method fefaults to usart1</p>
<p><code class="literal">HSerReceive</code> (user_byte_variable)</p>
<p>To receive an ASCII byte value via usart 4 using non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.</p>
<p>Comport = 4<br />
<code class="literal">HSerReceive</code> ( user_byte_variable )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>Serially receive a character using a function specifically via usart1.</strong></span></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HSerReceive1</code></p></td>
<td style="text-align: left;"><p>none</p></td>
<td style="text-align: left;"><p>This function handles the incoming characters as raw ASCII values.</p>
<p>The function receives a single byte value in the range of 0 to 255.</p>
<p>The function can return only a byte value from usart 1.</p>
<p>The blocking and non-blocking mode and the methods are the same as shown in the previous method.</p>
<p>To receive an ASCII byte value via usart 1 using blocking mode use</p>
<p>#define USART_BLOCKING<br />
…<br />
…<br />
user_number_variable = <code class="literal">HSerReceive1</code></p>
<p>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.</p>
<p>user_number_variable = <code class="literal">HSerReceive1</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>Serially receive a character using a function specifically via usart2</strong></span></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HSerReceive2</code></p></td>
<td style="text-align: left;"><p>none</p></td>
<td style="text-align: left;"><p>This function handles the incoming characters as raw ASCII values.</p>
<p>The function receives a single byte value in the range of 0 to 255.</p>
<p>The function can receive only a byte value from usart 2.</p>
<p>The blocking and non-blocking mode and the methods are the same as shown in the previous method.</p>
<p>To receive an ASCII byte value via usart 2 using blocking mode use</p>
<p>#define USART_BLOCKING<br />
…<br />
…<br />
user_byte_variable = <code class="literal">HSerReceive2</code></p>
<p>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.</p>
<p>user_byte_variable = <code class="literal">HSerReceive2</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>Serially receive a character using a function from either usart ports using a parameter to select the usart.</strong></span></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HSerReceiveFrom</code></p></td>
<td style="text-align: left;"><p>Usart_number,<br />
Default is 1</p></td>
<td style="text-align: left;"><p>This function handles the incoming characters as raw ASCII values.</p>
<p>The function return a single byte value in the range of 0 to 255.</p>
<p>The function can receive only a byte value from usart 1 and usart 2</p>
<p>The blocking and non-blocking mode and the methods are the same as shown in the previous method.</p>
<p>To receive an ASCII byte value via usart 1 using blocking mode use</p>
<p>#define USART_BLOCKING<br />
…<br />
…<br />
user_byte_variable = <code class="literal">HSerReceiveFrom</code></p>
<p>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.</p>
<p>'Chosen_usart = 2<br />
user_byte_variable = <code class="literal">HSerReceiveFrom</code> (2)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>Serially send a byte using any of the usart ports.</strong></span></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HSerSend</code></p></td>
<td style="text-align: left;"><p>Byte or byte_variable [,optional usart address] + The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</p></td>
<td style="text-align: left;"><p>This subroutine sends a byte value to usart 1. No additional parameter for the usart number is used.</p>
<p><code class="literal">HSerSend</code>( user_byte )</p>
<p>To print a variable value to usart 2. Note the additional parameter for the usart address.</p>
<p><code class="literal">HSerSend</code> ( user_byte, 2 )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>Serially send a byte and a CR&amp;LF using any of the usart ports</strong></span></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HSerPrintByteCRLF</code></p></td>
<td style="text-align: left;"><p>Byte or byte_variable + [,optional usart address] The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</p></td>
<td style="text-align: left;"><p>This subroutine sends a byte value to usart 1.</p>
<p><code class="literal">HserPrintCRLF</code> users_byte,2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="strong"><strong>Serially send CR&amp;LF (can be multiple) using any of the usart ports</strong></span></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HSerPrintCRLF</code></p></td>
<td style="text-align: left;"><p>Number of CR&amp;LF to be sent + [,optional usart address] The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</p></td>
<td style="text-align: left;"><p>This subroutine sends a CR&amp;LF to port 2.</p>
<p><code class="literal">HserPrintCRLF</code> 1,2 ' Will send a CR &amp; LF out of comport 2 to the terminal</p></td>
</tr>
</tbody>
</table>

</div>

<span class="strong">**Constants**</span> These constants affect the
operation of the hardware RS232 routines:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constant Name</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Default Value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">USART_BAUD_RATE</code></p></td>
<td style="text-align: left;"><p>Baud rate (in bps) for the routines to operate at.</p></td>
<td style="text-align: left;"><p>No default, user must enter a baud. Doesn’t have to be a standard baud.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">USART_BLOCKING</code></p></td>
<td style="text-align: left;"><p>If defined, this constant will cause the USART routines to wait until data can be sent or received.</p></td>
<td style="text-align: left;"><p>No parameter needed. Use “#defining” it implement the action.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">USART_TX_BLOCKING</code></p></td>
<td style="text-align: left;"><p>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</p></td>
<td style="text-align: left;"><p>No parameter needed. Use “#defining” it implement the action.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">USART2_BAUD_RATE</code></p></td>
<td style="text-align: left;"><p>Baud rate (in bps) for the routines to operate at.</p></td>
<td style="text-align: left;"><p>No default, user must enter a baud. Doesn’t have to be a standard baud.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">USART2_BLOCKING</code></p></td>
<td style="text-align: left;"><p>If defined, this constant will cause the USART routines to wait until data can be sent or received.</p></td>
<td style="text-align: left;"><p>No parameter needed. Use “#defining” it implement the action.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">USART2_TX_BLOCKING</code></p></td>
<td style="text-align: left;"><p>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</p></td>
<td style="text-align: left;"><p>No parameter needed. Use “#defining” it implement the action.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">USART3_BAUD_RATE</code></p></td>
<td style="text-align: left;"><p>Baud rate (in bps) for the routines to operate at.</p></td>
<td style="text-align: left;"><p>No default, user must enter a baud. Doesn’t have to be a standard baud.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">USART3_BLOCKING</code></p></td>
<td style="text-align: left;"><p>If defined, this constant will cause the USART routines to wait until data can be sent or received.</p></td>
<td style="text-align: left;"><p>No parameter needed. Use “#defining” it implement the action.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">USART3_TX_BLOCKING</code></p></td>
<td style="text-align: left;"><p>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</p></td>
<td style="text-align: left;"><p>No parameter needed. Use “#defining” it implement the action.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">USART4_BAUD_RATE</code></p></td>
<td style="text-align: left;"><p>Baud rate (in bps) for the routines to operate at.</p></td>
<td style="text-align: left;"><p>No default, user must enter a baud. Doesn’t have to be a standard baud.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">USART4_BLOCKING</code></p></td>
<td style="text-align: left;"><p>If defined, this constant will cause the USART routines to wait until data can be sent or received.</p></td>
<td style="text-align: left;"><p>No parameter needed. Use “#defining” it implement the action.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">USART4_TX_BLOCKING</code></p></td>
<td style="text-align: left;"><p>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</p></td>
<td style="text-align: left;"><p>No parameter needed. Use “#defining” it implement the action.<br />
<br />
</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">USART_DELAY</code></p></td>
<td style="text-align: left;"><p>This is the delay between characters.</p></td>
<td style="text-align: left;"><p><code class="literal">1 ms</code></p>
<p>To disable this delay between characters …​ Use #define <code class="literal">USART_DELAY  0 MS</code>, or, To disable this delay between characters …​ Use #define <code class="literal">USART_DELAY  OFF</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">CHECK_USART_BAUD_RATE</code></p></td>
<td style="text-align: left;"><p>Instruct the compiler to show the real BPS to be used</p></td>
<td style="text-align: left;"><p>Not the default operation</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">ISSUE_CHECK_USART_BAUD_RATE_WARNING</code></p></td>
<td style="text-align: left;"><p>Instruct the compiler to show BPS calculation errors</p></td>
<td style="text-align: left;"><p>Not the default operation</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">SerPrintCR</code></p></td>
<td style="text-align: left;"><p>Causes a Carriage return to be sent after every HserPrint automatically.</p></td>
<td style="text-align: left;"><p>No parameter needed. User “#defining” it implements the action</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">SerPrintLF</code></p></td>
<td style="text-align: left;"><p>Causes a LineFeed to be sent after every HserPrint. Some communications require both CR and LF</p></td>
<td style="text-align: left;"><p>No parameter needed. User “#defining” it implements the action</p></td>
</tr>
</tbody>
</table>

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>RS232 (software)</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_serial_communications.html" title="Serial Communications"><link rel="prev" href="_serial_communications.html" title="Serial Communications"><link rel="next" href="_rs232_software_overview.html" title="RS232 Software Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rs232_software"></a>RS232 (software)</h4></div></div></div><p>This is the Software Serial Communications section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="rs232_software"></span>RS232 (software)

</div>

</div>

</div>

This is the Software Serial Communications section of the Help file.
Please refer the sub-sections for details using the contents/folder
view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>RS232 (software optimised)</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_serial_communications.html" title="Serial Communications"><link rel="prev" href="_serprint.html" title="SerPrint"><link rel="next" href="_rs232_software_overview_optimised.html" title="RS232 Software Overview - Optimised"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rs232_software_optimised"></a>RS232 (software optimised)</h4></div></div></div><p>This is the Software Serial Communications section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="rs232_software_optimised"></span>RS232 (software optimised)

</div>

</div>

</div>

This is the Software Serial Communications section of the Help file.
Please refer the sub-sections for details using the contents/folder
view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>RS232 Software Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_software.html" title="RS232 (software)"><link rel="prev" href="_rs232_software.html" title="RS232 (software)"><link rel="next" href="_initser.html" title="InitSer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_rs232_software_overview"></a>RS232 Software Overview</h5></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>These routines allow the microcontroller to send and receive RS232 data.</p><p>All functions are implemented using software, so no special hardware is
required on the microcontroller. However, if the microcontroller has a
hardware serial module (usually referred to as UART or USART), and the
serial data lines are connected to the appropriate pins, the hardware
routines should be used for smaller code, improved reliability and
higher baud rates.</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>These constants are used to control settings for the RS232 serial
communication routines. To set them, place a line in the main program
file that uses <code class="literal">#define</code> to assign a value to the particular constant.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name/s</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">SendALow</code>, <code class="literal">SendBLow</code>, <code class="literal">SendCLow</code></p></td><td align="left" valign="top"><p>These are used to define the commands used to send a low (0) bit on
serial channels A, B and C respectively.</p></td><td align="left" valign="top"><p>No Default<br>
<span class="strong"><strong>Must be defined</strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SendAHigh</code>, <code class="literal">SendBHigh</code>, <code class="literal">SendCHigh</code></p></td><td align="left" valign="top"><p>These are used to define the commands used to send a high (1) bit on
serial channels A, B and C respectively.</p></td><td align="left" valign="top"><p>No Default<br>
<span class="strong"><strong>Must be defined</strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">RecALow</code>, <code class="literal">RecBLow</code>, <code class="literal">RecCLow</code></p></td><td align="left" valign="top"><p>The condition that is true when a low bit is being received</p></td><td align="left" valign="top"><p><code class="literal">Sys232Temp.0 OFF</code><br>
<span class="strong"><strong>Must be defined</strong></span></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">RecAHigh</code>, <code class="literal">RecBHigh</code>, <code class="literal">RecCHigh</code></p></td><td align="left" valign="top"><p>The condition that is true when a high bit is being received</p></td><td align="left" valign="top"><p><code class="literal">Sys232Temp.0 ON</code><br>
<span class="strong"><strong>Must be defined</strong></span></p></td></tr></tbody></table></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="rs232_software_overview"></span>RS232 Software Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

These routines allow the microcontroller to send and receive RS232 data.

All functions are implemented using software, so no special hardware is
required on the microcontroller. However, if the microcontroller has a
hardware serial module (usually referred to as UART or USART), and the
serial data lines are connected to the appropriate pins, the hardware
routines should be used for smaller code, improved reliability and
higher baud rates.

<span class="strong">**Relevant Constants:**</span>

These constants are used to control settings for the RS232 serial
communication routines. To set them, place a line in the main program
file that uses `#define` to assign a value to the particular constant.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constant Name/s</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Default Value</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">SendALow</code>, <code class="literal">SendBLow</code>, <code class="literal">SendCLow</code></p></td>
<td style="text-align: left;"><p>These are used to define the commands used to send a low (0) bit on serial channels A, B and C respectively.</p></td>
<td style="text-align: left;"><p>No Default<br />
<span class="strong"><strong>Must be defined</strong></span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">SendAHigh</code>, <code class="literal">SendBHigh</code>, <code class="literal">SendCHigh</code></p></td>
<td style="text-align: left;"><p>These are used to define the commands used to send a high (1) bit on serial channels A, B and C respectively.</p></td>
<td style="text-align: left;"><p>No Default<br />
<span class="strong"><strong>Must be defined</strong></span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">RecALow</code>, <code class="literal">RecBLow</code>, <code class="literal">RecCLow</code></p></td>
<td style="text-align: left;"><p>The condition that is true when a low bit is being received</p></td>
<td style="text-align: left;"><p><code class="literal">Sys232Temp.0 OFF</code><br />
<span class="strong"><strong>Must be defined</strong></span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">RecAHigh</code>, <code class="literal">RecBHigh</code>, <code class="literal">RecCHigh</code></p></td>
<td style="text-align: left;"><p>The condition that is true when a high bit is being received</p></td>
<td style="text-align: left;"><p><code class="literal">Sys232Temp.0 ON</code><br />
<span class="strong"><strong>Must be defined</strong></span></p></td>
</tr>
</tbody>
</table>

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>RS232 Software Overview - Optimised</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_software_optimised.html" title="RS232 (software optimised)"><link rel="prev" href="_rs232_software_optimised.html" title="RS232 (software optimised)"><link rel="next" href="_sernsend.html" title="SerNSend"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_rs232_software_overview_optimised"></a>RS232 Software Overview - Optimised</h5></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>These routines allow the microcontroller to send and receive RS232 data.</p><p>SoftSerial is a library for the GCBASIC compiler and works on AVR and PIC microcontrollers.
These routines allow the microcontroller to send and receive RS232 data.
All functions are implemented using software, so no special hardware is required on the microcontroller.
SoftSerial uses ASM routines for minimal overhead.
If the microcontroller has a hardware serial module (usually referred to as UART or USART) the hardware routines can be used too.</p><p><span class="strong"><strong>Features</strong></span></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">3 independent channels Ser1&#8230;&#8203; , Ser2&#8230;&#8203; , Ser3&#8230;&#8203;</li><li class="listitem">I/O pins user configurable</li><li class="listitem">polarity can be inverted</li><li class="listitem">freely adjustable baud rate</li><li class="listitem"><p class="simpara">maximum baudrate depends on MCU speed</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">PIC@ 1Mhz    9600 baud</li><li class="listitem">PIC@ 4Mhz   38400 baud</li><li class="listitem">PIC@ 8Mhz   64000 baud</li><li class="listitem">PIC@16Mhz  128000 baud</li><li class="listitem">AVR@ 1Mhz   28800 baud</li><li class="listitem">AVR@ 8Mhz  115200 baud</li><li class="listitem">AVR@16Mhz  460800 baud</li></ul></div></li><li class="listitem">5 - 8  data bits</li><li class="listitem">1 or 2 stop bits</li><li class="listitem">parity bit not supported</li></ul></div><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>These constants are used to control settings for the RS232 serial
communication routines. To set them, place a line in the main program
file that uses <code class="literal">#define</code> to assign a value to the particular constant.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="left" valign="top">Constant Name/s</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Valid Values</th><th align="left" valign="top">Default value</th></tr></thead><tbody><tr><td align="left" valign="top"><p>SER1_TXPORT,
SER2_TXPORT,
SER3_TXPORT</p></td><td align="left" valign="top"><p>These are used to define the port for sending on serial channels 1, 2 and 3 respectively. Note, that we also have to define a PortPin (see next line). It is not necessary to define this, if we want to receive only.
Sample:  #define SER1_TXPORT PortB</p></td><td align="left" valign="top"><p>PORTA - PORTx</p></td><td align="left" valign="top"><p>No default defined.
An appropiate constant must be defined.</p></td></tr><tr><td align="left" valign="top"><p>SER1_TXPIN,
SER2_TXPIN,
SER3_TXPIN</p></td><td align="left" valign="top"><p>These are used to define the pin (the corresponding bit) for sending on serial channels 1, 2 and 3 respectively.
Sample:  #define SER1_TXPIN 0</p></td><td align="left" valign="top"><p>0 - 7</p></td><td align="left" valign="top"><p>No default defined.
An appropiate constant must be defined to enable the TX port.</p></td></tr><tr><td align="left" valign="top"><p>SER1_RXPORT,
SER2_RXPORT,
SER3_RXPORT</p></td><td align="left" valign="top"><p>These are used to define the port for receiving on serial channels 1, 2 and 3 respectively. Note, that we also have to define a PortPin (see next line). It is not necessary to define this, if we want to receive only.
Sample:  #define SER1_RXPORT PortA</p></td><td align="left" valign="top"><p>PORTA - PORTx</p></td><td align="left" valign="top"><p>No default defined.
An appropiate constant must be defined to enable the TX port.</p></td></tr><tr><td align="left" valign="top"><p>SER1_RXPIN,
SER2_RXPIN,
SER3_RXPIN</p></td><td align="left" valign="top"><p>These are used to define the pin (the corresponding bit) for receiving on serial channels 1, 2 and 3 respectively. It is not necessary to define this, if we want to send only.
Sample:  #define SER1_RXPIN 5</p></td><td align="left" valign="top"><p>0 - 7</p></td><td align="left" valign="top"><p>No default defined.
An appropiate constant must be defined to enable the RX port.</p></td></tr><tr><td align="left" valign="top"><p>SER1_BAUD,
SER2_BAUD,
SER3_BAUD</p></td><td align="left" valign="top"><p>These are used to define the baudrate for sending and receiving on serial channels 1, 2 and 3 respectively. It is not necessary to define this, if we want to send only.
Sample:  #define SER1_BAUD 19200</p></td><td align="left" valign="top"><p>75 - 512000</p></td><td align="left" valign="top"><p>No default defined.
An appropiate constant must be defined to enable the RX port.</p></td></tr><tr><td align="left" valign="top"><p>SER1_DATABITS,
SER2_DATABITS,
SER3_DATABITS</p></td><td align="left" valign="top"><p>These are used to define the databits for sending and receiving on serial channels 1, 2 and 3 respectively.
Sample:  #define SER1_DATABITS 7</p></td><td align="left" valign="top"><p>5 - 8</p></td><td align="left" valign="top"><p>Optional
Default = 8</p></td></tr><tr><td align="left" valign="top"><p>SER1_STOPBITS,
SER2_STOPBITS,
SER3_STOPBITS</p></td><td align="left" valign="top"><p>These are used to define the stopbits for sending and receiving on serial channels 1, 2 and 3 respectively.
Sample:  #define SER1_STOPBITS 2</p></td><td align="left" valign="top"><p>1, 2</p></td><td align="left" valign="top"><p>Optional
Default = 1</p></td></tr><tr><td align="left" valign="top"><p>SER1_INVERT,
SER2_INVERT,
SER3_INVERT</p></td><td align="left" valign="top"><p>These are used to define the polarity for sending and receiving on serial channels 1, 2 and 3 respectively. If it is "On", then high bits will be changed to low, and low to high. This is useful for connection to a PCs native serial port or USB-serial converters with  MAX232.
Sample:  #define SER1_INVERT On</p></td><td align="left" valign="top"><p>On, Off</p></td><td align="left" valign="top"><p>Optional
Default = Off</p></td></tr><tr><td align="left" valign="top"><p>SER1_RXNOWAIT,
SER2_RXNOWAIT,
SER3_RXNOWAIT</p></td><td align="left" valign="top"><p>These are used to define, if SerNReceive waits for the startbits when receiving on serial channels 1, 2 and 3 respectively. If it is "On", then SerNReceive does not wait for the startbits edge, but directly reads the serial data. Also the time for delaying the startbit is shortened. This is useful when calling SerNReceive from an Interrupt-Service-Routine.
Sample:  #define SER1_RXNOWAIT On</p></td><td align="left" valign="top"><p>On, Off</p></td><td align="left" valign="top"><p>Optional
Default = Off</p></td></tr></tbody></table></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="rs232_software_overview_optimised"></span>RS232 Software Overview - Optimised

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

These routines allow the microcontroller to send and receive RS232 data.

SoftSerial is a library for the GCBASIC compiler and works on AVR and
PIC microcontrollers. These routines allow the microcontroller to send
and receive RS232 data. All functions are implemented using software, so
no special hardware is required on the microcontroller. SoftSerial uses
ASM routines for minimal overhead. If the microcontroller has a hardware
serial module (usually referred to as UART or USART) the hardware
routines can be used too.

<span class="strong">**Features**</span>

<div class="itemizedlist">

-   3 independent channels Ser1…​ , Ser2…​ , Ser3…​

-   I/O pins user configurable

-   polarity can be inverted

-   freely adjustable baud rate

-   maximum baudrate depends on MCU speed

    <div class="itemizedlist">

    -   PIC@ 1Mhz 9600 baud
    -   PIC@ 4Mhz 38400 baud
    -   PIC@ 8Mhz 64000 baud
    -   PIC@16Mhz 128000 baud
    -   AVR@ 1Mhz 28800 baud
    -   AVR@ 8Mhz 115200 baud
    -   AVR@16Mhz 460800 baud

    </div>

-   5 - 8 data bits

-   1 or 2 stop bits

-   parity bit not supported

</div>

<span class="strong">**Relevant Constants:**</span>

These constants are used to control settings for the RS232 serial
communication routines. To set them, place a line in the main program
file that uses `#define` to assign a value to the particular constant.

<div class="informaltable">

| Constant Name/s                                | Controls                                                                                                                                                                                                                                                                                                                                                                                                  | Valid Values  | Default value                                                                     |
|:-----------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------|:----------------------------------------------------------------------------------|
| SER1\_TXPORT, SER2\_TXPORT, SER3\_TXPORT       | These are used to define the port for sending on serial channels 1, 2 and 3 respectively. Note, that we also have to define a PortPin (see next line). It is not necessary to define this, if we want to receive only. Sample: \#define SER1\_TXPORT PortB                                                                                                                                                | PORTA - PORTx | No default defined. An appropiate constant must be defined.                       |
| SER1\_TXPIN, SER2\_TXPIN, SER3\_TXPIN          | These are used to define the pin (the corresponding bit) for sending on serial channels 1, 2 and 3 respectively. Sample: \#define SER1\_TXPIN 0                                                                                                                                                                                                                                                           | 0 - 7         | No default defined. An appropiate constant must be defined to enable the TX port. |
| SER1\_RXPORT, SER2\_RXPORT, SER3\_RXPORT       | These are used to define the port for receiving on serial channels 1, 2 and 3 respectively. Note, that we also have to define a PortPin (see next line). It is not necessary to define this, if we want to receive only. Sample: \#define SER1\_RXPORT PortA                                                                                                                                              | PORTA - PORTx | No default defined. An appropiate constant must be defined to enable the TX port. |
| SER1\_RXPIN, SER2\_RXPIN, SER3\_RXPIN          | These are used to define the pin (the corresponding bit) for receiving on serial channels 1, 2 and 3 respectively. It is not necessary to define this, if we want to send only. Sample: \#define SER1\_RXPIN 5                                                                                                                                                                                            | 0 - 7         | No default defined. An appropiate constant must be defined to enable the RX port. |
| SER1\_BAUD, SER2\_BAUD, SER3\_BAUD             | These are used to define the baudrate for sending and receiving on serial channels 1, 2 and 3 respectively. It is not necessary to define this, if we want to send only. Sample: \#define SER1\_BAUD 19200                                                                                                                                                                                                | 75 - 512000   | No default defined. An appropiate constant must be defined to enable the RX port. |
| SER1\_DATABITS, SER2\_DATABITS, SER3\_DATABITS | These are used to define the databits for sending and receiving on serial channels 1, 2 and 3 respectively. Sample: \#define SER1\_DATABITS 7                                                                                                                                                                                                                                                             | 5 - 8         | Optional Default = 8                                                              |
| SER1\_STOPBITS, SER2\_STOPBITS, SER3\_STOPBITS | These are used to define the stopbits for sending and receiving on serial channels 1, 2 and 3 respectively. Sample: \#define SER1\_STOPBITS 2                                                                                                                                                                                                                                                             | 1, 2          | Optional Default = 1                                                              |
| SER1\_INVERT, SER2\_INVERT, SER3\_INVERT       | These are used to define the polarity for sending and receiving on serial channels 1, 2 and 3 respectively. If it is "On", then high bits will be changed to low, and low to high. This is useful for connection to a PCs native serial port or USB-serial converters with MAX232. Sample: \#define SER1\_INVERT On                                                                                       | On, Off       | Optional Default = Off                                                            |
| SER1\_RXNOWAIT, SER2\_RXNOWAIT, SER3\_RXNOWAIT | These are used to define, if SerNReceive waits for the startbits when receiving on serial channels 1, 2 and 3 respectively. If it is "On", then SerNReceive does not wait for the startbits edge, but directly reads the serial data. Also the time for delaying the startbit is shortened. This is useful when calling SerNReceive from an Interrupt-Service-Routine. Sample: \#define SER1\_RXNOWAIT On | On, Off       | Optional Default = Off                                                            |

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Rtrim</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_right.html" title="Right"><link rel="next" href="_str.html" title="Str"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rtrim"></a>Rtrim</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>stringvar</em></span> = Rtrim(<span class="emphasis"><em>stringvar</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Rtrim</code> function will trim the 7-bit ASCII space character (value 32) from the RIGHT hand side of a string.</p><p>Use <code class="literal">Rtrim</code> on text that you have received from another source that may have irregular spacing at the right hand end of the string.</p><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_trim.html" title="Trim">Trim</a>, <a class="link" href="_ltrim.html" title="Ltrim">Ltrim</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="rtrim"></span>Rtrim

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    stringvar = Rtrim(stringvar)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Rtrim` function will trim the 7-bit ASCII space character (value
32) from the RIGHT hand side of a string.

Use `Rtrim` on text that you have received from another source that may
have irregular spacing at the right hand end of the string.

<span class="strong">**See Also**</span>
<a href="trim" class="link" title="Trim">Trim</a>,
<a href="ltrim" class="link" title="Ltrim">Ltrim</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SAFEraseBlock</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_safm.html" title="SAFM"><link rel="prev" href="_safwriteblock.html" title="SAFWriteBlock"><link rel="next" href="_eeram_device.html" title="EERAM ( Device )"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_saferaseblock"></a>SAFEraseBlock</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    SAFEraseBlock ( block_number )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with SAFM memory.
<span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
SAFEraseBlock is used to erase all data locations within the SAFM block.&nbsp;&nbsp;&nbsp; HEFM data within the HEFM block to the erase state value of the device.&nbsp;&nbsp;&nbsp;
This Value is 0xFF for each location and will read 0xFFFF if the program memory word is displayed.
Use Caution. Once the SAFM block is erased, the SAFEM data is gone forever and cannot be recovered unless it was previpusly saved.
<br>
<br>
The single parameter is as follows:</p><p><code class="literal">block_number</code> represents the block to be erased.&nbsp;&nbsp;&nbsp;
The block_number parameter is used to calculate the physical memory location(s) that are updated.
<br>
<br></p><p><span class="strong"><strong>Example 1:</strong></span></p><p>Erase a specific block of SAFEM.</p><pre class="screen">    '... code preamble to select part
    '... code to setup PPS, if needed
    '... code to setup serial, if needed

    'Erase block 2 of HEFM
    HEFEraseBlock ( 2)</pre><p><br>
<br>
See also
<a class="link" href="_safm_overview.html" title="SAFM Overview">SAFM Overview</a>,
<a class="link" href="_safread.html" title="SAFRead">SAFRead</a>,
<a class="link" href="_safreadword.html" title="SAFReadWord">SAFReadWord</a>,
<a class="link" href="_safwrite.html" title="SAFWrite">SAFWrite</a>,
<a class="link" href="_safwriteword.html" title="SAFWriteWord">SAFWriteWord</a>,
<a class="link" href="_safreadblock.html" title="SAFReadBlock">SAFReadBlock</a>,
<a class="link" href="_safwriteblock.html" title="SAFWriteBlock">SAFWriteBlock</a>,
<a class="link" href="_saferaseblock.html" title="SAFEraseBlock">SAFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="saferaseblock"></span>SAFEraseBlock

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    SAFEraseBlock ( block_number )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with SAFM memory. <span
class="strong">**Explanation:**</span>  
  
SAFEraseBlock is used to erase all data locations within the SAFM
block.    HEFM data within the HEFM block to the erase state value of
the device.    This Value is 0xFF for each location and will read 0xFFFF
if the program memory word is displayed. Use Caution. Once the SAFM
block is erased, the SAFEM data is gone forever and cannot be recovered
unless it was previpusly saved.  
  
The single parameter is as follows:

`block_number` represents the block to be erased.    The block\_number
parameter is used to calculate the physical memory location(s) that are
updated.  
  

<span class="strong">**Example 1:**</span>

Erase a specific block of SAFEM.

``` screen
    '... code preamble to select part
    '... code to setup PPS, if needed
    '... code to setup serial, if needed

    'Erase block 2 of HEFM
    HEFEraseBlock ( 2)
```

  
  
See also
<a href="safm_overview" class="link" title="SAFM Overview">SAFM Overview</a>,
<a href="safread" class="link" title="SAFRead">SAFRead</a>,
<a href="safreadword" class="link" title="SAFReadWord">SAFReadWord</a>,
<a href="safwrite" class="link" title="SAFWrite">SAFWrite</a>,
<a href="safwriteword" class="link" title="SAFWriteWord">SAFWriteWord</a>,
<a href="safreadblock" class="link" title="SAFReadBlock">SAFReadBlock</a>,
<a href="safwriteblock" class="link" title="SAFWriteBlock">SAFWriteBlock</a>,
<a href="saferaseblock" class="link" title="SAFEraseBlock">SAFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SAFM</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_memory.html" title="Memory"><link rel="prev" href="_deviceconfigurationread.html" title="DeviceConfigurationRead"><link rel="next" href="_safm_overview.html" title="SAFM Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_safm"></a>SAFM</h4></div></div></div><p>This is the SAFM section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="safm"></span>SAFM

</div>

</div>

</div>

This is the SAFM section of the Help file. Please refer the sub-sections
for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SAFM Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_safm.html" title="SAFM"><link rel="prev" href="_safm.html" title="SAFM"><link rel="next" href="_safread.html" title="SAFRead"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_safm_overview"></a>SAFM Overview</h5></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>Some Advanced (18F) and some Enhanced Mid-Range (16F) Microchip PIC devices support Storage Area Flash (SAF) memory. These devices also include EEPROM memory.&nbsp;&nbsp;&nbsp;
SAF memory is not High Endurance, meaning it does not have an endurance of 100K write cyces.&nbsp;&nbsp;&nbsp;
SAF has the same endurance as regular flash memmory, usually specified as 10K write cycles.&nbsp;&nbsp;&nbsp;
<br>
<br>
SAF memory appears at the top of program memory space and can be used for any purpose, like regular flash program memory.&nbsp;&nbsp;&nbsp;
Storage Area Flash is intended to be used to store data, such a device calibration data, RF device register settings, and other data. SAFEM can be Read as frequently as necessary.&nbsp;&nbsp;&nbsp; However,  it is not intended to be written frequently like EEPROM. If non-volatile memory need to be written frequenily, it is best to use the EEPROM on these devices.
<br>
<br>
As with all flash memory, data must be erased before it can be written and writing this memory will stall the device for a few ms. &nbsp;&nbsp;&nbsp;
Methods to read, write and erase the SAF memory are included in GCBASIC and they are described in this introduction.
<br>
<br>
The <code class="literal">hefsaf.h</code> library supports SAF operations for GCBASIC.
<br>
<br>
Note:  By default, GCBASIC will use SAF memory for regular executable code unless it is told otherwise.&nbsp;&nbsp;&nbsp;
If you wish to store data here, you should reserve the SAF memory by using the compiler option, as shown below to reserve 128 Words of SAF memory:&nbsp;&nbsp;&nbsp;This equates to 256 bytes on PIC 18F microcontrollers and 128 Bytes on PIC 16F microcontrollers</p><pre class="screen">    #option ReserveHighProg 128</pre><p>SAF memory is a block of memory locations found at the top of the Flash program memory.&nbsp;&nbsp;&nbsp;
Each memory location can be used to hold a variable value, either a byte or a word dependent on the specific device.&nbsp;&nbsp;&nbsp;
The main difference between SAF memory and EEPROM is that EEPROM allows byte-by-byte erase whereas the SAF memory does not.&nbsp;&nbsp;&nbsp;
With SAF memory data must be erased before a write and the erase can only be performed in blocks of memory.&nbsp;&nbsp;&nbsp;
The blocks, also called rows, are a fixed size associated with the specific device.&nbsp;&nbsp;&nbsp;
<br>
<br>
GCBASIC handles the erase operation automatically.&nbsp;&nbsp;&nbsp;
When a write operation is used by a user the GCBASIC library reads to a buffer, update the buffer, erase the block and finally write the buffer back to SAFM.&nbsp;&nbsp;&nbsp;
The complexity of using SAF memory is reduced with the automatically handling of these operations.&nbsp;&nbsp;&nbsp;
<br>
<br>
The library provides a set of methods to support use of SAF memory.
<br>
<br></p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top"><p>Method</p></td><td align="left" valign="top"><p>Parameters</p></td><td align="left" valign="top"><p>Usage</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFWrite</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: location, byte value</p></td><td align="left" valign="top"><p>SAFWrite ( location, byte_variable )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFWriteWord</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: location, word_value</p></td><td align="left" valign="top"><p>SAFWriteWord ( location, word_variable  )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFRead</code></p></td><td align="left" valign="top"><p>a function with the parameters: location returns a byte value</p></td><td align="left" valign="top"><p>byte_variable = SAFRead ( location  )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFRead</code></p></td><td align="left" valign="top"><p>a subroutine with the paramers: location, byte_value</p></td><td align="left" valign="top"><p>SAFRead ( location , out_byte_variable )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFReadWord</code></p></td><td align="left" valign="top"><p>a function with the parameters: location returns a word value</p></td><td align="left" valign="top"><p>word_variable = SAFRead ( location  )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFReadWord</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: location, word_value</p></td><td align="left" valign="top"><p>SAFRead ( location , word_variable )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFEraseBlock</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: block_number</p></td><td align="left" valign="top"><p>SAFEraseBlock ( 0 )
<br>
<br>
A value of 0,1,2,3 etc.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFWriteBlock</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: block_number, buffer() [,num_blocks ]</p></td><td align="left" valign="top"><p>SAFWriteBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String
<br>
<br>
The Array or a String will contain the values to be wrttin to the SAFM.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFReadBlock</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: block_number, buffer() [, num_blocks ]</p></td><td align="left" valign="top"><p>SAFReadBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String.
<br>
<br>
The Array or a String will contain the values from the SAFM.</p></td></tr></tbody></table></div><p><br>
<br>
The library also defines a set constants that are specific to the device.&nbsp;&nbsp;&nbsp;
These may be useful in the user program.&nbsp;&nbsp;&nbsp;
These constants are used by the library.&nbsp;&nbsp;&nbsp;
A user may use these public constants.
<br>
<br></p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Type</p></td><td align="left" valign="top"><p>Usage</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAF_ROWSIZE_BYTES</code></p></td><td align="left" valign="top"><p>Byte</p></td><td align="left" valign="top"><p>Size of an SAFM block in bytes</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAF_WORDS</code> and <code class="literal">SAF_BYTES</code></p></td><td align="left" valign="top"><p>Word or a Byte</p></td><td align="left" valign="top"><p>ChipSAFMemWords parameter from the device .dat file</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAF_START_ADDR</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Starting address of SAFM</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAF_NUM_BLOCKS</code></p></td><td align="left" valign="top"><p>Byte</p></td><td align="left" valign="top"><p>Number of block of SAFM</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPWORDS</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Device specific constant for the total flash size</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPSAFMEMWORDS</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Device specific constant for the number of SAFM words available</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPERASEROWSIZEWORDS</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Device specific constant for the number of SAFM in an erase row</p></td></tr></tbody></table></div><p><br>
<span class="strong"><strong>Warning</strong></span>
<br>
<br>
Whenever you update the hex file of your Microchip PIC micro-controller with your programmer you MAY erase the data that are stored in SAF memory.&nbsp;&nbsp;&nbsp;
If you want to avoid that you will have to flash your Microchip PIC micro-controller with software that allows memory exclusion when flashing.&nbsp;&nbsp;&nbsp;
This is the case with Microchip PIC MPLAB IPE (Go to <code class="literal">Advanced Mode/Enter password/Select Memory/Tick &#8220;Preserve Flash on Program&#8221;/
Enter Start and End address</code> of your SAFM).&nbsp;&nbsp;&nbsp;Or, simply use the PICkitPlus suite of software to preserve SAF memory during programming.
<br>
<br>
See also
<a class="link" href="_safread.html" title="SAFRead">SAFRead</a>,
<a class="link" href="_safreadword.html" title="SAFReadWord">SAFReadWord</a>,
<a class="link" href="_safwrite.html" title="SAFWrite">SAFWrite</a>,
<a class="link" href="_safwriteword.html" title="SAFWriteWord">SAFWriteWord</a>,
<a class="link" href="_safreadblock.html" title="SAFReadBlock">SAFReadBlock</a>,
<a class="link" href="_safwriteblock.html" title="SAFWriteBlock">SAFWriteBlock</a>,
<a class="link" href="_saferaseblock.html" title="SAFEraseBlock">SAFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="safm_overview"></span>SAFM Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

Some Advanced (18F) and some Enhanced Mid-Range (16F) Microchip PIC
devices support Storage Area Flash (SAF) memory. These devices also
include EEPROM memory.    SAF memory is not High Endurance, meaning it
does not have an endurance of 100K write cyces.    SAF has the same
endurance as regular flash memmory, usually specified as 10K write
cycles.     
  
SAF memory appears at the top of program memory space and can be used
for any purpose, like regular flash program memory.    Storage Area
Flash is intended to be used to store data, such a device calibration
data, RF device register settings, and other data. SAFEM can be Read as
frequently as necessary.    However, it is not intended to be written
frequently like EEPROM. If non-volatile memory need to be written
frequenily, it is best to use the EEPROM on these devices.  
  
As with all flash memory, data must be erased before it can be written
and writing this memory will stall the device for a few ms.     Methods
to read, write and erase the SAF memory are included in GCBASIC and they
are described in this introduction.  
  
The `hefsaf.h` library supports SAF operations for GCBASIC.  
  
Note: By default, GCBASIC will use SAF memory for regular executable
code unless it is told otherwise.    If you wish to store data here, you
should reserve the SAF memory by using the compiler option, as shown
below to reserve 128 Words of SAF memory:   This equates to 256 bytes on
PIC 18F microcontrollers and 128 Bytes on PIC 16F microcontrollers

``` screen
    #option ReserveHighProg 128
```

SAF memory is a block of memory locations found at the top of the Flash
program memory.    Each memory location can be used to hold a variable
value, either a byte or a word dependent on the specific device.    The
main difference between SAF memory and EEPROM is that EEPROM allows
byte-by-byte erase whereas the SAF memory does not.    With SAF memory
data must be erased before a write and the erase can only be performed
in blocks of memory.    The blocks, also called rows, are a fixed size
associated with the specific device.     
  
GCBASIC handles the erase operation automatically.    When a write
operation is used by a user the GCBASIC library reads to a buffer,
update the buffer, erase the block and finally write the buffer back to
SAFM.    The complexity of using SAF memory is reduced with the
automatically handling of these operations.     
  
The library provides a set of methods to support use of SAF memory.  
  

<div class="informaltable">

<table data-border="1" width="80%">
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Method</p></td>
<td style="text-align: left;"><p>Parameters</p></td>
<td style="text-align: left;"><p>Usage</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">SAFWrite</code></p></td>
<td style="text-align: left;"><p>a subroutine with the parameters: location, byte value</p></td>
<td style="text-align: left;"><p>SAFWrite ( location, byte_variable )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">SAFWriteWord</code></p></td>
<td style="text-align: left;"><p>a subroutine with the parameters: location, word_value</p></td>
<td style="text-align: left;"><p>SAFWriteWord ( location, word_variable )</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">SAFRead</code></p></td>
<td style="text-align: left;"><p>a function with the parameters: location returns a byte value</p></td>
<td style="text-align: left;"><p>byte_variable = SAFRead ( location )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">SAFRead</code></p></td>
<td style="text-align: left;"><p>a subroutine with the paramers: location, byte_value</p></td>
<td style="text-align: left;"><p>SAFRead ( location , out_byte_variable )</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">SAFReadWord</code></p></td>
<td style="text-align: left;"><p>a function with the parameters: location returns a word value</p></td>
<td style="text-align: left;"><p>word_variable = SAFRead ( location )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">SAFReadWord</code></p></td>
<td style="text-align: left;"><p>a subroutine with the parameters: location, word_value</p></td>
<td style="text-align: left;"><p>SAFRead ( location , word_variable )</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">SAFEraseBlock</code></p></td>
<td style="text-align: left;"><p>a subroutine with the parameters: block_number</p></td>
<td style="text-align: left;"><p>SAFEraseBlock ( 0 )<br />
<br />
A value of 0,1,2,3 etc.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">SAFWriteBlock</code></p></td>
<td style="text-align: left;"><p>a subroutine with the parameters: block_number, buffer() [,num_blocks ]</p></td>
<td style="text-align: left;"><p>SAFWriteBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String<br />
<br />
The Array or a String will contain the values to be wrttin to the SAFM.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">SAFReadBlock</code></p></td>
<td style="text-align: left;"><p>a subroutine with the parameters: block_number, buffer() [, num_blocks ]</p></td>
<td style="text-align: left;"><p>SAFReadBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String.<br />
<br />
The Array or a String will contain the values from the SAFM.</p></td>
</tr>
</tbody>
</table>

</div>

  
  
The library also defines a set constants that are specific to the
device.    These may be useful in the user program.    These constants
are used by the library.    A user may use these public constants.  
  

<div class="informaltable">

|                             |                |                                                                 |
|:----------------------------|:---------------|:----------------------------------------------------------------|
| Constant                    | Type           | Usage                                                           |
| `SAF_ROWSIZE_BYTES`         | Byte           | Size of an SAFM block in bytes                                  |
| `SAF_WORDS` and `SAF_BYTES` | Word or a Byte | ChipSAFMemWords parameter from the device .dat file             |
| `SAF_START_ADDR`            | Word           | Starting address of SAFM                                        |
| `SAF_NUM_BLOCKS`            | Byte           | Number of block of SAFM                                         |
| `CHIPWORDS`                 | Word           | Device specific constant for the total flash size               |
| `CHIPSAFMEMWORDS`           | Word           | Device specific constant for the number of SAFM words available |
| `CHIPERASEROWSIZEWORDS`     | Word           | Device specific constant for the number of SAFM in an erase row |

</div>

  
<span class="strong">**Warning**</span>  
  
Whenever you update the hex file of your Microchip PIC micro-controller
with your programmer you MAY erase the data that are stored in SAF
memory.    If you want to avoid that you will have to flash your
Microchip PIC micro-controller with software that allows memory
exclusion when flashing.    This is the case with Microchip PIC MPLAB
IPE (Go to
`Advanced Mode/Enter password/Select Memory/Tick “Preserve Flash on Program”/ Enter Start and End address`
of your SAFM).   Or, simply use the PICkitPlus suite of software to
preserve SAF memory during programming.  
  
See also
<a href="safread" class="link" title="SAFRead">SAFRead</a>,
<a href="safreadword" class="link" title="SAFReadWord">SAFReadWord</a>,
<a href="safwrite" class="link" title="SAFWrite">SAFWrite</a>,
<a href="safwriteword" class="link" title="SAFWriteWord">SAFWriteWord</a>,
<a href="safreadblock" class="link" title="SAFReadBlock">SAFReadBlock</a>,
<a href="safwriteblock" class="link" title="SAFWriteBlock">SAFWriteBlock</a>,
<a href="saferaseblock" class="link" title="SAFEraseBlock">SAFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SAFRead</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_safm.html" title="SAFM"><link rel="prev" href="_safm_overview.html" title="SAFM Overview"><link rel="next" href="_safreadword.html" title="SAFReadWord"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_safread"></a>SAFRead</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    'as a subroutine
    SAFRead ( location, data )

    'as a function
    data = SAFRead ( location )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with SAFM memory</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
SAFRead is used to read information, byte values, from SAFM, so that it can be accessed for use in a user program.
<br>
<br>
<code class="literal">location</code> represents the location or relative address to read.  The location will range from location 0 to SAF_BYTES - 1. This cab be from 0-127 or 0-255m depending upon the specific device. HEF_BYTES is a GCBASIC constant that represents the number of bytes of SAF Memory.&nbsp;&nbsp;&nbsp;
<br>
<br>
<code class="literal">data</code> is the data that is to be read from the SAFM data storage area.&nbsp;&nbsp;&nbsp;
This can be a byte value or a byte variable.
<br>
<br>
This method reads data from SAFM given the specific relative location.&nbsp;&nbsp;&nbsp;
This method is similar to the EPRead method for EEPROM.
<br>
<br>
<span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial
    '... code to setup PPS

    'The following example reads the SAFM data value into the byte variable &#8220;byte_value&#8221; using a subroutine.

    Dim data_byte as byte

    ;Write a byte of data to SAF Location 34
    SAFWrite( 34, 144)

    ;Read the byte back from SAF location 34
    byte_value = SAFread( 34 )

    ;Display the data on a terminal
    HserPrint "byte_value = "
    Hserprint byte_value</pre><p><br>
<br>
<span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial
    '... code to setup PPS

    'The following example reads the SAFM data value into the byte variable &#8220;byte_value&#8221; using a function.

    Dim data_byte as byte

    ;Write a byte of Data to SAF Location 34
    SAFWrite( 34, 144)

    ;Read the byte back from SAF location 34
    byte_value = SAFread( 34 )

    ;Display the data on a terminal
    HserPrint "byte_value = "
    Hserprint byte_value</pre><p><br>
<br>
See also
<a class="link" href="_safm_overview.html" title="SAFM Overview">SAFM Overview</a>,
<a class="link" href="_safread.html" title="SAFRead">SAFRead</a>,
<a class="link" href="_safreadword.html" title="SAFReadWord">SAFReadWord</a>,
<a class="link" href="_safwrite.html" title="SAFWrite">SAFWrite</a>,
<a class="link" href="_safwriteword.html" title="SAFWriteWord">SAFWriteWord</a>,
<a class="link" href="_safreadblock.html" title="SAFReadBlock">SAFReadBlock</a>,
<a class="link" href="_safwriteblock.html" title="SAFWriteBlock">SAFWriteBlock</a>,
<a class="link" href="_saferaseblock.html" title="SAFEraseBlock">SAFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="safread"></span>SAFRead

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    'as a subroutine
    SAFRead ( location, data )

    'as a function
    data = SAFRead ( location )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with SAFM memory

<span class="strong">**Explanation:**</span>  
  
SAFRead is used to read information, byte values, from SAFM, so that it
can be accessed for use in a user program.  
  
`location` represents the location or relative address to read. The
location will range from location 0 to SAF\_BYTES - 1. This cab be from
0-127 or 0-255m depending upon the specific device. HEF\_BYTES is a
GCBASIC constant that represents the number of bytes of SAF Memory.     
  
`data` is the data that is to be read from the SAFM data storage
area.    This can be a byte value or a byte variable.  
  
This method reads data from SAFM given the specific relative
location.    This method is similar to the EPRead method for EEPROM.  
  
<span class="strong">**Example 1:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial
    '... code to setup PPS

    'The following example reads the SAFM data value into the byte variable “byte_value” using a subroutine.

    Dim data_byte as byte

    ;Write a byte of data to SAF Location 34
    SAFWrite( 34, 144)

    ;Read the byte back from SAF location 34
    byte_value = SAFread( 34 )

    ;Display the data on a terminal
    HserPrint "byte_value = "
    Hserprint byte_value
```

  
  
<span class="strong">**Example 2:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial
    '... code to setup PPS

    'The following example reads the SAFM data value into the byte variable “byte_value” using a function.

    Dim data_byte as byte

    ;Write a byte of Data to SAF Location 34
    SAFWrite( 34, 144)

    ;Read the byte back from SAF location 34
    byte_value = SAFread( 34 )

    ;Display the data on a terminal
    HserPrint "byte_value = "
    Hserprint byte_value
```

  
  
See also
<a href="safm_overview" class="link" title="SAFM Overview">SAFM Overview</a>,
<a href="safread" class="link" title="SAFRead">SAFRead</a>,
<a href="safreadword" class="link" title="SAFReadWord">SAFReadWord</a>,
<a href="safwrite" class="link" title="SAFWrite">SAFWrite</a>,
<a href="safwriteword" class="link" title="SAFWriteWord">SAFWriteWord</a>,
<a href="safreadblock" class="link" title="SAFReadBlock">SAFReadBlock</a>,
<a href="safwriteblock" class="link" title="SAFWriteBlock">SAFWriteBlock</a>,
<a href="saferaseblock" class="link" title="SAFEraseBlock">SAFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SAFReadBlock</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_safm.html" title="SAFM"><link rel="prev" href="_safwriteword.html" title="SAFWriteWord"><link rel="next" href="_safwriteblock.html" title="SAFWriteBlock"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_safreadblock"></a>SAFReadBlock</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    SAFReadBlock ( block_number,  buffer(), [,  num_bytes] )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with SAFM memory.</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
HEFReadBlock is used to read information from the HEFM data storage into the buffer.&nbsp;&nbsp;&nbsp;
Once the buffer is populated it can be accessed for use within a user program.
<br>
<br>
The parameters are as follows:
<br>
<br>
<code class="literal">block_number</code> represents the block to be written to.&nbsp;&nbsp;&nbsp;
The block_number parameter is used to calculate the physical memory location(s) that are updated.
<br>
<br>
<code class="literal">buffer()</code> represents an array or string.&nbsp;&nbsp;&nbsp;
The buffer will be used as the data target for the block read operation.&nbsp;&nbsp;&nbsp;
The  buffer is handled as a buffer of bytes values.&nbsp;&nbsp;&nbsp;
In most cases the buffer should be the same size as a row/block of SAFM.&nbsp;&nbsp;&nbsp;
For most PIC Microcontrollers with SAFM this will be 32 bytes.&nbsp;&nbsp;&nbsp;
<br>
<br>
<code class="literal">num_bytes</code> is an optional parameter, and can be used to specify number of bytes to read from SAFM, starting at the first location in the selected SAFM block.&nbsp;&nbsp;&nbsp;
This parameter is not normally required as the default is set to the GCBASIC constant <code class="literal">SAF_ROWSIZE_BYTES</code>.
<br>
<br>
<span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    #chip 18F24K42, 16
    '... code preamble to setup PPS
    '... code to setup serial

      Dim My_Buffer(HEF_ROWSIZE_BYTES)
      Dim index as byte

      ;Write some data to Block 2
      My_Buffer = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32
      SAFWriteBlock(2, My_Buffer())

      ;Read the data back from SAFM using SAFReadBock
      SAFReadBlock( 2 , My_buffer() )

     ;Send the data to a terminal in decimal format
      index = 1
      Repeat SAF_ROWSIZE_BYTES
          Hserprint(My_Buffer(index))
          HserPrint " "
          index++
     End Repeat</pre><p><br>
<br>
See also
<a class="link" href="_safm_overview.html" title="SAFM Overview">SAFM Overview</a>,
<a class="link" href="_safread.html" title="SAFRead">SAFRead</a>,
<a class="link" href="_safreadword.html" title="SAFReadWord">SAFReadWord</a>,
<a class="link" href="_safwrite.html" title="SAFWrite">SAFWrite</a>,
<a class="link" href="_safwriteword.html" title="SAFWriteWord">SAFWriteWord</a>,
<a class="link" href="_safreadblock.html" title="SAFReadBlock">SAFReadBlock</a>,
<a class="link" href="_safwriteblock.html" title="SAFWriteBlock">SAFWriteBlock</a>,
<a class="link" href="_saferaseblock.html" title="SAFEraseBlock">SAFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="safreadblock"></span>SAFReadBlock

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    SAFReadBlock ( block_number,  buffer(), [,  num_bytes] )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with SAFM memory.

<span class="strong">**Explanation:**</span>  
  
HEFReadBlock is used to read information from the HEFM data storage into
the buffer.    Once the buffer is populated it can be accessed for use
within a user program.  
  
The parameters are as follows:  
  
`block_number` represents the block to be written to.    The
block\_number parameter is used to calculate the physical memory
location(s) that are updated.  
  
`buffer()` represents an array or string.    The buffer will be used as
the data target for the block read operation.    The buffer is handled
as a buffer of bytes values.    In most cases the buffer should be the
same size as a row/block of SAFM.    For most PIC Microcontrollers with
SAFM this will be 32 bytes.     
  
`num_bytes` is an optional parameter, and can be used to specify number
of bytes to read from SAFM, starting at the first location in the
selected SAFM block.    This parameter is not normally required as the
default is set to the GCBASIC constant `SAF_ROWSIZE_BYTES`.  
  
<span class="strong">**Example 1:**</span>

``` screen
    #chip 18F24K42, 16
    '... code preamble to setup PPS
    '... code to setup serial

      Dim My_Buffer(HEF_ROWSIZE_BYTES)
      Dim index as byte

      ;Write some data to Block 2
      My_Buffer = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32
      SAFWriteBlock(2, My_Buffer())

      ;Read the data back from SAFM using SAFReadBock
      SAFReadBlock( 2 , My_buffer() )

     ;Send the data to a terminal in decimal format
      index = 1
      Repeat SAF_ROWSIZE_BYTES
          Hserprint(My_Buffer(index))
          HserPrint " "
          index++
     End Repeat
```

  
  
See also
<a href="safm_overview" class="link" title="SAFM Overview">SAFM Overview</a>,
<a href="safread" class="link" title="SAFRead">SAFRead</a>,
<a href="safreadword" class="link" title="SAFReadWord">SAFReadWord</a>,
<a href="safwrite" class="link" title="SAFWrite">SAFWrite</a>,
<a href="safwriteword" class="link" title="SAFWriteWord">SAFWriteWord</a>,
<a href="safreadblock" class="link" title="SAFReadBlock">SAFReadBlock</a>,
<a href="safwriteblock" class="link" title="SAFWriteBlock">SAFWriteBlock</a>,
<a href="saferaseblock" class="link" title="SAFEraseBlock">SAFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SAFReadWord</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_safm.html" title="SAFM"><link rel="prev" href="_safread.html" title="SAFRead"><link rel="next" href="_safwrite.html" title="SAFWrite"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_safreadword"></a>SAFReadWord</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    'as a subroutine
    SAFReadWord ( location, data_word_variable )

    'as a function
    data_word_variable = SAFReadWord ( location )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with SAFM memory</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
SAFReadWord is used to read information, word values, from SAFM so that it can be accessed for use in a user program.
<br>
<br>
<code class="literal">location</code> represents the location or relative address to read. The location will range from 0 to SAF_BYTES -1.&nbsp;&nbsp;&nbsp;
Each data Word requires 2 SAF Locations, therefore the location will range from either 0 to 254 or 0 to 126 (in steps of 2),  depending upon the device.
<br>
<br>
<code class="literal">data</code> is the word data that is to be read from the SAFM location.&nbsp;&nbsp;&nbsp;
This must be a word variable.
<br>
<br>
This method reads word information from SAFM given the relative location in SAFM.&nbsp;&nbsp;&nbsp;
<br>
<br>
<span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial

    'The following example uses a subroutine to read an SAFM location into a word variable.

    dim data_word_variable as word

    ;Write a word to SAF location 64
    SAFWriteWord(  64, 0x1234 )

    ; Read the Word from SAF location 64
    SAFReadWord ( 64, data_word_variable  )

    HSerPrint "Value = "
    HSerPrint data_word_variable
    HSerPrintCRLF</pre><p><br>
If example 1 were displayed on a serial terminal.&nbsp;&nbsp;&nbsp;The result would show:</p><pre class="screen">    Value = 4660</pre><p><br>
<br>
<span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial

    'The following example uses a function to read an SAFM location into a word variable.

    dim data_word_variable as word

    ;Write a word to SAF location 64
    SAFWriteWord(  64, 0x4321 )

    ; Read the Word from SAF location 64
    data_word_variable = SAFReadWord ( 64 )

    HSerPrint "Value = "
    HSerPrint data_word_variable
    HSerPrintCRLF</pre><p><br>
If example 2 were displayed on a serial terminal.&nbsp;&nbsp;&nbsp;The result would show:</p><pre class="screen">    Value = 17185</pre><p><br>
<br>
See also
<a class="link" href="_safm_overview.html" title="SAFM Overview">SAFM Overview</a>,
<a class="link" href="_safread.html" title="SAFRead">SAFRead</a>,
<a class="link" href="_safreadword.html" title="SAFReadWord">SAFReadWord</a>,
<a class="link" href="_safwrite.html" title="SAFWrite">SAFWrite</a>,
<a class="link" href="_safwriteword.html" title="SAFWriteWord">SAFWriteWord</a>,
<a class="link" href="_safreadblock.html" title="SAFReadBlock">SAFReadBlock</a>,
<a class="link" href="_safwriteblock.html" title="SAFWriteBlock">SAFWriteBlock</a>,
<a class="link" href="_saferaseblock.html" title="SAFEraseBlock">SAFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="safreadword"></span>SAFReadWord

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    'as a subroutine
    SAFReadWord ( location, data_word_variable )

    'as a function
    data_word_variable = SAFReadWord ( location )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with SAFM memory

<span class="strong">**Explanation:**</span>  
  
SAFReadWord is used to read information, word values, from SAFM so that
it can be accessed for use in a user program.  
  
`location` represents the location or relative address to read. The
location will range from 0 to SAF\_BYTES -1.    Each data Word requires
2 SAF Locations, therefore the location will range from either 0 to 254
or 0 to 126 (in steps of 2), depending upon the device.  
  
`data` is the word data that is to be read from the SAFM location.   
This must be a word variable.  
  
This method reads word information from SAFM given the relative location
in SAFM.     
  
<span class="strong">**Example 1:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial

    'The following example uses a subroutine to read an SAFM location into a word variable.

    dim data_word_variable as word

    ;Write a word to SAF location 64
    SAFWriteWord(  64, 0x1234 )

    ; Read the Word from SAF location 64
    SAFReadWord ( 64, data_word_variable  )

    HSerPrint "Value = "
    HSerPrint data_word_variable
    HSerPrintCRLF
```

  
If example 1 were displayed on a serial terminal.   The result would
show:

``` screen
    Value = 4660
```

  
  
<span class="strong">**Example 2:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial

    'The following example uses a function to read an SAFM location into a word variable.

    dim data_word_variable as word

    ;Write a word to SAF location 64
    SAFWriteWord(  64, 0x4321 )

    ; Read the Word from SAF location 64
    data_word_variable = SAFReadWord ( 64 )

    HSerPrint "Value = "
    HSerPrint data_word_variable
    HSerPrintCRLF
```

  
If example 2 were displayed on a serial terminal.   The result would
show:

``` screen
    Value = 17185
```

  
  
See also
<a href="safm_overview" class="link" title="SAFM Overview">SAFM Overview</a>,
<a href="safread" class="link" title="SAFRead">SAFRead</a>,
<a href="safreadword" class="link" title="SAFReadWord">SAFReadWord</a>,
<a href="safwrite" class="link" title="SAFWrite">SAFWrite</a>,
<a href="safwriteword" class="link" title="SAFWriteWord">SAFWriteWord</a>,
<a href="safreadblock" class="link" title="SAFReadBlock">SAFReadBlock</a>,
<a href="safwriteblock" class="link" title="SAFWriteBlock">SAFWriteBlock</a>,
<a href="saferaseblock" class="link" title="SAFEraseBlock">SAFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SAFWrite</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_safm.html" title="SAFM"><link rel="prev" href="_safreadword.html" title="SAFReadWord"><link rel="next" href="_safwriteword.html" title="SAFWriteWord"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_safwrite"></a>SAFWrite</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    SAFWrite ( location, data )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with SAFM memory</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
SAFWrite is used to write information, byte values, to SAFM so that it can be accessed later for use in a user program.
<br>
<br>
<code class="literal">location</code> represents the location or relative address to write. The location will range from location 0 to SAF_BYTES - 1, or for all practical purposes 0-255 since all PIC Microcontrollers with SAFM support 256 bytes of SAF Memory.&nbsp;&nbsp;&nbsp;
HEF_BYTES is a GCBASIC constant that represents the number of bytes of SAF Memory.
<br>
<br>
<code class="literal">data</code> is the data that is to be written to the SAFM location.&nbsp;&nbsp;&nbsp;
This can be a byte value or a byte variable.
<br>
This method writes information to SAFM given the specific location.
This method is similar to the EPWrite method for EEPROM.
<br>
<br>
<span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">     #chip 18F24K42, 16
    '... code to setup PPS
    '... code to setup serial

    'The following example writes a byte value of 126 into HEFM location 34

    SAFWrite( 34,126 )</pre><p><br>
<br>
<span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    #chip 18F24K42, 16
    '... code to setup PPS
    '... code to setup serial

    'This example will populate the 256 bytes of SAF memory with a value that is same as the SAFM location

     Dim Rel_Address, DataByte as Byte
     Dim NVM_Address as Long
     Dim  DataWord, as Word

    For Rel_Aaddress = 0 to 255
        SAFWrite ( Rel_Address, Rel_Address )
    Next

    SAFM_Dump
    end

    ; This subroutine displays the SAF Flash Memory on a terminal
    ; Words in reverse byte order relative to address
    sub SAFM_Dump

    Dim Blocknum as Byte
    NVM_Address  = SAF_START_ADDR
    BlockNum = 0

    Repeat SAF_WORDS    ;128
        If NVM_Address % SAF_ROWSIZE_BYTES = 0 then
           If BlockNum &gt; 0 then   HSERPRINTCRLF
           HSerprintCRLF

           HserPrint "Block"
           HSerprint BlockNum
           HSerprint "  1 0   3 2   5 4   7 6   9 8   B A   D C   F E"
           BlockNum++
        End if

        IF NVM_Address  % 16 = 0 then
           HSerPrintCRLF
           hserprint hex(NVM_Address_H)
           hserprint hex(NVM_Address)
           hserprint "    "
        end if

        Rel_Address = NVM_ADDRESS - SAF_START_ADDR
        SAFReadWord(Rel_Address,DataWord)

        hserprint hex(DataWord_H)
        hserprint hex(DataWord)
        hserprint "  "

        NVM_Address+=2 ' Next "WORD"
    End Repeat
End sub</pre><p><br>
<br>
If example 2 were displayed on a serial terminal.&nbsp;&nbsp;&nbsp;The result would show:</p><pre class="screen">Block0  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F00    0100  0302  0504  0706  0908  0B0A  0D0C  0F0E
7F10    1110  1312  1514  1716  1918  1B1A  1D1C  1F1E
7F20    2120  2322  2524  2726  2928  2B2A  2D2C  2F2E
7F30    3130  3332  3534  3736  3938  3B3A  3D3C  3F3E

Block1  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F40    4140  4342  4544  4746  4948  4B4A  4D4C  4F4E
7F50    5150  5352  5554  5756  5958  5B5A  5D5C  5F5E
7F60    6160  6362  6564  6766  6968  6B6A  6D6C  6F6E
7F70    7170  7372  7574  7776  7978  7B7A  7D7C  7F7E

Block2  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F80    8180  8382  8584  8786  8988  8B8A  8D8C  8F8E
7F90    9190  9392  9594  9796  9998  9B9A  9D9C  9F9E
7FA0    A1A0  A3A2  A5A4  A7A6  A9A8  ABAA  ADAC  AFAE
7FB0    B1B0  B3B2  B5B4  B7B6  B9B8  BBBA  BDBC  BFBE

Block3  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7FC0    C1C0  C3C2  C5C4  C7C6  C9C8  CBCA  CDCC  CFCE
7FD0    D1D0  D3D2  D5D4  D7D6  D9D8  DBDA  DDDC  DFDE
7FE0    E1E0  E3E2  E5E4  E7E6  E9E8  EBEA  EDEC  EFEE
7FF0    F1F0  F3F2  F5F4  F7F6  F9F8  FBFA  FDFC  FFFE</pre><p><br>
<br>
See also
<a class="link" href="_safm_overview.html" title="SAFM Overview">SAFM Overview</a>,
<a class="link" href="_safread.html" title="SAFRead">SAFRead</a>,
<a class="link" href="_safreadword.html" title="SAFReadWord">SAFReadWord</a>,
<a class="link" href="_safwrite.html" title="SAFWrite">SAFWrite</a>,
<a class="link" href="_safwriteword.html" title="SAFWriteWord">SAFWriteWord</a>,
<a class="link" href="_safreadblock.html" title="SAFReadBlock">SAFReadBlock</a>,
<a class="link" href="_safwriteblock.html" title="SAFWriteBlock">SAFWriteBlock</a>,
<a class="link" href="_saferaseblock.html" title="SAFEraseBlock">SAFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="safwrite"></span>SAFWrite

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    SAFWrite ( location, data )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with SAFM memory

<span class="strong">**Explanation:**</span>  
  
SAFWrite is used to write information, byte values, to SAFM so that it
can be accessed later for use in a user program.  
  
`location` represents the location or relative address to write. The
location will range from location 0 to SAF\_BYTES - 1, or for all
practical purposes 0-255 since all PIC Microcontrollers with SAFM
support 256 bytes of SAF Memory.    HEF\_BYTES is a GCBASIC constant
that represents the number of bytes of SAF Memory.  
  
`data` is the data that is to be written to the SAFM location.    This
can be a byte value or a byte variable.  
This method writes information to SAFM given the specific location. This
method is similar to the EPWrite method for EEPROM.  
  
<span class="strong">**Example 1:**</span>

``` screen
     #chip 18F24K42, 16
    '... code to setup PPS
    '... code to setup serial

    'The following example writes a byte value of 126 into HEFM location 34

    SAFWrite( 34,126 )
```

  
  
<span class="strong">**Example 2:**</span>

``` screen
    #chip 18F24K42, 16
    '... code to setup PPS
    '... code to setup serial

    'This example will populate the 256 bytes of SAF memory with a value that is same as the SAFM location

     Dim Rel_Address, DataByte as Byte
     Dim NVM_Address as Long
     Dim  DataWord, as Word

    For Rel_Aaddress = 0 to 255
        SAFWrite ( Rel_Address, Rel_Address )
    Next

    SAFM_Dump
    end

    ; This subroutine displays the SAF Flash Memory on a terminal
    ; Words in reverse byte order relative to address
    sub SAFM_Dump

    Dim Blocknum as Byte
    NVM_Address  = SAF_START_ADDR
    BlockNum = 0

    Repeat SAF_WORDS    ;128
        If NVM_Address % SAF_ROWSIZE_BYTES = 0 then
           If BlockNum > 0 then   HSERPRINTCRLF
           HSerprintCRLF

           HserPrint "Block"
           HSerprint BlockNum
           HSerprint "  1 0   3 2   5 4   7 6   9 8   B A   D C   F E"
           BlockNum++
        End if

        IF NVM_Address  % 16 = 0 then
           HSerPrintCRLF
           hserprint hex(NVM_Address_H)
           hserprint hex(NVM_Address)
           hserprint "    "
        end if

        Rel_Address = NVM_ADDRESS - SAF_START_ADDR
        SAFReadWord(Rel_Address,DataWord)

        hserprint hex(DataWord_H)
        hserprint hex(DataWord)
        hserprint "  "

        NVM_Address+=2 ' Next "WORD"
    End Repeat
End sub
```

  
  
If example 2 were displayed on a serial terminal.   The result would
show:

``` screen
Block0  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F00    0100  0302  0504  0706  0908  0B0A  0D0C  0F0E
7F10    1110  1312  1514  1716  1918  1B1A  1D1C  1F1E
7F20    2120  2322  2524  2726  2928  2B2A  2D2C  2F2E
7F30    3130  3332  3534  3736  3938  3B3A  3D3C  3F3E

Block1  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F40    4140  4342  4544  4746  4948  4B4A  4D4C  4F4E
7F50    5150  5352  5554  5756  5958  5B5A  5D5C  5F5E
7F60    6160  6362  6564  6766  6968  6B6A  6D6C  6F6E
7F70    7170  7372  7574  7776  7978  7B7A  7D7C  7F7E

Block2  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F80    8180  8382  8584  8786  8988  8B8A  8D8C  8F8E
7F90    9190  9392  9594  9796  9998  9B9A  9D9C  9F9E
7FA0    A1A0  A3A2  A5A4  A7A6  A9A8  ABAA  ADAC  AFAE
7FB0    B1B0  B3B2  B5B4  B7B6  B9B8  BBBA  BDBC  BFBE

Block3  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7FC0    C1C0  C3C2  C5C4  C7C6  C9C8  CBCA  CDCC  CFCE
7FD0    D1D0  D3D2  D5D4  D7D6  D9D8  DBDA  DDDC  DFDE
7FE0    E1E0  E3E2  E5E4  E7E6  E9E8  EBEA  EDEC  EFEE
7FF0    F1F0  F3F2  F5F4  F7F6  F9F8  FBFA  FDFC  FFFE
```

  
  
See also
<a href="safm_overview" class="link" title="SAFM Overview">SAFM Overview</a>,
<a href="safread" class="link" title="SAFRead">SAFRead</a>,
<a href="safreadword" class="link" title="SAFReadWord">SAFReadWord</a>,
<a href="safwrite" class="link" title="SAFWrite">SAFWrite</a>,
<a href="safwriteword" class="link" title="SAFWriteWord">SAFWriteWord</a>,
<a href="safreadblock" class="link" title="SAFReadBlock">SAFReadBlock</a>,
<a href="safwriteblock" class="link" title="SAFWriteBlock">SAFWriteBlock</a>,
<a href="saferaseblock" class="link" title="SAFEraseBlock">SAFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SAFWriteBlock</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_safm.html" title="SAFM"><link rel="prev" href="_safreadblock.html" title="SAFReadBlock"><link rel="next" href="_saferaseblock.html" title="SAFEraseBlock"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_safwriteblock"></a>SAFWriteBlock</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    SAFWriteBlock ( block_number,  buffer(), [, num_bytes] )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with SAFM memory.</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
SAFWriteBlock is used to write information from a user buffer to SAFM.&nbsp;&nbsp;&nbsp;
Once the block is written  it can be accessed for use within a user program.
<br>
<br>
The parameters are as follows:
<br>
<br>
<code class="literal">block_number</code> represents the block to be written to.&nbsp;&nbsp;&nbsp;
The block_number parameter is used to calculate the physical memory location(s) that are updated.
<br>
<br>
<code class="literal">buffer()</code> represents an array or string.&nbsp;&nbsp;&nbsp;
The buffer will be used as the data source that is written to the SAFM block.&nbsp;&nbsp;&nbsp;
The buffer is handled as a buffer of bytes values.&nbsp;&nbsp;&nbsp;
In most cases the buffer should be the same size as a row/block of SAFM.&nbsp;&nbsp;&nbsp;
For most PIC Microcontrollers this will be 32 bytes.&nbsp;&nbsp;&nbsp;
Best practice is to size the buffer using the SAF_ROWSIZE_BYTES constant.&nbsp;&nbsp;&nbsp;
If the size of the buffer exceeds the device specific SAF_ROWSIZE_BYTES, the excess data will not be handled and the buffer will be truncated at the SAF_ROWSIZE_BYTES limit.&nbsp;&nbsp;&nbsp;
<br>
<br>
<code class="literal">num_bytes</code> is an optional parameter, and can be used to specify the number of bytes to write to HEFM, starting at the first location in the selected HEFM block.&nbsp;&nbsp;&nbsp;
This parameter is not normally required as the default is set to the GCBASIC constant <code class="literal">HEF_ROWSIZE_BYTES</code>.
<br>
<br>
<span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    #chip 18F24K42, 16
    '... code preamble to setup PPS
    '... code to setup serial

      Dim My_Buffer(HEF_ROWSIZE_BYTES)
      Dim index as byte

      ;Write some data to Block 2
      My_Buffer = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32
      SAFWriteBlock(2, My_Buffer())

      ;Read the data back from SAFM using SAFReadBock
      SAFReadBlock( 2 , My_buffer() )

     ;Send the data to a terminal in decimal format
      index = 1
      Repeat SAF_ROWSIZE_BYTES
          Hserprint(My_Buffer(index))
          HserPrint " "
          index++
     End Repeat</pre><p><br>
<br>
See also
<a class="link" href="_safm_overview.html" title="SAFM Overview">SAFM Overview</a>,
<a class="link" href="_safread.html" title="SAFRead">SAFRead</a>,
<a class="link" href="_safreadword.html" title="SAFReadWord">SAFReadWord</a>,
<a class="link" href="_safwrite.html" title="SAFWrite">SAFWrite</a>,
<a class="link" href="_safwriteword.html" title="SAFWriteWord">SAFWriteWord</a>,
<a class="link" href="_safreadblock.html" title="SAFReadBlock">SAFReadBlock</a>,
<a class="link" href="_safwriteblock.html" title="SAFWriteBlock">SAFWriteBlock</a>,
<a class="link" href="_saferaseblock.html" title="SAFEraseBlock">SAFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="safwriteblock"></span>SAFWriteBlock

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    SAFWriteBlock ( block_number,  buffer(), [, num_bytes] )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with SAFM memory.

<span class="strong">**Explanation:**</span>  
  
SAFWriteBlock is used to write information from a user buffer to
SAFM.    Once the block is written it can be accessed for use within a
user program.  
  
The parameters are as follows:  
  
`block_number` represents the block to be written to.    The
block\_number parameter is used to calculate the physical memory
location(s) that are updated.  
  
`buffer()` represents an array or string.    The buffer will be used as
the data source that is written to the SAFM block.    The buffer is
handled as a buffer of bytes values.    In most cases the buffer should
be the same size as a row/block of SAFM.    For most PIC
Microcontrollers this will be 32 bytes.    Best practice is to size the
buffer using the SAF\_ROWSIZE\_BYTES constant.    If the size of the
buffer exceeds the device specific SAF\_ROWSIZE\_BYTES, the excess data
will not be handled and the buffer will be truncated at the
SAF\_ROWSIZE\_BYTES limit.     
  
`num_bytes` is an optional parameter, and can be used to specify the
number of bytes to write to HEFM, starting at the first location in the
selected HEFM block.    This parameter is not normally required as the
default is set to the GCBASIC constant `HEF_ROWSIZE_BYTES`.  
  
<span class="strong">**Example 1:**</span>

``` screen
    #chip 18F24K42, 16
    '... code preamble to setup PPS
    '... code to setup serial

      Dim My_Buffer(HEF_ROWSIZE_BYTES)
      Dim index as byte

      ;Write some data to Block 2
      My_Buffer = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32
      SAFWriteBlock(2, My_Buffer())

      ;Read the data back from SAFM using SAFReadBock
      SAFReadBlock( 2 , My_buffer() )

     ;Send the data to a terminal in decimal format
      index = 1
      Repeat SAF_ROWSIZE_BYTES
          Hserprint(My_Buffer(index))
          HserPrint " "
          index++
     End Repeat
```

  
  
See also
<a href="safm_overview" class="link" title="SAFM Overview">SAFM Overview</a>,
<a href="safread" class="link" title="SAFRead">SAFRead</a>,
<a href="safreadword" class="link" title="SAFReadWord">SAFReadWord</a>,
<a href="safwrite" class="link" title="SAFWrite">SAFWrite</a>,
<a href="safwriteword" class="link" title="SAFWriteWord">SAFWriteWord</a>,
<a href="safreadblock" class="link" title="SAFReadBlock">SAFReadBlock</a>,
<a href="safwriteblock" class="link" title="SAFWriteBlock">SAFWriteBlock</a>,
<a href="saferaseblock" class="link" title="SAFEraseBlock">SAFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SAFWriteWord</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_safm.html" title="SAFM"><link rel="prev" href="_safwrite.html" title="SAFWrite"><link rel="next" href="_safreadblock.html" title="SAFReadBlock"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_safwriteword"></a>SAFWriteWord</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    SAFWriteWord ( location, data_word_value )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all PIC micro-controllers with SAFM memory</p><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
SAFWriteWord is used to write information, word values, to the SAFM data storage, so that it can be accessed later by a programmer on a Personal, or by the SAFRead commands.
<br>
<br>
<code class="literal">location</code> presents the location or relative address to write. The location will range from 0 to SAF_BYTES -1.&nbsp;&nbsp;&nbsp;
Each data Word requires 2 SAF Locations, therefore the location will range from either 0 to 254 or 0 to 126 (in steps of 2),  depending upon the device.
<br>
<br>
<code class="literal">data</code> is the data that is to be written to the SAFM location.&nbsp;&nbsp;&nbsp;This can be a word value or a word variable.
<br>
<br>
This method writes information to SAFM given the specific location in SAFM.&nbsp;&nbsp;&nbsp;
This method is similar to the methods for EEPROM, but supports Word values.
<br>
<br>
<span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    '... code preamble to select part
    '... code to setup serial

    'The following example stores in the word value of 0x1234 as SAFM location 34

    SAFWriteWord( 34, 0x1234 )</pre><p><br>
<br>
<span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    #chip 18F24K42, 16
    '... code to setup PPS
    '... code to setup serial

    'This example will write two word values to two specific locations.

     dim Word_Variable1 as Word
     dim Word_Variable2 as Word

    ;Write the data
    SAFWriteWord (16, 0x1234)   'location 16, in this device, equates to 0x7F10
    SAFWriteWord (18, 0x4321)   'location 18, in this device, equates to 0x7F12

   ;Read the data and send to terminal
    SAFReadWord(16, Word_Variable1 )
    SAFReadWord(18, Word_Variable2 )

   HserPrint "Word_Variable1 = "
   Hserprint Word_Variable1
   HSerPrintCRLF
   HserPrint "Word_Variable2 = "
   Hserprint Word_Variable2
   HSerPrintCRLF</pre><p><br>
<br>
If example 2 were displayed on a serial terminal.&nbsp;&nbsp;&nbsp;The result would show, where <code class="literal">----</code> is the existing value.</p><pre class="screen">Word_Variable1 = 4660
Word_Variable2 = 17185</pre><p><br>
<br>
See also
<a class="link" href="_safm_overview.html" title="SAFM Overview">SAFM Overview</a>,
<a class="link" href="_safread.html" title="SAFRead">SAFRead</a>,
<a class="link" href="_safreadword.html" title="SAFReadWord">SAFReadWord</a>,
<a class="link" href="_safwrite.html" title="SAFWrite">SAFWrite</a>,
<a class="link" href="_safwriteword.html" title="SAFWriteWord">SAFWriteWord</a>,
<a class="link" href="_safreadblock.html" title="SAFReadBlock">SAFReadBlock</a>,
<a class="link" href="_safwriteblock.html" title="SAFWriteBlock">SAFWriteBlock</a>,
<a class="link" href="_saferaseblock.html" title="SAFEraseBlock">SAFEraseBlock</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="safwriteword"></span>SAFWriteWord

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    SAFWriteWord ( location, data_word_value )
```

<span class="strong">**Command Availability:**</span>

Available on all PIC micro-controllers with SAFM memory

<span class="strong">**Explanation:**</span>  
  
SAFWriteWord is used to write information, word values, to the SAFM data
storage, so that it can be accessed later by a programmer on a Personal,
or by the SAFRead commands.  
  
`location` presents the location or relative address to write. The
location will range from 0 to SAF\_BYTES -1.    Each data Word requires
2 SAF Locations, therefore the location will range from either 0 to 254
or 0 to 126 (in steps of 2), depending upon the device.  
  
`data` is the data that is to be written to the SAFM location.   This
can be a word value or a word variable.  
  
This method writes information to SAFM given the specific location in
SAFM.    This method is similar to the methods for EEPROM, but supports
Word values.  
  
<span class="strong">**Example 1:**</span>

``` screen
    '... code preamble to select part
    '... code to setup serial

    'The following example stores in the word value of 0x1234 as SAFM location 34

    SAFWriteWord( 34, 0x1234 )
```

  
  
<span class="strong">**Example 2:**</span>

``` screen
    #chip 18F24K42, 16
    '... code to setup PPS
    '... code to setup serial

    'This example will write two word values to two specific locations.

     dim Word_Variable1 as Word
     dim Word_Variable2 as Word

    ;Write the data
    SAFWriteWord (16, 0x1234)   'location 16, in this device, equates to 0x7F10
    SAFWriteWord (18, 0x4321)   'location 18, in this device, equates to 0x7F12

   ;Read the data and send to terminal
    SAFReadWord(16, Word_Variable1 )
    SAFReadWord(18, Word_Variable2 )

   HserPrint "Word_Variable1 = "
   Hserprint Word_Variable1
   HSerPrintCRLF
   HserPrint "Word_Variable2 = "
   Hserprint Word_Variable2
   HSerPrintCRLF
```

  
  
If example 2 were displayed on a serial terminal.   The result would
show, where `----` is the existing value.

``` screen
Word_Variable1 = 4660
Word_Variable2 = 17185
```

  
  
See also
<a href="safm_overview" class="link" title="SAFM Overview">SAFM Overview</a>,
<a href="safread" class="link" title="SAFRead">SAFRead</a>,
<a href="safreadword" class="link" title="SAFReadWord">SAFReadWord</a>,
<a href="safwrite" class="link" title="SAFWrite">SAFWrite</a>,
<a href="safwriteword" class="link" title="SAFWriteWord">SAFWriteWord</a>,
<a href="safreadblock" class="link" title="SAFReadBlock">SAFReadBlock</a>,
<a href="safwriteblock" class="link" title="SAFWriteBlock">SAFWriteBlock</a>,
<a href="saferaseblock" class="link" title="SAFEraseBlock">SAFEraseBlock</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Scale</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_maths.html" title="Maths"><link rel="prev" href="_power.html" title="Power"><link rel="next" href="_sqrt.html" title="Sqrt"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_scale"></a>Scale</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    integer_variable = Scale (value_word , fromLow_integer , fromHigh_integer , toLow_integer , toHigh_integer [, calibration_integer] )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.&nbsp;&nbsp;&nbsp;The parameters are:</p><p><code class="literal">value</code>: the number to scale. A value between 0 and 0xFFFFF - all values passed will be treated as Word variables.</p><p><code class="literal">fromLow</code>: the lower bound of the value&#8217;s current range. An Integer value between -32767 and 32767.</p><p><code class="literal">fromHigh</code>: the upper bound of the value&#8217;s current range. An Integer value between -32767 and 32767.</p><p><code class="literal">toLow</code>: the lower bound of the value&#8217;s target range. An Integer value between -32767 and 32767.</p><p><code class="literal">toHigh</code>: the upper bound of the value&#8217;s target range. An Integer value between -32767 and 32767.</p><p><code class="literal">calibration</code>: optional calibration offset value. An Integer value between -32767 and 32767.
<br>
<br></p><p>This is also an overloaded method.  You can also use word variables to provide a returned result of 0-65535.
<br></p><pre class="screen">    word_variable = Scale (value_word , fromLow_word , fromHigh_word , toLow_wordr , toHigh_word [, calibration_integer] )</pre><p>Available on all microcontrollers.&nbsp;&nbsp;&nbsp;The parameters are:</p><p><code class="literal">value</code>: the number to scale. A value between 0 and 0xFFFFF - all values passed will be treated as Word variables.</p><p><code class="literal">fromLow</code>: the lower bound of the value&#8217;s current range. A word value.</p><p><code class="literal">fromHigh</code>: the upper bound of the value&#8217;s current range. A word value.</p><p><code class="literal">toLow</code>: the lower bound of the value&#8217;s target range.  A word value.</p><p><code class="literal">toHigh</code>: the upper bound of the value&#8217;s target range.  A word value.</p><p><code class="literal">calibration</code>: optional calibration offset value. An Integer value between -32767 and 32767.
<br>
<br>
<span class="strong"><strong>Explanation:</strong></span></p><p>Scales, re-maps, a number from one range to another.&nbsp;&nbsp;&nbsp;That is, a value of fromLow would gets scaled to toLow, a value of fromHigh to toHigh, values in-between to values in-between, etc.</p><p>The method does not constrain values to within the integer range returned, because out-of-range values are sometimes intended and useful.</p><p>Note that the "lower bounds" of either range may be larger or smaller than the "upper bounds" so the scale() method may be used to reverse a range of numbers, for example:</p><pre class="screen">    my_newvalue  = scale ( ReadAD10(An0) , 0, 1023, 135, 270)</pre><p>The method also handles negative integer numbers well, so that this example:</p><pre class="screen">    my_newvalue = scale(ReadAD(An0), 0, 255, 50, -100);</pre><p>This method is similar to the Ardunio Map() function.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="scale"></span>Scale

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    integer_variable = Scale (value_word , fromLow_integer , fromHigh_integer , toLow_integer , toHigh_integer [, calibration_integer] )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.   The parameters are:

`value`: the number to scale. A value between 0 and 0xFFFFF - all values
passed will be treated as Word variables.

`fromLow`: the lower bound of the value’s current range. An Integer
value between -32767 and 32767.

`fromHigh`: the upper bound of the value’s current range. An Integer
value between -32767 and 32767.

`toLow`: the lower bound of the value’s target range. An Integer value
between -32767 and 32767.

`toHigh`: the upper bound of the value’s target range. An Integer value
between -32767 and 32767.

`calibration`: optional calibration offset value. An Integer value
between -32767 and 32767.  
  

This is also an overloaded method. You can also use word variables to
provide a returned result of 0-65535.  

``` screen
    word_variable = Scale (value_word , fromLow_word , fromHigh_word , toLow_wordr , toHigh_word [, calibration_integer] )
```

Available on all microcontrollers.   The parameters are:

`value`: the number to scale. A value between 0 and 0xFFFFF - all values
passed will be treated as Word variables.

`fromLow`: the lower bound of the value’s current range. A word value.

`fromHigh`: the upper bound of the value’s current range. A word value.

`toLow`: the lower bound of the value’s target range. A word value.

`toHigh`: the upper bound of the value’s target range. A word value.

`calibration`: optional calibration offset value. An Integer value
between -32767 and 32767.  
  
<span class="strong">**Explanation:**</span>

Scales, re-maps, a number from one range to another.   That is, a value
of fromLow would gets scaled to toLow, a value of fromHigh to toHigh,
values in-between to values in-between, etc.

The method does not constrain values to within the integer range
returned, because out-of-range values are sometimes intended and useful.

Note that the "lower bounds" of either range may be larger or smaller
than the "upper bounds" so the scale() method may be used to reverse a
range of numbers, for example:

``` screen
    my_newvalue  = scale ( ReadAD10(An0) , 0, 1023, 135, 270)
```

The method also handles negative integer numbers well, so that this
example:

``` screen
    my_newvalue = scale(ReadAD(An0), 0, 255, 50, -100);
```

This method is similar to the Ardunio Map() function.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Scripts</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_readtable.html" title="ReadTable"><link rel="next" href="_subroutines.html" title="Subroutines"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_scripts"></a>Scripts</h3></div></div></div><p><span class="strong"><strong>About Scripts</strong></span></p><p>A script is a small section of code that GCBASIC runs when it
starts to compile a program.  Uses include performing calculations
that are required to adjust the program for different chip frequencies.</p><p>Scripts are not compiled or downloaded to the microcontroller - GCBASIC
reads them, executes them, then removes them from the program and then the
results calculated can be used as <span class="emphasis"><em>constants</em></span> in the user program.</p><p>Inside a script, <span class="emphasis"><em>constants</em></span> are treated like variables.  Scripts can read
the values of <span class="emphasis"><em>constants</em></span>, and set them to contain new values.</p><p><span class="strong"><strong>Using Scripts</strong></span></p><p>Scripts start with <code class="literal">#script</code> and end with <code class="literal">#endscript</code>. Inside, they can
consist of the following commands:</p><pre class="screen">    If
    Assignment (=)
    Error
    Warning
    Int()</pre><p><code class="literal">If</code> is similar to the If command in normal GCBASIC code, except that it does not have an <code class="literal">Else</code> clause.
It is used to compare the values of the script constants.</p><p>The <code class="literal">=</code> sign is identical to that in GCBASIC programs.
The <span class="emphasis"><em>constant</em></span> that is to be set goes on the left side of the <code class="literal">=</code> and the new value goes to the right of the <code class="literal">=</code>.</p><p><code class="literal">Error</code> is used to display an error message.
Anything after the <code class="literal">Error</code> command is displayed at the end of compilation, and is saved in the error log for the program.</p><p><code class="literal">Warning</code> is used to display a warning message. Anything after the <code class="literal">Warning</code> command is displayed at the end of compilation but warning does not halt compilation.</p><p><code class="literal">Int()</code> will calculate the integer value of a calculation. Using <code class="literal">Int()</code> is critical to set the <span class="emphasis"><em>constant</em></span> to the integer component of the calculation.</p><p><span class="strong"><strong>Notes:</strong></span></p><p>Use <code class="literal">Warning</code> to display constant values when creating and debugging scripts.</p><p>Scripts have a limited syntax and limited error checking when compiling.  The compiler may halt if you get something wrong.</p><p>Scripts that are incorrectly formatted may also halt the compiler or return unrelated error.</p><p>Scripts used for calculations should use the <code class="literal">Int( expression )</code> where you may have a floating point numbers returned.<br>
Scripts do use floating point for all calculations and a failure to use <code class="literal">Int()</code> may set the script constant and the resulting <span class="emphasis"><em>constant</em></span> to 0.</p><p>Scripts may require that complex math expressions may require definition in multiple steps/line to simplify the calculation.<br>
The returned value could be incorrect if simplification is not implemented.</p><p>Scripts can only access existing <code class="literal">constants</code> both user and system defined.</p><p>User defines variables are not accessible within the scope of a script.</p><p>Scripts has precendence over #define.  A #define constant statements are read first, then scripts run.
So, a script will always overwrite a constant that was set with #define.</p><p>Use <code class="literal">Warning</code> to display constants values when creating and debugging scripts.</p><p><span class="strong"><strong>Example Script</strong></span></p><p>This script is used in the pwm.h file.
It takes the values of the user defined <span class="emphasis"><em>constants</em></span> PWM_Freq, PWM_Duty and system <span class="emphasis"><em>constant</em></span> ChipMHz and calculates the results using the equations.
These calculation are based on information from a Microchip PIC datasheet to calculate the correct values to setup Pulse Width Modulation (PWM).</p><pre class="screen">    #script
        PR2Temp = INT((1/PWM_Freq)/(4*(1/(ChipMHz*1000))))
        T2PR = 1
        If PR2Temp &gt; 255 Then
            PR2Temp = INT((1 / PWM_Freq) / (16 * (1 / (ChipMHz * 1000))))
            T2PR = 4
            If PR2Temp &gt; 255 Then
                PR2Temp = INT(( 1 / PWM_Freq) / (64 * (1 / (ChipMHz * 1000))))
                T2PR = 16
                If PR2Temp &gt; 255 Then
                    Error Invalid PWM Frequency value
                End If
            End If
        End If

        DutyCycle = (PWM_Duty * 10.24) * PR2Temp / 1024
        DutyCycleH = (DutyCycle AND 1020) / 4
        DutyCycleL = DutyCycle AND 3
    #endscript</pre><p>During the execution of the script the calculations and assignment uses the constants in the script.</p><p>After this script has completed the <span class="emphasis"><em>constants</em></span> <code class="literal">PR2Temp</code>, <code class="literal">DutyCycleH</code> and <code class="literal">DutyCycleL</code> are set using the constants and/or the calculations.</p><p>The <span class="emphasis"><em>constants</em></span> assigned in this script, <code class="literal">PR2Temp</code>, <code class="literal">DutyCycleH</code> and <code class="literal">DutyCycleL</code>, are made available as <span class="emphasis"><em>constants</em></span> in the user program.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="scripts"></span>Scripts

</div>

</div>

</div>

<span class="strong">**About Scripts**</span>

A script is a small section of code that GCBASIC runs when it starts to
compile a program. Uses include performing calculations that are
required to adjust the program for different chip frequencies.

Scripts are not compiled or downloaded to the microcontroller - GCBASIC
reads them, executes them, then removes them from the program and then
the results calculated can be used as <span
class="emphasis">*constants*</span> in the user program.

Inside a script, <span class="emphasis">*constants*</span> are treated
like variables. Scripts can read the values of <span
class="emphasis">*constants*</span>, and set them to contain new values.

<span class="strong">**Using Scripts**</span>

Scripts start with `#script` and end with `#endscript`. Inside, they can
consist of the following commands:

``` screen
    If
    Assignment (=)
    Error
    Warning
    Int()
```

`If` is similar to the If command in normal GCBASIC code, except that it
does not have an `Else` clause. It is used to compare the values of the
script constants.

The `=` sign is identical to that in GCBASIC programs. The <span
class="emphasis">*constant*</span> that is to be set goes on the left
side of the `=` and the new value goes to the right of the `=`.

`Error` is used to display an error message. Anything after the `Error`
command is displayed at the end of compilation, and is saved in the
error log for the program.

`Warning` is used to display a warning message. Anything after the
`Warning` command is displayed at the end of compilation but warning
does not halt compilation.

`Int()` will calculate the integer value of a calculation. Using `Int()`
is critical to set the <span class="emphasis">*constant*</span> to the
integer component of the calculation.

<span class="strong">**Notes:**</span>

Use `Warning` to display constant values when creating and debugging
scripts.

Scripts have a limited syntax and limited error checking when compiling.
The compiler may halt if you get something wrong.

Scripts that are incorrectly formatted may also halt the compiler or
return unrelated error.

Scripts used for calculations should use the `Int( expression )` where
you may have a floating point numbers returned.  
Scripts do use floating point for all calculations and a failure to use
`Int()` may set the script constant and the resulting <span
class="emphasis">*constant*</span> to 0.

Scripts may require that complex math expressions may require definition
in multiple steps/line to simplify the calculation.  
The returned value could be incorrect if simplification is not
implemented.

Scripts can only access existing `constants` both user and system
defined.

User defines variables are not accessible within the scope of a script.

Scripts has precendence over \#define. A \#define constant statements
are read first, then scripts run. So, a script will always overwrite a
constant that was set with \#define.

Use `Warning` to display constants values when creating and debugging
scripts.

<span class="strong">**Example Script**</span>

This script is used in the pwm.h file. It takes the values of the user
defined <span class="emphasis">*constants*</span> PWM\_Freq, PWM\_Duty
and system <span class="emphasis">*constant*</span> ChipMHz and
calculates the results using the equations. These calculation are based
on information from a Microchip PIC datasheet to calculate the correct
values to setup Pulse Width Modulation (PWM).

``` screen
    #script
        PR2Temp = INT((1/PWM_Freq)/(4*(1/(ChipMHz*1000))))
        T2PR = 1
        If PR2Temp > 255 Then
            PR2Temp = INT((1 / PWM_Freq) / (16 * (1 / (ChipMHz * 1000))))
            T2PR = 4
            If PR2Temp > 255 Then
                PR2Temp = INT(( 1 / PWM_Freq) / (64 * (1 / (ChipMHz * 1000))))
                T2PR = 16
                If PR2Temp > 255 Then
                    Error Invalid PWM Frequency value
                End If
            End If
        End If

        DutyCycle = (PWM_Duty * 10.24) * PR2Temp / 1024
        DutyCycleH = (DutyCycle AND 1020) / 4
        DutyCycleL = DutyCycle AND 3
    #endscript
```

During the execution of the script the calculations and assignment uses
the constants in the script.

After this script has completed the <span
class="emphasis">*constants*</span> `PR2Temp`, `DutyCycleH` and
`DutyCycleL` are set using the constants and/or the calculations.

The <span class="emphasis">*constants*</span> assigned in this script,
`PR2Temp`, `DutyCycleH` and `DutyCycleL`, are made available as <span
class="emphasis">*constants*</span> in the user program.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SDD1289 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_pcd8544_controllers.html" title="PCD8544 Controllers"><link rel="next" href="_sh1106_controllers.html" title="SH1106 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_sdd1289_controllers"></a>SDD1289 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the SDD1289 graphics controller.  The SDD1289 is a 240 x 320 single chip controller driver IC for 262k color (RGB) amorphous TFT LCD.</p><p>The GCBASIC constants shown below control the configuration of the SDD1289 controller. &nbsp;&nbsp;&nbsp;GCBASIC supports SPI hardware and software connectivity  - this is shown in the tables below.</p><p>GCBASIC supports 65K-color mode operations.</p><p>To use the SDD1289 driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_SDD1289
    'Pin mappings for SDD1289
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting</pre><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Default</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_SDD1289</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DC</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Reset</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DI</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DO</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_SCK</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constant</th><th align="left" valign="top">Purpose</th><th align="left" valign="top">Default</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p>Set automatically</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p>Set automatically</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="left" valign="top"><p>6</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2,  [Optional In LineColour as 0 or 1]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2,  [Optional In LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2,  [Optional In LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SDD1289_[color]</code></p></td><td align="left" valign="top"><p>Specify color as a parameter for many GLCD commands</p></td><td align="left" valign="top"><p>Color constants for this device are shown in the list below.<br>
</p><p> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td></tr></tbody></table></div><pre class="screen">      SSD1289_BLACK   'hexidecimal value 0x0000
      SSD1289_RED     'hexidecimal value 0xF800
      SSD1289_GREEN   'hexidecimal value 0x07E0
      SSD1289_BLUE    'hexidecimal value 0x001F
      SSD1289_WHITE   'hexidecimal value 0xFFFF
      SSD1289_PURPLE  'hexidecimal value 0xF11F
      SSD1289_YELLOW  'hexidecimal value 0xFFE0
      SSD1289_CYAN    'hexidecimal value 0x07FF
      SSD1289_D_GRAY  'hexidecimal value 0x528A
      SSD1289_L_GRAY  'hexidecimal value 0x7997
      SSD1289_SILVER  'hexidecimal value 0xC618
      SSD1289_MAROON  'hexidecimal value 0x8000
      SSD1289_OLIVE   'hexidecimal value 0x8400
      SSD1289_LIME    'hexidecimal value 0x07E0
      SSD1289_AQUA    'hexidecimal value 0x07FF
      SSD1289_TEAL    'hexidecimal value 0x0410
      SSD1289_NAVY    'hexidecimal value 0x0010
      SSD1289_FUCHSIA 'hexidecimal value 0xF81F</pre><p>For a SDD1289 datasheet, please refer <a class="link" href="http://gcbasic.sourceforge.net/library/DISPLAY/SDD1289.pdf" target="_top">here</a>.<br></p><p>This example shows how to drive a SDD1289 based Graphic LCD module with the built in commands of GCBASIC.<br></p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    ;Chip Settings
    #chip 16F1937,32
    #config MCLRE_ON

    #include &lt;glcd.h&gt;

    'Defines for SDD1289
    #define GLCD_TYPE GLCD_TYPE_SDD1289
    'Pin mappings for SDD1289
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the SDD1289 Device")
    end</pre><p><br>
<br>
<span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> OR <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="sdd1289_controllers"></span>SDD1289 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the SDD1289 graphics
controller. The SDD1289 is a 240 x 320 single chip controller driver IC
for 262k color (RGB) amorphous TFT LCD.

The GCBASIC constants shown below control the configuration of the
SDD1289 controller.    GCBASIC supports SPI hardware and software
connectivity - this is shown in the tables below.

GCBASIC supports 65K-color mode operations.

To use the SDD1289 driver simply include the following in your user
code. This will initialise the driver.

``` screen
    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_SDD1289
    'Pin mappings for SDD1289
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting
```

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

| Constants    | Controls                                                                          | Default  |
|:-------------|:----------------------------------------------------------------------------------|:---------|
| `GLCD_TYPE`  | `GLCD_TYPE_SDD1289`                                                               |          |
| `GLCD_DC`    | Specifies the output pin that is connected to Data/Command IO pin on the GLCD.    | Required |
| `GLCD_CS`    | Specifies the output pin that is connected to Chip Select (CS) on the GLCD.       | Required |
| `GLCD_Reset` | Specifies the output pin that is connected to Reset pin on the GLCD.              | Required |
| `GLCD_DI`    | Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD. | Required |
| `GLCD_DO`    | Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD. | Required |
| `GLCD_SCK`   | Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.        | Required |

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

| Constant        | Purpose                                           | Default           |
|:----------------|:--------------------------------------------------|:------------------|
| `GLCD_WIDTH`    | The width parameter of the GLCD                   | Set automatically |
| `GLCD_HEIGHT`   | The height parameter of the GLCD                  | Set automatically |
| `GLCDFontWidth` | Specifies the font width of the GCBASIC font set. | 6                 |

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
<td style="text-align: left;"><p>Clear screen of GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDPrint</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar</code></p></td>
<td style="text-align: left;"><p>Print character on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDDrawString</code></p></td>
<td style="text-align: left;"><p>Print characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Box</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size</p></td>
<td style="text-align: left;"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2,  [Optional In LineColour as 0 or 1]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">FilledBox</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td>
<td style="text-align: left;"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2,  [Optional In LineColour 0 or 1] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Line</code></p></td>
<td style="text-align: left;"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2,  [Optional In LineColour 0 or 1] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">PSet</code></p></td>
<td style="text-align: left;"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte</code></p></td>
<td style="text-align: left;"><p>Set a byte value to the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDReadByte</code></p></td>
<td style="text-align: left;"><p>Read a byte value from the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">SDD1289_[color]</code></p></td>
<td style="text-align: left;"><p>Specify color as a parameter for many GLCD commands</p></td>
<td style="text-align: left;"><p>Color constants for this device are shown in the list below.<br />
</p>
<p>Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td>
</tr>
</tbody>
</table>

</div>

``` screen
      SSD1289_BLACK   'hexidecimal value 0x0000
      SSD1289_RED     'hexidecimal value 0xF800
      SSD1289_GREEN   'hexidecimal value 0x07E0
      SSD1289_BLUE    'hexidecimal value 0x001F
      SSD1289_WHITE   'hexidecimal value 0xFFFF
      SSD1289_PURPLE  'hexidecimal value 0xF11F
      SSD1289_YELLOW  'hexidecimal value 0xFFE0
      SSD1289_CYAN    'hexidecimal value 0x07FF
      SSD1289_D_GRAY  'hexidecimal value 0x528A
      SSD1289_L_GRAY  'hexidecimal value 0x7997
      SSD1289_SILVER  'hexidecimal value 0xC618
      SSD1289_MAROON  'hexidecimal value 0x8000
      SSD1289_OLIVE   'hexidecimal value 0x8400
      SSD1289_LIME    'hexidecimal value 0x07E0
      SSD1289_AQUA    'hexidecimal value 0x07FF
      SSD1289_TEAL    'hexidecimal value 0x0410
      SSD1289_NAVY    'hexidecimal value 0x0010
      SSD1289_FUCHSIA 'hexidecimal value 0xF81F
```

For a SDD1289 datasheet, please refer
<a href="http://gcbasic.sourceforge.net/library/DISPLAY/SDD1289.pdf" class="link">here</a>.  

This example shows how to drive a SDD1289 based Graphic LCD module with
the built in commands of GCBASIC.  

<span class="strong">**Example:**</span>

``` screen
    ;Chip Settings
    #chip 16F1937,32
    #config MCLRE_ON

    #include <glcd.h>

    'Defines for SDD1289
    #define GLCD_TYPE GLCD_TYPE_SDD1289
    'Pin mappings for SDD1289
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the SDD1289 Device")
    end
```

  
  
<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
OR <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Select</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_flow_control.html" title="Flow control"><link rel="prev" href="_repeat.html" title="Repeat"><link rel="next" href="_wait.html" title="Wait"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_select"></a>Select</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Select Case <span class="emphasis"><em>var</em></span>

    Case <span class="emphasis"><em>value1</em></span>
      <span class="emphasis"><em>code1</em></span>

    Case <span class="emphasis"><em>value2</em></span>
      <span class="emphasis"><em>code2</em></span>

    Case <span class="emphasis"><em>value_3 To _value4</em></span>
      <span class="emphasis"><em>code3</em></span>

    Case Else
      <span class="emphasis"><em>code4</em></span>

    End Select</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The Select Case control structure is used to select and run a particular
section of code, based on the value of <code class="literal"><span class="emphasis"><em>var</em></span></code>. If <code class="literal"><span class="emphasis"><em>var</em></span></code> equals <code class="literal"><span class="emphasis"><em>value1</em></span></code>
then <code class="literal"><span class="emphasis"><em>code1</em></span></code> will be run. Once <code class="literal"><span class="emphasis"><em>code1</em></span></code> has run, the chip will jump to
the <code class="literal">End Select</code> command and continue running the program. If none of the
other conditions are true, then the code under the <code class="literal">Case Else</code> section
will be run.</p><p><code class="literal">Case <span class="emphasis"><em>var</em></span> TO <span class="emphasis"><em>var</em></span></code> is a range of values. If the value is within the range the code section will be executed.</p><p><code class="literal">Case Else</code> is optional, and the program will function correctly without
it.</p><p>If there is only one line of code after the <code class="literal">Case</code>, the code may look
neater if the line is placed after the <code class="literal">Case</code>. This is shown below in the
example, for cases 3, 4 and 5.</p><p>It is important to note that <span class="strong"><strong>only one section of code will be run</strong></span> when
using <code class="literal">Select Case</code>.</p><p>There are two examples shown below.</p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    'Program to read a value from a potentiometer, and display a
    'different word based on the result

      #chip 16F877a, 4

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_NO_RW
    #define LCD_Enable PORTD.2

    DIR PORTA.0 IN
    Do
      Temp = ReadAD(AN0) / 20
      CLS
      Select Case Temp
        Case 0
          Print "None!"
        Case 1
          Print "One"
        Case 2
          Print "Two"
        Case 3: Print "Three"
        Case 4: Print "Four"
        Case 5: Print "Five"
        Case Else
          Print "A lot!"
      End Select
      Wait 250 ms
    Loop</pre><p><span class="strong"><strong>Example 2:</strong></span></p><p>This code demonstrates how to receive codes from a handheld remote
control unit. This has been tested and supports a Sony TV remote and
also a universal remote set to Sony TV mode.</p><p>The program gets both the device number and the key number, and also
translates the key number to English. The received results are displayed
on an LCD.</p><p>The circuit for the IR receiver and the chip is shown below.</p><pre class="screen">    'A program to receive IR codes sent by a Sony
    'compatible handheld remote control.

    #chip 16F88, 8                    'PIC16F88 running at 8 MHz
    #config mclr=off                  'reset handled internally

    '----- Constants

    #define LCD_IO      4             '4-bit mode
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS      PortB.2       'pin 8 is Register Select
    #define LCD_Enable  PortB.3       'pin 9 is Enable
    #define LCD_DB4     PortB.4       'DB4 on pin 10
    #define LCD_DB5     PortB.5       'DB5 on pin 11
    #define LCD_DB6     PortB.6       'DB6 on pin 12
    #define LCD_DB7     PortB.7       'DB7 on pin 13
    #define LCD_NO_RW                 'ground RW line on LCD
    #define IR          PortA.0       'sensor on pin 17

    '----- Variables

    dim device, cmd, count, i as byte
    dim pulse(12)                     'pulse count array
    dim button as string              'ASCII for button label

    '----- Program

    dir PortA in                      'A.0 is IR input
    dir PortB out                     'B.2 - B.6 for LCD

    cls                               'clear the LCD
    print "Dev:    Cmd:"              'logo for top line
    locate 1,0
    print "Button:"                   'logo for second line

    do
      getIR, cmd                      'wait for IR signal
      printCmd                        'show device and command
      printKey                        'show key label
      wait 10 mS                      'ignore any repeats
    loop                              'repeat forever

    '----- Subroutines

    sub getIR
      tarry1:
        count = 0                     'wait for start bit
        do while IR = 0               'measure width (active low)
          wait 100 uS                 '24 X 100 uS = 2.4 mS
          count += 1
        loop
      if count &lt; 20 then goto tarry1  'less than this so wait

      for i=1 to 12                   'read/store the 12 pulses
        tarry2:
          count = 0
          do while IR = 0             'zero = 6 units = 0.6 mS
            wait 100 uS               'one = 12 units = 1.2 mS
            count += 1
          loop
        if count &lt; 4 then goto tarry2 'too small to be legit
        pulse(i) = count              'else store pulse width
      next

      cmd = 0                         'command built up here
      for i = 1 to 7                  '1st seven bits are the cmd
        cmd = cmd / 2                 'shift into place
        if pulse(i) &gt; 10 then         'longer than 10 mS
           cmd = cmd + 64             'so call it a one
        end if
      next

      device = 0                      'device number built up here
      for i=8 to 12                   'next 5 bits are device number
        device = device / 2
        if pulse(i) &gt; 10 then
           device = device + 16
        end if
      next
    end sub

    sub printCmd            'print device number
      locate 0,5
      print "   "
      locate 0,5
      print device

      locate 0,13           'print raw command number
      print "   "
      locate 0,13
      print cmd
    end sub

    sub PrintKey            'print translated button
      locate 1,9
      print "       "
      locate 1,9

      select case cmd       'translate command code
        case 0
          button = "One"
        case 1
          button = "Two"
        case 2
          button = "Three"
        case 3
          button = "Four"
        case 4
          button = "Five"
        case 5
          button = "Six"
        case 6
          button = "Seven"
        case 7
          button = "Eight"
        case 8
          button = "Nine"
        case 9
          button = "Zero"
        case 10
          button = "#####"
        case 11
          button = "Enter"
        case 12
          button = "#####"
        case 13
          button = "#####"
        case 14
          button = "#####"
        case 15
          button = "#####"
        case 16
          button = "Chan+"
        case 17
          button = "Chan-"
        case 18
          button = "Vol+"
        case 19
          button = "Vol-"
        case 20
          button = "Mute"
        case 21
          button = "Power"
        case else
          button = "     "
      end select
      print button
    end sub</pre><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/selectb1.PNG" align="middle" alt="graphic"></div></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="select"></span>Select

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Select Case var

    Case value1
      code1

    Case value2
      code2

    Case value_3 To _value4
      code3

    Case Else
      code4

    End Select
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The Select Case control structure is used to select and run a particular
section of code, based on the value of `var`. If `var` equals `value1`
then `code1` will be run. Once `code1` has run, the chip will jump to
the `End Select` command and continue running the program. If none of
the other conditions are true, then the code under the `Case Else`
section will be run.

`Case var TO var` is a range of values. If the value is within the range
the code section will be executed.

`Case Else` is optional, and the program will function correctly without
it.

If there is only one line of code after the `Case`, the code may look
neater if the line is placed after the `Case`. This is shown below in
the example, for cases 3, 4 and 5.

It is important to note that <span class="strong">**only one section of
code will be run**</span> when using `Select Case`.

There are two examples shown below.

<span class="strong">**Example 1:**</span>

``` screen
    'Program to read a value from a potentiometer, and display a
    'different word based on the result

      #chip 16F877a, 4

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_NO_RW
    #define LCD_Enable PORTD.2

    DIR PORTA.0 IN
    Do
      Temp = ReadAD(AN0) / 20
      CLS
      Select Case Temp
        Case 0
          Print "None!"
        Case 1
          Print "One"
        Case 2
          Print "Two"
        Case 3: Print "Three"
        Case 4: Print "Four"
        Case 5: Print "Five"
        Case Else
          Print "A lot!"
      End Select
      Wait 250 ms
    Loop
```

<span class="strong">**Example 2:**</span>

This code demonstrates how to receive codes from a handheld remote
control unit. This has been tested and supports a Sony TV remote and
also a universal remote set to Sony TV mode.

The program gets both the device number and the key number, and also
translates the key number to English. The received results are displayed
on an LCD.

The circuit for the IR receiver and the chip is shown below.

``` screen
    'A program to receive IR codes sent by a Sony
    'compatible handheld remote control.

    #chip 16F88, 8                    'PIC16F88 running at 8 MHz
    #config mclr=off                  'reset handled internally

    '----- Constants

    #define LCD_IO      4             '4-bit mode
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS      PortB.2       'pin 8 is Register Select
    #define LCD_Enable  PortB.3       'pin 9 is Enable
    #define LCD_DB4     PortB.4       'DB4 on pin 10
    #define LCD_DB5     PortB.5       'DB5 on pin 11
    #define LCD_DB6     PortB.6       'DB6 on pin 12
    #define LCD_DB7     PortB.7       'DB7 on pin 13
    #define LCD_NO_RW                 'ground RW line on LCD
    #define IR          PortA.0       'sensor on pin 17

    '----- Variables

    dim device, cmd, count, i as byte
    dim pulse(12)                     'pulse count array
    dim button as string              'ASCII for button label

    '----- Program

    dir PortA in                      'A.0 is IR input
    dir PortB out                     'B.2 - B.6 for LCD

    cls                               'clear the LCD
    print "Dev:    Cmd:"              'logo for top line
    locate 1,0
    print "Button:"                   'logo for second line

    do
      getIR, cmd                      'wait for IR signal
      printCmd                        'show device and command
      printKey                        'show key label
      wait 10 mS                      'ignore any repeats
    loop                              'repeat forever

    '----- Subroutines

    sub getIR
      tarry1:
        count = 0                     'wait for start bit
        do while IR = 0               'measure width (active low)
          wait 100 uS                 '24 X 100 uS = 2.4 mS
          count += 1
        loop
      if count < 20 then goto tarry1  'less than this so wait

      for i=1 to 12                   'read/store the 12 pulses
        tarry2:
          count = 0
          do while IR = 0             'zero = 6 units = 0.6 mS
            wait 100 uS               'one = 12 units = 1.2 mS
            count += 1
          loop
        if count < 4 then goto tarry2 'too small to be legit
        pulse(i) = count              'else store pulse width
      next

      cmd = 0                         'command built up here
      for i = 1 to 7                  '1st seven bits are the cmd
        cmd = cmd / 2                 'shift into place
        if pulse(i) > 10 then         'longer than 10 mS
           cmd = cmd + 64             'so call it a one
        end if
      next

      device = 0                      'device number built up here
      for i=8 to 12                   'next 5 bits are device number
        device = device / 2
        if pulse(i) > 10 then
           device = device + 16
        end if
      next
    end sub

    sub printCmd            'print device number
      locate 0,5
      print "   "
      locate 0,5
      print device

      locate 0,13           'print raw command number
      print "   "
      locate 0,13
      print cmd
    end sub

    sub PrintKey            'print translated button
      locate 1,9
      print "       "
      locate 1,9

      select case cmd       'translate command code
        case 0
          button = "One"
        case 1
          button = "Two"
        case 2
          button = "Three"
        case 3
          button = "Four"
        case 4
          button = "Five"
        case 5
          button = "Six"
        case 6
          button = "Seven"
        case 7
          button = "Eight"
        case 8
          button = "Nine"
        case 9
          button = "Zero"
        case 10
          button = "#####"
        case 11
          button = "Enter"
        case 12
          button = "#####"
        case 13
          button = "#####"
        case 14
          button = "#####"
        case 15
          button = "#####"
        case 16
          button = "Chan+"
        case 17
          button = "Chan-"
        case 18
          button = "Vol+"
        case 19
          button = "Vol-"
        case 20
          button = "Mute"
        case 21
          button = "Power"
        case else
          button = "     "
      end select
      print button
    end sub
```

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/selectb1.PNG)

</div>

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Serial Communications</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_ds18b20setresolution.html" title="DS18B20SetResolution"><link rel="next" href="_rs232_software.html" title="RS232 (software)"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_serial_communications"></a>Serial Communications</h3></div></div></div><p>This is the Serial Communications section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="serial_communications"></span>Serial Communications

</div>

</div>

</div>

This is the Serial Communications section of the Help file. Please refer
the sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Serial/RS232 Buffer Ring</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_programs.html" title="Example Programs"><link rel="prev" href="_rgb_led_control.html" title="RGB LED Control"><link rel="next" href="_trigonometry_circle.html" title="Trigonometry Circle"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_serial_rs232_buffer_ring"></a>Serial/RS232 Buffer Ring</h3></div></div></div><p><span class="strong"><strong>Explanation:</strong></span></p><p>This program demonstrates how to create a serial input buffer ring.</p><p>The program receives a character into the buffer and sends back.  Try sending large volumes of characters&#8230;&#8203;..</p><p>This program program uses an interrupt event to capture the incoming byte value and place in the buffer ring. When a byte is received the buffer ring is incremented to ensuer the next byte is handled correctly.</p><p>Testing <code class="literal">bkbhit</code> will set to True when a byte has been received. Reading the function <code class="literal">bgetc</code> will return the last byte received.</p><p><span class="strong"><strong>Demonstration program:</strong></span></p><p>This demonstration program will support up to 256 bytes. For a larger buffer change the variables to words.</p><pre class="screen">    #chip 16F1937


    ' Add PPS if appropiate for your chip
    ' [change to your config] This is the config for a serial terminal

    ' assumes USART1
    ' turn on the RS232 and terminal port.
    ' Define the USART settings
    #DEFINE USART_BAUD_RATE 9600

    'This assumes you are using an ANSI compatible terminal.  Use PUTTY.EXE it is very easy to use.

    '   Main program

    'Wait for terminal to settle
    wait 3 s

    'Create the supporting variables
    Dim next_in As Byte
    Dim next_out As Byte
    Dim syncbyte As Byte
    Dim temppnt As Byte

    ' Constants etc required for Buffer Ring
    #DEFINE BUFFER_SIZE 8
    #DEFINE bkbhit (next_in &lt;&gt; next_out)

    'Define the Buffer
    Dim buffer( BUFFER_SIZE - 1 ) 'we will use element 0 in the array as part of out buffer

    'Call init the buffer
    InitBufferRing

    HSerSend 10
    HSerSend 13
    HSerSend 10
    HSerSend 13
    HSerPrint "Started: Serial between two devices"
    HSerSend 10
    HSerSend 13


    'Get character(s) and send back
    Do

        ' Do we have data in the buffer?
        if bkbhit then

            'Send the next character in the buffer, exposed via the function `bgetc` back the terminal
            HSerSend bgetc

        end if

    Loop

    'Supporting subroutines

    Sub readUSART

        buffer(next_in) = HSerReceive
        temppnt = next_in
        next_in = ( next_in + 1 ) % BUFFER_SIZE
        If ( next_in = next_out ) Then  ' buffer is full!!
            next_in = temppnt
        End If

    End Sub

    Function bgetc
        Dim local_next_out as Byte    'maintain a local copy of the next_out variable to ensure it does not change when an Interrupt happens
        local_next_out = next_out
        bgetc = buffer(local_next_out)
        local_next_out=(local_next_out+1) % BUFFER_SIZE
        INTOFF
        next_out = local_next_out
        INTON
    End Function




    Sub InitBufferRing

        'Set the buffer to the first address
        next_in = 0
        next_out = 0
        'Interrupt Handler - some have RCIE and some have U1RXIE, so handle
        #IFDEF BIT( RCIE )
            On Interrupt UsartRX1Ready Call readUSART
        #ENDIF
        #IFDEF BIT( U1RXIE )
            On Interrupt UART1ReceiveInterrupt Call readUSART
        #ENDIF
        #IFDEF AVR
            On Interrupt UsartRX1Ready Call readUSART
        #ENDIF

    End Sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="serial_rs232_buffer_ring"></span>Serial/RS232 Buffer Ring

</div>

</div>

</div>

<span class="strong">**Explanation:**</span>

This program demonstrates how to create a serial input buffer ring.

The program receives a character into the buffer and sends back. Try
sending large volumes of characters…​..

This program program uses an interrupt event to capture the incoming
byte value and place in the buffer ring. When a byte is received the
buffer ring is incremented to ensuer the next byte is handled correctly.

Testing `bkbhit` will set to True when a byte has been received. Reading
the function `bgetc` will return the last byte received.

<span class="strong">**Demonstration program:**</span>

This demonstration program will support up to 256 bytes. For a larger
buffer change the variables to words.

``` screen
    #chip 16F1937


    ' Add PPS if appropiate for your chip
    ' [change to your config] This is the config for a serial terminal

    ' assumes USART1
    ' turn on the RS232 and terminal port.
    ' Define the USART settings
    #DEFINE USART_BAUD_RATE 9600

    'This assumes you are using an ANSI compatible terminal.  Use PUTTY.EXE it is very easy to use.

    '   Main program

    'Wait for terminal to settle
    wait 3 s

    'Create the supporting variables
    Dim next_in As Byte
    Dim next_out As Byte
    Dim syncbyte As Byte
    Dim temppnt As Byte

    ' Constants etc required for Buffer Ring
    #DEFINE BUFFER_SIZE 8
    #DEFINE bkbhit (next_in <> next_out)

    'Define the Buffer
    Dim buffer( BUFFER_SIZE - 1 ) 'we will use element 0 in the array as part of out buffer

    'Call init the buffer
    InitBufferRing

    HSerSend 10
    HSerSend 13
    HSerSend 10
    HSerSend 13
    HSerPrint "Started: Serial between two devices"
    HSerSend 10
    HSerSend 13


    'Get character(s) and send back
    Do

        ' Do we have data in the buffer?
        if bkbhit then

            'Send the next character in the buffer, exposed via the function `bgetc` back the terminal
            HSerSend bgetc

        end if

    Loop

    'Supporting subroutines

    Sub readUSART

        buffer(next_in) = HSerReceive
        temppnt = next_in
        next_in = ( next_in + 1 ) % BUFFER_SIZE
        If ( next_in = next_out ) Then  ' buffer is full!!
            next_in = temppnt
        End If

    End Sub

    Function bgetc
        Dim local_next_out as Byte    'maintain a local copy of the next_out variable to ensure it does not change when an Interrupt happens
        local_next_out = next_out
        bgetc = buffer(local_next_out)
        local_next_out=(local_next_out+1) % BUFFER_SIZE
        INTOFF
        next_out = local_next_out
        INTON
    End Function




    Sub InitBufferRing

        'Set the buffer to the first address
        next_in = 0
        next_out = 0
        'Interrupt Handler - some have RCIE and some have U1RXIE, so handle
        #IFDEF BIT( RCIE )
            On Interrupt UsartRX1Ready Call readUSART
        #ENDIF
        #IFDEF BIT( U1RXIE )
            On Interrupt UART1ReceiveInterrupt Call readUSART
        #ENDIF
        #IFDEF AVR
            On Interrupt UsartRX1Ready Call readUSART
        #ENDIF

    End Sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SerNPrint</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_software_optimised.html" title="RS232 (software optimised)"><link rel="prev" href="_sernsend.html" title="SerNSend"><link rel="next" href="_sernreceive.html" title="SerNReceive"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_sernprint"></a>SerNPrint</h5></div></div></div><p><span class="strong"><strong>Ser1Print, Ser2Print, Ser3Print</strong></span></p><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Ser1Print value
    Ser2Print value
    Ser3Print value</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will send a value using the channel referred to as Ser1.. , Ser2&#8230;&#8203; , Ser3&#8230;&#8203; according to the rules set by the related defines.
value can be a string, integer, long, word or byte.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will send text and an icrementing value using PORTB.1

    ; ----- Configuration
    #chip 16F886, 16
    #option Explicit

    ; ----- Include library
    #include &lt;SoftSerial.h&gt;

    ; ----- Config Serial UART :
    #define SER1_BAUD 115200   ; baudrate must be defined
    ; Config I/O ports for transmitting:
    #define SER1_TXPORT PORTB  ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 1       ; portbit  must be defined

    ; ----- Variables
    Dim xx As Word
    xx = 1000

    ; ----- Main body of program commences here.
    Do Forever
      Wait 1 s       'time to enjoy the result
      Ser1Send  13   'new line in Terminal
      Ser1Send  10
      Ser1Print "Software-UART: "  'send a text
      Ser1Print xx   'send the value of xx
      xx += 1
    Loop</pre><p>Exposed in SoftSerial.h authored by Frank Steinberg</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="sernprint"></span>SerNPrint

</div>

</div>

</div>

<span class="strong">**Ser1Print, Ser2Print, Ser3Print**</span>

<span class="strong">**Syntax:**</span>

``` screen
    Ser1Print value
    Ser2Print value
    Ser3Print value
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This command will send a value using the channel referred to as Ser1.. ,
Ser2…​ , Ser3…​ according to the rules set by the related defines. value
can be a string, integer, long, word or byte.

<span class="strong">**Example:**</span>

``` screen
    'This program will send text and an icrementing value using PORTB.1

    ; ----- Configuration
    #chip 16F886, 16
    #option Explicit

    ; ----- Include library
    #include <SoftSerial.h>

    ; ----- Config Serial UART :
    #define SER1_BAUD 115200   ; baudrate must be defined
    ; Config I/O ports for transmitting:
    #define SER1_TXPORT PORTB  ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 1       ; portbit  must be defined

    ; ----- Variables
    Dim xx As Word
    xx = 1000

    ; ----- Main body of program commences here.
    Do Forever
      Wait 1 s       'time to enjoy the result
      Ser1Send  13   'new line in Terminal
      Ser1Send  10
      Ser1Print "Software-UART: "  'send a text
      Ser1Print xx   'send the value of xx
      xx += 1
    Loop
```

Exposed in SoftSerial.h authored by Frank Steinberg

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SerNReceive</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_software_optimised.html" title="RS232 (software optimised)"><link rel="prev" href="_sernprint.html" title="SerNPrint"><link rel="next" href="_rs232_hardware.html" title="RS232 (hardware)"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_sernreceive"></a>SerNReceive</h5></div></div></div><p><span class="strong"><strong>Ser1Receive, Ser2Receive, Ser3Receive</strong></span></p><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    bytevar = Ser1Receive
    bytevar = Ser2Receive
    bytevar = Ser3Receive</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This function will read a byte using the channel referred to as Ser1.. , Ser2&#8230;&#8203; , Ser3&#8230;&#8203; according to the rules set by the related defines. The received byte is stored in the variable bytevar.
By default the function waits for the startbit impulse edge before executing the following commands. See the sample files how to realize timeout-functionality or interrupt-driven receiving.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will receive bytes on PORTB.0 and send back using PORTB.1

    ; ----- Configuration
    #chip 16F886, 16
    #option Explicit

    ; ----- Include library
    #include &lt;SoftSerial.h&gt;

    ; ----- Config Serial UART :
    #define SER1_BAUD 115200   ; baudrate must be defined
    #define SER1_DATABITS 7    ; databits optional (default = 8)
    #define SER1_STOPBITS 2    ; stopbits optional (default = 1)
    #define SER1_INVERT Off    ; inverted polarity optional (default = Off)
    ; Config I/O ports for transmitting:
    #define SER1_TXPORT PORTB  ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 1       ; portbit  must be defined
    ; Config I/O ports for receiving:
    #define SER1_RXPORT PORTB  ; I/O port (without .bit) must be defined
    #define SER1_RXPIN 0       ; portbit  must be defined
    #define SER1_RXNOWAIT Off  ; don't wait for stopbit optional (default = Off)

    ; ----- Variables
    Dim RecByte As Byte

    ; ----- Main body of program commences here.
     Wait 1 Ms     'delay to prevent garbage if sending too quick after init
     Ser1Send 10   'new line in Terminal
     Ser1Send 13   '
     Ser1Print "Please send a byte!"

     Do Forever
      RecByte = Ser1Receive   'receive one byte - wait until detecting startbit
      Ser1Send  13            'new line in Terminal
      Ser1Send  10            '
      Ser1Print "You sent: "  'send a text
      Ser1Send RecByte        'send the sign representing the byte
     Loop</pre><p>Exposed in SoftSerial.h authored by Frank Steinberg</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="sernreceive"></span>SerNReceive

</div>

</div>

</div>

<span class="strong">**Ser1Receive, Ser2Receive, Ser3Receive**</span>

<span class="strong">**Syntax:**</span>

``` screen
    bytevar = Ser1Receive
    bytevar = Ser2Receive
    bytevar = Ser3Receive
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This function will read a byte using the channel referred to as Ser1.. ,
Ser2…​ , Ser3…​ according to the rules set by the related defines. The
received byte is stored in the variable bytevar. By default the function
waits for the startbit impulse edge before executing the following
commands. See the sample files how to realize timeout-functionality or
interrupt-driven receiving.

<span class="strong">**Example:**</span>

``` screen
    'This program will receive bytes on PORTB.0 and send back using PORTB.1

    ; ----- Configuration
    #chip 16F886, 16
    #option Explicit

    ; ----- Include library
    #include <SoftSerial.h>

    ; ----- Config Serial UART :
    #define SER1_BAUD 115200   ; baudrate must be defined
    #define SER1_DATABITS 7    ; databits optional (default = 8)
    #define SER1_STOPBITS 2    ; stopbits optional (default = 1)
    #define SER1_INVERT Off    ; inverted polarity optional (default = Off)
    ; Config I/O ports for transmitting:
    #define SER1_TXPORT PORTB  ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 1       ; portbit  must be defined
    ; Config I/O ports for receiving:
    #define SER1_RXPORT PORTB  ; I/O port (without .bit) must be defined
    #define SER1_RXPIN 0       ; portbit  must be defined
    #define SER1_RXNOWAIT Off  ; don't wait for stopbit optional (default = Off)

    ; ----- Variables
    Dim RecByte As Byte

    ; ----- Main body of program commences here.
     Wait 1 Ms     'delay to prevent garbage if sending too quick after init
     Ser1Send 10   'new line in Terminal
     Ser1Send 13   '
     Ser1Print "Please send a byte!"

     Do Forever
      RecByte = Ser1Receive   'receive one byte - wait until detecting startbit
      Ser1Send  13            'new line in Terminal
      Ser1Send  10            '
      Ser1Print "You sent: "  'send a text
      Ser1Send RecByte        'send the sign representing the byte
     Loop
```

Exposed in SoftSerial.h authored by Frank Steinberg

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SerNSend</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_software_optimised.html" title="RS232 (software optimised)"><link rel="prev" href="_rs232_software_overview_optimised.html" title="RS232 Software Overview - Optimised"><link rel="next" href="_sernprint.html" title="SerNPrint"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_sernsend"></a>SerNSend</h5></div></div></div><p><span class="strong"><strong>Ser1Send, Ser2Send, Ser3Send</strong></span></p><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Ser1Send data
    Ser2Send data
    Ser3Send data</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will send a byte given by data using the channel referred to as Ser1.. , Ser2&#8230;&#8203; , Ser3&#8230;&#8203; according to the rules set by the related defines.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will send one byte using PORTA.5

    ; ----- Configuration
    #chip 12F1501, 1

    ; ----- Include library
    #include &lt;SoftSerial.h&gt;

    ; ----- Config Serial UART for sending:
    #define SER1_BAUD 9600     ; baudrate must be defined
    #define SER1_TXPORT PORTA  ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 5       ; portbit  must be defined

    ; ----- Main body of program commences here.
    Ser1Send 88   'send one byte (88 = X)</pre><p>Exposed in SoftSerial.h authored by Frank Steinberg</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="sernsend"></span>SerNSend

</div>

</div>

</div>

<span class="strong">**Ser1Send, Ser2Send, Ser3Send**</span>

<span class="strong">**Syntax:**</span>

``` screen
    Ser1Send data
    Ser2Send data
    Ser3Send data
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This command will send a byte given by data using the channel referred
to as Ser1.. , Ser2…​ , Ser3…​ according to the rules set by the related
defines.

<span class="strong">**Example:**</span>

``` screen
    'This program will send one byte using PORTA.5

    ; ----- Configuration
    #chip 12F1501, 1

    ; ----- Include library
    #include <SoftSerial.h>

    ; ----- Config Serial UART for sending:
    #define SER1_BAUD 9600     ; baudrate must be defined
    #define SER1_TXPORT PORTA  ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 5       ; portbit  must be defined

    ; ----- Main body of program commences here.
    Ser1Send 88   'send one byte (88 = X)
```

Exposed in SoftSerial.h authored by Frank Steinberg

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SerPrint</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_software.html" title="RS232 (software)"><link rel="prev" href="_serreceive.html" title="SerReceive"><link rel="next" href="_rs232_software_optimised.html" title="RS232 (software optimised)"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_serprint"></a>SerPrint</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  SerPrint <span class="emphasis"><em>channel, value</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">SerPrint</code> is used to send a value over the serial connection. <code class="literal"><span class="emphasis"><em>value</em></span></code> can
be a string, integer, long, word or byte.</p><p><code class="literal"><span class="emphasis"><em>channel</em></span></code> is the serial connection to send data through (1 | 2 |3 ).</p><p><code class="literal">SerPrint</code> will not send any new line characters. If the chip is sending
to a terminal, these commands should follow <code class="literal">SerPrint</code>.</p><pre class="screen">    SerSend channel, 13
    SerSend channel, 10</pre><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will display any values received over the serial
    'connection. If "pot" is received, the value of the analog sensor
    'will be sent.

    'Chip settings
    #chip 18F2525, 8

    'LCD settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTC.7
    #define LCD_RW PORTC.6
    #define LCD_Enable PORTC.5
    #define LCD_DB4 PORTC.4
    #define LCD_DB5 PORTC.3
    #define LCD_DB6 PORTC.2
    #define LCD_DB7 PORTC.1

    'Serial settings
    #define RS232Out PORTB.0
    #define RS232In  PORTB.1

    'Set pin direction
    Dir RS232Out Out
    Dir RS232In In

    'Config Software-UART
    #define SendAHigh Set RS232Out ON
    #define SendALow Set RS232Out OFF
    #define RecAHigh Set RS232In ON
    #define RecALow Set RS232In OFF
    set RS232Out On

    Do
      'Potentiometer
      #define POT_PORT PORTA.0
      #define POT_AN AN0

      'Set pin direction
      Dir POT_PORT In

      'Create buffer variables to store received messages
      Dim Buffer As String
      Dim OldBuffer As String
      BufferSize = 0

      'Set up serial connection
      InitSer 1, r9600, 1 + WaitForStart, 8, 1, none, invert

      'Show test messages
      Print "Serial Tester"
      Wait 1 s
      SerPrint 1, "GCBASIC RS232 Test"
      SerSend 1, 13
      SerSend 1, 10
      Wait 1 s

      'Main loop
     'Get a byte from the terminal
      SerReceive 1, Temp

      'If Enter key was pressed, deal with buffer contents
      If Temp = 13 Then
        Buffer(0) = BufferSize

        'Try to execute commands in buffer
        If Not ExecCommand (Buffer) Then
          'Show message on bottom line, last message on top.
          CLS
          Print OldBuffer
          Locate 1, 0
          Print Buffer
          'Store the message for next time
          OldBuffer = Buffer
        End If

        BufferSize = 0
      End If
      'Backspace code, delete last character in buffer
      If Temp = 8 Then
        If BufferSize &gt; 0 Then BufferSize -= 1
      End If
      'Received ASCII code between 32 and 127, add to buffer
      If Temp &gt;= 32 And Temp &lt;= 127 Then
        BufferSize += 1
        Buffer(BufferSize) = Temp
      End If
    Loop

    'Takes a sensor reading and sends it to terminal
    Sub SendSensorReading
      SerPrint 1, "Sensor Reading: "
      SerPrint 1, ReadAD10(POT_AN)
      SerSend 1, 13
      SerSend 1, 10
    End Sub

    'Will check the buffer for a command
    'If command found, run it and return true
    'If not, return false
    Function ExecCommand (CmdIn As String)
      ExecCommand = False
      'If received command is "pot", show potentiometer value
      If CmdIn = "pot" Then
        SendSensorReading
        ExecCommand = True
      End If
    End Function</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_rs232_software_overview.html" title="RS232 Software Overview">RS232 Software Overview</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="serprint"></span>SerPrint

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  SerPrint channel, value
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

`SerPrint` is used to send a value over the serial connection. `value`
can be a string, integer, long, word or byte.

`channel` is the serial connection to send data through (1 \| 2 \|3 ).

`SerPrint` will not send any new line characters. If the chip is sending
to a terminal, these commands should follow `SerPrint`.

``` screen
    SerSend channel, 13
    SerSend channel, 10
```

<span class="strong">**Example:**</span>

``` screen
    'This program will display any values received over the serial
    'connection. If "pot" is received, the value of the analog sensor
    'will be sent.

    'Chip settings
    #chip 18F2525, 8

    'LCD settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTC.7
    #define LCD_RW PORTC.6
    #define LCD_Enable PORTC.5
    #define LCD_DB4 PORTC.4
    #define LCD_DB5 PORTC.3
    #define LCD_DB6 PORTC.2
    #define LCD_DB7 PORTC.1

    'Serial settings
    #define RS232Out PORTB.0
    #define RS232In  PORTB.1

    'Set pin direction
    Dir RS232Out Out
    Dir RS232In In

    'Config Software-UART
    #define SendAHigh Set RS232Out ON
    #define SendALow Set RS232Out OFF
    #define RecAHigh Set RS232In ON
    #define RecALow Set RS232In OFF
    set RS232Out On

    Do
      'Potentiometer
      #define POT_PORT PORTA.0
      #define POT_AN AN0

      'Set pin direction
      Dir POT_PORT In

      'Create buffer variables to store received messages
      Dim Buffer As String
      Dim OldBuffer As String
      BufferSize = 0

      'Set up serial connection
      InitSer 1, r9600, 1 + WaitForStart, 8, 1, none, invert

      'Show test messages
      Print "Serial Tester"
      Wait 1 s
      SerPrint 1, "GCBASIC RS232 Test"
      SerSend 1, 13
      SerSend 1, 10
      Wait 1 s

      'Main loop
     'Get a byte from the terminal
      SerReceive 1, Temp

      'If Enter key was pressed, deal with buffer contents
      If Temp = 13 Then
        Buffer(0) = BufferSize

        'Try to execute commands in buffer
        If Not ExecCommand (Buffer) Then
          'Show message on bottom line, last message on top.
          CLS
          Print OldBuffer
          Locate 1, 0
          Print Buffer
          'Store the message for next time
          OldBuffer = Buffer
        End If

        BufferSize = 0
      End If
      'Backspace code, delete last character in buffer
      If Temp = 8 Then
        If BufferSize > 0 Then BufferSize -= 1
      End If
      'Received ASCII code between 32 and 127, add to buffer
      If Temp >= 32 And Temp <= 127 Then
        BufferSize += 1
        Buffer(BufferSize) = Temp
      End If
    Loop

    'Takes a sensor reading and sends it to terminal
    Sub SendSensorReading
      SerPrint 1, "Sensor Reading: "
      SerPrint 1, ReadAD10(POT_AN)
      SerSend 1, 13
      SerSend 1, 10
    End Sub

    'Will check the buffer for a command
    'If command found, run it and return true
    'If not, return false
    Function ExecCommand (CmdIn As String)
      ExecCommand = False
      'If received command is "pot", show potentiometer value
      If CmdIn = "pot" Then
        SendSensorReading
        ExecCommand = True
      End If
    End Function
```

<span class="strong">**For more help, see**</span>
<a href="rs232_software_overview" class="link" title="RS232 Software Overview">RS232 Software Overview</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SerReceive</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_software.html" title="RS232 (software)"><link rel="prev" href="_sersend.html" title="SerSend"><link rel="next" href="_serprint.html" title="SerPrint"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_serreceive"></a>SerReceive</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  SerReceive <span class="emphasis"><em>channel</em></span>, <span class="emphasis"><em>output</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will read a byte from the RS232 channel given by
<code class="literal"><span class="emphasis"><em>channel</em></span></code> according to the rules set using <code class="literal">InitSer</code>, and store the
received byte in the variable <code class="literal"><span class="emphasis"><em>output</em></span></code>.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  'This program will read a byte from PORTB.2, and set the LED on if
  'the byte is more than 50. This can be used with the SerSend
  'example program.

  #chip 16F88, 8

  #define RecAHigh PORTB.2 ON
  #define RecALow PORTB.2 OFF
  #define LED PORTB.0

  Dir PORTB.0 Out
  Dir PORTB.2 In

  InitSer 1, r9600, 1 + WaitForStart, 8, 1, none, normal
  Do
    SerReceive 1, Temp
    If Temp &lt;= 50 Then Set LED Off
    If Temp &gt; 50 Then Set LED On
  Loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_rs232_software_overview.html" title="RS232 Software Overview">RS232 Software Overview</a>,
<a class="link" href="_initser.html" title="InitSer">InitSer</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="serreceive"></span>SerReceive

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  SerReceive channel, output
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This command will read a byte from the RS232 channel given by `channel`
according to the rules set using `InitSer`, and store the received byte
in the variable `output`.

<span class="strong">**Example:**</span>

``` screen
  'This program will read a byte from PORTB.2, and set the LED on if
  'the byte is more than 50. This can be used with the SerSend
  'example program.

  #chip 16F88, 8

  #define RecAHigh PORTB.2 ON
  #define RecALow PORTB.2 OFF
  #define LED PORTB.0

  Dir PORTB.0 Out
  Dir PORTB.2 In

  InitSer 1, r9600, 1 + WaitForStart, 8, 1, none, normal
  Do
    SerReceive 1, Temp
    If Temp <= 50 Then Set LED Off
    If Temp > 50 Then Set LED On
  Loop
```

<span class="strong">**For more help, see**</span>
<a href="rs232_software_overview" class="link" title="RS232 Software Overview">RS232 Software Overview</a>,
<a href="initser" class="link" title="InitSer">InitSer</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SerSend</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_software.html" title="RS232 (software)"><link rel="prev" href="_initser.html" title="InitSer"><link rel="next" href="_serreceive.html" title="SerReceive"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_sersend"></a>SerSend</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  SerSend <span class="emphasis"><em>channel</em></span>, <span class="emphasis"><em>data</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will send a byte given by <code class="literal"><span class="emphasis"><em>data</em></span></code> using the RS232 channel
referred to as <code class="literal"><span class="emphasis"><em>channel</em></span></code> according to the rules set using <code class="literal">InitSer</code>.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  'This program will send a byte using PORTB.2, the value of which
  'depends on whether a button is pressed. This can be used with the example for SerReceive.

  #chip 16F819, 8

  #define RS232Out PORTB.2
  #define RS232In  PORTB.1

  Dir RS232Out Out
  Dir RS232In In

  'Config Software-UART
  #define SendAHigh Set RS232Out ON
  #define SendALow Set RS232Out OFF
  #define RecAHigh Set RS232In ON
  #define RecALow Set RS232In OFF

  Dir Button In

  InitSer 1, r9600, 1+WaitForStart, 8, 1, none, normal
  Do
    If Button = On Then Temp = 100
    If Button = Off Then Temp = 0
    SerSend 1, Temp
    Wait 100 ms
  Loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_rs232_software_overview.html" title="RS232 Software Overview">RS232 Software Overview</a>,
<a class="link" href="_initser.html" title="InitSer">InitSer</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="sersend"></span>SerSend

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  SerSend channel, data
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This command will send a byte given by `data` using the RS232 channel
referred to as `channel` according to the rules set using `InitSer`.

<span class="strong">**Example:**</span>

``` screen
  'This program will send a byte using PORTB.2, the value of which
  'depends on whether a button is pressed. This can be used with the example for SerReceive.

  #chip 16F819, 8

  #define RS232Out PORTB.2
  #define RS232In  PORTB.1

  Dir RS232Out Out
  Dir RS232In In

  'Config Software-UART
  #define SendAHigh Set RS232Out ON
  #define SendALow Set RS232Out OFF
  #define RecAHigh Set RS232In ON
  #define RecALow Set RS232In OFF

  Dir Button In

  InitSer 1, r9600, 1+WaitForStart, 8, 1, none, normal
  Do
    If Button = On Then Temp = 100
    If Button = Off Then Temp = 0
    SerSend 1, Temp
    Wait 100 ms
  Loop
```

<span class="strong">**For more help, see**</span>
<a href="rs232_software_overview" class="link" title="RS232 Software Overview">RS232 Software Overview</a>,
<a href="initser" class="link" title="InitSer">InitSer</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Set</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_rotate.html" title="Rotate"><link rel="next" href="_swap4.html" title="SWAP4"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_set"></a>Set</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Set <span class="emphasis"><em>variable.bit</em></span> {On | Off}</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The purpose of the Set command is to turn individuals bits on and off.</p><p>The Set command is most useful for controlling output ports, but can also be used to set variables.</p><p>Often when controlling output ports, Set is used in conjunction with constants. This makes it easier to adapt the program for a new circuit later.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Blink LED sample program for GCBASIC
    'Controls an LED on PORTB bit 0.

    'Set chip model and config options
    #chip 16F84A, 20

    'Set a constant to represent the output port
    #define LED PORTB.0

    'Set pin direction
    Dir LED Out

    'Main routine
    Do
        Set LED On
        Wait 1 sec
        Set LED OFF
        Wait 1 sec
    Loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="set"></span>Set

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Set variable.bit {On | Off}
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The purpose of the Set command is to turn individuals bits on and off.

The Set command is most useful for controlling output ports, but can
also be used to set variables.

Often when controlling output ports, Set is used in conjunction with
constants. This makes it easier to adapt the program for a new circuit
later.

<span class="strong">**Example:**</span>

``` screen
    'Blink LED sample program for GCBASIC
    'Controls an LED on PORTB bit 0.

    'Set chip model and config options
    #chip 16F84A, 20

    'Set a constant to represent the output port
    #define LED PORTB.0

    'Set pin direction
    Dir LED Out

    'Main routine
    Do
        Set LED On
        Wait 1 sec
        Set LED OFF
        Wait 1 sec
    Loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Settimer</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_inittimer12.html" title="InitTimer12"><link rel="next" href="_starttimer.html" title="StartTimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_settimer"></a>Settimer</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Settimer <span class="emphasis"><em>timernumber</em></span>, <span class="emphasis"><em>byte_value</em></span>

    Settimer <span class="emphasis"><em>timernumber</em></span>, <span class="emphasis"><em>word_value</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a Timer modules.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">Settimer</code> will set the value of the specified timer with either byte value or a word value.
8-bit timers use a byte value. 16-bit timers use a word value.</p><p><code class="literal">Settimer</code> can be used on-the-fly, so there is no requirement to stop the timer first.</p><p>Refer to the datasheet for timer specific information.</p><p><br>
<br>
<br>
<span class="strong"><strong>Example:</strong></span></p><p>This example shows the operation of setting two timers - is not intended as a meaningful solution.</p><pre class="screen">    #chip 16f877a, 4
    On Interrupt Timer1Overflow call Overflowed
    Set PORTB.0 On

    InitTimer1 Osc, PS1_8
    SetTimer 1, 1
    StartTimer 1

    InitTimer2 PS2_16, PS2_16
    SetTimer 2, 255
    StartTimer 2

    'Manually set Timer2Overflow to create a second event
    'this will event will be handled by the Interrupt sub routine
    TMR2IE = 1
    end

    Sub Interrupt
      Set PORTB.2 On
      TMR2IF = 0
    End Sub

    Sub Overflowed
      Set PORTB.1 On
      TMR1IF = 0
    End Sub</pre><p><span class="strong"><strong>Supported in &lt;TIMER.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="settimer"></span>Settimer

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Settimer timernumber, byte_value

    Settimer timernumber, word_value
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a Timer modules.

<span class="strong">**Explanation:**</span>

`Settimer` will set the value of the specified timer with either byte
value or a word value. 8-bit timers use a byte value. 16-bit timers use
a word value.

`Settimer` can be used on-the-fly, so there is no requirement to stop
the timer first.

Refer to the datasheet for timer specific information.

  
  
  
<span class="strong">**Example:**</span>

This example shows the operation of setting two timers - is not intended
as a meaningful solution.

``` screen
    #chip 16f877a, 4
    On Interrupt Timer1Overflow call Overflowed
    Set PORTB.0 On

    InitTimer1 Osc, PS1_8
    SetTimer 1, 1
    StartTimer 1

    InitTimer2 PS2_16, PS2_16
    SetTimer 2, 255
    StartTimer 2

    'Manually set Timer2Overflow to create a second event
    'this will event will be handled by the Interrupt sub routine
    TMR2IE = 1
    end

    Sub Interrupt
      Set PORTB.2 On
      TMR2IF = 0
    End Sub

    Sub Overflowed
      Set PORTB.1 On
      TMR1IF = 0
    End Sub
```

<span class="strong">**Supported in &lt;TIMER.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Setting Variables</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_more_on_setting_variables_and_constants.html" title="More on setting Variables and Constants"><link rel="next" href="_variable_lifecycle.html" title="Variable Lifecycle"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_setting_variables"></a>Setting Variables</h4></div></div></div><p><br>
<span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>Variable</em></span> = <span class="emphasis"><em>data</em></span></pre><p><br>
<span class="strong"><strong>Explanation:</strong></span>
<br>
<code class="literal"><span class="emphasis"><em>Variable</em></span></code> will be set to <code class="literal"><span class="emphasis"><em>data</em></span></code>.<br>
<code class="literal"><span class="emphasis"><em>data</em></span></code> can be either a fixed value (such as 157), another variable, or a sum.
<br>
All unknown byte variables are assigned Zero. A variable with the name of <span class="strong"><strong>Forever</strong></span> is not defined by GCBASIC and therefore defaults to the value of zero.
<br>
If <code class="literal"><span class="emphasis"><em>data</em></span></code> is a fixed value, it must be an integer between 0 and 255 inclusive.
<br>
If <code class="literal"><span class="emphasis"><em>data</em></span></code> is a calculation, then it may have any of the following operands:</p><p><br></p><pre class="screen">    + (add)
    - (subtract, or negate if there is no value before it)
    * (multiply)
    / (divide)
    % (modulo)
    &amp; (and)
    | (or)
    # (xor)
    ! (not)
    = (equal)
    &lt;&gt; (not equal)
    &lt; (less than)
    &gt; (greater than)
    &lt;= (less than or equal)
    &gt;= (more than or equal)</pre><p><br>
The final six operands are for checking conditions.  They will return FALSE (0) if the condition is false, or TRUE (255) if the condition is true.
<br>
The <code class="literal">And</code>, <code class="literal">Or</code>, <code class="literal">Xor</code> and <code class="literal">Not</code> operators function both as bitwise and logical operators.
<br>
GCBASIC understands order of operations. If multiple operands are present, they will be processed in this order:
<br></p><pre class="screen">    Brackets
    Unary operations (not and negate)
    Multiply/Divide/Modulo
    Add/Subtract
    Conditional operators
    And/Or/Xor</pre><p><br>
There are several modes in which variables can be set. GCBASIC will automatically use a different mode for each calculation, depending on the type of variable being set. If a byte variable is being set, byte mode will be used; if a word variable is being set, word mode will be used. If a byte is being set but the calculation involves numbers larger than 255, word mode can be used by adding [WORD] to the start of one of the values in the calculation. This is known as casting - refer to the Variables article for more information.
<br>
<br></p><p><span class="strong"><strong>And with other operations</strong></span></p><p>The order of operations, comparison operations have a higher precedence than boolean operations.&nbsp;&nbsp;GCBASIC behaves the same way as most other languages.&nbsp;&nbsp;Source code like this (randomly taken from glcd_ili9326.h) works.</p><pre class="screen">if GLCDfntDefaultSize = 2 and CurrCharRow = 7 then</pre><p>It is an easy mistake to compare values and get the precendent incorrect.&nbsp;&nbsp;Generally, if you can use an individual bit check, that is generally the best way to go. These are a lot simpler for the compiler to deal with and result in much nicer assembly.</p><p>This works using the correct order of precendence.</p><pre class="screen">    if (H_Byte &amp; 0x10) = 0x10 Then ...

    'or, using the individual bit check to do the same
    if H_Byte.4 Then</pre><p>This will fail as the order of precendence as shown below.</p><pre class="screen">    if H_Byte &amp; 0x10 = 0x10 Then ...

    'the code above equates. This is not achieve the testing of the H_byte.4
    if H_Byte &amp; ( 0x10 = 0x10 ) Then ...</pre><p><span class="strong"><strong>Divide or division</strong></span></p><p>GCBASIC support division.</p><p>When using division you will get accurate results, within the limitations of integer numbers, by completing any multiplication first and the division last. &nbsp;&nbsp;But, you may have issues with variables overflowing - ensure your variable type are correct for the calculation type.</p><p>If you that calculation a division, the compiler will use the long division routine, if the value may overflow, and then  fit the result into a word. &nbsp;&nbsp;This code provides the correct result, again within the limitations of integer numbers:</p><pre class="screen">    dim L1s as word
    dim L1p as word
    L1s = 6547200 / L1p</pre><p>Division also sets the global system variable SysCalcTempX to the remainder of the division.&nbsp;&nbsp;However the following simple rules apply.
<br></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">If both of the parameters of the division are constants, the compiler will do the calculation itself and use the result rather than making the microcontroller work out the same thing every time.  So, if there are two constants used, the microcontroller division routine does not get used, and SysCalcTempX does not get set.</li><li class="listitem">If either of the parameters of the division are variables, the compiler will ensure the microcontroller does the calculation as the result could be different every time.  So, in the this case the microcontroller division routine does get used, and SysCalcTempX is set.
<br></li></ul></div><p>If you prefer, you can add <code class="literal">Let</code> to the start of the line. &nbsp;&nbsp;It will not alter the execution of the program, but is included for those who are used to including it in other BASIC dialects.
<br>
<br></p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program is to illustrate the setting of variables.
    Chipmunk = 46        'Sets the variable Chipmunk to 46
    Animal = Chipmunk    'Sets the variable Animal to the value of the variable Chipmunk
    Bear = 2 + 3 * 5     'Sets the variable Bear to the result of 2 + 3 * 5, 17.
    Sheep = (2 + 3) * 5  'Sets the variable Sheep to the result of (2 + 3) * 5, 25.
    Animal = 2 * Bear    'Sets the variable Animal to twice the value of Bear.

    LargeVar = 321       'LargeVar must be set as a word - see DIM.
    Temp = LargeVar / [WORD]5 'Note the use of [WORD] to ensure that the calculation is performed correctly</pre><p><br>
<br>
<span class="strong"><strong>Setting Explicit Bits of a Variable/Register:</strong></span>
<br>
<br>
GCBASIC supports the method setting a specific bit of a variable or register.  Use the following method:
<br></p><pre class="screen">    'variable.bit method
    myByteVariable.0 = 1   'will set bit 0 to 1
    myByteVariable.1 = 0   'will set bit 1 to 0
    myByteVariable.2 = 1   'will set bit 2 to 1</pre><p><br></p><p>To set more than one bit in one command GCBASIC supports the bits method.
<br></p><p>GCBASIC also supports setting specific bits of a variable or register.  Use the following method:
<br></p><pre class="screen">    'variable.bitS method
    SPLLEN, IRCF3, IRCF2, IRCF1, IRCF0 = b'01111'
    ' would generate ASM [for your specific microcontroller like the following.
    ' bcf OSCTUNE,PLLEN,ACCESS
    ' bsf OSCCON,IRCF2,ACCESS
    ' bsf OSCCON,IRCF1,ACCESS
    ' bsf OSCCON,IRCF0,ACCESS</pre><p><br>
This method is limited to literal values.  You cannot use value from another variable as the setting value (at v0.98.00).
<br>
<br></p><p><span class="strong"><strong>Setting Explicit Bits of a Variable/Register with Error Handling</strong></span>
<br>
<br>
To set more than one bit in one command GCBASIC supports the bits method.
<br></p><p>GCBASIC also supports setting specific bits of a variable or register with error handling.  Use this method to prevent errors when a specified bit does not exist.
<br></p><p>The <code class="literal">[canskip]</code> prefix will handle the error condition when a specific bit or specific bits do not exist.  The following example shows the usage.
<br></p><pre class="screen">    [canskip] SPLLEN, IRCF3, IRCF2, IRCF1, IRCF0 = b'01111'</pre><p><br>
This method is limited to literal values.  You cannot use value from another variable as the setting value (at v0.98.00).
<br>
<br>
This example shows how the error handler compares to not have the <code class="literal">[canskip]</code> prefix
<br></p><pre class="screen">      ' Of these two lines, only the first compiles:
      [canskip] SPLLEN, IRCF3, IRCF2, IRCF1, IRCF0 = b'01111'    'first line with error handler
      SPLLEN, IRCF3, IRCF2, IRCF1, IRCF0 = b'01111'              'second line with no error handler

      'Second line produces this message:
      'samevar.gcb (16): Error: Bit IRCF3 is not a valid bit and cannot be set</pre><p><br>
<span class="strong"><strong>Setting a String - set a string with Escape characters</strong></span></p><p>An example showing how to set a string to an escape sequence for an ANSI terminal.&nbsp;&nbsp;You can `Dim`ension a string and then assign the elements similar to setting array elements.</p><pre class="screen">    dim line2 as string
    line2 =  27, "[", "2", "H", 27, "[","K"
    HSerPrint line2</pre><p>Will send the following to the terminal.
&lt;esc&gt;[2H&lt;esc&gt;[K</p><p><br>
<br></p><p><span class="strong"><strong>For more help, see:</strong></span> <a class="link" href="">Variables</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="setting_variables"></span>Setting Variables

</div>

</div>

</div>

  
<span class="strong">**Syntax:**</span>

``` screen
    Variable = data
```

  
<span class="strong">**Explanation:**</span>  
`Variable` will be set to `data`.  
`data` can be either a fixed value (such as 157), another variable, or a
sum.  
All unknown byte variables are assigned Zero. A variable with the name
of <span class="strong">**Forever**</span> is not defined by GCBASIC and
therefore defaults to the value of zero.  
If `data` is a fixed value, it must be an integer between 0 and 255
inclusive.  
If `data` is a calculation, then it may have any of the following
operands:

  

``` screen
    + (add)
    - (subtract, or negate if there is no value before it)
    * (multiply)
    / (divide)
    % (modulo)
    & (and)
    | (or)
    # (xor)
    ! (not)
    = (equal)
    <> (not equal)
    < (less than)
    > (greater than)
    <= (less than or equal)
    >= (more than or equal)
```

  
The final six operands are for checking conditions. They will return
FALSE (0) if the condition is false, or TRUE (255) if the condition is
true.  
The `And`, `Or`, `Xor` and `Not` operators function both as bitwise and
logical operators.  
GCBASIC understands order of operations. If multiple operands are
present, they will be processed in this order:  

``` screen
    Brackets
    Unary operations (not and negate)
    Multiply/Divide/Modulo
    Add/Subtract
    Conditional operators
    And/Or/Xor
```

  
There are several modes in which variables can be set. GCBASIC will
automatically use a different mode for each calculation, depending on
the type of variable being set. If a byte variable is being set, byte
mode will be used; if a word variable is being set, word mode will be
used. If a byte is being set but the calculation involves numbers larger
than 255, word mode can be used by adding \[WORD\] to the start of one
of the values in the calculation. This is known as casting - refer to
the Variables article for more information.  
  

<span class="strong">**And with other operations**</span>

The order of operations, comparison operations have a higher precedence
than boolean operations.  GCBASIC behaves the same way as most other
languages.  Source code like this (randomly taken from glcd\_ili9326.h)
works.

``` screen
if GLCDfntDefaultSize = 2 and CurrCharRow = 7 then
```

It is an easy mistake to compare values and get the precendent
incorrect.  Generally, if you can use an individual bit check, that is
generally the best way to go. These are a lot simpler for the compiler
to deal with and result in much nicer assembly.

This works using the correct order of precendence.

``` screen
    if (H_Byte & 0x10) = 0x10 Then ...

    'or, using the individual bit check to do the same
    if H_Byte.4 Then
```

This will fail as the order of precendence as shown below.

``` screen
    if H_Byte & 0x10 = 0x10 Then ...

    'the code above equates. This is not achieve the testing of the H_byte.4
    if H_Byte & ( 0x10 = 0x10 ) Then ...
```

<span class="strong">**Divide or division**</span>

GCBASIC support division.

When using division you will get accurate results, within the
limitations of integer numbers, by completing any multiplication first
and the division last.   But, you may have issues with variables
overflowing - ensure your variable type are correct for the calculation
type.

If you that calculation a division, the compiler will use the long
division routine, if the value may overflow, and then fit the result
into a word.   This code provides the correct result, again within the
limitations of integer numbers:

``` screen
    dim L1s as word
    dim L1p as word
    L1s = 6547200 / L1p
```

Division also sets the global system variable SysCalcTempX to the
remainder of the division.  However the following simple rules apply.  

<div class="itemizedlist">

-   If both of the parameters of the division are constants, the
    compiler will do the calculation itself and use the result rather
    than making the microcontroller work out the same thing every time.
    So, if there are two constants used, the microcontroller division
    routine does not get used, and SysCalcTempX does not get set.
-   If either of the parameters of the division are variables, the
    compiler will ensure the microcontroller does the calculation as the
    result could be different every time. So, in the this case the
    microcontroller division routine does get used, and SysCalcTempX is
    set.  

</div>

If you prefer, you can add `Let` to the start of the line.   It will not
alter the execution of the program, but is included for those who are
used to including it in other BASIC dialects.  
  

<span class="strong">**Example:**</span>

``` screen
    'This program is to illustrate the setting of variables.
    Chipmunk = 46        'Sets the variable Chipmunk to 46
    Animal = Chipmunk    'Sets the variable Animal to the value of the variable Chipmunk
    Bear = 2 + 3 * 5     'Sets the variable Bear to the result of 2 + 3 * 5, 17.
    Sheep = (2 + 3) * 5  'Sets the variable Sheep to the result of (2 + 3) * 5, 25.
    Animal = 2 * Bear    'Sets the variable Animal to twice the value of Bear.

    LargeVar = 321       'LargeVar must be set as a word - see DIM.
    Temp = LargeVar / [WORD]5 'Note the use of [WORD] to ensure that the calculation is performed correctly
```

  
  
<span class="strong">**Setting Explicit Bits of a
Variable/Register:**</span>  
  
GCBASIC supports the method setting a specific bit of a variable or
register. Use the following method:  

``` screen
    'variable.bit method
    myByteVariable.0 = 1   'will set bit 0 to 1
    myByteVariable.1 = 0   'will set bit 1 to 0
    myByteVariable.2 = 1   'will set bit 2 to 1
```

  

To set more than one bit in one command GCBASIC supports the bits
method.  

GCBASIC also supports setting specific bits of a variable or register.
Use the following method:  

``` screen
    'variable.bitS method
    SPLLEN, IRCF3, IRCF2, IRCF1, IRCF0 = b'01111'
    ' would generate ASM [for your specific microcontroller like the following.
    ' bcf OSCTUNE,PLLEN,ACCESS
    ' bsf OSCCON,IRCF2,ACCESS
    ' bsf OSCCON,IRCF1,ACCESS
    ' bsf OSCCON,IRCF0,ACCESS
```

  
This method is limited to literal values. You cannot use value from
another variable as the setting value (at v0.98.00).  
  

<span class="strong">**Setting Explicit Bits of a Variable/Register with
Error Handling**</span>  
  
To set more than one bit in one command GCBASIC supports the bits
method.  

GCBASIC also supports setting specific bits of a variable or register
with error handling. Use this method to prevent errors when a specified
bit does not exist.  

The `[canskip]` prefix will handle the error condition when a specific
bit or specific bits do not exist. The following example shows the
usage.  

``` screen
    [canskip] SPLLEN, IRCF3, IRCF2, IRCF1, IRCF0 = b'01111'
```

  
This method is limited to literal values. You cannot use value from
another variable as the setting value (at v0.98.00).  
  
This example shows how the error handler compares to not have the
`[canskip]` prefix  

``` screen
      ' Of these two lines, only the first compiles:
      [canskip] SPLLEN, IRCF3, IRCF2, IRCF1, IRCF0 = b'01111'    'first line with error handler
      SPLLEN, IRCF3, IRCF2, IRCF1, IRCF0 = b'01111'              'second line with no error handler

      'Second line produces this message:
      'samevar.gcb (16): Error: Bit IRCF3 is not a valid bit and cannot be set
```

  
<span class="strong">**Setting a String - set a string with Escape
characters**</span>

An example showing how to set a string to an escape sequence for an ANSI
terminal.  You can \`Dim\`ension a string and then assign the elements
similar to setting array elements.

``` screen
    dim line2 as string
    line2 =  27, "[", "2", "H", 27, "[","K"
    HSerPrint line2
```

Will send the following to the terminal. &lt;esc&gt;\[2H&lt;esc&gt;\[K

  
  

<span class="strong">**For more help, see:**</span>
<a href="" class="link">Variables</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SetWith</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_bitwise.html" title="Bitwise"><link rel="prev" href="_fnlsr.html" title="FnLSR"><link rel="next" href="_memory.html" title="Memory"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_setwith"></a>SetWith</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    SetWith(TargetBit, Source)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">SetWith</code> is an extended version of SET, it allows a Bit Field to be set or cleared by evaluating the content of Source. <code class="literal">SetWith</code> should always be used when TargetBit is an I/O Bit and Source is a Function, in order to avoid the possibility of I/O jitter.</p><p>Source may be a variable and of  type: Bit, Byte, Word or Long, a Constant, an expression or a Function.</p><p>It will SET  TargetBit  to 1 if Source evaluates to anything other than zero. TargetBit  will always be a 1 or a 0 regardless of the variable type of TargetBit.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    ' This program will reflect the state of SW1(RA3) on LED DS1(RC0) of the Microchip
    ' Low Pin Count Demo Board. Notice that because SW1 is normally High the state has to
    ' be inverted to turn on the LED (DS1) when SW1 is pressed.

    #chip   16f690    ' declare the target Device

    #Define SW1 PORTA.3
    #Define DS1 PORTC.0

    DIR DS1 Out
    DIR SW1 In

    Do
      ' set the Bit DS1 to equal the Bit SW1
      SetWith( DS1, !SW1 )
    Loop
    END</pre><p><span class="strong"><strong>See Also <a class="link" href="_bitwise_operations_overview.html" title="Bitwise Operations Overview">Bitwise Operations Overview</a></strong></span> and <span class="strong"><strong><a class="link" href="_conditions.html" title="Conditions">Conditions</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="setwith"></span>SetWith

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    SetWith(TargetBit, Source)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

`SetWith` is an extended version of SET, it allows a Bit Field to be set
or cleared by evaluating the content of Source. `SetWith` should always
be used when TargetBit is an I/O Bit and Source is a Function, in order
to avoid the possibility of I/O jitter.

Source may be a variable and of type: Bit, Byte, Word or Long, a
Constant, an expression or a Function.

It will SET TargetBit to 1 if Source evaluates to anything other than
zero. TargetBit will always be a 1 or a 0 regardless of the variable
type of TargetBit.

<span class="strong">**Example:**</span>

``` screen
    ' This program will reflect the state of SW1(RA3) on LED DS1(RC0) of the Microchip
    ' Low Pin Count Demo Board. Notice that because SW1 is normally High the state has to
    ' be inverted to turn on the LED (DS1) when SW1 is pressed.

    #chip   16f690    ' declare the target Device

    #Define SW1 PORTA.3
    #Define DS1 PORTC.0

    DIR DS1 Out
    DIR SW1 In

    Do
      ' set the Bit DS1 to equal the Bit SW1
      SetWith( DS1, !SW1 )
    Loop
    END
```

<span class="strong">**See Also
<a href="bitwise_operations_overview" class="link" title="Bitwise Operations Overview">Bitwise Operations Overview</a>**</span>
and <span
class="strong">**<a href="conditions" class="link" title="Conditions">Conditions</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SH1106 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_sdd1289_controllers.html" title="SDD1289 Controllers"><link rel="next" href="_ssd1306_controllers.html" title="SSD1306 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_sh1106_controllers"></a>SH1106 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the SH1106 graphics controller.  THe SH1106 is a single-chip CMOS OLED/PLED driver with controller for organic/polymer light emitting diode dot-matrix graphic display system.  SH1106 consists of 132 segments, 64 commons that can support a maximum display resolution of 132 X 64. It is designed for Common Cathode type OLED panel.</p><p>The GCBASIC constants shown below control the configuration of the SH1106 controller. &nbsp;&nbsp;&nbsp;GCBASIC supports i2C hardware and software connectivity  - this is shown in the tables below.</p><p>The SH1106 is a monochrome device.</p><p>To use the SH1106 driver simply include the following in your user code.  This will initialise the driver.  You can select Full Mode GLCD, Low Memory Mode GLCD or Text mode these require 1024, 128 or 0 byte GLCD buffer respectively - you microcontroller requires sufficient RAM to support the selected mode of GLCD operation.</p><pre class="screen">    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SH1106
    #define GLCD_I2C_Address 0x78
    '#define GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE        'select Low Memory mode of operation
    '#define GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY        'select Text mode of operation

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master</pre><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_SH1106</code></p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_I2C_Address</code></p></td><td align="left" valign="top"><p>I2C address of the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HI2C_BAUD_RATE</code></p></td><td align="left" valign="top"><p><code class="literal">HI2C_BAUD_RATE</code></p></td><td align="left" valign="top"><p>400 or 100</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HI2C_DATA</code></p></td><td align="left" valign="top"><p><code class="literal">HI2C_DATA</code></p></td><td align="left" valign="top"><p>Mandated, plus<br>
<code class="literal">HI2CMode Master</code> is required.</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="center" valign="top"><p><code class="literal">128</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="center" valign="top"><p><code class="literal">64</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="center" valign="top"><p><code class="literal">6</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY</code></p></td><td align="left" valign="top"><p>Specifies that the display controller will operate in text mode and BMP
draw mode only.<br>
For microcontrollers with low RAM this will be set be
default.<br>
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <code class="literal">GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE</code></p></td><td align="center" valign="top"><p>Optional</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE</code></p></td><td align="left" valign="top"><p>Specifies that the display controller will operate in Low Memory mode.</p></td><td align="center" valign="top"><p>Optional</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte (LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Open_PageTransaction</code></p></td><td align="left" valign="top"><p>Commence a series of GLCD commands when in low memory mode.  Must be followed a  <code class="literal">GLCD_Close_PageTransaction</code> command.</p></td><td align="left" valign="top"><p><code class="literal">GLCD_Close_PageTransaction 0, 7</code> where 0 and 7 are the range of pages to be updated</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Close_PageTransaction</code></p></td><td align="left" valign="top"><p>Commence a series of GLCD commands when in low memory mode.  Must follow a <code class="literal">GLCD_Open_PageTransaction</code> command.</p></td><td align="left" valign="top">&nbsp;</td></tr></tbody></table></div><p>The additional GCBASIC commands for this GLCD are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDSetDisplayInvertMode</code></p></td><td align="left" valign="top"><p>Inverts the display</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDSetDisplayNormalMode</code></p></td><td align="left" valign="top"><p>Set the display to normal mode</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDSetContrast ( dim_state )</code></p></td><td align="left" valign="top"><p>Sets the constrast between 0 and 255. The contrast increases as the value increases.<br>
Parameter is dim value</p></td></tr></tbody></table></div><p>For a SH1106 datasheet, please refer <a class="link" href="http://gcbasic.sourceforge.net/library/DISPLAY/SH1106.pdf" target="_top">here</a>.</p><p>This example shows how to drive a SH1106 based Graphic LCD module with the built in commands of GCBASIC.</p><pre class="screen">; ----- Configuration
    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SH1106
    #define GLCD_I2C_Address 0x78

    GLCDCLS
    GLCDPrint 0, 0, "GCBASIC"
    GLCDPrint (0, 16, "Anobium 2021")

    wait 3 s
    GLCDCLS

    ' Prepare the static components of the screen
    GLCDPrint ( 0,   0, "PrintStr") ; Print some text
    GLCDPrint ( 64,  0, "@")
    ; Print some more text
    GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
    GLCDPrint ( 86, 0, "Mhz") ; Print some text
    GLCDDrawString( 0,8,"DrawStr") ; Draw some text
    box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    Circle( 44,41,15) ; Draw a circle
    line 64,31,0,31 ; Draw a line

    DO forever
       for CCount = 31 to 127
            GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
            GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
            GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
            GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
            GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

            GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
            GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

            box (46,9,56,19) ; Draw a Box
            GLCDDrawChar(48, 9, CCount ) ; Draw a character
            outString = str( CCount ) ; Prepare a string
            GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

            filledbox 3,43,11,51, wordNumber ; Draw a filled box

            FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
            line 0,63,64,31 ; Draw a line

            ; Do some simple maths
            longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
        NEXT
    LOOP
    end</pre><p>This example shows how to drive a SH1106 based Graphic I2C LCD module with the built in commands of GCBASIC using Low Memory Mode GLCD.</p><p>Note the use of <code class="literal">GLCD_Open_PageTransaction</code> and <code class="literal">GLCD_Close_PageTransaction</code> to support the Low Memory Mode of operation and the contraining of all GLCD commands with the transaction commands.  The use Low Memory Mode GLCD the two defines <code class="literal">GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE</code> and <code class="literal">GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY</code> are included in the user program.</p><pre class="screen">    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SH1106  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x78
    #define GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS
    GLCD_Open_PageTransaction 0,7
       GLCDPrint 0, 0, "GCBASIC"
       GLCDPrint (0, 16, "Anobium 2021")
    GLCD_Close_PageTransaction
    wait 3 s
    GLCDCLS

    DO forever

      for CCount = 31 to 127

        outString = str( CCount ) ; Prepare a string

        GLCD_Open_PageTransaction 0,7

           ' Prepare the static components of the screen
           GLCDPrint ( 0,   0, "PrintStr") ; Print some text
           GLCDPrint ( 64,  0, "@")
           ; Print some more text
           GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
           GLCDPrint ( 86, 0, "Mhz") ; Print some text
           GLCDDrawString( 0,8,"DrawStr") ; Draw some text
           box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           Circle( 44,41,15) ; Draw a circle
           line 64,31,0,31 ; Draw a line

           GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
           GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
           GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
           GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
           GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

           GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
           GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

           box (46,8,56,19) ; Draw a Box
           GLCDDrawChar(48, 9, CCount ) ; Draw a character

           GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

           filledbox 3,43,11,51, wordNumber ; Draw a filled box

           FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
           line 0,63,64,31 ; Draw a line

        GLCD_Close_PageTransaction

        ; Do some simple maths
        longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
       NEXT
    LOOP
    end</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="sh1106_controllers"></span>SH1106 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the SH1106 graphics
controller. THe SH1106 is a single-chip CMOS OLED/PLED driver with
controller for organic/polymer light emitting diode dot-matrix graphic
display system. SH1106 consists of 132 segments, 64 commons that can
support a maximum display resolution of 132 X 64. It is designed for
Common Cathode type OLED panel.

The GCBASIC constants shown below control the configuration of the
SH1106 controller.    GCBASIC supports i2C hardware and software
connectivity - this is shown in the tables below.

The SH1106 is a monochrome device.

To use the SH1106 driver simply include the following in your user code.
This will initialise the driver. You can select Full Mode GLCD, Low
Memory Mode GLCD or Text mode these require 1024, 128 or 0 byte GLCD
buffer respectively - you microcontroller requires sufficient RAM to
support the selected mode of GLCD operation.

``` screen
    #include <glcd.h>

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SH1106
    #define GLCD_I2C_Address 0x78
    '#define GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE        'select Low Memory mode of operation
    '#define GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY        'select Text mode of operation

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master
```

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Options</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE</code></p></td>
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_SH1106</code></p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_I2C_Address</code></p></td>
<td style="text-align: left;"><p>I2C address of the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">HI2C_BAUD_RATE</code></p></td>
<td style="text-align: left;"><p><code class="literal">HI2C_BAUD_RATE</code></p></td>
<td style="text-align: left;"><p>400 or 100</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">HI2C_DATA</code></p></td>
<td style="text-align: left;"><p><code class="literal">HI2C_DATA</code></p></td>
<td style="text-align: left;"><p>Mandated, plus<br />
<code class="literal">HI2CMode Master</code> is required.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: center;"><p><code class="literal">128</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: center;"><p><code class="literal">64</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Specifies the font width of the GCBASIC font set.</p></td>
<td style="text-align: center;"><p><code class="literal">6</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY</code></p></td>
<td style="text-align: left;"><p>Specifies that the display controller will operate in text mode and BMP draw mode only.<br />
For microcontrollers with low RAM this will be set be default.<br />
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <code class="literal">GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE</code></p></td>
<td style="text-align: center;"><p>Optional</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE</code></p></td>
<td style="text-align: left;"><p>Specifies that the display controller will operate in Low Memory mode.</p></td>
<td style="text-align: center;"><p>Optional</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**Purpose**</span>                                                                              | <span class="strong">**Example**</span>                                                        |
|:----------------------------------------|:---------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------|
| `GLCDCLS`                               | Clear screen of GLCD                                                                                                 | `GLCDCLS`                                                                                      |
| `GLCDPrint`                             | Print string of characters on GLCD using GCB font set                                                                | `GLCDPrint( Xposition, Yposition, Stringvariable )`                                            |
| `GLCDDrawChar`                          | Print character on GLCD using GCB font set                                                                           | `GLCDDrawChar( Xposition, Yposition, CharCode )`                                               |
| `GLCDDrawString`                        | Print characters on GLCD using GCB font set                                                                          | `GLCDDrawString( Xposition, Yposition, Stringvariable )`                                       |
| `Box`                                   | Draw a box on the GLCD to a specific size                                                                            | `Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )`   |
| `FilledBox`                             | Draw a box on the GLCD to a specific size that is filled with the foreground colour.                                 | `FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )` |
| `Line`                                  | Draw a line on the GLCD to a specific length that is filled with the specific attribute.                             | `Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`     |
| `PSet`                                  | Set a pixel on the GLCD at a specific position that is set with the specific attribute.                              | `PSet(Xposition, Yposition, Pixel Colour 0 or 1)`                                              |
| `GLCDWriteByte`                         | Set a byte value to the controller, see the datasheet for usage.                                                     | `GLCDWriteByte (LCDByte)`                                                                      |
| `GLCDReadByte`                          | Read a byte value from the controller, see the datasheet for usage.                                                  | `bytevariable = GLCDReadByte`                                                                  |
| `GLCD_Open_PageTransaction`             | Commence a series of GLCD commands when in low memory mode. Must be followed a `GLCD_Close_PageTransaction` command. | `GLCD_Close_PageTransaction 0, 7` where 0 and 7 are the range of pages to be updated           |
| `GLCD_Close_PageTransaction`            | Commence a series of GLCD commands when in low memory mode. Must follow a `GLCD_Open_PageTransaction` command.       |                                                                                                |

</div>

The additional GCBASIC commands for this GLCD are shown in the table
below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDSetDisplayInvertMode</code></p></td>
<td style="text-align: left;"><p>Inverts the display</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDSetDisplayNormalMode</code></p></td>
<td style="text-align: left;"><p>Set the display to normal mode</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDSetContrast ( dim_state )</code></p></td>
<td style="text-align: left;"><p>Sets the constrast between 0 and 255. The contrast increases as the value increases.<br />
Parameter is dim value</p></td>
</tr>
</tbody>
</table>

</div>

For a SH1106 datasheet, please refer
<a href="http://gcbasic.sourceforge.net/library/DISPLAY/SH1106.pdf" class="link">here</a>.

This example shows how to drive a SH1106 based Graphic LCD module with
the built in commands of GCBASIC.

``` screen
; ----- Configuration
    #chip mega328p,16
    #include <glcd.h>

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SH1106
    #define GLCD_I2C_Address 0x78

    GLCDCLS
    GLCDPrint 0, 0, "GCBASIC"
    GLCDPrint (0, 16, "Anobium 2021")

    wait 3 s
    GLCDCLS

    ' Prepare the static components of the screen
    GLCDPrint ( 0,   0, "PrintStr") ; Print some text
    GLCDPrint ( 64,  0, "@")
    ; Print some more text
    GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
    GLCDPrint ( 86, 0, "Mhz") ; Print some text
    GLCDDrawString( 0,8,"DrawStr") ; Draw some text
    box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    Circle( 44,41,15) ; Draw a circle
    line 64,31,0,31 ; Draw a line

    DO forever
       for CCount = 31 to 127
            GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
            GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
            GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
            GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
            GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

            GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
            GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

            box (46,9,56,19) ; Draw a Box
            GLCDDrawChar(48, 9, CCount ) ; Draw a character
            outString = str( CCount ) ; Prepare a string
            GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

            filledbox 3,43,11,51, wordNumber ; Draw a filled box

            FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
            line 0,63,64,31 ; Draw a line

            ; Do some simple maths
            longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
        NEXT
    LOOP
    end
```

This example shows how to drive a SH1106 based Graphic I2C LCD module
with the built in commands of GCBASIC using Low Memory Mode GLCD.

Note the use of `GLCD_Open_PageTransaction` and
`GLCD_Close_PageTransaction` to support the Low Memory Mode of operation
and the contraining of all GLCD commands with the transaction commands.
The use Low Memory Mode GLCD the two defines
`GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE` and
`GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY` are included in the user program.

``` screen
    #chip mega328p,16
    #include <glcd.h>

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SH1106  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x78
    #define GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS
    GLCD_Open_PageTransaction 0,7
       GLCDPrint 0, 0, "GCBASIC"
       GLCDPrint (0, 16, "Anobium 2021")
    GLCD_Close_PageTransaction
    wait 3 s
    GLCDCLS

    DO forever

      for CCount = 31 to 127

        outString = str( CCount ) ; Prepare a string

        GLCD_Open_PageTransaction 0,7

           ' Prepare the static components of the screen
           GLCDPrint ( 0,   0, "PrintStr") ; Print some text
           GLCDPrint ( 64,  0, "@")
           ; Print some more text
           GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
           GLCDPrint ( 86, 0, "Mhz") ; Print some text
           GLCDDrawString( 0,8,"DrawStr") ; Draw some text
           box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           Circle( 44,41,15) ; Draw a circle
           line 64,31,0,31 ; Draw a line

           GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
           GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
           GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
           GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
           GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

           GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
           GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

           box (46,8,56,19) ; Draw a Box
           GLCDDrawChar(48, 9, CCount ) ; Draw a character

           GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

           filledbox 3,43,11,51, wordNumber ; Draw a filled box

           FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
           line 0,63,64,31 ; Draw a line

        GLCD_Close_PageTransaction

        ; Do some simple maths
        longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
       NEXT
    LOOP
    end
```

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ShortTone</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_sound.html" title="Sound"><link rel="prev" href="_tone.html" title="Tone"><link rel="next" href="_play.html" title="Play"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_shorttone"></a>ShortTone</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ShortTone Frequency, Duration</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will produce the specified tone for the specified duration.
Frequency is measured in units of 10 Hz, and Duration is in 1 ms units.
Please note that this command may not produce the exact frequency
specified. While it is accurate enough for error beeps and small pieces
of monophonic music, it should not be used for anything that requires a
highly precise frequency.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Sample program to produce a tone on PORTB bit 1, based on the
    'reading of an LDR on AN0 (usually PORTA bit 0).

    #chip 16F88, 20
    #define SoundOut PORTB.1

    Dir PORTA.0 In

    Do
        ShortTone ReadAD(AN0), 100
    Loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_sound_overview.html" title="Sound Overview">Sound Overview</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="shorttone"></span>ShortTone

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ShortTone Frequency, Duration
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This command will produce the specified tone for the specified duration.
Frequency is measured in units of 10 Hz, and Duration is in 1 ms units.
Please note that this command may not produce the exact frequency
specified. While it is accurate enough for error beeps and small pieces
of monophonic music, it should not be used for anything that requires a
highly precise frequency.

<span class="strong">**Example:**</span>

``` screen
    'Sample program to produce a tone on PORTB bit 1, based on the
    'reading of an LDR on AN0 (usually PORTA bit 0).

    #chip 16F88, 20
    #define SoundOut PORTB.1

    Dir PORTA.0 In

    Do
        ShortTone ReadAD(AN0), 100
    Loop
```

<span class="strong">**For more help, see**</span>
<a href="sound_overview" class="link" title="Sound Overview">Sound Overview</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SMT Timers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_reading_timers.html" title="Reading Timers"><link rel="next" href="_variables_operations.html" title="Variables Operations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_smt_timers"></a>SMT Timers</h4></div></div></div><p>The Signal Measurement Timer (SMT) capability is a 24-bit counter with advanced clocking and gating logic, which can be configured for measuring a variety of digital signal parameters such as pulse width, frequency and duty cycle, and the time difference between edges on two signals.&nbsp;&nbsp;</p><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    SETSMT1PERIOD ( 4045000 )        ' 1.000s period
                                     ' a perfect internal clock would be 4000000

    SETSMT2PERIOD ( 9322401 )        ' 4.600s period

    InitSMT1(SMT_FOSC,SMTPres_1)
    InitSMT2(SMT_FOSC4,SMTPres_8)

    On Interrupt SMT1Overflow Call yourSMT1InterruptHandler
    On interrupt SMT2Overflow Call yourSMT1InterruptHandler

    StartSMT1
    StartSMT2</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on Microchip microcontrollers with the SMT timer module.</p><p>This command set supports the use of the SMT as a 24-bit timer only.</p><p>Microchip PIC Microcontrollers have either 1 or 2 Signal Measurement Timers (SMT).&nbsp;&nbsp; A 24-bit timer allows for very long timer periods/high resolution and can be quite useful for certain applications.
&nbsp;&nbsp;SMT timers support multiple clock sources and prescales.&nbsp;&nbsp; Interrupt on overflow/match is also supported.</p><p>SMT timers will "overflow" when the 24-bit timer value "matches"  the 24-bit period registers.</p><p>The timer period can be precisely adjusted/set by writing a period value to the respective period register for eact timer.</p><p>The maximum period is achieved by a period register value of 16,777,215.&nbsp;&nbsp;  16,777,215 is the default value at POR. &nbsp;&nbsp;The timer period is also affected by the ChipMhz, TimerSource and Timer Prescale.</p><p>The library supports "normal" timer operation of SMT1/SMT2.&nbsp;&nbsp; The library does not support the advanced signal measurement features.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Commands are detailed in the table below:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Description</th><th align="left" valign="top">Example
&nbsp;</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">InitSMT1( Source,Presscaler )</code></p></td><td align="left" valign="top"><p>Source can be one of the below:<br>
<code class="literal">SMT_AT1_perclk</code> &nbsp;&nbsp;equates to     6<br>
<code class="literal">SMT_MFINTOSC</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equates to        5         (500KHz)<br>
<code class="literal">SMT_MFINTOSC_16</code> equates to     4         (500Khz / 16)<br>
<code class="literal">SMT_LFINTOSC</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equates to        3         (32Khz)<br>
<code class="literal">SMT_HFINTOSC</code>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equates to       2<br>
<code class="literal">SMT_FOSC4</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equates to           1         (FOSC/4)<br>
<code class="literal">SMT_FOSC</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equates to            0<br>
<br>
Prescaler can be one of the following:<br>
<code class="literal">SMTPres_1</code> equates to      1:1<br>
<code class="literal">SMTPres_2</code> equates to      1:2<br>
<code class="literal">SMTPres_4</code> equates to      1:4<br>
<code class="literal">SMTPres_8</code> equates to      1:8<br>
<br></p></td><td align="left" valign="top"><p><code class="literal">InitSMT1(SMT_FOSC,SMTPres_1)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">InitSMT2( Source,Presscaler )</code></p></td><td align="left" valign="top"><p>Source can be one of the below:<br>
<code class="literal">SMT_AT1_perclk</code> &nbsp;&nbsp;equates to     6<br>
<code class="literal">SMT_MFINTOSC</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equates to        5         (500KHz)<br>
<code class="literal">SMT_MFINTOSC_16</code> equates to     4         (500Khz / 16)<br>
<code class="literal">SMT_LFINTOSC</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equates to        3         (32Khz)<br>
<code class="literal">SMT_HFINTOSC</code>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equates to       2<br>
<code class="literal">SMT_FOSC4</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equates to           1         (FOSC/4)<br>
<code class="literal">SMT_FOSC</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equates to            0<br>
<br>
Prescaler can be one of the following:<br>
<code class="literal">SMTPres_1</code> equates to      1:1<br>
<code class="literal">SMTPres_2</code> equates to      1:2<br>
<code class="literal">SMTPres_4</code> equates to      1:4<br>
<code class="literal">SMTPres_8</code> equates to      1:8<br>
</p><p><br></p></td><td align="left" valign="top"><p><code class="literal">InitSMT2(SMT_FOSC4,SMTPres_8)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ClearSMT1</code></p></td><td align="left" valign="top"><p>Clears the timer.  No parameter required.</p></td><td align="left" valign="top"><p><code class="literal">ClearSMT1</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ClearSMT</code></p></td><td align="left" valign="top"><p>Clears the timer.  No parameter required.</p></td><td align="left" valign="top"><p><code class="literal">ClearSMT2</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SetSMT1( TimerValue )</code></p></td><td align="left" valign="top"><p>Sets the timer to the specific value.  The value can be 1 to 16777215</p></td><td align="left" valign="top"><p><code class="literal">SETSMT1(4045000)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SetSMT2( TimerValue )</code></p></td><td align="left" valign="top"><p>Sets the timer to the specific value.  The value can be 1 to 16777215</p></td><td align="left" valign="top"><p><code class="literal">SETSMT2(4045000)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">StopSMT1</code></p></td><td align="left" valign="top"><p>Stops the timer.  No parameter required.</p></td><td align="left" valign="top"><p><code class="literal">StopSMT2</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">StopSMT2</code></p></td><td align="left" valign="top"><p>Stops the timer.  No parameter required.</p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">StartSMT1</code></p></td><td align="left" valign="top"><p>Starts the timer.  No parameter required.</p></td><td align="left" valign="top"><p><code class="literal">StartSMT1</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">StartSMT2</code></p></td><td align="left" valign="top"><p>Starts the timer.  No parameter required.</p></td><td align="left" valign="top"><p><code class="literal">StartSMT2</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SetSMT1Period ( PeriodValue )</code></p></td><td align="left" valign="top"><p>Sets the timer period to the specific value.  The value can be 1 to 16777215</p></td><td align="left" valign="top"><p><code class="literal">SETSMT1PERIOD(4045000)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SetSMT2Period ( PeriodValue )</code></p></td><td align="left" valign="top"><p>Sets the timer period to the specific value.  The value can be 1 to 16777215</p></td><td align="left" valign="top"><p><code class="literal">SETSMT1PERIOD(9322401)</code></p></td></tr></tbody></table></div><p><br>
<br>
<span class="strong"><strong>Example 1 (Microchip Only):</strong></span></p><p>This example will ..</p><pre class="screen">    #Chip 16F18855, 32

    #option explicit
    #Include &lt;SMT_Timers.h&gt;
    #config CLKOUTEN_ON


      '' -------------------LATA-----------------
      '' Bit#:  -7---6---5---4---3---2---1---0---
      '' LED:   ---------------|D5 |D4 |D3 |D1 |-
      ''-----------------------------------------
      ''
      #define LEDD2 PORTA.0
      #define LEDD3 PORTA.1
      #define LEDD4 PORTA.2
      #define LEDD5 PORTA.3
      #define Potentiometer   PORTA.4

      Dir     LEDD2 OUT
      Dir     LEDD3 OUT
      Dir     LEDD4 OUT
      Dir     LEDD5 OUT
      DIR     Potentiometer In


     SETSMT1PERIOD ( 4045000 )        ' 1.000s periodwith the parameters of SMT_FOSC and SMTPres_1 within the clock variance of the interclock
                                      ' a perfect internal clock would be 4000000

     SETSMT1PERIOD ( 9322401 )        ' 4.600s period with the parameters of SMT_FOSC4 and SMTPres_8

     InitSMT1(SMT_FOSC,SMTPres_1)
     InitSMT2(SMT_FOSC4,SMTPres_8)


     On Interrupt SMT1Overflow Call BlinkLEDD2
     On interrupt SMT2Overflow Call BlinkLEDD3

     StartSMT1
     StartSMT2


     Do
       '// Waiting for interrupts

     LOOP


    Sub BlinkLEDD2
      LEDD2 = !LEDD2
    End SUB



    Sub BlinkLEDD3
      LEDD3 = !LEDD3
    End SUB</pre><p><br>
<br></p><p><span class="strong"><strong>Supported in &lt;SMT_Timers.h&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="smt_timers"></span>SMT Timers

</div>

</div>

</div>

The Signal Measurement Timer (SMT) capability is a 24-bit counter with
advanced clocking and gating logic, which can be configured for
measuring a variety of digital signal parameters such as pulse width,
frequency and duty cycle, and the time difference between edges on two
signals.  

<span class="strong">**Syntax:**</span>

``` screen
    SETSMT1PERIOD ( 4045000 )        ' 1.000s period
                                     ' a perfect internal clock would be 4000000

    SETSMT2PERIOD ( 9322401 )        ' 4.600s period

    InitSMT1(SMT_FOSC,SMTPres_1)
    InitSMT2(SMT_FOSC4,SMTPres_8)

    On Interrupt SMT1Overflow Call yourSMT1InterruptHandler
    On interrupt SMT2Overflow Call yourSMT1InterruptHandler

    StartSMT1
    StartSMT2
```

<span class="strong">**Command Availability:**</span>

Available on Microchip microcontrollers with the SMT timer module.

This command set supports the use of the SMT as a 24-bit timer only.

Microchip PIC Microcontrollers have either 1 or 2 Signal Measurement
Timers (SMT).   A 24-bit timer allows for very long timer periods/high
resolution and can be quite useful for certain applications.   SMT
timers support multiple clock sources and prescales.   Interrupt on
overflow/match is also supported.

SMT timers will "overflow" when the 24-bit timer value "matches" the
24-bit period registers.

The timer period can be precisely adjusted/set by writing a period value
to the respective period register for eact timer.

The maximum period is achieved by a period register value of
16,777,215.   16,777,215 is the default value at POR.   The timer period
is also affected by the ChipMhz, TimerSource and Timer Prescale.

The library supports "normal" timer operation of SMT1/SMT2.   The
library does not support the advanced signal measurement features.

<span class="strong">**Explanation:**</span>

Commands are detailed in the table below:

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Example  </th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">InitSMT1( Source,Presscaler )</code></p></td>
<td style="text-align: left;"><p>Source can be one of the below:<br />
<code class="literal">SMT_AT1_perclk</code>   equates to 6<br />
<code class="literal">SMT_MFINTOSC</code>       equates to 5 (500KHz)<br />
<code class="literal">SMT_MFINTOSC_16</code> equates to 4 (500Khz / 16)<br />
<code class="literal">SMT_LFINTOSC</code>       equates to 3 (32Khz)<br />
<code class="literal">SMT_HFINTOSC</code>      equates to 2<br />
<code class="literal">SMT_FOSC4</code>             equates to 1 (FOSC/4)<br />
<code class="literal">SMT_FOSC</code>               equates to 0<br />
<br />
Prescaler can be one of the following:<br />
<code class="literal">SMTPres_1</code> equates to 1:1<br />
<code class="literal">SMTPres_2</code> equates to 1:2<br />
<code class="literal">SMTPres_4</code> equates to 1:4<br />
<code class="literal">SMTPres_8</code> equates to 1:8<br />
<br />
</p></td>
<td style="text-align: left;"><p><code class="literal">InitSMT1(SMT_FOSC,SMTPres_1)</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">InitSMT2( Source,Presscaler )</code></p></td>
<td style="text-align: left;"><p>Source can be one of the below:<br />
<code class="literal">SMT_AT1_perclk</code>   equates to 6<br />
<code class="literal">SMT_MFINTOSC</code>       equates to 5 (500KHz)<br />
<code class="literal">SMT_MFINTOSC_16</code> equates to 4 (500Khz / 16)<br />
<code class="literal">SMT_LFINTOSC</code>       equates to 3 (32Khz)<br />
<code class="literal">SMT_HFINTOSC</code>      equates to 2<br />
<code class="literal">SMT_FOSC4</code>             equates to 1 (FOSC/4)<br />
<code class="literal">SMT_FOSC</code>               equates to 0<br />
<br />
Prescaler can be one of the following:<br />
<code class="literal">SMTPres_1</code> equates to 1:1<br />
<code class="literal">SMTPres_2</code> equates to 1:2<br />
<code class="literal">SMTPres_4</code> equates to 1:4<br />
<code class="literal">SMTPres_8</code> equates to 1:8<br />
</p>
<p><br />
</p></td>
<td style="text-align: left;"><p><code class="literal">InitSMT2(SMT_FOSC4,SMTPres_8)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">ClearSMT1</code></p></td>
<td style="text-align: left;"><p>Clears the timer. No parameter required.</p></td>
<td style="text-align: left;"><p><code class="literal">ClearSMT1</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">ClearSMT</code></p></td>
<td style="text-align: left;"><p>Clears the timer. No parameter required.</p></td>
<td style="text-align: left;"><p><code class="literal">ClearSMT2</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">SetSMT1( TimerValue )</code></p></td>
<td style="text-align: left;"><p>Sets the timer to the specific value. The value can be 1 to 16777215</p></td>
<td style="text-align: left;"><p><code class="literal">SETSMT1(4045000)</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">SetSMT2( TimerValue )</code></p></td>
<td style="text-align: left;"><p>Sets the timer to the specific value. The value can be 1 to 16777215</p></td>
<td style="text-align: left;"><p><code class="literal">SETSMT2(4045000)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">StopSMT1</code></p></td>
<td style="text-align: left;"><p>Stops the timer. No parameter required.</p></td>
<td style="text-align: left;"><p><code class="literal">StopSMT2</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">StopSMT2</code></p></td>
<td style="text-align: left;"><p>Stops the timer. No parameter required.</p></td>
<td style="text-align: left;"> </td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">StartSMT1</code></p></td>
<td style="text-align: left;"><p>Starts the timer. No parameter required.</p></td>
<td style="text-align: left;"><p><code class="literal">StartSMT1</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">StartSMT2</code></p></td>
<td style="text-align: left;"><p>Starts the timer. No parameter required.</p></td>
<td style="text-align: left;"><p><code class="literal">StartSMT2</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">SetSMT1Period ( PeriodValue )</code></p></td>
<td style="text-align: left;"><p>Sets the timer period to the specific value. The value can be 1 to 16777215</p></td>
<td style="text-align: left;"><p><code class="literal">SETSMT1PERIOD(4045000)</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">SetSMT2Period ( PeriodValue )</code></p></td>
<td style="text-align: left;"><p>Sets the timer period to the specific value. The value can be 1 to 16777215</p></td>
<td style="text-align: left;"><p><code class="literal">SETSMT1PERIOD(9322401)</code></p></td>
</tr>
</tbody>
</table>

</div>

  
  
<span class="strong">**Example 1 (Microchip Only):**</span>

This example will ..

``` screen
    #Chip 16F18855, 32

    #option explicit
    #Include <SMT_Timers.h>
    #config CLKOUTEN_ON


      '' -------------------LATA-----------------
      '' Bit#:  -7---6---5---4---3---2---1---0---
      '' LED:   ---------------|D5 |D4 |D3 |D1 |-
      ''-----------------------------------------
      ''
      #define LEDD2 PORTA.0
      #define LEDD3 PORTA.1
      #define LEDD4 PORTA.2
      #define LEDD5 PORTA.3
      #define Potentiometer   PORTA.4

      Dir     LEDD2 OUT
      Dir     LEDD3 OUT
      Dir     LEDD4 OUT
      Dir     LEDD5 OUT
      DIR     Potentiometer In


     SETSMT1PERIOD ( 4045000 )        ' 1.000s periodwith the parameters of SMT_FOSC and SMTPres_1 within the clock variance of the interclock
                                      ' a perfect internal clock would be 4000000

     SETSMT1PERIOD ( 9322401 )        ' 4.600s period with the parameters of SMT_FOSC4 and SMTPres_8

     InitSMT1(SMT_FOSC,SMTPres_1)
     InitSMT2(SMT_FOSC4,SMTPres_8)


     On Interrupt SMT1Overflow Call BlinkLEDD2
     On interrupt SMT2Overflow Call BlinkLEDD3

     StartSMT1
     StartSMT2


     Do
       '// Waiting for interrupts

     LOOP


    Sub BlinkLEDD2
      LEDD2 = !LEDD2
    End SUB



    Sub BlinkLEDD3
      LEDD3 = !LEDD3
    End SUB
```

  
  

<span class="strong">**Supported in &lt;SMT\_Timers.h&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SonyRemote.h</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_infrared_remote.html" title="InfraRed Remote"><link rel="prev" href="_infrared_remote.html" title="InfraRed Remote"><link rel="next" href="_midpoint_circle_algorithm.html" title="Midpoint Circle Algorithm"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_sonyremote_h"></a>SonyRemote.h</h4></div></div></div><p><span class="strong"><strong>Explanation:</strong></span>
Sony IR Remote Control Library for GCBASIC</p><p>This include file will let you easily read and use the infrared signals from a Sony compatible television remote control. In particular, the remote control transmits a pulse modulated signal, the sensor detects this, and the subroutine in this header file decodes the signal, returning two numbers: one representing the device (television, VCR, DVD, tuner, etc.), while the the other returns the key which has been depressed (VOL+, MUTE, channel numbers 0 through 9, etc.).</p><p>This has been tested and confirmed with a fixed remote control purchased surplus for $2.00 from All Electronics, as well as an universal remote control, set to Sony mode.</p><p>Moreover it has also been tested with a Panasonic IR sensor and a Vishay sensor, both purchased surplus for about fifty cents.</p><p>Every combination performed well, and it is probably the case that most any garden variety 38 kHz IR sensor will work. The only tricky bit is making sure you get the pinout for your sensor correct, search out the datasheet for whichever device you use.</p><p>There are only three pins: Ground Vcc Data</p><p>It is essential to filter the power applied to the Vcc pin. Do this by connecting a 100 ohm resistor from the +5V power supply to the Vcc pin, and bridge the pin to ground with a 4.7uF electrolytic capacitor.</p><p>The Data pin requires a 4.7k pullup resistor.</p><p>There is only one constant required of the calling program. It indicates which port line the IR sensor is connected to. For example,</p><pre class="screen">    #DEFINE IR_DATA_PIN PORTA.0</pre><p>There is one subroutine:</p><pre class="screen">    readIR_Remote(IR_rem_dev, IR_rem_key)</pre><p>The values returned are, respectively, the device number mentioned earlier and the key that is currently pressed. Both are byte values.</p><p>Seventeen local bytes are consumed, and two bytes are used for the output parameters. That&#8217;s a grand total of nineteen bytes required when invoking this subroutine.</p><p><span class="strong"><strong>Header File</strong></span></p><pre class="screen">    sub readIR_Remote(out IR_rem_dev as byte, out IR_rem_key as byte)
      dim IR_rem_count, IR_rem_i as byte
      dim IR_rem_width(12) as byte            ;pulse width array

      do
        IR_rem_count = 0                      ;wait for start bit
        do while IR_DATA_PIN = 0              ;measure width (active low)
          wait 100 uS                         ;24 X 100 uS = 2.4 mS
          IR_rem_count++
        loop
      loop while IR_rem_count &lt; 20            ;less than this so wait

      for IR_rem_i = 1 to 12                  ;read/store the 12 pulses
        do
          IR_rem_count = 0
          do while IR_DATA_PIN = 0            ;zero = 6 units = 0.6 mS
            wait 100 uS                       ;one = 12 units = 1.2 mS
            IR_rem_count++
          loop
        loop while IR_rem_count &lt; 4           ;too small to be legit

        IR_rem_width(IR_rem_i) = IR_rem_count ;else store pulse width
      next IR_rem_i

      IR_rem_key = 0                          ;command built up here
      for IR_rem_i = 1 to 7                   ;1st 7 bits are the key
        IR_rem_key = IR_rem_key / 2           ;shift into place
        if IR_rem_width(IR_rem_i) &gt; 10 then   ;longer than 10 mS
           IR_rem_key = IR_rem_key + 64       ;so call it a one
        end if
      next

      IR_rem_dev = 0                          ;device number built up here
      for IR_rem_i = 8 to 12                  ;next 5 bits are device number
        IR_rem_dev = IR_rem_dev / 2
        if IR_rem_width( IR_rem_i ) &gt; 10 then
           IR_rem_dev = IR_rem_dev + 16
        end if
      next
    end sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="sonyremote_h"></span>SonyRemote.h

</div>

</div>

</div>

<span class="strong">**Explanation:**</span> Sony IR Remote Control
Library for GCBASIC

This include file will let you easily read and use the infrared signals
from a Sony compatible television remote control. In particular, the
remote control transmits a pulse modulated signal, the sensor detects
this, and the subroutine in this header file decodes the signal,
returning two numbers: one representing the device (television, VCR,
DVD, tuner, etc.), while the the other returns the key which has been
depressed (VOL+, MUTE, channel numbers 0 through 9, etc.).

This has been tested and confirmed with a fixed remote control purchased
surplus for $2.00 from All Electronics, as well as an universal remote
control, set to Sony mode.

Moreover it has also been tested with a Panasonic IR sensor and a Vishay
sensor, both purchased surplus for about fifty cents.

Every combination performed well, and it is probably the case that most
any garden variety 38 kHz IR sensor will work. The only tricky bit is
making sure you get the pinout for your sensor correct, search out the
datasheet for whichever device you use.

There are only three pins: Ground Vcc Data

It is essential to filter the power applied to the Vcc pin. Do this by
connecting a 100 ohm resistor from the +5V power supply to the Vcc pin,
and bridge the pin to ground with a 4.7uF electrolytic capacitor.

The Data pin requires a 4.7k pullup resistor.

There is only one constant required of the calling program. It indicates
which port line the IR sensor is connected to. For example,

``` screen
    #DEFINE IR_DATA_PIN PORTA.0
```

There is one subroutine:

``` screen
    readIR_Remote(IR_rem_dev, IR_rem_key)
```

The values returned are, respectively, the device number mentioned
earlier and the key that is currently pressed. Both are byte values.

Seventeen local bytes are consumed, and two bytes are used for the
output parameters. That’s a grand total of nineteen bytes required when
invoking this subroutine.

<span class="strong">**Header File**</span>

``` screen
    sub readIR_Remote(out IR_rem_dev as byte, out IR_rem_key as byte)
      dim IR_rem_count, IR_rem_i as byte
      dim IR_rem_width(12) as byte            ;pulse width array

      do
        IR_rem_count = 0                      ;wait for start bit
        do while IR_DATA_PIN = 0              ;measure width (active low)
          wait 100 uS                         ;24 X 100 uS = 2.4 mS
          IR_rem_count++
        loop
      loop while IR_rem_count < 20            ;less than this so wait

      for IR_rem_i = 1 to 12                  ;read/store the 12 pulses
        do
          IR_rem_count = 0
          do while IR_DATA_PIN = 0            ;zero = 6 units = 0.6 mS
            wait 100 uS                       ;one = 12 units = 1.2 mS
            IR_rem_count++
          loop
        loop while IR_rem_count < 4           ;too small to be legit

        IR_rem_width(IR_rem_i) = IR_rem_count ;else store pulse width
      next IR_rem_i

      IR_rem_key = 0                          ;command built up here
      for IR_rem_i = 1 to 7                   ;1st 7 bits are the key
        IR_rem_key = IR_rem_key / 2           ;shift into place
        if IR_rem_width(IR_rem_i) > 10 then   ;longer than 10 mS
           IR_rem_key = IR_rem_key + 64       ;so call it a one
        end if
      next

      IR_rem_dev = 0                          ;device number built up here
      for IR_rem_i = 8 to 12                  ;next 5 bits are device number
        IR_rem_dev = IR_rem_dev / 2
        if IR_rem_width( IR_rem_i ) > 10 then
           IR_rem_dev = IR_rem_dev + 16
        end if
      next
    end sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Sound</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_hi2cwaitmssp.html" title="HI2CWaitMSSP"><link rel="next" href="_sound_overview.html" title="Sound Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_sound"></a>Sound</h3></div></div></div><p>This is the Sound section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="sound"></span>Sound

</div>

</div>

</div>

This is the Sound section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Sound Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_sound.html" title="Sound"><link rel="prev" href="_sound.html" title="Sound"><link rel="next" href="_tone.html" title="Tone"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_sound_overview"></a>Sound Overview</h4></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>These GCBASIC methods generate tones of a given frequency and duration.</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Method</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>Tone</p></td><td align="left" valign="top"><p>Generate a specified tone for a specified duration in terms of a frequency of a specified Mhz and units of 10ms</p></td></tr><tr><td align="left" valign="top"><p>ShortTone</p></td><td align="left" valign="top"><p>Generate a specified tone for a specified duration in terms of a frequency of a 10Mhz and units of 1ms</p></td></tr><tr><td align="left" valign="top"><p>Play</p></td><td align="left" valign="top"><p>Play a tune string.  The format of the string is the QBASIC play command.</p></td></tr><tr><td align="left" valign="top"><p>PlayRTTTL</p></td><td align="left" valign="top"><p>Play a tune string.  The format of the string is the Nokia cell phone RTTTL format.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>These constants are used to control settings for the tone generation routines. To set them, place a line in the main program file that uses <code class="literal">#define</code> to assign a value to the particular constant.</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">SoundOut</code></p></td><td align="left" valign="top"><p>The output pin to produce sound on</p></td><td align="left" valign="top"><p>N/A - <span class="strong"><strong><span class="emphasis"><em>Must be defined</em></span></strong></span></p></td></tr></tbody></table></div><p><span class="strong"><strong><span class="emphasis"><em>Note:</em></span></strong></span> If an exact frequency is required, or a smaller program is needed, these routines should not be used. Instead, you should use code like this:</p><pre class="screen">    Repeat <span class="emphasis"><em>count</em></span>
    PulseOut SoundOut, <span class="emphasis"><em>period</em></span> us
    Wait <span class="emphasis"><em>period</em></span> us
    End Repeat</pre><p>Set <code class="literal"><span class="emphasis"><em>count</em></span></code> and <code class="literal"><span class="emphasis"><em>period</em></span></code> to the appropriate values as follows:</p><p><code class="literal"><span class="emphasis"><em>period</em></span></code> to 1000000 / desired frequency / 2<br>
<code class="literal"><span class="emphasis"><em>count</em></span></code> to desired duration / <span class="emphasis"><em>period</em></span>.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="sound_overview"></span>Sound Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

These GCBASIC methods generate tones of a given frequency and duration.

<div class="informaltable">

| <span class="strong">**Method**</span> | <span class="strong">**Controls**</span>                                                                        |
|:---------------------------------------|:----------------------------------------------------------------------------------------------------------------|
| Tone                                   | Generate a specified tone for a specified duration in terms of a frequency of a specified Mhz and units of 10ms |
| ShortTone                              | Generate a specified tone for a specified duration in terms of a frequency of a 10Mhz and units of 1ms          |
| Play                                   | Play a tune string. The format of the string is the QBASIC play command.                                        |
| PlayRTTTL                              | Play a tune string. The format of the string is the Nokia cell phone RTTTL format.                              |

</div>

<span class="strong">**Relevant Constants:**</span>

These constants are used to control settings for the tone generation
routines. To set them, place a line in the main program file that uses
`#define` to assign a value to the particular constant.

<div class="informaltable">

| <span class="strong">**Constant Name**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Default Value**</span>                                         |
|:----------------------------------------------|:-----------------------------------------|:--------------------------------------------------------------------------------------|
| `SoundOut`                                    | The output pin to produce sound on       | N/A - <span class="strong">**<span class="emphasis">*Must be defined*</span>**</span> |

</div>

<span class="strong">**<span class="emphasis">*Note:*</span>**</span> If
an exact frequency is required, or a smaller program is needed, these
routines should not be used. Instead, you should use code like this:

``` screen
    Repeat count
    PulseOut SoundOut, period us
    Wait period us
    End Repeat
```

Set `count` and `period` to the appropriate values as follows:

`period` to 1000000 / desired frequency / 2  
`count` to desired duration / <span class="emphasis">*period*</span>.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SPI</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_ps2writebyte.html" title="PS2WriteByte"><link rel="next" href="_spi_overview.html" title="SPI Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spi"></a>SPI</h3></div></div></div><p>This is the Serial Peripheral Interface section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="spi"></span>SPI

</div>

</div>

</div>

This is the Serial Peripheral Interface section of the Help file. Please
refer the sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SPIMode</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_spi.html" title="SPI"><link rel="prev" href="_spi_overview.html" title="SPI Overview"><link rel="next" href="_spitransfer.html" title="SPITransfer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_spimode"></a>SPIMode</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    SPIMode ( <span class="emphasis"><em>Mode</em></span> [, SPIClockMode])</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on Microchip PIC microcontrollers with Hardware SPI modules.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><span class="emphasis"><em>Mode</em></span> sets the mode of the SPI module within the microcontroller. These are
the possible SPI Modes:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Mode Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">MasterSlow</code></p></td><td align="left" valign="top"><p>Master mode, SPI clock is 1/64 of the frequency of the microcontroller.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Master</code></p></td><td align="left" valign="top"><p>Master mode, SPI clock is 1/16 of the frequency of the microcontroller.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">MasterFast</code></p></td><td align="left" valign="top"><p>Master mode, SPI clock is 1/4 of the frequency of the microcontroller.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Slave</code></p></td><td align="left" valign="top"><p>Slave mode</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SlaveSS</code></p></td><td align="left" valign="top"><p>Slave mode, with the Slave Select pin enabled.</p></td></tr></tbody></table></div><p><span class="emphasis"><em>SPIClockMode</em></span> is an optional parameter to set the mode of the SPI clock mode. This optional parameter sets both the clock polarity and clock edge.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>SPIClockMode</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>0</p></td><td align="left" valign="top"><p>SPI_CPOL = 0 &amp; SPI_CPHA = 0</p></td></tr><tr><td align="left" valign="top"><p>1</p></td><td align="left" valign="top"><p>SPI_CPOL = 0 &amp; SPI_CPHA = 1</p></td></tr><tr><td align="left" valign="top"><p>2</p></td><td align="left" valign="top"><p>SPI_CPOL = 1 &amp; SPI_CPHA = 0</p></td></tr><tr><td align="left" valign="top"><p>3</p></td><td align="left" valign="top"><p>SPI_CPOL = 1 &amp; SPI_CPHA = 1</p></td></tr></tbody></table></div><p>You can alternatively use constants to set the SPIClockMode as follows:</p><pre class="screen">    SPIMode ( MasterFast, SPI_CPOL_n + SPI_CPHA_n )</pre><p>Where the following parameters can be used as a calculation to set the SPIClockMode.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Mode Name</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>SPI_CPOL_0</p></td><td align="left" valign="top"><p>CPOL = 0</p></td></tr><tr><td align="left" valign="top"><p>SPI_CPOL_1</p></td><td align="left" valign="top"><p>CPOL = 1</p></td></tr><tr><td align="left" valign="top"><p>SPI_CPHA_0</p></td><td align="left" valign="top"><p>CPHA = 0</p></td></tr><tr><td align="left" valign="top"><p>SPI_CPHA_1</p></td><td align="left" valign="top"><p>CPHA = 1</p></td></tr></tbody></table></div><p><span class="strong"><strong>Summary:</strong></span></p><p>When using SPI setting the clock frequency is completed using SPIMode, and the master must also configure the clock polarity and phase with respect to the data. Using the two options as CPOL and CPHA.</p><p>The timing diagram is shown below. The timing is further described and applies to both the master and the slave device.</p><p>When CPOL=0 the base value of the clock is zero, i.e. the active state is 1 and idle state is 0.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">For CPHA=0, data are captured on the clock&#8217;s rising edge (low&#8594;high transition) and data is output on a falling edge (high&#8594;low clock transition).</li><li class="listitem">For CPHA=1, data are captured on the clock&#8217;s falling edge and data is output on a rising edge.</li></ul></div><p>When CPOL=1 the base value of the clock is one (inversion of CPOL=0), i.e. the active state is 0 and idle state is 1.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">For CPHA=0, data are captured on clock&#8217;s falling edge and data is output on a rising edge.</li><li class="listitem">For CPHA=1, data are captured on clock&#8217;s rising edge and data is output on a falling edge.</li></ul></div><p>When CPHA=0 means sampling on the first clock edge and , while CPHA=1 means sampling on the second clock edge, regardless of whether that clock edge is rising or falling.  Note that with CPHA=0, the data must be stable for a half cycle before the first clock cycle.</p><p>In other words, CPHA=0 means transmitting data on the active to idle state and CPHA=1 means that data is transmitted on the idle to active state edge. Note that if transmission happens on a particular edge, then capturing will happen on the opposite edge(i.e. if transmission happens on falling, then reception happens on rising and vice versa). The MOSI and MISO signals are usually stable (at their reception points) for the half cycle until the next clock transition. SPI master and slave devices may well sample data at different points in that half cycle.</p><p>This adds more flexibility to the communication channel between the master and slave.</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/spimode1.PNG" align="middle" alt="[graphic"></div></div><p><span class="strong"><strong>Example</strong></span></p><p>This example demonstrates the SPI capabilities for the mega328p.  The process is similar of any microcontroller..</p><p>You must set the data line as inputs and outputs.</p><pre class="screen">        #chip mega328p, 16
        #option explicit
        #include &lt;UNO_mega328p.h &gt;

        #define SPI_HardwareSPI  'comment this out to make into Software SPI but, you may have to change clock lines

        'Pin mappings for SPI - this SPI driver supports Hardware SPI
        #define SPI_DC       DIGITAL_8          ' Data command line
        #define SPI_CS       DIGITAL_4          ' Chip select line
        #define SPI_RESET    DIGITAL_9          ' Reset line

        #define SPI_DI       DIGITAL_12          ' Data in | MISO
        #define SPI_DO       DIGITAL_11          ' Data out | MOSI
        #define SPI_SCK      DIGITAL_13          ' Clock Line

        dir SPI_DC    out
        dir SPI_CS    out
        dir SPI_RESET out
        dir SPI_DO    Out
        dir SPI_DI    In
        dir SPI_SCK   Out

        'If DIGITAL_10 is NOT used as the SPI_CS (sometimes called SS) the port must and output or set as input/pulled high with a 10k resistor.
        'As follows:
        'If CS is configured as an input, it must be held high to ensure Master SPI operation.
        'If the CS pin is driven low by peripheral circuitry when the SPI is configured as a Master with the SS pin defined as an input, the
        'SPI system interprets this as another master selecting the SPI as a slave and starting to send data to it!
        'If CS is an output SPI communications will commence with no flow control.
        dir DIGITAL_10 Out


        dim outbyte, inbyte as byte

        SPIMode ( MasterFast, SPI_CPOL_0 + SPI_CPHA_0 )


       do
        set SPI_CS OFF;  Select line
        set SPI_DC OFF;  Send Data if off, or, Data if On
        SPITransfer ( outbyte, inbyte )
        set SPI_CS ON;   Deselect Line
        set SPI_DC ON
        wait 10 ms
       loop</pre><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_spitransfer.html" title="SPITransfer">SPITransfer</a>,<a class="link" href="_fasthwspitransfer.html" title="FastHWSPITransfer">FastHWSPITransfer</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="spimode"></span>SPIMode

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    SPIMode ( Mode [, SPIClockMode])
```

<span class="strong">**Command Availability:**</span>

Available on Microchip PIC microcontrollers with Hardware SPI modules.

<span class="strong">**Explanation:**</span>

<span class="emphasis">*Mode*</span> sets the mode of the SPI module
within the microcontroller. These are the possible SPI Modes:

<div class="informaltable">

| <span class="strong">**Mode Name**</span> | <span class="strong">**Description**</span>                             |
|:------------------------------------------|:------------------------------------------------------------------------|
| `MasterSlow`                              | Master mode, SPI clock is 1/64 of the frequency of the microcontroller. |
| `Master`                                  | Master mode, SPI clock is 1/16 of the frequency of the microcontroller. |
| `MasterFast`                              | Master mode, SPI clock is 1/4 of the frequency of the microcontroller.  |
| `Slave`                                   | Slave mode                                                              |
| `SlaveSS`                                 | Slave mode, with the Slave Select pin enabled.                          |

</div>

<span class="emphasis">*SPIClockMode*</span> is an optional parameter to
set the mode of the SPI clock mode. This optional parameter sets both
the clock polarity and clock edge.

<div class="informaltable">

| <span class="strong">**SPIClockMode**</span> | <span class="strong">**Description**</span> |
|:---------------------------------------------|:--------------------------------------------|
| 0                                            | SPI\_CPOL = 0 & SPI\_CPHA = 0               |
| 1                                            | SPI\_CPOL = 0 & SPI\_CPHA = 1               |
| 2                                            | SPI\_CPOL = 1 & SPI\_CPHA = 0               |
| 3                                            | SPI\_CPOL = 1 & SPI\_CPHA = 1               |

</div>

You can alternatively use constants to set the SPIClockMode as follows:

``` screen
    SPIMode ( MasterFast, SPI_CPOL_n + SPI_CPHA_n )
```

Where the following parameters can be used as a calculation to set the
SPIClockMode.

<div class="informaltable">

| <span class="strong">**Mode Name**</span> | <span class="strong">**Description**</span> |
|:------------------------------------------|:--------------------------------------------|
| SPI\_CPOL\_0                              | CPOL = 0                                    |
| SPI\_CPOL\_1                              | CPOL = 1                                    |
| SPI\_CPHA\_0                              | CPHA = 0                                    |
| SPI\_CPHA\_1                              | CPHA = 1                                    |

</div>

<span class="strong">**Summary:**</span>

When using SPI setting the clock frequency is completed using SPIMode,
and the master must also configure the clock polarity and phase with
respect to the data. Using the two options as CPOL and CPHA.

The timing diagram is shown below. The timing is further described and
applies to both the master and the slave device.

When CPOL=0 the base value of the clock is zero, i.e. the active state
is 1 and idle state is 0.

<div class="itemizedlist">

-   For CPHA=0, data are captured on the clock’s rising edge (low→high
    transition) and data is output on a falling edge (high→low clock
    transition).
-   For CPHA=1, data are captured on the clock’s falling edge and data
    is output on a rising edge.

</div>

When CPOL=1 the base value of the clock is one (inversion of CPOL=0),
i.e. the active state is 0 and idle state is 1.

<div class="itemizedlist">

-   For CPHA=0, data are captured on clock’s falling edge and data is
    output on a rising edge.
-   For CPHA=1, data are captured on clock’s rising edge and data is
    output on a falling edge.

</div>

When CPHA=0 means sampling on the first clock edge and , while CPHA=1
means sampling on the second clock edge, regardless of whether that
clock edge is rising or falling. Note that with CPHA=0, the data must be
stable for a half cycle before the first clock cycle.

In other words, CPHA=0 means transmitting data on the active to idle
state and CPHA=1 means that data is transmitted on the idle to active
state edge. Note that if transmission happens on a particular edge, then
capturing will happen on the opposite edge(i.e. if transmission happens
on falling, then reception happens on rising and vice versa). The MOSI
and MISO signals are usually stable (at their reception points) for the
half cycle until the next clock transition. SPI master and slave devices
may well sample data at different points in that half cycle.

This adds more flexibility to the communication channel between the
master and slave.

<div class="informalfigure">

<div class="mediaobject" align="center">

![\[graphic](./images/spimode1.PNG)

</div>

</div>

<span class="strong">**Example**</span>

This example demonstrates the SPI capabilities for the mega328p. The
process is similar of any microcontroller..

You must set the data line as inputs and outputs.

``` screen
        #chip mega328p, 16
        #option explicit
        #include <UNO_mega328p.h >

        #define SPI_HardwareSPI  'comment this out to make into Software SPI but, you may have to change clock lines

        'Pin mappings for SPI - this SPI driver supports Hardware SPI
        #define SPI_DC       DIGITAL_8          ' Data command line
        #define SPI_CS       DIGITAL_4          ' Chip select line
        #define SPI_RESET    DIGITAL_9          ' Reset line

        #define SPI_DI       DIGITAL_12          ' Data in | MISO
        #define SPI_DO       DIGITAL_11          ' Data out | MOSI
        #define SPI_SCK      DIGITAL_13          ' Clock Line

        dir SPI_DC    out
        dir SPI_CS    out
        dir SPI_RESET out
        dir SPI_DO    Out
        dir SPI_DI    In
        dir SPI_SCK   Out

        'If DIGITAL_10 is NOT used as the SPI_CS (sometimes called SS) the port must and output or set as input/pulled high with a 10k resistor.
        'As follows:
        'If CS is configured as an input, it must be held high to ensure Master SPI operation.
        'If the CS pin is driven low by peripheral circuitry when the SPI is configured as a Master with the SS pin defined as an input, the
        'SPI system interprets this as another master selecting the SPI as a slave and starting to send data to it!
        'If CS is an output SPI communications will commence with no flow control.
        dir DIGITAL_10 Out


        dim outbyte, inbyte as byte

        SPIMode ( MasterFast, SPI_CPOL_0 + SPI_CPHA_0 )


       do
        set SPI_CS OFF;  Select line
        set SPI_DC OFF;  Send Data if off, or, Data if On
        SPITransfer ( outbyte, inbyte )
        set SPI_CS ON;   Deselect Line
        set SPI_DC ON
        wait 10 ms
       loop
```

<span class="strong">**See also**</span>
<a href="spitransfer" class="link" title="SPITransfer">SPITransfer</a>,<a href="fasthwspitransfer" class="link" title="FastHWSPITransfer">FastHWSPITransfer</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SPITransfer</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_spi.html" title="SPI"><link rel="prev" href="_spimode.html" title="SPIMode"><link rel="next" href="_fasthwspitransfer.html" title="FastHWSPITransfer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_spitransfer"></a>SPITransfer</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  <code class="literal">SPITransfer</code> <span class="emphasis"><em>tx</em></span>, <span class="emphasis"><em>rx</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on Microchip PIC microcontrollers with Hardware SPI modules.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command simultaneously sends and receives a byte of data using the
SPI protocol. It behaves differently depending on whether the microcontroller has
been set to act as a master or a slave.
When operating as a master, <code class="literal">SPITransfer</code> will initiate a transfer. The
data in <code class="literal"><span class="emphasis"><em>tx</em></span></code> will be sent to the slave, whilst the byte that is buffered
in the slave will be read into <code class="literal"><span class="emphasis"><em>rx</em></span></code>.
In slave mode, the <code class="literal">SPITransfer</code> command will pause the program until a
transfer is initiated by the master. At this point, it will send the
data in <code class="literal"><span class="emphasis"><em>tx</em></span></code> whilst reading the transmission from the master into the
<code class="literal"><span class="emphasis"><em>rx</em></span></code> variable.</p><p><span class="strong"><strong>Example:</strong></span></p><p>There are two example programs for this command - one to run on the
slave microcontroller , and one on the master. A reading is taken from a sensor on
the slave, and sent across to the master which shows the data on its LCD
screen.</p><p><span class="strong"><strong>Slave Program:</strong></span></p><pre class="screen">  'Select chip model and configuration
  #chip 16F88, 20
  #config MCLR_OFF

  'Set directions of SPI pins
  dir PORTB.2 out
  dir PORTB.1 in
  dir PORTB.4 in
  'Set direction of analogue pin
  dir PORTA.0 in

  'Set SPI mode to slave
  SPIMode Slave

  'Allow other microcontroller to initialise LCD
  Wait 1 sec

  'Main loop - takes a reading, and then waits to send it across.
  do
  'Note that rx is 0 - this is because no data is to be received.
  SPITransfer ReadAD(AN0), 0
  loop</pre><p><span class="strong"><strong>Master Program:</strong></span></p><pre class="screen">  'General hardware configuration
  #chip 16F877A, 20

  'LCD connection settings
  #define LCD_IO 8
  #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
  #define LCD_DATA_PORT PORTC
  #define LCD_RS PORTD.0
  #define LCD_RW PORTD.1
  #define LCD_Enable PORTD.2

  'Set SPI pin directions
  dir PORTC.5 out
  dir PORTC.4 in
  dir PORTC.3 out

  'Set SPI Mode to master, with fast clock
  SPIMode MasterFast

  'Main Loop
  do
  'Read a byte from the slave
  'No data to send, so tx is 0
  SPITransfer 0, Temp

  'Display data
  if Temp &gt; 0 then
    CLS
    Print "Light: "
    LCDInt Temp
    Temp = 0
  end if

  'Wait to allow time for the LCD to show the given value
  wait 100 ms
  loop</pre><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_spimode.html" title="SPIMode">SPIMode</a>,<a class="link" href="_fasthwspitransfer.html" title="FastHWSPITransfer">FastHWSPITransfer</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="spitransfer"></span>SPITransfer

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  SPITransfer tx, rx
```

<span class="strong">**Command Availability:**</span>

Available on Microchip PIC microcontrollers with Hardware SPI modules.

<span class="strong">**Explanation:**</span>

This command simultaneously sends and receives a byte of data using the
SPI protocol. It behaves differently depending on whether the
microcontroller has been set to act as a master or a slave. When
operating as a master, `SPITransfer` will initiate a transfer. The data
in `tx` will be sent to the slave, whilst the byte that is buffered in
the slave will be read into `rx`. In slave mode, the `SPITransfer`
command will pause the program until a transfer is initiated by the
master. At this point, it will send the data in `tx` whilst reading the
transmission from the master into the `rx` variable.

<span class="strong">**Example:**</span>

There are two example programs for this command - one to run on the
slave microcontroller , and one on the master. A reading is taken from a
sensor on the slave, and sent across to the master which shows the data
on its LCD screen.

<span class="strong">**Slave Program:**</span>

``` screen
  'Select chip model and configuration
  #chip 16F88, 20
  #config MCLR_OFF

  'Set directions of SPI pins
  dir PORTB.2 out
  dir PORTB.1 in
  dir PORTB.4 in
  'Set direction of analogue pin
  dir PORTA.0 in

  'Set SPI mode to slave
  SPIMode Slave

  'Allow other microcontroller to initialise LCD
  Wait 1 sec

  'Main loop - takes a reading, and then waits to send it across.
  do
  'Note that rx is 0 - this is because no data is to be received.
  SPITransfer ReadAD(AN0), 0
  loop
```

<span class="strong">**Master Program:**</span>

``` screen
  'General hardware configuration
  #chip 16F877A, 20

  'LCD connection settings
  #define LCD_IO 8
  #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
  #define LCD_DATA_PORT PORTC
  #define LCD_RS PORTD.0
  #define LCD_RW PORTD.1
  #define LCD_Enable PORTD.2

  'Set SPI pin directions
  dir PORTC.5 out
  dir PORTC.4 in
  dir PORTC.3 out

  'Set SPI Mode to master, with fast clock
  SPIMode MasterFast

  'Main Loop
  do
  'Read a byte from the slave
  'No data to send, so tx is 0
  SPITransfer 0, Temp

  'Display data
  if Temp > 0 then
    CLS
    Print "Light: "
    LCDInt Temp
    Temp = 0
  end if

  'Wait to allow time for the LCD to show the given value
  wait 100 ms
  loop
```

<span class="strong">**See also**</span>
<a href="spimode" class="link" title="SPIMode">SPIMode</a>,<a href="fasthwspitransfer" class="link" title="FastHWSPITransfer">FastHWSPITransfer</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SPI Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_spi.html" title="SPI"><link rel="prev" href="_spi.html" title="SPI"><link rel="next" href="_spimode.html" title="SPIMode"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_spi_overview"></a>SPI Overview</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><p>The SPI interface allows for the transmission and receiption of data simultaneously on two lines (MOSI and MISO).</p><p>The Clock polarity (CPOL) and clock phase (CPHA) are the main parameters that define a clock format to be used by the SPI bus. Depending on CPOL parameter, SPI clock may be inverted or non-inverted. CPHA parameter is used to shift the sampling phase. If CPHA=0 the data are sampled on the leading (first) clock edge. If CPHA=1 the data are sampled on the trailing (second) clock edge, regardless of whether that clock edge is rising or falling.</p><p>CPOL=0, CPHA=0</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/spi-cpol-0-cpha-0.png" align="middle" alt="[graphic"></div></div><p>The data must be available before the first clock signal rising.  The clock idle state is zero.  The data on MISO and MOSI lines must be stable while the clock is high and can be changed when the clock is low. The data is captured on the clock&#8217;s low-to-high transition and propagated on high-to-low clock transition.</p><p>CPOL=0, CPHA=1</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/spi-cpol-0-cpha-1.png" align="middle" alt="[graphic"></div></div><p>The first clock signal rising can be used to prepare the data. The clock idle state is zero. The data on MISO and MOSI lines must be stable while the clock is low and can be changed when the clock is high. The data is captured on the clock&#8217;s high-to-low transition and propagated on low-to-high clock transition.</p><p>CPOL=1, CPHA=0</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/spi-cpol-1-cpha-0.png" align="middle" alt="[graphic"></div></div><p>The data must be available before the first clock signal falling. The clock idle state is one. The data on MISO and MOSI lines must be stable while the clock is low and can be changed when the clock is high. The data is captured on the clock&#8217;s high-to-low transition and propagated on low-to-high clock transition.</p><p>CPOL=1, CPHA=1</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/spi-cpol-1-cpha-1.png" align="middle" alt="[graphic"></div></div><p>The first clock signal falling can be used to prepare the data. The clock idle state is one. The data on MISO and MOSI lines must be stable while the clock is high and can be changed when the clock is low. The data is captured on the clock&#8217;s low-to-high transition and propagated on high-to-low clock transition.</p><p><span class="strong"><strong>Key Commands</strong></span></p><pre class="screen">    SPIMode  ( _Mode_ [, SPIClockMode])

    SPITransfer (  _OutByte_, _InByte_ )

    FastHWSPITransfer( _OutByte_ )

    #define HWSPIMode MASTERULTRAFAST       'MASTERSLOW | MASTER | MASTERFAST | MASTERULTRAFAST for specific AVRs only | MasterSSPADDMode for specific PICs SSPADD support
                                            'Defaults to MASTERFAST when microcontroller frequency less or equal to 32 mhz
                                            'Defaults to MASTER when microcontroller frequency more than 32 mhz.</pre><p>The GCBASIC used the microcontrollers hardware module for SPI.  The example below shows an implementation of Hardware and Software SPI.  Software SPI allows for a greater choice of ports to be used to control the SPI operations.</p><p><span class="strong"><strong>Example</strong></span></p><p>This example demonstrates the SPI capabilities for the mega328p.  The process is similar of any microcontroller..</p><p>This example show using the hardware SPI option and a sofware SPI option.</p><p>Using hardware SPI mode - make sure the <code class="literal">#define SPI_HardwareSPI</code> is not commented out.
Using software SPI mode - comment out <code class="literal">#define SPI_HardwareSPI</code>. The example code will then use software SPI.</p><p><span class="strong"><strong>Setting the SPI Mode</strong></span></p><p>Hardware SPI mode the Data Out, Data In and Clock (DO/DI and SCK) cannot be moved but the optional Data Command, Chip Select and Reset are all moveable.</p><p>Software SPI mode the Data Out, Data In and Clock (DO/DI and SCK), Data Command, Chip Select and Reset are all moveable.</p><p>Use the constant <code class="literal">HWSPIMode</code> to set the SPI frequency when using GCBASIC libraries.</p><pre class="screen">    #define HWSPIMode MASTERULTRAFAST</pre><p>GCBASIC libraries will default to to MASTERFAST when microcontroller frequency less or equal to 32 mhz and default to MASTER when microcontroller frequency more than 32 mhz.</p><p>The options for <code class="literal">HWSPIMode</code> are:</p><p><code class="literal">MASTERSLOW</code>, or, <code class="literal">MASTER</code> or <code class="literal">MASTERFAST</code> or <code class="literal">MASTERULTRAFAST</code> for specific AVRs only or <code class="literal">MasterSSPADDMode</code> for specific PICs SSPADD support</p><p>This constant sets the library to the desire SPI fequency, therefore enable adaption of the SPI frequency without have to change the library.</p><p>The SPI frequnecy must be the same for all the used devices.&nbsp;&nbsp; In particular, it must be set equal to the one dictated by the slowest SPI device to be used.</p><p>More freedom is available when more than an hardware SPI is available as well as when the user want to use hardware SPI for a device and software SPI for a second one.</p><p><span class="strong"><strong>Using multiple SPI devices</strong></span></p><p>There will be use cases were you need to use more than one SPI target device at a time.&nbsp;&nbsp;In such cases the device defined for SPI must be inserted in your program for each device.</p><p>As an example using e-Paper and SRAM at the same time, with an hardware SPI would require <code class="literal">#define SPISRAM_HARDWARESPI</code> and <code class="literal">#define EPD_HardwareSPI</code>.&nbsp;&nbsp;</p><p>Obviously, when all SPI devices use the same SPI lines, you must  select one device at a time by setting SPI Chip Select line to <code class="literal">OFF</code> for the specific target SPI device, and you must set <code class="literal">ON</code> the SPI Chip Select line for any other SPI device&nbsp;&nbsp;-&nbsp;&nbsp;this is a normal convention of SPI usage. &nbsp;&nbsp; This is not specific to GCBASIC..</p><p><span class="strong"><strong>Code overview</strong></span></p><pre class="literallayout">InitSPIMode calls SPIMode. if needed, when hardware mode, and set the port firections.
The sub SendByteviaSPI is called to handle whether to call the Hardware or use Software (bit-banging) SPI.</pre><pre class="screen">        #chip mega328p, 16
        #option explicit
        #include &lt;UNO_mega328p.h &gt;

        #define SPI_HardwareSPI  'comment this out to make into Software SPI but, you may have to change clock lines

        'Pin mappings for SPI - this SPI driver supports Hardware SPI
        #define SPI_DC       DIGITAL_8          ' Data command line
        #define SPI_CS       DIGITAL_4          ' Chip select line
        #define SPI_RESET    DIGITAL_9          ' Reset line

        #define SPI_DI       DIGITAL_12          ' Data in | MISO
        #define SPI_DO       DIGITAL_11          ' Data out | MOSI
        #define SPI_SCK      DIGITAL_13          ' Clock Line

        dir SPI_DC    out
        dir SPI_CS    out
        dir SPI_RESET out
        dir SPI_DO    Out
        dir SPI_DI    In
        dir SPI_SCK   Out

        'If DIGITAL_10 is NOT used as the SPI_CS (sometimes called SS) the port must and output or set as input/pulled high with a 10k resistor.
        'As follows:
        'If CS is configured as an input, it must be held high to ensure Master SPI operation.
        'If the CS pin is driven low by peripheral circuitry when the SPI is configured as a Master with the SS pin defined as an input, the
        'SPI system interprets this as another master selecting the SPI as a slave and starting to send data to it!
        'If CS is an output SPI communications will commence with no flow control.
        dir DIGITAL_10 Out

        DIM byte1 As byte
        DIM byte2 As byte
        DIM byte3 As byte

        byte1 = 100 ' temp values (will come from potentiometer later)
        byte2 = 150
        byte3 = 200

        InitSPIMode


        do forever
            set SPI_CS OFF;
            set SPI_DC OFF;
            SendByteviaSPI (byte1)
            set SPI_CS ON;
            set SPI_DC ON

            set SPI_CS OFF;
            set SPI_DC OFF;
            SendByteviaSPI (byte2)
            set SPI_CS ON;
            set SPI_DC ON

            set SPI_CS OFF;
            set SPI_DC OFF;
            SendByteviaSPI (byte3)
            set SPI_CS ON;
            set SPI_DC ON

            wait 10 ms
        loop



    sub InitSPIMode

          #ifdef SPI_HardwareSPI
              SPIMode ( MasterFast, SPI_CPOL_0 + SPI_CPHA_0 )
          #endif

          set SPI_DO OFF;
          set SPI_CS ON;   therefore CPOL=0
          set SPI_DC ON;   deselect

    End sub

    sub  SendByteviaSPI( in SPISendByte as byte )

      set SPI_CS OFF
      set SPI_DC OFF;

      #ifdef SPI_HardwareSPI
         FastHWSPITransfer  SPISendByte
         set SPI_CS ON;
         exit sub
      #endif

      #ifndef SPI_HardwareSPI
      repeat 8

        if SPISendByte.7 = ON  then
          set SPI_DO ON;
        else
          set SPI_DO OFF;
        end if
        SET SPI_SCK On;           ; therefore CPOL=0 ==ON, and, where CPOL=1==ON
        rotate SPISendByte left
        set SPI_SCK Off;          ; therefore CPOL=0  =OFF, and, where CPOL=1==OFF

      end repeat
      set SPI_CS ON;
      set SPI_DO OFF;
      #endif

    end Sub</pre><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_spimode.html" title="SPIMode">SPIMode</a>,<a class="link" href="_spitransfer.html" title="SPITransfer">SPITransfer</a>,<a class="link" href="_fasthwspitransfer.html" title="FastHWSPITransfer">FastHWSPITransfer</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="spi_overview"></span>SPI Overview

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

The SPI interface allows for the transmission and receiption of data
simultaneously on two lines (MOSI and MISO).

The Clock polarity (CPOL) and clock phase (CPHA) are the main parameters
that define a clock format to be used by the SPI bus. Depending on CPOL
parameter, SPI clock may be inverted or non-inverted. CPHA parameter is
used to shift the sampling phase. If CPHA=0 the data are sampled on the
leading (first) clock edge. If CPHA=1 the data are sampled on the
trailing (second) clock edge, regardless of whether that clock edge is
rising or falling.

CPOL=0, CPHA=0

<div class="informalfigure">

<div class="mediaobject" align="center">

![\[graphic](./images/spi-cpol-0-cpha-0.png)

</div>

</div>

The data must be available before the first clock signal rising. The
clock idle state is zero. The data on MISO and MOSI lines must be stable
while the clock is high and can be changed when the clock is low. The
data is captured on the clock’s low-to-high transition and propagated on
high-to-low clock transition.

CPOL=0, CPHA=1

<div class="informalfigure">

<div class="mediaobject" align="center">

![\[graphic](./images/spi-cpol-0-cpha-1.png)

</div>

</div>

The first clock signal rising can be used to prepare the data. The clock
idle state is zero. The data on MISO and MOSI lines must be stable while
the clock is low and can be changed when the clock is high. The data is
captured on the clock’s high-to-low transition and propagated on
low-to-high clock transition.

CPOL=1, CPHA=0

<div class="informalfigure">

<div class="mediaobject" align="center">

![\[graphic](./images/spi-cpol-1-cpha-0.png)

</div>

</div>

The data must be available before the first clock signal falling. The
clock idle state is one. The data on MISO and MOSI lines must be stable
while the clock is low and can be changed when the clock is high. The
data is captured on the clock’s high-to-low transition and propagated on
low-to-high clock transition.

CPOL=1, CPHA=1

<div class="informalfigure">

<div class="mediaobject" align="center">

![\[graphic](./images/spi-cpol-1-cpha-1.png)

</div>

</div>

The first clock signal falling can be used to prepare the data. The
clock idle state is one. The data on MISO and MOSI lines must be stable
while the clock is high and can be changed when the clock is low. The
data is captured on the clock’s low-to-high transition and propagated on
high-to-low clock transition.

<span class="strong">**Key Commands**</span>

``` screen
    SPIMode  ( _Mode_ [, SPIClockMode])

    SPITransfer (  _OutByte_, _InByte_ )

    FastHWSPITransfer( _OutByte_ )

    #define HWSPIMode MASTERULTRAFAST       'MASTERSLOW | MASTER | MASTERFAST | MASTERULTRAFAST for specific AVRs only | MasterSSPADDMode for specific PICs SSPADD support
                                            'Defaults to MASTERFAST when microcontroller frequency less or equal to 32 mhz
                                            'Defaults to MASTER when microcontroller frequency more than 32 mhz.
```

The GCBASIC used the microcontrollers hardware module for SPI. The
example below shows an implementation of Hardware and Software SPI.
Software SPI allows for a greater choice of ports to be used to control
the SPI operations.

<span class="strong">**Example**</span>

This example demonstrates the SPI capabilities for the mega328p. The
process is similar of any microcontroller..

This example show using the hardware SPI option and a sofware SPI
option.

Using hardware SPI mode - make sure the `#define SPI_HardwareSPI` is not
commented out. Using software SPI mode - comment out
`#define SPI_HardwareSPI`. The example code will then use software SPI.

<span class="strong">**Setting the SPI Mode**</span>

Hardware SPI mode the Data Out, Data In and Clock (DO/DI and SCK) cannot
be moved but the optional Data Command, Chip Select and Reset are all
moveable.

Software SPI mode the Data Out, Data In and Clock (DO/DI and SCK), Data
Command, Chip Select and Reset are all moveable.

Use the constant `HWSPIMode` to set the SPI frequency when using GCBASIC
libraries.

``` screen
    #define HWSPIMode MASTERULTRAFAST
```

GCBASIC libraries will default to to MASTERFAST when microcontroller
frequency less or equal to 32 mhz and default to MASTER when
microcontroller frequency more than 32 mhz.

The options for `HWSPIMode` are:

`MASTERSLOW`, or, `MASTER` or `MASTERFAST` or `MASTERULTRAFAST` for
specific AVRs only or `MasterSSPADDMode` for specific PICs SSPADD
support

This constant sets the library to the desire SPI fequency, therefore
enable adaption of the SPI frequency without have to change the library.

The SPI frequnecy must be the same for all the used devices.   In
particular, it must be set equal to the one dictated by the slowest SPI
device to be used.

More freedom is available when more than an hardware SPI is available as
well as when the user want to use hardware SPI for a device and software
SPI for a second one.

<span class="strong">**Using multiple SPI devices**</span>

There will be use cases were you need to use more than one SPI target
device at a time.  In such cases the device defined for SPI must be
inserted in your program for each device.

As an example using e-Paper and SRAM at the same time, with an hardware
SPI would require `#define SPISRAM_HARDWARESPI` and
`#define EPD_HardwareSPI`.  

Obviously, when all SPI devices use the same SPI lines, you must select
one device at a time by setting SPI Chip Select line to `OFF` for the
specific target SPI device, and you must set `ON` the SPI Chip Select
line for any other SPI device  -  this is a normal convention of SPI
usage.    This is not specific to GCBASIC..

<span class="strong">**Code overview**</span>

``` literallayout
InitSPIMode calls SPIMode. if needed, when hardware mode, and set the port firections.
The sub SendByteviaSPI is called to handle whether to call the Hardware or use Software (bit-banging) SPI.
```

``` screen
        #chip mega328p, 16
        #option explicit
        #include <UNO_mega328p.h >

        #define SPI_HardwareSPI  'comment this out to make into Software SPI but, you may have to change clock lines

        'Pin mappings for SPI - this SPI driver supports Hardware SPI
        #define SPI_DC       DIGITAL_8          ' Data command line
        #define SPI_CS       DIGITAL_4          ' Chip select line
        #define SPI_RESET    DIGITAL_9          ' Reset line

        #define SPI_DI       DIGITAL_12          ' Data in | MISO
        #define SPI_DO       DIGITAL_11          ' Data out | MOSI
        #define SPI_SCK      DIGITAL_13          ' Clock Line

        dir SPI_DC    out
        dir SPI_CS    out
        dir SPI_RESET out
        dir SPI_DO    Out
        dir SPI_DI    In
        dir SPI_SCK   Out

        'If DIGITAL_10 is NOT used as the SPI_CS (sometimes called SS) the port must and output or set as input/pulled high with a 10k resistor.
        'As follows:
        'If CS is configured as an input, it must be held high to ensure Master SPI operation.
        'If the CS pin is driven low by peripheral circuitry when the SPI is configured as a Master with the SS pin defined as an input, the
        'SPI system interprets this as another master selecting the SPI as a slave and starting to send data to it!
        'If CS is an output SPI communications will commence with no flow control.
        dir DIGITAL_10 Out

        DIM byte1 As byte
        DIM byte2 As byte
        DIM byte3 As byte

        byte1 = 100 ' temp values (will come from potentiometer later)
        byte2 = 150
        byte3 = 200

        InitSPIMode


        do forever
            set SPI_CS OFF;
            set SPI_DC OFF;
            SendByteviaSPI (byte1)
            set SPI_CS ON;
            set SPI_DC ON

            set SPI_CS OFF;
            set SPI_DC OFF;
            SendByteviaSPI (byte2)
            set SPI_CS ON;
            set SPI_DC ON

            set SPI_CS OFF;
            set SPI_DC OFF;
            SendByteviaSPI (byte3)
            set SPI_CS ON;
            set SPI_DC ON

            wait 10 ms
        loop



    sub InitSPIMode

          #ifdef SPI_HardwareSPI
              SPIMode ( MasterFast, SPI_CPOL_0 + SPI_CPHA_0 )
          #endif

          set SPI_DO OFF;
          set SPI_CS ON;   therefore CPOL=0
          set SPI_DC ON;   deselect

    End sub

    sub  SendByteviaSPI( in SPISendByte as byte )

      set SPI_CS OFF
      set SPI_DC OFF;

      #ifdef SPI_HardwareSPI
         FastHWSPITransfer  SPISendByte
         set SPI_CS ON;
         exit sub
      #endif

      #ifndef SPI_HardwareSPI
      repeat 8

        if SPISendByte.7 = ON  then
          set SPI_DO ON;
        else
          set SPI_DO OFF;
        end if
        SET SPI_SCK On;           ; therefore CPOL=0 ==ON, and, where CPOL=1==ON
        rotate SPISendByte left
        set SPI_SCK Off;          ; therefore CPOL=0  =OFF, and, where CPOL=1==OFF

      end repeat
      set SPI_CS ON;
      set SPI_DO OFF;
      #endif

    end Sub
```

<span class="strong">**See also**</span>
<a href="spimode" class="link" title="SPIMode">SPIMode</a>,<a href="spitransfer" class="link" title="SPITransfer">SPITransfer</a>,<a href="fasthwspitransfer" class="link" title="FastHWSPITransfer">FastHWSPITransfer</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Sqrt</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_maths.html" title="Maths"><link rel="prev" href="_scale.html" title="Scale"><link rel="next" href="_trigonometry_sine_cosine_and_tangent.html" title="Trigonometry Sine, Cosine and Tangent"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_sqrt"></a>Sqrt</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    word_variable = sqrt ( <span class="emphasis"><em>word</em></span> )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>A square root routine for GCBASIC. The function only involves bit shifting, addition and subtraction, which makes it fast and efficient.</p><p>This method required a word variable as the input and a word variable as the output. The method will handle arguments of up to 4294.</p><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers, required MATHS.H include file.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    ;Demo: Show the first 100 square roots to 2 decimal places.
    ;This uses the maths.h include file.

    ;----- Configuration

    #chip 16F88, 8                  ;PIC16F88 running at 8 MHz
    #config mclr=off                ;reset handled internally

    #include &lt;maths.h&gt;              ;required maths.h

    ;----- Constants

    #define LCD_IO      4           ;4-bit mode
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS      PortB.2     ;pin 8 is LCD Register Select
    #define LCD_Enable  PortB.3     ;pin 9 is LCD Enable
    #define LCD_DB4     PortB.4     ;DB4 on pin 10
    #define LCD_DB5     PortB.5     ;DB5 on pin 11
    #define LCD_DB6     PortB.6     ;DB6 on pin 12
    #define LCD_DB7     PortB.7     ;DB7 on pin 13
    #define LCD_NO_RW   1           ;ground the RW line on LCD

    ;----- Variables

    dim length as byte
    dim i as word
    dim valStr, outStr as string

    ;----- Program

    dir PortB out       ;all outputs to the LCD

    for i = 0 to 100   ;print first 100 square roots
      cls
      print "sqrt("
      print i
      print ")="

      valStr = str(sqrt(i))         ;format decimal nicely
      length = len(valStr)

      select case length
       case 1:
          outStr = "0.00"           ;zero case
       case 3:
          outStr = left(valStr,1)+ "."+right(valStr,2)
        case 4:
          outStr = left(valStr,2)+ "."+right(valStr,2)
        case 5:
          outStr = left(valStr,3)+ "."+right(valStr,2)
      end select

      print outStr                  ;display results
      wait 2 S
    next i</pre><p><span class="strong"><strong>Supported in &lt;MATHS.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="sqrt"></span>Sqrt

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    word_variable = sqrt ( word )
```

<span class="strong">**Explanation:**</span>

A square root routine for GCBASIC. The function only involves bit
shifting, addition and subtraction, which makes it fast and efficient.

This method required a word variable as the input and a word variable as
the output. The method will handle arguments of up to 4294.

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers, required MATHS.H include file.

<span class="strong">**Example:**</span>

``` screen
    ;Demo: Show the first 100 square roots to 2 decimal places.
    ;This uses the maths.h include file.

    ;----- Configuration

    #chip 16F88, 8                  ;PIC16F88 running at 8 MHz
    #config mclr=off                ;reset handled internally

    #include <maths.h>              ;required maths.h

    ;----- Constants

    #define LCD_IO      4           ;4-bit mode
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS      PortB.2     ;pin 8 is LCD Register Select
    #define LCD_Enable  PortB.3     ;pin 9 is LCD Enable
    #define LCD_DB4     PortB.4     ;DB4 on pin 10
    #define LCD_DB5     PortB.5     ;DB5 on pin 11
    #define LCD_DB6     PortB.6     ;DB6 on pin 12
    #define LCD_DB7     PortB.7     ;DB7 on pin 13
    #define LCD_NO_RW   1           ;ground the RW line on LCD

    ;----- Variables

    dim length as byte
    dim i as word
    dim valStr, outStr as string

    ;----- Program

    dir PortB out       ;all outputs to the LCD

    for i = 0 to 100   ;print first 100 square roots
      cls
      print "sqrt("
      print i
      print ")="

      valStr = str(sqrt(i))         ;format decimal nicely
      length = len(valStr)

      select case length
       case 1:
          outStr = "0.00"           ;zero case
       case 3:
          outStr = left(valStr,1)+ "."+right(valStr,2)
        case 4:
          outStr = left(valStr,2)+ "."+right(valStr,2)
        case 5:
          outStr = left(valStr,3)+ "."+right(valStr,2)
      end select

      print outStr                  ;display results
      wait 2 S
    next i
```

<span class="strong">**Supported in &lt;MATHS.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SRAMRead</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_sram_device.html" title="SRAM ( Device )"><link rel="prev" href="_sram_overview.html" title="SRAM Overview"><link rel="next" href="_sramwrite.html" title="SRAMWrite"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_sramread"></a>SRAMRead</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    SRAMRead <span class="emphasis"><em>location, store</em></span>

    or

    <span class="emphasis"><em>store = SRAMRead location</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip PIC and Atmel AVR microcontrollers with SRAM data memory attached.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">SRAMRead</code> is the method, a function or a subroutine, used to read information from the SRAM data storage.</p><p><code class="literal"><span class="emphasis"><em>location</em></span></code> represents the location to read data from.</p><p><code class="literal"><span class="emphasis"><em>store</em></span></code> is the variable in which to store the data after it has been read from SRAM.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #include &lt;uno_mega328p.h&gt;
    #option explicit

    'Set up SRAM
    #define SPISRAM_CS      DIGITAL_5     'Also known as SS, or Slave Select
    #define SPISRAM_SCK     DIGITAL_13    'Also known as CLK
    #define SPISRAM_DO      DIGITAL_11    'Also known as MOSI
    #define SPISRAM_DI      DIGITAL_12    'Also known as MISO

    #define SPISRAM_HARDWARESPI
    #define SPISRAM_TYPE     SRAM_23LC1024

  '********************************************************************************

  'Main program

  dim in_byte as byte

  'Using a function:  Read from SRAM location 0x10 and place the results in the variable in_byte
  in_byte = SRAMRead ( 0x10 )

  'Using a subroutine:  Read from SRAM location 0x10 and place the results in the variable in_byte
  SRAMRead ( 0x10, in_byte )</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_sram_overview.html" title="SRAM Overview">SRAM Overview</a> or <a class="link" href="_sramwrite.html" title="SRAMWrite">SRAMWrite</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="sramread"></span>SRAMRead

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    SRAMRead location, store

    or

    store = SRAMRead location
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip PIC and Atmel AVR microcontrollers with SRAM
data memory attached.

<span class="strong">**Explanation:**</span>

`SRAMRead` is the method, a function or a subroutine, used to read
information from the SRAM data storage.

`location` represents the location to read data from.

`store` is the variable in which to store the data after it has been
read from SRAM.

<span class="strong">**Example:**</span>

``` screen
    #include <uno_mega328p.h>
    #option explicit

    'Set up SRAM
    #define SPISRAM_CS      DIGITAL_5     'Also known as SS, or Slave Select
    #define SPISRAM_SCK     DIGITAL_13    'Also known as CLK
    #define SPISRAM_DO      DIGITAL_11    'Also known as MOSI
    #define SPISRAM_DI      DIGITAL_12    'Also known as MISO

    #define SPISRAM_HARDWARESPI
    #define SPISRAM_TYPE     SRAM_23LC1024

  '********************************************************************************

  'Main program

  dim in_byte as byte

  'Using a function:  Read from SRAM location 0x10 and place the results in the variable in_byte
  in_byte = SRAMRead ( 0x10 )

  'Using a subroutine:  Read from SRAM location 0x10 and place the results in the variable in_byte
  SRAMRead ( 0x10, in_byte )
```

<span class="strong">**For more help, see
<a href="sram_overview" class="link" title="SRAM Overview">SRAM Overview</a>
or
<a href="sramwrite" class="link" title="SRAMWrite">SRAMWrite</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SRAMWrite</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_sram_device.html" title="SRAM ( Device )"><link rel="prev" href="_sramread.html" title="SRAMRead"><link rel="next" href="_flow_control.html" title="Flow control"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_sramwrite"></a>SRAMWrite</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    SRAMWrite <span class="emphasis"><em>location</em></span>, <span class="emphasis"><em>data</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip PIC and Atmel AVR microcontrollers with SRAM data memory attached.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">SRAMWrite</code> is the method used to write information to the SRAM data storage, so that
it can be accessed by the <code class="literal">SRAMRead</code> command.</p><p><code class="literal"><span class="emphasis"><em>location</em></span></code> represents the location to read data from, and this location will vary
from one application/solution to another.</p><p><code class="literal"><span class="emphasis"><em>data</em></span></code> is the data that is to be written to the SRAM, a byte value or a byte variable.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #include &lt;uno_mega328p.h&gt;
    #option explicit

    'Set up SRAM
    #define SPISRAM_CS      DIGITAL_5     'Also known as SS, or Slave Select
    #define SPISRAM_SCK     DIGITAL_13    'Also known as CLK
    #define SPISRAM_DO      DIGITAL_11    'Also known as MOSI
    #define SPISRAM_DI      DIGITAL_12    'Also known as MISO

    #define SPISRAM_HARDWARESPI
    #define SPISRAM_TYPE     SRAM_23LC1024

  '********************************************************************************

  'Main program

  dim out_byte as byte

  'A subroutine:  Weite to SRAM location 0x10 and the variable out_byte
  SRAMRead ( 0x10, out_byte )</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_sram_overview.html" title="SRAM Overview">SRAMOverview</a> or <a class="link" href="_sramread.html" title="SRAMRead">SRAMRead</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="sramwrite"></span>SRAMWrite

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    SRAMWrite location, data
```

<span class="strong">**Command Availability:**</span>

Available on all Microchip PIC and Atmel AVR microcontrollers with SRAM
data memory attached.

<span class="strong">**Explanation:**</span>

`SRAMWrite` is the method used to write information to the SRAM data
storage, so that it can be accessed by the `SRAMRead` command.

`location` represents the location to read data from, and this location
will vary from one application/solution to another.

`data` is the data that is to be written to the SRAM, a byte value or a
byte variable.

<span class="strong">**Example:**</span>

``` screen
    #include <uno_mega328p.h>
    #option explicit

    'Set up SRAM
    #define SPISRAM_CS      DIGITAL_5     'Also known as SS, or Slave Select
    #define SPISRAM_SCK     DIGITAL_13    'Also known as CLK
    #define SPISRAM_DO      DIGITAL_11    'Also known as MOSI
    #define SPISRAM_DI      DIGITAL_12    'Also known as MISO

    #define SPISRAM_HARDWARESPI
    #define SPISRAM_TYPE     SRAM_23LC1024

  '********************************************************************************

  'Main program

  dim out_byte as byte

  'A subroutine:  Weite to SRAM location 0x10 and the variable out_byte
  SRAMRead ( 0x10, out_byte )
```

<span class="strong">**For more help, see
<a href="sram_overview" class="link" title="SRAM Overview">SRAMOverview</a>
or
<a href="sramread" class="link" title="SRAMRead">SRAMRead</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SRAM ( Device )</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_memory.html" title="Memory"><link rel="prev" href="_47xxx_eeram_devices.html" title="47xxx EERam Devices"><link rel="next" href="_sram_overview.html" title="SRAM Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_sram_device"></a>SRAM  ( Device )</h4></div></div></div><p>This is the SRAM section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="sram_device"></span>SRAM ( Device )

</div>

</div>

</div>

This is the SRAM section of the Help file. Please refer the sub-sections
for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SRAM Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_sram_device.html" title="SRAM ( Device )"><link rel="prev" href="_sram_device.html" title="SRAM ( Device )"><link rel="next" href="_sramread.html" title="SRAMRead"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_sram_overview"></a>SRAM Overview</h5></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>Serial SRAM is a standalone volatile memory that provides an easy and inexpensive way to add more RAM to application.&nbsp;&nbsp;These are 8-pin low-power devices.&nbsp;&nbsp;
They are high-performance devices have unlimited endurance and zero write times, making them ideal for applications involving continuous data transfer, buffering, data logging, audio, video, internet, graphics and other math and data-intensive functions.&nbsp;&nbsp;</p><p>These devices are available from 64 Kbit up to 1 Mbit in density and support SPI, SDI and SQI&#8482; bus modes.&nbsp;&nbsp;</p><p>The GCBASIC library only supports SPI bus mode.&nbsp;&nbsp;  The GCBASIC library supports hardware and software SPI - this is controlled via a constant, see below.</p><p>To use the SRAM libray simply include the following in your user code.&nbsp;&nbsp;</p><p>This will initialise the driver.&nbsp;&nbsp;</p><pre class="screen">    #define SPISRAM_CS      Porta.2      'Also known as SS, or Slave Select
    #define SPISRAM_SCK     Portc.3      'Also known as CLK
    #define SPISRAM_DO      Portc.5      'Also known as MOSI
    #define SPISRAM_DI      Portc.4      'Also known as MISO

    #define SPISRAM_HARDWARESPI
    #define SPISRAM_TYPE     SRAM_23LC1024</pre><p>SRAM memory operations.&nbsp;&nbsp;&nbsp;</p><p><br>
<br>
The library exposes a set of method to support use of SRAM memory.
<br>
<br></p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top"><p>Method</p></td><td align="left" valign="top"><p>Parameters</p></td><td align="left" valign="top"><p>Usage</p></td></tr><tr><td align="left" valign="top"><p>SRAMWrite</p></td><td align="left" valign="top"><p>eepAddr as long, eepromVal as byte</p></td><td align="left" valign="top"><p>A subroutine that required the address and the value to be written to SRAM.</p></td></tr><tr><td align="left" valign="top"><p>SRAMRead</p></td><td align="left" valign="top"><p>eepAddr as long, eepromVal as byte</p></td><td align="left" valign="top"><p>A subroutine that required the address and variable to updated with the byte value from the specified SRAM address.</p></td></tr><tr><td align="left" valign="top"><p>SRAMRead</p></td><td align="left" valign="top"><p>eepAddr as long</p></td><td align="left" valign="top"><p>A function that required the address. The function returns a byte value from the specified SRAM address.</p></td></tr></tbody></table></div><p><br>
<br>
The library requires a set of constants to support use of SRAM memory.
<br>
<br></p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Parameters</p></td><td align="left" valign="top"><p>Usage</p></td></tr><tr><td align="left" valign="top"><p>SPISRAM_TYPE</p></td><td align="left" valign="top"><p>Specifies the type of SRAM.</p></td><td align="left" valign="top"><p>Requires one of the following constants
</p><p>SRAM_23LC1024,<br>
SRAM_23LCV1024,<br>
SRAM_23LC1024,<br>
SRAM_23A1024,<br>
SRAM_23LCV512,<br>
SRAM_23LC512, <br>
SRAM_23A512, <br>
SRAM_23K256, <br>
SRAM_23A256, <br>
SRAM_23A640, or <br>
SRAM_23K640</p></td></tr><tr><td align="left" valign="top"><p>SPISRAM_CS</p></td><td align="left" valign="top"><p>Specifies the port for the chip select port.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p>SPISRAM_SCK</p></td><td align="left" valign="top"><p>Specifies the port for the SPI clock port.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p>SPISRAM_DO</p></td><td align="left" valign="top"><p>Specifies the port for the SPI data out, or MOSI, port.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p>SPISRAM_DI</p></td><td align="left" valign="top"><p>Specifies the port for the data in, or MISO, port.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p>HWSPIMode</p></td><td align="left" valign="top"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td><td align="left" valign="top"><p>Optional defaults to MASTERFAST.
</p><p>Options are MASTERSLOW,<br>
MASTER,<br>
MASTERFAST, or<br>
MASTERULTRAFAST for specific AVRs only.</p></td></tr><tr><td align="left" valign="top"><p>SPISRAM_HARDWARESPI</p></td><td align="left" valign="top"><p>Instructs the library to use hardware SPI, remove or comment out if you want to use software SPI.</p></td><td align="left" valign="top"><p>Optional</p></td></tr></tbody></table></div><p><br>
<br>
The library also exposes a constant that is specific to the device.&nbsp;&nbsp;&nbsp;</p><p>These may be useful in the user program.&nbsp;&nbsp;&nbsp;</p><p>This constant is used by the library.&nbsp;&nbsp;&nbsp;</p><p>A user may use this public constant.
<br>
<br></p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Type</p></td><td align="left" valign="top"><p>Usage</p></td></tr><tr><td align="left" valign="top"><p>SPISRAM_CAPACITY</p></td><td align="left" valign="top"><p>Long value</p></td><td align="left" valign="top"><p>Use to determine the size of the SRAM device</p></td></tr></tbody></table></div><p><span class="strong"><strong>Examples</strong></span></p><pre class="screen">    #include &lt;uno_mega328p.h&gt;
    #option explicit

   ' USART settings
    #define USART_BAUD_RATE 57600
    #define USART_DELAY 0 ms
    #define USART_BLOCKING
    #define USART_TX_BLOCKING


    'SD card attached to SPI bus as follows:
    '
    'UNO:    MOSI - pin 11, MISO - pin 12, CLK - pin 13, CS - pin 4 (CS pin can be changed) and pin #10 (SS) must be an output
    'Mega:   MOSI - pin 51, MISO - pin 50, CLK - pin 52, CS - pin 4 (CS pin can be changed) and pin #52 (SS) must be an output
    'Leonardo: Connect to hardware SPI via the ICSP header

    #define SPISRAM_CS      DIGITAL_5     'Also known as SS, or Slave Select
    #define SPISRAM_SCK      DIGITAL_13    'Also known as CLK
    #define SPISRAM_DO      DIGITAL_11    'Also known as MOSI
    #define SPISRAM_DI      DIGITAL_12    'Also known as MISO

    #define SPISRAM_HARDWARESPI
    #define SPISRAM_TYPE     SRAM_23LC1024

    #define HWSPIMode MASTERULTRAFAST       'MASTERSLOW | MASTER | MASTERFAST | MASTERULTRAFAST for specific AVRs only. Defaults to MASTERFAST


  '********************************************************************************

  'Main program

    'Wait 2 seconds to open the serial terminal
    wait 2 s

    HSerPrintCRLF 2
    HSerPrint "Writing..."
    HSerPrintCRLF
    For SRAM_location=0 to SPISRAM_CAPACITY - 1
     SRAMWrite ( [long]SRAM_location, SRAM_location and 255 )
    Next


    dim spirambyteread as Byte
    spirambyteread = 11
    HSerPrintCRLF 2
    dim SRAM_location as long
    HSerPrint "Reading..."
    HSerPrintCRLF
    For SRAM_location=0 to SPISRAM_CAPACITY - 1
     'choose one....
     'SRAMread ( SRAM_location, spirambyteread )
    'or, as a function
     spirambyteread = SRAMread ( SRAM_location )

     if spirambyteread = ( SRAM_location and 255 ) then
       HSerPrint hex(spirambyteread)
     else
       HSerPrint "**"
     end if
     HSerPrint ":"
    Next
    HSerPrintCRLF
    HSerPrint "Wait..."
    HSerPrintCRLF
    Wait 2 s

    HSerPrint "Rewriting to 0x00 ..."
    HSerPrintCRLF
    For SRAM_location=0 to SPISRAM_CAPACITY - 1
     SRAMWrite ( [long]SRAM_location, 0 )
    Next

    Dim errorcount as long
    errorcount = 0
    For SRAM_location=0 to SPISRAM_CAPACITY - 1
     SRAMRead ( SRAM_location, spirambyteread )
     if spirambyteread &lt;&gt; 0 then
       errorcount++
     end if
    Next
    HSerPrint "Error Count (should be 0) = "
    HSerPrint errorcount
    HSerPrintCRLF
    HSerPrint "End..."
    HSerPrintCRLF
    end</pre><p>or, for a PIC with PPS</p><pre class="screen">    'Chip Settings.
   #chip 18F47k42, 64
   #config MCLRE = ON
   #option explicit


   'PPS Tool version: 0.0.5.27
   'PinManager data: v1.78
   'Generated for 18F47K42
   '
   'Template comment at the start of the config file
   '
   #startup InitPPS, 85
   #define PPSToolPart 18F47K42

   Sub InitPPS
      'This has been added to turn off PPS SPI when in SPI software mode
       #ifdef SPISRAM_HARDWARESPI
         'Module: SPI1
         RC3PPS = 0x001E  'SCK1 &gt; RC3
         SPI1SCKPPS = 0x0013  'RC3 &gt; SCK1 (bi-directional)
         RC5PPS = 0x001F  'SDO1 &gt; RC5
         SPI1SDIPPS = 0x0014  'RC4 &gt; SDI1
         'Module: UART pin directions
       #endif
       'Module: UART pin directions
       Dir PORTC.6 Out  ' Make TX1 pin an output
       'Module: UART1
       RC6PPS = 0x0013  'TX1 &gt; RC6
   End Sub
   'Template comment at the end of the config file


   ' USART settings
   #define USART_BAUD_RATE 57600
   #define USART_DELAY 0 ms
   #define USART_BLOCKING
   #define USART_TX_BLOCKING

   #define SPISRAM_CS      Porta.2      'Also known as SS, or Slave Select
   #define SPISRAM_SCK      Portc.3      'Also known as CLK
   #define SPISRAM_DO      Portc.5      'Also known as MOSI
   #define SPISRAM_DI      Portc.4      'Also known as MISO

   #define SPISRAM_HARDWARESPI
   #define SPISRAM_TYPE     SRAM_23LC1024

   '********************************************************************************

   'Main program

   'Wait 2 seconds to open the serial terminal
   wait 2 s
   dim sizeofSPIRAM as long
   sizeofSPIRAM = SPISRAM_CAPACITY
   HSerPrintCRLF 2
   HSerPrint "Writing...SPISRAM_CAPACITY = 0x"
   HSerPrint hex(sizeofSPIRAM_U)
   HSerPrint hex(sizeofSPIRAM_H)
   HSerPrint hex(sizeofSPIRAM)
   HSerPrintCRLF
   wait 100 ms

   dim SRAM_location as long
   For SRAM_location=0 to SPISRAM_CAPACITY - 1
    SRAMWrite ( [long]SRAM_location, SRAM_location and 255 )
   Next


   dim spirambyteread as Byte
   spirambyteread = 11 'could be any number....
   HSerPrintCRLF 2

   HSerPrint "Reading..."
   HSerPrintCRLF
   For SRAM_location=0 to SPISRAM_CAPACITY - 1
    'choose one....
    'SRAMRead ( SRAM_location, spirambyteread )
   'or, as a function
    spirambyteread = SRAMRead ( SRAM_location )

    if spirambyteread = ( SRAM_location and 255 ) then
      HSerPrint hex(spirambyteread)
    else
      HSerPrint "**"
    end if
    HSerPrint ":"
   Next
   HSerPrintCRLF
   HSerPrint "Wait..."
   HSerPrintCRLF
   Wait 2 s

   HSerPrint "Rewriting to 0x00 ..."
   HSerPrintCRLF
   For SRAM_location=0 to SPISRAM_CAPACITY - 1
    SRAMWrite ( [long]SRAM_location, 0 )
   Next

   Dim errorcount as long
   errorcount = 0
   For SRAM_location=0 to SPISRAM_CAPACITY - 1
    SRAMRead ( SRAM_location, spirambyteread )
    if spirambyteread &lt;&gt; 0 then
      errorcount++
    end if
   Next
   HSerPrint "Error Count (should be 0) = "
   HSerPrint errorcount
   HSerPrintCRLF
   HSerPrint "End..."
   HSerPrintCRLF

   do

   loop</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_sramread.html" title="SRAMRead">SRAMRead</a> or <a class="link" href="_sramwrite.html" title="SRAMWrite">SRAMWrite</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="sram_overview"></span>SRAM Overview

</div>

</div>

</div>

<span class="strong">**Introduction:**</span>

Serial SRAM is a standalone volatile memory that provides an easy and
inexpensive way to add more RAM to application.  These are 8-pin
low-power devices.   They are high-performance devices have unlimited
endurance and zero write times, making them ideal for applications
involving continuous data transfer, buffering, data logging, audio,
video, internet, graphics and other math and data-intensive functions.  

These devices are available from 64 Kbit up to 1 Mbit in density and
support SPI, SDI and SQI™ bus modes.  

The GCBASIC library only supports SPI bus mode.   The GCBASIC library
supports hardware and software SPI - this is controlled via a constant,
see below.

To use the SRAM libray simply include the following in your user code.  

This will initialise the driver.  

``` screen
    #define SPISRAM_CS      Porta.2      'Also known as SS, or Slave Select
    #define SPISRAM_SCK     Portc.3      'Also known as CLK
    #define SPISRAM_DO      Portc.5      'Also known as MOSI
    #define SPISRAM_DI      Portc.4      'Also known as MISO

    #define SPISRAM_HARDWARESPI
    #define SPISRAM_TYPE     SRAM_23LC1024
```

SRAM memory operations.   

  
  
The library exposes a set of method to support use of SRAM memory.  
  

<div class="informaltable">

|           |                                    |                                                                                                                     |
|:----------|:-----------------------------------|:--------------------------------------------------------------------------------------------------------------------|
| Method    | Parameters                         | Usage                                                                                                               |
| SRAMWrite | eepAddr as long, eepromVal as byte | A subroutine that required the address and the value to be written to SRAM.                                         |
| SRAMRead  | eepAddr as long, eepromVal as byte | A subroutine that required the address and variable to updated with the byte value from the specified SRAM address. |
| SRAMRead  | eepAddr as long                    | A function that required the address. The function returns a byte value from the specified SRAM address.            |

</div>

  
  
The library requires a set of constants to support use of SRAM memory.  
  

<div class="informaltable">

<table data-border="1" width="80%">
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Constant</p></td>
<td style="text-align: left;"><p>Parameters</p></td>
<td style="text-align: left;"><p>Usage</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>SPISRAM_TYPE</p></td>
<td style="text-align: left;"><p>Specifies the type of SRAM.</p></td>
<td style="text-align: left;"><p>Requires one of the following constants</p>
<p>SRAM_23LC1024,<br />
SRAM_23LCV1024,<br />
SRAM_23LC1024,<br />
SRAM_23A1024,<br />
SRAM_23LCV512,<br />
SRAM_23LC512,<br />
SRAM_23A512,<br />
SRAM_23K256,<br />
SRAM_23A256,<br />
SRAM_23A640, or<br />
SRAM_23K640</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>SPISRAM_CS</p></td>
<td style="text-align: left;"><p>Specifies the port for the chip select port.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>SPISRAM_SCK</p></td>
<td style="text-align: left;"><p>Specifies the port for the SPI clock port.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>SPISRAM_DO</p></td>
<td style="text-align: left;"><p>Specifies the port for the SPI data out, or MOSI, port.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>SPISRAM_DI</p></td>
<td style="text-align: left;"><p>Specifies the port for the data in, or MISO, port.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>HWSPIMode</p></td>
<td style="text-align: left;"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td>
<td style="text-align: left;"><p>Optional defaults to MASTERFAST.</p>
<p>Options are MASTERSLOW,<br />
MASTER,<br />
MASTERFAST, or<br />
MASTERULTRAFAST for specific AVRs only.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>SPISRAM_HARDWARESPI</p></td>
<td style="text-align: left;"><p>Instructs the library to use hardware SPI, remove or comment out if you want to use software SPI.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
</tbody>
</table>

</div>

  
  
The library also exposes a constant that is specific to the device.   

These may be useful in the user program.   

This constant is used by the library.   

A user may use this public constant.  
  

<div class="informaltable">

|                   |            |                                              |
|:------------------|:-----------|:---------------------------------------------|
| Constant          | Type       | Usage                                        |
| SPISRAM\_CAPACITY | Long value | Use to determine the size of the SRAM device |

</div>

<span class="strong">**Examples**</span>

``` screen
    #include <uno_mega328p.h>
    #option explicit

   ' USART settings
    #define USART_BAUD_RATE 57600
    #define USART_DELAY 0 ms
    #define USART_BLOCKING
    #define USART_TX_BLOCKING


    'SD card attached to SPI bus as follows:
    '
    'UNO:    MOSI - pin 11, MISO - pin 12, CLK - pin 13, CS - pin 4 (CS pin can be changed) and pin #10 (SS) must be an output
    'Mega:   MOSI - pin 51, MISO - pin 50, CLK - pin 52, CS - pin 4 (CS pin can be changed) and pin #52 (SS) must be an output
    'Leonardo: Connect to hardware SPI via the ICSP header

    #define SPISRAM_CS      DIGITAL_5     'Also known as SS, or Slave Select
    #define SPISRAM_SCK      DIGITAL_13    'Also known as CLK
    #define SPISRAM_DO      DIGITAL_11    'Also known as MOSI
    #define SPISRAM_DI      DIGITAL_12    'Also known as MISO

    #define SPISRAM_HARDWARESPI
    #define SPISRAM_TYPE     SRAM_23LC1024

    #define HWSPIMode MASTERULTRAFAST       'MASTERSLOW | MASTER | MASTERFAST | MASTERULTRAFAST for specific AVRs only. Defaults to MASTERFAST


  '********************************************************************************

  'Main program

    'Wait 2 seconds to open the serial terminal
    wait 2 s

    HSerPrintCRLF 2
    HSerPrint "Writing..."
    HSerPrintCRLF
    For SRAM_location=0 to SPISRAM_CAPACITY - 1
     SRAMWrite ( [long]SRAM_location, SRAM_location and 255 )
    Next


    dim spirambyteread as Byte
    spirambyteread = 11
    HSerPrintCRLF 2
    dim SRAM_location as long
    HSerPrint "Reading..."
    HSerPrintCRLF
    For SRAM_location=0 to SPISRAM_CAPACITY - 1
     'choose one....
     'SRAMread ( SRAM_location, spirambyteread )
    'or, as a function
     spirambyteread = SRAMread ( SRAM_location )

     if spirambyteread = ( SRAM_location and 255 ) then
       HSerPrint hex(spirambyteread)
     else
       HSerPrint "**"
     end if
     HSerPrint ":"
    Next
    HSerPrintCRLF
    HSerPrint "Wait..."
    HSerPrintCRLF
    Wait 2 s

    HSerPrint "Rewriting to 0x00 ..."
    HSerPrintCRLF
    For SRAM_location=0 to SPISRAM_CAPACITY - 1
     SRAMWrite ( [long]SRAM_location, 0 )
    Next

    Dim errorcount as long
    errorcount = 0
    For SRAM_location=0 to SPISRAM_CAPACITY - 1
     SRAMRead ( SRAM_location, spirambyteread )
     if spirambyteread <> 0 then
       errorcount++
     end if
    Next
    HSerPrint "Error Count (should be 0) = "
    HSerPrint errorcount
    HSerPrintCRLF
    HSerPrint "End..."
    HSerPrintCRLF
    end
```

or, for a PIC with PPS

``` screen
    'Chip Settings.
   #chip 18F47k42, 64
   #config MCLRE = ON
   #option explicit


   'PPS Tool version: 0.0.5.27
   'PinManager data: v1.78
   'Generated for 18F47K42
   '
   'Template comment at the start of the config file
   '
   #startup InitPPS, 85
   #define PPSToolPart 18F47K42

   Sub InitPPS
      'This has been added to turn off PPS SPI when in SPI software mode
       #ifdef SPISRAM_HARDWARESPI
         'Module: SPI1
         RC3PPS = 0x001E  'SCK1 > RC3
         SPI1SCKPPS = 0x0013  'RC3 > SCK1 (bi-directional)
         RC5PPS = 0x001F  'SDO1 > RC5
         SPI1SDIPPS = 0x0014  'RC4 > SDI1
         'Module: UART pin directions
       #endif
       'Module: UART pin directions
       Dir PORTC.6 Out  ' Make TX1 pin an output
       'Module: UART1
       RC6PPS = 0x0013  'TX1 > RC6
   End Sub
   'Template comment at the end of the config file


   ' USART settings
   #define USART_BAUD_RATE 57600
   #define USART_DELAY 0 ms
   #define USART_BLOCKING
   #define USART_TX_BLOCKING

   #define SPISRAM_CS      Porta.2      'Also known as SS, or Slave Select
   #define SPISRAM_SCK      Portc.3      'Also known as CLK
   #define SPISRAM_DO      Portc.5      'Also known as MOSI
   #define SPISRAM_DI      Portc.4      'Also known as MISO

   #define SPISRAM_HARDWARESPI
   #define SPISRAM_TYPE     SRAM_23LC1024

   '********************************************************************************

   'Main program

   'Wait 2 seconds to open the serial terminal
   wait 2 s
   dim sizeofSPIRAM as long
   sizeofSPIRAM = SPISRAM_CAPACITY
   HSerPrintCRLF 2
   HSerPrint "Writing...SPISRAM_CAPACITY = 0x"
   HSerPrint hex(sizeofSPIRAM_U)
   HSerPrint hex(sizeofSPIRAM_H)
   HSerPrint hex(sizeofSPIRAM)
   HSerPrintCRLF
   wait 100 ms

   dim SRAM_location as long
   For SRAM_location=0 to SPISRAM_CAPACITY - 1
    SRAMWrite ( [long]SRAM_location, SRAM_location and 255 )
   Next


   dim spirambyteread as Byte
   spirambyteread = 11 'could be any number....
   HSerPrintCRLF 2

   HSerPrint "Reading..."
   HSerPrintCRLF
   For SRAM_location=0 to SPISRAM_CAPACITY - 1
    'choose one....
    'SRAMRead ( SRAM_location, spirambyteread )
   'or, as a function
    spirambyteread = SRAMRead ( SRAM_location )

    if spirambyteread = ( SRAM_location and 255 ) then
      HSerPrint hex(spirambyteread)
    else
      HSerPrint "**"
    end if
    HSerPrint ":"
   Next
   HSerPrintCRLF
   HSerPrint "Wait..."
   HSerPrintCRLF
   Wait 2 s

   HSerPrint "Rewriting to 0x00 ..."
   HSerPrintCRLF
   For SRAM_location=0 to SPISRAM_CAPACITY - 1
    SRAMWrite ( [long]SRAM_location, 0 )
   Next

   Dim errorcount as long
   errorcount = 0
   For SRAM_location=0 to SPISRAM_CAPACITY - 1
    SRAMRead ( SRAM_location, spirambyteread )
    if spirambyteread <> 0 then
      errorcount++
    end if
   Next
   HSerPrint "Error Count (should be 0) = "
   HSerPrint errorcount
   HSerPrintCRLF
   HSerPrint "End..."
   HSerPrintCRLF

   do

   loop
```

<span class="strong">**For more help, see
<a href="sramread" class="link" title="SRAMRead">SRAMRead</a> or
<a href="sramwrite" class="link" title="SRAMWrite">SRAMWrite</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SSD1306 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_sh1106_controllers.html" title="SH1106 Controllers"><link rel="next" href="_ssd1331_controllers.html" title="SSD1331 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_ssd1306_controllers"></a>SSD1306 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the SSD1306 graphics controller.</p><p>The SSD1306 is a single-chip CMOS OLED/PLED driver with controller for organic / polymer light emitting diode dot-matrix graphic display system. It consists of 128 segments and 64 commons. This IC is designed for Common Cathode type OLED panel.</p><p>The SSD1306 embeds with contrast control, display RAM and oscillator, which reduces the number of external components and power consumption. It has 256-step brightness control. Data/Commands are sent from general MCU through the hardware selectable 6800/8000 series compatible Parallel Interface, I2C interface or Serial Peripheral Interface. It is suitable for many compact portable applications, such as mobile phone sub-display, MP3 player and calculator, etc.</p><p>The GCBASIC constants shown below control the configuration of the SSD1306 controller. &nbsp;&nbsp;&nbsp;GCBASIC supports SPI and I2C hardware &amp; software connectivity  - this is shown in the tables below.</p><p>To use the SSD1306 driver simply include the following in your user code.  This will initialise the driver.</p><p>The SSD1306 library supports 128 * 64 pixels or 128 * 32 pixels.  The default is 128 * 64 pixels.</p><p>The SSD1306 is a monochrome device.</p><p>The SSD1306 can operate in three modes. Full GLCD mode, Low Memory GLCD mode or Text/JPG mode the full GLCD mode requires a minimum of 1k bytes or 512 bytes for the 128x64 and the 128x32 devices respectively in Full GLCD mode.  For microcontrollers with limited memory the third mode of operation - Text mode.  These can be selected by setting the correct constant.</p><p>To use the SSD1306 drivers simply include one of the following configuration.  You can select Full Mode GLCD, Low Memory Mode GLCD or Text mode these require 1024, 128 or 0 byte GLCD buffer respectively - you microcontroller requires sufficient RAM to support the selected mode of GLCD operation.</p><pre class="screen">    'An I2C configuration
    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306
    #define GLCD_I2C_Address 0x78
    '#define GLCD_TYPE_SH1306_LOWMEMORY_GLCD_MODE       'select Low Memory mode of operation
    '#define GLCD_TYPE_SH1306_CHARACTER_MODE_ONLY       'select Text mode of operation


    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master</pre><p>or,</p><pre class="screen">    'An SPI configuration'
    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306

    ; ----- Define Hardware settings
    #define S4Wire_DATA

    #define MOSI_SSD1306 PortB.1
    #define SCK_SSD1306  PortB.2
    #define DC_SSD1306   PortB.3
    #define CS_SSD1306   PortB.4
    #define RES_SSD1306  PortB.5</pre><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_SSD1306</code></p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_I2C_Address</code></p></td><td align="left" valign="top"><p>I2C address of the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr></tbody></table></div><p>The GCBASIC constants for SPI/S4Wire control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_SSD1306</code></p></td><td align="left" valign="top"><p>Required to support 128 * 64 pixels.  Mutualy exclusive to GLCD_TYPE_SSD1306_32</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_SSD1306_32</code></p></td><td align="left" valign="top"><p>Required to support 128 * 32 pixels.  Mutualy exclusive to GLCD_TYPE_SSD1306</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">S4Wire_Data</code></p></td><td align="left" valign="top"><p>4 wire SPI Mode</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">MOSI_SSD1306</code></p></td><td align="left" valign="top"><p>Specifies output pin connected to serial data in D1 pin</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SCK_SSD1306</code></p></td><td align="left" valign="top"><p>Specifies output pin connected to serial clock D0 pin</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">DC_SSD1306</code></p></td><td align="left" valign="top"><p>Specifies output pin connected to data control DC pin</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CS_SSD1306</code></p></td><td align="left" valign="top"><p>Specifies output pin connected to chip select CS pin</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">RES_SSD1306</code></p></td><td align="left" valign="top"><p>Specifies output pin connected to reset RES pin</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">128</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">64</code> or <code class="literal">32</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_PROTECTOVERRUN</code></p></td><td align="left" valign="top"><p>Define this constant to restrict pixel operations with the pixel limits</p></td><td align="left" valign="top"><p>Not defined</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Rotate GCLD Constants</strong></span></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDYFLIP</code></p></td><td align="left" valign="top"><p>Define this constant to rotate the GLCD  display</p></td><td align="left" valign="top"><p>Not defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDXFLIP</code></p></td><td align="left" valign="top"><p>Define this constant to rotate the GLCD  display</p></td><td align="left" valign="top"><p>Not defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDXYFLIP</code></p></td><td align="left" valign="top"><p>Define this constant to rotate the GLCD  display</p></td><td align="left" valign="top"><p>Not defined</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Memory Management Constants</strong></span></p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_SSD1306_CHARACTER_MODE_ONLY</code></p></td><td align="left" valign="top"><p>Specifies that the display controller will operate in text mode and BMP
draw mode only.<br>
For microcontrollers with low RAM this will be set be
default.<br>
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <code class="literal">GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE</code></p></td><td align="left" valign="top"><p>Optional</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE</code></p></td><td align="left" valign="top"><p>Specifies that the display controller will operate in Low Memory mode.</p></td><td align="left" valign="top"><p>Optional</p></td></tr></tbody></table></div><p>The GCBASIC variables for control display characteristics are shown in the table below.
These variables control the user definable parameters of a specific GLCD.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Variable</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Type</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_OLED_FONT</code></p></td><td align="left" valign="top"><p>Specifies the use of the optional OLED font set.
</p><p>The GLCDFNTDEFAULTSIZE can be set to 1 or 2 only.
</p><p><code class="literal">GLCDFNTDEFAULTSIZE=  1</code>.   A small 8 height pixel font with variable width.
<code class="literal">GLCDFNTDEFAULTSIZE=  2</code>.   A larger 10 width * 16 height pixel font.</p></td><td align="left" valign="top"><p>Optional</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDBACKGROUND</code></p></td><td align="left" valign="top"><p>GLCD background state.</p></td><td align="left" valign="top"><p>A monochrome value.<br>
For mono GLCDs the default is White or 0x0001.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFOREGROUND</code></p></td><td align="left" valign="top"><p>Color of GLCD foreground.</p></td><td align="left" valign="top"><p>A monochrome value.<br>
For mono GLCDs the default is non-white or 0x0000.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFONTWIDTH</code></p></td><td align="left" valign="top"><p>Width of the current GLCD font.</p></td><td align="left" valign="top"><p>Default is 6 pixels.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFNTDEFAULT</code></p></td><td align="left" valign="top"><p>Size of the current GLCD font.</p></td><td align="left" valign="top"><p>Default is 0.
</p><p></p><p>This equates to the standard GCB font set.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFNTDEFAULTSIZE</code></p></td><td align="left" valign="top"><p>Size of the current GLCD font.</p></td><td align="left" valign="top"><p>Default is 1.
</p><p></p><p>This equates to the 8 pixel high.</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the
table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte (LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Open_PageTransaction</code></p></td><td align="left" valign="top"><p>Commence a series of GLCD commands when in low memory mode.  Must be followed a  <code class="literal">GLCD_Close_PageTransaction</code> command.</p></td><td align="left" valign="top"><p><code class="literal">GLCD_Close_PageTransaction 0, 7</code> where 0 and 7 are the range of pages to be updated</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Close_PageTransaction</code></p></td><td align="left" valign="top"><p>Commence a series of GLCD commands when in low memory mode.  Must follow a <code class="literal">GLCD_Open_PageTransaction</code> command.</p></td><td align="left" valign="top">&nbsp;</td></tr></tbody></table></div><p>The GCBASIC specific commands for this GLCD are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">Stopscroll_SSD1306</code></p></td><td align="left" valign="top"><p>Stops all scrolling</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Startscrollright_SSD1306 ( start , stop [,scrollspeed] )</code></p></td><td align="left" valign="top"><p>Activate a right handed scroll for rows start through stop
Hint, the display is 16 rows tall. To scroll the whole display, execute:<br>
<code class="literal">startscrollright_SSD1306(0x00, 0x0F)</code><br>
Parameters are <code class="literal">Start row</code>, <code class="literal">End row</code>, optionally <code class="literal">Scrollspeed</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Startscrollleft_SSD1306 ( start , stop [,scrollspeed] )</code></p></td><td align="left" valign="top"><p>Activate a left handed scroll for rows start through stop
Hint, the display is 16 rows tall. To scroll the whole display, execute:<br>
<code class="literal">startscrollleft_SSD1306(0x00, 0x0F)</code><br>
Parameters are <code class="literal">Start row</code>, <code class="literal">End row</code>, optionally <code class="literal">Scrollspeed</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Startscrolldiagright_SSD1306 ( start , stop [,scrollspeed] )</code></p></td><td align="left" valign="top"><p>Activate a diagright handed scroll for rows start through stop
Hint, the display is 16 rows tall. To scroll the whole display, execute:<br>
<code class="literal">startscrolldiagright_SSD1306(0x00, 0x0F)</code><br>
Parameters are <code class="literal">Start row</code>, <code class="literal">End row</code>, optionally <code class="literal">Scrollspeed</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Startscrolldiagleft_SSD1306 ( start , stop [,scrollspeed] )</code></p></td><td align="left" valign="top"><p>Activate a diagleft handed scroll for rows start through stop
Hint, the display is 16 rows tall. To scroll the whole display, execute:<br>
<code class="literal">startscrolldiagleft_SSD1306(0x00, 0x0F)</code><br>
Parameters are <code class="literal">Start row</code>,<code class="literal">End row</code>, optionally <code class="literal">Scrollspeed</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDSetContrast ( dim_state )</code></p></td><td align="left" valign="top"><p>Sets the constrast between 0 and 255. The contrast increases as the value increases.<br>
Parameter is dim value</p></td></tr></tbody></table></div><p>For a SSD1306 datasheet, please refer <a class="link" href="http://gcbasic.sourceforge.net/library/DISPLAY/SSD1306.pdf" target="_top">here</a>.</p><p>This example shows how to drive a SSD1306 based Graphic I2C LCD module with the built in commands of GCBASIC using Full Mode GLCD</p><pre class="screen">    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x78

    dim outString as string * 21

    GLCDCLS
    GLCDPrint 0, 0, "GCBASIC"
    GLCDPrint (0, 16, "Anobium 2021")

    wait 3 s
    GLCDCLS

    ' Prepare the static components of the screen
    GLCDPrint ( 0,   0, "PrintStr") ; Print some text
    GLCDPrint ( 64,  0, "@")
    ; Print some more text
    GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
    GLCDPrint ( 86, 0, "Mhz") ; Print some text
    GLCDDrawString( 0,8,"DrawStr") ; Draw some text
    box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    Circle( 44,41,15) ; Draw a circle
    line 64,31,0,31 ; Draw a line

    DO forever
       for CCount = 31 to 127
            GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
            GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
            GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
            GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
            GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

            GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
            GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

            box (46,9,56,19) ; Draw a Box
            GLCDDrawChar(48, 9, CCount ) ; Draw a character
            outString = str( CCount ) ; Prepare a string
            GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

            filledbox 3,43,11,51, wordNumber ; Draw a filled box

            FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
            line 0,63,64,31 ; Draw a line

            ; Do some simple maths
            longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
        NEXT
    LOOP
    end</pre><p><br>
<br>
This example shows how to drive a SSD1306 based Graphic I2C LCD module with the built in commands of GCBASIC using Low Memory Mode GLCD.
<br>
Note the use of <code class="literal">GLCD_Open_PageTransaction</code> and <code class="literal">GLCD_Close_PageTransaction</code> to support the Low Memory Mode of operation and the contraining of all GLCD commands with the transaction commands.  The use Low Memory Mode GLCD the two defines <code class="literal">GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE</code> and <code class="literal">GLCD_TYPE_SSD1306_CHARACTER_MODE_ONLY</code> are included in the user program.
<br></p><pre class="screen">    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x78
    #define GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_SSD1306_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS

    'To clarify - page udpates
    '0,7 correspond with the Text Lines from 0 to 7 on a 64 Pixel Display
    'In this example Code would be GLCD_Open_PageTransaction 0,1 been enough
    'But it is allowed to use GLCD_Open_PageTransaction 0,7 to show the full screen update
    GLCD_Open_PageTransaction 0,7
       GLCDPrint 0, 0, "GCBASIC"
       GLCDPrint (0, 16, "Anobium 2021")
    GLCD_Close_PageTransaction
    wait 3 s
    DO forever

      for CCount = 31 to 127

        outString = str( CCount ) ; Prepare a string

        GLCD_Open_PageTransaction 0,7

           ' Prepare the static components of the screen
           GLCDPrint ( 0,   0, "PrintStr") ; Print some text
           GLCDPrint ( 64,  0, "@")
           ; Print some more text
           GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
           GLCDPrint ( 86, 0, "Mhz") ; Print some text
           GLCDDrawString( 0,8,"DrawStr") ; Draw some text
           box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           Circle( 44,41,15) ; Draw a circle
           line 64,31,0,31 ; Draw a line

           GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
           GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
           GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
           GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
           GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

           GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
           GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

           box (46,8,56,19) ; Draw a Box
           GLCDDrawChar(48, 9, CCount ) ; Draw a character

           GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

           filledbox 3,43,11,51, wordNumber ; Draw a filled box

           FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
           line 0,63,64,31 ; Draw a line

        GLCD_Close_PageTransaction

        ; Do some simple maths
        longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
       NEXT
    LOOP
    end</pre><p><br>
This example shows how to drive a SSD1306 based Graphic SPI LCD module with the built in commands of GCBASIC.
<br></p><pre class="screen">    'Chip model
    #chip mega328p, 16
    #include &lt;glcd.h&gt;

    'Defines for a 7 pin SPI module
    'RES pin is pulsed low in glcd_SSD1306.h for proper startup
    #define MOSI_SSD1306 PortB.1
    #define SCK_SSD1306 PortB.2
    #define DC_SSD1306 PortB.3
    #define CS_SSD1306 PortB.4
    #define RES_SSD1306 PortB.5
    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306   'for 128 * 64 pixels support
    #define S4Wire_DATA

    dim longnumber as Long
    longnumber = 123456
    dim wordnumber as word
    wordnumber = 62535
    dim bytenumber as Byte
    bytenumber =255

    #define led PortB.0
    dir led out


    Do
         SET led ON
         wait 1 s
         SET led OFF

        GLCDCLS
        GLCDPrint (30, 0, "Hello World!")
        Circle (18,24,10)
        FilledCircle (48,24,10)
        Box (70,14,90,34)
        FilledBox (106,14,126,34)
        GLCDDrawString (32,35,"Draw String")
        GLCDPrint (0,46,longnumber)
        GLCDPrint (94,46,wordnumber)
        GLCDPrint (52,55,bytenumber)
        Line (0,40,127,63)
        Line (0,63,127,40)
        wait 3 s

    Loop</pre><p><br>
This example shows how to drive a SSD1306 based Graphic I2C LCD module with 128 * 32 pixel support.
<br></p><pre class="screen">    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306_32  'for 128 * 32 pixels support
    #define GLCD_I2C_Address 0x78

    GLCDCLS
    GLCDPrint 0, 0, "GCBASIC"
    GLCDPrint (0, 16, "Anobium 2021")</pre><p><br>
This example shows how to drive a SSD1306 with the OLED fonts.  Note the use of the <code class="literal">GLCDfntDefaultSize</code> to select the size of the OLED font in use.
<br></p><pre class="screen">    #define GLCD_OLED_FONT

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  SSD1306" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</pre><p><br>
This example shows how to set the SSD1306 OLED the lowest constrast level by using a OLED chip specific command.
<br></p><pre class="screen">    'Use the GCB command to set the lowest constrast
    GLCDSetContrast ( 0 )
      'Then, use the Write command to set the output between 0 and 255
      Write_Command_SSD1306(SSD1306_SETVCOMDETECT)
      Write_Command_SSD1306(15)      ' 0x40 default, to lower the contrast, put 0 for lowest and 255 for highest.


    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  SSD1306" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</pre><p><br></p><p>This example shows how to disable the large OLED Fontset.  This disables the font to reduce memory usage.</p><p>When the large OLED fontset is disabled every character will be shown as a block character.
<br></p><pre class="screen">    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts
    #define GLCD_Disable_OLED_FONT2       'The constant to disable the large fontset.

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  SSD1306" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</pre><p><br></p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="ssd1306_controllers"></span>SSD1306 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the SSD1306 graphics
controller.

The SSD1306 is a single-chip CMOS OLED/PLED driver with controller for
organic / polymer light emitting diode dot-matrix graphic display
system. It consists of 128 segments and 64 commons. This IC is designed
for Common Cathode type OLED panel.

The SSD1306 embeds with contrast control, display RAM and oscillator,
which reduces the number of external components and power consumption.
It has 256-step brightness control. Data/Commands are sent from general
MCU through the hardware selectable 6800/8000 series compatible Parallel
Interface, I2C interface or Serial Peripheral Interface. It is suitable
for many compact portable applications, such as mobile phone
sub-display, MP3 player and calculator, etc.

The GCBASIC constants shown below control the configuration of the
SSD1306 controller.    GCBASIC supports SPI and I2C hardware & software
connectivity - this is shown in the tables below.

To use the SSD1306 driver simply include the following in your user
code. This will initialise the driver.

The SSD1306 library supports 128 \* 64 pixels or 128 \* 32 pixels. The
default is 128 \* 64 pixels.

The SSD1306 is a monochrome device.

The SSD1306 can operate in three modes. Full GLCD mode, Low Memory GLCD
mode or Text/JPG mode the full GLCD mode requires a minimum of 1k bytes
or 512 bytes for the 128x64 and the 128x32 devices respectively in Full
GLCD mode. For microcontrollers with limited memory the third mode of
operation - Text mode. These can be selected by setting the correct
constant.

To use the SSD1306 drivers simply include one of the following
configuration. You can select Full Mode GLCD, Low Memory Mode GLCD or
Text mode these require 1024, 128 or 0 byte GLCD buffer respectively -
you microcontroller requires sufficient RAM to support the selected mode
of GLCD operation.

``` screen
    'An I2C configuration
    #include <glcd.h>

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306
    #define GLCD_I2C_Address 0x78
    '#define GLCD_TYPE_SH1306_LOWMEMORY_GLCD_MODE       'select Low Memory mode of operation
    '#define GLCD_TYPE_SH1306_CHARACTER_MODE_ONLY       'select Text mode of operation


    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master
```

or,

``` screen
    'An SPI configuration'
    #include <glcd.h>

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306

    ; ----- Define Hardware settings
    #define S4Wire_DATA

    #define MOSI_SSD1306 PortB.1
    #define SCK_SSD1306  PortB.2
    #define DC_SSD1306   PortB.3
    #define CS_SSD1306   PortB.4
    #define RES_SSD1306  PortB.5
```

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

| <span class="strong">**Constants**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Options**</span> |
|:------------------------------------------|:-----------------------------------------|:----------------------------------------|
| `GLCD_TYPE`                               | `GLCD_TYPE_SSD1306`                      | Required                                |
| `GLCD_I2C_Address`                        | I2C address of the GLCD.                 | Required                                |

</div>

The GCBASIC constants for SPI/S4Wire control display characteristics are
shown in the table below.

<div class="informaltable">

| <span class="strong">**Constants**</span> | <span class="strong">**Controls**</span>                | <span class="strong">**Options**</span>                                            |
|:------------------------------------------|:--------------------------------------------------------|:-----------------------------------------------------------------------------------|
| `GLCD_TYPE`                               | `GLCD_TYPE_SSD1306`                                     | Required to support 128 \* 64 pixels. Mutualy exclusive to GLCD\_TYPE\_SSD1306\_32 |
| `GLCD_TYPE`                               | `GLCD_TYPE_SSD1306_32`                                  | Required to support 128 \* 32 pixels. Mutualy exclusive to GLCD\_TYPE\_SSD1306     |
| `S4Wire_Data`                             | 4 wire SPI Mode                                         | Required                                                                           |
| `MOSI_SSD1306`                            | Specifies output pin connected to serial data in D1 pin | Must be defined                                                                    |
| `SCK_SSD1306`                             | Specifies output pin connected to serial clock D0 pin   | Must be defined                                                                    |
| `DC_SSD1306`                              | Specifies output pin connected to data control DC pin   | Must be defined                                                                    |
| `CS_SSD1306`                              | Specifies output pin connected to chip select CS pin    | Must be defined                                                                    |
| `RES_SSD1306`                             | Specifies output pin connected to reset RES pin         | Must be defined                                                                    |

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">128</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">64</code> or <code class="literal">32</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_PROTECTOVERRUN</code></p></td>
<td style="text-align: left;"><p>Define this constant to restrict pixel operations with the pixel limits</p></td>
<td style="text-align: left;"><p>Not defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="strong"><strong>Rotate GCLD Constants</strong></span></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDYFLIP</code></p></td>
<td style="text-align: left;"><p>Define this constant to rotate the GLCD display</p></td>
<td style="text-align: left;"><p>Not defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDXFLIP</code></p></td>
<td style="text-align: left;"><p>Define this constant to rotate the GLCD display</p></td>
<td style="text-align: left;"><p>Not defined</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDXYFLIP</code></p></td>
<td style="text-align: left;"><p>Define this constant to rotate the GLCD display</p></td>
<td style="text-align: left;"><p>Not defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="strong"><strong>Memory Management Constants</strong></span></p></td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_SSD1306_CHARACTER_MODE_ONLY</code></p></td>
<td style="text-align: left;"><p>Specifies that the display controller will operate in text mode and BMP draw mode only.<br />
For microcontrollers with low RAM this will be set be default.<br />
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <code class="literal">GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE</code></p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE</code></p></td>
<td style="text-align: left;"><p>Specifies that the display controller will operate in Low Memory mode.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC variables for control display characteristics are shown in
the table below. These variables control the user definable parameters
of a specific GLCD.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Variable</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Purpose</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Type</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_OLED_FONT</code></p></td>
<td style="text-align: left;"><p>Specifies the use of the optional OLED font set.</p>
<p>The GLCDFNTDEFAULTSIZE can be set to 1 or 2 only.</p>
<p><code class="literal">GLCDFNTDEFAULTSIZE=  1</code>. A small 8 height pixel font with variable width. <code class="literal">GLCDFNTDEFAULTSIZE=  2</code>. A larger 10 width * 16 height pixel font.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDBACKGROUND</code></p></td>
<td style="text-align: left;"><p>GLCD background state.</p></td>
<td style="text-align: left;"><p>A monochrome value.<br />
For mono GLCDs the default is White or 0x0001.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFOREGROUND</code></p></td>
<td style="text-align: left;"><p>Color of GLCD foreground.</p></td>
<td style="text-align: left;"><p>A monochrome value.<br />
For mono GLCDs the default is non-white or 0x0000.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDFONTWIDTH</code></p></td>
<td style="text-align: left;"><p>Width of the current GLCD font.</p></td>
<td style="text-align: left;"><p>Default is 6 pixels.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFNTDEFAULT</code></p></td>
<td style="text-align: left;"><p>Size of the current GLCD font.</p></td>
<td style="text-align: left;"><p>Default is 0.</p>
<p>This equates to the standard GCB font set.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDFNTDEFAULTSIZE</code></p></td>
<td style="text-align: left;"><p>Size of the current GLCD font.</p></td>
<td style="text-align: left;"><p>Default is 1.</p>
<p>This equates to the 8 pixel high.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**Purpose**</span>                                                                              | <span class="strong">**Example**</span>                                                        |
|:----------------------------------------|:---------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------|
| `GLCDCLS`                               | Clear screen of GLCD                                                                                                 | `GLCDCLS`                                                                                      |
| `GLCDPrint`                             | Print string of characters on GLCD using GCB font set                                                                | `GLCDPrint( Xposition, Yposition, Stringvariable )`                                            |
| `GLCDDrawChar`                          | Print character on GLCD using GCB font set                                                                           | `GLCDDrawChar( Xposition, Yposition, CharCode )`                                               |
| `GLCDDrawString`                        | Print characters on GLCD using GCB font set                                                                          | `GLCDDrawString( Xposition, Yposition, Stringvariable )`                                       |
| `Box`                                   | Draw a box on the GLCD to a specific size                                                                            | `Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )`   |
| `FilledBox`                             | Draw a box on the GLCD to a specific size that is filled with the foreground colour.                                 | `FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )` |
| `Line`                                  | Draw a line on the GLCD to a specific length that is filled with the specific attribute.                             | `Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`     |
| `PSet`                                  | Set a pixel on the GLCD at a specific position that is set with the specific attribute.                              | `PSet(Xposition, Yposition, Pixel Colour 0 or 1)`                                              |
| `GLCDWriteByte`                         | Set a byte value to the controller, see the datasheet for usage.                                                     | `GLCDWriteByte (LCDByte)`                                                                      |
| `GLCDReadByte`                          | Read a byte value from the controller, see the datasheet for usage.                                                  | `bytevariable = GLCDReadByte`                                                                  |
| `GLCD_Open_PageTransaction`             | Commence a series of GLCD commands when in low memory mode. Must be followed a `GLCD_Close_PageTransaction` command. | `GLCD_Close_PageTransaction 0, 7` where 0 and 7 are the range of pages to be updated           |
| `GLCD_Close_PageTransaction`            | Commence a series of GLCD commands when in low memory mode. Must follow a `GLCD_Open_PageTransaction` command.       |                                                                                                |

</div>

The GCBASIC specific commands for this GLCD are shown in the table
below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Stopscroll_SSD1306</code></p></td>
<td style="text-align: left;"><p>Stops all scrolling</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">Startscrollright_SSD1306 ( start , stop [,scrollspeed] )</code></p></td>
<td style="text-align: left;"><p>Activate a right handed scroll for rows start through stop Hint, the display is 16 rows tall. To scroll the whole display, execute:<br />
<code class="literal">startscrollright_SSD1306(0x00, 0x0F)</code><br />
Parameters are <code class="literal">Start row</code>, <code class="literal">End row</code>, optionally <code class="literal">Scrollspeed</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Startscrollleft_SSD1306 ( start , stop [,scrollspeed] )</code></p></td>
<td style="text-align: left;"><p>Activate a left handed scroll for rows start through stop Hint, the display is 16 rows tall. To scroll the whole display, execute:<br />
<code class="literal">startscrollleft_SSD1306(0x00, 0x0F)</code><br />
Parameters are <code class="literal">Start row</code>, <code class="literal">End row</code>, optionally <code class="literal">Scrollspeed</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">Startscrolldiagright_SSD1306 ( start , stop [,scrollspeed] )</code></p></td>
<td style="text-align: left;"><p>Activate a diagright handed scroll for rows start through stop Hint, the display is 16 rows tall. To scroll the whole display, execute:<br />
<code class="literal">startscrolldiagright_SSD1306(0x00, 0x0F)</code><br />
Parameters are <code class="literal">Start row</code>, <code class="literal">End row</code>, optionally <code class="literal">Scrollspeed</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Startscrolldiagleft_SSD1306 ( start , stop [,scrollspeed] )</code></p></td>
<td style="text-align: left;"><p>Activate a diagleft handed scroll for rows start through stop Hint, the display is 16 rows tall. To scroll the whole display, execute:<br />
<code class="literal">startscrolldiagleft_SSD1306(0x00, 0x0F)</code><br />
Parameters are <code class="literal">Start row</code>,<code class="literal">End row</code>, optionally <code class="literal">Scrollspeed</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDSetContrast ( dim_state )</code></p></td>
<td style="text-align: left;"><p>Sets the constrast between 0 and 255. The contrast increases as the value increases.<br />
Parameter is dim value</p></td>
</tr>
</tbody>
</table>

</div>

For a SSD1306 datasheet, please refer
<a href="http://gcbasic.sourceforge.net/library/DISPLAY/SSD1306.pdf" class="link">here</a>.

This example shows how to drive a SSD1306 based Graphic I2C LCD module
with the built in commands of GCBASIC using Full Mode GLCD

``` screen
    #chip mega328p,16
    #include <glcd.h>

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x78

    dim outString as string * 21

    GLCDCLS
    GLCDPrint 0, 0, "GCBASIC"
    GLCDPrint (0, 16, "Anobium 2021")

    wait 3 s
    GLCDCLS

    ' Prepare the static components of the screen
    GLCDPrint ( 0,   0, "PrintStr") ; Print some text
    GLCDPrint ( 64,  0, "@")
    ; Print some more text
    GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
    GLCDPrint ( 86, 0, "Mhz") ; Print some text
    GLCDDrawString( 0,8,"DrawStr") ; Draw some text
    box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    Circle( 44,41,15) ; Draw a circle
    line 64,31,0,31 ; Draw a line

    DO forever
       for CCount = 31 to 127
            GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
            GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
            GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
            GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
            GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

            GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
            GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

            box (46,9,56,19) ; Draw a Box
            GLCDDrawChar(48, 9, CCount ) ; Draw a character
            outString = str( CCount ) ; Prepare a string
            GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

            filledbox 3,43,11,51, wordNumber ; Draw a filled box

            FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
            line 0,63,64,31 ; Draw a line

            ; Do some simple maths
            longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
        NEXT
    LOOP
    end
```

  
  
This example shows how to drive a SSD1306 based Graphic I2C LCD module
with the built in commands of GCBASIC using Low Memory Mode GLCD.  
Note the use of `GLCD_Open_PageTransaction` and
`GLCD_Close_PageTransaction` to support the Low Memory Mode of operation
and the contraining of all GLCD commands with the transaction commands.
The use Low Memory Mode GLCD the two defines
`GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE` and
`GLCD_TYPE_SSD1306_CHARACTER_MODE_ONLY` are included in the user
program.  

``` screen
    #chip mega328p,16
    #include <glcd.h>

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x78
    #define GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_SSD1306_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS

    'To clarify - page udpates
    '0,7 correspond with the Text Lines from 0 to 7 on a 64 Pixel Display
    'In this example Code would be GLCD_Open_PageTransaction 0,1 been enough
    'But it is allowed to use GLCD_Open_PageTransaction 0,7 to show the full screen update
    GLCD_Open_PageTransaction 0,7
       GLCDPrint 0, 0, "GCBASIC"
       GLCDPrint (0, 16, "Anobium 2021")
    GLCD_Close_PageTransaction
    wait 3 s
    DO forever

      for CCount = 31 to 127

        outString = str( CCount ) ; Prepare a string

        GLCD_Open_PageTransaction 0,7

           ' Prepare the static components of the screen
           GLCDPrint ( 0,   0, "PrintStr") ; Print some text
           GLCDPrint ( 64,  0, "@")
           ; Print some more text
           GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
           GLCDPrint ( 86, 0, "Mhz") ; Print some text
           GLCDDrawString( 0,8,"DrawStr") ; Draw some text
           box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           Circle( 44,41,15) ; Draw a circle
           line 64,31,0,31 ; Draw a line

           GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
           GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
           GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
           GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
           GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

           GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
           GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

           box (46,8,56,19) ; Draw a Box
           GLCDDrawChar(48, 9, CCount ) ; Draw a character

           GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

           filledbox 3,43,11,51, wordNumber ; Draw a filled box

           FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
           line 0,63,64,31 ; Draw a line

        GLCD_Close_PageTransaction

        ; Do some simple maths
        longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
       NEXT
    LOOP
    end
```

  
This example shows how to drive a SSD1306 based Graphic SPI LCD module
with the built in commands of GCBASIC.  

``` screen
    'Chip model
    #chip mega328p, 16
    #include <glcd.h>

    'Defines for a 7 pin SPI module
    'RES pin is pulsed low in glcd_SSD1306.h for proper startup
    #define MOSI_SSD1306 PortB.1
    #define SCK_SSD1306 PortB.2
    #define DC_SSD1306 PortB.3
    #define CS_SSD1306 PortB.4
    #define RES_SSD1306 PortB.5
    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306   'for 128 * 64 pixels support
    #define S4Wire_DATA

    dim longnumber as Long
    longnumber = 123456
    dim wordnumber as word
    wordnumber = 62535
    dim bytenumber as Byte
    bytenumber =255

    #define led PortB.0
    dir led out


    Do
         SET led ON
         wait 1 s
         SET led OFF

        GLCDCLS
        GLCDPrint (30, 0, "Hello World!")
        Circle (18,24,10)
        FilledCircle (48,24,10)
        Box (70,14,90,34)
        FilledBox (106,14,126,34)
        GLCDDrawString (32,35,"Draw String")
        GLCDPrint (0,46,longnumber)
        GLCDPrint (94,46,wordnumber)
        GLCDPrint (52,55,bytenumber)
        Line (0,40,127,63)
        Line (0,63,127,40)
        wait 3 s

    Loop
```

  
This example shows how to drive a SSD1306 based Graphic I2C LCD module
with 128 \* 32 pixel support.  

``` screen
    #chip mega328p,16
    #include <glcd.h>

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306_32  'for 128 * 32 pixels support
    #define GLCD_I2C_Address 0x78

    GLCDCLS
    GLCDPrint 0, 0, "GCBASIC"
    GLCDPrint (0, 16, "Anobium 2021")
```

  
This example shows how to drive a SSD1306 with the OLED fonts. Note the
use of the `GLCDfntDefaultSize` to select the size of the OLED font in
use.  

``` screen
    #define GLCD_OLED_FONT

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  SSD1306" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")
```

  
This example shows how to set the SSD1306 OLED the lowest constrast
level by using a OLED chip specific command.  

``` screen
    'Use the GCB command to set the lowest constrast
    GLCDSetContrast ( 0 )
      'Then, use the Write command to set the output between 0 and 255
      Write_Command_SSD1306(SSD1306_SETVCOMDETECT)
      Write_Command_SSD1306(15)      ' 0x40 default, to lower the contrast, put 0 for lowest and 255 for highest.


    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  SSD1306" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")
```

  

This example shows how to disable the large OLED Fontset. This disables
the font to reduce memory usage.

When the large OLED fontset is disabled every character will be shown as
a block character.  

``` screen
    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts
    #define GLCD_Disable_OLED_FONT2       'The constant to disable the large fontset.

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  SSD1306" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")
```

  

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SSD1331 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_ssd1306_controllers.html" title="SSD1306 Controllers"><link rel="next" href="_ssd1351_controllers.html" title="SSD1351 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_ssd1331_controllers"></a>SSD1331 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the SSD1331 graphics controller.  The SSD1331 is a single-chip controller/driver for 262K-color, graphic type OLED-LCD.</p><p>The GCBASIC constants shown below control the configuration of the SSD1331 controller. &nbsp;&nbsp;&nbsp;GCBASIC supports SPI, hardware and software SPI, connectivity. This is shown in the tables below.</p><p>GCBASIC supports 65K-color mode operations.</p><p>To use the SSD1331 driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">        #include &lt;glcd.h&gt;
        #include &lt;UNO_mega328p.h &gt;

        #define GLCD_TYPE GLCD_TYPE_SSD1331

        'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
        #define GLCD_DC       portb.0           ' Data command line
        #define GLCD_CS       portb.2           ' Chip select line
        #define GLCD_RESET    portb.1           ' Reset line
        #define GLCD_DO       portb.3           ' Data out | MOSI
        #define GLCD_SCK      portb.5           ' Clock Line

        #define SSD1331_HardwareSPI    ' remove/comment out if you want to use software SPI.</pre><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_SSD1331</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DC</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command IO pin on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS) on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Reset</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DO</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on
the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_SCK</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Clock (CLK) pin on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SSD1331_HardwareSPI</code></p></td><td align="left" valign="top"><p>Specifies that hardware SPI will be used</p></td><td align="left" valign="top"><p>SPI ports MUST be defined that match the SPI module for each specific microcontroller
</p><p>    <span class="strong"><strong>#define SSD1331_HardwareSPI</strong></span></p></td></tr><tr><td align="left" valign="top"><p>HWSPIMode</p></td><td align="left" valign="top"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td><td align="left" valign="top"><p>Optional defaults to MASTERFAST.
</p><p>Options are MASTERSLOW,<br>
MASTER,<br>
MASTERFAST, or<br>
MASTERULTRAFAST for specific AVRs only.</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="center" valign="top"><p><code class="literal">96</code><br>
This cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="center" valign="top"><p><code class="literal">48</code><br>
This cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="center" valign="top"><p><code class="literal">6</code> or <code class="literal">5</code> for the OLED font set.</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code>
</p><p> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td></tr></tbody></table></div><pre class="screen">   SSD1331_BLACK   'hexidecimal value 0x0000
   SSD1331_BLUE    'hexidecimal value 0xF800
   SSD1331_RED     'hexidecimal value 0x001F
   SSD1331_GREEN   'hexidecimal value 0x07E0
   SSD1331_CYAN    'hexidecimal value 0xFFE0
   SSD1331_MAGENTA 'hexidecimal value 0xF81F
   SSD1331_YELLOW  'hexidecimal value 0x07FF
   SSD1331_WHITE   'hexidecimal value 0xFFFF</pre><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #chip mega328p, 16
    #option explicit

    #include &lt;glcd.h&gt;
    #include &lt;UNO_mega328p.h &gt;

    #define GLCD_TYPE GLCD_TYPE_SSD1331

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       portb.0           ' Data command line
    #define GLCD_CS       portb.2           ' Chip select line
    #define GLCD_RESET    portb.1           ' Reset line
    #define GLCD_DO       portb.3           ' Data out | MOSI
    #define GLCD_SCK      portb.5           ' Clock Line

    #define SSD1331_HardwareSPI    ' remove/comment out if you want to use software SPI.

    'GLCD selected OLED font set.
    #define GLCD_OLED_FONT
    GLCDfntDefaultsize = 1

    GLCDCLS
    GLCDPrintStringLN ("GCBASIC")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("Test of the SSD1331")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("Anobium 2021")
    end</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="ssd1331_controllers"></span>SSD1331 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the SSD1331 graphics
controller. The SSD1331 is a single-chip controller/driver for
262K-color, graphic type OLED-LCD.

The GCBASIC constants shown below control the configuration of the
SSD1331 controller.    GCBASIC supports SPI, hardware and software SPI,
connectivity. This is shown in the tables below.

GCBASIC supports 65K-color mode operations.

To use the SSD1331 driver simply include the following in your user
code. This will initialise the driver.

``` screen
        #include <glcd.h>
        #include <UNO_mega328p.h >

        #define GLCD_TYPE GLCD_TYPE_SSD1331

        'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
        #define GLCD_DC       portb.0           ' Data command line
        #define GLCD_CS       portb.2           ' Chip select line
        #define GLCD_RESET    portb.1           ' Reset line
        #define GLCD_DO       portb.3           ' Data out | MOSI
        #define GLCD_SCK      portb.5           ' Clock Line

        #define SSD1331_HardwareSPI    ' remove/comment out if you want to use software SPI.
```

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Options</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE</code></p></td>
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_SSD1331</code></p></td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DC</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_CS</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Chip Select (CS) on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_Reset</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_DO</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_SCK</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">SSD1331_HardwareSPI</code></p></td>
<td style="text-align: left;"><p>Specifies that hardware SPI will be used</p></td>
<td style="text-align: left;"><p>SPI ports MUST be defined that match the SPI module for each specific microcontroller</p>
<p><span class="strong"><strong>#define SSD1331_HardwareSPI</strong></span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>HWSPIMode</p></td>
<td style="text-align: left;"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td>
<td style="text-align: left;"><p>Optional defaults to MASTERFAST.</p>
<p>Options are MASTERSLOW,<br />
MASTER,<br />
MASTERFAST, or<br />
MASTERULTRAFAST for specific AVRs only.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: center;"><p><code class="literal">96</code><br />
This cannot be changed</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: center;"><p><code class="literal">48</code><br />
This cannot be changed</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Specifies the font width of the GCBASIC font set.</p></td>
<td style="text-align: center;"><p><code class="literal">6</code> or <code class="literal">5</code> for the OLED font set.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Command</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Purpose</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Example</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
<td style="text-align: left;"><p>Clear screen of GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDPrint</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar</code></p></td>
<td style="text-align: left;"><p>Print character on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDDrawString</code></p></td>
<td style="text-align: left;"><p>Print characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Box</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size</p></td>
<td style="text-align: left;"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">FilledBox</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td>
<td style="text-align: left;"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Line</code></p></td>
<td style="text-align: left;"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">PSet</code></p></td>
<td style="text-align: left;"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p>
<p>Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td>
</tr>
</tbody>
</table>

</div>

``` screen
   SSD1331_BLACK   'hexidecimal value 0x0000
   SSD1331_BLUE    'hexidecimal value 0xF800
   SSD1331_RED     'hexidecimal value 0x001F
   SSD1331_GREEN   'hexidecimal value 0x07E0
   SSD1331_CYAN    'hexidecimal value 0xFFE0
   SSD1331_MAGENTA 'hexidecimal value 0xF81F
   SSD1331_YELLOW  'hexidecimal value 0x07FF
   SSD1331_WHITE   'hexidecimal value 0xFFFF
```

<span class="strong">**Example:**</span>

``` screen
    #chip mega328p, 16
    #option explicit

    #include <glcd.h>
    #include <UNO_mega328p.h >

    #define GLCD_TYPE GLCD_TYPE_SSD1331

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       portb.0           ' Data command line
    #define GLCD_CS       portb.2           ' Chip select line
    #define GLCD_RESET    portb.1           ' Reset line
    #define GLCD_DO       portb.3           ' Data out | MOSI
    #define GLCD_SCK      portb.5           ' Clock Line

    #define SSD1331_HardwareSPI    ' remove/comment out if you want to use software SPI.

    'GLCD selected OLED font set.
    #define GLCD_OLED_FONT
    GLCDfntDefaultsize = 1

    GLCDCLS
    GLCDPrintStringLN ("GCBASIC")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("Test of the SSD1331")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("Anobium 2021")
    end
```

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SSD1351 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_ssd1331_controllers.html" title="SSD1331 Controllers"><link rel="next" href="_st7567_controllers.html" title="ST7567 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_ssd1351_controllers"></a>SSD1351 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the SSD1351 graphics controller.  The SSD1351 is a single-chip controller/driver for 262K-color, graphic type OLED-LCD.</p><p>The GCBASIC constants shown below control the configuration of the SSD1351 controller. &nbsp;&nbsp;&nbsp;GCBASIC supports SPI, hardware and software SPI, connectivity. This is shown in the tables below.</p><p>GCBASIC supports 65K-color mode operations.</p><p>To use the SSD1351 driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">        #include &lt;glcd.h&gt;
        #define GLCD_TYPE GLCD_TYPE_SSD1351

        'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
        #define GLCD_DC       portb.0           ' Data command line
        #define GLCD_CS       portb.2           ' Chip select line
        #define GLCD_RESET    portb.1           ' Reset line
        #define GLCD_DO       portb.3           ' Data out | MOSI
        #define GLCD_SCK      portb.5           ' Clock Line

        #define SSD1351_HardwareSPI    ' remove/comment out if you want to use software SPI.  If you are using PPS to setup the SPI - ensure that PPS SPI is disabled to use software SPI.</pre><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_SSD1351</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DC</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command IO pin on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS) on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Reset</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DO</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on
the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_SCK</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Clock (CLK) pin on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SSD1351_HardwareSPI</code></p></td><td align="left" valign="top"><p>Specifies that hardware SPI will be used</p></td><td align="left" valign="top"><p>SPI ports MUST be defined that match the SPI module for each specific microcontroller
</p><p>    <span class="strong"><strong>#define SSD1351_HardwareSPI</strong></span></p></td></tr><tr><td align="left" valign="top"><p>HWSPIMode</p></td><td align="left" valign="top"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td><td align="left" valign="top"><p>Optional defaults to MASTERFAST.
</p><p>Options are MASTERSLOW,<br>
MASTER,<br>
MASTERFAST, or<br>
MASTERULTRAFAST for specific AVRs only.</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="center" valign="top"><p><code class="literal">128</code><br>
This cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="center" valign="top"><p><code class="literal">128</code><br>
This cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="center" valign="top"><p><code class="literal">6</code> or <code class="literal">5</code> for the OLED font set.</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code>
</p><p> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td></tr></tbody></table></div><pre class="screen">   SSD1351_BLACK   'hexidecimal value 0x0000
   SSD1351_BLUE    'hexidecimal value 0xF800
   SSD1351_RED     'hexidecimal value 0x001F
   SSD1351_GREEN   'hexidecimal value 0x07E0
   SSD1351_CYAN    'hexidecimal value 0xFFE0
   SSD1351_MAGENTA 'hexidecimal value 0xF81F
   SSD1351_YELLOW  'hexidecimal value 0x07FF
   SSD1351_WHITE   'hexidecimal value 0xFFFF</pre><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #chip mega328p, 16
    #option explicit

    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_SSD1351

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       portb.0           ' Data command line
    #define GLCD_CS       portb.2           ' Chip select line
    #define GLCD_RESET    portb.1           ' Reset line
    #define GLCD_DO       portb.3           ' Data out | MOSI
    #define GLCD_SCK      portb.5           ' Clock Line

    #define SSD1351_HardwareSPI    ' remove/comment out if you want to use software SPI.

    'GLCD selected OLED font set.
    #define GLCD_OLED_FONT
    GLCDfntDefaultsize = 1

    GLCDCLS
    GLCDPrintStringLN ("GCBASIC")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("Test of the SSD1351")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("October 2021")
    end</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="ssd1351_controllers"></span>SSD1351 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the SSD1351 graphics
controller. The SSD1351 is a single-chip controller/driver for
262K-color, graphic type OLED-LCD.

The GCBASIC constants shown below control the configuration of the
SSD1351 controller.    GCBASIC supports SPI, hardware and software SPI,
connectivity. This is shown in the tables below.

GCBASIC supports 65K-color mode operations.

To use the SSD1351 driver simply include the following in your user
code. This will initialise the driver.

``` screen
        #include <glcd.h>
        #define GLCD_TYPE GLCD_TYPE_SSD1351

        'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
        #define GLCD_DC       portb.0           ' Data command line
        #define GLCD_CS       portb.2           ' Chip select line
        #define GLCD_RESET    portb.1           ' Reset line
        #define GLCD_DO       portb.3           ' Data out | MOSI
        #define GLCD_SCK      portb.5           ' Clock Line

        #define SSD1351_HardwareSPI    ' remove/comment out if you want to use software SPI.  If you are using PPS to setup the SPI - ensure that PPS SPI is disabled to use software SPI.
```

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Options</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE</code></p></td>
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_SSD1351</code></p></td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DC</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_CS</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Chip Select (CS) on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_Reset</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_DO</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_SCK</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">SSD1351_HardwareSPI</code></p></td>
<td style="text-align: left;"><p>Specifies that hardware SPI will be used</p></td>
<td style="text-align: left;"><p>SPI ports MUST be defined that match the SPI module for each specific microcontroller</p>
<p><span class="strong"><strong>#define SSD1351_HardwareSPI</strong></span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>HWSPIMode</p></td>
<td style="text-align: left;"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td>
<td style="text-align: left;"><p>Optional defaults to MASTERFAST.</p>
<p>Options are MASTERSLOW,<br />
MASTER,<br />
MASTERFAST, or<br />
MASTERULTRAFAST for specific AVRs only.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: center;"><p><code class="literal">128</code><br />
This cannot be changed</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: center;"><p><code class="literal">128</code><br />
This cannot be changed</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Specifies the font width of the GCBASIC font set.</p></td>
<td style="text-align: center;"><p><code class="literal">6</code> or <code class="literal">5</code> for the OLED font set.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Command</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Purpose</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Example</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
<td style="text-align: left;"><p>Clear screen of GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDPrint</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar</code></p></td>
<td style="text-align: left;"><p>Print character on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDDrawString</code></p></td>
<td style="text-align: left;"><p>Print characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Box</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size</p></td>
<td style="text-align: left;"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">FilledBox</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td>
<td style="text-align: left;"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Line</code></p></td>
<td style="text-align: left;"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">PSet</code></p></td>
<td style="text-align: left;"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p>
<p>Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td>
</tr>
</tbody>
</table>

</div>

``` screen
   SSD1351_BLACK   'hexidecimal value 0x0000
   SSD1351_BLUE    'hexidecimal value 0xF800
   SSD1351_RED     'hexidecimal value 0x001F
   SSD1351_GREEN   'hexidecimal value 0x07E0
   SSD1351_CYAN    'hexidecimal value 0xFFE0
   SSD1351_MAGENTA 'hexidecimal value 0xF81F
   SSD1351_YELLOW  'hexidecimal value 0x07FF
   SSD1351_WHITE   'hexidecimal value 0xFFFF
```

<span class="strong">**Example:**</span>

``` screen
    #chip mega328p, 16
    #option explicit

    #include <glcd.h>
    #define GLCD_TYPE GLCD_TYPE_SSD1351

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       portb.0           ' Data command line
    #define GLCD_CS       portb.2           ' Chip select line
    #define GLCD_RESET    portb.1           ' Reset line
    #define GLCD_DO       portb.3           ' Data out | MOSI
    #define GLCD_SCK      portb.5           ' Clock Line

    #define SSD1351_HardwareSPI    ' remove/comment out if you want to use software SPI.

    'GLCD selected OLED font set.
    #define GLCD_OLED_FONT
    GLCDfntDefaultsize = 1

    GLCDCLS
    GLCDPrintStringLN ("GCBASIC")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("Test of the SSD1351")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("October 2021")
    end
```

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7567 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_ssd1351_controllers.html" title="SSD1351 Controllers"><link rel="next" href="_st7735_controllers.html" title="ST7735 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_st7567_controllers"></a>ST7567 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the ST7567 graphics controller.</p><p>The ST7567 is a single-chip CMOS LCD driver with controller for organic / polymer light emitting diode dot-matrix graphic display system. It consists of 128 segments and 64 commons. This IC is designed for Common Cathode type LCD panel.</p><p>ST7567 is a single-chip dot matrix LCD driver which incorporates LCD controller and common/segment drivers.
A ST7567 can be connected directly to a microprocessor with I2C or 4-line serial interface (SPI-4).
Display data sent from microprocessor is stored in the internal Display Data RAM (DDRAM) of 65x132 bits.
The display data bits which are stored in DDRAM are directly related to the pixels of LCD panel.
The ST7567 contains 132 segment-outputs, 64 common-outputs and 1 icon-common-output, however the address pixels are 128 * 64.
The ST7567 has built-in oscillation circuit and low power consumption power circuit, ST7567 generates LCD driving signal without external clock or power, so that it is possible to make a display system with the fewest components and minimal power consumption.</p><p>There are different types of ST75xx GLCDs.&nbsp;&nbsp;&nbsp;The table below shows the different types and the GCBASIC support.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"><col class="col_5"></colgroup><thead><tr><th align="left" valign="top">Index</th><th align="left" valign="top">GLCD MPU</th><th align="left" valign="top">Interfaces</th><th align="left" valign="top">Datasheet Ref</th><th align="left" valign="top">Support</th></tr></thead><tbody><tr><td align="left" valign="top"><p>1</p></td><td align="left" valign="top"><p>ST7565</p></td><td align="left" valign="top"><p>Parallel 8080&amp;6080</p></td><td align="left" valign="top"><p>Ver 1.0a;Page 12</p></td><td align="left" valign="top"><p>Not supported</p></td></tr><tr><td align="left" valign="top"><p>2</p></td><td align="left" valign="top"><p>ST7565S</p></td><td align="left" valign="top"><p>Parallel 8080&amp;6080</p></td><td align="left" valign="top"><p>Ver 0.6b;Page 23</p></td><td align="left" valign="top"><p>Not supported</p></td></tr><tr><td align="left" valign="top"><p>3</p></td><td align="left" valign="top"><p>ST7567</p></td><td align="left" valign="top"><p>4 Pin SPI;Parallel 8080&amp;6080</p></td><td align="left" valign="top"><p>Ver1.4b;Page 12</p></td><td align="left" valign="top"><p>3&amp;4 Pin SPI</p></td></tr><tr><td align="left" valign="top"><p>4</p></td><td align="left" valign="top"><p>ST7567S</p></td><td align="left" valign="top"><p>3&amp;4 Pin SPI;I2C;Parallel 8080&amp;6080</p></td><td align="left" valign="top"><p>Ver1.4;Page 17</p></td><td align="left" valign="top"><p>3&amp;4 Pin SPI &amp; I2C</p></td></tr><tr><td align="left" valign="top"><p>5</p></td><td align="left" valign="top"><p>ST7576</p></td><td align="left" valign="top"><p>3&amp;4 Pin SPI;I2C;Parallel 8080&amp;6080</p></td><td align="left" valign="top"><p>Ver1;Page 18</p></td><td align="left" valign="top"><p>3&amp;4 Pin SPI &amp; I2C</p></td></tr></tbody></table></div><p>The ST7567 embeds with contrast control, display RAM and it is suitable for many compact portable applications, such as mobile phone sub-display, MP3 player and calculator, etc.</p><p>The GCBASIC constants shown below control the configuration of the ST7567 controller. &nbsp;&nbsp;&nbsp;GCBASIC supports SPI and I2C software connectivity  - this is shown in the tables below.</p><p>The ST7567 library supports 128 * 64 pixels.</p><p>The ST7567 is a monochrome device.
The library supports difference bias settings for the different types of LCD.
See the constant <code class="literal">ST7567_BIAS</code> for the options.</p><p>The ST7567 can operate in three modes. Full GLCD mode, Low Memory GLCD mode or Text/JPG mode the full GLCD mode requires a minimum of 1k bytes or 512 bytes for the 128x64 respectively in Full GLCD mode.  For microcontrollers with limited memory the third mode of operation - Text mode.  These can be selected by setting the correct constant.</p><p>To use the ST7567 drivers simply include one of the following configuration.  You can select Full Mode GLCD, Low Memory Mode GLCD or Text mode these require 1024, 128 or 0 bytes GLCD buffer respectively - you microcontroller requires sufficient RAM to support the selected mode of GLCD operation.</p><p>To use the ST7567 driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">    'An I2C configuration
    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_ST7567
    #define GLCD_I2C_Address 0x7E
    #define ST7567_BIAS     ST7567_SET_BIAS_7    ' ST7567_SET_BIAS_7 or ST7567_SET_BIAS_9


    ; ----- Define software IC2 settings
    #DEFINE I2C_MODE MASTER
    #DEFINE I2C_DATA PORTB.4
    #DEFINE I2C_CLOCK PORTB.6
    #DEFINE I2C_DISABLE_INTERRUPTS ON</pre><p>or,</p><pre class="screen">    'An SPI configuration'
    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_ST7567

    ; ----- Define Hardware settings
    #define S4Wire_DATA

    #define MOSI_ST7567 PortB.1
    #define SCK_ST7567  PortB.2
    #define DC_ST7567   PortB.3
    #define CS_ST7567   PortB.4
    #define RES_ST7567  PortB.5</pre><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_ST7567</code></p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_I2C_Address</code></p></td><td align="left" valign="top"><p>I2C address of the GLCD.</p></td><td align="left" valign="top"><p>Required defaults to 0x7E</p></td></tr></tbody></table></div><p>The GCBASIC constants for SPI/S4Wire control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_ST7567</code></p></td><td align="left" valign="top"><p>Required to support 128 * 64 pixels.  Mutualy exclusive to GLCD_TYPE_ST7567_32</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ST7567_BIAS</code></p></td><td align="left" valign="top"><p>Bias ratio of the voltage required to driving the LCD at a fixes duty of 1/65 ( see the datasheet)</p></td><td align="left" valign="top"><p>Defaults to <code class="literal">ST7567_SET_BIAS_7</code>.  Can be either <code class="literal">ST7567_SET_BIAS_7</code> or <code class="literal">ST7567_SET_BIAS_9</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">S4Wire_Data</code></p></td><td align="left" valign="top"><p>4 wire SPI Mode</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">MOSI_ST7567</code></p></td><td align="left" valign="top"><p>Specifies output pin connected to serial data in D1 pin</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SCK_ST7567</code></p></td><td align="left" valign="top"><p>Specifies output pin connected to serial clock D0 pin</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">DC_ST7567</code></p></td><td align="left" valign="top"><p>Specifies output pin connected to data control DC pin</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CS_ST7567</code></p></td><td align="left" valign="top"><p>Specifies output pin connected to chip select CS pin</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">RES_ST7567</code></p></td><td align="left" valign="top"><p>Specifies output pin connected to reset RES pin</p></td><td align="left" valign="top"><p>Must be defined</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">128</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">64</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_PROTECTOVERRUN</code></p></td><td align="left" valign="top"><p>Define this constant to restrict pixel operations with the pixel limits</p></td><td align="left" valign="top"><p>Not defined</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_ST7567_CHARACTER_MODE_ONLY</code></p></td><td align="left" valign="top"><p>Specifies that the display controller will operate in text mode and BMP
draw mode only.<br>
For microcontrollers with low RAM this will be set be
default.<br>
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <code class="literal">GLCD_TYPE_ST7567_LOWMEMORY_GLCD_MODE</code></p></td><td align="left" valign="top"><p>Optional</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_ST7567_LOWMEMORY_GLCD_MODE</code></p></td><td align="left" valign="top"><p>Specifies that the display controller will operate in Low Memory mode.</p></td><td align="left" valign="top"><p>Optional</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_OLED_FONT</code></p></td><td align="left" valign="top"><p>Specifies the use of the optional OLED font set.
</p><p>The GLCDfntDefaultsize can be set to 1 or 2 only.
</p><p><code class="literal">GLCDfntDefaultsize=  1</code>.   A small 8 height pixel font with variable width.
<code class="literal">GLCDfntDefaultsize=  2</code>.   A larger 10 width * 16 height pixel font.</p></td><td align="left" valign="top"><p>Optional</p></td></tr></tbody></table></div><p>The GCBASIC variables for control display characteristics are shown in the table below.
These variables control the user definable parameters of a specific GLCD.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Variable</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Type</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDBackground</code></p></td><td align="left" valign="top"><p>GLCD background state.</p></td><td align="left" valign="top"><p>A monochrome value.<br>
For mono GLCDs the default is White or 0x0001.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDForeground</code></p></td><td align="left" valign="top"><p>Color of GLCD foreground.</p></td><td align="left" valign="top"><p>A monochrome value.<br>
For mono GLCDs the default is non-white or 0x0000.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Width of the current GLCD font.</p></td><td align="left" valign="top"><p>Default is 6 pixels.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDfntDefault</code></p></td><td align="left" valign="top"><p>Size of the current GLCD font.</p></td><td align="left" valign="top"><p>Default is 0.
</p><p></p><p>This equates to the standard GCB font set.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDfntDefaultsize</code></p></td><td align="left" valign="top"><p>Size of the current GLCD font.</p></td><td align="left" valign="top"><p>Default is 1.
</p><p></p><p>This equates to the 8 pixel high.</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the
table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte (LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Open_PageTransaction</code></p></td><td align="left" valign="top"><p>Commence a series of GLCD commands when in low memory mode.  Must be followed a  <code class="literal">GLCD_Close_PageTransaction</code> command.</p></td><td align="left" valign="top"><p><code class="literal">GLCD_Close_PageTransaction 0, 7</code> where 0 and 7 are the range of pages to be updated</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Close_PageTransaction</code></p></td><td align="left" valign="top"><p>Commence a series of GLCD commands when in low memory mode.  Must follow a <code class="literal">GLCD_Open_PageTransaction</code> command.</p></td><td align="left" valign="top">&nbsp;</td></tr></tbody></table></div><p>The GCBASIC specific commands for this GLCD are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDSetContrast ( dim_state )</code></p></td><td align="left" valign="top"><p>Sets the constrast between 0 and 255. The contrast increases as the value increases.<br>
Parameter is dim value</p></td></tr></tbody></table></div><p>This example shows how to drive a ST7567 based Graphic I2C LCD module with the built in commands of GCBASIC using Full Mode GLCD</p><pre class="screen">    #CHIP 18F26Q71
    #OPTION Explicit

    #startup InitPPS, 85
        #define PPSToolPart 18F26Q71

        Sub InitPPS
            // Ensure PPS is NOT set for Software I2C
            UNLOCKPPS
            RB6PPS = 0
            RB4PPS = 0
        End Sub
        'Template comment at the end of the config file


    '' -------------------PORTA----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' IO:   ----------------------------------
    ''-----------------------------------------
    ''

    '' -------------------PORTB----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' IO:    ----SCL-----SDA------------------
    ''-----------------------------------------
    ''

    '' ------------------PORTC-----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' IO:    ---------------------------------
    ''-----------------------------------------

    ' Define Software I2C settings
        #DEFINE I2C_MODE MASTER
        #DEFINE I2C_DATA PORTB.4
        #DEFINE I2C_CLOCK PORTB.6
        #DEFINE I2C_DISABLE_INTERRUPTS ON

    '*****************************************************************************************************
    'Main program commences here.. everything before this is setup for the chip.

        Dim DeviceID As Byte
        Dim DISPLAYNEWLINE As Byte

        #include &lt;glcd.h&gt;
        #DEFINE GLCD_TYPE GLCD_TYPE_ST7567
        #DEFINE GLCDDIRECTION INVERTED

    ; ----- Define variables
        Dim BYTENUMBER, CCOUNT as Byte

        CCount = 0
        dim longNumber as long
        longNumber = 123456 ' max value = 4294967290
        dim wordNumber as Word
        dim outstring as string
        wordNumber = 0
        byteNumber = 0

    ; ----- Main program

        GLCDPrint 0, 0,   "GCBASIC"
        GLCDPrint (0, 16, "Anobium 2024")
        GLCDPrint (0, 32, "Portability Demo")
        GLCDPrint (0, 48, ChipNameStr )

        wait 3 s
        GLCDCLS

        ' Prepare the static components of the screen
        GLCDPrint ( 2,   2, "PrintStr")                                   ; Print some text
        GLCDPrint ( 64,  2, "@")                                          ; Print some more text
        GLCDPrint ( 72,  2, ChipMhz)                                      ; Print chip speed
        GLCDPrint ( 86, 2, "Mhz")                                         ; Print some text
        GLCDDrawString( 2,10,"DrawStr")                                    ; Draw some text
        box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1                               ; Draw a box
        box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1       ; Draw a box
        Circle( 44,41,15)                                                 ; Draw a circle
        line 64,31,0,31                                                   ; Draw a line

        DO forever

            for CCount = 32 to 127

                GLCDPrint ( 64 ,  36,  hex(longNumber_E ) )                 ; Print a HEX string
                GLCDPrint ( 76 ,  36,  hex(longNumber_U ) )                 ; Print a HEX string
                GLCDPrint ( 88 ,  36,  hex(longNumber_H ) )                 ; Print a HEX string
                GLCDPrint ( 100 ,  36, hex(longNumber   ) )                 ; Print a HEX string
                GLCDPrint ( 112 ,  36, "h" )                                ; Print a HEX string


                GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) )           ; Print a padded string
                GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) )           ; Print a padded string


                box (46,9,56,19)                                           ; Draw a Box
                GLCDDrawChar(48, 10, CCount )                               ; Draw a character
                outString = str( CCount )                                  ; Prepare a string
                GLCDDrawString(64, 10, pad(outString,3) )                   ; Draw a string

                filledbox 3,43,11,51, wordNumber                           ; Draw a filled box

                FilledCircle( 44,41,9, longNumber xor 1)                   ; Draw a filled box
                line 0,63,64,31                                            ; Draw a line

                                                                            ; Do some simple maths
                longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
            NEXT
        LOOP
        end</pre><p><br>
<br>
This example shows how to drive a ST7567 based Graphic I2C LCD module with the built in commands of GCBASIC using Low Memory Mode GLCD.
<br>
Note the use of <code class="literal">GLCD_Open_PageTransaction</code> and <code class="literal">GLCD_Close_PageTransaction</code> to support the Low Memory Mode of operation and the contraining of all GLCD commands with the transaction commands.  The use Low Memory Mode GLCD the two defines <code class="literal">GLCD_TYPE_ST7567_LOWMEMORY_GLCD_MODE</code> and <code class="literal">GLCD_TYPE_ST7567_CHARACTER_MODE_ONLY</code> are included in the user program.
<br></p><pre class="screen">    #chip {any valid chip}
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #DEFINE I2C_MODE MASTER
    #DEFINE I2C_DATA PORTB.4
    #DEFINE I2C_CLOCK PORTB.6
    #DEFINE I2C_DISABLE_INTERRUPTS ON

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_ST7567  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x7E
    #define GLCD_TYPE_ST7567_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_ST7567_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS

    'To clarify - page udpates
    '0,7 correspond with the Text Lines from 0 to 7 on a 64 Pixel Display
    'In this example Code would be GLCD_Open_PageTransaction 0,1 been enough
    'But it is allowed to use GLCD_Open_PageTransaction 0,7 to show the full screen update
    GLCD_Open_PageTransaction 0,7
       GLCDPrint 0, 0, "GCBASIC"
       GLCDPrint (0, 16, "Anobium 2024")
    GLCD_Close_PageTransaction
    wait 3 s
    DO forever

      for CCount = 31 to 127

        outString = str( CCount ) ; Prepare a string

        GLCD_Open_PageTransaction 0,7

           ' Prepare the static components of the screen
           GLCDPrint ( 0,   0, "PrintStr") ; Print some text
           GLCDPrint ( 64,  0, "@")
           ; Print some more text
           GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
           GLCDPrint ( 86, 0, "Mhz") ; Print some text
           GLCDDrawString( 0,8,"DrawStr") ; Draw some text
           box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           Circle( 44,41,15) ; Draw a circle
           line 64,31,0,31 ; Draw a line

           GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
           GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
           GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
           GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
           GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

           GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
           GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

           box (46,8,56,19) ; Draw a Box
           GLCDDrawChar(48, 9, CCount ) ; Draw a character

           GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

           filledbox 3,43,11,51, wordNumber ; Draw a filled box

           FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
           line 0,63,64,31 ; Draw a line

        GLCD_Close_PageTransaction

        ; Do some simple maths
        longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
       NEXT
    LOOP
    end</pre><p><br>
This example shows how to drive a ST7567 based Graphic SPI LCD module with the built in commands of GCBASIC.
<br></p><pre class="screen">    #chip  {any valid chip}
    #include &lt;glcd.h&gt;

    'Defines for a 7 pin SPI module
    'RES pin is pulsed low in glcd_ST7567.h for proper startup
    #define MOSI_ST7567 PortB.1
    #define SCK_ST7567 PortB.2
    #define DC_ST7567 PortB.3
    #define CS_ST7567 PortB.4
    #define RES_ST7567 PortB.5
    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_ST7567   'for 128 * 64 pixels support
    #define S4Wire_DATA

    dim longnumber as Long
    longnumber = 123456
    dim wordnumber as word
    wordnumber = 62535
    dim bytenumber as Byte
    bytenumber =255

    #define led PortB.0
    dir led out


    Do
         SET led ON
         wait 1 s
         SET led OFF

        GLCDCLS
        GLCDPrint (30, 0, "Hello World!")
        Circle (18,24,10)
        FilledCircle (48,24,10)
        Box (70,14,90,34)
        FilledBox (106,14,126,34)
        GLCDDrawString (32,35,"Draw String")
        GLCDPrint (0,46,longnumber)
        GLCDPrint (94,46,wordnumber)
        GLCDPrint (52,55,bytenumber)
        Line (0,40,127,63)
        Line (0,63,127,40)
        wait 3 s

    Loop</pre><p><br>
This example shows how to drive a ST7567 with the OLED fonts.  Note the use of the <code class="literal">GLCDfntDefaultSize</code> to select the size of the OLED font in use.
<br></p><pre class="screen">    #define GLCD_OLED_FONT

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7567" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</pre><p><br>
This example shows how to set the ST7567 OLED the lowest constrast level by using a OLED chip specific command.
<br></p><pre class="screen">    'Use the GCB command to set the lowest constrast
    GLCDSetContrast ( 0 )

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7567" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</pre><p><br></p><p>This example shows how to disable the large OLED Fontset.  This disables the font to reduce memory usage.</p><p>When the large OLED fontset is disabled every character will be shown as a block character.
<br></p><pre class="screen">    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts
    #define GLCD_Disable_OLED_FONT2       'The constant to disable the large fontset.

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7567" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</pre><p><br></p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="st7567_controllers"></span>ST7567 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the ST7567 graphics
controller.

The ST7567 is a single-chip CMOS LCD driver with controller for organic
/ polymer light emitting diode dot-matrix graphic display system. It
consists of 128 segments and 64 commons. This IC is designed for Common
Cathode type LCD panel.

ST7567 is a single-chip dot matrix LCD driver which incorporates LCD
controller and common/segment drivers. A ST7567 can be connected
directly to a microprocessor with I2C or 4-line serial interface
(SPI-4). Display data sent from microprocessor is stored in the internal
Display Data RAM (DDRAM) of 65x132 bits. The display data bits which are
stored in DDRAM are directly related to the pixels of LCD panel. The
ST7567 contains 132 segment-outputs, 64 common-outputs and 1
icon-common-output, however the address pixels are 128 \* 64. The ST7567
has built-in oscillation circuit and low power consumption power
circuit, ST7567 generates LCD driving signal without external clock or
power, so that it is possible to make a display system with the fewest
components and minimal power consumption.

There are different types of ST75xx GLCDs.   The table below shows the
different types and the GCBASIC support.

<div class="informaltable">

| Index | GLCD MPU | Interfaces                         | Datasheet Ref    | Support           |
|:------|:---------|:-----------------------------------|:-----------------|:------------------|
| 1     | ST7565   | Parallel 8080&6080                 | Ver 1.0a;Page 12 | Not supported     |
| 2     | ST7565S  | Parallel 8080&6080                 | Ver 0.6b;Page 23 | Not supported     |
| 3     | ST7567   | 4 Pin SPI;Parallel 8080&6080       | Ver1.4b;Page 12  | 3&4 Pin SPI       |
| 4     | ST7567S  | 3&4 Pin SPI;I2C;Parallel 8080&6080 | Ver1.4;Page 17   | 3&4 Pin SPI & I2C |
| 5     | ST7576   | 3&4 Pin SPI;I2C;Parallel 8080&6080 | Ver1;Page 18     | 3&4 Pin SPI & I2C |

</div>

The ST7567 embeds with contrast control, display RAM and it is suitable
for many compact portable applications, such as mobile phone
sub-display, MP3 player and calculator, etc.

The GCBASIC constants shown below control the configuration of the
ST7567 controller.    GCBASIC supports SPI and I2C software connectivity
- this is shown in the tables below.

The ST7567 library supports 128 \* 64 pixels.

The ST7567 is a monochrome device. The library supports difference bias
settings for the different types of LCD. See the constant `ST7567_BIAS`
for the options.

The ST7567 can operate in three modes. Full GLCD mode, Low Memory GLCD
mode or Text/JPG mode the full GLCD mode requires a minimum of 1k bytes
or 512 bytes for the 128x64 respectively in Full GLCD mode. For
microcontrollers with limited memory the third mode of operation - Text
mode. These can be selected by setting the correct constant.

To use the ST7567 drivers simply include one of the following
configuration. You can select Full Mode GLCD, Low Memory Mode GLCD or
Text mode these require 1024, 128 or 0 bytes GLCD buffer respectively -
you microcontroller requires sufficient RAM to support the selected mode
of GLCD operation.

To use the ST7567 driver simply include the following in your user code.
This will initialise the driver.

``` screen
    'An I2C configuration
    #include <glcd.h>

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_ST7567
    #define GLCD_I2C_Address 0x7E
    #define ST7567_BIAS     ST7567_SET_BIAS_7    ' ST7567_SET_BIAS_7 or ST7567_SET_BIAS_9


    ; ----- Define software IC2 settings
    #DEFINE I2C_MODE MASTER
    #DEFINE I2C_DATA PORTB.4
    #DEFINE I2C_CLOCK PORTB.6
    #DEFINE I2C_DISABLE_INTERRUPTS ON
```

or,

``` screen
    'An SPI configuration'
    #include <glcd.h>

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_ST7567

    ; ----- Define Hardware settings
    #define S4Wire_DATA

    #define MOSI_ST7567 PortB.1
    #define SCK_ST7567  PortB.2
    #define DC_ST7567   PortB.3
    #define CS_ST7567   PortB.4
    #define RES_ST7567  PortB.5
```

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

| <span class="strong">**Constants**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Options**</span> |
|:------------------------------------------|:-----------------------------------------|:----------------------------------------|
| `GLCD_TYPE`                               | `GLCD_TYPE_ST7567`                       | Required                                |
| `GLCD_I2C_Address`                        | I2C address of the GLCD.                 | Required defaults to 0x7E               |

</div>

The GCBASIC constants for SPI/S4Wire control display characteristics are
shown in the table below.

<div class="informaltable">

| <span class="strong">**Constants**</span> | <span class="strong">**Controls**</span>                                                           | <span class="strong">**Options**</span>                                                   |
|:------------------------------------------|:---------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------|
| `GLCD_TYPE`                               | `GLCD_TYPE_ST7567`                                                                                 | Required to support 128 \* 64 pixels. Mutualy exclusive to GLCD\_TYPE\_ST7567\_32         |
| `ST7567_BIAS`                             | Bias ratio of the voltage required to driving the LCD at a fixes duty of 1/65 ( see the datasheet) | Defaults to `ST7567_SET_BIAS_7`. Can be either `ST7567_SET_BIAS_7` or `ST7567_SET_BIAS_9` |
| `S4Wire_Data`                             | 4 wire SPI Mode                                                                                    | Required                                                                                  |
| `MOSI_ST7567`                             | Specifies output pin connected to serial data in D1 pin                                            | Must be defined                                                                           |
| `SCK_ST7567`                              | Specifies output pin connected to serial clock D0 pin                                              | Must be defined                                                                           |
| `DC_ST7567`                               | Specifies output pin connected to data control DC pin                                              | Must be defined                                                                           |
| `CS_ST7567`                               | Specifies output pin connected to chip select CS pin                                               | Must be defined                                                                           |
| `RES_ST7567`                              | Specifies output pin connected to reset RES pin                                                    | Must be defined                                                                           |

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">128</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">64</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_PROTECTOVERRUN</code></p></td>
<td style="text-align: left;"><p>Define this constant to restrict pixel operations with the pixel limits</p></td>
<td style="text-align: left;"><p>Not defined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_ST7567_CHARACTER_MODE_ONLY</code></p></td>
<td style="text-align: left;"><p>Specifies that the display controller will operate in text mode and BMP draw mode only.<br />
For microcontrollers with low RAM this will be set be default.<br />
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <code class="literal">GLCD_TYPE_ST7567_LOWMEMORY_GLCD_MODE</code></p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_ST7567_LOWMEMORY_GLCD_MODE</code></p></td>
<td style="text-align: left;"><p>Specifies that the display controller will operate in Low Memory mode.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_OLED_FONT</code></p></td>
<td style="text-align: left;"><p>Specifies the use of the optional OLED font set.</p>
<p>The GLCDfntDefaultsize can be set to 1 or 2 only.</p>
<p><code class="literal">GLCDfntDefaultsize=  1</code>. A small 8 height pixel font with variable width. <code class="literal">GLCDfntDefaultsize=  2</code>. A larger 10 width * 16 height pixel font.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC variables for control display characteristics are shown in
the table below. These variables control the user definable parameters
of a specific GLCD.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Variable</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Purpose</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Type</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDBackground</code></p></td>
<td style="text-align: left;"><p>GLCD background state.</p></td>
<td style="text-align: left;"><p>A monochrome value.<br />
For mono GLCDs the default is White or 0x0001.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDForeground</code></p></td>
<td style="text-align: left;"><p>Color of GLCD foreground.</p></td>
<td style="text-align: left;"><p>A monochrome value.<br />
For mono GLCDs the default is non-white or 0x0000.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Width of the current GLCD font.</p></td>
<td style="text-align: left;"><p>Default is 6 pixels.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDfntDefault</code></p></td>
<td style="text-align: left;"><p>Size of the current GLCD font.</p></td>
<td style="text-align: left;"><p>Default is 0.</p>
<p>This equates to the standard GCB font set.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDfntDefaultsize</code></p></td>
<td style="text-align: left;"><p>Size of the current GLCD font.</p></td>
<td style="text-align: left;"><p>Default is 1.</p>
<p>This equates to the 8 pixel high.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**Purpose**</span>                                                                              | <span class="strong">**Example**</span>                                                        |
|:----------------------------------------|:---------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------|
| `GLCDCLS`                               | Clear screen of GLCD                                                                                                 | `GLCDCLS`                                                                                      |
| `GLCDPrint`                             | Print string of characters on GLCD using GCB font set                                                                | `GLCDPrint( Xposition, Yposition, Stringvariable )`                                            |
| `GLCDDrawChar`                          | Print character on GLCD using GCB font set                                                                           | `GLCDDrawChar( Xposition, Yposition, CharCode )`                                               |
| `GLCDDrawString`                        | Print characters on GLCD using GCB font set                                                                          | `GLCDDrawString( Xposition, Yposition, Stringvariable )`                                       |
| `Box`                                   | Draw a box on the GLCD to a specific size                                                                            | `Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )`   |
| `FilledBox`                             | Draw a box on the GLCD to a specific size that is filled with the foreground colour.                                 | `FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )` |
| `Line`                                  | Draw a line on the GLCD to a specific length that is filled with the specific attribute.                             | `Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`     |
| `PSet`                                  | Set a pixel on the GLCD at a specific position that is set with the specific attribute.                              | `PSet(Xposition, Yposition, Pixel Colour 0 or 1)`                                              |
| `GLCDWriteByte`                         | Set a byte value to the controller, see the datasheet for usage.                                                     | `GLCDWriteByte (LCDByte)`                                                                      |
| `GLCDReadByte`                          | Read a byte value from the controller, see the datasheet for usage.                                                  | `bytevariable = GLCDReadByte`                                                                  |
| `GLCD_Open_PageTransaction`             | Commence a series of GLCD commands when in low memory mode. Must be followed a `GLCD_Close_PageTransaction` command. | `GLCD_Close_PageTransaction 0, 7` where 0 and 7 are the range of pages to be updated           |
| `GLCD_Close_PageTransaction`            | Commence a series of GLCD commands when in low memory mode. Must follow a `GLCD_Open_PageTransaction` command.       |                                                                                                |

</div>

The GCBASIC specific commands for this GLCD are shown in the table
below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDSetContrast ( dim_state )</code></p></td>
<td style="text-align: left;"><p>Sets the constrast between 0 and 255. The contrast increases as the value increases.<br />
Parameter is dim value</p></td>
</tr>
</tbody>
</table>

</div>

This example shows how to drive a ST7567 based Graphic I2C LCD module
with the built in commands of GCBASIC using Full Mode GLCD

``` screen
    #CHIP 18F26Q71
    #OPTION Explicit

    #startup InitPPS, 85
        #define PPSToolPart 18F26Q71

        Sub InitPPS
            // Ensure PPS is NOT set for Software I2C
            UNLOCKPPS
            RB6PPS = 0
            RB4PPS = 0
        End Sub
        'Template comment at the end of the config file


    '' -------------------PORTA----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' IO:   ----------------------------------
    ''-----------------------------------------
    ''

    '' -------------------PORTB----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' IO:    ----SCL-----SDA------------------
    ''-----------------------------------------
    ''

    '' ------------------PORTC-----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' IO:    ---------------------------------
    ''-----------------------------------------

    ' Define Software I2C settings
        #DEFINE I2C_MODE MASTER
        #DEFINE I2C_DATA PORTB.4
        #DEFINE I2C_CLOCK PORTB.6
        #DEFINE I2C_DISABLE_INTERRUPTS ON

    '*****************************************************************************************************
    'Main program commences here.. everything before this is setup for the chip.

        Dim DeviceID As Byte
        Dim DISPLAYNEWLINE As Byte

        #include <glcd.h>
        #DEFINE GLCD_TYPE GLCD_TYPE_ST7567
        #DEFINE GLCDDIRECTION INVERTED

    ; ----- Define variables
        Dim BYTENUMBER, CCOUNT as Byte

        CCount = 0
        dim longNumber as long
        longNumber = 123456 ' max value = 4294967290
        dim wordNumber as Word
        dim outstring as string
        wordNumber = 0
        byteNumber = 0

    ; ----- Main program

        GLCDPrint 0, 0,   "GCBASIC"
        GLCDPrint (0, 16, "Anobium 2024")
        GLCDPrint (0, 32, "Portability Demo")
        GLCDPrint (0, 48, ChipNameStr )

        wait 3 s
        GLCDCLS

        ' Prepare the static components of the screen
        GLCDPrint ( 2,   2, "PrintStr")                                   ; Print some text
        GLCDPrint ( 64,  2, "@")                                          ; Print some more text
        GLCDPrint ( 72,  2, ChipMhz)                                      ; Print chip speed
        GLCDPrint ( 86, 2, "Mhz")                                         ; Print some text
        GLCDDrawString( 2,10,"DrawStr")                                    ; Draw some text
        box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1                               ; Draw a box
        box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1       ; Draw a box
        Circle( 44,41,15)                                                 ; Draw a circle
        line 64,31,0,31                                                   ; Draw a line

        DO forever

            for CCount = 32 to 127

                GLCDPrint ( 64 ,  36,  hex(longNumber_E ) )                 ; Print a HEX string
                GLCDPrint ( 76 ,  36,  hex(longNumber_U ) )                 ; Print a HEX string
                GLCDPrint ( 88 ,  36,  hex(longNumber_H ) )                 ; Print a HEX string
                GLCDPrint ( 100 ,  36, hex(longNumber   ) )                 ; Print a HEX string
                GLCDPrint ( 112 ,  36, "h" )                                ; Print a HEX string


                GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) )           ; Print a padded string
                GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) )           ; Print a padded string


                box (46,9,56,19)                                           ; Draw a Box
                GLCDDrawChar(48, 10, CCount )                               ; Draw a character
                outString = str( CCount )                                  ; Prepare a string
                GLCDDrawString(64, 10, pad(outString,3) )                   ; Draw a string

                filledbox 3,43,11,51, wordNumber                           ; Draw a filled box

                FilledCircle( 44,41,9, longNumber xor 1)                   ; Draw a filled box
                line 0,63,64,31                                            ; Draw a line

                                                                            ; Do some simple maths
                longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
            NEXT
        LOOP
        end
```

  
  
This example shows how to drive a ST7567 based Graphic I2C LCD module
with the built in commands of GCBASIC using Low Memory Mode GLCD.  
Note the use of `GLCD_Open_PageTransaction` and
`GLCD_Close_PageTransaction` to support the Low Memory Mode of operation
and the contraining of all GLCD commands with the transaction commands.
The use Low Memory Mode GLCD the two defines
`GLCD_TYPE_ST7567_LOWMEMORY_GLCD_MODE` and
`GLCD_TYPE_ST7567_CHARACTER_MODE_ONLY` are included in the user
program.  

``` screen
    #chip {any valid chip}
    #include <glcd.h>

    ; ----- Define Hardware settings
    ' Define I2C settings
    #DEFINE I2C_MODE MASTER
    #DEFINE I2C_DATA PORTB.4
    #DEFINE I2C_CLOCK PORTB.6
    #DEFINE I2C_DISABLE_INTERRUPTS ON

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_ST7567  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x7E
    #define GLCD_TYPE_ST7567_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_ST7567_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS

    'To clarify - page udpates
    '0,7 correspond with the Text Lines from 0 to 7 on a 64 Pixel Display
    'In this example Code would be GLCD_Open_PageTransaction 0,1 been enough
    'But it is allowed to use GLCD_Open_PageTransaction 0,7 to show the full screen update
    GLCD_Open_PageTransaction 0,7
       GLCDPrint 0, 0, "GCBASIC"
       GLCDPrint (0, 16, "Anobium 2024")
    GLCD_Close_PageTransaction
    wait 3 s
    DO forever

      for CCount = 31 to 127

        outString = str( CCount ) ; Prepare a string

        GLCD_Open_PageTransaction 0,7

           ' Prepare the static components of the screen
           GLCDPrint ( 0,   0, "PrintStr") ; Print some text
           GLCDPrint ( 64,  0, "@")
           ; Print some more text
           GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
           GLCDPrint ( 86, 0, "Mhz") ; Print some text
           GLCDDrawString( 0,8,"DrawStr") ; Draw some text
           box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           Circle( 44,41,15) ; Draw a circle
           line 64,31,0,31 ; Draw a line

           GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
           GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
           GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
           GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
           GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

           GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
           GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

           box (46,8,56,19) ; Draw a Box
           GLCDDrawChar(48, 9, CCount ) ; Draw a character

           GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

           filledbox 3,43,11,51, wordNumber ; Draw a filled box

           FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
           line 0,63,64,31 ; Draw a line

        GLCD_Close_PageTransaction

        ; Do some simple maths
        longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
       NEXT
    LOOP
    end
```

  
This example shows how to drive a ST7567 based Graphic SPI LCD module
with the built in commands of GCBASIC.  

``` screen
    #chip  {any valid chip}
    #include <glcd.h>

    'Defines for a 7 pin SPI module
    'RES pin is pulsed low in glcd_ST7567.h for proper startup
    #define MOSI_ST7567 PortB.1
    #define SCK_ST7567 PortB.2
    #define DC_ST7567 PortB.3
    #define CS_ST7567 PortB.4
    #define RES_ST7567 PortB.5
    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_ST7567   'for 128 * 64 pixels support
    #define S4Wire_DATA

    dim longnumber as Long
    longnumber = 123456
    dim wordnumber as word
    wordnumber = 62535
    dim bytenumber as Byte
    bytenumber =255

    #define led PortB.0
    dir led out


    Do
         SET led ON
         wait 1 s
         SET led OFF

        GLCDCLS
        GLCDPrint (30, 0, "Hello World!")
        Circle (18,24,10)
        FilledCircle (48,24,10)
        Box (70,14,90,34)
        FilledBox (106,14,126,34)
        GLCDDrawString (32,35,"Draw String")
        GLCDPrint (0,46,longnumber)
        GLCDPrint (94,46,wordnumber)
        GLCDPrint (52,55,bytenumber)
        Line (0,40,127,63)
        Line (0,63,127,40)
        wait 3 s

    Loop
```

  
This example shows how to drive a ST7567 with the OLED fonts. Note the
use of the `GLCDfntDefaultSize` to select the size of the OLED font in
use.  

``` screen
    #define GLCD_OLED_FONT

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7567" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")
```

  
This example shows how to set the ST7567 OLED the lowest constrast level
by using a OLED chip specific command.  

``` screen
    'Use the GCB command to set the lowest constrast
    GLCDSetContrast ( 0 )

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7567" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")
```

  

This example shows how to disable the large OLED Fontset. This disables
the font to reduce memory usage.

When the large OLED fontset is disabled every character will be shown as
a block character.  

``` screen
    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts
    #define GLCD_Disable_OLED_FONT2       'The constant to disable the large fontset.

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7567" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")
```

  

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7735 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_st7567_controllers.html" title="ST7567 Controllers"><link rel="next" href="_st7789_controllers.html" title="ST7789 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_st7735_controllers"></a>ST7735 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the ST7735 graphics controller.  The ST7735 or ST7735R is a single-chip controller/driver for 262K-color, graphic type TFT-LCD.</p><p>GCBASIC supports 65K-color mode operations.</p><p>The GCBASIC constants shown below control the configuration of the ST7735 or ST7735R controller. &nbsp;&nbsp;&nbsp;GCBASIC supports an 8 bit bus connectivity. The 8 bit must be a single port of consective bits  - this is shown in the tables below.</p><p>To use the ST7735 driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_ST7735R
    #define ST7735TABCOLOR ST7735_BLACKTAB  ; can also be ST7735_GREENTAB or ST7735_REDTAB or GLCD_TYPE_ST7735R_160_80

    'Pin mappings for ST7735
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS    porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting</pre><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_ST7735</code> or <code class="literal">GLCD_TYPE_ST7735R</code> or <code class="literal">GLCD_TYPE_ST7735R_160_80</code></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">ST7735TABCOLOR</code></p></td><td align="left" valign="top"><p>Specifies the type of ST7735 chipset.  The default is <code class="literal">ST7735_BLACKTAB</code></p></td><td align="left" valign="top"><p>Options are <code class="literal">ST7735_BLACKTAB</code>, <code class="literal">ST7735_GREENTAB</code> or <code class="literal">ST7735_REDTAB</code>.  Each tab is a different ST7735 configuration. If you do not know  your type try each constant and test.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DATA_PORT</code></p></td><td align="left" valign="top"><p>Not Available for this controller.</p></td><td align="left" valign="top"><p>Not applicable.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DC</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command IO pin on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS) on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Reset</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DI</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data In (GLCD out) pin on
the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_D0</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on
the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_SLK</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Clock (CLK) pin on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ST7735_HardwareSPI</code></p></td><td align="left" valign="top"><p>Specifies that hardware SPI will be used</p></td><td align="left" valign="top"><p>SPI ports MUST be defined that match the SPI module for each specific microcontroller
</p><p>    <span class="strong"><strong>#define ST7735_HardwareSPI</strong></span></p></td></tr><tr><td align="left" valign="top"><p>HWSPIMode</p></td><td align="left" valign="top"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td><td align="left" valign="top"><p>Optional defaults to MASTERFAST.
</p><p>Options are MASTERSLOW,<br>
MASTER,<br>
MASTERFAST, or<br>
MASTERULTRAFAST for specific AVRs only.</p></td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">ST7735_XSTART</code></p></td><td align="left" valign="top"><p>Specifies the adjustment made to the X axis when writing to the GLCD.  This is used to correct any geometry correction required for specific GLCDs.</p></td><td align="left" valign="top"><p>Optional.  Defaults are set for each specific GLCD.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ST7735_YSTART</code></p></td><td align="left" valign="top"><p>Specifies the adjustment made to the Y axis when writing to the GLCD.  This is used to correct any geometry correction required for specific GLCDs.</p></td><td align="left" valign="top"><p>Optional.  Defaults are set for each specific GLCD.</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="center" valign="top"><p><code class="literal">160</code><br>
This cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="center" valign="top"><p><code class="literal">128</code><br>
This cannot be changed</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="center" valign="top"><p><code class="literal">6</code></p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte (LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ST7735_[color]</code></p></td><td align="left" valign="top"><p>Specify color as a parameter for many GLCD commands</p></td><td align="left" valign="top"><p>Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF., see <a class="link" href="http://www.barth-dev.de/online/rgb565-color-picker/" target="_top">http://www.barth-dev.de/online/rgb565-color-picker/</a> for a wider range of color parameters.</p></td></tr></tbody></table></div><p>For a ST7735 datasheet, please refer
<a class="link" href="http://www.crystalfontz.com/controllers/ST7735_V2.1_20100505.pdf" target="_top">here.</a></p><p>For a ST7735R datasheet, please refer
<a class="link" href="https://cdn-shop.adafruit.com/datasheets/ST7735R_V0.2.pdf" target="_top">here.</a></p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    ;Chip Settings
    #chip 16F1937,32
    #config MCLRE_ON

    #include &lt;glcd.h&gt;

    'Defines for ST7735
GLCD_TYPE GLCD_TYPE_ST7735R
    'Pin mappings for ST7735
GLCD_DC porta.0
GLCD_CS porta.1
GLCD_RESET porta.2
GLCD_DI porta.3
GLCD_DO porta.4
GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the ST7735 Device")
    end</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="st7735_controllers"></span>ST7735 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the ST7735 graphics
controller. The ST7735 or ST7735R is a single-chip controller/driver for
262K-color, graphic type TFT-LCD.

GCBASIC supports 65K-color mode operations.

The GCBASIC constants shown below control the configuration of the
ST7735 or ST7735R controller.    GCBASIC supports an 8 bit bus
connectivity. The 8 bit must be a single port of consective bits - this
is shown in the tables below.

To use the ST7735 driver simply include the following in your user code.
This will initialise the driver.

``` screen
    #include <glcd.h>
    #define GLCD_TYPE GLCD_TYPE_ST7735R
    #define ST7735TABCOLOR ST7735_BLACKTAB  ; can also be ST7735_GREENTAB or ST7735_REDTAB or GLCD_TYPE_ST7735R_160_80

    'Pin mappings for ST7735
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS    porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting
```

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Options</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE</code></p></td>
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_ST7735</code> or <code class="literal">GLCD_TYPE_ST7735R</code> or <code class="literal">GLCD_TYPE_ST7735R_160_80</code></p></td>
<td style="text-align: left;"> </td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">ST7735TABCOLOR</code></p></td>
<td style="text-align: left;"><p>Specifies the type of ST7735 chipset. The default is <code class="literal">ST7735_BLACKTAB</code></p></td>
<td style="text-align: left;"><p>Options are <code class="literal">ST7735_BLACKTAB</code>, <code class="literal">ST7735_GREENTAB</code> or <code class="literal">ST7735_REDTAB</code>. Each tab is a different ST7735 configuration. If you do not know your type try each constant and test.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_DATA_PORT</code></p></td>
<td style="text-align: left;"><p>Not Available for this controller.</p></td>
<td style="text-align: left;"><p>Not applicable.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DC</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_CS</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Chip Select (CS) on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_Reset</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_DI</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_D0</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_SLK</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">ST7735_HardwareSPI</code></p></td>
<td style="text-align: left;"><p>Specifies that hardware SPI will be used</p></td>
<td style="text-align: left;"><p>SPI ports MUST be defined that match the SPI module for each specific microcontroller</p>
<p><span class="strong"><strong>#define ST7735_HardwareSPI</strong></span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>HWSPIMode</p></td>
<td style="text-align: left;"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td>
<td style="text-align: left;"><p>Optional defaults to MASTERFAST.</p>
<p>Options are MASTERSLOW,<br />
MASTER,<br />
MASTERFAST, or<br />
MASTERULTRAFAST for specific AVRs only.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">ST7735_XSTART</code></p></td>
<td style="text-align: left;"><p>Specifies the adjustment made to the X axis when writing to the GLCD. This is used to correct any geometry correction required for specific GLCDs.</p></td>
<td style="text-align: left;"><p>Optional. Defaults are set for each specific GLCD.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">ST7735_YSTART</code></p></td>
<td style="text-align: left;"><p>Specifies the adjustment made to the Y axis when writing to the GLCD. This is used to correct any geometry correction required for specific GLCDs.</p></td>
<td style="text-align: left;"><p>Optional. Defaults are set for each specific GLCD.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.  

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: center;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: center;"><p><code class="literal">160</code><br />
This cannot be changed</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: center;"><p><code class="literal">128</code><br />
This cannot be changed</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Specifies the font width of the GCBASIC font set.</p></td>
<td style="text-align: center;"><p><code class="literal">6</code></p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**Purpose**</span>                                                  | <span class="strong">**Example**</span>                                                                                                                                                   |
|:----------------------------------------|:-----------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `GLCDCLS`                               | Clear screen of GLCD                                                                     | `GLCDCLS`                                                                                                                                                                                 |
| `GLCDPrint`                             | Print string of characters on GLCD using GCB font set                                    | `GLCDPrint( Xposition, Yposition, Stringvariable )`                                                                                                                                       |
| `GLCDDrawChar`                          | Print character on GLCD using GCB font set                                               | `GLCDDrawChar( Xposition, Yposition, CharCode )`                                                                                                                                          |
| `GLCDDrawString`                        | Print characters on GLCD using GCB font set                                              | `GLCDDrawString( Xposition, Yposition, Stringvariable )`                                                                                                                                  |
| `Box`                                   | Draw a box on the GLCD to a specific size                                                | `Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )`                                                                                              |
| `FilledBox`                             | Draw a box on the GLCD to a specific size that is filled with the foreground colour.     | `FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`                                                                                            |
| `Line`                                  | Draw a line on the GLCD to a specific length that is filled with the specific attribute. | `Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`                                                                                                |
| `PSet`                                  | Set a pixel on the GLCD at a specific position that is set with the specific attribute.  | `PSet(Xposition, Yposition, Pixel Colour 0 or 1)`                                                                                                                                         |
| `GLCDWriteByte`                         | Set a byte value to the controller, see the datasheet for usage.                         | `GLCDWriteByte (LCDByte)`                                                                                                                                                                 |
| `GLCDReadByte`                          | Read a byte value from the controller, see the datasheet for usage.                      | `bytevariable = GLCDReadByte`                                                                                                                                                             |
| `ST7735_[color]`                        | Specify color as a parameter for many GLCD commands                                      | Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF., see <http://www.barth-dev.de/online/rgb565-color-picker/> for a wider range of color parameters. |

</div>

For a ST7735 datasheet, please refer
<a href="http://www.crystalfontz.com/controllers/ST7735_V2.1_20100505.pdf" class="link">here.</a>

For a ST7735R datasheet, please refer
<a href="https://cdn-shop.adafruit.com/datasheets/ST7735R_V0.2.pdf" class="link">here.</a>

<span class="strong">**Example:**</span>

``` screen
    ;Chip Settings
    #chip 16F1937,32
    #config MCLRE_ON

    #include <glcd.h>

    'Defines for ST7735
GLCD_TYPE GLCD_TYPE_ST7735R
    'Pin mappings for ST7735
GLCD_DC porta.0
GLCD_CS porta.1
GLCD_RESET porta.2
GLCD_DI porta.3
GLCD_DO porta.4
GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the ST7735 Device")
    end
```

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7789 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_st7735_controllers.html" title="ST7735 Controllers"><link rel="next" href="_st7920_controllers.html" title="ST7920 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_st7789_controllers"></a>ST7789 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the ST7789 graphics controller.  The ST7789 is a TFT LCD Single Chip Driver with 240x240 or 320x240 Resolution and 65K colors.</p><p>GCBASIC supports 65K-color mode operations.</p><p>The GCBASIC constants shown below control the configuration of the ST7789 controller. &nbsp;&nbsp;&nbsp;GCBASIC supports SPI hardware and software connectivity  - this is shown in the tables below.</p><p>To use the ST7789 driver simply include the following in your user code.  This will initialise the driver.</p><pre class="screen">    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE       GLCD_TYPE_ST7789_240_240
    //  #DEFINE GLCD_TYPE   GLCD_TYPE_ST7789_320_240

    'Pin mappings for ST7789 - these MUST be specified
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting

    'Optional to use the following - please check the datasheet for the specific GLCD.
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_DI     porta.3           'example port setting</pre><p>The GCBASIC constants for the interface to the controller are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Options</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_ST7789_240_240</code> or <code class="literal">GLCD_TYPE_ST7789_320_240</code></p></td><td align="left" valign="top"><p>Select one option to set geometry</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DC</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Reset</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DO</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_SCK</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DI</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</p></td><td align="left" valign="top"><p>Optional</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</p></td><td align="left" valign="top"><p>Optional</p></td></tr><tr><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">HWSPIMode</code></p></td><td align="left" valign="top"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td><td align="left" valign="top"><p>Optional defaults to MASTERFAST.
</p><p>Options are MASTERSLOW,<br>
MASTER,<br>
MASTERFAST, or<br>
MASTERULTRAFAST for specific AVRs only.</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Constants</th><th align="left" valign="top">Controls</th><th align="left" valign="top">Default</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">320</code> or <code class="literal">240</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">240</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Specifies the font width of the GCBASIC font set.</p></td><td align="left" valign="top"><p><code class="literal">6</code> for GCB fonts, and <code class="literal">5</code> for OLED fonts.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_OLED_FONT</code></p></td><td align="left" valign="top"><p>Specifies the use of the optional OLED font set.
</p><p>The GLCDfntDefaultsize can be set to 1 or 2 only.
</p><p><code class="literal">GLCDfntDefaultsize=  1</code>.   A small 8 height pixel font with variable width.
<code class="literal">GLCDfntDefaultsize=  2</code>.   A larger 10 width * 16 height pixel font.</p></td><td align="left" valign="top"><p>Optional</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the table below.&nbsp;&nbsp;&nbsp;Always review the appropiate library for the latest full set of supported commands.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDRotate</code></p></td><td align="left" valign="top"><p>Rotate the display</p></td><td align="left" valign="top"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ST7789_[color]</code></p></td><td align="left" valign="top"><p>Specify color as a parameter for many GLCD commands</p></td><td align="left" valign="top"><p>Color constants for this device are shown in the list below.<br></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ReadPixel</code></p></td><td align="left" valign="top"><p>Read the pixel color at the specified XY coordination.  Returns long variable with Red, Green and Blue encoded in the lower 24 bits.</p></td><td align="left" valign="top"><p>ReadPixel( Xosition , Yposition ) or ReadPixel_ST7789( Xosition , Yposition )
</p><p> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td></tr></tbody></table></div><pre class="screen">    TFT_BLACK       0x0000
    TFT_NAVY        0x000F
    TFT_DARKGREEN   0x03E0
    TFT_DARKCYAN    0x03EF
    TFT_MAROON      0x7800
    TFT_PURPLE      0x780F
    TFT_OLIVE       0x7BE0
    TFT_LIGHTGREY   0xC618
    TFT_DARKGREY    0x7BEF
    TFT_BLUE        0x001F
    TFT_GREEN       0x07E0
    TFT_CYAN        0x07FF
    TFT_RED         0xF800
    TFT_MAGENTA     0xF81F
    TFT_YELLOW      0xFFE0
    TFT_WHITE       0xFFFF
    TFT_ORANGE      0xFD20
    TFT_GREENYELLOW 0xAFE5
    TFT_PINK        0xF81F</pre><p>This example shows how to drive a ST7789 based Graphic LCD module with the built in commands of GCBASIC.</p><p>The library support PIC, AVR and LGT - change to suit your configuration.</p><p><span class="strong"><strong>Example #1</strong></span></p><pre class="screen">    #chip LGT8F328P
    #include &lt;LGT8F328P.h&gt;
    #option explicit

    #include &lt;glcd.h&gt;
    #include &lt;glcd_st7789.h&gt;
    #define ST7789_HardwareSPI
    #define HWSPIMode MASTERULTRAFAST

    // Can be either pixels geometry
        #define GLCD_TYPE GLCD_TYPE_ST7789_240_240
        //#define GLCD_TYPE GLCD_TYPE_ST7789_320_240

    //Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       DIGITAL_8           ' Data command line
    #define GLCD_CS       DIGITAL_10          ' Chip select line
    #define GLCD_RESET    DIGITAL_9           ' Reset line
    #define GLCD_DI       DIGITAL_12          ' Data in | MISO    - Not used therefore not really required
    #define GLCD_DO       DIGITAL_11          ' Data out | MOSI
    #define GLCD_SCK      DIGITAL_13          ' Clock Line

    #define GLCD_EXTENDEDFONTSET1
    GLCDBackground = TFT_BLACK
    GLCDCLS TFT_BLACK

    GLCDfntDefaultsize = 2

    GLCDRotate Portrait_Rev
    GLCDPrint (0,0,"Hello World",TFT_GREEN)

    GLCDRotate Portrait
    GLCDPrint (0,0,"Hello World",TFT_GREEN)

    GLCDROTATE Landscape
    GLCDPrint (0,0,"Hello World",TFT_GREEN)

    GLCDROTATE Landscape_Rev
    GLCDPrint (0,0,"Hello World",TFT_GREEN)</pre><p><span class="strong"><strong>Example #2</strong></span></p><p>This example shows how to drive a ST7789 using a PIC with PPS.</p><pre class="screen">    #chip 16F15376
    #option Explicit

        #startup InitPPS, 85

        Sub InitPPS
            #ifdef ST7789_HardwareSPI

                'This #ifdef is added to enable easy change from hardware SPI (using PPS) to software PPS that just uses the port assignments shown below.

                SSP1CLKPPS = 0x1    //RC3-&gt;MSSP1:SCK1
                RC3PPS = 0x15       //RC3-&gt;MSSP1:SCK1
                RC5PPS = 0x16       //RC5-&gt;MSSP1:SDO1
                SSP1DATPPS = 0x14   //RC4-&gt;MSSP1:SDI1

            #endif
        End Sub

    ' ********************** Setup the GLCD ************************************************

        #INCLUDE &lt;glcd.h&gt;
        #define GLCD_TYPE        GLCD__TYPE_ST7789_240_240
        // #define GLCD_TYPE     GLCD__TYPE_ST7789_320_240


        'This is a PPS chip, so, need to make the DO/SDO &amp; SCK match the PPS assignments
        #DEFINE GLCD_DO     portC.5
        #DEFINE GLCD_SCK    portC.3

        'Additinal pin assignments for GLCD
        #DEFINE GLCD_DC     portA.4
        #DEFINE GLCD_RESET  portA.1
        'It is optional on the ST7789 to set the GLCD_CS... therefore, here but commented out
        '#DEFINE GLCD_CS     porte.0

        'Uncomment out the next line... enable or disable the PPS!!!
        #DEFINE ST7789_HardwareSPI    ' remove/comment out if you want to use software SPI.0

    ' ********************** DEMO REALLY STARTS HERE ************************************************
    GLCDPrint(0, 0, "Test of the ST7789 Device")
    end</pre><p><br></p><p><span class="strong"><strong>Example #3</strong></span></p><p>This example shows how to drive a ILI3941 with the OLED fonts.  Note the use of the <code class="literal">GLCDfntDefaultSize</code> to select the size of the OLED font in use.
<br></p><pre class="screen">    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7789" )
    GLCDPrint ( 0, 34, "Size: "+ Str(GLCD_WIDTH) +" x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</pre><p><br></p><p><span class="strong"><strong>Example #4</strong></span></p><p>This example shows how to disable the large OLED Fontset.  This disables the font to reduce memory usage.</p><p>When the extended OLED fontset is disabled every character will be shown as a block character.</p><pre class="screen">    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts
    #define GLCD_Disable_OLED_FONT2       'The constant to disable the extended OLED fontset.

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7789" )
    GLCDPrint ( 0, 34, "Size: "+ Str(GLCD_WIDTH) +" x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</pre><p><br></p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="st7789_controllers"></span>ST7789 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the ST7789 graphics
controller. The ST7789 is a TFT LCD Single Chip Driver with 240x240 or
320x240 Resolution and 65K colors.

GCBASIC supports 65K-color mode operations.

The GCBASIC constants shown below control the configuration of the
ST7789 controller.    GCBASIC supports SPI hardware and software
connectivity - this is shown in the tables below.

To use the ST7789 driver simply include the following in your user code.
This will initialise the driver.

``` screen
    #include <glcd.h>
    #DEFINE GLCD_TYPE       GLCD_TYPE_ST7789_240_240
    //  #DEFINE GLCD_TYPE   GLCD_TYPE_ST7789_320_240

    'Pin mappings for ST7789 - these MUST be specified
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting

    'Optional to use the following - please check the datasheet for the specific GLCD.
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_DI     porta.3           'example port setting
```

The GCBASIC constants for the interface to the controller are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Constants</th>
<th style="text-align: left;">Controls</th>
<th style="text-align: left;">Options</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE</code></p></td>
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_ST7789_240_240</code> or <code class="literal">GLCD_TYPE_ST7789_320_240</code></p></td>
<td style="text-align: left;"><p>Select one option to set geometry</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DC</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_Reset</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Reset pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DO</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_SCK</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Required</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_DI</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_CS</code></p></td>
<td style="text-align: left;"><p>Specifies the output pin that is connected to Chip Select (CS) on the GLCD.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">HWSPIMode</code></p></td>
<td style="text-align: left;"><p>Specifies the speed of the SPI communications for Hardware SPI only.</p></td>
<td style="text-align: left;"><p>Optional defaults to MASTERFAST.</p>
<p>Options are MASTERSLOW,<br />
MASTER,<br />
MASTERFAST, or<br />
MASTERULTRAFAST for specific AVRs only.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Constants</th>
<th style="text-align: left;">Controls</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">320</code> or <code class="literal">240</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">240</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Specifies the font width of the GCBASIC font set.</p></td>
<td style="text-align: left;"><p><code class="literal">6</code> for GCB fonts, and <code class="literal">5</code> for OLED fonts.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_OLED_FONT</code></p></td>
<td style="text-align: left;"><p>Specifies the use of the optional OLED font set.</p>
<p>The GLCDfntDefaultsize can be set to 1 or 2 only.</p>
<p><code class="literal">GLCDfntDefaultsize=  1</code>. A small 8 height pixel font with variable width. <code class="literal">GLCDfntDefaultsize=  2</code>. A larger 10 width * 16 height pixel font.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.   Always review the appropiate library for the latest full set of
supported commands.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDCLS</code></p></td>
<td style="text-align: left;"><p>Clear screen of GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDCLS  [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDPrint</code></p></td>
<td style="text-align: left;"><p>Print string of characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar</code></p></td>
<td style="text-align: left;"><p>Print character on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDDrawString</code></p></td>
<td style="text-align: left;"><p>Print characters on GLCD using GCB font set</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Box</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size</p></td>
<td style="text-align: left;"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">FilledBox</code></p></td>
<td style="text-align: left;"><p>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</p></td>
<td style="text-align: left;"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Line</code></p></td>
<td style="text-align: left;"><p>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">PSet</code></p></td>
<td style="text-align: left;"><p>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</p></td>
<td style="text-align: left;"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour)</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte</code></p></td>
<td style="text-align: left;"><p>Set a byte value to the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">GLCDWriteByte ( LCDByte)</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDReadByte</code></p></td>
<td style="text-align: left;"><p>Read a byte value from the controller, see the datasheet for usage.</p></td>
<td style="text-align: left;"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDRotate</code></p></td>
<td style="text-align: left;"><p>Rotate the display</p></td>
<td style="text-align: left;"><p><code class="literal">LANDSCAPE</code>, <code class="literal">PORTRAIT_REV</code>, <code class="literal">LANDSCAPE_REV</code> and <code class="literal">PORTRAIT</code> are supported</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">ST7789_[color]</code></p></td>
<td style="text-align: left;"><p>Specify color as a parameter for many GLCD commands</p></td>
<td style="text-align: left;"><p>Color constants for this device are shown in the list below.<br />
</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">ReadPixel</code></p></td>
<td style="text-align: left;"><p>Read the pixel color at the specified XY coordination. Returns long variable with Red, Green and Blue encoded in the lower 24 bits.</p></td>
<td style="text-align: left;"><p>ReadPixel( Xosition , Yposition ) or ReadPixel_ST7789( Xosition , Yposition )</p>
<p>Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</p></td>
</tr>
</tbody>
</table>

</div>

``` screen
    TFT_BLACK       0x0000
    TFT_NAVY        0x000F
    TFT_DARKGREEN   0x03E0
    TFT_DARKCYAN    0x03EF
    TFT_MAROON      0x7800
    TFT_PURPLE      0x780F
    TFT_OLIVE       0x7BE0
    TFT_LIGHTGREY   0xC618
    TFT_DARKGREY    0x7BEF
    TFT_BLUE        0x001F
    TFT_GREEN       0x07E0
    TFT_CYAN        0x07FF
    TFT_RED         0xF800
    TFT_MAGENTA     0xF81F
    TFT_YELLOW      0xFFE0
    TFT_WHITE       0xFFFF
    TFT_ORANGE      0xFD20
    TFT_GREENYELLOW 0xAFE5
    TFT_PINK        0xF81F
```

This example shows how to drive a ST7789 based Graphic LCD module with
the built in commands of GCBASIC.

The library support PIC, AVR and LGT - change to suit your
configuration.

<span class="strong">**Example \#1**</span>

``` screen
    #chip LGT8F328P
    #include <LGT8F328P.h>
    #option explicit

    #include <glcd.h>
    #include <glcd_st7789.h>
    #define ST7789_HardwareSPI
    #define HWSPIMode MASTERULTRAFAST

    // Can be either pixels geometry
        #define GLCD_TYPE GLCD_TYPE_ST7789_240_240
        //#define GLCD_TYPE GLCD_TYPE_ST7789_320_240

    //Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       DIGITAL_8           ' Data command line
    #define GLCD_CS       DIGITAL_10          ' Chip select line
    #define GLCD_RESET    DIGITAL_9           ' Reset line
    #define GLCD_DI       DIGITAL_12          ' Data in | MISO    - Not used therefore not really required
    #define GLCD_DO       DIGITAL_11          ' Data out | MOSI
    #define GLCD_SCK      DIGITAL_13          ' Clock Line

    #define GLCD_EXTENDEDFONTSET1
    GLCDBackground = TFT_BLACK
    GLCDCLS TFT_BLACK

    GLCDfntDefaultsize = 2

    GLCDRotate Portrait_Rev
    GLCDPrint (0,0,"Hello World",TFT_GREEN)

    GLCDRotate Portrait
    GLCDPrint (0,0,"Hello World",TFT_GREEN)

    GLCDROTATE Landscape
    GLCDPrint (0,0,"Hello World",TFT_GREEN)

    GLCDROTATE Landscape_Rev
    GLCDPrint (0,0,"Hello World",TFT_GREEN)
```

<span class="strong">**Example \#2**</span>

This example shows how to drive a ST7789 using a PIC with PPS.

``` screen
    #chip 16F15376
    #option Explicit

        #startup InitPPS, 85

        Sub InitPPS
            #ifdef ST7789_HardwareSPI

                'This #ifdef is added to enable easy change from hardware SPI (using PPS) to software PPS that just uses the port assignments shown below.

                SSP1CLKPPS = 0x1    //RC3->MSSP1:SCK1
                RC3PPS = 0x15       //RC3->MSSP1:SCK1
                RC5PPS = 0x16       //RC5->MSSP1:SDO1
                SSP1DATPPS = 0x14   //RC4->MSSP1:SDI1

            #endif
        End Sub

    ' ********************** Setup the GLCD ************************************************

        #INCLUDE <glcd.h>
        #define GLCD_TYPE        GLCD__TYPE_ST7789_240_240
        // #define GLCD_TYPE     GLCD__TYPE_ST7789_320_240


        'This is a PPS chip, so, need to make the DO/SDO & SCK match the PPS assignments
        #DEFINE GLCD_DO     portC.5
        #DEFINE GLCD_SCK    portC.3

        'Additinal pin assignments for GLCD
        #DEFINE GLCD_DC     portA.4
        #DEFINE GLCD_RESET  portA.1
        'It is optional on the ST7789 to set the GLCD_CS... therefore, here but commented out
        '#DEFINE GLCD_CS     porte.0

        'Uncomment out the next line... enable or disable the PPS!!!
        #DEFINE ST7789_HardwareSPI    ' remove/comment out if you want to use software SPI.0

    ' ********************** DEMO REALLY STARTS HERE ************************************************
    GLCDPrint(0, 0, "Test of the ST7789 Device")
    end
```

  

<span class="strong">**Example \#3**</span>

This example shows how to drive a ILI3941 with the OLED fonts. Note the
use of the `GLCDfntDefaultSize` to select the size of the OLED font in
use.  

``` screen
    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7789" )
    GLCDPrint ( 0, 34, "Size: "+ Str(GLCD_WIDTH) +" x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")
```

  

<span class="strong">**Example \#4**</span>

This example shows how to disable the large OLED Fontset. This disables
the font to reduce memory usage.

When the extended OLED fontset is disabled every character will be shown
as a block character.

``` screen
    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts
    #define GLCD_Disable_OLED_FONT2       'The constant to disable the extended OLED fontset.

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7789" )
    GLCDPrint ( 0, 34, "Size: "+ Str(GLCD_WIDTH) +" x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")
```

  

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920cTile</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920tile.html" title="ST7920Tile"><link rel="next" href="_st7920glocate.html" title="ST7920gLocate"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920ctile"></a>ST7920cTile</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  ST7920cTile ( word variable )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Tiles screen with a Chinese Symbol.</p><p>This required 2 bytes of data into DDRAM to display one 16x16 font from
memory location A140H~D75FH are BIG5 code, A1A0H~F7FFH are GB code.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    Dim CTileValue as word
    cTileValue = (0xA140H * 256 ) + 0xA140H
    ST7920Tile (CTileValue) &#8216;tile the screen with a nice cross hatch</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920ctile"></span>ST7920cTile

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  ST7920cTile ( word variable )
```

<span class="strong">**Explanation:**</span>

Tiles screen with a Chinese Symbol.

This required 2 bytes of data into DDRAM to display one 16x16 font from
memory location A140H\~D75FH are BIG5 code, A1A0H\~F7FFH are GB code.

<span class="strong">**Example usage:**</span>

``` screen
    Dim CTileValue as word
    cTileValue = (0xA140H * 256 ) + 0xA140H
    ST7920Tile (CTileValue) ‘tile the screen with a nice cross hatch
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920GLCDClearGraphics</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="next" href="_st7920glcddisablegraphics.html" title="ST7920GLCDDisableGraphics"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920glcdcleargraphics"></a>ST7920GLCDClearGraphics</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920GLCDClearGraphics</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command clears the GCLD display.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ST7920GLCDClearGraphics 'clear the screen</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920glcdcleargraphics"></span>ST7920GLCDClearGraphics

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920GLCDClearGraphics
```

<span class="strong">**Explanation:**</span>

This command clears the GCLD display.

<span class="strong">**Example usage:**</span>

``` screen
    ST7920GLCDClearGraphics 'clear the screen
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920GLCDDisableGraphics</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920glcdcleargraphics.html" title="ST7920GLCDClearGraphics"><link rel="next" href="_st7920glcdenablegraphics.html" title="ST7920GLCDEnableGraphics"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920glcddisablegraphics"></a>ST7920GLCDDisableGraphics</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920GLCDDisableGraphics</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command sets the GCLD display controller to text mode.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ST7920GLCDDisableGraphics 'Set to text mode</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920glcddisablegraphics"></span>ST7920GLCDDisableGraphics

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920GLCDDisableGraphics
```

<span class="strong">**Explanation:**</span>

This command sets the GCLD display controller to text mode.

<span class="strong">**Example usage:**</span>

``` screen
    ST7920GLCDDisableGraphics 'Set to text mode
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920GLCDEnableGraphics</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920glcddisablegraphics.html" title="ST7920GLCDDisableGraphics"><link rel="next" href="_st7920graphictest.html" title="ST7920GraphicTest"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920glcdenablegraphics"></a>ST7920GLCDEnableGraphics</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920GLCDEnableGraphics</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command sets the GCLD display controller to text mode.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ST7920GLCDEnableGraphics 'Set to text mode</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920glcdenablegraphics"></span>ST7920GLCDEnableGraphics

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920GLCDEnableGraphics
```

<span class="strong">**Explanation:**</span>

This command sets the GCLD display controller to text mode.

<span class="strong">**Example usage:**</span>

``` screen
    ST7920GLCDEnableGraphics 'Set to text mode
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920GLCDReadByte</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920linev.html" title="ST7920linev"><link rel="next" href="_st7920writebyte.html" title="ST7920WriteByte"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920glcdreadbyte"></a>ST7920GLCDReadByte</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    byte_variable = ST7920GLCDReadByte</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This function return the word value (16 bits) of the GLCD display for
the current XY position.</p><p>This is called by the GLCD common routines.</p><p>See the data sheet for more information.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    SET GLCD_RS OFF

    ST7920WriteByte( SysCalcPositionY )
    ST7920WriteByte( SysCalcPositionX )
    ' read data
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = (GLCDDataTempWord*256) + ST7920GLCDReadByte</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920glcdreadbyte"></span>ST7920GLCDReadByte

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    byte_variable = ST7920GLCDReadByte
```

<span class="strong">**Explanation:**</span>

This function return the word value (16 bits) of the GLCD display for
the current XY position.

This is called by the GLCD common routines.

See the data sheet for more information.

<span class="strong">**Example usage:**</span>

``` screen
    SET GLCD_RS OFF

    ST7920WriteByte( SysCalcPositionY )
    ST7920WriteByte( SysCalcPositionX )
    ' read data
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = (GLCDDataTempWord*256) + ST7920GLCDReadByte
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920gLocate</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920ctile.html" title="ST7920cTile"><link rel="next" href="_st7920gtile.html" title="ST7920gTile"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920glocate"></a>ST7920gLocate</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920gLocate ( Xpos, Ypos)</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command locates the pixel at the specific X and Y location of the
graphical screen.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ST7920gLocate ( 64, 31) &#8216;the pixel at the mid screen point</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920glocate"></span>ST7920gLocate

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920gLocate ( Xpos, Ypos)
```

<span class="strong">**Explanation:**</span>

This command locates the pixel at the specific X and Y location of the
graphical screen.

<span class="strong">**Example usage:**</span>

``` screen
    ST7920gLocate ( 64, 31) ‘the pixel at the mid screen point
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920GraphicTest</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920glcdenablegraphics.html" title="ST7920GLCDEnableGraphics"><link rel="next" href="_st7920linehs.html" title="ST7920LineHs"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920graphictest"></a>ST7920GraphicTest</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920GraphicTest</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command tests the graphics functionality of the GLCD display.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ST7920GraphicTest &#8216;Test the display</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920graphictest"></span>ST7920GraphicTest

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920GraphicTest
```

<span class="strong">**Explanation:**</span>

This command tests the graphics functionality of the GLCD display.

<span class="strong">**Example usage:**</span>

``` screen
    ST7920GraphicTest ‘Test the display
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920gReaddata</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920writedata.html" title="ST7920WriteData"><link rel="next" href="_t6963_controllers.html" title="T6963 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920greaddata"></a>ST7920gReaddata</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    byte_variable = ST7920gReaddata</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This function return the word value (16 bits) of the GLCD display for
the current XY position.</p><p>See the data sheet for more information.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ...
    ' Read a word from the display device.
    word_variable = ST7920GLCDReadData</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920greaddata"></span>ST7920gReaddata

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    byte_variable = ST7920gReaddata
```

<span class="strong">**Explanation:**</span>

This function return the word value (16 bits) of the GLCD display for
the current XY position.

See the data sheet for more information.

<span class="strong">**Example usage:**</span>

``` screen
    ...
    ' Read a word from the display device.
    word_variable = ST7920GLCDReadData
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920gTile</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920glocate.html" title="ST7920gLocate"><link rel="next" href="_st7920lineh.html" title="ST7920lineh"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920gtile"></a>ST7920gTile</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920gTile ( byte variable , byte variable)</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Tile LCD screen with two bytes in Graphic Mode.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ST7920gTile (0x55, 0x85) &#8216;tile the screen with an odd cross hatch</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920gtile"></span>ST7920gTile

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920gTile ( byte variable , byte variable)
```

<span class="strong">**Explanation:**</span>

Tile LCD screen with two bytes in Graphic Mode.

<span class="strong">**Example usage:**</span>

``` screen
    ST7920gTile (0x55, 0x85) ‘tile the screen with an odd cross hatch
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920lineh</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920gtile.html" title="ST7920gTile"><link rel="next" href="_st7920linev.html" title="ST7920linev"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920lineh"></a>ST7920lineh</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920lineh ( Xpos, Ypos, xUnitsStyle, )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command draws a horizontal line with the specific style. The style
can be ON or OFF. Default is ON.</p><p>This is called by the GLCD common routines.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ST7920lineh ( 0, 31,128 , ON) &#8216;will draw a line</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920lineh"></span>ST7920lineh

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920lineh ( Xpos, Ypos, xUnitsStyle, )
```

<span class="strong">**Explanation:**</span>

This command draws a horizontal line with the specific style. The style
can be ON or OFF. Default is ON.

This is called by the GLCD common routines.

<span class="strong">**Example usage:**</span>

``` screen
    ST7920lineh ( 0, 31,128 , ON) ‘will draw a line
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920LineHs</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920graphictest.html" title="ST7920GraphicTest"><link rel="next" href="_st7920locate.html" title="ST7920Locate"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920linehs"></a>ST7920LineHs</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920LineHs ( Xpos, Ypos, XLength, Style)</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command draws a line with a specific style. The style is based on
the bits value of the byte passed to the routine.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ST7920LineHs ( 0, 31,128 , 0x55) &#8216;will draw a dashed line</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920linehs"></span>ST7920LineHs

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920LineHs ( Xpos, Ypos, XLength, Style)
```

<span class="strong">**Explanation:**</span>

This command draws a line with a specific style. The style is based on
the bits value of the byte passed to the routine.

<span class="strong">**Example usage:**</span>

``` screen
    ST7920LineHs ( 0, 31,128 , 0x55) ‘will draw a dashed line
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920linev</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920lineh.html" title="ST7920lineh"><link rel="next" href="_st7920glcdreadbyte.html" title="ST7920GLCDReadByte"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920linev"></a>ST7920linev</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920lineh ( Xpos, Ypos, xUnitsStyle, )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command draws a vertical line with the specific style. The style
can be ON or OFF. Default is ON</p><p>This is called by the GLCD common routines.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ST7920lineh ( 0, 31,128 , ON) &#8216;will draw a line</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920linev"></span>ST7920linev

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920lineh ( Xpos, Ypos, xUnitsStyle, )
```

<span class="strong">**Explanation:**</span>

This command draws a vertical line with the specific style. The style
can be ON or OFF. Default is ON

This is called by the GLCD common routines.

<span class="strong">**Example usage:**</span>

``` screen
    ST7920lineh ( 0, 31,128 , ON) ‘will draw a line
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920Locate</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920linehs.html" title="ST7920LineHs"><link rel="next" href="_st7920tile.html" title="ST7920Tile"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920locate"></a>ST7920Locate</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920Locate ( Xpos, Ypos)</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command locates the pixel at the specific X and Y location of the
text screen. Subsequent printing to the GLCD will place a character to
the GLCD controller on the specified row and column. Due to the design
of the ST7920 controller (to accomodate Mandarin and Cyrillic), you must
place the text on the column according to the numbers above the diagram
below. The addressing is handle by the command.</p><pre class="screen">|--0--|--1--|--2--|...      ...|--7--|

+--+--+--+--+--+---------------------+

|H |e |l |l |o |  ...                | &lt;- row 0 (address 0x80)

+--+--+--+--+--+---------------------+

|T |h |i |s |  |i ...                | &lt;- row 1 (address 0x90)

+--+--+--+--+--+---------------------+

|' |' |' |' |' |' ...                | &lt;- row 2 (address 0x88)

+--+--+--+--+--+---------------------+

|- |- |- |- |- |- ...                | &lt;- row 3 (address 0x98)

+--+--+--+--+--+---------------------+</pre><p>Writing 'a' onto the 1st column, and 1st row:</p><pre class="screen">|--0--|--1--|--2--|...      ...|--7--|

+--+--+--+--+--+---------------------+

|  |  |  |  |  |  ...                | &lt;- row 0 (address 0x80)

+--+--+--+--+--+---------------------+

|  |  |a |  |  |  ...                | &lt;- row 1 (address 0x90)

+--+--+--+--+--+---------------------+

|  |  |  |  |  |  ...                 | &lt;- row 2 (address 0x88)

+--+--+--+--+--+---------------------+

|  |  |  |  |  |  ...                | &lt;- row 3 (address 0x98)

+--+--+--+--+--+---------------------+</pre><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ST7920Locate ( 64, 31) &#8216;the pixel at the mid screen point</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920locate"></span>ST7920Locate

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920Locate ( Xpos, Ypos)
```

<span class="strong">**Explanation:**</span>

This command locates the pixel at the specific X and Y location of the
text screen. Subsequent printing to the GLCD will place a character to
the GLCD controller on the specified row and column. Due to the design
of the ST7920 controller (to accomodate Mandarin and Cyrillic), you must
place the text on the column according to the numbers above the diagram
below. The addressing is handle by the command.

``` screen
|--0--|--1--|--2--|...      ...|--7--|

+--+--+--+--+--+---------------------+

|H |e |l |l |o |  ...                | <- row 0 (address 0x80)

+--+--+--+--+--+---------------------+

|T |h |i |s |  |i ...                | <- row 1 (address 0x90)

+--+--+--+--+--+---------------------+

|' |' |' |' |' |' ...                | <- row 2 (address 0x88)

+--+--+--+--+--+---------------------+

|- |- |- |- |- |- ...                | <- row 3 (address 0x98)

+--+--+--+--+--+---------------------+
```

Writing 'a' onto the 1st column, and 1st row:

``` screen
|--0--|--1--|--2--|...      ...|--7--|

+--+--+--+--+--+---------------------+

|  |  |  |  |  |  ...                | <- row 0 (address 0x80)

+--+--+--+--+--+---------------------+

|  |  |a |  |  |  ...                | <- row 1 (address 0x90)

+--+--+--+--+--+---------------------+

|  |  |  |  |  |  ...                 | <- row 2 (address 0x88)

+--+--+--+--+--+---------------------+

|  |  |  |  |  |  ...                | <- row 3 (address 0x98)

+--+--+--+--+--+---------------------+
```

<span class="strong">**Example usage:**</span>

``` screen
    ST7920Locate ( 64, 31) ‘the pixel at the mid screen point
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920Tile</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920locate.html" title="ST7920Locate"><link rel="next" href="_st7920ctile.html" title="ST7920cTile"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920tile"></a>ST7920Tile</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920Tile ( word variable )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command tiles the screen with the word value provided.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    Dim tileValue as word
    tileValue = (0x55 * 256 ) + 0x55
    ST7920Tile (tileValue) &#8216;tile the screen with a nice cross hatch</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920tile"></span>ST7920Tile

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920Tile ( word variable )
```

<span class="strong">**Explanation:**</span>

This command tiles the screen with the word value provided.

<span class="strong">**Example usage:**</span>

``` screen
    Dim tileValue as word
    tileValue = (0x55 * 256 ) + 0x55
    ST7920Tile (tileValue) ‘tile the screen with a nice cross hatch
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920WriteByte</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920glcdreadbyte.html" title="ST7920GLCDReadByte"><link rel="next" href="_st7920writecommand.html" title="ST7920WriteCommand"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920writebyte"></a>ST7920WriteByte</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920GLCDWriteByte</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command write to the appropriate location as specified by the
current XY position.</p><p>This is called by the GLCD common routines.</p><p>See the data sheet for more information.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ...

    SET GLCD_RS OFF

    ST7920WriteByte( SysCalcPositionY )
    ST7920WriteByte( SysCalcPositionX )
    ' read data
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = (GLCDDataTempWord*256) + ST7920GLCDReadByte
    ...</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920writebyte"></span>ST7920WriteByte

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920GLCDWriteByte
```

<span class="strong">**Explanation:**</span>

This command write to the appropriate location as specified by the
current XY position.

This is called by the GLCD common routines.

See the data sheet for more information.

<span class="strong">**Example usage:**</span>

``` screen
    ...

    SET GLCD_RS OFF

    ST7920WriteByte( SysCalcPositionY )
    ST7920WriteByte( SysCalcPositionX )
    ' read data
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = (GLCDDataTempWord*256) + ST7920GLCDReadByte
    ...
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920WriteCommand</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920writebyte.html" title="ST7920WriteByte"><link rel="next" href="_st7920writedata.html" title="ST7920WriteData"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920writecommand"></a>ST7920WriteCommand</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920GWriteCommand ( byte_variable)</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command writes a command to the controller.</p><p>See the data sheet for more information.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ...
    ST7920WriteCommand(0x36) ' set the graphics mode on
    GLCD_TYPE_ST7920_GRAPHICS_MODE = true
    ...</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920writecommand"></span>ST7920WriteCommand

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920GWriteCommand ( byte_variable)
```

<span class="strong">**Explanation:**</span>

This command writes a command to the controller.

See the data sheet for more information.

<span class="strong">**Example usage:**</span>

``` screen
    ...
    ST7920WriteCommand(0x36) ' set the graphics mode on
    GLCD_TYPE_ST7920_GRAPHICS_MODE = true
    ...
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920WriteData</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_st7920_controllers.html" title="ST7920 Controllers"><link rel="prev" href="_st7920writecommand.html" title="ST7920WriteCommand"><link rel="next" href="_st7920greaddata.html" title="ST7920gReaddata"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_st7920writedata"></a>ST7920WriteData</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    ST7920GWriteData ( byte_variable)</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command writes data to the controller.</p><p>See the data sheet for more information.</p><p><span class="strong"><strong>Example usage:</strong></span></p><pre class="screen">    ...
    for yy = 0 to ( GLCD_HEIGHT - 1 )
      ST7920gLocate(0, yy)
      for xx = 0 to ( GLCD_COLS -1 )
        ST7920WriteData( 0x55 )
        T7920WriteData( 0x55 )
      next
    next
    ...</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="st7920writedata"></span>ST7920WriteData

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    ST7920GWriteData ( byte_variable)
```

<span class="strong">**Explanation:**</span>

This command writes data to the controller.

See the data sheet for more information.

<span class="strong">**Example usage:**</span>

``` screen
    ...
    for yy = 0 to ( GLCD_HEIGHT - 1 )
      ST7920gLocate(0, yy)
      for xx = 0 to ( GLCD_COLS -1 )
        ST7920WriteData( 0x55 )
        T7920WriteData( 0x55 )
      next
    next
    ...
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ST7920 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_st7789_controllers.html" title="ST7789 Controllers"><link rel="next" href="_st7920glcdcleargraphics.html" title="ST7920GLCDClearGraphics"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_st7920_controllers"></a>ST7920 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the ST7920 graphics controller.</p><p>The GCBASIC constants for control of the connectivity are shown
in the table below. The only connectivity option the 8-bit mode where 8
pins are connected between the microcontroller and the GLCD to control the
data bus.<br></p><p>The ST7920 GLCD is graphics and character mixed mode display.<br></p><p>ST7920 LCD controller/driver IC can display alphabets, numbers, Chinese
fonts and self-defined characters.&nbsp;&nbsp;&nbsp;It supports 3 kinds of bus interface,
namely 8-bit, 4-bit and serial.&nbsp;&nbsp;&nbsp;GCBASIC is currently supports
8-bit only. For LCD only operations (text characters only) you can use
the GCBASIC LCD routines.<br></p><p>All functions, including display RAM, Character Generation ROM, LCD
display drivers and control circuits are all in a one-chip solution.
With a minimum system configuration, a Chinese character display system
can be easily achieved.<br></p><p>The ST7920 includes character ROM with 8192 16x16 dots Chinese fonts and
126 16x8 dots half-width alphanumerical fonts.&nbsp;&nbsp;&nbsp;It supports 64x256 dots
graphic display area for graphic display (GDRAM).&nbsp;&nbsp;&nbsp;Mix-mode display with
both character and graphic data is possible.&nbsp;&nbsp;&nbsp;ST7920 has built-in CGRAM
and provide 4 sets software programmable 16x16 fonts.<br></p><p>To use the ST7920 driver simply include the following in your user code.  This will initialise the driver.<br></p><pre class="screen">    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ST7920

    #define GLCD_Enable     PORTA.1           'example port setting
    #define GLCD_RS         PORTa.0           'example port setting
    #define GLCD_RW         PORTA.2           'example port setting
    #define GLCD_RESET      PORTA.3           'example port setting
    #define GLCD_DATA_PORT  PORTD             'example port setting</pre><p>The GCBASIC constants for the interface to the controller are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_ST7920</code></p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DATA_PORT</code></p></td><td align="left" valign="top"><p>Specifies the output port that is connected between the microcontroller
and the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Register Select on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RW</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Read/Write on the GLCD.
The R/W pin can be disabled*.</p></td><td align="left" valign="top"><p><span class="strong"><strong><span class="emphasis"><em>Must be defined</em></span></strong></span> <span class="emphasis"><em>unless R/W is disabled), see</em></span> <code class="literal">GLCD_NO_RW</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RESET</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_ENABLE</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Enable on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_NO_RW</code></p></td><td align="left" valign="top"><p>Disables read/write inspection of the device during read/write
operations</p></td><td align="left" valign="top"><p>Optional, but recommend NOT to set.
The R/W pin can be disabled by setting the <code class="literal">GLCD_NO_RW</code> constant. If this
is done, there is no need for the <code class="literal">R/W</code> to be connected to the chip, and
no need for the <code class="literal">LCD_RW</code> constant to be set. Ensure that the <code class="literal">R/W</code> line on
the LCD is connected to ground if not used.</p></td></tr><tr><td colspan="3" align="left" valign="top"><p>Constants that control the timing of the library</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ST7920READDELAY</code></p></td><td align="left" valign="top"><p>Set the time delay between read data transmissions.</p></td><td align="left" valign="top"><p>Optional, set to <code class="literal">20</code> us as the default value.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">ST7920WRITEDELAY</code></p></td><td align="left" valign="top"><p>Set the time delay between write data transmissions.</p></td><td align="left" valign="top"><p>Optional, set to <code class="literal">2</code> us as the default value.
</p><p></p><p>    ' read delay of 25 is required at 32mhz, this can be reduced to 0 for slower clock speeds
    #DEFINE ST7920READDELAY 25
    ' write delay of 2 is required at 32mhz.  this can be reduced to 1 for slower clock speeds
    #DEFINE ST7920WRITEDELAY 2</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below. <br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">128</code>&nbsp;&nbsp;cannot be changed.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">64</code>&nbsp;&nbsp;cannot be changed.</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the
table below. For device specific see the commands with the prefix of
ST7920*.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td></tr><tr><td colspan="3" align="left" valign="top"><p>The following methods ( calls ) are available for expert use.
<br></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDWriteByte</code></p></td><td align="left" valign="top"><p>Set a byte value to the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">GLCDWriteByte (LCDByte)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDReadByte</code></p></td><td align="left" valign="top"><p>Read a byte value from the controller, see the datasheet for usage.</p></td><td align="left" valign="top"><p><code class="literal">bytevariable = GLCDReadByte</code></p></td></tr></tbody></table></div><p>For a TS7920 datasheet, please refer
<a class="link" href="http://www.crystalfontz.com/controllers/ST7920.pdf" target="_top">here.</a></p><p>This example shows how to drive a ST7920 based Graphic LCD module with
the built in commands of GCBASIC. See
<a class="link" href="http://www.greatcowbasic.com/sample-projects.html" target="_top">Graphic LCD</a> for
details, this is an external web site.</p><p><span class="strong"><strong>Example 1:</strong></span></p><pre class="screen">    ;Chip Settings
    #CHIP 16F1937,32
    #CONFIG  MCLRE_ON

    #INCLUDE &lt;GLCD.H&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ST7920
    #DEFINE GLCD_IO 8
    #DEFINE GLCD_WIDTH 128
    #DEFINE GLCD_HEIGHT 160
    ' read delay of 25 is required at 32mhz, this can be reduced to 0 for slower clock speeds
    #DEFINE ST7920READDELAY 25
    ' write delay of 2 is required at 32mhz.  this can be reduced to 1 for slower clock speeds
    #DEFINE ST7920WRITEDELAY 2

    #DEFINE GLCD_RS PORTA.0
    #DEFINE GLCD_ENABLE PORTA.1
    #DEFINE GLCD_RW PORTA.2
    #DEFINE GLCD_RESET PORTA.3
    #DEFINE GLCD_DATA_PORT PORTD

    ST7920GLCDEnableGraphics
    GLCDClearGraphics_ST7920
    GLCDPrint 0, 1, "GCBASIC "
    wait 1 s

    GLCDCLS
    GLCDClearGraphics_ST7920

    rrun = 0
    dim msg1 as string * 16

    dim  xradius, yordinate , radiusErr, incrementalxradius, orginalxradius, orginalyordinate as Integer


    Do forever
        GLCDCLS
        GLCDClearGraphics_ST7920          ;clear screen
        GLCDDrawString 30,0,"ChipMhz@"    ;print string
        GLCDDrawString 78,0, str(ChipMhz) ;print string
        Circle(10,10,10,0)            ;upper left
        Circle(117,10,10,0)           ;upper right
        Circle(63,31,10,0)            ;center
        Circle(63,31,20,0)            ;center
        Circle(10,53,10,0)            ;lower left
        Circle(117,53,10,0)           ;lower right
        GLCDDrawString 30,54,"PIC16F1937" ;print string
        wait 1 s                  ;wait
        FilledBox( 0,0,128,63)          ;create box
        for ypos = 0 to 63              ;draw row by row
             Line 0,ypos,128, 0      ;draw line
        next
        wait 1 s                  ;wait
        GLCDClearGraphics_ST7920          ;clear
    loop</pre><p><span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">    ;Chip Settings
    #CHIP 16F1937,32
    #CONFIG MCLRE_ON

    #INCLUDE &lt;GLCD.H&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ST7920
    #DEFINE GLCD_IO 8
    #DEFINE GLCD_WIDTH 128
    #DEFINE GLCD_HEIGHT 160

    ' read delay of 25 is required at 32mhz, this can be reduced to 0 for slower clock speeds
    #DEFINE ST7920READDELAY 25
    ' write delay of 2 is required at 32mhz.  this can be reduced to 1 for slower clock speeds
    #DEFINE ST7920WRITEDELAY 2

    #DEFINE GLCD_RS PORTA.0
    #DEFINE GLCD_ENABLE PORTA.1
    #DEFINE GLCD_RW PORTA.2
    #DEFINE GLCD_RESET PORTA.3
    #DEFINE GLCD_DATA_PORT PORTD

    WAIT 1 S
    GLCDEnableGraphics_ST7920
    GLCDClearGraphics_ST7920
    Tile_ST7920 "A"
    GLCDPrint 0, 1, "GCBASIC "

    GLCDCLS

    rrun = 0
    dim msg1 as string * 16

    do forever

    GLCDEnableGraphics_ST7920
    GLCDClearGraphics_ST7920
    GTile_ST7920 0x55, 0x55
    wait 1 s

    GLCDClearGraphics_ST7920
    Lineh_ST7920(0, 0, GLCD_WIDTH)
    Lineh_ST7920(0, GLCD_HEIGHT - 1, GLCD_WIDTH)
    Linev_ST7920(0, 0, GLCD_HEIGHT)
    Linev_ST7920(GLCD_WIDTH - 1, 0, GLCD_HEIGHT)

    Box 18,30,28,40

    WAIT 2 S

    FilledBox 18,30,28,40

    GLCDClearGraphics_ST7920

    Start:

    GLCDDrawString 0,10,"Hello" 'Print Hello
    wait 1 s
    GLCDDrawString 0,10, "ASCII #:" 'Print ASCII #:
    Box 18,30,28,40 'Draw Box Around ASCII Character
    for char = 0x30 to 0x39        'Print 0 through 9
          GLCDDrawString 16, 20 , Str(char)+"  "
          GLCDdrawCHAR 20, 30, char
          wait 250 ms
    next
    line 0,50,127,50    'Draw Line using line command
    for xvar = 0 to 80  'draw line using Pset command
            pset xvar,63,on                    '
    next
    FilledBox 18,30,28,40 'Draw Box Around ASCII Character
    Wait 1 s
    GLCDClearGraphics_ST7920
    GLCDDrawString 0,10,"End  "
    wait 1 s
    GLCDClearGraphics_ST7920

    workingGLCDDrawChar:
    GLCDEnableGraphics_ST7920
    dim gtext as string
    gtext = "ST7920 @QC12864B"

    for xchar = 1 to gtext(0)  'Print 0 through 9
          xxpos = (1+(xchar*6)-6)
          GLCDDrawChar xxpos , 0 , gtext(xchar)
    next

    GLCDDrawString  1, 9, "GCBASIC"
    GLCDDrawString  1, 18,"GLCD 128*64"
    GLCDDrawString  1, 27,"Using GLCD.H from GCB"
    GLCDDrawString  1, 37,"Using GLCD.H GCB"
    GLCDDrawString  1, 45,"GLCDDrawChar method"
    GLCDDrawString  1, 54,"Test Routines"
    wait 1 s

    GLCDClearGraphics_ST7920
    ST7920GLCDDisableGraphics
    GLCDCLS

    msg1 = "Run = " +str(rrun)
    rrun++
    GLCDPrint 0, 0, "ST7920 @QC12864B"
    GLCDPrint 0, 1, "GCBASIC "
    GLCDPrint 0, 2, "GLCD 128*64"
    GLCDPrint 0, 3, msg1
    wait 5 s
    GLCDCLS

    ' show all chars... takes some time!
    ST7920CallBuiltinChar

    wait 1 s
    GLCDCLS

    ' See http://www.khngai.com/chinese/charmap/tblbig.php?page=0
    ' and see https://sourceforge.net/projects/vietunicode/files/hannom/hannom%20v2005/ for the FONTS!!

    dim BIG5code as word

    'ST7920 can display half-width HCGROM fonts, user- defined CGRAM fonts and full 16x16 CGROM fonts. The
    'character codes in 0000H~0006H will use user- defined fonts in CGRAM. The character codes in 02H~7FH will use
    'half-width alpha numeric fonts. The character code larger than A1H will be treated as 16x16 fonts and will be
    'combined with the next byte automatically. The 16x16 BIG5 fonts are stored in A140H~D75FH while the 16x16 GB
    'fonts are stored in A1A0H~F7FFH. In short:
    '1. To display HCGROM fonts:
    'Write 2 bytes of data into DDRAM to display two 8x16 fonts. Each byte represents 1 character.
    'The data is among 02H~7FH.
    '2. To display CGRAM fonts:
    'Write 2 bytes of data into DDRAM to display one 16x16 font.
    'Only 0000H, 0002H, 0004H and 0006H are acceptable.
    '3. To display CGROM fonts:
    'Write 2 bytes of data into DDRAM to display one 16x16 font.
    'A140H~D75FH are BIG5 code, A1A0H~F7FFH are GB code.

    'To display HCGROM fonts
    ' Write 2 bytes of data into DDRAM to display two 8x16 fonts. Each byte represents 1 character.
    ' The data is among 02H~7FH.
    ' The english characters set...

    linetest1:

      GLCDEnableGraphics_ST7920

      wait 1 s
      GLCDClearGraphics_ST7920

    'lineh test
    LineH_ST7920(0, 0, GLCD_WIDTH)
    LineH_ST7920(0, GLCD_HEIGHT - 1, GLCD_WIDTH)
    LineV_ST7920(0, 0, GLCD_HEIGHT)
    LineV_ST7920(GLCD_WIDTH - 1, 0, GLCD_HEIGHT)

    ' box test
    LineH_ST7920(10 ,0 , 118 )
    LineH_ST7920(0 ,8 , 128)
    LineH_ST7920(16 ,16 , 96 )
    LineH_ST7920(10 ,32 , 108 )
    LineH_ST7920(0, 16, GLCD_WIDTH)
    LineH_ST7920(0, 24, GLCD_WIDTH)
    LineH_ST7920(0, 32, GLCD_WIDTH)
    LineH_ST7920(0, 40, GLCD_WIDTH)
    LineH_ST7920(0, 48, GLCD_WIDTH)
    LineH_ST7920(0, 56, GLCD_WIDTH)
    LineH_ST7920(0, 63, GLCD_WIDTH)
    LineV_ST7920(16, 0, GLCD_HEIGHT)
    LineV_ST7920(17, 0, GLCD_HEIGHT)
    LineV_ST7920(15, 0, GLCD_HEIGHT)

    LineV_ST7920(46, 0, GLCD_HEIGHT)
    LineV_ST7920(47, 0, GLCD_HEIGHT)
    LineV_ST7920(48, 0, GLCD_HEIGHT)

    LineV_ST7920(46, 0, GLCD_HEIGHT)
    LineV_ST7920(47, 0, GLCD_HEIGHT)
    LineV_ST7920(48, 0, GLCD_HEIGHT)

    LineV_ST7920(96, 0, GLCD_HEIGHT)
    LineV_ST7920(97, 0, GLCD_HEIGHT)
    LineV_ST7920(98, 0, GLCD_HEIGHT)

    for HCGROM = 0 to GLCD_WIDTH step 8
        LineV_ST7920(HCGROM, 0, GLCD_HEIGHT)
    next

    GraphicTestPlace:

      GLCDClearGraphics_ST7920
      GraphicTest_ST7920
      GLCDClearGraphics_ST7920

      ' Test draw a line
      for yrowpos = 0 to 63 step 4
        LineH_ST7920(0, yrowpos, GLCD_WIDTH)
      next

      GLCDClearGraphics_ST7920
      ST7920GLCDDisableGraphics
      GLCDCLS

      SetIcon_ST7920( 1, 0x55 )

    loop

    sub ST7920CallBuiltinChar
        ' 0xA140 ~ 0xA15F
          for ii = 0 to 31

              WriteData_ST7920( 0xA1)
              WriteData_ST7920( 0x40 + ii)

          next

          wait 1 s

          GLCDCLS

          ' 0xA140 ~ 0xA15F
          for ii = 0 to 31

              WriteData_ST7920( 0xA1)
              WriteData_ST7920( 0xb0 + ii)

          next
          wait 1 s
          GLCDCLS

          ' 0xA140 ~ 0xA15F
          for ii = 0 to 31

              WriteData_ST7920( 0xA4)
              WriteData_ST7920( 0x40 + ii)

          next
          wait 1 s
          GLCDCLS
    end sub</pre><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="st7920_controllers"></span>ST7920 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the ST7920 graphics
controller.

The GCBASIC constants for control of the connectivity are shown in the
table below. The only connectivity option the 8-bit mode where 8 pins
are connected between the microcontroller and the GLCD to control the
data bus.  

The ST7920 GLCD is graphics and character mixed mode display.  

ST7920 LCD controller/driver IC can display alphabets, numbers, Chinese
fonts and self-defined characters.   It supports 3 kinds of bus
interface, namely 8-bit, 4-bit and serial.   GCBASIC is currently
supports 8-bit only. For LCD only operations (text characters only) you
can use the GCBASIC LCD routines.  

All functions, including display RAM, Character Generation ROM, LCD
display drivers and control circuits are all in a one-chip solution.
With a minimum system configuration, a Chinese character display system
can be easily achieved.  

The ST7920 includes character ROM with 8192 16x16 dots Chinese fonts and
126 16x8 dots half-width alphanumerical fonts.   It supports 64x256 dots
graphic display area for graphic display (GDRAM).   Mix-mode display
with both character and graphic data is possible.   ST7920 has built-in
CGRAM and provide 4 sets software programmable 16x16 fonts.  

To use the ST7920 driver simply include the following in your user code.
This will initialise the driver.  

``` screen
    #include <glcd.h>
    #DEFINE GLCD_TYPE GLCD_TYPE_ST7920

    #define GLCD_Enable     PORTA.1           'example port setting
    #define GLCD_RS         PORTa.0           'example port setting
    #define GLCD_RW         PORTA.2           'example port setting
    #define GLCD_RESET      PORTA.3           'example port setting
    #define GLCD_DATA_PORT  PORTD             'example port setting
```

The GCBASIC constants for the interface to the controller are shown in
the table below.

<div class="informaltable">

<span class="strong">**Constants**</span>

</div>

</div>

<span class="strong">**Controls**</span>

<span class="strong">**Options**</span>

`GLCD_TYPE`

`GLCD_TYPE_ST7920`

Required

`GLCD_DATA_PORT`

Specifies the output port that is connected between the microcontroller
and the GLCD.

Required

`GLCD_RS`

Specifies the output pin that is connected to Register Select on the
GLCD.

Required

`GLCD_RW`

Specifies the output pin that is connected to Read/Write on the GLCD.
The R/W pin can be disabled\*.

<span class="strong">**<span class="emphasis">*Must be
defined*</span>**</span> <span class="emphasis">*unless R/W is
disabled), see*</span> `GLCD_NO_RW`

`GLCD_RESET`

Specifies the output pin that is connected to Reset on the GLCD.

Required

`GLCD_ENABLE`

Specifies the output pin that is connected to Enable on the GLCD.

Required

`GLCD_NO_RW`

Disables read/write inspection of the device during read/write
operations

Optional, but recommend NOT to set. The R/W pin can be disabled by
setting the `GLCD_NO_RW` constant. If this is done, there is no need for
the `R/W` to be connected to the chip, and no need for the `LCD_RW`
constant to be set. Ensure that the `R/W` line on the LCD is connected
to ground if not used.

Constants that control the timing of the library

`ST7920READDELAY`

Set the time delay between read data transmissions.

Optional, set to `20` us as the default value.

`ST7920WRITEDELAY`

Set the time delay between write data transmissions.

Optional, set to `2` us as the default value.

' read delay of 25 is required at 32mhz, this can be reduced to 0 for
slower clock speeds \#DEFINE ST7920READDELAY 25 ' write delay of 2 is
required at 32mhz. this can be reduced to 1 for slower clock speeds
\#DEFINE ST7920WRITEDELAY 2

The GCBASIC constants for control display characteristics are shown in
the table below.  

<div class="informaltable">

| <span class="strong">**Constants**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Default**</span> |
|:------------------------------------------|:-----------------------------------------|:----------------------------------------|
| `GLCD_WIDTH`                              | The width parameter of the GLCD          | `128`  cannot be changed.               |
| `GLCD_HEIGHT`                             | The height parameter of the GLCD         | `64`  cannot be changed.                |

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below. For device specific see the commands with the prefix of ST7920\*.

<div class="informaltable">

<span class="strong">**Command**</span>

</div>

<span class="strong">**Purpose**</span>

<span class="strong">**Example**</span>

`GLCDCLS`

Clear screen of GLCD

`GLCDCLS`

`GLCDPrint`

Print string of characters on GLCD using GCB font set

`GLCDPrint( Xposition, Yposition, Stringvariable )`

`GLCDDrawChar`

Print character on GLCD using GCB font set

`GLCDDrawChar( Xposition, Yposition, CharCode )`

`GLCDDrawString`

Print characters on GLCD using GCB font set

`GLCDDrawString( Xposition, Yposition, Stringvariable )`

`Box`

Draw a box on the GLCD to a specific size

`Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )`

`FilledBox`

Draw a box on the GLCD to a specific size that is filled with the
foreground colour.

`FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`

`Line`

Draw a line on the GLCD to a specific length that is filled with the
specific attribute.

`Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`

`PSet`

Set a pixel on the GLCD at a specific position that is set with the
specific attribute.

`PSet(Xposition, Yposition, Pixel Colour 0 or 1)`

The following methods ( calls ) are available for expert use.  

`GLCDWriteByte`

Set a byte value to the controller, see the datasheet for usage.

`GLCDWriteByte (LCDByte)`

`GLCDReadByte`

Read a byte value from the controller, see the datasheet for usage.

`bytevariable = GLCDReadByte`

For a TS7920 datasheet, please refer
<a href="http://www.crystalfontz.com/controllers/ST7920.pdf" class="link">here.</a>

This example shows how to drive a ST7920 based Graphic LCD module with
the built in commands of GCBASIC. See
<a href="http://www.greatcowbasic.com/sample-projects" class="link">Graphic LCD</a>
for details, this is an external web site.

<span class="strong">**Example 1:**</span>

``` screen
    ;Chip Settings
    #CHIP 16F1937,32
    #CONFIG  MCLRE_ON

    #INCLUDE <GLCD.H>
    #DEFINE GLCD_TYPE GLCD_TYPE_ST7920
    #DEFINE GLCD_IO 8
    #DEFINE GLCD_WIDTH 128
    #DEFINE GLCD_HEIGHT 160
    ' read delay of 25 is required at 32mhz, this can be reduced to 0 for slower clock speeds
    #DEFINE ST7920READDELAY 25
    ' write delay of 2 is required at 32mhz.  this can be reduced to 1 for slower clock speeds
    #DEFINE ST7920WRITEDELAY 2

    #DEFINE GLCD_RS PORTA.0
    #DEFINE GLCD_ENABLE PORTA.1
    #DEFINE GLCD_RW PORTA.2
    #DEFINE GLCD_RESET PORTA.3
    #DEFINE GLCD_DATA_PORT PORTD

    ST7920GLCDEnableGraphics
    GLCDClearGraphics_ST7920
    GLCDPrint 0, 1, "GCBASIC "
    wait 1 s

    GLCDCLS
    GLCDClearGraphics_ST7920

    rrun = 0
    dim msg1 as string * 16

    dim  xradius, yordinate , radiusErr, incrementalxradius, orginalxradius, orginalyordinate as Integer


    Do forever
        GLCDCLS
        GLCDClearGraphics_ST7920          ;clear screen
        GLCDDrawString 30,0,"ChipMhz@"    ;print string
        GLCDDrawString 78,0, str(ChipMhz) ;print string
        Circle(10,10,10,0)            ;upper left
        Circle(117,10,10,0)           ;upper right
        Circle(63,31,10,0)            ;center
        Circle(63,31,20,0)            ;center
        Circle(10,53,10,0)            ;lower left
        Circle(117,53,10,0)           ;lower right
        GLCDDrawString 30,54,"PIC16F1937" ;print string
        wait 1 s                  ;wait
        FilledBox( 0,0,128,63)          ;create box
        for ypos = 0 to 63              ;draw row by row
             Line 0,ypos,128, 0      ;draw line
        next
        wait 1 s                  ;wait
        GLCDClearGraphics_ST7920          ;clear
    loop
```

<span class="strong">**Example 2:**</span>

``` screen
    ;Chip Settings
    #CHIP 16F1937,32
    #CONFIG MCLRE_ON

    #INCLUDE <GLCD.H>
    #DEFINE GLCD_TYPE GLCD_TYPE_ST7920
    #DEFINE GLCD_IO 8
    #DEFINE GLCD_WIDTH 128
    #DEFINE GLCD_HEIGHT 160

    ' read delay of 25 is required at 32mhz, this can be reduced to 0 for slower clock speeds
    #DEFINE ST7920READDELAY 25
    ' write delay of 2 is required at 32mhz.  this can be reduced to 1 for slower clock speeds
    #DEFINE ST7920WRITEDELAY 2

    #DEFINE GLCD_RS PORTA.0
    #DEFINE GLCD_ENABLE PORTA.1
    #DEFINE GLCD_RW PORTA.2
    #DEFINE GLCD_RESET PORTA.3
    #DEFINE GLCD_DATA_PORT PORTD

    WAIT 1 S
    GLCDEnableGraphics_ST7920
    GLCDClearGraphics_ST7920
    Tile_ST7920 "A"
    GLCDPrint 0, 1, "GCBASIC "

    GLCDCLS

    rrun = 0
    dim msg1 as string * 16

    do forever

    GLCDEnableGraphics_ST7920
    GLCDClearGraphics_ST7920
    GTile_ST7920 0x55, 0x55
    wait 1 s

    GLCDClearGraphics_ST7920
    Lineh_ST7920(0, 0, GLCD_WIDTH)
    Lineh_ST7920(0, GLCD_HEIGHT - 1, GLCD_WIDTH)
    Linev_ST7920(0, 0, GLCD_HEIGHT)
    Linev_ST7920(GLCD_WIDTH - 1, 0, GLCD_HEIGHT)

    Box 18,30,28,40

    WAIT 2 S

    FilledBox 18,30,28,40

    GLCDClearGraphics_ST7920

    Start:

    GLCDDrawString 0,10,"Hello" 'Print Hello
    wait 1 s
    GLCDDrawString 0,10, "ASCII #:" 'Print ASCII #:
    Box 18,30,28,40 'Draw Box Around ASCII Character
    for char = 0x30 to 0x39        'Print 0 through 9
          GLCDDrawString 16, 20 , Str(char)+"  "
          GLCDdrawCHAR 20, 30, char
          wait 250 ms
    next
    line 0,50,127,50    'Draw Line using line command
    for xvar = 0 to 80  'draw line using Pset command
            pset xvar,63,on                    '
    next
    FilledBox 18,30,28,40 'Draw Box Around ASCII Character
    Wait 1 s
    GLCDClearGraphics_ST7920
    GLCDDrawString 0,10,"End  "
    wait 1 s
    GLCDClearGraphics_ST7920

    workingGLCDDrawChar:
    GLCDEnableGraphics_ST7920
    dim gtext as string
    gtext = "ST7920 @QC12864B"

    for xchar = 1 to gtext(0)  'Print 0 through 9
          xxpos = (1+(xchar*6)-6)
          GLCDDrawChar xxpos , 0 , gtext(xchar)
    next

    GLCDDrawString  1, 9, "GCBASIC"
    GLCDDrawString  1, 18,"GLCD 128*64"
    GLCDDrawString  1, 27,"Using GLCD.H from GCB"
    GLCDDrawString  1, 37,"Using GLCD.H GCB"
    GLCDDrawString  1, 45,"GLCDDrawChar method"
    GLCDDrawString  1, 54,"Test Routines"
    wait 1 s

    GLCDClearGraphics_ST7920
    ST7920GLCDDisableGraphics
    GLCDCLS

    msg1 = "Run = " +str(rrun)
    rrun++
    GLCDPrint 0, 0, "ST7920 @QC12864B"
    GLCDPrint 0, 1, "GCBASIC "
    GLCDPrint 0, 2, "GLCD 128*64"
    GLCDPrint 0, 3, msg1
    wait 5 s
    GLCDCLS

    ' show all chars... takes some time!
    ST7920CallBuiltinChar

    wait 1 s
    GLCDCLS

    ' See http://www.khngai.com/chinese/charmap/tblbig.php?page=0
    ' and see https://sourceforge.net/projects/vietunicode/files/hannom/hannom%20v2005/ for the FONTS!!

    dim BIG5code as word

    'ST7920 can display half-width HCGROM fonts, user- defined CGRAM fonts and full 16x16 CGROM fonts. The
    'character codes in 0000H~0006H will use user- defined fonts in CGRAM. The character codes in 02H~7FH will use
    'half-width alpha numeric fonts. The character code larger than A1H will be treated as 16x16 fonts and will be
    'combined with the next byte automatically. The 16x16 BIG5 fonts are stored in A140H~D75FH while the 16x16 GB
    'fonts are stored in A1A0H~F7FFH. In short:
    '1. To display HCGROM fonts:
    'Write 2 bytes of data into DDRAM to display two 8x16 fonts. Each byte represents 1 character.
    'The data is among 02H~7FH.
    '2. To display CGRAM fonts:
    'Write 2 bytes of data into DDRAM to display one 16x16 font.
    'Only 0000H, 0002H, 0004H and 0006H are acceptable.
    '3. To display CGROM fonts:
    'Write 2 bytes of data into DDRAM to display one 16x16 font.
    'A140H~D75FH are BIG5 code, A1A0H~F7FFH are GB code.

    'To display HCGROM fonts
    ' Write 2 bytes of data into DDRAM to display two 8x16 fonts. Each byte represents 1 character.
    ' The data is among 02H~7FH.
    ' The english characters set...

    linetest1:

      GLCDEnableGraphics_ST7920

      wait 1 s
      GLCDClearGraphics_ST7920

    'lineh test
    LineH_ST7920(0, 0, GLCD_WIDTH)
    LineH_ST7920(0, GLCD_HEIGHT - 1, GLCD_WIDTH)
    LineV_ST7920(0, 0, GLCD_HEIGHT)
    LineV_ST7920(GLCD_WIDTH - 1, 0, GLCD_HEIGHT)

    ' box test
    LineH_ST7920(10 ,0 , 118 )
    LineH_ST7920(0 ,8 , 128)
    LineH_ST7920(16 ,16 , 96 )
    LineH_ST7920(10 ,32 , 108 )
    LineH_ST7920(0, 16, GLCD_WIDTH)
    LineH_ST7920(0, 24, GLCD_WIDTH)
    LineH_ST7920(0, 32, GLCD_WIDTH)
    LineH_ST7920(0, 40, GLCD_WIDTH)
    LineH_ST7920(0, 48, GLCD_WIDTH)
    LineH_ST7920(0, 56, GLCD_WIDTH)
    LineH_ST7920(0, 63, GLCD_WIDTH)
    LineV_ST7920(16, 0, GLCD_HEIGHT)
    LineV_ST7920(17, 0, GLCD_HEIGHT)
    LineV_ST7920(15, 0, GLCD_HEIGHT)

    LineV_ST7920(46, 0, GLCD_HEIGHT)
    LineV_ST7920(47, 0, GLCD_HEIGHT)
    LineV_ST7920(48, 0, GLCD_HEIGHT)

    LineV_ST7920(46, 0, GLCD_HEIGHT)
    LineV_ST7920(47, 0, GLCD_HEIGHT)
    LineV_ST7920(48, 0, GLCD_HEIGHT)

    LineV_ST7920(96, 0, GLCD_HEIGHT)
    LineV_ST7920(97, 0, GLCD_HEIGHT)
    LineV_ST7920(98, 0, GLCD_HEIGHT)

    for HCGROM = 0 to GLCD_WIDTH step 8
        LineV_ST7920(HCGROM, 0, GLCD_HEIGHT)
    next

    GraphicTestPlace:

      GLCDClearGraphics_ST7920
      GraphicTest_ST7920
      GLCDClearGraphics_ST7920

      ' Test draw a line
      for yrowpos = 0 to 63 step 4
        LineH_ST7920(0, yrowpos, GLCD_WIDTH)
      next

      GLCDClearGraphics_ST7920
      ST7920GLCDDisableGraphics
      GLCDCLS

      SetIcon_ST7920( 1, 0x55 )

    loop

    sub ST7920CallBuiltinChar
        ' 0xA140 ~ 0xA15F
          for ii = 0 to 31

              WriteData_ST7920( 0xA1)
              WriteData_ST7920( 0x40 + ii)

          next

          wait 1 s

          GLCDCLS

          ' 0xA140 ~ 0xA15F
          for ii = 0 to 31

              WriteData_ST7920( 0xA1)
              WriteData_ST7920( 0xb0 + ii)

          next
          wait 1 s
          GLCDCLS

          ' 0xA140 ~ 0xA15F
          for ii = 0 to 31

              WriteData_ST7920( 0xA4)
              WriteData_ST7920( 0x40 + ii)

          next
          wait 1 s
          GLCDCLS
    end sub
```

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>StartTimer</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_settimer.html" title="Settimer"><link rel="next" href="_stoptimer.html" title="StopTimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_starttimer"></a>StartTimer</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    StartTimer <span class="emphasis"><em>TimerNo</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a Timer module.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">StartTimer</code> is used to start the specified timer.</p><p><span class="strong"><strong>Timer 0:</strong></span></p><p>Please refer to the datasheet to determine if Timer 0 on specific Microchip PIC microcontroller
can be started and stopped with <code class="literal">starttimer</code> and <code class="literal">stoptimer</code>. If the Microchip PIC microcontroller
has a register named "T0CON"  then it supports <code class="literal">stoptimer</code> and <code class="literal">starttimer</code>.</p><p>On Microchip PIC 18(L)Fxxx microcontrollers Timer 0 can be started  with <code class="literal">starttimer</code>.<br>
On Microchip PIC baseline and midrange microcontrollers <code class="literal">starttimer</code> (and <code class="literal">stoptimer</code>) has no effect upon Timer 0.</p><p><br>
<br>
<br>
<span class="strong"><strong>Example:</strong></span></p><p>This example will measure that time that a switch is depressed (or on) and will write the results to the EEPROM.</p><pre class="screen">    #chip 16F819, 20
    #define Switch PORTA.0

    Dir Switch In
    DataCount = 0

    'Initilise Timer 1
    InitTimer1 Osc, PS1_8

    Dim TimerValue As Word

    Do
        ClearTimer 1
        Wait Until Switch = On
        StartTimer 1
        Wait Until Switch = Off
        StopTimer 1

        'Read the timer
        TimerValue = Timer1

        'Log the timer value
        EPWrite(DataCount, TimerValue_H)
        EPWrite(DataCount + 1, TimerValue)
        DataCount += 2
    Loop</pre><p><span class="strong"><strong>Supported in &lt;TIMER.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="starttimer"></span>StartTimer

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    StartTimer TimerNo
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a Timer module.

<span class="strong">**Explanation:**</span>

`StartTimer` is used to start the specified timer.

<span class="strong">**Timer 0:**</span>

Please refer to the datasheet to determine if Timer 0 on specific
Microchip PIC microcontroller can be started and stopped with
`starttimer` and `stoptimer`. If the Microchip PIC microcontroller has a
register named "T0CON" then it supports `stoptimer` and `starttimer`.

On Microchip PIC 18(L)Fxxx microcontrollers Timer 0 can be started with
`starttimer`.  
On Microchip PIC baseline and midrange microcontrollers `starttimer`
(and `stoptimer`) has no effect upon Timer 0.

  
  
  
<span class="strong">**Example:**</span>

This example will measure that time that a switch is depressed (or on)
and will write the results to the EEPROM.

``` screen
    #chip 16F819, 20
    #define Switch PORTA.0

    Dir Switch In
    DataCount = 0

    'Initilise Timer 1
    InitTimer1 Osc, PS1_8

    Dim TimerValue As Word

    Do
        ClearTimer 1
        Wait Until Switch = On
        StartTimer 1
        Wait Until Switch = Off
        StopTimer 1

        'Read the timer
        TimerValue = Timer1

        'Log the timer value
        EPWrite(DataCount, TimerValue_H)
        EPWrite(DataCount + 1, TimerValue)
        DataCount += 2
    Loop
```

<span class="strong">**Supported in &lt;TIMER.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>StopTimer</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_starttimer.html" title="StartTimer"><link rel="next" href="_reading_timers.html" title="Reading Timers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_stoptimer"></a>StopTimer</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    StopTimer <span class="emphasis"><em>TimerNo</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a Timer modules.
<span class="strong"><strong>Explanation:</strong></span></p><p>On the Microchip PIC 18(L)Fxxx microcontrollers Timer 0 can be stopped  with <code class="literal">stopttimer</code>.<br>
With respect to Timer 0 on the Microchip PIC baseline and midrage range of microcontrollers <code class="literal">stoptimer</code> (and <code class="literal">starttimer</code>) has no effect as Timer 0.</p><p><br>
<br>
<br>
<span class="strong"><strong>Example:</strong></span></p><p>This example will measure that time that a switch is depressed (or on) and will write the results to the EEPROM. <br>
The example shows how to stop a timer when not in use.</p><pre class="screen">    #chip 16F819, 20
    #define Switch PORTA.0

    Dir Switch In
    DataCount = 0

    'Initilise Timer 1
    InitTimer1 Osc, PS1_8

    Dim TimerValue As Word

    Do
        ClearTimer 1
        Wait Until Switch = On
        StartTimer 1
        Wait Until Switch = Off
        StopTimer 1

        'Read the timer
        TimerValue = Timer1

        'Log the timer value
        EPWrite(DataCount, TimerValue_H)
        EPWrite(DataCount + 1, TimerValue)
        DataCount += 2
    Loop</pre><p><span class="strong"><strong>Supported in &lt;TIMER.H&gt;</strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="stoptimer"></span>StopTimer

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    StopTimer TimerNo
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers with a Timer modules. <span
class="strong">**Explanation:**</span>

On the Microchip PIC 18(L)Fxxx microcontrollers Timer 0 can be stopped
with `stopttimer`.  
With respect to Timer 0 on the Microchip PIC baseline and midrage range
of microcontrollers `stoptimer` (and `starttimer`) has no effect as
Timer 0.

  
  
  
<span class="strong">**Example:**</span>

This example will measure that time that a switch is depressed (or on)
and will write the results to the EEPROM.  
The example shows how to stop a timer when not in use.

``` screen
    #chip 16F819, 20
    #define Switch PORTA.0

    Dir Switch In
    DataCount = 0

    'Initilise Timer 1
    InitTimer1 Osc, PS1_8

    Dim TimerValue As Word

    Do
        ClearTimer 1
        Wait Until Switch = On
        StartTimer 1
        Wait Until Switch = Off
        StopTimer 1

        'Read the timer
        TimerValue = Timer1

        'Log the timer value
        EPWrite(DataCount, TimerValue_H)
        EPWrite(DataCount + 1, TimerValue)
        DataCount += 2
    Loop
```

<span class="strong">**Supported in &lt;TIMER.H&gt;**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Str</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_rtrim.html" title="Rtrim"><link rel="next" href="_trim.html" title="Trim"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_str"></a>Str</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    <span class="emphasis"><em>stringvar</em></span> = Str(<span class="emphasis"><em>number</em></span>)     'supports decimal byte and word strings only.

    'Use the following to support decimal long number strings.
    <span class="emphasis"><em>stringvar</em></span> = Str32(<span class="emphasis"><em>long number</em></span>)     'supports  decimal long number strings.

    'Use the following to support decimal integer number strings.
    <span class="emphasis"><em>stringvar</em></span> = StrInteger(<span class="emphasis"><em>integer number</em></span>)     ' decimal integer number strings.</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Str</code> function will convert a number into a string. <code class="literal"><span class="emphasis"><em>number</em></span></code> can be any byte or word variable, or a fixed number between 0 and 65535 inclusive.&nbsp;&nbsp;For Long numbers use <code class="literal">Str32</code> and for Integer numbers use <code class="literal">StrInteger</code>.</p><p>The string variable <code class="literal"><span class="emphasis"><em>stringvar</em></span></code> will contain the same number, represented as a string.&nbsp;&nbsp;The length of the string returned is 5, 10 or 6 characters for Byte &amp; Word, Long and Integer respectively.</p><p>This function is especially useful if a number needs to added to the end of a string, or if a custom data sending routine has been created but only supports the output of string variables.
<br>
<br>
These methods will not support  conversion of hexadecimal number strings.
<br>
<br>
<span class="strong"><strong>Example1:</strong></span></p><pre class="screen">    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Take an A/D reading
    SensorReading = ReadAD(AN0)

    'Create a string variable
    Dim OutVar As String

    'Fill string with sensor reading
    OutVar = Str(SensorReading)

    'Send
    HSerPrint OutVar
    HSerPrintCRLF

    When using the functions STR() do not leave space between the function
    call and the left brace. You will get a compiler error that is
    meaningless.

    ' use this, note this is no space between the STR and the left brace!
    STR(number_variable)
    ' do not use, note the space!
    STR (number_variable)</pre><p><br>
<br>
<span class="strong"><strong>Example2:</strong></span></p><pre class="screen">    '''
    '''
    '''
    '''
    '''************************************************************************
    '''
    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCB@SYN
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: June 2021
    '''
    ' ----- Configuration
      'Chip Settings.
      #chip 16f18855,32
      #Config CLRE_ON
      #option Explicit

    ; ----- Define Hardware settings

      '' -------------------LATA-----------------
      '' Bit#:  -7---6---5---4---3---2---1---0---
      '' LED:   ---------------|D5 |D4 |D3 |D2 |-
      ''-----------------------------------------
      ''

      'Set the PPS of the RS232 ports.
      UNLOCKPPS
        RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
      LOCKPPS

    ; ----- Constants
      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

      #define LEDD2 PORTA.0
      #define LEDD3 PORTA.1
      #define LEDD4 PORTA.2
      #define LEDD5 PORTA.3
      Dir     LEDD2 OUT
      Dir     LEDD3 OUT
      Dir     LEDD4 OUT
      Dir     LEDD5 OUT


      #define Potentiometer       PORTA.4
      DIR     Potentiometer In

      #define SWITCH_DOWN         0
      #define SWITCH_UP           1
      #define SWITCH              PORTA.5
      Dir SWITCH                  In

    ; ----- Variables
    dim bytevar as Byte
    dim wordvar as Word
    dim longvar as long
    dim integervarP, integervarN,integervar as Integer

    ; ----- Main body of program commences here.
    bytevar = 0xff
    wordvar = 0xffff
    longvar = 0xffffffff
    integervarP = 127
    integervarN = -127
    integervar = 0

    do
       wait 100 ms

       HSerPrint str( bytevar )
       HSerPrintCRLF
       HSerPrint str( wordvar )
       HSerPrintCRLF
       HSerPrint str32( longvar )
       HSerPrintCRLF
       HSerPrint StrInteger( integervarP )
       HSerPrintCRLF
       HSerPrint StrInteger( integervarN )
       HSerPrintCRLF
       HSerPrint StrInteger( integervar )
       HSerPrintCRLF
       wait 100 ms
       HSerPrintCRLF

       wait 1 s
    loop
    end

; ----- Support methods.  Subroutines and Functions</pre><p><br>
<br>
<span class="strong"><strong>See Also</strong></span> <a class="link" href="_hex.html" title="Hex">Hex</a>, <a class="link" href="_val.html" title="Val">Val</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="str"></span>Str

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    stringvar = Str(number)     'supports decimal byte and word strings only.

    'Use the following to support decimal long number strings.
    stringvar = Str32(long number)     'supports  decimal long number strings.

    'Use the following to support decimal integer number strings.
    stringvar = StrInteger(integer number)     ' decimal integer number strings.
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Str` function will convert a number into a string. `number` can be
any byte or word variable, or a fixed number between 0 and 65535
inclusive.  For Long numbers use `Str32` and for Integer numbers use
`StrInteger`.

The string variable `stringvar` will contain the same number,
represented as a string.  The length of the string returned is 5, 10 or
6 characters for Byte & Word, Long and Integer respectively.

This function is especially useful if a number needs to added to the end
of a string, or if a custom data sending routine has been created but
only supports the output of string variables.  
  
These methods will not support conversion of hexadecimal number
strings.  
  
<span class="strong">**Example1:**</span>

``` screen
    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Take an A/D reading
    SensorReading = ReadAD(AN0)

    'Create a string variable
    Dim OutVar As String

    'Fill string with sensor reading
    OutVar = Str(SensorReading)

    'Send
    HSerPrint OutVar
    HSerPrintCRLF

    When using the functions STR() do not leave space between the function
    call and the left brace. You will get a compiler error that is
    meaningless.

    ' use this, note this is no space between the STR and the left brace!
    STR(number_variable)
    ' do not use, note the space!
    STR (number_variable)
```

  
  
<span class="strong">**Example2:**</span>

``` screen
    '''
    '''
    '''
    '''
    '''************************************************************************
    '''
    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCB@SYN
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: June 2021
    '''
    ' ----- Configuration
      'Chip Settings.
      #chip 16f18855,32
      #Config CLRE_ON
      #option Explicit

    ; ----- Define Hardware settings

      '' -------------------LATA-----------------
      '' Bit#:  -7---6---5---4---3---2---1---0---
      '' LED:   ---------------|D5 |D4 |D3 |D2 |-
      ''-----------------------------------------
      ''

      'Set the PPS of the RS232 ports.
      UNLOCKPPS
        RC0PPS = 0x0010     'RC0->EUSART:TX;
        RXPPS  = 0x0011     'RC1->EUSART:RX;
      LOCKPPS

    ; ----- Constants
      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

      #define LEDD2 PORTA.0
      #define LEDD3 PORTA.1
      #define LEDD4 PORTA.2
      #define LEDD5 PORTA.3
      Dir     LEDD2 OUT
      Dir     LEDD3 OUT
      Dir     LEDD4 OUT
      Dir     LEDD5 OUT


      #define Potentiometer       PORTA.4
      DIR     Potentiometer In

      #define SWITCH_DOWN         0
      #define SWITCH_UP           1
      #define SWITCH              PORTA.5
      Dir SWITCH                  In

    ; ----- Variables
    dim bytevar as Byte
    dim wordvar as Word
    dim longvar as long
    dim integervarP, integervarN,integervar as Integer

    ; ----- Main body of program commences here.
    bytevar = 0xff
    wordvar = 0xffff
    longvar = 0xffffffff
    integervarP = 127
    integervarN = -127
    integervar = 0

    do
       wait 100 ms

       HSerPrint str( bytevar )
       HSerPrintCRLF
       HSerPrint str( wordvar )
       HSerPrintCRLF
       HSerPrint str32( longvar )
       HSerPrintCRLF
       HSerPrint StrInteger( integervarP )
       HSerPrintCRLF
       HSerPrint StrInteger( integervarN )
       HSerPrintCRLF
       HSerPrint StrInteger( integervar )
       HSerPrintCRLF
       wait 100 ms
       HSerPrintCRLF

       wait 1 s
    loop
    end

; ----- Support methods.  Subroutines and Functions
```

  
  
<span class="strong">**See Also**</span>
<a href="hex" class="link" title="Hex">Hex</a>,
<a href="val" class="link" title="Val">Val</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>String Manipulation</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_swap.html" title="SWAP"><link rel="next" href="_asc.html" title="Asc"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_string_manipulation"></a>String Manipulation</h3></div></div></div><p>This is the String Manipulation section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p><p><a class="link" href="_asc.html" title="Asc">Asc</a>,
<a class="link" href="_bytetobin.html" title="ByteToBin">Bytetobin</a>,
<a class="link" href="_chr.html" title="Chr">Chr</a>,
<a class="link" href="_fill.html" title="Fill">Fill</a>,
<a class="link" href="_hex.html" title="Hex">Hex</a>,
<a class="link" href="_instr.html" title="Instr">Instr</a>,
<a class="link" href="_lcase.html" title="LCase">Lcase</a>,
<a class="link" href="_left.html" title="Left">Left</a>,
<a class="link" href="_leftpad.html" title="LeftPad">Leftpad</a>,
<a class="link" href="_len.html" title="Len">Len</a>,
<a class="link" href="_mid.html" title="Mid">Mid</a>,
<a class="link" href="_pad.html" title="Pad">Pad</a>,
<a class="link" href="_right.html" title="Right">Right</a>,
<a class="link" href="_rtrim.html" title="Rtrim">Rtrim</a>,
<a class="link" href="_str.html" title="Str">Str</a>,
<a class="link" href="_trim.html" title="Trim">Trim</a>,
<a class="link" href="_ucase.html" title="UCase">Ucase</a>,
<a class="link" href="_val.html" title="Val">Val</a>,
<a class="link" href="_wordtobin.html" title="WordToBin">Wordtobin</a>,
<a class="link" href="_setting_variables.html" title="Setting Variables">Setting Variables</a> or
<a class="link" href="_concatenation.html" title="Concatenation">concatenation</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="string_manipulation"></span>String Manipulation

</div>

</div>

</div>

This is the String Manipulation section of the Help file. Please refer
the sub-sections for details using the contents/folder view.

<a href="asc" class="link" title="Asc">Asc</a>,
<a href="bytetobin" class="link" title="ByteToBin">Bytetobin</a>,
<a href="chr" class="link" title="Chr">Chr</a>,
<a href="fill" class="link" title="Fill">Fill</a>,
<a href="hex" class="link" title="Hex">Hex</a>,
<a href="instr" class="link" title="Instr">Instr</a>,
<a href="lcase" class="link" title="LCase">Lcase</a>,
<a href="left" class="link" title="Left">Left</a>,
<a href="leftpad" class="link" title="LeftPad">Leftpad</a>,
<a href="len" class="link" title="Len">Len</a>,
<a href="mid" class="link" title="Mid">Mid</a>,
<a href="pad" class="link" title="Pad">Pad</a>,
<a href="right" class="link" title="Right">Right</a>,
<a href="rtrim" class="link" title="Rtrim">Rtrim</a>,
<a href="str" class="link" title="Str">Str</a>,
<a href="trim" class="link" title="Trim">Trim</a>,
<a href="ucase" class="link" title="UCase">Ucase</a>,
<a href="val" class="link" title="Val">Val</a>,
<a href="wordtobin" class="link" title="WordToBin">Wordtobin</a>,
<a href="setting_variables" class="link" title="Setting Variables">Setting Variables</a>
or
<a href="concatenation" class="link" title="Concatenation">concatenation</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Subroutines</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_syntax.html" title="Syntax"><link rel="prev" href="_scripts.html" title="Scripts"><link rel="next" href="_converters.html" title="Converters"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_subroutines"></a>Subroutines</h3></div></div></div><p><span class="strong"><strong>About Subroutines</strong></span></p><p>A subroutine is a small program inside of the main program. Subroutines
are typically used when a task needs to be repeated several times in
different parts of the main program.</p><p>There are two main uses for subroutines:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Keeping programs neat and easy to read</li><li class="listitem">Reducing the size of programs by allowing common sections of code to
be reused.</li></ul></div><p>When the microcontroller comes to a subroutine it saves its location in the current
program before jumping to the start of, or calling, the subroutine. Once
it reaches the end of the subroutine it returns to the main program, and
continues to run the code where it left off previously.</p><p>Normally, it is possible for subroutines to call other subroutines.
There are limits to the number of times that a subroutine can call
another sub, which vary from chip to chip:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Microcontroller Family</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Instruction Width</strong></span></th><th align="center" valign="top"><span class="strong"><strong>Number of subs called</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>10F*, 12C5*, 12F5*, 16C5*, 16F5*</p></td><td align="center" valign="top"><p>12</p></td><td align="center" valign="top"><p>1</p></td></tr><tr><td align="left" valign="top"><p>12C*, 12F*, 16C*, 16F*, except those above</p></td><td align="center" valign="top"><p>14</p></td><td align="center" valign="top"><p>7</p></td></tr><tr><td align="left" valign="top"><p>18F*, 18C*</p></td><td align="center" valign="top"><p>16</p></td><td align="center" valign="top"><p>31</p></td></tr></tbody></table></div><p>These limits are due to the amount of memory on the microcontroller which saves its
location before it jumps to a new subroutine. Some GCBASIC commands are
subroutines, so you should always allow for 2 or 3 subroutine calls more
than your program has.</p><p>On 16F chips, the program memory is divided into pages. Each page holds 2048 instructions.&nbsp;&nbsp;&nbsp;
If the program jumps from code on one page to code on another, the compiler has to select the new page.&nbsp;&nbsp;&nbsp;Having to do this makes the program bigger, so try to avoid this.
To keep jumps between pages down, GCBASIC imposes a rule that each subroutine must be entirely within one page, so that only jumps to other subroutines require the page selection.&nbsp;&nbsp;&nbsp;
As an example, say you have two pages of memory, each 2048 instructions (words) long.<br>
If you have a main sub that is 1500 words, and four other subroutines each 600 words long, your total program size would be 3900 words and you might expect it to fit into the 4096 words available. &nbsp;&nbsp;&nbsp;
The problem though is that once the main routine takes 1500 words from page 1, nothing else will fit after it. Three of the 600 word subroutines would fit onto page 2, but that leaves one 600 word subroutine that will not fit into the 500 left on page 1 or the 200 left on page 2.&nbsp;&nbsp;&nbsp;
If you want to reduce the chance of this happening, the best option is to keep your subroutines smaller - move anything out of the main routine and into another one - this will resolve memory page constraints.&nbsp;&nbsp;&nbsp;</p><p>Atmel AVR microcontrollers have no fixed limit on how many subroutines can be
called at a time, but if too many are called then some variables on the
chip may be corrupted. To check if there are too many subroutines, work
out the most that will be called at once, then multiply that number by 2
and create an array of that size. If an out of memory error message
comes up, there are too many calls.</p><p>Another feature of subroutines is that they are able to accept
parameters. These are values that are passed from the main program to
the subroutine when it is called, and then passed back when the
subroutine ends.</p><p><span class="strong"><strong>Using Subroutines</strong></span></p><p>To call a subroutine is very simple - all that is needed is the name of
the sub, and then a list of parameters. This code will call a subroutine
named "Buzz" that has no parameters:</p><pre class="screen">    Buzz</pre><p>If the sub has parameters, then they should be listed after the name of
the subroutine. This would be the command to call a subroutine named
"MoveArm" that has three parameters:</p><pre class="screen">    MoveArm NewX, NewY, 10</pre><p>Or, you may choose to put brackets around the parameters, like so:</p><pre class="screen">    MoveArm (NewX, NewY, 10)</pre><p>All that this does is change the appearance of the code - it doesn&#8217;t
make any difference to what the code does. Decide which one meets your
own personal preference, and then stick with it.</p><p><span class="strong"><strong>Creating subroutines</strong></span></p><p>To create a subroutine is almost as simple as using one. There must be a
line at the start which has <code class="literal">sub</code>, and then the name of the subroutine.
Also, there needs to be a line at the end of the subroutine which reads
<code class="literal">end sub</code>. To create a subroutine called <code class="literal">Buzz</code>, this is the required
code:</p><pre class="screen">    sub Buzz

    'code for the subroutine goes here

    end sub</pre><p>If the subroutine has parameters, then they need to be listed after the
name. For example, to define the <code class="literal">MoveArm</code> sub used above, use this
code:</p><pre class="screen">    sub MoveArm(ArmX, ArmY, ArmZ)

    'code for the subroutine goes here

    end sub</pre><p>In the above sub, <code class="literal">ArmX</code>, <code class="literal">ArmY</code> and <code class="literal">ArmZ</code> are all variables. If the call
from above is used, the variables will have these values at the start of
the subroutine:</p><pre class="screen">    ArmX = NewX
    ArmY = NewY
    ArmZ = 10</pre><p>When the subroutine has finished running, GCBASIC will copy the values
back where possible. <code class="literal">NewX</code> will be assigned to <code class="literal">ArmX</code>, and <code class="literal">NewY</code> will be
assigned to <code class="literal">ArmY</code>. GCBASIC will not attempt to set the number 10 to <code class="literal">ArmZ</code>.</p><p><span class="strong"><strong>Controlling the direction data moves in</strong></span></p><p>It is possible to instruct GCBASIC not to copy the value back after the
subroutine is called. If a subroutine is defined like this:</p><pre class="screen">    sub MoveArm(In ArmX, In ArmY, In ArmZ)
    'code for the subroutine goes here

    end sub</pre><p>Then GCBASIC will copy the values to the subroutine, but will not copy
them back.</p><p>GCBASIC can also be prevented from copying the values back, by adding
<code class="literal">Out</code> before the parameter name. This is used in the EEPROM reading
routines - there is no point copying a data value into the read
subroutine, so <code class="literal">Out</code> has been used to avoid wasting time and memory. The
EPRead routine is defined as <code class="literal">Sub EPRead(In Address, Out Data)</code>.</p><p>Many older sections of code use <code class="literal">#NR</code> at the end of the line where the
parameters are specified. The <code class="literal">#NR</code> means "No Return", and when used has
the same effect as adding <code class="literal">In</code> before every parameter. Use of <code class="literal">#NR</code> is
not recommended, as it does not give the same level of control.</p><p><span class="strong"><strong>Using different data types for parameters</strong></span></p><p>It is possible to use any type of variable a as parameter for a
subroutine. Just add <code class="literal">As</code> and then the data type to the end of the
parameter name. For example, to make all of the parameters for the
<code class="literal">MoveArm</code> subroutine word variables, use this code:</p><pre class="screen">    sub MoveArm(ArmX As Word, ArmY As Word, ArmZ As Word)
    ...
    end sub</pre><p><span class="strong"><strong>Optional parameters</strong></span></p><p>Sometimes, the same value may be used over and over again for a
parameter, except in a particular case. If this occurs, a default value
may be specified for the parameter, and then a value for that parameter
only needs to be given in a call if it is different to the default.</p><p>For example, suppose a subroutine to create an error beep is required.
Normally it emits ! 440 Hz tone, but sometimes a different tone is
required. To create the sub, this code would be use:</p><pre class="screen">    Sub ErrorBeep(Optional OutTone As Word = 440)
      Tone OutTone, 100
    End Sub</pre><p>Note the <code class="literal">Optional</code> before the parameter, and the <code class="literal">= 440</code> after it.
This tells GCBASIC that if no parameter is supplied, then set the
<code class="literal">OutTone</code> parameter to 440.</p><p>If called using this line:</p><pre class="screen">    ErrorBeep</pre><p>then a 440 Hz beep will be emitted. If called using this line:</p><pre class="screen">    ErrorBeep 1000</pre><p>then the sub will produce a 1000 Hz tone.</p><p>When using several parameters, it is possible to make any number of them
optional. If the optional parameter/s are at the end of the call, then
no value needs to be specified. If they are at the start or in the
middle, then you must insert commas to allow GCBASIC to tell where the
optional parameters are.</p><p><span class="strong"><strong>Overloading</strong></span></p><p>It is possible to have 2 subroutines with the same name, but different
parameters. This is known as overloading, and GCBASIC will automatically
select the most appropriate subroutine for each call.</p><p>An example of this is the Print routine in the LCD routines. There are
actually several Print subroutines; for example, one has a byte
parameter, one a word parameter, and one a string parameter. If this
command is used:</p><pre class="screen">    Print 100</pre><p>Then the Print (byte) subroutine will be called. However, if this
command is used:</p><pre class="screen">    Print 30112</pre><p>Then the Print (word) subroutine will be called. If there is no exact
match for a particular call, GCBASIC will use the option that requires
the least conversion of variable types. For example, if this command is
used:</p><pre class="screen">    Print PORTB.0</pre><p>The byte print will be used. This is because byte is the closest type to
the single bit parameter.</p><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_functions.html" title="Functions">Functions</a>, <a class="link" href="_exit.html" title="Exit">Exit</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="subroutines"></span>Subroutines

</div>

</div>

</div>

<span class="strong">**About Subroutines**</span>

A subroutine is a small program inside of the main program. Subroutines
are typically used when a task needs to be repeated several times in
different parts of the main program.

There are two main uses for subroutines:

<div class="itemizedlist">

-   Keeping programs neat and easy to read
-   Reducing the size of programs by allowing common sections of code to
    be reused.

</div>

When the microcontroller comes to a subroutine it saves its location in
the current program before jumping to the start of, or calling, the
subroutine. Once it reaches the end of the subroutine it returns to the
main program, and continues to run the code where it left off
previously.

Normally, it is possible for subroutines to call other subroutines.
There are limits to the number of times that a subroutine can call
another sub, which vary from chip to chip:

<div class="informaltable">

| <span class="strong">**Microcontroller Family**</span> | <span class="strong">**Instruction Width**</span> | <span class="strong">**Number of subs called**</span> |
|:-------------------------------------------------------|:-------------------------------------------------:|:-----------------------------------------------------:|
| 10F\*, 12C5\*, 12F5\*, 16C5\*, 16F5\*                  |                        12                         |                           1                           |
| 12C\*, 12F\*, 16C\*, 16F\*, except those above         |                        14                         |                           7                           |
| 18F\*, 18C\*                                           |                        16                         |                          31                           |

</div>

These limits are due to the amount of memory on the microcontroller
which saves its location before it jumps to a new subroutine. Some
GCBASIC commands are subroutines, so you should always allow for 2 or 3
subroutine calls more than your program has.

On 16F chips, the program memory is divided into pages. Each page holds
2048 instructions.    If the program jumps from code on one page to code
on another, the compiler has to select the new page.   Having to do this
makes the program bigger, so try to avoid this. To keep jumps between
pages down, GCBASIC imposes a rule that each subroutine must be entirely
within one page, so that only jumps to other subroutines require the
page selection.    As an example, say you have two pages of memory, each
2048 instructions (words) long.  
If you have a main sub that is 1500 words, and four other subroutines
each 600 words long, your total program size would be 3900 words and you
might expect it to fit into the 4096 words available.     The problem
though is that once the main routine takes 1500 words from page 1,
nothing else will fit after it. Three of the 600 word subroutines would
fit onto page 2, but that leaves one 600 word subroutine that will not
fit into the 500 left on page 1 or the 200 left on page 2.    If you
want to reduce the chance of this happening, the best option is to keep
your subroutines smaller - move anything out of the main routine and
into another one - this will resolve memory page constraints.   

Atmel AVR microcontrollers have no fixed limit on how many subroutines
can be called at a time, but if too many are called then some variables
on the chip may be corrupted. To check if there are too many
subroutines, work out the most that will be called at once, then
multiply that number by 2 and create an array of that size. If an out of
memory error message comes up, there are too many calls.

Another feature of subroutines is that they are able to accept
parameters. These are values that are passed from the main program to
the subroutine when it is called, and then passed back when the
subroutine ends.

<span class="strong">**Using Subroutines**</span>

To call a subroutine is very simple - all that is needed is the name of
the sub, and then a list of parameters. This code will call a subroutine
named "Buzz" that has no parameters:

``` screen
    Buzz
```

If the sub has parameters, then they should be listed after the name of
the subroutine. This would be the command to call a subroutine named
"MoveArm" that has three parameters:

``` screen
    MoveArm NewX, NewY, 10
```

Or, you may choose to put brackets around the parameters, like so:

``` screen
    MoveArm (NewX, NewY, 10)
```

All that this does is change the appearance of the code - it doesn’t
make any difference to what the code does. Decide which one meets your
own personal preference, and then stick with it.

<span class="strong">**Creating subroutines**</span>

To create a subroutine is almost as simple as using one. There must be a
line at the start which has `sub`, and then the name of the subroutine.
Also, there needs to be a line at the end of the subroutine which reads
`end sub`. To create a subroutine called `Buzz`, this is the required
code:

``` screen
    sub Buzz

    'code for the subroutine goes here

    end sub
```

If the subroutine has parameters, then they need to be listed after the
name. For example, to define the `MoveArm` sub used above, use this
code:

``` screen
    sub MoveArm(ArmX, ArmY, ArmZ)

    'code for the subroutine goes here

    end sub
```

In the above sub, `ArmX`, `ArmY` and `ArmZ` are all variables. If the
call from above is used, the variables will have these values at the
start of the subroutine:

``` screen
    ArmX = NewX
    ArmY = NewY
    ArmZ = 10
```

When the subroutine has finished running, GCBASIC will copy the values
back where possible. `NewX` will be assigned to `ArmX`, and `NewY` will
be assigned to `ArmY`. GCBASIC will not attempt to set the number 10 to
`ArmZ`.

<span class="strong">**Controlling the direction data moves in**</span>

It is possible to instruct GCBASIC not to copy the value back after the
subroutine is called. If a subroutine is defined like this:

``` screen
    sub MoveArm(In ArmX, In ArmY, In ArmZ)
    'code for the subroutine goes here

    end sub
```

Then GCBASIC will copy the values to the subroutine, but will not copy
them back.

GCBASIC can also be prevented from copying the values back, by adding
`Out` before the parameter name. This is used in the EEPROM reading
routines - there is no point copying a data value into the read
subroutine, so `Out` has been used to avoid wasting time and memory. The
EPRead routine is defined as `Sub EPRead(In Address, Out Data)`.

Many older sections of code use `#NR` at the end of the line where the
parameters are specified. The `#NR` means "No Return", and when used has
the same effect as adding `In` before every parameter. Use of `#NR` is
not recommended, as it does not give the same level of control.

<span class="strong">**Using different data types for
parameters**</span>

It is possible to use any type of variable a as parameter for a
subroutine. Just add `As` and then the data type to the end of the
parameter name. For example, to make all of the parameters for the
`MoveArm` subroutine word variables, use this code:

``` screen
    sub MoveArm(ArmX As Word, ArmY As Word, ArmZ As Word)
    ...
    end sub
```

<span class="strong">**Optional parameters**</span>

Sometimes, the same value may be used over and over again for a
parameter, except in a particular case. If this occurs, a default value
may be specified for the parameter, and then a value for that parameter
only needs to be given in a call if it is different to the default.

For example, suppose a subroutine to create an error beep is required.
Normally it emits ! 440 Hz tone, but sometimes a different tone is
required. To create the sub, this code would be use:

``` screen
    Sub ErrorBeep(Optional OutTone As Word = 440)
      Tone OutTone, 100
    End Sub
```

Note the `Optional` before the parameter, and the `= 440` after it. This
tells GCBASIC that if no parameter is supplied, then set the `OutTone`
parameter to 440.

If called using this line:

``` screen
    ErrorBeep
```

then a 440 Hz beep will be emitted. If called using this line:

``` screen
    ErrorBeep 1000
```

then the sub will produce a 1000 Hz tone.

When using several parameters, it is possible to make any number of them
optional. If the optional parameter/s are at the end of the call, then
no value needs to be specified. If they are at the start or in the
middle, then you must insert commas to allow GCBASIC to tell where the
optional parameters are.

<span class="strong">**Overloading**</span>

It is possible to have 2 subroutines with the same name, but different
parameters. This is known as overloading, and GCBASIC will automatically
select the most appropriate subroutine for each call.

An example of this is the Print routine in the LCD routines. There are
actually several Print subroutines; for example, one has a byte
parameter, one a word parameter, and one a string parameter. If this
command is used:

``` screen
    Print 100
```

Then the Print (byte) subroutine will be called. However, if this
command is used:

``` screen
    Print 30112
```

Then the Print (word) subroutine will be called. If there is no exact
match for a particular call, GCBASIC will use the option that requires
the least conversion of variable types. For example, if this command is
used:

``` screen
    Print PORTB.0
```

The byte print will be used. This is because byte is the closest type to
the single bit parameter.

<span class="strong">**See Also**</span>
<a href="functions" class="link" title="Functions">Functions</a>,
<a href="exit" class="link" title="Exit">Exit</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SWAP</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_swap4.html" title="SWAP4"><link rel="next" href="_string_manipulation.html" title="String Manipulation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_swap"></a>SWAP</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    SWAP( VariableA, VariableB)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p>Support Bytes and Words only.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>A function that swaps (or exchanges) one byte or word for another. SWAP support the use of byte and word variables.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="swap"></span>SWAP

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    SWAP( VariableA, VariableB)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

Support Bytes and Words only.

<span class="strong">**Explanation:**</span>

A function that swaps (or exchanges) one byte or word for another. SWAP
support the use of byte and word variables.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SWAP4</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_set.html" title="Set"><link rel="next" href="_swap.html" title="SWAP"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_swap4"></a>SWAP4</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    SWAP4( VariableA)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p>Support Bytes only.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>A function that swaps (or exchanges) nibbles (or the 8 bits of a byte in nibbles).</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    dim ByteVariable as Byte

    ' Set variable to  0x12
    ByteVariable = 0x12

    ByteVariable = Swap4( ByteVariable )

    HSerPrint hex(ByteVariable)

    ' Would return 0x21</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="swap4"></span>SWAP4

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    SWAP4( VariableA)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

Support Bytes only.

<span class="strong">**Explanation:**</span>

A function that swaps (or exchanges) nibbles (or the 8 bits of a byte in
nibbles).

<span class="strong">**Example:**</span>

``` screen
    dim ByteVariable as Byte

    ' Set variable to  0x12
    ByteVariable = 0x12

    ByteVariable = Swap4( ByteVariable )

    HSerPrint hex(ByteVariable)

    ' Would return 0x21
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Syntax</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_usb_drivers_installer.html" title="USB Drivers Installer"><link rel="next" href="_arrays.html" title="Arrays"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_syntax"></a>Syntax</h2></div></div></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="syntax"></span>Syntax
--------------------------------

</div>

</div>

</div>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>T6963 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_st7920greaddata.html" title="ST7920gReaddata"><link rel="next" href="_uc1601_controllers.html" title="UC1601 Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_t6963_controllers"></a>T6963 Controllers</h5></div></div></div><p>This section covers Graphical Liquid Crystal Display (GLCD) devices that use the Toshiba T6963 graphics controller.&nbsp;&nbsp;&nbsp;The T6963 is a monochrome device that typically is blue or white.&nbsp;&nbsp;&nbsp;The GLCD can be provided in a number of pixels sizes - 240 * 64 or 240 * 128.
<br>
<br>
The Toshiba T6963 is a very popular LCD controller for use in small graphics modules. It is capable of controlling displays with a resolution up to 240x128. Because of its low power and
small outline it is most suitable for mobile applications such as PDAs, MP3 players or mobile measurement equipment.
<br>
<br>
A number of GLCD  modules have this controller built-in these include the SP12N002 &amp; SP14N001. Although this controller is small, it has the capability of displaying
and merging text and graphics and it manages all the interfacing signals to the displays Row and Column drivers.&nbsp;&nbsp;&nbsp;The GCBASIC library supports the complex capabilities of the T6963.
<br>
<br>
The T6963 is an LCD is driven by on-board 5V parallel interface chipset T6963.&nbsp;&nbsp;&nbsp;For the specific operating voltage always verify the operating voltages in the device specific datasheet.
<br>
<br>
The GCBASIC connectivity option is the 8-bit mode - where 8 connections (for the data) are required between the microcontroller and the GLCD to control the data bus.
<br>
<br>
To use the T6963 driver simply include the following in your user code.  &nbsp;&nbsp;&nbsp;This will initialise the driver.
<br>
<br></p><pre class="screen">    #chip 16f1939,32
    #option explicit

    '***********************************************************************************************
    'Specify this GLCD - a 240 x 64 pixels display
    #include &lt;glcd.h&gt;
     #define GLCD_TYPE GLCD_TYPE_T6963_64

    '***********************************************************************************************
    'define the connectivity - the 8bit port
    #define GLCD_DATA_PORT PORTD             'Library support contigous 8-bit port

  '  or
  '  #define GLCD_DB0      PORTD.0            'chip specific configuration where the ibrary supports 8-bit port defined via 8 constants
  '  #define GLCD_DB1      PORTD.1            'chip specific configuration
  '  #define GLCD_DB2      PORTD.2            'chip specific configuration
  '  #define GLCD_DB3      PORTD.3            'chip specific configuration
  '  #define GLCD_DB4      PORTD.4            'chip specific configuration
  '  #define GLCD_DB5      PORTD.5            'chip specific configuration
  '  #define GLCD_DB6      PORTD.6            'chip specific configuration
  '  #define GLCD_DB7      PORTD.7            'chip specific configuration

     #define GLCD_CS        PORTa.7           'Chip Enable (Active Low)
     #define GLCD_CD        PORTa.0           'Command or Data conrol line port
     #define GLCD_RD        PORTA.1           'Read control line  port
     #define GLCD_WR        PORTA.2           'Write control line port
     #define GLCD_RESET     PORTA.3           'Reset port
     #define GLCD_FS        PORTA.5           'FS port
     #define GLCD_FS_SELECT 1                 'FS1 Font Select port. 6x8 font: FS1=&#8220;High&#8221;=1 8x8 font FS1=&#8220;Low&#8221;=0 for GLCD_FS_SELECT

    '***********************************************************************************************
    '*
    '* Note    :   The T6963 controller's RAM address space from $0000 - $7FFF, total 32kbyte RAM, or it could be 64kbyte RAM best check!!
    '*
    '***********************************************************************************************
     #define TEXT_HOME_ADDR      0x0000                                                         'This is specific to the GLCD display
     #define GRH_HOME_ADDR       0x3FFF                                                         'This is specific to the GLCD display
     #define CG_HOME_ADDR        0x77FF                                                         'This is specific to the GLCD display
     #define COLUMN              40    'Set column number to be 40 , 32, 30 etc.                 This is specific to the GLCD display
     #define MAX_ROW_PIXEL       64    'MAX_ROW_PIXEL the physical matrix length (y direction)   This is specific to the GLCD display
     #define MAX_COL_PIXEL       240   'MAX_COL_PIXEL the physical matrix width (x direction)    This is specific to the GLCD display

    '***********************************************************************************************
    '* End of configuration
    '***********************************************************************************************</pre><p><br>
<br></p><p>The GCBASIC constants for the interface to the controller are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_TYPE_T6963_64</code> or <code class="literal">GLCD_TYPE_T6963_128</code></p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DATA_PORT</code></p></td><td align="left" valign="top"><p>A full 8-bit port.  8 contigous input/outputs.</p></td><td align="left" valign="top"><p>or use GLCD_DB0..GLCD_DB7</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_DB0..7</code></p></td><td align="left" valign="top"><p>A 8-bit port using 8 input/outputs.</p></td><td align="left" valign="top"><p>or use GLCD_DATA_PORT</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Chip Select on the
GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_CD</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Command/Data on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RD</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Read on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_WR</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Write on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_RESET</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to Reset on the GLCD.</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_FS</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to FS  on the GLCD.  The FS specifies the font size.  Please set to 6 setting  GLCD_FS_SELECT = 1</p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_FS_SELECT</code></p></td><td align="left" valign="top"><p>Specifies the output pin that is connected to FS  on the GLCD.  The FS specifies the font size.  Please set to 6 setting  GLCD_FS_SELECT = 1</p></td><td align="left" valign="top"><p>Required.  Can be 1 or 0.  Default setting is 1.</p></td></tr></tbody></table></div><p><br>
<br></p><p>The T6963 differs from most other GLCD controllers in its use of the display RAM.&nbsp;&nbsp;&nbsp; Where a fixed area
of memory is normally allocated for text, graphics and the external character generator, but with
the T6963 the size for each area <span class="strong"><strong>MUST</strong></span> be set by software commands.&nbsp;&nbsp;&nbsp; This means that the area for
text, graphics and external character generator can be freely allocated within the external
memory, up to 64 kByte.&nbsp;&nbsp;&nbsp;Check the specific device for the amount of memory available.&nbsp;&nbsp;&nbsp;This can range from 4 kbyte to 64 kbyte.</p><p><br>
<br>
For more information on memory management refer the device specific datasheet.
<br>
<br>
The GCBASIC constants control the memory configuration of the T6963 controller.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Value</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Comments</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">TEXT_HOME_ADDR</code></p></td><td align="left" valign="top"><p>0x0000</p></td><td align="left" valign="top"><p>This is specific to the GLCD display</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GRH_HOME_ADDR</code></p></td><td align="left" valign="top"><p>0x3FFF</p></td><td align="left" valign="top"><p>This is specific to the GLCD display</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CG_HOME_ADDR</code></p></td><td align="left" valign="top"><p>0x77FF</p></td><td align="left" valign="top"><p>This is specific to the GLCD display</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">COLUMN</code></p></td><td align="left" valign="top"><p>40</p></td><td align="left" valign="top"><p>Set column number to be 40 , 32, 30 etc.  This is specific to the GLCD display</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">MAX_ROW_PIXEL</code></p></td><td align="left" valign="top"><p>64</p></td><td align="left" valign="top"><p>MAX_ROW_PIXEL the physical matrix length (y direction)   This is specific to the GLCD display</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">MAX_COL_PIXEL</code></p></td><td align="left" valign="top"><p>240</p></td><td align="left" valign="top"><p>MAX_COL_PIXEL the physical matrix width (x direction)    This is specific to the GLCD display</p></td></tr></tbody></table></div><p><br>
<br>
The GCBASIC library supports the following capabilities.&nbsp;&nbsp;&nbsp;Please refer to the relevant Help section and the device specific demonstrations.
<br>
<br>
<span class="strong"><strong>Commands Supported for the LCD and GLCD</strong></span>
<br>
<br></p><p>The GLCD command set covers the standard GLCDCLS, Line, Circle and all the GLCD methods and the  LCD command set: CLS, Locate, Print, LCDHEX etc.  The demonstrations show how to load BMP loading via external data sources and GLCD and LCD page swapping.
<br>
<br>
The table below shows the specific implementations of the command set for this device.&nbsp;&nbsp;&nbsp;Refer to the GLCD and LCD in the Help for the generic GLCD and LCD commands.
<br>
<br></p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Commands</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Usage</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>CLS</p></td><td align="left" valign="top"><p>Clear the screen of the current LCD page</p></td></tr><tr><td align="left" valign="top"><p>LOCATE</p></td><td align="left" valign="top"><p>Locate the cursor at a specific screen position</p></td></tr><tr><td align="left" valign="top"><p>PRINT</p></td><td align="left" valign="top"><p>Print numbers or strings</p></td></tr><tr><td align="left" valign="top"><p>PUT</p></td><td align="left" valign="top"><p>Put a specific ASCII code at a specific screen position</p></td></tr><tr><td align="left" valign="top"><p>LCDHOME</p></td><td align="left" valign="top"><p>Set output position of 0, 0</p></td></tr><tr><td align="left" valign="top"><p>LCDcmd</p></td><td align="left" valign="top"><p>Send specific command to the device to control the device.</p></td></tr><tr><td align="left" valign="top"><p>LCDdata</p></td><td align="left" valign="top"><p>Send specific data to the device to control the device.</p></td></tr><tr><td align="left" valign="top"><p>LCDHex</p></td><td align="left" valign="top"><p>Print Hex value of a number to the LCD screen</p></td></tr><tr><td align="left" valign="top"><p>LCDSpace</p></td><td align="left" valign="top"><p>Print a number of space to the LCD screen</p></td></tr><tr><td align="left" valign="top"><p>LCDCursor</p></td><td align="left" valign="top"><p>Send specific commands to the device to control the cursor</p></td></tr><tr><td align="left" valign="top"><p>GLCDCLS</p></td><td align="left" valign="top"><p>Clear the screen of the current GLCD page</p></td></tr><tr><td align="left" valign="top"><p>GLCDRotate</p></td><td align="left" valign="top"><p>Rotate the GLCD screen. Only Landscape rotation is supported.</p></td></tr><tr><td align="left" valign="top"><p>SelectGLCDPage_T6963</p></td><td align="left" valign="top"><p>Select a specific GLCD page.</p></td></tr><tr><td align="left" valign="top"><p>SelectLCDPage_T6963</p></td><td align="left" valign="top"><p>Select a specific LCD page.</p></td></tr></tbody></table></div><p><br>
<br>
<span class="strong"><strong>GLCD and LCD page swapping</strong></span>
<br>
<br>
To support GLCD and LCD page swapping - this can be used to support fixed pages of information, BMPs or scrolling the following constants have are available to the user.
<br>
<br></p><p>For GLCD memory addressing</p><pre class="screen">  GLCDPage0_T6963
  GLCDPage1_T6963
  GLCDPage2_T6963
  ... etc
  GLCDPage10_T6963</pre><p>Ten pages are automatically created but the number of pages available is constrained by the memory configuration.
<br>
<br>
For LCD memory addressing</p><pre class="screen">  LCDPage0_T6963
  LCDPage1_T6963
  LCDPage2_T6963
  ...etc
  LCDPage10_T6963</pre><p>Ten pages are automatically created but the number of pages available is constrained by the memory configuration.
<br>
To use add the following to you user program.&nbsp;&nbsp;&nbsp;See the demonstration programs for more detailed usage.&nbsp;&nbsp;&nbsp;After calling the <code class="literal">SelectGLCDPage</code> or <code class="literal">SelectLCDPage</code> methods all GLCD or LCD commands will be applied to the current GLCD or LCD page.
<br>
<br></p><pre class="screen">    'Select the GLCD page 1 memory
    SelectGLCDPage ( GLCDPage1_T6963 )

    'Select the LCD page 2 memory
    SelectLCDPage ( LCDPage2_T6963 )</pre><p><br>
<br></p><p>The <code class="literal">SelectLCDPage</code> and <code class="literal">SelectLCDPage</code> and "Set Text Home Address" methods change the screen being viewed on the device.</p><p>The key is to establish what you want your memory map to look like.  &nbsp;&nbsp;&nbsp; Below is a map for one of my 240 x 64 pixel  device.   &nbsp;&nbsp;&nbsp; The default is for 10 screen pages (some newer LCD&#8217;s may have more RAM for more screens). &nbsp;&nbsp;&nbsp; If you write the appropriate value (0x1000, or 0x11b0, or 0x1360, etc) to the text home address, the display will instantly change to that screen - using <code class="literal">SelectLCDPage</code> and <code class="literal">SelectLCDPage</code> method with the appropiate constant as parameter.</p><p>You can write your screens "ahead of time", in my case during the "splash screen" delay interval, and instantly change to them later as desired. &nbsp;&nbsp;&nbsp; You can do this by setting <span class="strong"><strong>current_grh_home_addr</strong></span> to the appropiate page. &nbsp;&nbsp;&nbsp;And, then execute the GLCD commands you would normal use.</p><p>The graphic and text screens are independant but can be overlaid for a variety of useful effects.</p><p>Although, not tested,  the LCD text screens can be scrolled 1 full text line at a time, while the GLCD screens can be scrolled 1 pixel row at a time, provided you&#8217;ve set up your memory map accordingly with adequate RAM for the graphic area.</p><p><br>
<br>
<span class="strong"><strong>Default Memory Map</strong></span>
<br>
<br></p><pre class="screen">            '
            '*******************************************************
            '
            ' LCD MEMORY MAP
            '
            '*******************************************************
            '
            '
            '
            ' --------------------
            ' |                  | 0x0000
            ' |                  |
            ' | TEXT RAM AREA    | Each page has the numnbers of bytes + extra
            ' | ( 10 SCREENs )   | few bytes need to attributes. This is
            ' |                  | mentioned in the datasheet but imperical
            ' |                  | testing shows... you need the extra bytes
            ' --------------------
            ' |                  |
            ' | xx bytes unused  |
            ' |                  |
            ' --------------------
            ' |                  | 0x3fff
            ' |                  |
            ' |                  |
            ' |  GCLD RAM AREA   |
            ' |  ( 10 SCREENS )  |
            ' |                  |
            ' |                  |
            ' |          |
            ' --------------------
            ' |                  | 0x77ff
            ' |   CG RAM AREA    | (Sacrosanct)
            ' |                  |
            ' -------------------- 0x7ffff
            '</pre><p><span class="strong"><strong>Other methods and constants</strong></span>
<br>
There are many other methods and constants that support this device.&nbsp;&nbsp;&nbsp;Reviewing the library will assist in understanding how these private methods and constants support the overal solution for this library.
<br>
<br></p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p><p>&nbsp;&nbsp;&nbsp;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="t6963_controllers"></span>T6963 Controllers

</div>

</div>

</div>

This section covers Graphical Liquid Crystal Display (GLCD) devices that
use the Toshiba T6963 graphics controller.   The T6963 is a monochrome
device that typically is blue or white.   The GLCD can be provided in a
number of pixels sizes - 240 \* 64 or 240 \* 128.  
  
The Toshiba T6963 is a very popular LCD controller for use in small
graphics modules. It is capable of controlling displays with a
resolution up to 240x128. Because of its low power and small outline it
is most suitable for mobile applications such as PDAs, MP3 players or
mobile measurement equipment.  
  
A number of GLCD modules have this controller built-in these include the
SP12N002 & SP14N001. Although this controller is small, it has the
capability of displaying and merging text and graphics and it manages
all the interfacing signals to the displays Row and Column
drivers.   The GCBASIC library supports the complex capabilities of the
T6963.  
  
The T6963 is an LCD is driven by on-board 5V parallel interface chipset
T6963.   For the specific operating voltage always verify the operating
voltages in the device specific datasheet.  
  
The GCBASIC connectivity option is the 8-bit mode - where 8 connections
(for the data) are required between the microcontroller and the GLCD to
control the data bus.  
  
To use the T6963 driver simply include the following in your user code.
   This will initialise the driver.  
  

``` screen
    #chip 16f1939,32
    #option explicit

    '***********************************************************************************************
    'Specify this GLCD - a 240 x 64 pixels display
    #include <glcd.h>
     #define GLCD_TYPE GLCD_TYPE_T6963_64

    '***********************************************************************************************
    'define the connectivity - the 8bit port
    #define GLCD_DATA_PORT PORTD             'Library support contigous 8-bit port

  '  or
  '  #define GLCD_DB0      PORTD.0            'chip specific configuration where the ibrary supports 8-bit port defined via 8 constants
  '  #define GLCD_DB1      PORTD.1            'chip specific configuration
  '  #define GLCD_DB2      PORTD.2            'chip specific configuration
  '  #define GLCD_DB3      PORTD.3            'chip specific configuration
  '  #define GLCD_DB4      PORTD.4            'chip specific configuration
  '  #define GLCD_DB5      PORTD.5            'chip specific configuration
  '  #define GLCD_DB6      PORTD.6            'chip specific configuration
  '  #define GLCD_DB7      PORTD.7            'chip specific configuration

     #define GLCD_CS        PORTa.7           'Chip Enable (Active Low)
     #define GLCD_CD        PORTa.0           'Command or Data conrol line port
     #define GLCD_RD        PORTA.1           'Read control line  port
     #define GLCD_WR        PORTA.2           'Write control line port
     #define GLCD_RESET     PORTA.3           'Reset port
     #define GLCD_FS        PORTA.5           'FS port
     #define GLCD_FS_SELECT 1                 'FS1 Font Select port. 6x8 font: FS1=“High”=1 8x8 font FS1=“Low”=0 for GLCD_FS_SELECT

    '***********************************************************************************************
    '*
    '* Note    :   The T6963 controller's RAM address space from $0000 - $7FFF, total 32kbyte RAM, or it could be 64kbyte RAM best check!!
    '*
    '***********************************************************************************************
     #define TEXT_HOME_ADDR      0x0000                                                         'This is specific to the GLCD display
     #define GRH_HOME_ADDR       0x3FFF                                                         'This is specific to the GLCD display
     #define CG_HOME_ADDR        0x77FF                                                         'This is specific to the GLCD display
     #define COLUMN              40    'Set column number to be 40 , 32, 30 etc.                 This is specific to the GLCD display
     #define MAX_ROW_PIXEL       64    'MAX_ROW_PIXEL the physical matrix length (y direction)   This is specific to the GLCD display
     #define MAX_COL_PIXEL       240   'MAX_COL_PIXEL the physical matrix width (x direction)    This is specific to the GLCD display

    '***********************************************************************************************
    '* End of configuration
    '***********************************************************************************************
```

  
  

The GCBASIC constants for the interface to the controller are shown in
the table below.

<div class="informaltable">

| <span class="strong">**Constants**</span> | <span class="strong">**Controls**</span>                                                                                                   | <span class="strong">**Options**</span>        |
|:------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------|
| `GLCD_TYPE`                               | `GLCD_TYPE_TYPE_T6963_64` or `GLCD_TYPE_T6963_128`                                                                                         | Required                                       |
| `GLCD_DATA_PORT`                          | A full 8-bit port. 8 contigous input/outputs.                                                                                              | or use GLCD\_DB0..GLCD\_DB7                    |
| `GLCD_DB0..7`                             | A 8-bit port using 8 input/outputs.                                                                                                        | or use GLCD\_DATA\_PORT                        |
| `GLCD_CS`                                 | Specifies the output pin that is connected to Chip Select on the GLCD.                                                                     | Required                                       |
| `GLCD_CD`                                 | Specifies the output pin that is connected to Command/Data on the GLCD.                                                                    | Required                                       |
| `GLCD_RD`                                 | Specifies the output pin that is connected to Read on the GLCD.                                                                            | Required                                       |
| `GLCD_WR`                                 | Specifies the output pin that is connected to Write on the GLCD.                                                                           | Required                                       |
| `GLCD_RESET`                              | Specifies the output pin that is connected to Reset on the GLCD.                                                                           | Required                                       |
| `GLCD_FS`                                 | Specifies the output pin that is connected to FS on the GLCD. The FS specifies the font size. Please set to 6 setting GLCD\_FS\_SELECT = 1 | Required                                       |
| `GLCD_FS_SELECT`                          | Specifies the output pin that is connected to FS on the GLCD. The FS specifies the font size. Please set to 6 setting GLCD\_FS\_SELECT = 1 | Required. Can be 1 or 0. Default setting is 1. |

</div>

  
  

The T6963 differs from most other GLCD controllers in its use of the
display RAM.    Where a fixed area of memory is normally allocated for
text, graphics and the external character generator, but with the T6963
the size for each area <span class="strong">**MUST**</span> be set by
software commands.    This means that the area for text, graphics and
external character generator can be freely allocated within the external
memory, up to 64 kByte.   Check the specific device for the amount of
memory available.   This can range from 4 kbyte to 64 kbyte.

  
  
For more information on memory management refer the device specific
datasheet.  
  
The GCBASIC constants control the memory configuration of the T6963
controller.

<div class="informaltable">

| <span class="strong">**Constants**</span> | <span class="strong">**Value**</span> | <span class="strong">**Comments**</span>                                                      |
|:------------------------------------------|:--------------------------------------|:----------------------------------------------------------------------------------------------|
| `TEXT_HOME_ADDR`                          | 0x0000                                | This is specific to the GLCD display                                                          |
| `GRH_HOME_ADDR`                           | 0x3FFF                                | This is specific to the GLCD display                                                          |
| `CG_HOME_ADDR`                            | 0x77FF                                | This is specific to the GLCD display                                                          |
| `COLUMN`                                  | 40                                    | Set column number to be 40 , 32, 30 etc. This is specific to the GLCD display                 |
| `MAX_ROW_PIXEL`                           | 64                                    | MAX\_ROW\_PIXEL the physical matrix length (y direction) This is specific to the GLCD display |
| `MAX_COL_PIXEL`                           | 240                                   | MAX\_COL\_PIXEL the physical matrix width (x direction) This is specific to the GLCD display  |

</div>

  
  
The GCBASIC library supports the following capabilities.   Please refer
to the relevant Help section and the device specific demonstrations.  
  
<span class="strong">**Commands Supported for the LCD and
GLCD**</span>  
  

The GLCD command set covers the standard GLCDCLS, Line, Circle and all
the GLCD methods and the LCD command set: CLS, Locate, Print, LCDHEX
etc. The demonstrations show how to load BMP loading via external data
sources and GLCD and LCD page swapping.  
  
The table below shows the specific implementations of the command set
for this device.   Refer to the GLCD and LCD in the Help for the generic
GLCD and LCD commands.  
  

<div class="informaltable">

| <span class="strong">**Commands**</span> | <span class="strong">**Usage**</span>                         |
|:-----------------------------------------|:--------------------------------------------------------------|
| CLS                                      | Clear the screen of the current LCD page                      |
| LOCATE                                   | Locate the cursor at a specific screen position               |
| PRINT                                    | Print numbers or strings                                      |
| PUT                                      | Put a specific ASCII code at a specific screen position       |
| LCDHOME                                  | Set output position of 0, 0                                   |
| LCDcmd                                   | Send specific command to the device to control the device.    |
| LCDdata                                  | Send specific data to the device to control the device.       |
| LCDHex                                   | Print Hex value of a number to the LCD screen                 |
| LCDSpace                                 | Print a number of space to the LCD screen                     |
| LCDCursor                                | Send specific commands to the device to control the cursor    |
| GLCDCLS                                  | Clear the screen of the current GLCD page                     |
| GLCDRotate                               | Rotate the GLCD screen. Only Landscape rotation is supported. |
| SelectGLCDPage\_T6963                    | Select a specific GLCD page.                                  |
| SelectLCDPage\_T6963                     | Select a specific LCD page.                                   |

</div>

  
  
<span class="strong">**GLCD and LCD page swapping**</span>  
  
To support GLCD and LCD page swapping - this can be used to support
fixed pages of information, BMPs or scrolling the following constants
have are available to the user.  
  

For GLCD memory addressing

``` screen
  GLCDPage0_T6963
  GLCDPage1_T6963
  GLCDPage2_T6963
  ... etc
  GLCDPage10_T6963
```

Ten pages are automatically created but the number of pages available is
constrained by the memory configuration.  
  
For LCD memory addressing

``` screen
  LCDPage0_T6963
  LCDPage1_T6963
  LCDPage2_T6963
  ...etc
  LCDPage10_T6963
```

Ten pages are automatically created but the number of pages available is
constrained by the memory configuration.  
To use add the following to you user program.   See the demonstration
programs for more detailed usage.   After calling the `SelectGLCDPage`
or `SelectLCDPage` methods all GLCD or LCD commands will be applied to
the current GLCD or LCD page.  
  

``` screen
    'Select the GLCD page 1 memory
    SelectGLCDPage ( GLCDPage1_T6963 )

    'Select the LCD page 2 memory
    SelectLCDPage ( LCDPage2_T6963 )
```

  
  

The `SelectLCDPage` and `SelectLCDPage` and "Set Text Home Address"
methods change the screen being viewed on the device.

The key is to establish what you want your memory map to look like.    
Below is a map for one of my 240 x 64 pixel device.     The default is
for 10 screen pages (some newer LCD’s may have more RAM for more
screens).     If you write the appropriate value (0x1000, or 0x11b0, or
0x1360, etc) to the text home address, the display will instantly change
to that screen - using `SelectLCDPage` and `SelectLCDPage` method with
the appropiate constant as parameter.

You can write your screens "ahead of time", in my case during the
"splash screen" delay interval, and instantly change to them later as
desired.     You can do this by setting <span
class="strong">**current\_grh\_home\_addr**</span> to the appropiate
page.    And, then execute the GLCD commands you would normal use.

The graphic and text screens are independant but can be overlaid for a
variety of useful effects.

Although, not tested, the LCD text screens can be scrolled 1 full text
line at a time, while the GLCD screens can be scrolled 1 pixel row at a
time, provided you’ve set up your memory map accordingly with adequate
RAM for the graphic area.

  
  
<span class="strong">**Default Memory Map**</span>  
  

``` screen
            '
            '*******************************************************
            '
            ' LCD MEMORY MAP
            '
            '*******************************************************
            '
            '
            '
            ' --------------------
            ' |                  | 0x0000
            ' |                  |
            ' | TEXT RAM AREA    | Each page has the numnbers of bytes + extra
            ' | ( 10 SCREENs )   | few bytes need to attributes. This is
            ' |                  | mentioned in the datasheet but imperical
            ' |                  | testing shows... you need the extra bytes
            ' --------------------
            ' |                  |
            ' | xx bytes unused  |
            ' |                  |
            ' --------------------
            ' |                  | 0x3fff
            ' |                  |
            ' |                  |
            ' |  GCLD RAM AREA   |
            ' |  ( 10 SCREENS )  |
            ' |                  |
            ' |                  |
            ' |          |
            ' --------------------
            ' |                  | 0x77ff
            ' |   CG RAM AREA    | (Sacrosanct)
            ' |                  |
            ' -------------------- 0x7ffff
            '
```

<span class="strong">**Other methods and constants**</span>  
There are many other methods and constants that support this
device.   Reviewing the library will assist in understanding how these
private methods and constants support the overal solution for this
library.  
  

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

   

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Timers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_play_rtttl.html" title="Play RTTTL"><link rel="next" href="_timer_overview.html" title="Timer Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_timers"></a>Timers</h3></div></div></div><p>This is the Timers section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="timers"></span>Timers

</div>

</div>

</div>

This is the Timers section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Timer Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_timers.html" title="Timers"><link rel="next" href="_cleartimer.html" title="ClearTimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_timer_overview"></a>Timer Overview</h4></div></div></div><p>GCBASIC supports methods to set, clear, read, start and stop the microcontroller timers.</p><p>GCBASIC supports the following timers.</p><pre class="screen">    Timer 0
    Timer 1
    Timer 2
    Timer 3
    Timer 4
    Timer 5
    Timer 6
    Timer 7
    Timer 8
    Timer 10
    Timer 12</pre><p>Not all of these timers available on all microcontrollers. For example,
if a microcontroller has three timers, then typically only <code class="literal">Timer0</code>,
<code class="literal">Timer1</code> and <code class="literal">Timer2</code> will be available.</p><p>Please refer to the datasheet for your microcontroller to determine the supported
timers and if a specific timer is 8-bit or 16-bit.</p><p><span class="strong"><strong>Calculating a Timer Prescaler:</strong></span></p><p>To initialise and change the timers you may have to change the Prescaler.</p><p>A Prescaler is an electronic counting circuit used to reduce a high frequency electrical signal to a lower frequency by integer division.
The prescaler takes the basic timer clock frequency and divides it by some value before being processed by the timer, according to how the Prescaler register(s) are configured.
The prescaler values that may be configured might be limited to a few fixed values, see the timer specfic page in this Help file or refer to the datasheet.</p><p>To use a Prescaler some simple integer maths is required, however, when calculating the Prescaler there is often be a tradeoff between resolution, where a high resolution requires a high clock frequency and range where a high clock frequency willl cause the timer to overflow more quickly.
For example, achieving 1 us resolution and a 1 sec maximum period using a 16-bit timer may require some clever thinking when using 8-bit timers.
Please ask for advice via the GCBASIC forum, or, search for some of the many great resources on the internet to calculate a Prescaler value.</p><p><span class="strong"><strong>Common Langauge:</strong></span></p><p>Using timers has the following terms /common langauge.  This following paragraph is intended to explain the common language.</p><p>The Oscillator (OSC) is the system clock, this can be sourced from an internal or external source, OSC is same the as microcontroller Mhz.
This is called the the Frequency of the OSCillator (FOSC) or the System Clock.</p><p>On a Microchip PIC microcontroller, one machine code instruction is executed for every four system clock pulses.<br>
This means that instructions are executed at a frequency of FOSC/4.<br>
The Microchip PIC datasheets call this FOSC/4 or FOSC4.<br>
All Microchip PIC timer prescales are based on the FOSC/4, not the FOSC or the System Clock.<br>
As Prescale are based upon FOSC/4,  you must use FOSC/4 in your timer calculations to get the results you expect.<br>
All Prescale and Postscale values are integer numbers.</p><p>On Atmel AVR microcontroller, most machine code instructions will execute in a single clock pulse.</p><p><span class="strong"><strong>Timer differences between Microchip PIC and Atmel AVR microcontrollers:</strong></span></p><p>Initialising a timer for a Microchip PIC microcontroller may not operate as expected when using the same code for an Atmel AVR microcontroller by simply changing the <code class="literal">#chip</code> definition.
You <span class="strong"><strong>must</strong></span> recalculate the Prescaler of a timer when moving timer parameters between Microchip PIC and Atmel AVR microcontrollers.
And, of course, the same when moving timer parameters between Atmel AVR and Microchip PIC microcontrollers.</p><p><span class="strong"><strong>Timer Best Practices:</strong></span></p><p>Initialising microcontrollers with very limited RAM using GCBASIC needs carefull consideration.
RAM may be need to be optimised by using ASM to control the timers.
You can use GCBASIC to create the timer related GCBASIC ASM code then manually edit the GCBASIC ASM to optmise RAM usage.
Add your revised and optimised ASM back into your program and then remove the no longer required calls the the GCBASIC methods.
If you need advice on this subject please ask for advice via the GCBASIC forum.</p><p><span class="strong"><strong>Using Timers 2/4/6/8 on Microchip PIC microcontrollers.</strong></span></p><p>A Microchip PIC microcontroller can have one of two types of 8-bit timer 2/4/6/8.</p><p>The first type has only one clock source and that clock is the FOSC/4 source.</p><p>The second type is much more flexible and can have many different clock sources and supports more prescale values.</p><p>The timer type for a Microchip PIC microcontroller can be determined by checking for the existence of a T2CLKCON register, either in the Datasheet or in the GCBASIC "dat file" for the specific microcontroller.</p><p>If the microcontroller DOES NOT have a T2CLKCON register then ALL Timer 2/4/6/8 timers on that chip are the first type, and are configured using:</p><pre class="screen">    _InitTimer2 (PreScale, PostScale)_   'Timer2 is example for timer 2/4/6 or 8</pre><p>If the microcontroller DOES have a T2CLKCON register then ALL Timer 2/4/6/8 timers on that chip are the second type and are configured using:</p><pre class="screen">    _InitTimer2 (Source, PreScale, PostScale)_   'Timer2 is example for timer 2/4/6 or 8</pre><p>The possible <span class="emphasis"><em>Source</em></span>, <span class="emphasis"><em>PreScale</em></span> and <span class="emphasis"><em>PostScale</em></span> constants for each type are shown in the GCBASIC Help file.  See each timer for the constants.</p><p>The "Period" of these timers is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&nbsp;&nbsp;&nbsp;The timer period registers are PR2, PR4, PR6 or PR8 for timer2, timer4, timer6 and timer8 respectively.  These registers are also called PRx and TMRx where the <span class="strong"><strong><code class="literal">x</code></strong></span> refers to specific timer number.</p><p>When a specific timer is enabled/started the TMRx timer register will increment until the TMRx register matches the value in the PRx register.&nbsp;&nbsp;&nbsp;At this time the TMRx register is cleared to 0 and the timer continues to increment until the next match of the PRx register, and so on until the timer is stopped.&nbsp;&nbsp;&nbsp;The lower the value of the PRx register, the shorter the timer period will be.&nbsp;&nbsp;&nbsp;The default value for the PRX register at power up is 255.</p><p>The timer interrupt flag (TMRxIF) is set based upon the number of match conditions as determine by the postscaler.&nbsp;&nbsp;&nbsp;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.</p><p><br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="timer_overview"></span>Timer Overview

</div>

</div>

</div>

GCBASIC supports methods to set, clear, read, start and stop the
microcontroller timers.

GCBASIC supports the following timers.

``` screen
    Timer 0
    Timer 1
    Timer 2
    Timer 3
    Timer 4
    Timer 5
    Timer 6
    Timer 7
    Timer 8
    Timer 10
    Timer 12
```

Not all of these timers available on all microcontrollers. For example,
if a microcontroller has three timers, then typically only `Timer0`,
`Timer1` and `Timer2` will be available.

Please refer to the datasheet for your microcontroller to determine the
supported timers and if a specific timer is 8-bit or 16-bit.

<span class="strong">**Calculating a Timer Prescaler:**</span>

To initialise and change the timers you may have to change the
Prescaler.

A Prescaler is an electronic counting circuit used to reduce a high
frequency electrical signal to a lower frequency by integer division.
The prescaler takes the basic timer clock frequency and divides it by
some value before being processed by the timer, according to how the
Prescaler register(s) are configured. The prescaler values that may be
configured might be limited to a few fixed values, see the timer specfic
page in this Help file or refer to the datasheet.

To use a Prescaler some simple integer maths is required, however, when
calculating the Prescaler there is often be a tradeoff between
resolution, where a high resolution requires a high clock frequency and
range where a high clock frequency willl cause the timer to overflow
more quickly. For example, achieving 1 us resolution and a 1 sec maximum
period using a 16-bit timer may require some clever thinking when using
8-bit timers. Please ask for advice via the GCBASIC forum, or, search
for some of the many great resources on the internet to calculate a
Prescaler value.

<span class="strong">**Common Langauge:**</span>

Using timers has the following terms /common langauge. This following
paragraph is intended to explain the common language.

The Oscillator (OSC) is the system clock, this can be sourced from an
internal or external source, OSC is same the as microcontroller Mhz.
This is called the the Frequency of the OSCillator (FOSC) or the System
Clock.

On a Microchip PIC microcontroller, one machine code instruction is
executed for every four system clock pulses.  
This means that instructions are executed at a frequency of FOSC/4.  
The Microchip PIC datasheets call this FOSC/4 or FOSC4.  
All Microchip PIC timer prescales are based on the FOSC/4, not the FOSC
or the System Clock.  
As Prescale are based upon FOSC/4, you must use FOSC/4 in your timer
calculations to get the results you expect.  
All Prescale and Postscale values are integer numbers.

On Atmel AVR microcontroller, most machine code instructions will
execute in a single clock pulse.

<span class="strong">**Timer differences between Microchip PIC and Atmel
AVR microcontrollers:**</span>

Initialising a timer for a Microchip PIC microcontroller may not operate
as expected when using the same code for an Atmel AVR microcontroller by
simply changing the `#chip` definition. You <span
class="strong">**must**</span> recalculate the Prescaler of a timer when
moving timer parameters between Microchip PIC and Atmel AVR
microcontrollers. And, of course, the same when moving timer parameters
between Atmel AVR and Microchip PIC microcontrollers.

<span class="strong">**Timer Best Practices:**</span>

Initialising microcontrollers with very limited RAM using GCBASIC needs
carefull consideration. RAM may be need to be optimised by using ASM to
control the timers. You can use GCBASIC to create the timer related
GCBASIC ASM code then manually edit the GCBASIC ASM to optmise RAM
usage. Add your revised and optimised ASM back into your program and
then remove the no longer required calls the the GCBASIC methods. If you
need advice on this subject please ask for advice via the GCBASIC forum.

<span class="strong">**Using Timers 2/4/6/8 on Microchip PIC
microcontrollers.**</span>

A Microchip PIC microcontroller can have one of two types of 8-bit timer
2/4/6/8.

The first type has only one clock source and that clock is the FOSC/4
source.

The second type is much more flexible and can have many different clock
sources and supports more prescale values.

The timer type for a Microchip PIC microcontroller can be determined by
checking for the existence of a T2CLKCON register, either in the
Datasheet or in the GCBASIC "dat file" for the specific microcontroller.

If the microcontroller DOES NOT have a T2CLKCON register then ALL Timer
2/4/6/8 timers on that chip are the first type, and are configured
using:

``` screen
    _InitTimer2 (PreScale, PostScale)_   'Timer2 is example for timer 2/4/6 or 8
```

If the microcontroller DOES have a T2CLKCON register then ALL Timer
2/4/6/8 timers on that chip are the second type and are configured
using:

``` screen
    _InitTimer2 (Source, PreScale, PostScale)_   'Timer2 is example for timer 2/4/6 or 8
```

The possible <span class="emphasis">*Source*</span>, <span
class="emphasis">*PreScale*</span> and <span
class="emphasis">*PostScale*</span> constants for each type are shown in
the GCBASIC Help file. See each timer for the constants.

The "Period" of these timers is determined by the system clock speed,
the prescale value and 8-bit value in the respective timer period
register.   The timer period registers are PR2, PR4, PR6 or PR8 for
timer2, timer4, timer6 and timer8 respectively. These registers are also
called PRx and TMRx where the <span class="strong">**`x`**</span> refers
to specific timer number.

When a specific timer is enabled/started the TMRx timer register will
increment until the TMRx register matches the value in the PRx
register.   At this time the TMRx register is cleared to 0 and the timer
continues to increment until the next match of the PRx register, and so
on until the timer is stopped.   The lower the value of the PRx
register, the shorter the timer period will be.   The default value for
the PRX register at power up is 255.

The timer interrupt flag (TMRxIF) is set based upon the number of match
conditions as determine by the postscaler.   The postscaler does not
actually change the timer period, it changes the time between interrupt
conditions.

  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TMDec</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_tm1637_4_digits.html" title="7 Segment Displays - TM1637 4 Digits"><link rel="prev" href="_tm_bright.html" title="TM_Bright"><link rel="next" href="_tmhex.html" title="TMHex"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_tmdec"></a>TMDec</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    TMDec  Value [, Options ]</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><span class="emphasis"><em>Value</em></span> is a word value.&nbsp;&nbsp;
Only values from 0 to 9999 can be displayed, values greater than 9999 will be  displayed as ----.</p><p><span class="emphasis"><em>Options</em></span> as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">0 or omitted, only decimal value will be displayed;</li><li class="listitem">1 decimal valur with  the leading zeros;</li><li class="listitem">2 decimal number with the colon on digit 2;</li><li class="listitem">3 decimal number with the colon on digit 2 and the leading zeros.</li></ul></div><p><br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="tmdec"></span>TMDec

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    TMDec  Value [, Options ]
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

<span class="emphasis">*Value*</span> is a word value.   Only values
from 0 to 9999 can be displayed, values greater than 9999 will be
displayed as ----.

<span class="emphasis">*Options*</span> as follows:

<div class="itemizedlist">

-   0 or omitted, only decimal value will be displayed;
-   1 decimal valur with the leading zeros;
-   2 decimal number with the colon on digit 2;
-   3 decimal number with the colon on digit 2 and the leading zeros.

</div>

  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TMDec</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_tm1637_6_digits.html" title="7 Segment Displays - TM1637 6 Digits"><link rel="prev" href="_tm_bright_2.html" title="TM_Bright"><link rel="next" href="_tmhex_2.html" title="TMHex"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_tmdec_2"></a>TMDec</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    TMDec  Value [, Options ]</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><span class="emphasis"><em>Value</em></span> is a word value.&nbsp;&nbsp;
Only values from 0 to 9999 can be displayed, values greater than 9999 will be  displayed as ----.</p><p><span class="emphasis"><em>Options</em></span> as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">0 or omitted, only decimal value will be displayed;</li><li class="listitem">1 decimal valur with  the leading zeros;</li><li class="listitem">2 decimal number with the colon on digit 2;</li><li class="listitem">3 decimal number with the colon on digit 2 and the leading zeros.</li></ul></div><p><br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="tmdec_2"></span>TMDec

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    TMDec  Value [, Options ]
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

<span class="emphasis">*Value*</span> is a word value.   Only values
from 0 to 9999 can be displayed, values greater than 9999 will be
displayed as ----.

<span class="emphasis">*Options*</span> as follows:

<div class="itemizedlist">

-   0 or omitted, only decimal value will be displayed;
-   1 decimal valur with the leading zeros;
-   2 decimal number with the colon on digit 2;
-   3 decimal number with the colon on digit 2 and the leading zeros.

</div>

  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TMHex</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_tm1637_4_digits.html" title="7 Segment Displays - TM1637 4 Digits"><link rel="prev" href="_tmdec.html" title="TMDec"><link rel="next" href="_tmwritechar.html" title="TMWriteChar"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_tmhex"></a>TMHex</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    TMHex  Value</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><span class="emphasis"><em>Value</em></span> is a word value.&nbsp;&nbsp;
Only values from from 0x0000 to 0xFFFF can be displayed. Non-hex values will be displayed as greater than 9999 will be  displayed ??.</p><p><br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="tmhex"></span>TMHex

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    TMHex  Value
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

<span class="emphasis">*Value*</span> is a word value.   Only values
from from 0x0000 to 0xFFFF can be displayed. Non-hex values will be
displayed as greater than 9999 will be displayed ??.

  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TMHex</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_tm1637_6_digits.html" title="7 Segment Displays - TM1637 6 Digits"><link rel="prev" href="_tmdec_2.html" title="TMDec"><link rel="next" href="_tmwritechar_2.html" title="TMWriteChar"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_tmhex_2"></a>TMHex</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    TMHex  Value</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><span class="emphasis"><em>Value</em></span> is a word value.&nbsp;&nbsp;
Only values from from 0x0000 to 0xFFFF can be displayed. Non-hex values will be displayed as greater than 9999 will be  displayed ??.</p><p><br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="tmhex_2"></span>TMHex

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    TMHex  Value
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

<span class="emphasis">*Value*</span> is a word value.   Only values
from from 0x0000 to 0xFFFF can be displayed. Non-hex values will be
displayed as greater than 9999 will be displayed ??.

  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TMWrite4Dig</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_tm1637_4_digits.html" title="7 Segment Displays - TM1637 4 Digits"><link rel="prev" href="_7_segment_displays_tm1637_4_digits.html" title="7 Segment Displays - TM1637 4 Digits"><link rel="next" href="_tm_bright.html" title="TM_Bright"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_tmwrite4dig"></a>TMWrite4Dig</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    TMWrite4Dig (dig1, dig2, dig3, dig4  [, Brightness ],  Colon ]  ] )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Command defines each digit (left to right) as 0 to 9  OR 0x00 to 0x0F  (15). Additionally  0x10  (16) is a blank, 0x11 (17) is a minus sign, 0x12 (18) is a degree sign,  0x13 (19) is a  bracket and 0x14 (20) is a question mark.</p><p><span class="emphasis"><em>Brightness</em></span> set the brightness (8-15).
<span class="emphasis"><em>Colon</em></span>  turns the colon (only on  digit 2) to off (0) or on (1).
<br>
<br>
<br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="tmwrite4dig"></span>TMWrite4Dig

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    TMWrite4Dig (dig1, dig2, dig3, dig4  [, Brightness ],  Colon ]  ] )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

Command defines each digit (left to right) as 0 to 9 OR 0x00 to 0x0F
(15). Additionally 0x10 (16) is a blank, 0x11 (17) is a minus sign, 0x12
(18) is a degree sign, 0x13 (19) is a bracket and 0x14 (20) is a
question mark.

<span class="emphasis">*Brightness*</span> set the brightness (8-15).
<span class="emphasis">*Colon*</span> turns the colon (only on digit 2)
to off (0) or on (1).  
  
  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TMWrite6Dig</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_tm1637_6_digits.html" title="7 Segment Displays - TM1637 6 Digits"><link rel="prev" href="_7_segment_displays_tm1637_6_digits.html" title="7 Segment Displays - TM1637 6 Digits"><link rel="next" href="_tm_bright_2.html" title="TM_Bright"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_tmwrite6dig"></a>TMWrite6Dig</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    TMWrite6Dig (dig1, dig2, dig3, dig4, dig5, dig6, Brightness,  Point)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Command defines each digit (left to right) as 0 to 9  or 0x00 to 0x0F  (15). Additionally  0x10  (16) is a blank, 0x11 (17) is a minus sign, 0x12 (18) is a degree sign,  0x13 (19) is a  bracket and 0x14 (20) is a question mark.</p><p><span class="emphasis"><em>Brightness</em></span> set the brightness (8-15).
<span class="emphasis"><em>Colon</em></span>  turns the colon (only on  digit 2) to off (0) or on (1).
<br>
<br>
<br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="tmwrite6dig"></span>TMWrite6Dig

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    TMWrite6Dig (dig1, dig2, dig3, dig4, dig5, dig6, Brightness,  Point)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

Command defines each digit (left to right) as 0 to 9 or 0x00 to 0x0F
(15). Additionally 0x10 (16) is a blank, 0x11 (17) is a minus sign, 0x12
(18) is a degree sign, 0x13 (19) is a bracket and 0x14 (20) is a
question mark.

<span class="emphasis">*Brightness*</span> set the brightness (8-15).
<span class="emphasis">*Colon*</span> turns the colon (only on digit 2)
to off (0) or on (1).  
  
  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TMWriteChar</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_tm1637_4_digits.html" title="7 Segment Displays - TM1637 4 Digits"><link rel="prev" href="_tmhex.html" title="TMHex"><link rel="next" href="_7_segment_displays_tm1637_6_digits.html" title="7 Segment Displays - TM1637 6 Digits"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_tmwritechar"></a>TMWriteChar</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    TMWriteChar ( TMaddr, TMchar )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><span class="emphasis"><em>TMaddr</em></span> is 0 , 1 , 2 , 3 (display left to right)
<span class="emphasis"><em>TMchar</em></span> is a letter from A to Z (default alphabet) or from <code class="literal">a</code> to <code class="literal">z</code> Siekoo alphabet by Alexander Fakoo, more info at: <a class="link" href="http://en.fakoo.de/siekoo.html" target="_top">http://en.fakoo.de/siekoo.html</a>. &nbsp;&nbsp;
You can insert the special characters (blank, -, ) and/or ?).
<br>
<br>
Character map:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/TM1657a.png" align="middle" height="252" alt="graphic"></div></div><p><br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="tmwritechar"></span>TMWriteChar

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    TMWriteChar ( TMaddr, TMchar )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

<span class="emphasis">*TMaddr*</span> is 0 , 1 , 2 , 3 (display left to
right) <span class="emphasis">*TMchar*</span> is a letter from A to Z
(default alphabet) or from `a` to `z` Siekoo alphabet by Alexander
Fakoo, more info at: <http://en.fakoo.de/siekoo>.    You can insert
the special characters (blank, -, ) and/or ?).  
  
Character map:

<div class="informalfigure">

<div class="mediaobject" align="center">

<img src="./images/TM1657a.png" height="252" alt="graphic" />

</div>

</div>

  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TMWriteChar</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_tm1637_6_digits.html" title="7 Segment Displays - TM1637 6 Digits"><link rel="prev" href="_tmhex_2.html" title="TMHex"><link rel="next" href="_tm_point.html" title="TM_Point"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_tmwritechar_2"></a>TMWriteChar</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    TMWriteChar ( TMaddr, TMchar )</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><span class="emphasis"><em>TMaddr</em></span> is 0 , 1 , 2 , 3 4, 5 (display left to right)
<span class="emphasis"><em>TMchar</em></span> is a letter from A to Z (default alphabet) or from <code class="literal">a</code> to <code class="literal">z</code> Siekoo alphabet by Alexander Fakoo, more info at: <a class="link" href="http://en.fakoo.de/siekoo.html" target="_top">http://en.fakoo.de/siekoo.html</a>. &nbsp;&nbsp;
You can insert the special characters (blank, -, ) and/or ?).
<br>
<br>
Character map:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/TM1657a.png" align="middle" height="252" alt="graphic"></div></div><p><br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="tmwritechar_2"></span>TMWriteChar

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    TMWriteChar ( TMaddr, TMchar )
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

<span class="emphasis">*TMaddr*</span> is 0 , 1 , 2 , 3 4, 5 (display
left to right) <span class="emphasis">*TMchar*</span> is a letter from A
to Z (default alphabet) or from `a` to `z` Siekoo alphabet by Alexander
Fakoo, more info at: <http://en.fakoo.de/siekoo>.    You can insert
the special characters (blank, -, ) and/or ?).  
  
Character map:

<div class="informalfigure">

<div class="mediaobject" align="center">

<img src="./images/TM1657a.png" height="252" alt="graphic" />

</div>

</div>

  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TM_Bright</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_tm1637_4_digits.html" title="7 Segment Displays - TM1637 4 Digits"><link rel="prev" href="_tmwrite4dig.html" title="TMWrite4Dig"><link rel="next" href="_tmdec.html" title="TMDec"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_tm_bright"></a>TM_Bright</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    TM_Bright = Brightness</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><span class="emphasis"><em>Brightness</em></span> sets the brightness for the display with a range of 8 to 15.&nbsp;&nbsp;
Default to 15.&nbsp;&nbsp;
<br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="tm_bright"></span>TM\_Bright

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    TM_Bright = Brightness
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

<span class="emphasis">*Brightness*</span> sets the brightness for the
display with a range of 8 to 15.   Default to 15.    
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TM_Bright</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_tm1637_6_digits.html" title="7 Segment Displays - TM1637 6 Digits"><link rel="prev" href="_tmwrite6dig.html" title="TMWrite6Dig"><link rel="next" href="_tmdec_2.html" title="TMDec"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_tm_bright_2"></a>TM_Bright</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    TM_Bright = Brightness</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p><span class="emphasis"><em>Brightness</em></span> sets the brightness for the display with a range of 8 to 15.&nbsp;&nbsp;
Default to 15.&nbsp;&nbsp;</p><p>TM_Bright must be defined before the first use the commands: TMDec, TMHex or TMWriteChar, to set the brightness of the characters (8-15), without this, the display will be blank.</p><p><br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="tm_bright_2"></span>TM\_Bright

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    TM_Bright = Brightness
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

<span class="emphasis">*Brightness*</span> sets the brightness for the
display with a range of 8 to 15.   Default to 15.  

TM\_Bright must be defined before the first use the commands: TMDec,
TMHex or TMWriteChar, to set the brightness of the characters (8-15),
without this, the display will be blank.

  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TM_Point</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_7_segment_displays_tm1637_6_digits.html" title="7 Segment Displays - TM1637 6 Digits"><link rel="prev" href="_tmwritechar_2.html" title="TMWriteChar"><link rel="next" href="_one_wire_devices.html" title="One Wire Devices"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="_tm_point"></a>TM_Point</h6></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    TM_Point = (Point)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>Must be defined before use the command TMDec to set the decimal point(s)</p><p>Rules for decimal points</p><p>You can use the TM_Point and TMWrite6dig commands to turn on one or more decimal points.&nbsp;&nbsp;
This is achieved with an 8-bit binary number, with the leftmost bit (MSB) representing the 1st decimal point, the next the 2nd, and so on.&nbsp;&nbsp;
The state of the last two bits is ignored because it is only 6 digits.&nbsp;&nbsp;</p><p>Examples:</p><p>&#8226; binary number 0B01010000 (decimal 80) switch on decimal point on digits 2 and 4.
&#8226; number 0 switch off all digital points
&#8226; 255 (0B11111111) switch all on.</p><p><br>
<br>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

###### <span id="tm_point"></span>TM\_Point

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    TM_Point = (Point)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

Must be defined before use the command TMDec to set the decimal point(s)

Rules for decimal points

You can use the TM\_Point and TMWrite6dig commands to turn on one or
more decimal points.   This is achieved with an 8-bit binary number,
with the leftmost bit (MSB) representing the 1st decimal point, the next
the 2nd, and so on.   The state of the last two bits is ignored because
it is only 6 digits.  

Examples:

• binary number 0B01010000 (decimal 80) switch on decimal point on
digits 2 and 4. • number 0 switch off all digital points • 255
(0B11111111) switch all on.

  
  
  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Tone</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_sound.html" title="Sound"><link rel="prev" href="_sound_overview.html" title="Sound Overview"><link rel="next" href="_shorttone.html" title="ShortTone"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_tone"></a>Tone</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    Tone <span class="emphasis"><em>Frequency, Duration</em></span></pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will produce the specified tone for the specified duration.
<code class="literal"><span class="emphasis"><em>Frequency</em></span></code> is measured in Hz, and <code class="literal"><span class="emphasis"><em>Duration</em></span></code> is in 10 ms units.</p><p>Please note that this command may not produce the exact frequency
specified. While it is accurate enough for error beeps and small pieces
of monophonic music, it should not be used for anything that requires a
highly precise frequency.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">'Sample program to produce a constant A note (440 Hz)
'on PORTB bit 1.
#chip 16F877A, 20
#define SoundOut PORTB.1

Do
    Tone 440, 1000
Loop</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_sound_overview.html" title="Sound Overview">Sound Overview</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="tone"></span>Tone

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    Tone Frequency, Duration
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

This command will produce the specified tone for the specified duration.
`Frequency` is measured in Hz, and `Duration` is in 10 ms units.

Please note that this command may not produce the exact frequency
specified. While it is accurate enough for error beeps and small pieces
of monophonic music, it should not be used for anything that requires a
highly precise frequency.

<span class="strong">**Example:**</span>

``` screen
'Sample program to produce a constant A note (440 Hz)
'on PORTB bit 1.
#chip 16F877A, 20
#define SoundOut PORTB.1

Do
    Tone 440, 1000
Loop
```

<span class="strong">**For more help, see**</span>
<a href="sound_overview" class="link" title="Sound Overview">Sound Overview</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Touch Screen</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_triangle.html" title="Triangle"><link rel="next" href="_ads_7843_serial_driver.html" title="ADS 7843 Serial Driver"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_touch_screen"></a>Touch Screen</h3></div></div></div><p>This is the Touch Screen section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="touch_screen"></span>Touch Screen

</div>

</div>

</div>

This is the Touch Screen section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Triangle</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_lcd.html" title="Graphical LCD"><link rel="prev" href="_pset.html" title="Pset"><link rel="next" href="_touch_screen.html" title="Touch Screen"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_triangle"></a>Triangle</h4></div></div></div><p><span class="strong"><strong>Triangle:</strong></span></p><pre class="screen">    Triangle(XPixelPosition1, YPixelPosition1, XPixelPosition2, YPixelPosition2, XPixelPosition3, YPixelPosition3 [,Optional LineColour] )</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Draws a Triangle on a GLCD at <code class="literal">XPixelPositionN</code>, <code class="literal">YPixelPositionN</code>.</p><p>The constant <code class="literal">GLCD_PROTECTOVERRUN</code> can be added to prevent Triangles from
re-drawing at the screen edges. Ensure the <code class="literal">GLCD_Width</code> and <code class="literal">GLCD_HEIGHT</code>
constants are set correctly when using this additional constant.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #include &lt;glcd.h&gt;

    Triangle(0, 0, 31, 63, 127, 0 )</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="triangle"></span>Triangle

</div>

</div>

</div>

<span class="strong">**Triangle:**</span>

``` screen
    Triangle(XPixelPosition1, YPixelPosition1, XPixelPosition2, YPixelPosition2, XPixelPosition3, YPixelPosition3 [,Optional LineColour] )
```

<span class="strong">**Explanation:**</span>

Draws a Triangle on a GLCD at `XPixelPositionN`, `YPixelPositionN`.

The constant `GLCD_PROTECTOVERRUN` can be added to prevent Triangles
from re-drawing at the screen edges. Ensure the `GLCD_Width` and
`GLCD_HEIGHT` constants are set correctly when using this additional
constant.

<span class="strong">**Example:**</span>

``` screen
    #include <glcd.h>

    Triangle(0, 0, 31, 63, 127, 0 )
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Tricks and Tips</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_acknowledgements.html" title="Acknowledgements"><link rel="next" href="_uno_as_isp_programmer.html" title="UNO as ISP programmer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_tricks_and_tips"></a>Tricks and Tips</h2></div></div></div><p>This is a collation of tricks and tips that may be useful to you.
<br>
<br>
<a class="link" href="_tricks_and_tips.html#RAMVARIABLESANDRESETS">RAM, variables and resets</a></p><p><a class="link" href="_tricks_and_tips.html#FORNEXTLEGACY">Reverting the FOR-NEXT loop to the Legacy FOR-NEXT method</a></p><p><a class="link" href="_tricks_and_tips.html#REQUIRED">Change the compilers behaviour when the compiler states a capability is not available</a></p><p><a class="link" href="_tricks_and_tips.html#MINIMALASM">Create a minimal ASM source with no config and/or initsys</a></p><p><a class="link" href="_tricks_and_tips.html#PPSandUSARTs">PPS microconrollers and multiple USARTs</a>
<br>
<br></p><p><a name="RAMVARIABLESANDRESETS"></a><span class="strong"><strong>TIP: RAM, variables and resets</strong></span></p><p>When you define a variable it will be mapped to a RAM location.&nbsp;&nbsp;
As you develop your solution your should always do the following to ensure the variable are initialised correctly.&nbsp;&nbsp;</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Always initialise variables to a known state</li></ul></div><p>A variable will not show up in the ASM source code unless it is used somewhere in code. &nbsp;&nbsp;
Adding <code class="literal">Variable = 0</code>  will assure that the variable is initialised and will show up in the ASM.&nbsp;&nbsp;
This is very useful for troubleshooting.&nbsp;&nbsp;
This is essential when debugging ASM to look at variables that are defined using "EQU".&nbsp;&nbsp;
If you do not initialise or use the variable then the variable will not be shown in the EQU list of variables.&nbsp;&nbsp;
So, initialise all your variables.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Always power cycle the microcontroller after programming</li></ul></div><p>A soft reset when debugging/testing/programming will not reset the RAM to a known state.
This is essential when debugging ASM to look at variables that are defined using "EQU".&nbsp;&nbsp;
A soft reset  does not change the contents of RAM.&nbsp;&nbsp;
Where a hard reset reverts ram back to an undefined /random state!&nbsp;&nbsp;
So, a power cycle is good practice.&nbsp;&nbsp;
<br>
<br></p><p><a name="FORNEXTLEGACY"></a><span class="strong"><strong>TRICK: Reverting the FOR-NEXT loop to the Legacy FOR-NEXT method ?</strong></span></p><p>Why do this?  To reduce the PROGMEM size.&nbsp;&nbsp;
But, you must assure yourself that the loop variable cannot overflow as the legacy FOR-NEXT does not prevent an overflow of the loop variable.</p><p>Some background.&nbsp;&nbsp;
In 2021 the GCBASIC compiler was updated to improve the operation of the FOR-NEXT loop.&nbsp;&nbsp;
The improvement did increase the size of the ASM generated.&nbsp;&nbsp;
The legacy FOR-NEXT loop had some major issues that included never ending loops, incorrect end loop and unexpected operations.&nbsp;&nbsp;
This was all caused by the compiler, not the user, and in 2021 the compiler was updated to resolve these issues.&nbsp;&nbsp;</p><p>However, there is a risk that the new FOR-NEXT method causes 1) larger ASM that will not fit in small microcontrollers or 2) the new code does not operate as expected.&nbsp;&nbsp;
In either case you can disable the new FOR-NEXT method by adding a constant as shown below.&nbsp;&nbsp;
Adding this constant will revert the FOR-NEXT loop asm generated to the legacy method.&nbsp;&nbsp;</p><pre class="screen">    #DEFINE USELEGACYFORNEXT</pre><p><br>
<br></p><p><a name="REQUIRED"></a><span class="strong"><strong>TRICK: How to change the compilers behaviour when the compiler states a capability is not available when I know it is ?</strong></span></p><p>The compiler is issuing an error message that a EEPROM, HEF, SAF, PWM16 or hardware USART is not available&#8230;&#8203; but, it is.&nbsp;&nbsp;</p><p>This is caused by the microcontroller DAT file.&nbsp;&nbsp;
The microcontroller DAT file is missing key information that informs the compiler that a specific capability is available.&nbsp;&nbsp;
This information was added to prevent silent failures where you could use a capability when it is not available.&nbsp;&nbsp;</p><p>The compiler thinks your microcontroller does not have the selected capability. &nbsp;&nbsp;
Simply use the table below to resolve.&nbsp;&nbsp;
Adding the constant defined to your source program.&nbsp;&nbsp;</p><p>Then, let us know via the Forum so we can correct the source microcontroller DAT file.
<br>
<br></p><div class="horizontal"><table border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top">
<p>EEPROM</p>
</td><td valign="top">
<p><code class="literal">#DEFINE CHIPEEPROM = 1</code></p>
</td></tr><tr><td valign="top">
<p>HEF</p>
</td><td valign="top">
<p><code class="literal">#DEFINE  CHIPHEFWORDS = 128</code></p>
</td></tr><tr><td valign="top">
<p>SAF</p>
</td><td valign="top">
<p><code class="literal">#DEFINE  CHIPSAFWORDS = 128</code></p>
</td></tr><tr><td valign="top">
<p>PWM16</p>
</td><td valign="top">
<p><code class="literal">#DEFINE  CHIPPWM16TYPE  = 1</code></p>
</td></tr><tr><td valign="top">
<p>USART hardware</p>
</td><td valign="top">
<p><code class="literal">#DEFINE  CHIPUSART  = 1</code></p>
</td></tr></tbody></table></div><p><br>
<br></p><p><a name="MINIMALASM"></a><span class="strong"><strong>TRICK: How do I create a minimal ASM source with no config and/or initsys?</strong></span></p><p>Very easy.&nbsp;&nbsp;
Simple add two <code class="literal">#OPTION</code> statements.&nbsp;&nbsp;</p><p><code class="literal">#OPTION UserCodeOnly ENTERBOOTLOADER:</code> &nbsp;&nbsp;This will instruct the compiler to NOT call the INITSYS() method.&nbsp;&nbsp;
And, to jump to a label.&nbsp;&nbsp;
The label is mandated.&nbsp;&nbsp;The label specified will be included in the ASM generated.</p><p><code class="literal">#OPTION NoConfig</code>&nbsp;&nbsp;This will instruct the compiler to NOT add the microcontroller specific config statements.</p><p>Example:</p><pre class="screen">    #chip 16f877a, 4
    #OPTION Explicit

    #OPTION UserCodeOnly ENTERBOOTLOADER:
    #OPTION NoConfig

    ENTERBOOTLOADER:</pre><p>The example above yields the following asm.&nbsp;&nbsp;
Comment lines have been removed for clarity.</p><pre class="screen">     LIST p=16F877A, r=DEC
    #include &lt;P16F877A.inc&gt;

    ;Vectors
      ORG 0
      pagesel ENTERBOOTLOADER
      goto  ENTERBOOTLOADER

    ;ORG 5


    ENTERBOOTLOADER

    ;ORG 2048
    ;ORG 4096
    ;ORG 6144

     END</pre><p><a name="PPSandUSARTs"></a><span class="strong"><strong>TIP: PPS and multiple USARTs</strong></span></p><p>You can set up multiple pins to simultaneously operate as a peripheral output on microcontrollers with Peripheral Pin Select (PPS).
<br>
<br>
PPS microcontrollers can set up to simultaneously output specific modules.&nbsp;&nbsp;
The example below shows the method to output two TX ports.&nbsp;&nbsp;
Hardware Serial (TX1) data will now be output on both B.6 and C.6
<br>
<br></p><pre class="screen">    Sub InitPPS
            'Module: UART pin directions
            Dir PORTC.6 Out    ' Make TX1 pin an output
            Dir PORTB.6 Out    ' Make TX1 pin an output
            'Module: UART1 to two ports
            RC6PPS = 0x0020    'TX1 &gt; RC6
            RB6PPS = 0x0020    'TX1 &gt; RB6

    End Sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="tricks_and_tips"></span>Tricks and Tips
--------------------------------------------------

</div>

</div>

</div>

This is a collation of tricks and tips that may be useful to you.  
  
<a href="tricks_and_tips#RAMVARIABLESANDRESETS" class="link">RAM, variables and resets</a>

<a href="tricks_and_tips#FORNEXTLEGACY" class="link">Reverting the FOR-NEXT loop to the Legacy FOR-NEXT method</a>

<a href="tricks_and_tips#REQUIRED" class="link">Change the compilers behaviour when the compiler states a capability is not available</a>

<a href="tricks_and_tips#MINIMALASM" class="link">Create a minimal ASM source with no config and/or initsys</a>

<a href="tricks_and_tips#PPSandUSARTs" class="link">PPS microconrollers and multiple USARTs</a>  
  

<span id="RAMVARIABLESANDRESETS"></span><span class="strong">**TIP: RAM,
variables and resets**</span>

When you define a variable it will be mapped to a RAM location.   As you
develop your solution your should always do the following to ensure the
variable are initialised correctly.  

<div class="itemizedlist">

-   Always initialise variables to a known state

</div>

A variable will not show up in the ASM source code unless it is used
somewhere in code.    Adding `Variable = 0` will assure that the
variable is initialised and will show up in the ASM.   This is very
useful for troubleshooting.   This is essential when debugging ASM to
look at variables that are defined using "EQU".   If you do not
initialise or use the variable then the variable will not be shown in
the EQU list of variables.   So, initialise all your variables.

<div class="itemizedlist">

-   Always power cycle the microcontroller after programming

</div>

A soft reset when debugging/testing/programming will not reset the RAM
to a known state. This is essential when debugging ASM to look at
variables that are defined using "EQU".   A soft reset does not change
the contents of RAM.   Where a hard reset reverts ram back to an
undefined /random state!   So, a power cycle is good practice.    
  

<span id="FORNEXTLEGACY"></span><span class="strong">**TRICK: Reverting
the FOR-NEXT loop to the Legacy FOR-NEXT method ?**</span>

Why do this? To reduce the PROGMEM size.   But, you must assure yourself
that the loop variable cannot overflow as the legacy FOR-NEXT does not
prevent an overflow of the loop variable.

Some background.   In 2021 the GCBASIC compiler was updated to improve
the operation of the FOR-NEXT loop.   The improvement did increase the
size of the ASM generated.   The legacy FOR-NEXT loop had some major
issues that included never ending loops, incorrect end loop and
unexpected operations.   This was all caused by the compiler, not the
user, and in 2021 the compiler was updated to resolve these issues.  

However, there is a risk that the new FOR-NEXT method causes 1) larger
ASM that will not fit in small microcontrollers or 2) the new code does
not operate as expected.   In either case you can disable the new
FOR-NEXT method by adding a constant as shown below.   Adding this
constant will revert the FOR-NEXT loop asm generated to the legacy
method.  

``` screen
    #DEFINE USELEGACYFORNEXT
```

  
  

<span id="REQUIRED"></span><span class="strong">**TRICK: How to change
the compilers behaviour when the compiler states a capability is not
available when I know it is ?**</span>

The compiler is issuing an error message that a EEPROM, HEF, SAF, PWM16
or hardware USART is not available…​ but, it is.  

This is caused by the microcontroller DAT file.   The microcontroller
DAT file is missing key information that informs the compiler that a
specific capability is available.   This information was added to
prevent silent failures where you could use a capability when it is not
available.  

The compiler thinks your microcontroller does not have the selected
capability.    Simply use the table below to resolve.   Adding the
constant defined to your source program.  

Then, let us know via the Forum so we can correct the source
microcontroller DAT file.  
  

<div class="horizontal">

|                |                               |
|----------------|-------------------------------|
| EEPROM         | `#DEFINE CHIPEEPROM = 1`      |
| HEF            | `#DEFINE  CHIPHEFWORDS = 128` |
| SAF            | `#DEFINE  CHIPSAFWORDS = 128` |
| PWM16          | `#DEFINE  CHIPPWM16TYPE  = 1` |
| USART hardware | `#DEFINE  CHIPUSART  = 1`     |

</div>

  
  

<span id="MINIMALASM"></span><span class="strong">**TRICK: How do I
create a minimal ASM source with no config and/or initsys?**</span>

Very easy.   Simple add two `#OPTION` statements.  

`#OPTION UserCodeOnly ENTERBOOTLOADER:`   This will instruct the
compiler to NOT call the INITSYS() method.   And, to jump to a label.  
The label is mandated.  The label specified will be included in the ASM
generated.

`#OPTION NoConfig`  This will instruct the compiler to NOT add the
microcontroller specific config statements.

Example:

``` screen
    #chip 16f877a, 4
    #OPTION Explicit

    #OPTION UserCodeOnly ENTERBOOTLOADER:
    #OPTION NoConfig

    ENTERBOOTLOADER:
```

The example above yields the following asm.   Comment lines have been
removed for clarity.

``` screen
     LIST p=16F877A, r=DEC
    #include <P16F877A.inc>

    ;Vectors
      ORG 0
      pagesel ENTERBOOTLOADER
      goto  ENTERBOOTLOADER

    ;ORG 5


    ENTERBOOTLOADER

    ;ORG 2048
    ;ORG 4096
    ;ORG 6144

     END
```

<span id="PPSandUSARTs"></span><span class="strong">**TIP: PPS and
multiple USARTs**</span>

You can set up multiple pins to simultaneously operate as a peripheral
output on microcontrollers with Peripheral Pin Select (PPS).  
  
PPS microcontrollers can set up to simultaneously output specific
modules.   The example below shows the method to output two TX ports.  
Hardware Serial (TX1) data will now be output on both B.6 and C.6  
  

``` screen
    Sub InitPPS
            'Module: UART pin directions
            Dir PORTC.6 Out    ' Make TX1 pin an output
            Dir PORTB.6 Out    ' Make TX1 pin an output
            'Module: UART1 to two ports
            RC6PPS = 0x0020    'TX1 > RC6
            RB6PPS = 0x0020    'TX1 > RB6

    End Sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Trigonometry ATAN</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_maths.html" title="Maths"><link rel="prev" href="_trigonometry_sine_cosine_and_tangent.html" title="Trigonometry Sine, Cosine and Tangent"><link rel="next" href="_peripheral_pin_select.html" title="Peripheral Pin Select"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_trigonometry_atan"></a>Trigonometry ATAN</h4></div></div></div><p><span class="strong"><strong>Syntax</strong></span>:</p><pre class="screen">    #include &lt;maths.h&gt;

    integer_variable = ATan (_x_vector_,_y_vector_)</pre><p><span class="strong"><strong>Explanation</strong></span>:</p><p>GCBASIC supports the trigonometric function for ATan.&nbsp;&nbsp;</p><p><span class="strong"><strong>Details:</strong></span></p><p>GCBASIC supports the following functions ATan( x, y) where x and y are the vectors.  The function returns an Integer result representing the angle measured in a whole number of degrees.</p><p>The function also returns a global byte variable NegFlag with returns the quadrant of the angle.</p><pre class="literallayout">Quadrant 1 = 0 to 89
Quadrant 2 = 90 to 179
Quadrant 3 = 180 to 269
Quadrant 4 = 270 to 359</pre><p>This ATan function is a fast XY vector to integer degree algorithm developed in Jan 2011, see www.RomanBlack.com and see <a class="link" href="http://www.romanblack.com/integer_degree.htm" target="_top">http://www.romanblack.com/integer_degree.htm</a></p><p>The function converts any XY vectors including 0 to a degree value that should be within +/- 1 degree of the accurate value without needing large slow trig functions like ArcTan() or ArcCos().</p><p>At least one of the X or Y values must be non-zero.&nbsp;&nbsp;
This is the full version, for all 4 quadrants and will generate the angle in integer degrees from 0-360.&nbsp;&nbsp;
Any values of X and Y are usable including negative values provided they are between -1456 and 1456 so the 16bit multiply does not overflow.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="trigonometry_atan"></span>Trigonometry ATAN

</div>

</div>

</div>

<span class="strong">**Syntax**</span>:

``` screen
    #include <maths.h>

    integer_variable = ATan (_x_vector_,_y_vector_)
```

<span class="strong">**Explanation**</span>:

GCBASIC supports the trigonometric function for ATan.  

<span class="strong">**Details:**</span>

GCBASIC supports the following functions ATan( x, y) where x and y are
the vectors. The function returns an Integer result representing the
angle measured in a whole number of degrees.

The function also returns a global byte variable NegFlag with returns
the quadrant of the angle.

``` literallayout
Quadrant 1 = 0 to 89
Quadrant 2 = 90 to 179
Quadrant 3 = 180 to 269
Quadrant 4 = 270 to 359
```

This ATan function is a fast XY vector to integer degree algorithm
developed in Jan 2011, see www.RomanBlack.com and see
<http://www.romanblack.com/integer_degree.htm>

The function converts any XY vectors including 0 to a degree value that
should be within +/- 1 degree of the accurate value without needing
large slow trig functions like ArcTan() or ArcCos().

At least one of the X or Y values must be non-zero.   This is the full
version, for all 4 quadrants and will generate the angle in integer
degrees from 0-360.   Any values of X and Y are usable including
negative values provided they are between -1456 and 1456 so the 16bit
multiply does not overflow.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Trigonometry Circle</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_example_programs.html" title="Example Programs"><link rel="prev" href="_serial_rs232_buffer_ring.html" title="Serial/RS232 Buffer Ring"><link rel="next" href="_graphical_gcbasic.html" title="Graphical GCBASIC"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_trigonometry_circle"></a>Trigonometry Circle</h3></div></div></div><p><span class="strong"><strong>Explanation:</strong></span></p><p>GCBASIC can draw circles on a Graphical LCD device using GCBASIC library functions.</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/trigonometrycirclesb1.PNG" align="middle" alt="graphic"></div></div><p><span class="strong"><strong>Demonstration program:</strong></span></p><pre class="screen">    ;Circle and filled circle commands on a graphic LCD.
    ;This uses the 2-place trigonometric routines found in the include file.

    ;----- Configuration
    #CHIP 16F88, 8              ;PIC16F88 RUNNING AT 8 MHZ
    #CONFIG MCLR=OFF            ;RESET HANDLED INTERNALLY
    #OPTION EXPLICIT
    #DEFINE USELEGACYFORNEXT    ;WILL ENSURE THE OLD FOR-NEXT Loop is used just to save some memory as this is a very simple FOR-NEXT loop

    #INCLUDE &lt;GLCD.H&gt;
    #INCLUDE &lt;TRIG2PLACES.H&gt;

    ;----- Constants

    ;Pinout is shown for the LCM12864H-FSB-FBW
    ;graphical LCD available from Amazon.

    ;       +5V                 ;LCD pin 1
    ;       ground              ;LCD pin 2
    ;       Vo = wiper of pot   ;LCD pin 3
    #define GLCD_DB0 PORTB.0    ;LCD pin 4
    #define GLCD_DB1 PORTB.1    ;LCD pin 5
    #define GLCD_DB2 PORTB.2    ;LCD pin 6
    #define GLCD_DB3 PORTB.3    ;LCD pin 7
    #define GLCD_DB4 PORTB.4    ;LCD pin 8
    #define GLCD_DB5 PORTB.5    ;LCD pin 9
    #define GLCD_DB6 PORTB.6    ;LCD pin 10
    #define GLCD_DB7 PORTB.7    ;LCD pin 11
    #define GLCD_CS2 PORTA.0    ;LCD pin 12
    #define GLCD_CS1 PORTA.1    ;LCD pin 13
    #define GLCD_RESET PORTA.2  ;LCD pin 14
    #define GLCD_RW PORTA.3     ;LCD pin 15
    #define GLCD_RS PORTA.4     ;LCD pin 16
    #define GLCD_ENABLE PORTA.6 ;LCD pin 17
    ;       Vee = pot low side  ;LCD pin 18
    ;       backlight anode     ;LCD pin 19
    ;       backlight cathode   ;LCD pin 20

    #define GLCD_TYPE GLCD_TYPE_KS0108
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 64


    ;----- Variables

    dim cx, cy, edge, jj as byte
    dim ii as word

    ;----- Program

    myCircle(10,10,10)
    ;upper left
    myCircle(117,10,10)                 ;upper right
    myCircleFilled(63,31,10)            ;center
    myCircle(63,31,20)                  ;center
    myCircleFilled(10,53,10)            ;lower left
    myCircleFilled(117,53,10)           ;lower right

    ;----- Subroutines

    sub myCircle(cenX, cenY, rad)
        ;Center of circle = (cenX,cenY), radius = rad

        for ii = 0 to 358 step 2                 ;every two degrees
            cx = cenX -((10*rad*cos(ii))/100+5)/10  ;properly rounded x value
            cy = cenY -((10*rad*sin(ii))/100+5)/10  ;properly rounded y value

            ;the following ignores the pixel if off the screen
            if (cx&gt;=0 and cx&lt;=GLCD_WIDTH and cy&gt;=0 and cy&lt;=GLCD_HEIGHT) then
            Pset(cx, cy, on)
            end if
        next ii
    end sub

    sub myCircleFilled(cenX, cenY, rad)
        ;Center of circle = (cenX,cenY), radius = rad

        for ii = 0 to 358 step 2
            cx = cenX -((10*rad*cos(ii))/100+5)/10
            cy = cenY -((10*rad*sin(ii))/100+5)/10
            edge = 2 * cenX - cx                  ;compute right edge

            for jj = cx to edge                    ;fill entire line, uses legacy for next permitting CX to be less than edge
                if (jj&gt;=0 and jj&lt;=GLCD_WIDTH and cy&gt;=0 and cy&lt;=GLCD_HEIGHT) then
                    Pset(jj,cy,on)
                end if
            next jj
        next ii
    end sub</pre><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_trigonometry_sine_cosine_and_tangent.html" title="Trigonometry Sine, Cosine and Tangent">Trigonometry</a>, <a class="link" href="_circle.html" title="Circle">Circle</a>, <a class="link" href="_filledcircle.html" title="FilledCircle">FilledCircle</a>,</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="trigonometry_circle"></span>Trigonometry Circle

</div>

</div>

</div>

<span class="strong">**Explanation:**</span>

GCBASIC can draw circles on a Graphical LCD device using GCBASIC library
functions.

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/trigonometrycirclesb1.PNG)

</div>

</div>

<span class="strong">**Demonstration program:**</span>

``` screen
    ;Circle and filled circle commands on a graphic LCD.
    ;This uses the 2-place trigonometric routines found in the include file.

    ;----- Configuration
    #CHIP 16F88, 8              ;PIC16F88 RUNNING AT 8 MHZ
    #CONFIG MCLR=OFF            ;RESET HANDLED INTERNALLY
    #OPTION EXPLICIT
    #DEFINE USELEGACYFORNEXT    ;WILL ENSURE THE OLD FOR-NEXT Loop is used just to save some memory as this is a very simple FOR-NEXT loop

    #INCLUDE <GLCD.H>
    #INCLUDE <TRIG2PLACES.H>

    ;----- Constants

    ;Pinout is shown for the LCM12864H-FSB-FBW
    ;graphical LCD available from Amazon.

    ;       +5V                 ;LCD pin 1
    ;       ground              ;LCD pin 2
    ;       Vo = wiper of pot   ;LCD pin 3
    #define GLCD_DB0 PORTB.0    ;LCD pin 4
    #define GLCD_DB1 PORTB.1    ;LCD pin 5
    #define GLCD_DB2 PORTB.2    ;LCD pin 6
    #define GLCD_DB3 PORTB.3    ;LCD pin 7
    #define GLCD_DB4 PORTB.4    ;LCD pin 8
    #define GLCD_DB5 PORTB.5    ;LCD pin 9
    #define GLCD_DB6 PORTB.6    ;LCD pin 10
    #define GLCD_DB7 PORTB.7    ;LCD pin 11
    #define GLCD_CS2 PORTA.0    ;LCD pin 12
    #define GLCD_CS1 PORTA.1    ;LCD pin 13
    #define GLCD_RESET PORTA.2  ;LCD pin 14
    #define GLCD_RW PORTA.3     ;LCD pin 15
    #define GLCD_RS PORTA.4     ;LCD pin 16
    #define GLCD_ENABLE PORTA.6 ;LCD pin 17
    ;       Vee = pot low side  ;LCD pin 18
    ;       backlight anode     ;LCD pin 19
    ;       backlight cathode   ;LCD pin 20

    #define GLCD_TYPE GLCD_TYPE_KS0108
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 64


    ;----- Variables

    dim cx, cy, edge, jj as byte
    dim ii as word

    ;----- Program

    myCircle(10,10,10)
    ;upper left
    myCircle(117,10,10)                 ;upper right
    myCircleFilled(63,31,10)            ;center
    myCircle(63,31,20)                  ;center
    myCircleFilled(10,53,10)            ;lower left
    myCircleFilled(117,53,10)           ;lower right

    ;----- Subroutines

    sub myCircle(cenX, cenY, rad)
        ;Center of circle = (cenX,cenY), radius = rad

        for ii = 0 to 358 step 2                 ;every two degrees
            cx = cenX -((10*rad*cos(ii))/100+5)/10  ;properly rounded x value
            cy = cenY -((10*rad*sin(ii))/100+5)/10  ;properly rounded y value

            ;the following ignores the pixel if off the screen
            if (cx>=0 and cx<=GLCD_WIDTH and cy>=0 and cy<=GLCD_HEIGHT) then
            Pset(cx, cy, on)
            end if
        next ii
    end sub

    sub myCircleFilled(cenX, cenY, rad)
        ;Center of circle = (cenX,cenY), radius = rad

        for ii = 0 to 358 step 2
            cx = cenX -((10*rad*cos(ii))/100+5)/10
            cy = cenY -((10*rad*sin(ii))/100+5)/10
            edge = 2 * cenX - cx                  ;compute right edge

            for jj = cx to edge                    ;fill entire line, uses legacy for next permitting CX to be less than edge
                if (jj>=0 and jj<=GLCD_WIDTH and cy>=0 and cy<=GLCD_HEIGHT) then
                    Pset(jj,cy,on)
                end if
            next jj
        next ii
    end sub
```

<span class="strong">**See also**</span>
<a href="trigonometry_sine_cosine_and_tangent" class="link" title="Trigonometry Sine, Cosine and Tangent">Trigonometry</a>,
<a href="circle" class="link" title="Circle">Circle</a>,
<a href="filledcircle" class="link" title="FilledCircle">FilledCircle</a>,

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Trigonometry Sine, Cosine and Tangent</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_maths.html" title="Maths"><link rel="prev" href="_sqrt.html" title="Sqrt"><link rel="next" href="_trigonometry_atan.html" title="Trigonometry ATAN"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_trigonometry_sine_cosine_and_tangent"></a>Trigonometry Sine, Cosine and Tangent</h4></div></div></div><p><span class="strong"><strong>Syntax</strong></span>:</p><pre class="screen">    integer_variable = sin( <span class="emphasis"><em>integer_variable</em></span> )

    integer_variable = cos( <span class="emphasis"><em>integer_variable</em></span> )

    integer_variable = tan( <span class="emphasis"><em>integer_variable</em></span> )</pre><p><span class="strong"><strong>Explanation</strong></span>:</p><p>GCBASIC supports Three Primary Trigonometric Functions</p><p>GCBASIC supports the following functions, sin(x), cos(x), tan(x), where x is a signed integer representing an angle measured in a whole number of degrees.&nbsp;&nbsp;
The output values are also integers, represented as fixed point decimal fractions.</p><p><span class="strong"><strong>Details:</strong></span></p><p>The sine, cosine and tangent functions are available for your programs simply by including the header file offering the precision you need.</p><pre class="screen">    #INCLUDE &lt;TRIG2PLACES.H&gt; gives two decimal places
    #INCLUDE &lt;TRIG3PLACES.H&gt; gives three decimal places
    #INCLUDE &lt;TRIG4PLACES.H&gt; gives four decimal places</pre><p>In fixed point representation, the decimal point is assumed.&nbsp;&nbsp;For example, with two places of accuracy, sin(60) returns 87, which you would interpret as 0.87.&nbsp;&nbsp;With three places, 866 is returned, to be interpreted as 0.866, and so on.&nbsp;&nbsp;Another way of thinking of this is to consider the two-place values as scaled up by 100, the three-place values scaled up by 1000 and the four-place values scaled up by 10,000.</p><p>Sine and Cosine are always defined, but remember that tangent fails to exist at 90 degrees, 270 degrees and all their coterminal angles.&nbsp;&nbsp;It is the responsibility of the calling program to avoid these special values.</p><p>Note that the tangent function is not available to four decimal places, since its value grows so rapidly, exceeding what the Integer data type can represent.</p><p>These routines are completely general. The input argument may be positive, negative or zero, with no restriction on the size.&nbsp;&nbsp;Further observe that lookup tables are used, so the routines are very fast, efficient and accurate.</p><p><span class="strong"><strong>Example: Show the trigonometric values to three decimal places.</strong></span></p><pre class="screen">    ;----- Configuration
    #CHIP 16F88, 8                  ;PIC16F88 RUNNING AT 8 MHZ
    #CONFIG MCLR=OFF                ;RESET HANDLED INTERNALLY

    #INCLUDE &lt;TRIG3PLACES.H&gt;

    ;----- Constants

    #define LCD_IO      4           ;4-bit mode
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS      PortB.2     ;pin 8 is LCD Register Select
    #define LCD_Enable  PortB.3     ;pin 9 is LCD Enable
    #define LCD_DB4     PortB.4     ;DB4 on pin 10
    #define LCD_DB5     PortB.5     ;DB5 on pin 11
    #define LCD_DB6     PortB.6     ;DB6a on pin 12
    #define LCD_DB7     PortB.7     ;DB7 on pin 13
    #define LCD_NO_RW   1           ;ground the RW line on LCD

    ;----- Variables

    dim ii as integer
    dim outStr, valStr as string

    ;----- Program

    dir PortB out                   ;all outputs to the LCD

    for ii = -720 to 720             ;arguments from -720 to 720
    cls
    print "sin("                  ;print the label
    print ii                      ;and the argument
    print ")="                    ;and closing parenthesis
    locate 1,0
    printTrig(sin(ii))             ;print value of the sine
    wait 500 mS                   ;pause to view

    cls                           ;do likewise for cosine
    print "cos("
    print ii
    print ")="
    locate 1,0
    printTrig(cos(ii))
    wait 500 mS                   ;pause to view
    cls                           ;do likewise for tangent
    print "tan("
    print ii
    print ")="
    locate 1,0
    printTrig(tan(ii))
    wait 500 mS                   ;pause to view
    next i

    sub printTrig(in value as integer)
        ;print decently formatted trig results

        outStr = ""                   ;assume positive (no sign)

        if value &lt; 0 then             ;handle negatives
            outStr = "-"                ;prefix a minus sign
            value = -1 * value          ;but work with positives
        end if

        valStr = str(value)
        length = len(valStr)
        select case length
            case 1:
            outStr = outStr + "0.00" + valStr
            case 2:
            outStr = outStr + "0.0" + valStr
            case 3:
            outStr = outStr + "0." + valStr
            case 4:
            outStr = outStr + left(valStr,1) + "." + right(valStr,3)
            case 5:
            outStr = outStr + left(valStr,2) + "." + right(valStr,3)
        end select
        print outStr
    end sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="trigonometry_sine_cosine_and_tangent"></span>Trigonometry Sine, Cosine and Tangent

</div>

</div>

</div>

<span class="strong">**Syntax**</span>:

``` screen
    integer_variable = sin( integer_variable )

    integer_variable = cos( integer_variable )

    integer_variable = tan( integer_variable )
```

<span class="strong">**Explanation**</span>:

GCBASIC supports Three Primary Trigonometric Functions

GCBASIC supports the following functions, sin(x), cos(x), tan(x), where
x is a signed integer representing an angle measured in a whole number
of degrees.   The output values are also integers, represented as fixed
point decimal fractions.

<span class="strong">**Details:**</span>

The sine, cosine and tangent functions are available for your programs
simply by including the header file offering the precision you need.

``` screen
    #INCLUDE <TRIG2PLACES.H> gives two decimal places
    #INCLUDE <TRIG3PLACES.H> gives three decimal places
    #INCLUDE <TRIG4PLACES.H> gives four decimal places
```

In fixed point representation, the decimal point is assumed.  For
example, with two places of accuracy, sin(60) returns 87, which you
would interpret as 0.87.  With three places, 866 is returned, to be
interpreted as 0.866, and so on.  Another way of thinking of this is to
consider the two-place values as scaled up by 100, the three-place
values scaled up by 1000 and the four-place values scaled up by 10,000.

Sine and Cosine are always defined, but remember that tangent fails to
exist at 90 degrees, 270 degrees and all their coterminal angles.  It is
the responsibility of the calling program to avoid these special values.

Note that the tangent function is not available to four decimal places,
since its value grows so rapidly, exceeding what the Integer data type
can represent.

These routines are completely general. The input argument may be
positive, negative or zero, with no restriction on the size.  Further
observe that lookup tables are used, so the routines are very fast,
efficient and accurate.

<span class="strong">**Example: Show the trigonometric values to three
decimal places.**</span>

``` screen
    ;----- Configuration
    #CHIP 16F88, 8                  ;PIC16F88 RUNNING AT 8 MHZ
    #CONFIG MCLR=OFF                ;RESET HANDLED INTERNALLY

    #INCLUDE <TRIG3PLACES.H>

    ;----- Constants

    #define LCD_IO      4           ;4-bit mode
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS      PortB.2     ;pin 8 is LCD Register Select
    #define LCD_Enable  PortB.3     ;pin 9 is LCD Enable
    #define LCD_DB4     PortB.4     ;DB4 on pin 10
    #define LCD_DB5     PortB.5     ;DB5 on pin 11
    #define LCD_DB6     PortB.6     ;DB6a on pin 12
    #define LCD_DB7     PortB.7     ;DB7 on pin 13
    #define LCD_NO_RW   1           ;ground the RW line on LCD

    ;----- Variables

    dim ii as integer
    dim outStr, valStr as string

    ;----- Program

    dir PortB out                   ;all outputs to the LCD

    for ii = -720 to 720             ;arguments from -720 to 720
    cls
    print "sin("                  ;print the label
    print ii                      ;and the argument
    print ")="                    ;and closing parenthesis
    locate 1,0
    printTrig(sin(ii))             ;print value of the sine
    wait 500 mS                   ;pause to view

    cls                           ;do likewise for cosine
    print "cos("
    print ii
    print ")="
    locate 1,0
    printTrig(cos(ii))
    wait 500 mS                   ;pause to view
    cls                           ;do likewise for tangent
    print "tan("
    print ii
    print ")="
    locate 1,0
    printTrig(tan(ii))
    wait 500 mS                   ;pause to view
    next i

    sub printTrig(in value as integer)
        ;print decently formatted trig results

        outStr = ""                   ;assume positive (no sign)

        if value < 0 then             ;handle negatives
            outStr = "-"                ;prefix a minus sign
            value = -1 * value          ;but work with positives
        end if

        valStr = str(value)
        length = len(valStr)
        select case length
            case 1:
            outStr = outStr + "0.00" + valStr
            case 2:
            outStr = outStr + "0.0" + valStr
            case 3:
            outStr = outStr + "0." + valStr
            case 4:
            outStr = outStr + left(valStr,1) + "." + right(valStr,3)
            case 5:
            outStr = outStr + left(valStr,2) + "." + right(valStr,3)
        end select
        print outStr
    end sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Trim</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_str.html" title="Str"><link rel="next" href="_ucase.html" title="UCase"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_trim"></a>Trim</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  <span class="emphasis"><em>stringvar</em></span> = Trim(<span class="emphasis"><em>stringvar</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Trim</code> function will trim the 7-bit ASCII space character (value 32) from text.</p><p><code class="literal">Trim</code> removes all spaces from text except for single spaces between words. Use <code class="literal">Trim</code> on text that you have received from another source that may have irregular spacing at the left or right hand ends of the string.</p><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_ltrim.html" title="Ltrim">Ltrim</a>, <a class="link" href="_rtrim.html" title="Rtrim">Rtrim</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="trim"></span>Trim

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  stringvar = Trim(stringvar)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Trim` function will trim the 7-bit ASCII space character (value 32)
from text.

`Trim` removes all spaces from text except for single spaces between
words. Use `Trim` on text that you have received from another source
that may have irregular spacing at the left or right hand ends of the
string.

<span class="strong">**See Also**</span>
<a href="ltrim" class="link" title="Ltrim">Ltrim</a>,
<a href="rtrim" class="link" title="Rtrim">Rtrim</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Troubleshooting</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_frequently_asked_questions.html" title="Frequently Asked Questions"><link rel="next" href="_compiler_insights.html" title="Compiler Insights"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_troubleshooting"></a>Troubleshooting</h2></div></div></div><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Problem</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Common Causes</strong></span></th><th align="left" valign="top"><span class="strong"><strong>More Assistance</strong></span></th></tr></thead><tbody><tr><td rowspan="3" align="left" valign="middle"><p>Cannot compile a program</p></td><td align="left" valign="top"><p>There is an error in the program. Is GCBASIC complaining about a
particular line of code?</p></td><td align="left" valign="top"><p>GCBASIC Forums</p></td></tr><tr><td align="left" valign="top"><p>GCBASIC has not been installed correctly - reinstall it.</p></td><td align="left" valign="top"><p>GCBASIC Forums</p></td></tr><tr><td align="left" valign="top"><p>There is a bug in GCBASIC</p></td><td align="left" valign="top"><p>Post on the GCBASIC Forums. Ensure you state the version of your compiler and attach your code as a ZIP.</p></td></tr><tr><td align="left" valign="top"><p>A program compiles and downloads fine, but will not run</p></td><td align="left" valign="top"><p>Oscillator not selected.</p></td><td align="left" valign="top"><p><a class="link" href="_configuration.html" title="Configuration">Configuration</a></p></td></tr></tbody></table></div></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="troubleshooting"></span>Troubleshooting
--------------------------------------------------

</div>

</div>

</div>

<div class="informaltable">

<span class="strong">**Problem**</span>

</div>

</div>

<span class="strong">**Common Causes**</span>

<span class="strong">**More Assistance**</span>

Cannot compile a program

There is an error in the program. Is GCBASIC complaining about a
particular line of code?

GCBASIC Forums

GCBASIC has not been installed correctly - reinstall it.

GCBASIC Forums

There is a bug in GCBASIC

Post on the GCBASIC Forums. Ensure you state the version of your
compiler and attach your code as a ZIP.

A program compiles and downloads fine, but will not run

Oscillator not selected.

<a href="configuration" class="link" title="Configuration">Configuration</a>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>UC1601 Controllers</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_glcd_overview.html" title="GLCD Overview"><link rel="prev" href="_t6963_controllers.html" title="T6963 Controllers"><link rel="next" href="_box.html" title="Box"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_uc1601_controllers"></a>UC1601 Controllers</h5></div></div></div><p>This section covers GLCD devices that use the UC1601 graphics controller.</p><p>The UC1601 is an advanced high-voltage mixed signal CMOS IC, especially designed for the display needs of ultra-low power hand-held devices.</p><p>The UC1601 embeds with contrast control, display RAM and oscillator, which reduces the number of external components and power consumption.&nbsp;&nbsp; It has 256-step brightness control. Data/Commands are sent from general MCU through the hardware selectable 6800/8000 series compatible Parallel Interface, I2C interface or Serial Peripheral Interface. It is suitable for many compact portable applications, such as mobile phone sub-display, MP3 player and calculator, etc.</p><p>The UC1601 library supports 132 * 22 pixels.&nbsp;&nbsp;  The UC1601 library  supports monochrome devices.</p><p><span class="inlinemediaobject"><img src="./images/UC1601.gif" width="396" height="66" alt="graphic"></span></p><p>The UC1601 can operate in three modes.&nbsp;&nbsp; Full GLCD mode, Low Memory GLCD mode or Text/JPG mode the full GLCD mode requires a minimum of 396 bytes or 128 bytes for the respective modes.&nbsp;&nbsp;For microcontrollers with limited memory the third mode of operation - Text mode.  These can be selected by setting the correct constant.</p><p>To use the UC1601 driver simply include the following in your user code.  This will initialise the driver.</p><p>The GCBASIC constants shown below control the configuration of the UC1601 controller. &nbsp;&nbsp;&nbsp;GCBASIC supports hardware I2C &amp; software I2C connectivity  - this is shown in the tables below.</p><p>To use the UC1601 drivers simply include one of the following configuration.</p><pre class="screen">    'An I2C configuration
    #include &lt;glcd.h&gt;

    #define GLCD_TYPE GLCD_TYPE_UC1601
    #define GLCD_I2C_Address      0x70                   'I2C address
    #define GLCD_RESET            portc.0                'Hard Reset pin connection
    #define GLCD_PROTECTOVERRUN
    #define GLCD_OLED_FONT

    ; ----- Define Hardware settings for I2C
    ' Define I2C settings - CHANGE PORTS
    #define I2C_MODE Master
    #define I2C_DATA PORTb.5
    #define I2C_CLOCK PORTb.7
    #define I2C_DISABLE_INTERRUPTS ON</pre><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Options</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE</code></p></td><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_UC1601</code></p></td><td align="left" valign="top"><p>Required</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_I2C_Address</code></p></td><td align="left" valign="top"><p>I2C address of the GLCD.</p></td><td align="left" valign="top"><p>Fixed at 0x70.</p></td></tr></tbody></table></div><p>The GCBASIC constants for control display characteristics are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constants</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCD_WIDTH</code></p></td><td align="left" valign="top"><p>The width parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">132</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_HEIGHT</code></p></td><td align="left" valign="top"><p>The height parameter of the GLCD</p></td><td align="left" valign="top"><p><code class="literal">22</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_PROTECTOVERRUN</code></p></td><td align="left" valign="top"><p>Define this constant to restrict pixel operations with the pixel limits</p></td><td align="left" valign="top"><p>Recommended</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_UC1601_CHARACTER_MODE_ONLY</code></p></td><td align="left" valign="top"><p>Specifies that the display controller will operate in text mode and BMP
draw mode only.<br>
For microcontrollers with low RAM this will be set be
default.<br>
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <code class="literal">GLCD_TYPE_UC1601_LOWMEMORY_GLCD_MODE</code></p></td><td align="left" valign="top"><p>Optional</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_TYPE_UC1601_LOWMEMORY_GLCD_MODE</code></p></td><td align="left" valign="top"><p>Specifies that the display controller will operate in Low Memory mode.</p></td><td align="left" valign="top"><p>Optional</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_OLED_FONT</code></p></td><td align="left" valign="top"><p>Specifies the use of the optional OLED font set.
</p><p>The GLCDfntDefaultsize can be set to 1 or 2 only.
</p><p><code class="literal">GLCDfntDefaultsize=  1</code>.   A small 8 height pixel font with variable width.
<code class="literal">GLCDfntDefaultsize=  2</code>.   A larger 10 width * 16 height pixel font.</p></td><td align="left" valign="top"><p>Optional</p></td></tr></tbody></table></div><p>The GCBASIC variables for control display characteristics are shown in the table below.
These variables control the user definable parameters of a specific GLCD.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Variable</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Type</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDBackground</code></p></td><td align="left" valign="top"><p>GLCD background state.</p></td><td align="left" valign="top"><p>A monochrome value.<br>
For mono GLCDs the default is White or 0x0001.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDForeground</code></p></td><td align="left" valign="top"><p>Color of GLCD foreground.</p></td><td align="left" valign="top"><p>A monochrome value.<br>
For mono GLCDs the default is non-white or 0x0000.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDFontWidth</code></p></td><td align="left" valign="top"><p>Width of the current GLCD font.</p></td><td align="left" valign="top"><p>Default is 6 pixels.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDfntDefault</code></p></td><td align="left" valign="top"><p>Size of the current GLCD font.</p></td><td align="left" valign="top"><p>Default is 0.
</p><p></p><p>This equates to the standard GCB font set.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDfntDefaultsize</code></p></td><td align="left" valign="top"><p>Size of the current GLCD font.</p></td><td align="left" valign="top"><p>Default is 1.
</p><p></p><p>This equates to the 8 pixel high.</p></td></tr></tbody></table></div><p>The GCBASIC commands supported for this GLCD are shown in the
table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Command</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Purpose</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td><td align="left" valign="top"><p>Clear screen of GLCD</p></td><td align="left" valign="top"><p><code class="literal">GLCDCLS</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDPrint</code></p></td><td align="left" valign="top"><p>Print string of characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDPrint( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawChar</code></p></td><td align="left" valign="top"><p>Print character on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawChar( Xposition, Yposition, CharCode )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDDrawString</code></p></td><td align="left" valign="top"><p>Print characters on GLCD using GCB font set</p></td><td align="left" valign="top"><p><code class="literal">GLCDDrawString( Xposition, Yposition, Stringvariable )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Box</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size</p></td><td align="left" valign="top"><p><code class="literal">Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">FilledBox</code></p></td><td align="left" valign="top"><p>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</p></td><td align="left" valign="top"><p><code class="literal">FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Line</code></p></td><td align="left" valign="top"><p>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">PSet</code></p></td><td align="left" valign="top"><p>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</p></td><td align="left" valign="top"><p><code class="literal">PSet(Xposition, Yposition, Pixel Colour 0 or 1)</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Open_PageTransaction</code></p></td><td align="left" valign="top"><p>Commence a series of GLCD commands when in low memory mode.  Must be followed a  <code class="literal">GLCD_Close_PageTransaction</code> command.</p></td><td align="left" valign="top"><p><code class="literal">GLCD_Close_PageTransaction 0, 3</code> where 0 and 3 are the range of pages to be updated</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCD_Close_PageTransaction</code></p></td><td align="left" valign="top"><p>Commence a series of GLCD commands when in low memory mode.  Must follow a <code class="literal">GLCD_Open_PageTransaction</code> command.</p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p><code class="literal">Open_Transaction_UC1601</code></p></td><td align="left" valign="top"><p>Send command instruction to GLCD.  Handles I2C and SPI protocols.</p></td><td align="left" valign="top"><p>Transaction must be closed by using <code class="literal">Close_Transaction_UC1601</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Open_Transaction_Data_UC1601</code></p></td><td align="left" valign="top"><p>Send data instruction to GLCD.  Handles I2C and SPI protocols.</p></td><td align="left" valign="top"><p>Transaction must be closed by using <code class="literal">Close_Transaction_UC1601</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Write_Transaction_Data_UC1601</code></p></td><td align="left" valign="top"><p>Send transactional, a stream of, data to GLCD.</p></td><td align="left" valign="top"><p>Transaction must be opened and closed by using transaction commands.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Close_Transaction_UC1601</code></p></td><td align="left" valign="top"><p>Close the communications to the GLCD.</p></td><td align="left" valign="top"><p>Transaction must be opened by using <code class="literal">Open_Transaction_UC1601</code> or <code class="literal">Open_Transaction_Data_UC1601</code></p></td></tr></tbody></table></div><p>The GCBASIC specific commands for this GLCD are shown in the table below.</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Command</th><th align="left" valign="top">Purpose</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">Stopscroll_UC1601</code></p></td><td align="left" valign="top"><p>Stops all scrolling</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Startscroll_UC1601 ( start  )</code></p></td><td align="left" valign="top"><p>Activates a vertical scroll for rows start.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">GLCDSetContrast ( contrast_state )</code></p></td><td align="left" valign="top"><p>Sets the constrast between 0 and 255. The contrast increases as the value increases.<br>
Parameter is contrast value</p></td></tr></tbody></table></div><p>For a UC1601 datasheet, please refer <a class="link" href="http://gcbasic.sourceforge.net/library/DISPLAY/UC1601.pdf" target="_top">here</a>.</p><p>This example shows how to drive a UC1601 based Graphic I2C LCD module with the built in commands of GCBASIC using Full Mode GLCD</p><pre class="screen">        ; ----- Configuration
        #chip 16f18446, 32
        #option explicit


    ; ----- Define GLCD Hardware settings
        #include &lt;glcd.h&gt;

        #define GLCD_TYPE GLCD_TYPE_UC1601
        #define GLCD_I2C_Address      0x70                   'I2C address
        #define GLCD_RESET            portc.0                'Hard Reset pin connection
        #define GLCD_PROTECTOVERRUN
        #define GLCD_OLED_FONT

    ; ----- Define Hardware settings

        ' Define I2C settings - CHANGE PORTS
        #define I2C_MODE Master
        #define I2C_DATA PORTb.5
        #define I2C_CLOCK PORTb.7
        #define I2C_DISABLE_INTERRUPTS ON

    ; ----- Define variables

    ; ----- Main program

        'You can treat the GLCD like an LCD....
        GLCDPrintStringLN "User the GLCD like an LCD...."
        GLCDPrintStringLN "The GLCDPrintString commands...."
        GLCDPrintString "Enjoy....."
        wait 4 s

    end</pre><p><br>
<br>
This example shows how to drive a UC1601 based Graphic I2C LCD module with the built in commands of GCBASIC using Low Memory Mode GLCD.
<br>
Note the use of <code class="literal">GLCD_Open_PageTransaction</code> and <code class="literal">GLCD_Close_PageTransaction</code> to support the Low Memory Mode of operation and the contraining of all GLCD commands with the transaction commands.  The use Low Memory Mode GLCD the two defines <code class="literal">GLCD_TYPE_UC1601_LOWMEMORY_GLCD_MODE</code> and <code class="literal">GLCD_TYPE_UC1601_CHARACTER_MODE_ONLY</code> are included in the user program.
<br></p><pre class="screen">    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_UC1601
    #define GLCD_TYPE_UC1601_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_UC1601_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS

    'To clarify - page udpates
    '0,7 correspond with the Text Lines from 0 to 3 on a 22 Pixel Display
    'In this example Code would be GLCD_Open_PageTransaction 0,1 been enough
    'But it is allowed to use GLCD_Open_PageTransaction 0,3 to show the full screen update
    GLCD_Open_PageTransaction 0,3
       GLCDPrint 0, 0, "GCBASIC"
       GLCDPrint (0, 16, "Anobium 2021")
    GLCD_Close_PageTransaction

    end</pre><p><br></p><p><span class="strong"><strong>For more help, see</strong></span>
<a class="link" href="_glcdcls.html" title="GLCDCLS">GLCDCLS</a>, <a class="link" href="_glcddrawchar.html" title="GLCDDrawChar">GLCDDrawChar</a>, <a class="link" href="_glcdprint.html" title="GLCDPrint">GLCDPrint</a>, <a class="link" href="_glcdreadbyte.html" title="GLCDReadByte">GLCDReadByte</a>, <a class="link" href="_glcdwritebyte.html" title="GLCDWriteByte">GLCDWriteByte</a> or <a class="link" href="_pset.html" title="Pset">Pset</a></p><p>Supported in &lt;GLCD.H&gt;</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

##### <span id="uc1601_controllers"></span>UC1601 Controllers

</div>

</div>

</div>

This section covers GLCD devices that use the UC1601 graphics
controller.

The UC1601 is an advanced high-voltage mixed signal CMOS IC, especially
designed for the display needs of ultra-low power hand-held devices.

The UC1601 embeds with contrast control, display RAM and oscillator,
which reduces the number of external components and power consumption.  
It has 256-step brightness control. Data/Commands are sent from general
MCU through the hardware selectable 6800/8000 series compatible Parallel
Interface, I2C interface or Serial Peripheral Interface. It is suitable
for many compact portable applications, such as mobile phone
sub-display, MP3 player and calculator, etc.

The UC1601 library supports 132 \* 22 pixels.   The UC1601 library
supports monochrome devices.

<span
class="inlinemediaobject"><img src="./images/UC1601.gif" width="396" height="66" alt="graphic" /></span>

The UC1601 can operate in three modes.   Full GLCD mode, Low Memory GLCD
mode or Text/JPG mode the full GLCD mode requires a minimum of 396 bytes
or 128 bytes for the respective modes.  For microcontrollers with
limited memory the third mode of operation - Text mode. These can be
selected by setting the correct constant.

To use the UC1601 driver simply include the following in your user code.
This will initialise the driver.

The GCBASIC constants shown below control the configuration of the
UC1601 controller.    GCBASIC supports hardware I2C & software I2C
connectivity - this is shown in the tables below.

To use the UC1601 drivers simply include one of the following
configuration.

``` screen
    'An I2C configuration
    #include <glcd.h>

    #define GLCD_TYPE GLCD_TYPE_UC1601
    #define GLCD_I2C_Address      0x70                   'I2C address
    #define GLCD_RESET            portc.0                'Hard Reset pin connection
    #define GLCD_PROTECTOVERRUN
    #define GLCD_OLED_FONT

    ; ----- Define Hardware settings for I2C
    ' Define I2C settings - CHANGE PORTS
    #define I2C_MODE Master
    #define I2C_DATA PORTb.5
    #define I2C_CLOCK PORTb.7
    #define I2C_DISABLE_INTERRUPTS ON
```

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

| <span class="strong">**Constants**</span> | <span class="strong">**Controls**</span> | <span class="strong">**Options**</span> |
|:------------------------------------------|:-----------------------------------------|:----------------------------------------|
| `GLCD_TYPE`                               | `GLCD_TYPE_UC1601`                       | Required                                |
| `GLCD_I2C_Address`                        | I2C address of the GLCD.                 | Fixed at 0x70.                          |

</div>

The GCBASIC constants for control display characteristics are shown in
the table below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Constants</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Controls</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Default</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_WIDTH</code></p></td>
<td style="text-align: left;"><p>The width parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">132</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_HEIGHT</code></p></td>
<td style="text-align: left;"><p>The height parameter of the GLCD</p></td>
<td style="text-align: left;"><p><code class="literal">22</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_PROTECTOVERRUN</code></p></td>
<td style="text-align: left;"><p>Define this constant to restrict pixel operations with the pixel limits</p></td>
<td style="text-align: left;"><p>Recommended</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_UC1601_CHARACTER_MODE_ONLY</code></p></td>
<td style="text-align: left;"><p>Specifies that the display controller will operate in text mode and BMP draw mode only.<br />
For microcontrollers with low RAM this will be set be default.<br />
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <code class="literal">GLCD_TYPE_UC1601_LOWMEMORY_GLCD_MODE</code></p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCD_TYPE_UC1601_LOWMEMORY_GLCD_MODE</code></p></td>
<td style="text-align: left;"><p>Specifies that the display controller will operate in Low Memory mode.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCD_OLED_FONT</code></p></td>
<td style="text-align: left;"><p>Specifies the use of the optional OLED font set.</p>
<p>The GLCDfntDefaultsize can be set to 1 or 2 only.</p>
<p><code class="literal">GLCDfntDefaultsize=  1</code>. A small 8 height pixel font with variable width. <code class="literal">GLCDfntDefaultsize=  2</code>. A larger 10 width * 16 height pixel font.</p></td>
<td style="text-align: left;"><p>Optional</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC variables for control display characteristics are shown in
the table below. These variables control the user definable parameters
of a specific GLCD.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Variable</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Purpose</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Type</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDBackground</code></p></td>
<td style="text-align: left;"><p>GLCD background state.</p></td>
<td style="text-align: left;"><p>A monochrome value.<br />
For mono GLCDs the default is White or 0x0001.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDForeground</code></p></td>
<td style="text-align: left;"><p>Color of GLCD foreground.</p></td>
<td style="text-align: left;"><p>A monochrome value.<br />
For mono GLCDs the default is non-white or 0x0000.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDFontWidth</code></p></td>
<td style="text-align: left;"><p>Width of the current GLCD font.</p></td>
<td style="text-align: left;"><p>Default is 6 pixels.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">GLCDfntDefault</code></p></td>
<td style="text-align: left;"><p>Size of the current GLCD font.</p></td>
<td style="text-align: left;"><p>Default is 0.</p>
<p>This equates to the standard GCB font set.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDfntDefaultsize</code></p></td>
<td style="text-align: left;"><p>Size of the current GLCD font.</p></td>
<td style="text-align: left;"><p>Default is 1.</p>
<p>This equates to the 8 pixel high.</p></td>
</tr>
</tbody>
</table>

</div>

The GCBASIC commands supported for this GLCD are shown in the table
below.

<div class="informaltable">

| <span class="strong">**Command**</span> | <span class="strong">**Purpose**</span>                                                                              | <span class="strong">**Example**</span>                                                         |
|:----------------------------------------|:---------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------|
| `GLCDCLS`                               | Clear screen of GLCD                                                                                                 | `GLCDCLS`                                                                                       |
| `GLCDPrint`                             | Print string of characters on GLCD using GCB font set                                                                | `GLCDPrint( Xposition, Yposition, Stringvariable )`                                             |
| `GLCDDrawChar`                          | Print character on GLCD using GCB font set                                                                           | `GLCDDrawChar( Xposition, Yposition, CharCode )`                                                |
| `GLCDDrawString`                        | Print characters on GLCD using GCB font set                                                                          | `GLCDDrawString( Xposition, Yposition, Stringvariable )`                                        |
| `Box`                                   | Draw a box on the GLCD to a specific size                                                                            | `Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour as 0 or 1] )`    |
| `FilledBox`                             | Draw a box on the GLCD to a specific size that is filled with the foreground colour.                                 | `FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`  |
| `Line`                                  | Draw a line on the GLCD to a specific length that is filled with the specific attribute.                             | `Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In LineColour 0 or 1] )`      |
| `PSet`                                  | Set a pixel on the GLCD at a specific position that is set with the specific attribute.                              | `PSet(Xposition, Yposition, Pixel Colour 0 or 1)`                                               |
| `GLCD_Open_PageTransaction`             | Commence a series of GLCD commands when in low memory mode. Must be followed a `GLCD_Close_PageTransaction` command. | `GLCD_Close_PageTransaction 0, 3` where 0 and 3 are the range of pages to be updated            |
| `GLCD_Close_PageTransaction`            | Commence a series of GLCD commands when in low memory mode. Must follow a `GLCD_Open_PageTransaction` command.       |                                                                                                 |
| `Open_Transaction_UC1601`               | Send command instruction to GLCD. Handles I2C and SPI protocols.                                                     | Transaction must be closed by using `Close_Transaction_UC1601`                                  |
| `Open_Transaction_Data_UC1601`          | Send data instruction to GLCD. Handles I2C and SPI protocols.                                                        | Transaction must be closed by using `Close_Transaction_UC1601`                                  |
| `Write_Transaction_Data_UC1601`         | Send transactional, a stream of, data to GLCD.                                                                       | Transaction must be opened and closed by using transaction commands.                            |
| `Close_Transaction_UC1601`              | Close the communications to the GLCD.                                                                                | Transaction must be opened by using `Open_Transaction_UC1601` or `Open_Transaction_Data_UC1601` |

</div>

The GCBASIC specific commands for this GLCD are shown in the table
below.

<div class="informaltable">

<table data-border="1">
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">Stopscroll_UC1601</code></p></td>
<td style="text-align: left;"><p>Stops all scrolling</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><code class="literal">Startscroll_UC1601 ( start  )</code></p></td>
<td style="text-align: left;"><p>Activates a vertical scroll for rows start.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><code class="literal">GLCDSetContrast ( contrast_state )</code></p></td>
<td style="text-align: left;"><p>Sets the constrast between 0 and 255. The contrast increases as the value increases.<br />
Parameter is contrast value</p></td>
</tr>
</tbody>
</table>

</div>

For a UC1601 datasheet, please refer
<a href="http://gcbasic.sourceforge.net/library/DISPLAY/UC1601.pdf" class="link">here</a>.

This example shows how to drive a UC1601 based Graphic I2C LCD module
with the built in commands of GCBASIC using Full Mode GLCD

``` screen
        ; ----- Configuration
        #chip 16f18446, 32
        #option explicit


    ; ----- Define GLCD Hardware settings
        #include <glcd.h>

        #define GLCD_TYPE GLCD_TYPE_UC1601
        #define GLCD_I2C_Address      0x70                   'I2C address
        #define GLCD_RESET            portc.0                'Hard Reset pin connection
        #define GLCD_PROTECTOVERRUN
        #define GLCD_OLED_FONT

    ; ----- Define Hardware settings

        ' Define I2C settings - CHANGE PORTS
        #define I2C_MODE Master
        #define I2C_DATA PORTb.5
        #define I2C_CLOCK PORTb.7
        #define I2C_DISABLE_INTERRUPTS ON

    ; ----- Define variables

    ; ----- Main program

        'You can treat the GLCD like an LCD....
        GLCDPrintStringLN "User the GLCD like an LCD...."
        GLCDPrintStringLN "The GLCDPrintString commands...."
        GLCDPrintString "Enjoy....."
        wait 4 s

    end
```

  
  
This example shows how to drive a UC1601 based Graphic I2C LCD module
with the built in commands of GCBASIC using Low Memory Mode GLCD.  
Note the use of `GLCD_Open_PageTransaction` and
`GLCD_Close_PageTransaction` to support the Low Memory Mode of operation
and the contraining of all GLCD commands with the transaction commands.
The use Low Memory Mode GLCD the two defines
`GLCD_TYPE_UC1601_LOWMEMORY_GLCD_MODE` and
`GLCD_TYPE_UC1601_CHARACTER_MODE_ONLY` are included in the user
program.  

``` screen
    #chip mega328p,16
    #include <glcd.h>

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_UC1601
    #define GLCD_TYPE_UC1601_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_UC1601_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS

    'To clarify - page udpates
    '0,7 correspond with the Text Lines from 0 to 3 on a 22 Pixel Display
    'In this example Code would be GLCD_Open_PageTransaction 0,1 been enough
    'But it is allowed to use GLCD_Open_PageTransaction 0,3 to show the full screen update
    GLCD_Open_PageTransaction 0,3
       GLCDPrint 0, 0, "GCBASIC"
       GLCDPrint (0, 16, "Anobium 2021")
    GLCD_Close_PageTransaction

    end
```

  

<span class="strong">**For more help, see**</span>
<a href="glcdcls" class="link" title="GLCDCLS">GLCDCLS</a>,
<a href="glcddrawchar" class="link" title="GLCDDrawChar">GLCDDrawChar</a>,
<a href="glcdprint" class="link" title="GLCDPrint">GLCDPrint</a>,
<a href="glcdreadbyte" class="link" title="GLCDReadByte">GLCDReadByte</a>,
<a href="glcdwritebyte" class="link" title="GLCDWriteByte">GLCDWriteByte</a>
or <a href="pset" class="link" title="Pset">Pset</a>

Supported in &lt;GLCD.H&gt;

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>UCase</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_trim.html" title="Trim"><link rel="next" href="_val.html" title="Val"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_ucase"></a>UCase</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  <span class="emphasis"><em>output</em></span> = UCase(<span class="emphasis"><em>source</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">UCase</code> function will convert all of the letters in the string <code class="literal"><span class="emphasis"><em>source</em></span></code> to upper case, and return the result.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the string in upper case
    'Will display "HELLO, WORLD!"
    HSerPrint UCase(TestData)
    HSerPrintCRLF</pre><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_lcase.html" title="LCase">LCase</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="ucase"></span>UCase

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  output = UCase(source)
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `UCase` function will convert all of the letters in the string
`source` to upper case, and return the result.

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the string in upper case
    'Will display "HELLO, WORLD!"
    HSerPrint UCase(TestData)
    HSerPrintCRLF
```

<span class="strong">**See Also**</span>
<a href="lcase" class="link" title="LCase">LCase</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>UnLockPPS</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_peripheral_pin_select.html" title="Peripheral Pin Select"><link rel="prev" href="_peripheral_pin_select_for_microchip_microcontrollers.html" title="Peripheral Pin Select for Microchip microcontrollers."><link rel="next" href="_lockpps.html" title="LockPPS"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_unlockpps"></a>UnLockPPS</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    UNLOCKPPS</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Peripheral Pin Select (PPS) has an operation mode in which all input and output selections can be prevented to stop  inadvertent changes.</p><p>PPS selections are unlocked by setting by the use of the <code class="literal">UnLockPPS</code> command.</p><p>Using this command will ensure the special sequence of Microchip assembler is handled correctly.</p><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all Microchip microcontrollers only.</p><pre class="screen">    #chip 16f18855,32
    #option explicit

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      UNLOCKPPS
        RC0PPS = 0x0010       'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011       'RC1-&gt;EUSART:RX;

        SSP1CLKPPS = 0x14     'RC3-&gt;MSSP1:SCL1;
        SSP1DATPPS = 0x13     'RC4-&gt;MSSP1:SDA1;
        RC3PPS = 0x15         'RC3-&gt;MSSP1:SCL1;
        RC4PPS = 0x14         'RC4-&gt;MSSP1:SDA1;
      LockPPS
    End Sub</pre><p><span class="strong"><strong>For more help, see: <a class="link" href="_lockpps.html" title="LockPPS">LockPPS</a></strong></span>.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="unlockpps"></span>UnLockPPS

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    UNLOCKPPS
```

<span class="strong">**Explanation:**</span>

Peripheral Pin Select (PPS) has an operation mode in which all input and
output selections can be prevented to stop inadvertent changes.

PPS selections are unlocked by setting by the use of the `UnLockPPS`
command.

Using this command will ensure the special sequence of Microchip
assembler is handled correctly.

<span class="strong">**Command Availability:**</span>

Available on all Microchip microcontrollers only.

``` screen
    #chip 16f18855,32
    #option explicit

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      UNLOCKPPS
        RC0PPS = 0x0010       'RC0->EUSART:TX;
        RXPPS  = 0x0011       'RC1->EUSART:RX;

        SSP1CLKPPS = 0x14     'RC3->MSSP1:SCL1;
        SSP1DATPPS = 0x13     'RC4->MSSP1:SDA1;
        RC3PPS = 0x15         'RC3->MSSP1:SCL1;
        RC4PPS = 0x14         'RC4->MSSP1:SDA1;
      LockPPS
    End Sub
```

<span class="strong">**For more help, see:
<a href="lockpps" class="link" title="LockPPS">LockPPS</a>**</span>.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>UNO as ISP programmer</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_tricks_and_tips.html" title="Tricks and Tips"><link rel="prev" href="_tricks_and_tips.html" title="Tricks and Tips"><link rel="next" href="_microcontroller_fundamentals.html" title="Microcontroller Fundamentals"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_uno_as_isp_programmer"></a>UNO as ISP programmer</h3></div></div></div><p>So, you have brought some ATtiny88 breakout boards online.&nbsp;&nbsp;
They are advertised as Nano equivalents but are inferior to the Nano in having low RAM (512 bytes vs 2048) and missing some other features.&nbsp;&nbsp;
Specifically the lack of a USB comport for programming.&nbsp;&nbsp;</p><p>The ATtiny88 USB interface only works in Arduino IDE with some tweaking, and, you are not in the mood for learning how to write sketches after being in the GCB environment for years.&nbsp;&nbsp;</p><p>This is an all-in-one tutorial for programming the ATtiny88 via AVRdude using GCB.&nbsp;&nbsp;</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The only baud rate that works is 19200. Every other baud rate failed in testing</p></div><p>The process described will create a new programmer entry in the GCB Programmer Options to fully automate the compile &amp; program progress.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This refers to an ATtiny88 but you can use this method for many AVRs which used in conjunction with AvrDude.</p></div><p><span class="strong"><strong>The Process</strong></span></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Obtain an Arduino UNO or mega.&nbsp;&nbsp;
Upload this <a class="link" href="https://sourceforge.net/p/gcbasic/discussion/chipfileforum/thread/088449090a/ed10/attachment/arduino_As_ISP_adafruit.hex" target="_top">hex file</a> to convert the UNO into an ISP programmer or follow steps 2 -5 below.</li><li class="listitem">Download the Arduino IDE software.&nbsp;&nbsp;
This is used to upload a sketch to the UNO that converts it into an ISP programmer.</li><li class="listitem">Connect the UNO to your PC via USB.&nbsp;&nbsp;
In Arduino IDE goto Tools &#8594; Set board and select "Arduino UNO".&nbsp;&nbsp;
Select the correct com port for the Arduino Uno as show in device manager.</li><li class="listitem">Goto file &#8594; examples &#8594; ArduinoISP to select the sketch that will convert the UNO to an ISP programmer. I found a better(?) working version at adafruit. Simply copy all the text from this link into a new sketch <a class="link" href="https://raw.githubusercontent.com/adafruit/ArduinoISP/master/ArduinoISP.ino" target="_top">https://raw.githubusercontent.com/adafruit/ArduinoISP/master/ArduinoISP.ino</a> (or download the ino file attached and open it in Arduino IDE) and goto step 5</li><li class="listitem">Click upload and confirm the sketch uploaded correctly by checking the status window at the bottom of the Arduino IDE</li><li class="listitem">Build a cable to connect the ISP headers on the UNO and target (ATtiny88) board as described below. Search online for the UNO ISP header pinout, the ISP header happens to be labelled underneath the ATtiny88 breakout board.</li><li class="listitem">Connect pin 10 of the UNO to the reset pin on target ISP header</li><li class="listitem">Connect VCC to VCC, MOSI to MOSI, MISO to MISO, GND to GND, SCK to SCK.</li><li class="listitem">Open Synwrite &#8594; "IDE tools" &#8594; "GCB tools" &#8594; "Edit Programmer preferences", or, in GCStudio "Edit Programmer preferences"</li><li class="listitem">Click "add" and a program editor window opens</li><li class="listitem">Enter name Arduino as ISP or similar</li><li class="listitem">In the "Use if" box paste DEF(AVR)</li><li class="listitem">In the "File" box paste %instdir%..\avrdude\avrdude.exe</li><li class="listitem">In the "command line parameters" paste -c avrisp -p t88 -P %Port% -b 19200 -U flash:w:"%FileName%":a</li><li class="listitem">Select the com port that corresponds to the connected UNO port</li><li class="listitem">Click ok</li></ol></div><p><span class="emphasis"><em>Enter the sample code here into GCB IDE</em></span></p><pre class="screen">    #chip tiny88, 12

    dir portd.0 out

    Do
      set portd.0 on
      wait 500 ms
      set portd.0 off
      wait 500 ms
    Loop</pre><p>Now you can select "Hex/Flash" to upload the code to the Attiny88.&nbsp;&nbsp;
If all goes well the LED should blink on and off every second</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="uno_as_isp_programmer"></span>UNO as ISP programmer

</div>

</div>

</div>

So, you have brought some ATtiny88 breakout boards online.   They are
advertised as Nano equivalents but are inferior to the Nano in having
low RAM (512 bytes vs 2048) and missing some other features.  
Specifically the lack of a USB comport for programming.  

The ATtiny88 USB interface only works in Arduino IDE with some tweaking,
and, you are not in the mood for learning how to write sketches after
being in the GCB environment for years.  

This is an all-in-one tutorial for programming the ATtiny88 via AVRdude
using GCB.  

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

### Note

The only baud rate that works is 19200. Every other baud rate failed in
testing

</div>

The process described will create a new programmer entry in the GCB
Programmer Options to fully automate the compile & program progress.

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

### Note

This refers to an ATtiny88 but you can use this method for many AVRs
which used in conjunction with AvrDude.

</div>

<span class="strong">**The Process**</span>

<div class="orderedlist">

1.  Obtain an Arduino UNO or mega.   Upload this
    <a href="https://sourceforge.net/p/gcbasic/discussion/chipfileforum/thread/088449090a/ed10/attachment/arduino_As_ISP_adafruit.hex" class="link">hex file</a>
    to convert the UNO into an ISP programmer or follow steps 2 -5
    below.
2.  Download the Arduino IDE software.   This is used to upload a sketch
    to the UNO that converts it into an ISP programmer.
3.  Connect the UNO to your PC via USB.   In Arduino IDE goto Tools →
    Set board and select "Arduino UNO".   Select the correct com port
    for the Arduino Uno as show in device manager.
4.  Goto file → examples → ArduinoISP to select the sketch that will
    convert the UNO to an ISP programmer. I found a better(?) working
    version at adafruit. Simply copy all the text from this link into a
    new sketch
    <https://raw.githubusercontent.com/adafruit/ArduinoISP/master/ArduinoISP.ino>
    (or download the ino file attached and open it in Arduino IDE) and
    goto step 5
5.  Click upload and confirm the sketch uploaded correctly by checking
    the status window at the bottom of the Arduino IDE
6.  Build a cable to connect the ISP headers on the UNO and target
    (ATtiny88) board as described below. Search online for the UNO ISP
    header pinout, the ISP header happens to be labelled underneath the
    ATtiny88 breakout board.
7.  Connect pin 10 of the UNO to the reset pin on target ISP header
8.  Connect VCC to VCC, MOSI to MOSI, MISO to MISO, GND to GND, SCK to
    SCK.
9.  Open Synwrite → "IDE tools" → "GCB tools" → "Edit Programmer
    preferences", or, in GCStudio "Edit Programmer preferences"
10. Click "add" and a program editor window opens
11. Enter name Arduino as ISP or similar
12. In the "Use if" box paste DEF(AVR)
13. In the "File" box paste %instdir%..\\avrdude\\avrdude.exe
14. In the "command line parameters" paste -c avrisp -p t88 -P %Port% -b
    19200 -U flash:w:"%FileName%":a
15. Select the com port that corresponds to the connected UNO port
16. Click ok

</div>

<span class="emphasis">*Enter the sample code here into GCB IDE*</span>

``` screen
    #chip tiny88, 12

    dir portd.0 out

    Do
      set portd.0 on
      wait 500 ms
      set portd.0 off
      wait 500 ms
    Loop
```

Now you can select "Hex/Flash" to upload the code to the Attiny88.   If
all goes well the LED should blink on and off every second

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>USB Drivers Installer</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microcontroller_fundamentals.html" title="Microcontroller Fundamentals"><link rel="prev" href="_variable_memory_allocation.html" title="Variable Memory Allocation"><link rel="next" href="_syntax.html" title="Syntax"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_usb_drivers_installer"></a>USB Drivers Installer</h3></div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Installing the USB driver is only required when using the GCBASIC USB library.</p></div><p><span class="strong"><strong>Description:</strong></span></p><p>The drivers for windows x86 and x64 correspond to the USB LIBKWIN capability of GCBasic for supported PIC microcontrollers.</p><p>For security reasons, in Microsoft windows for a driver to be installed, it is necessary that it be digitally signed by Microsoft.</p><p>Microsoft did make a special &#8220;Test&#8221; mode for developers to install MANUALLY unsigned drivers for debug and testing, being a technical advanced and not user-friendly procedure; at the same time the windows developers make efforts to disable the capability of doing this in an automated fashion by the concerns of being used as a vulnerability of the operating system.</p><p>This scenario will make installing test drivers difficult and frustrating for the uninitiated, at the same time for a useful Hobby project it will be not practical to make end users to take all this drama.</p><p>This driver installer method resolves the constraints imposed by the Windows operating system, and, therefore will allow you to install the drivers in the easiest way possible, almost like any driver of a well-known company.</p><p><span class="strong"><strong>Usage:</strong></span></p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>The installer will reboot the system without notice. Please close all programs and save any work you have open before begin whit the driver install.</p></div><p>1 - Open the installer, it will request admin rights.</p><p>2 - Navigate thru the wizard to automatically extract the driver files (there aren&#8217;t any options to select).</p><p>3 - At the end of the wizard, after you click the exit button, the system will restart automatically</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>In the case where your computer has Secure Boot enabled, the installer will advise you of extra steps needed after reboot, at the end of this page you will find a graphic reflecting those steeps and what elements you need to select.</p></div><p>4 - After restart and login in to your user account, a window will inform you that the driver is not signed and you will be asked if you want to install the driver, please allow it.</p><p>5 - when the driver has been installed, the computer will restart automatically.</p><p><br>
<br></p><p><span class="strong"><strong>Secure Boot Enabled, Boot menu steps</strong></span>
<br>
<br></p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/winresteepsm.png" align="middle" alt="graphic"></div></div><p><br>
<br></p><p><span class="strong"><strong>USB Driver details</strong></span></p><p>The driver uses the following USB flags.</p><pre class="screen">    USB_VID 0x1209
    USB_PID 0x2006
    USB_REV 0x0000</pre><p>For others, need to modify and recompile the USB library.</p><p>USB_PRODUCT_NAME and USB_VENDOR_NAME can change without problem (windows device manager will show the name reported by the hardware not the driver</p><p><span class="strong"><strong>Tested on (but not limited to)</strong></span></p><pre class="screen">    Windows 11 pro x64 secureboot disabled, os build Dev 21H2 22000.194
    Windows 11 pro x64 secureboot enabled, os build Dev rs_prerelease 22458.1000
    Windows 10 pro x64 secureboot disabled, os build stable 20H2 19042.867
    Windows 7 pro x86 secureboot disabled, os service pack 1 build 6.1.7601</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="usb_drivers_installer"></span>USB Drivers Installer

</div>

</div>

</div>

<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

### Warning

Installing the USB driver is only required when using the GCBASIC USB
library.

</div>

<span class="strong">**Description:**</span>

The drivers for windows x86 and x64 correspond to the USB LIBKWIN
capability of GCBasic for supported PIC microcontrollers.

For security reasons, in Microsoft windows for a driver to be installed,
it is necessary that it be digitally signed by Microsoft.

Microsoft did make a special “Test” mode for developers to install
MANUALLY unsigned drivers for debug and testing, being a technical
advanced and not user-friendly procedure; at the same time the windows
developers make efforts to disable the capability of doing this in an
automated fashion by the concerns of being used as a vulnerability of
the operating system.

This scenario will make installing test drivers difficult and
frustrating for the uninitiated, at the same time for a useful Hobby
project it will be not practical to make end users to take all this
drama.

This driver installer method resolves the constraints imposed by the
Windows operating system, and, therefore will allow you to install the
drivers in the easiest way possible, almost like any driver of a
well-known company.

<span class="strong">**Usage:**</span>

<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

### Warning

The installer will reboot the system without notice. Please close all
programs and save any work you have open before begin whit the driver
install.

</div>

1 - Open the installer, it will request admin rights.

2 - Navigate thru the wizard to automatically extract the driver files
(there aren’t any options to select).

3 - At the end of the wizard, after you click the exit button, the
system will restart automatically

<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

### Warning

In the case where your computer has Secure Boot enabled, the installer
will advise you of extra steps needed after reboot, at the end of this
page you will find a graphic reflecting those steeps and what elements
you need to select.

</div>

4 - After restart and login in to your user account, a window will
inform you that the driver is not signed and you will be asked if you
want to install the driver, please allow it.

5 - when the driver has been installed, the computer will restart
automatically.

  
  

<span class="strong">**Secure Boot Enabled, Boot menu steps**</span>  
  

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/winresteepsm.png)

</div>

</div>

  
  

<span class="strong">**USB Driver details**</span>

The driver uses the following USB flags.

``` screen
    USB_VID 0x1209
    USB_PID 0x2006
    USB_REV 0x0000
```

For others, need to modify and recompile the USB library.

USB\_PRODUCT\_NAME and USB\_VENDOR\_NAME can change without problem
(windows device manager will show the name reported by the hardware not
the driver

<span class="strong">**Tested on (but not limited to)**</span>

``` screen
    Windows 11 pro x64 secureboot disabled, os build Dev 21H2 22000.194
    Windows 11 pro x64 secureboot enabled, os build Dev rs_prerelease 22458.1000
    Windows 10 pro x64 secureboot disabled, os build stable 20H2 19042.867
    Windows 7 pro x86 secureboot disabled, os service pack 1 build 6.1.7601
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Using Assembler</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="__option_reservehighprog.html" title="#Option ReserveHighProg"><link rel="next" href="_assembler_overview.html" title="Assembler Overview"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_using_assembler"></a>Using Assembler</h2></div></div></div><p>This is the Using Assembler section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="using_assembler"></span>Using Assembler
--------------------------------------------------

</div>

</div>

</div>

This is the Using Assembler section of the Help file. Please refer the
sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Using GCBASIC</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="index.html" title="GCBASIC documentation"><link rel="prev" href="_introducing_gcbasic.html" title="Introducing GCBASIC"><link rel="next" href="_pic_users_and_beginners_start_here.html" title="PIC users and Beginners: Start Here"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_using_gcbasic"></a>Using GCBASIC</h2></div></div></div><p>Need to compile a program with GCBASIC, but don&#8217;t know where to begin? Try these simple instructions:
<br>
<br>
 - Complete the installation using the default values - select all the programmers but not the portable mode.
<br>
<br>
 - The installer will automatically start the IDE.
<br>
<br>
 - When a GCBASIC source file is opened, check out the &#8220;GCB tools&#8221; menu ( IDE Tools / GCB tools ) - through this menu you can access the oneclick commands. Or try the right mouse button - this will access the same options.
<br>
<br>
 - The IDE Tools&#8230;&#8203; commands (function keys F5 - F8) starts a GCBASIC utility which calls the batchfiles for compiling sourcecode and programming
   ("flashing")<span class="small"><sup>(1)</sup></span> the target microcontroller.   You have to select the appropriate programmer in &#8220;Edit Programmer Preferences&#8221; ( IDE Tools / GCB tools / Edit Programmer Preferences or by pressing Ctrl+Alt+E ).  Find your programmer in the list and drag it to the top beneath the heading &#8220;Programmers to use (in order)&#8221;. GCBASIC will now attempt to flash the microcontroller with that programmer first when you click on "Make HEX and FLASH" ( F5 ) or "FLASH previous made hexfile" ( F8 ).
<br>
<br>
 - In the unlikely event that your programmer is not listed you can add it by pressing &#8220;Add&#8230;&#8221; in &#8220;Edit Programmer Preferences&#8221;.  You would have to know the working directory and command line options etc. for the programmer.  See the help tips at the bottom by clicking on the fields.
<br>
<br>
 - For project-specific flashing you can edit the current programmers in &#8220;Edit Programmer Preferences&#8221; to suit your needs by clicking on &#8220;Edit&#8230;&#8221;. Use the &#8220;Use If:&#8221; parameter to choose programmer preferences. See the help tips. The chip model is autodetected by the IDE for use in &#8220;Use IF:&#8221; or in command line options etc.
<br>
<br>
 - Some programmers use a .hex file to "flash" the microcontroller.  By selecting "Make HEX" ( F5 ), GCBASIC will compile the program and make a .hex file in the same directory as the GCBASIC file.  This method can also be used to check for errors in the GCBASIC program before flashing.
<br>
<br>
   - Included programmer software is:
<br>
   &#8201;&#8212;&#8201;Avrdude for AVR,
<br>
   &#8201;&#8212;&#8201;PICPgm for PIC,
<br>
   &#8201;&#8212;&#8201;PicKit2 and PicKit3
<br>
   &#8201;&#8212;&#8201;TinyBootLoader+
<br>
   &#8201;&#8212;&#8201;Arduino
<br>
   &#8201;&#8212;&#8201;Northern Software Programmer
<br>
   &#8201;&#8212;&#8201;Microchip Xpress Board and many, many more.</p><p><span class="small"><sup>(1)</sup> You need a suitable programmer to do this, and instructions should be
included with the programmer on how to download and connect the hardware to the microcontroller.</span>
<br>
<br></p><p><span class="strong"><strong>Programmer Preferences</strong></span>
<br>
<br>
The &#8220;Programmer Preferences&#8221; is a software tool to control and set-up the different programmers.  See below:
<br>
<br>
<span class="strong"><strong>When using GC Code at the IDE</strong></span>
<br>
<br>
Select Terminal/Run Task or press function &lt;F4&gt; to see the menu
<br>
<br>
<span class="inlinemediaobject"><img src="./images/Prefs1.gif" width="640" height="480" alt="graphic"></span>
<br>
<br>
<span class="strong"><strong>Or, when using GC Code at the IDE</strong></span>
<br>
<br>
Select the drop down menu to see the menu
<br>
<br>
<span class="inlinemediaobject"><img src="./images/Prefs2.gif" width="640" height="480" alt="graphic"></span>
<br>
<br>
<span class="strong"><strong>When using SynWrite at the IDE</strong></span>
<br>
<br>
<span class="inlinemediaobject"><img src="./images/PPtool.gif" width="640" height="480" alt="graphic"></span>
<br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

<span id="using_gcbasic"></span>Using GCBASIC
----------------------------------------------

</div>

</div>

</div>

Need to compile a program with GCBASIC, but don’t know where to begin?
Try these simple instructions:  
  
- Complete the installation using the default values - select all the
programmers but not the portable mode.  
  
- The installer will automatically start the IDE.  
  
- When a GCBASIC source file is opened, check out the “GCB tools” menu (
IDE Tools / GCB tools ) - through this menu you can access the oneclick
commands. Or try the right mouse button - this will access the same
options.  
  
- The IDE Tools…​ commands (function keys F5 - F8) starts a GCBASIC
utility which calls the batchfiles for compiling sourcecode and
programming ("flashing")<span class="small"><sup>(1)</sup></span> the
target microcontroller. You have to select the appropriate programmer in
“Edit Programmer Preferences” ( IDE Tools / GCB tools / Edit Programmer
Preferences or by pressing Ctrl+Alt+E ). Find your programmer in the
list and drag it to the top beneath the heading “Programmers to use (in
order)”. GCBASIC will now attempt to flash the microcontroller with that
programmer first when you click on "Make HEX and FLASH" ( F5 ) or "FLASH
previous made hexfile" ( F8 ).  
  
- In the unlikely event that your programmer is not listed you can add
it by pressing “Add…” in “Edit Programmer Preferences”. You would have
to know the working directory and command line options etc. for the
programmer. See the help tips at the bottom by clicking on the fields.  
  
- For project-specific flashing you can edit the current programmers in
“Edit Programmer Preferences” to suit your needs by clicking on “Edit…”.
Use the “Use If:” parameter to choose programmer preferences. See the
help tips. The chip model is autodetected by the IDE for use in “Use
IF:” or in command line options etc.  
  
- Some programmers use a .hex file to "flash" the microcontroller. By
selecting "Make HEX" ( F5 ), GCBASIC will compile the program and make a
.hex file in the same directory as the GCBASIC file. This method can
also be used to check for errors in the GCBASIC program before
flashing.  
  
- Included programmer software is:  
 — Avrdude for AVR,  
 — PICPgm for PIC,  
 — PicKit2 and PicKit3  
 — TinyBootLoader+  
 — Arduino  
 — Northern Software Programmer  
 — Microchip Xpress Board and many, many more.

<span class="small"><sup>(1)</sup> You need a suitable programmer to do
this, and instructions should be included with the programmer on how to
download and connect the hardware to the microcontroller.</span>  
  

<span class="strong">**Programmer Preferences**</span>  
  
The “Programmer Preferences” is a software tool to control and set-up
the different programmers. See below:  
  
<span class="strong">**When using GC Code at the IDE**</span>  
  
Select Terminal/Run Task or press function &lt;F4&gt; to see the menu  
  
<span
class="inlinemediaobject"><img src="./images/Prefs1.gif" width="640" height="480" alt="graphic" /></span>  
  
<span class="strong">**Or, when using GC Code at the IDE**</span>  
  
Select the drop down menu to see the menu  
  
<span
class="inlinemediaobject"><img src="./images/Prefs2.gif" width="640" height="480" alt="graphic" /></span>  
  
<span class="strong">**When using SynWrite at the IDE**</span>  
  
<span
class="inlinemediaobject"><img src="./images/PPtool.gif" width="640" height="480" alt="graphic" /></span>  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Using Variables</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_variables_operations.html" title="Variables Operations"><link rel="next" href="_more_on_setting_variables_and_constants.html" title="More on setting Variables and Constants"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_using_variables"></a>Using Variables</h4></div></div></div><p><span class="strong"><strong>Explaination</strong></span></p><p>Using and accessing bytes within word and long numbers etc may be required when you are creating your solution. This can be done with some ease.</p><p><span class="strong"><strong>Example 1:</strong></span></p><p>You can access the bytes within word and longs variables using the following as a guide using the Suffixes <code class="literal">_H</code>, <code class="literal">_U</code> and <code class="literal">_E</code>
<br></p><pre class="screen">    Dim workvariable as word
    workvariable = 21845
    Dim lowb as byte
    Dim highb as byte
    Dim upperb as byte
    Dim lastb as byte

    lowb = workvariable
    highb = workvariable_H
    upperb = workvariable_U
    lastb = workvariable_E</pre><p><br>
To further explain, where
<br></p><pre class="screen">    Dim rB as Byte
    Dim sW as Word</pre><p><br>
To extract the bytes from a WORD of 16 bits use the Suffix <code class="literal">_H</code>
<br></p><pre class="screen">    'To use the bits 7-0 [lower byte] in the Word variable sW
    rB = sW

    'For bits 15-8 [upper byte] in the Word variable sW, use sw_H
    rB = sW_H</pre><p><br>
To extract the bytes from a LONG of 32 bits use the Suffixes <code class="literal">_H</code>, <code class="literal">_U</code> and
<code class="literal">_E</code>, where
<br></p><pre class="screen">    Dim rB as Byte
    Dim tL as Long

    &#8216; For bits 7-0 [lowest byte #0] in Long variable tL
    rB = tL

    &#8216; For bits 15-8 [lower middle byte #1] in Long variable tL
    rB = tL_H

    &#8216; For bits 23-16 [upper middle byte #2] in Long variable tL
    rB = tL_U

    &#8216; For bits 31-24 [highest byte #3] in Long variable tL
    rB = tL_E</pre><p><br>
To extract nibbles from the variable <code class="literal">rB</code>
<br></p><pre class="screen">    lower_nibble = rB &amp; 0x0F
    upper_nibble = (rB &amp; 0xF0) / 16</pre><p><br>
<br>
<span class="strong"><strong>Example 2:</strong></span></p><p>Assigning values to Word and Long variables via the the Byte variable (the Least Significant Byte [.lsb]) of the same Word and Long variable.</p><p>Because a Long (or Word) variable and the Least Significant Byte, of the variable, have the same variable assignments to specific byte elements (_e, _u and _h) assignment must be appropriate to the element.</p><p>The code below uses a Long variable but the same principle is used for a Word.</p><p>Assigning two values, a byte and a word constant value, to the variable tL to compare resulting impact on Long variable.</p><pre class="screen">    Dim tL as Long

    tL = 255  'All bits of the value 255 will reside in the lowest byte of the Long variable tL
    tL = 286   'This assignment will flow into tL_H where tL_H =1 and tl=30.</pre><p>Assigning values to specific elements of a Long variable.</p><pre class="screen">    'Assign value to specific elements
    tL_E = 0xF7
    tL_U = 0xC5
    tL_H = 0xE3

    'is same as the following assignment, we show the use of casting for clarification only.
    [Long] tL = 0xF7C5E300   The lower byte (tL) is empty (zero).

    'or, treat the Long as a byte and assign a byte.
    [byte]tL = [byte]0xA4</pre><p>Assigning values to the byte element of a long variable.</p><pre class="screen">    'This will assign the lowest byte with 0xA4 but this assignment will also clear the upper 3 byte elements of the long variable.
    tL = 0xA4

    'To assign the lowest byte
    tL = ( tL and 0xffffff00 ) + 0xA4  'Wwill preserve the upper bytes and ensure the lowest byte is assigned correctly.</pre><p>A method to check a variable is assigned as expected is to use HserPrint and HserPrint hex(), as follows:</p><pre class="screen">    ' HserPrint hex() only prints one byte so we need to handle the four elements
    HserPrint " Print tL _E, tL_U, tL_H &amp; tL as hex"
    HserPrint hex (tL_E)
    HserPrint hex (tL_U)
    HserPrint hex (tL_H)
    HserPrint hex (tL)
    HserPrintCRLF
    HserPrint "Variable tL = "
    HserPrint tL</pre><p>The user code above will result in an output as follows:</p><pre class="screen">    Print tL _E, tL_U, tL_H &amp; tL as hexF7C5E3A4
    Variable tL = 4156941220</pre><p><br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="using_variables"></span>Using Variables

</div>

</div>

</div>

<span class="strong">**Explaination**</span>

Using and accessing bytes within word and long numbers etc may be
required when you are creating your solution. This can be done with some
ease.

<span class="strong">**Example 1:**</span>

You can access the bytes within word and longs variables using the
following as a guide using the Suffixes `_H`, `_U` and `_E`  

``` screen
    Dim workvariable as word
    workvariable = 21845
    Dim lowb as byte
    Dim highb as byte
    Dim upperb as byte
    Dim lastb as byte

    lowb = workvariable
    highb = workvariable_H
    upperb = workvariable_U
    lastb = workvariable_E
```

  
To further explain, where  

``` screen
    Dim rB as Byte
    Dim sW as Word
```

  
To extract the bytes from a WORD of 16 bits use the Suffix `_H`  

``` screen
    'To use the bits 7-0 [lower byte] in the Word variable sW
    rB = sW

    'For bits 15-8 [upper byte] in the Word variable sW, use sw_H
    rB = sW_H
```

  
To extract the bytes from a LONG of 32 bits use the Suffixes `_H`, `_U`
and `_E`, where  

``` screen
    Dim rB as Byte
    Dim tL as Long

    ‘ For bits 7-0 [lowest byte #0] in Long variable tL
    rB = tL

    ‘ For bits 15-8 [lower middle byte #1] in Long variable tL
    rB = tL_H

    ‘ For bits 23-16 [upper middle byte #2] in Long variable tL
    rB = tL_U

    ‘ For bits 31-24 [highest byte #3] in Long variable tL
    rB = tL_E
```

  
To extract nibbles from the variable `rB`  

``` screen
    lower_nibble = rB & 0x0F
    upper_nibble = (rB & 0xF0) / 16
```

  
  
<span class="strong">**Example 2:**</span>

Assigning values to Word and Long variables via the the Byte variable
(the Least Significant Byte \[.lsb\]) of the same Word and Long
variable.

Because a Long (or Word) variable and the Least Significant Byte, of the
variable, have the same variable assignments to specific byte elements
(\_e, \_u and \_h) assignment must be appropriate to the element.

The code below uses a Long variable but the same principle is used for a
Word.

Assigning two values, a byte and a word constant value, to the variable
tL to compare resulting impact on Long variable.

``` screen
    Dim tL as Long

    tL = 255  'All bits of the value 255 will reside in the lowest byte of the Long variable tL
    tL = 286   'This assignment will flow into tL_H where tL_H =1 and tl=30.
```

Assigning values to specific elements of a Long variable.

``` screen
    'Assign value to specific elements
    tL_E = 0xF7
    tL_U = 0xC5
    tL_H = 0xE3

    'is same as the following assignment, we show the use of casting for clarification only.
    [Long] tL = 0xF7C5E300   The lower byte (tL) is empty (zero).

    'or, treat the Long as a byte and assign a byte.
    [byte]tL = [byte]0xA4
```

Assigning values to the byte element of a long variable.

``` screen
    'This will assign the lowest byte with 0xA4 but this assignment will also clear the upper 3 byte elements of the long variable.
    tL = 0xA4

    'To assign the lowest byte
    tL = ( tL and 0xffffff00 ) + 0xA4  'Wwill preserve the upper bytes and ensure the lowest byte is assigned correctly.
```

A method to check a variable is assigned as expected is to use HserPrint
and HserPrint hex(), as follows:

``` screen
    ' HserPrint hex() only prints one byte so we need to handle the four elements
    HserPrint " Print tL _E, tL_U, tL_H & tL as hex"
    HserPrint hex (tL_E)
    HserPrint hex (tL_U)
    HserPrint hex (tL_H)
    HserPrint hex (tL)
    HserPrintCRLF
    HserPrint "Variable tL = "
    HserPrint tL
```

The user code above will result in an output as follows:

``` screen
    Print tL _E, tL_U, tL_H & tL as hexF7C5E3A4
    Variable tL = 4156941220
```

  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Val</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_ucase.html" title="UCase"><link rel="next" href="_integertobin.html" title="IntegerToBin"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_val"></a>Val</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    var = Val(<span class="emphasis"><em>string</em></span>)   'Supports decimal byte and word strings only.

    'use the following for strings that represent Long numbers
    var = Val32(<span class="emphasis"><em>string</em></span>)   'Supports decimal long number strings only.</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Val</code> function will extract a number from a string variable, and store it in a word variable. One potential use is reading numbers that are sent in ASCII format over a serial connection.
<br>
<br>
The <code class="literal">Val32</code> function will extract a long number from a string variable, and store it in a long variable.</p><p><br>
<br>
The <code class="literal">Val</code> function will not extract a value from a hexadecimal string.
<br>
<br></p><p><span class="strong"><strong>Example1:</strong></span></p><pre class="screen">    'Program for an RS232 controlled dimmer
    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Set pin directions for USART and PWM

    'Variable for output level
    Dim OutputLevel As Word

    'Variables for received bytes
    Dim DataIn As String
    DataInCount = 0

    'Main Loop
    Do
        'Get serial byte
        Wait Until USARTHasData
        HSerReceive InByte

        'Process latest byte
        'Enter key?
        If InByte = 13 Then
            'Convert output level to numeric variable
            OutputLevel = Val(DataIn)

            'Output
            HPWM 1, 32, OutputLevel

            'Clear output buffer for next command
            DataIn = ""
            DataInCount = 0
        End If

        'Number?
        If InByte &gt;= 48 and InByte &lt;= 57 Then
            'Add to end of DataIn string
            DataInCount += 1
            DataIn(DataInCount) = InByte
            DataIn(0) = DataInCount
        End If
    Loop</pre><p><br>
<br></p><p><span class="strong"><strong>Example2:</strong></span></p><pre class="screen">    ' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #Config MCLRE_ON

    ; ----- Define Hardware settings

    '' -------------------LATA-----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' LED:   ---------------|D5 |D4 |D3 |D2 |-
    ''-----------------------------------------
    ''

    'Set the PPS of the RS232 ports.
    UNLOCKPPS
      RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
      RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
    LOCKPPS

    ; ----- Constants
    #define USART_BAUD_RATE 19200
    #define USART_TX_BLOCKING

    #define LEDD2 PORTA.0
    #define LEDD3 PORTA.1
    #define LEDD4 PORTA.2
    #define LEDD5 PORTA.3
    Dir     LEDD2 OUT
    Dir     LEDD3 OUT
    Dir     LEDD4 OUT
    Dir     LEDD5 OUT


    #define Potentiometer       PORTA.4
    DIR     Potentiometer In

    #define SWITCH_DOWN         0
    #define SWITCH_UP           1
    #define SWITCH              PORTA.5
    Dir SWITCH                  In

    ; ----- Variables
    dim bytevar as Byte
    dim wordvar as Word
    dim longvar as long

    bytevar = 0
    wordvar = 0
    longvar = 0



    ; ----- Main body of program commences here.

     #option Explicit

     do
         wait 100 ms

         bytevar = Val( "255" )
         HSerPrint bytevar
         HSerPrintCRLF

         wordvar = Val( "65535" )
         HSerPrint wordvar
         HSerPrintCRLF

         longvar = Val32( "65536" )
         HSerPrint longvar
         HSerPrintCRLF 2

         wait 1 s
      loop
    end

  ; ----- Support methods.  Subroutines and Functions</pre><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_hex.html" title="Hex">Hex</a>, <a class="link" href="_str.html" title="Str">Str</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="val"></span>Val

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    var = Val(string)   'Supports decimal byte and word strings only.

    'use the following for strings that represent Long numbers
    var = Val32(string)   'Supports decimal long number strings only.
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers

<span class="strong">**Explanation:**</span>

The `Val` function will extract a number from a string variable, and
store it in a word variable. One potential use is reading numbers that
are sent in ASCII format over a serial connection.  
  
The `Val32` function will extract a long number from a string variable,
and store it in a long variable.

  
  
The `Val` function will not extract a value from a hexadecimal string.  
  

<span class="strong">**Example1:**</span>

``` screen
    'Program for an RS232 controlled dimmer
    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Set pin directions for USART and PWM

    'Variable for output level
    Dim OutputLevel As Word

    'Variables for received bytes
    Dim DataIn As String
    DataInCount = 0

    'Main Loop
    Do
        'Get serial byte
        Wait Until USARTHasData
        HSerReceive InByte

        'Process latest byte
        'Enter key?
        If InByte = 13 Then
            'Convert output level to numeric variable
            OutputLevel = Val(DataIn)

            'Output
            HPWM 1, 32, OutputLevel

            'Clear output buffer for next command
            DataIn = ""
            DataInCount = 0
        End If

        'Number?
        If InByte >= 48 and InByte <= 57 Then
            'Add to end of DataIn string
            DataInCount += 1
            DataIn(DataInCount) = InByte
            DataIn(0) = DataInCount
        End If
    Loop
```

  
  

<span class="strong">**Example2:**</span>

``` screen
    ' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #Config MCLRE_ON

    ; ----- Define Hardware settings

    '' -------------------LATA-----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' LED:   ---------------|D5 |D4 |D3 |D2 |-
    ''-----------------------------------------
    ''

    'Set the PPS of the RS232 ports.
    UNLOCKPPS
      RC0PPS = 0x0010     'RC0->EUSART:TX;
      RXPPS  = 0x0011     'RC1->EUSART:RX;
    LOCKPPS

    ; ----- Constants
    #define USART_BAUD_RATE 19200
    #define USART_TX_BLOCKING

    #define LEDD2 PORTA.0
    #define LEDD3 PORTA.1
    #define LEDD4 PORTA.2
    #define LEDD5 PORTA.3
    Dir     LEDD2 OUT
    Dir     LEDD3 OUT
    Dir     LEDD4 OUT
    Dir     LEDD5 OUT


    #define Potentiometer       PORTA.4
    DIR     Potentiometer In

    #define SWITCH_DOWN         0
    #define SWITCH_UP           1
    #define SWITCH              PORTA.5
    Dir SWITCH                  In

    ; ----- Variables
    dim bytevar as Byte
    dim wordvar as Word
    dim longvar as long

    bytevar = 0
    wordvar = 0
    longvar = 0



    ; ----- Main body of program commences here.

     #option Explicit

     do
         wait 100 ms

         bytevar = Val( "255" )
         HSerPrint bytevar
         HSerPrintCRLF

         wordvar = Val( "65535" )
         HSerPrint wordvar
         HSerPrintCRLF

         longvar = Val32( "65536" )
         HSerPrint longvar
         HSerPrintCRLF 2

         wait 1 s
      loop
    end

  ; ----- Support methods.  Subroutines and Functions
```

<span class="strong">**See Also**</span>
<a href="hex" class="link" title="Hex">Hex</a>,
<a href="str" class="link" title="Str">Str</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Variables Operations</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_command_references.html" title="Command References"><link rel="prev" href="_smt_timers.html" title="SMT Timers"><link rel="next" href="_using_variables.html" title="Using Variables"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_variables_operations"></a>Variables Operations</h3></div></div></div><p>This is the Variables Operations section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="variables_operations"></span>Variables Operations

</div>

</div>

</div>

This is the Variables Operations section of the Help file. Please refer
the sub-sections for details using the contents/folder view.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Variable Advanced Types</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microcontroller_fundamentals.html" title="Microcontroller Fundamentals"><link rel="prev" href="_variable_types.html" title="Variable Types"><link rel="next" href="_variable_memory_allocation.html" title="Variable Memory Allocation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_variable_advanced_types"></a>Variable Advanced Types</h3></div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Experimental - Not Supported - For Development Team use only</p></div><p><span class="strong"><strong>About Variable Advanced Types</strong></span></p><p>A variable is an area of memory on the microcontroller that can be used to store a number or other data.&nbsp;&nbsp;
This is useful for many purposes, such as taking a sensor reading and acting on it, or counting the number of times the microcontroller has performed a particular task.</p><p>Each variable must be given a name, such as "MyVariable" or "PieCounter".&nbsp;&nbsp;
Choosing a name for a variable is easy - do not include spaces or any symbols (other than _), and make sure that the name is at least 2 characters (letters and/or numbers) long.</p><p><span class="strong"><strong>Advanced Types</strong></span></p><p>There are a number different types of advanced variable types, and each type can store a different range of numeric information.&nbsp;&nbsp;
With respect to advanced variables GCBASIC supports:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">large integers which can be signed &amp; unsigned</li><li class="listitem">floating points floats) which can be signed and unsigned.&nbsp;&nbsp;</li></ul></div><p>However, using large integers and floats point maths is also much slower than integer maths when performing calculations and loops, therefore should be avoided if.&nbsp;&nbsp;
You should convert float calculations to integer maths to increase operation of your solution.&nbsp;&nbsp;
The example program (shown below) shows how use a float maths and how to achieve the same calculation using integer maths.&nbsp;&nbsp;
<br>
<br>
The advanced variable types that GCBASIC supports are:</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Advanced Variable type</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Information that this variable can store</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example uses for this type of variable</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>LongINT</p></td><td align="left" valign="top"><p>A list of whole numbers between - (2 ^ 63) and 2 ^ 63 - 1</p></td><td align="left" valign="top"><p>Storing very, very big integer numbers that could be a negative number.
</p><p>The GCBASIC range is -9999999999999990 to 9999999999999990.
</p><p>This range is an implementation constraint with the GCBASIC compiler.</p></td></tr><tr><td align="left" valign="top"><p>uLongINT</p></td><td align="left" valign="top"><p>A whole number between 0 and 2 ^ 64 - 1</p></td><td align="left" valign="top"><p>Storing very, very, very big integer numbers</p></td></tr><tr><td align="left" valign="top"><p>Single</p></td><td align="left" valign="top"><p>A numeric floating point values that range from -3.4x10 ^ 38 and +3.4x10 ^ 38  with up to seven significant digits.</p></td><td align="left" valign="top"><p>Storing decimal numbers that could be a negative number and positive.</p></td></tr><tr><td align="left" valign="top"><p>Double</p></td><td align="left" valign="top"><p>A numeric floating point values that range from  -1.7x10 ^ 308 and +1.7x10 ^ 308 with up to 15 significant digits.</p></td><td align="left" valign="top"><p>Storing decimal numbers that could be a negative number and positive.</p></td></tr></tbody></table></div><p><br>
The format for single and double floats is defined by the IEEE 754 standard.&nbsp;&nbsp;
Sign, exponent and mantissa are all in the positions described here: <a class="link" href="https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/" target="_top">https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/</a></p><p><span class="strong"><strong>Organisation of advanced variables</strong></span></p><p>GCBASIC stores advanced variables in bytes.&nbsp;&nbsp;
The format of these bytes is:</p><pre class="literallayout">_ D, _C, _B, _A, _E, _U, _H, variable_name  ( from high to Low)</pre><p>You can access the bytes within advanced variables using the following as a guide using the suffixes _A, _B, _C etc.</p><p>Example of accessing the lowest byte, the _H, _U and the _A bytes.</p><pre class="screen">    Dim workvariable as longInt
    workvariable = 21845
    Dim lowb as byte
    Dim highb as byte
    Dim upperb as byte
    Dim lastb as byte


    lowb = workvariable
    highb = workvariable_H
    upperb = workvariable_U
    lastb = workvariable_A</pre><p><br>
<br>
<span class="strong"><strong>Using Advanced Variables</strong></span></p><p>Advanced variables must be "DIMensioned" first.&nbsp;&nbsp;This involves using the DIM command,
to tell GCBASIC that it is dealing with an advanced variable.</p><pre class="screen">    Dim myLongInt as LongInt
    myLongInt = 9999999999999990          'see the Help for constraints

    Dim myuLongInt as uLongInt
    myuLongInt = 0xFFFFFFFFFFFFF          'see the Help for constraints

    Dim mySingle as Single
    mySingle= 1.1

    Dim myDouble as Double
    myDouble=3.141592</pre><p><br>
<br></p><p><span class="strong"><strong>Using Advanced Variables</strong></span></p><p>Advanced variables are only supported by a subset of the functions of GCBASIC.&nbsp;&nbsp;</p><p>If the function is NOT shown below assume the function is NOT supported.&nbsp;&nbsp;If you use a function that is not shown below then you may get a silent failure and you may not get the results you expected.</p><p>The functional characteristics are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Dimensioning of  longInt, ulongInt, single and double advanced variable types.</li><li class="listitem">Assigning advanced variables creation of values from constants.</li><li class="listitem">Assigning a single to double and double to single.</li><li class="listitem">Assigning single to long and long to single.</li><li class="listitem">Assigning double to long and long to double.</li><li class="listitem">The assignment of a single or a double to a long also deals with byte and word.&nbsp;&nbsp; This is very inefficient.</li><li class="listitem">Copying between variables of the same type (so double to double, and single to single and other advanced variables).</li><li class="listitem">Extract of the unit value of a single or double variable to a long variable.</li><li class="listitem">Setting of advanced variable bits.</li><li class="listitem">Addition and subtraction of advanced variables.</li><li class="listitem">Rotate of longInt &amp; ulongInt advanced variables.</li><li class="listitem">Negate of longInt &amp; ulongInt advanced variables.</li><li class="listitem">Boolean operators working on advanced variables.</li><li class="listitem">Use of  float variable(s) as global variables. &nbsp;&nbsp;Passing float variable(s) as parameters to methods ( sub, function and macro) not supported.</li></ul></div><p><br>
<br></p><p>Functions explicitly not supported</p><p>These are the functions that are not supported.&nbsp;&nbsp;
Assuming that a function is not supported is the best approach when using advanced variables.&nbsp;&nbsp;
Use of these functions may cause an error message or may silently fail producing invalid ASM.
<br>
Functionality explicitly not supported is shown below.&nbsp;&nbsp;
<br></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Support for conditional statements</li><li class="listitem">Support for overload subs/functions</li><li class="listitem">Passing float variable(s) as parameters to methods ( sub, function and macro)</li><li class="listitem">Extraction of mantissa value</li><li class="listitem">Multiplication</li><li class="listitem">Division</li><li class="listitem">Modulo</li><li class="listitem">IntToString</li><li class="listitem">SingleToString</li><li class="listitem">StringToVal</li><li class="listitem">StringToInt</li><li class="listitem">StringToSingle</li><li class="listitem">Advanced variable(s) to string functions</li><li class="listitem">Math functions for float variable(s) (see below for pseudo functions)</li><li class="listitem">Rotate of single &amp; double advanced variable(s)</li><li class="listitem">Negate of single &amp; double advanced variable(s)</li><li class="listitem">Reliable serial operations using methods like HSerPrint or SerPrint.</li></ul></div><p><br>
<br></p><p><span class="strong"><strong>Assigning Values to Advanced Variables</strong></span></p><p>You can assign values to advanced variables using&nbsp;&nbsp;`=`.&nbsp;&nbsp;</p><p>A simple, but typical example follows.&nbsp;&nbsp;This is the typical for numeric variable assignment.</p><pre class="screen">    Dim myLontINT as LontINT
    myLontINT = 0XFFFFFF       'assign the value of 16777215</pre><p>Another example is bitwise assignments as follows:</p><pre class="screen">    myLontINT.16 = 1  'set the single bit to 1</pre><p><br>
<br></p><p><span class="strong"><strong>INT() and ROUND()</strong></span></p><p>Floating point numbers are not exact, and may yield unexpected results when compared using conditions (IF etc).&nbsp;&nbsp;
For example 6.0 / 3.0 may not equal 2.0.&nbsp;&nbsp;
Users should instead check that the absolute value of the difference between the numbers is less than some small number.
<br></p><p>These techniques replace the INT() and ROUND() functions.
<br>
<br></p><p><span class="emphasis"><em>Pseudo INT()</em></span></p><p>Using the INT() function is not supported.&nbsp;&nbsp;</p><p>So, use the conversion from floating point to integer as this results in integer truncation.</p><pre class="screen">        dim mySingleVar as Single
        mySingleVar = 2.9  'A float type variable

        dim myLongVar as Long
        myLongVar = mySingleVar ' will set myLongVar to 2</pre><p><br>
<br></p><p><span class="emphasis"><em>Pseudo ROUND()</em></span></p><p>Using the ROUND() function is not supported.&nbsp;&nbsp;</p><p>So, to round off during the conversion process,  add 0.5:&nbsp;&nbsp;As follows:</p><pre class="screen">        'Add 0.5 to a single or double and then assign to an integer variable

        dim mySingleVar as Single
        mySingleVar = 2.9

        dim myLongVar as Long
        myLongVar= mySingleVar + [single]0.5  '3</pre><p><br>
<br></p><p><span class="strong"><strong>Example Program</strong></span></p><p>This program shows the values of calculation of 4.5 * multiplied by a number ( 4.5 x a range of 0 to 40,000).&nbsp;&nbsp;
The program shows setting up the advanced variables, assigned a value and completing the multiplication of the initial value using a repeat loop.&nbsp;&nbsp;
The repeat loop is used as advanced variables are are not supported by multiplication ( or division ), so, using the repeat an alternative to multiplication, just a lot slower.&nbsp;&nbsp;</p><p>The program using advanced variables to show the results, and, then uses factorised ineger maths to show the results.&nbsp;&nbsp;
The performance of each approach can be examined on the serial terminal.</p><pre class="screen">    HSerPrintCRLF 2
    HSerPrint "Maths test "
    HSerPrintCRLF 2

    DIM multiplier as Word
    DIM ccount as Double
    DIM calcresult as Single
    Dim result as Long

    HSerPrint "Use floats with pseudo multiplier  maths"
    HSerPrintCRLF

    'Assign a value to a double variable
    ccount   = 4.5

      For  multiplier = 0 to 40000 step 2500
        calcresult = 0

        'Do some maths... multiplier x ccount .... slow but as there is NO multi or divide for floats.. this is a method to simulate a multiplier operation
        Repeat multiplier
            calcresult = calcresult + ccount
        End Repeat

        HSerPrint "4.5"
        HSerPrint " x "
        HSerPrint left(str32(multiplier)+"        ", 8 )
        HSerPrint " = "

        'Convert Single to Long to get the result
        result = calcresult
        HSerPrint left(str32(result)+"        ", 8 )

        'Now do the scale maths - this can all be done in integer maths
        HSerPrint " scaled result = "
        result = 180-(result/1000)
        HSerPrint Result
        HSerPrintCRLF
        wait 100 ms

      next


    'Use conventional Integer number using facttoristion
    HSerPrint "Use factored integer maths"
    HSerPrintCRLF
    dim ccount_int as Byte 'integer byte

    'Factored the 4.5 x 10 larger
    ccount_int   = 45

    For  multiplier = 0 to 40000 step 2500

      'Do some maths... multiplier x ccount
      result = multiplier * ccount_int

      HSerPrint "45"
      HSerPrint " x "
      HSerPrint left(str32(multiplier)+"        ", 8 )
      HSerPrint " = "

      HSerPrint left(str32(result)+"        ", 8 )

      'Now do the scale maths - this can all be done in integer maths
      HSerPrint " scaled result = "

      'Factored calculation is 10 x larger
      result = 180-(result/10000)
      HSerPrint Result
      HSerPrintCRLF
      wait 100 ms

    next</pre><p>To check variables and apply logic based on their value, see
<a class="link" href="_if.html" title="If">If</a>, <a class="link" href="_do.html" title="Do">Do</a>, <a class="link" href="_for.html" title="For">For</a>, <a class="link" href="_conditions.html" title="Conditions">Conditions</a>
<br></p><p><span class="strong"><strong>For more help, see:</strong></span> <a class="link" href="_dim.html" title="Dim">Declaring variables with DIM</a>, <a class="link" href="_setting_variables.html" title="Setting Variables">Setting Variables</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="variable_advanced_types"></span>Variable Advanced Types

</div>

</div>

</div>

<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

### Warning

Experimental - Not Supported - For Development Team use only

</div>

<span class="strong">**About Variable Advanced Types**</span>

A variable is an area of memory on the microcontroller that can be used
to store a number or other data.   This is useful for many purposes,
such as taking a sensor reading and acting on it, or counting the number
of times the microcontroller has performed a particular task.

Each variable must be given a name, such as "MyVariable" or
"PieCounter".   Choosing a name for a variable is easy - do not include
spaces or any symbols (other than \_), and make sure that the name is at
least 2 characters (letters and/or numbers) long.

<span class="strong">**Advanced Types**</span>

There are a number different types of advanced variable types, and each
type can store a different range of numeric information.   With respect
to advanced variables GCBASIC supports:

<div class="itemizedlist">

-   large integers which can be signed & unsigned
-   floating points floats) which can be signed and unsigned.  

</div>

However, using large integers and floats point maths is also much slower
than integer maths when performing calculations and loops, therefore
should be avoided if.   You should convert float calculations to integer
maths to increase operation of your solution.   The example program
(shown below) shows how use a float maths and how to achieve the same
calculation using integer maths.    
  
The advanced variable types that GCBASIC supports are:

<div class="informaltable">

<table data-border="1" width="80%">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="strong"><strong>Advanced Variable type</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Information that this variable can store</strong></span></th>
<th style="text-align: left;"><span class="strong"><strong>Example uses for this type of variable</strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>LongINT</p></td>
<td style="text-align: left;"><p>A list of whole numbers between - (2 ^ 63) and 2 ^ 63 - 1</p></td>
<td style="text-align: left;"><p>Storing very, very big integer numbers that could be a negative number.</p>
<p>The GCBASIC range is -9999999999999990 to 9999999999999990.</p>
<p>This range is an implementation constraint with the GCBASIC compiler.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>uLongINT</p></td>
<td style="text-align: left;"><p>A whole number between 0 and 2 ^ 64 - 1</p></td>
<td style="text-align: left;"><p>Storing very, very, very big integer numbers</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Single</p></td>
<td style="text-align: left;"><p>A numeric floating point values that range from -3.4x10 ^ 38 and +3.4x10 ^ 38 with up to seven significant digits.</p></td>
<td style="text-align: left;"><p>Storing decimal numbers that could be a negative number and positive.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Double</p></td>
<td style="text-align: left;"><p>A numeric floating point values that range from -1.7x10 ^ 308 and +1.7x10 ^ 308 with up to 15 significant digits.</p></td>
<td style="text-align: left;"><p>Storing decimal numbers that could be a negative number and positive.</p></td>
</tr>
</tbody>
</table>

</div>

  
The format for single and double floats is defined by the IEEE 754
standard.   Sign, exponent and mantissa are all in the positions
described here:
<https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/>

<span class="strong">**Organisation of advanced variables**</span>

GCBASIC stores advanced variables in bytes.   The format of these bytes
is:

``` literallayout
_ D, _C, _B, _A, _E, _U, _H, variable_name  ( from high to Low)
```

You can access the bytes within advanced variables using the following
as a guide using the suffixes \_A, \_B, \_C etc.

Example of accessing the lowest byte, the \_H, \_U and the \_A bytes.

``` screen
    Dim workvariable as longInt
    workvariable = 21845
    Dim lowb as byte
    Dim highb as byte
    Dim upperb as byte
    Dim lastb as byte


    lowb = workvariable
    highb = workvariable_H
    upperb = workvariable_U
    lastb = workvariable_A
```

  
  
<span class="strong">**Using Advanced Variables**</span>

Advanced variables must be "DIMensioned" first.  This involves using the
DIM command, to tell GCBASIC that it is dealing with an advanced
variable.

``` screen
    Dim myLongInt as LongInt
    myLongInt = 9999999999999990          'see the Help for constraints

    Dim myuLongInt as uLongInt
    myuLongInt = 0xFFFFFFFFFFFFF          'see the Help for constraints

    Dim mySingle as Single
    mySingle= 1.1

    Dim myDouble as Double
    myDouble=3.141592
```

  
  

<span class="strong">**Using Advanced Variables**</span>

Advanced variables are only supported by a subset of the functions of
GCBASIC.  

If the function is NOT shown below assume the function is NOT
supported.  If you use a function that is not shown below then you may
get a silent failure and you may not get the results you expected.

The functional characteristics are:

<div class="itemizedlist">

-   Dimensioning of longInt, ulongInt, single and double advanced
    variable types.
-   Assigning advanced variables creation of values from constants.
-   Assigning a single to double and double to single.
-   Assigning single to long and long to single.
-   Assigning double to long and long to double.
-   The assignment of a single or a double to a long also deals with
    byte and word.   This is very inefficient.
-   Copying between variables of the same type (so double to double, and
    single to single and other advanced variables).
-   Extract of the unit value of a single or double variable to a long
    variable.
-   Setting of advanced variable bits.
-   Addition and subtraction of advanced variables.
-   Rotate of longInt & ulongInt advanced variables.
-   Negate of longInt & ulongInt advanced variables.
-   Boolean operators working on advanced variables.
-   Use of float variable(s) as global variables.   Passing float
    variable(s) as parameters to methods ( sub, function and macro) not
    supported.

</div>

  
  

Functions explicitly not supported

These are the functions that are not supported.   Assuming that a
function is not supported is the best approach when using advanced
variables.   Use of these functions may cause an error message or may
silently fail producing invalid ASM.  
Functionality explicitly not supported is shown below.    

<div class="itemizedlist">

-   Support for conditional statements
-   Support for overload subs/functions
-   Passing float variable(s) as parameters to methods ( sub, function
    and macro)
-   Extraction of mantissa value
-   Multiplication
-   Division
-   Modulo
-   IntToString
-   SingleToString
-   StringToVal
-   StringToInt
-   StringToSingle
-   Advanced variable(s) to string functions
-   Math functions for float variable(s) (see below for pseudo
    functions)
-   Rotate of single & double advanced variable(s)
-   Negate of single & double advanced variable(s)
-   Reliable serial operations using methods like HSerPrint or SerPrint.

</div>

  
  

<span class="strong">**Assigning Values to Advanced Variables**</span>

You can assign values to advanced variables using  \`=\`.  

A simple, but typical example follows.  This is the typical for numeric
variable assignment.

``` screen
    Dim myLontINT as LontINT
    myLontINT = 0XFFFFFF       'assign the value of 16777215
```

Another example is bitwise assignments as follows:

``` screen
    myLontINT.16 = 1  'set the single bit to 1
```

  
  

<span class="strong">**INT() and ROUND()**</span>

Floating point numbers are not exact, and may yield unexpected results
when compared using conditions (IF etc).   For example 6.0 / 3.0 may not
equal 2.0.   Users should instead check that the absolute value of the
difference between the numbers is less than some small number.  

These techniques replace the INT() and ROUND() functions.  
  

<span class="emphasis">*Pseudo INT()*</span>

Using the INT() function is not supported.  

So, use the conversion from floating point to integer as this results in
integer truncation.

``` screen
        dim mySingleVar as Single
        mySingleVar = 2.9  'A float type variable

        dim myLongVar as Long
        myLongVar = mySingleVar ' will set myLongVar to 2
```

  
  

<span class="emphasis">*Pseudo ROUND()*</span>

Using the ROUND() function is not supported.  

So, to round off during the conversion process, add 0.5:  As follows:

``` screen
        'Add 0.5 to a single or double and then assign to an integer variable

        dim mySingleVar as Single
        mySingleVar = 2.9

        dim myLongVar as Long
        myLongVar= mySingleVar + [single]0.5  '3
```

  
  

<span class="strong">**Example Program**</span>

This program shows the values of calculation of 4.5 \* multiplied by a
number ( 4.5 x a range of 0 to 40,000).   The program shows setting up
the advanced variables, assigned a value and completing the
multiplication of the initial value using a repeat loop.   The repeat
loop is used as advanced variables are are not supported by
multiplication ( or division ), so, using the repeat an alternative to
multiplication, just a lot slower.  

The program using advanced variables to show the results, and, then uses
factorised ineger maths to show the results.   The performance of each
approach can be examined on the serial terminal.

``` screen
    HSerPrintCRLF 2
    HSerPrint "Maths test "
    HSerPrintCRLF 2

    DIM multiplier as Word
    DIM ccount as Double
    DIM calcresult as Single
    Dim result as Long

    HSerPrint "Use floats with pseudo multiplier  maths"
    HSerPrintCRLF

    'Assign a value to a double variable
    ccount   = 4.5

      For  multiplier = 0 to 40000 step 2500
        calcresult = 0

        'Do some maths... multiplier x ccount .... slow but as there is NO multi or divide for floats.. this is a method to simulate a multiplier operation
        Repeat multiplier
            calcresult = calcresult + ccount
        End Repeat

        HSerPrint "4.5"
        HSerPrint " x "
        HSerPrint left(str32(multiplier)+"        ", 8 )
        HSerPrint " = "

        'Convert Single to Long to get the result
        result = calcresult
        HSerPrint left(str32(result)+"        ", 8 )

        'Now do the scale maths - this can all be done in integer maths
        HSerPrint " scaled result = "
        result = 180-(result/1000)
        HSerPrint Result
        HSerPrintCRLF
        wait 100 ms

      next


    'Use conventional Integer number using facttoristion
    HSerPrint "Use factored integer maths"
    HSerPrintCRLF
    dim ccount_int as Byte 'integer byte

    'Factored the 4.5 x 10 larger
    ccount_int   = 45

    For  multiplier = 0 to 40000 step 2500

      'Do some maths... multiplier x ccount
      result = multiplier * ccount_int

      HSerPrint "45"
      HSerPrint " x "
      HSerPrint left(str32(multiplier)+"        ", 8 )
      HSerPrint " = "

      HSerPrint left(str32(result)+"        ", 8 )

      'Now do the scale maths - this can all be done in integer maths
      HSerPrint " scaled result = "

      'Factored calculation is 10 x larger
      result = 180-(result/10000)
      HSerPrint Result
      HSerPrintCRLF
      wait 100 ms

    next
```

To check variables and apply logic based on their value, see
<a href="if" class="link" title="If">If</a>,
<a href="do" class="link" title="Do">Do</a>,
<a href="for" class="link" title="For">For</a>,
<a href="conditions" class="link" title="Conditions">Conditions</a>  

<span class="strong">**For more help, see:**</span>
<a href="dim" class="link" title="Dim">Declaring variables with DIM</a>,
<a href="setting_variables" class="link" title="Setting Variables">Setting Variables</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Variable Lifecycle</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_setting_variables.html" title="Setting Variables"><link rel="next" href="_dim.html" title="Dim"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_variable_lifecycle"></a>Variable Lifecycle</h4></div></div></div><p><span class="strong"><strong>Explanation</strong></span></p><p>Within GCBASIC you can use variables. This section details the Variable Lifecycle when using variables.</p><p><span class="strong"><strong>Variable rules - with #Option Explicit</strong></span></p><p>As shown below in the rule without #Option Explicit but ALL variables MUST be defined including bytes variables.</p><p><span class="strong"><strong>Variable rules - without #Option Explicit</strong></span></p><p>Scope - every variable is global from an addressing/usage point of view.</p><p>Once a variable is defined, and then the variable it is used the variable persists.</p><p>Aliasing - You can reduce memory usage by Aliasing.  Remember all variables are global so you must be careful.</p><p>If there are two variables with the same name, they will be placed in the same memory location. You can reuse the same variable name in two subs/functions, and you can make the variables different types, but writing to the variable in one sub will overwrite the value from the other sub, see the example below.</p><p>As a general guide define any shared variables near the start of the program for easier readability.</p><p>All variables should be initialised with a desired initialisation value.  Do not assume the initialisation value is Zero.</p><p>Variables local to particular subroutines are not implemented.</p><p><span class="strong"><strong>Specific rules to spefic variable types</strong></span></p><p>All variables are global.  Bit variables defined in subs/function are global.</p><p>Byte variables do not need to be defined using the DIM statement.  See #Option Explicit above.  Just to clarify byte is default type, this means:</p><pre class="screen">    Dim MainVar As Byte is unnecessary.
    MainVar = 128    automatic defines the MainVar variable</pre><p>Bit, Word, Longs, Integers and Strings variables must be defined.</p><p>All variables are global, but, if they are defined inside a particular subroutine then their type is not, see the example below:</p><p>Example code:</p><pre class="screen">    Dim MainVar As Byte
    Dim OtherVar As Word

    MainVar = 128
    OtherVar = 514

    DemoSub
    'At this point:
    'MainVar is a byte, value 128
    'OtherVar is a word, value 514
    'Counter is a byte, value 2
    '(Byte is default type, but location shared with that of Counter in DemoSub. High byte ignored)

    Sub DemoSub
        Dim Counter As Word
        Counter = 2050
        'At this point:
        'MainVar and OtherVar as byte and word, as in main routine
        'Counter is a word, value 2050
    End Sub</pre><p>In DemoSub, Counter is a word. But anywhere else in the program it is a byte unless otherwise specified.   If the variable is used/read in the main routine, it will be treated as a byte, and only the low 8 bits will be returned. In this example the low 8 bits of 2050 are 2.</p><p>The main reason for keeping the type inside the subroutine was for the following scenario:
A subroutine uses a temporary variable of type byte, and relies on it overflowing.</p><p>Another subroutine uses a temporary variable of the same name, but of word type.</p><p>If the first subroutine is already in the program, and then the second one is added, the behaviour of the first one will not change at all due to the addition of the second one.</p><p>The handling of variable types using this method minimises the size of the generated assembly code.</p><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="__option_explicit.html" title="#Option Explicit">Option Explicit</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="variable_lifecycle"></span>Variable Lifecycle

</div>

</div>

</div>

<span class="strong">**Explanation**</span>

Within GCBASIC you can use variables. This section details the Variable
Lifecycle when using variables.

<span class="strong">**Variable rules - with \#Option Explicit**</span>

As shown below in the rule without \#Option Explicit but ALL variables
MUST be defined including bytes variables.

<span class="strong">**Variable rules - without \#Option
Explicit**</span>

Scope - every variable is global from an addressing/usage point of view.

Once a variable is defined, and then the variable it is used the
variable persists.

Aliasing - You can reduce memory usage by Aliasing. Remember all
variables are global so you must be careful.

If there are two variables with the same name, they will be placed in
the same memory location. You can reuse the same variable name in two
subs/functions, and you can make the variables different types, but
writing to the variable in one sub will overwrite the value from the
other sub, see the example below.

As a general guide define any shared variables near the start of the
program for easier readability.

All variables should be initialised with a desired initialisation value.
Do not assume the initialisation value is Zero.

Variables local to particular subroutines are not implemented.

<span class="strong">**Specific rules to spefic variable types**</span>

All variables are global. Bit variables defined in subs/function are
global.

Byte variables do not need to be defined using the DIM statement. See
\#Option Explicit above. Just to clarify byte is default type, this
means:

``` screen
    Dim MainVar As Byte is unnecessary.
    MainVar = 128    automatic defines the MainVar variable
```

Bit, Word, Longs, Integers and Strings variables must be defined.

All variables are global, but, if they are defined inside a particular
subroutine then their type is not, see the example below:

Example code:

``` screen
    Dim MainVar As Byte
    Dim OtherVar As Word

    MainVar = 128
    OtherVar = 514

    DemoSub
    'At this point:
    'MainVar is a byte, value 128
    'OtherVar is a word, value 514
    'Counter is a byte, value 2
    '(Byte is default type, but location shared with that of Counter in DemoSub. High byte ignored)

    Sub DemoSub
        Dim Counter As Word
        Counter = 2050
        'At this point:
        'MainVar and OtherVar as byte and word, as in main routine
        'Counter is a word, value 2050
    End Sub
```

In DemoSub, Counter is a word. But anywhere else in the program it is a
byte unless otherwise specified. If the variable is used/read in the
main routine, it will be treated as a byte, and only the low 8 bits will
be returned. In this example the low 8 bits of 2050 are 2.

The main reason for keeping the type inside the subroutine was for the
following scenario: A subroutine uses a temporary variable of type byte,
and relies on it overflowing.

Another subroutine uses a temporary variable of the same name, but of
word type.

If the first subroutine is already in the program, and then the second
one is added, the behaviour of the first one will not change at all due
to the addition of the second one.

The handling of variable types using this method minimises the size of
the generated assembly code.

<span class="strong">**For more help, see**</span>
<a href="_option_explicit" class="link" title="#Option Explicit">Option Explicit</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Variable Memory Allocation</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microcontroller_fundamentals.html" title="Microcontroller Fundamentals"><link rel="prev" href="_variable_advanced_types.html" title="Variable Advanced Types"><link rel="next" href="_usb_drivers_installer.html" title="USB Drivers Installer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_variable_memory_allocation"></a>Variable Memory Allocation</h3></div></div></div><p>This section discusses the allocation of variables to RAM ( GPR, SRAM or other TLA).</p><p>Variables in GCBASIC can be bits, bytes, words, integers, longs, arrays or reals. &nbsp;&nbsp;This section will NOT address reals as these are developmental variables only.</p><p>Variables can also be defined as Aliases - this is discussed later in this section.</p><p><span class="strong"><strong>Basic variable allocation</strong></span></p><p>Variables of  type <span class="emphasis"><em>byte</em></span>, <span class="emphasis"><em>word</em></span>, <span class="emphasis"><em>integer</em></span>, <span class="emphasis"><em>longs</em></span> are placed in RAM using the following simple rules.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">A RAM memory location  is automatically assigned starting at the first available memory location.</li><li class="listitem">The first memory location is first RAM location as defined in the chip datasheet.</li><li class="listitem">Once a variable is allocated the RAM location is marked as used and this specific location can be reviewed in the ASM source.</li><li class="listitem">Bytes use a single  RAM location, words two  RAM locations, integer and longs four  RAM locations.</li><li class="listitem">Subsequent variables of type byte, word, integer, longs are placed in RAM at the next available RAM location.</li></ol></div><p>Variables of  <span class="emphasis"><em>array</em></span> and <span class="emphasis"><em>strings</em></span> type are placed in RAM using the following simple rules.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">A RAM memory location is automatically assigned from the end of RAM less the ( size of the array + 1 byte ).</li><li class="listitem">The last memory location is last RAM location as defined in the chip datasheet.</li><li class="listitem">Once an array is allocated the RAM location is marked as used and the start of the array RAM location can be reviewed in the ASM source.</li><li class="listitem">Subsequent variables of type array in RAM at the next available RAM location subtracted from the start the of previous RAM location minus the size of this next array.</li></ol></div><p>Variables of <span class="emphasis"><em>bit</em></span> type are placed in RAM using the following simple rules.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Bit memory location is automatically assigned to the first bit with the creation of a BYTE variable at a RAM memory location that is automatically assigned starting at the first available memory location. &nbsp;&nbsp; This byte can handle 8 bits.</li><li class="listitem">Once a bit is allocated the byte is marked as used and this specific location can be reviewed in the ASM source.</li><li class="listitem">Subsequent bits are allocation either to an existing byte variable, or when 8 bits are allocated to an existing byte variable another byte variable will be created.</li></ol></div><p><span class="strong"><strong>Addressing Variables</strong></span></p><p>Addressing variable can be achieved by using the @ prefix. &nbsp;&nbsp; This will return the address of the variable (the same @ applies to table data).</p><p>The following example shows registers DMAnSSAU, DMAnSSAH, DMAnSSAL being loaded with the address of the array WaveArray.</p><pre class="screen">    ' Source start address
    Dim addressdummy as byte
    Dim DMAnSS as long ALIAS addressdummy, DMAnSSAU, DMAnSSAH, DMAnSSAL
    DMAnSS = @WaveArray</pre><p><br></p><p><span class="strong"><strong>AT allocation</strong></span></p><p>The Dim variable command can be used to instruct GCBASIC to allocate variables  at a specific memory location using the parameter AT.</p><p>The compiler will inspect the provided AT memory location and if the memory location is already used ( by an existing variable), lower than the minimum memory location or greater than the maximum memory location an error will be issued.</p><p><br>
<span class="strong"><strong>Variable Aliases</strong></span></p><p>Variable can be defined as  aliases. &nbsp;&nbsp; Aliases  are used to refer to existing memory locations SFR or RAM and aliases can be used to construct other variables.&nbsp;&nbsp;  Constructed variables can be a mix  ( or not ) of SFR or RAM.  &nbsp;&nbsp; These are useful for joining predefined byte variables together to form a word/long variable.</p><p>Aliases are not like pointers in many languages - they must always refer to an existing variable or variables and cannot be changed.</p><p>When setting a register/variable bit ( i.e  my_variable.my_bit_address_variable ) and using a alias for the variable then you must ensure the bytes that construct the variable are consecutive.</p><p>Aliases are shown in the ASM source in the ;ALIAS VARIABLES section.</p><p>The coding approach should be to DIMension the variable (word, integer, or long) first, then create the byte aliases:</p><pre class="screen">    Dim my_variable as LONG
    Dim ByteOne   as Byte alias my_variable_E
    Dim ByteTwo   as Byte alias my_variable_U
    Dim ByteThree as Byte alias my_variable_H
    Dim ByteFour  as Byte alias my_variable

    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    'then, use the four byte variables as you need to.</pre><p>To set a series of registers that are not consecutive, it is recommended to use a mask variable then apply it to the registers:</p><pre class="screen">    Dim my_variable as LONG
    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    porta =  my_variable_E
    portb =  my_variable_E
    portc =  my_variable_E
    portd =  my_variable_E</pre><p><span class="strong"><strong>Memory Specification</strong></span></p><p>All memory specifics like RAM size, lower and upper RAM addresses are specified in the chip specific dat file.</p><p>The dat file details should be reviewed in PICINFO application.   See the PICINFO/CHIPDATA tab for RAM and MaxAddress etc.</p><p>A simple calculation is MaxAddress - RAM +1 = the 'first memory address'.  And, 'first memory address' + RAM -1 = 'the last memory address.</p><p>This can be confirmed by review the DAT file. See the section [FreeRAM] for the start and end of RAM.</p><p>The dat file also has a [NoBankRAM].  NoBankRAM is somewhat misnamed - it is used for the defintion of (any) access bank locations.&nbsp;&nbsp; If a memory location is defined in both NoBankRAM and FreeRAM, then the compiler knows that it is access bank RAM.&nbsp;&nbsp;If an SFR location is in one of the NoBankRAM ranges, then the compiler knows not to do any bank selection when accessing that register.</p><p>The [NoBankRAM] section includes two ranges, one for access bank RAM, one for access bank SFRs.
The first range MUST be the ACCESS RAM range
The first range is the FAST SFR range</p><p>If there are no ranges defined in NoBankRAM, the compiler will try to guess them.&nbsp;&nbsp;
On 18Fs, it will guess based on where the lowest SFR is, and from what the total RAM on the chip is.&nbsp;&nbsp; If there&#8217;s only one range defined. &nbsp;&nbsp; in the NoBankRAM locations, the compiler will assume that is the range for the RAM, and then will guess where the range for the access bank SFRs is.</p><pre class="screen">    'GCBASIC/GCGB Chip Data File
    'Chip: 18F27Q43

    [ChipData]

    .... many other data rows

    'This constant is exposed as ChipRAM
    RAM=8192             'Dec values

    .... many other data rows

    'This constant is exposed as ChipMaxAddress
    MaxAddress=9471      'Dec values

    .... many other data rows

    [FreeRAM]
    500:24FF             'Hex value

    [NoBankRAM]
    500:55F              'Hex value
    460:4FF              'Hex value

    .... many other data rows</pre><p><br></p><p>In the example shown above the following can be extracted.
<br></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">RAM size:              RAM = 8192d</li><li class="listitem">Minimum RAM address:   FREERAM = 0x500</li><li class="listitem">Maximum RAM address:   FREERAM = 0x24FF</li><li class="listitem">Maximum RAM address:   MAXADDRESS=9471d or 0x24FF</li><li class="listitem">ACCESS RAM:            NOBANKRAM = 0x500-0x55F</li><li class="listitem">BANKED SFR:            NOBANKRAM = 0x460-0x4FF</li></ol></div><p><br>
<br></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="variable_memory_allocation"></span>Variable Memory Allocation

</div>

</div>

</div>

This section discusses the allocation of variables to RAM ( GPR, SRAM or
other TLA).

Variables in GCBASIC can be bits, bytes, words, integers, longs, arrays
or reals.   This section will NOT address reals as these are
developmental variables only.

Variables can also be defined as Aliases - this is discussed later in
this section.

<span class="strong">**Basic variable allocation**</span>

Variables of type <span class="emphasis">*byte*</span>, <span
class="emphasis">*word*</span>, <span class="emphasis">*integer*</span>,
<span class="emphasis">*longs*</span> are placed in RAM using the
following simple rules.

<div class="orderedlist">

1.  A RAM memory location is automatically assigned starting at the
    first available memory location.
2.  The first memory location is first RAM location as defined in the
    chip datasheet.
3.  Once a variable is allocated the RAM location is marked as used and
    this specific location can be reviewed in the ASM source.
4.  Bytes use a single RAM location, words two RAM locations, integer
    and longs four RAM locations.
5.  Subsequent variables of type byte, word, integer, longs are placed
    in RAM at the next available RAM location.

</div>

Variables of <span class="emphasis">*array*</span> and <span
class="emphasis">*strings*</span> type are placed in RAM using the
following simple rules.

<div class="orderedlist">

1.  A RAM memory location is automatically assigned from the end of RAM
    less the ( size of the array + 1 byte ).
2.  The last memory location is last RAM location as defined in the chip
    datasheet.
3.  Once an array is allocated the RAM location is marked as used and
    the start of the array RAM location can be reviewed in the ASM
    source.
4.  Subsequent variables of type array in RAM at the next available RAM
    location subtracted from the start the of previous RAM location
    minus the size of this next array.

</div>

Variables of <span class="emphasis">*bit*</span> type are placed in RAM
using the following simple rules.

<div class="orderedlist">

1.  Bit memory location is automatically assigned to the first bit with
    the creation of a BYTE variable at a RAM memory location that is
    automatically assigned starting at the first available memory
    location.    This byte can handle 8 bits.
2.  Once a bit is allocated the byte is marked as used and this specific
    location can be reviewed in the ASM source.
3.  Subsequent bits are allocation either to an existing byte variable,
    or when 8 bits are allocated to an existing byte variable another
    byte variable will be created.

</div>

<span class="strong">**Addressing Variables**</span>

Addressing variable can be achieved by using the @ prefix.    This will
return the address of the variable (the same @ applies to table data).

The following example shows registers DMAnSSAU, DMAnSSAH, DMAnSSAL being
loaded with the address of the array WaveArray.

``` screen
    ' Source start address
    Dim addressdummy as byte
    Dim DMAnSS as long ALIAS addressdummy, DMAnSSAU, DMAnSSAH, DMAnSSAL
    DMAnSS = @WaveArray
```

  

<span class="strong">**AT allocation**</span>

The Dim variable command can be used to instruct GCBASIC to allocate
variables at a specific memory location using the parameter AT.

The compiler will inspect the provided AT memory location and if the
memory location is already used ( by an existing variable), lower than
the minimum memory location or greater than the maximum memory location
an error will be issued.

  
<span class="strong">**Variable Aliases**</span>

Variable can be defined as aliases.    Aliases are used to refer to
existing memory locations SFR or RAM and aliases can be used to
construct other variables.   Constructed variables can be a mix ( or not
) of SFR or RAM.    These are useful for joining predefined byte
variables together to form a word/long variable.

Aliases are not like pointers in many languages - they must always refer
to an existing variable or variables and cannot be changed.

When setting a register/variable bit ( i.e
my\_variable.my\_bit\_address\_variable ) and using a alias for the
variable then you must ensure the bytes that construct the variable are
consecutive.

Aliases are shown in the ASM source in the ;ALIAS VARIABLES section.

The coding approach should be to DIMension the variable (word, integer,
or long) first, then create the byte aliases:

``` screen
    Dim my_variable as LONG
    Dim ByteOne   as Byte alias my_variable_E
    Dim ByteTwo   as Byte alias my_variable_U
    Dim ByteThree as Byte alias my_variable_H
    Dim ByteFour  as Byte alias my_variable

    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    'then, use the four byte variables as you need to.
```

To set a series of registers that are not consecutive, it is recommended
to use a mask variable then apply it to the registers:

``` screen
    Dim my_variable as LONG
    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    porta =  my_variable_E
    portb =  my_variable_E
    portc =  my_variable_E
    portd =  my_variable_E
```

<span class="strong">**Memory Specification**</span>

All memory specifics like RAM size, lower and upper RAM addresses are
specified in the chip specific dat file.

The dat file details should be reviewed in PICINFO application. See the
PICINFO/CHIPDATA tab for RAM and MaxAddress etc.

A simple calculation is MaxAddress - RAM +1 = the 'first memory
address'. And, 'first memory address' + RAM -1 = 'the last memory
address.

This can be confirmed by review the DAT file. See the section
\[FreeRAM\] for the start and end of RAM.

The dat file also has a \[NoBankRAM\]. NoBankRAM is somewhat misnamed -
it is used for the defintion of (any) access bank locations.   If a
memory location is defined in both NoBankRAM and FreeRAM, then the
compiler knows that it is access bank RAM.  If an SFR location is in one
of the NoBankRAM ranges, then the compiler knows not to do any bank
selection when accessing that register.

The \[NoBankRAM\] section includes two ranges, one for access bank RAM,
one for access bank SFRs. The first range MUST be the ACCESS RAM range
The first range is the FAST SFR range

If there are no ranges defined in NoBankRAM, the compiler will try to
guess them.   On 18Fs, it will guess based on where the lowest SFR is,
and from what the total RAM on the chip is.   If there’s only one range
defined.    in the NoBankRAM locations, the compiler will assume that is
the range for the RAM, and then will guess where the range for the
access bank SFRs is.

``` screen
    'GCBASIC/GCGB Chip Data File
    'Chip: 18F27Q43

    [ChipData]

    .... many other data rows

    'This constant is exposed as ChipRAM
    RAM=8192             'Dec values

    .... many other data rows

    'This constant is exposed as ChipMaxAddress
    MaxAddress=9471      'Dec values

    .... many other data rows

    [FreeRAM]
    500:24FF             'Hex value

    [NoBankRAM]
    500:55F              'Hex value
    460:4FF              'Hex value

    .... many other data rows
```

  

In the example shown above the following can be extracted.  

<div class="orderedlist">

1.  RAM size: RAM = 8192d
2.  Minimum RAM address: FREERAM = 0x500
3.  Maximum RAM address: FREERAM = 0x24FF
4.  Maximum RAM address: MAXADDRESS=9471d or 0x24FF
5.  ACCESS RAM: NOBANKRAM = 0x500-0x55F
6.  BANKED SFR: NOBANKRAM = 0x460-0x4FF

</div>

  
  

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Variable Types</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_microcontroller_fundamentals.html" title="Microcontroller Fundamentals"><link rel="prev" href="_data_types.html" title="Data Types"><link rel="next" href="_variable_advanced_types.html" title="Variable Advanced Types"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_variable_types"></a>Variable Types</h3></div></div></div><p><span class="strong"><strong>About Variables and Variable Types</strong></span></p><p>A variable is an area of memory on the microcontroller that can be used
to store a number or a series of letters. This is useful for many
purposes, such as taking a sensor reading and acting on it, or counting
the number of times the microcontroller has performed a particular task.</p><p>Each variable must be given a name, such as "MyVariable" or
"PieCounter". Choosing a name for a variable is easy - just don&#8217;t
include spaces or any symbols (other than _), and make sure that the
name is at least 2 characters (letters and/or numbers) long.</p><p><span class="strong"><strong>Variable Types</strong></span></p><p>There are several different types of variable, and each type can store a
different sort of information. These are the variable types that GCBASIC can currently use:</p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Variable type</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Information that this variable can store</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Example uses for this type of variable</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>Bit</p></td><td align="left" valign="top"><p>A bit (0 or 1)</p></td><td align="left" valign="top"><p>Flags to track whether or not a piece of code has run</p></td></tr><tr><td align="left" valign="top"><p>Byte</p></td><td align="left" valign="top"><p>A whole number between 0 and 255</p></td><td align="left" valign="top"><p>General purpose storage of data, such as counters</p></td></tr><tr><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>A whole number between 0 and 65535</p></td><td align="left" valign="top"><p>Storage of extra large numbers</p></td></tr><tr><td align="left" valign="top"><p>Integer</p></td><td align="left" valign="top"><p>A whole number between -32768 and 32767</p></td><td align="left" valign="top"><p>Anything where a negative number will occur</p></td></tr><tr><td align="left" valign="top"><p>Long</p></td><td align="left" valign="top"><p>A whole number between 0 and 2<sup>32</sup> (4.29 billion)</p></td><td align="left" valign="top"><p>Storing very, very big numbers</p></td></tr><tr><td align="left" valign="top"><p>Array</p></td><td align="left" valign="top"><p>A list of whole numbers, each of which may be a byte, word, integer, or long</p></td><td align="left" valign="top"><p>Logs of sensor readings</p></td></tr><tr><td align="left" valign="top"><p>String</p></td><td align="left" valign="top"><p>A series of letters, numbers and symbols.</p></td><td align="left" valign="top"><p>Messages that are to be shown on a screen</p></td></tr></tbody></table></div><p><span class="strong"><strong>Using Variables</strong></span></p><p>Byte variables do not need any special commands to set them up - just
put the name of the variable in to the command where the variable is
needed.</p><p>Other types of variable can be used in a very similar way, except that
they must be "dimensioned" first. This involves using the DIM command,
to tell GCBASIC that it is dealing with something other than a
byte variable.</p><p>A key feature of variables is that it is possible the have the
microcontroller check a variable, and only run a section of code if it
is a given value. This can be done with the IF command.</p><p><span class="strong"><strong>Number Variables</strong></span></p><p>You can assign values to number variables using&nbsp;&amp;#160`=`.&nbsp;&nbsp;</p><p>A simple, but typical example follows.&nbsp;&nbsp;This is the typical for numeric variable assignment.</p><pre class="screen">    myByteVarible = 127       'assign the value of 127</pre><p>GCBASIC support bitwise assignments s follows:</p><pre class="screen">    portc.0 = !porta.1  'set a single bit to the value of another bit</pre><p>The function <code class="literal">FnLSL</code> performs the shift operation found in other languages.  Here is an example:</p><pre class="screen">    MyVar = FnLSL( 1, BitNum)`  is Equivalent to `MyVar = 1&lt;&lt;BitNum`</pre><p>To set a bit of a port and to prevent glitches during operations, use <code class="literal">#option volatile</code> as folllows:</p><pre class="screen">    'add this option for a specific port.
    #option volatile portc.0

    'then in your code
    portc.0 = !porta.1</pre><p>To set a bit of a port or variable, encapsulate it in the <code class="literal">SetWith</code> method.  Using this method also eliminates any glitches during the update.</p><pre class="screen">    SetWith(MyPORT, MyPORT OR FnLSL( 1, BitNum))</pre><p>To clear a bit of a port, use this method:</p><pre class="screen">    MyPORT = MyPORT AND NOT FnLSL( 1, BitNum))</pre><p>To set a bit within an array, use this method:</p><pre class="screen">    video_buffer_A1(video_adress) = video_buffer_A1(video_adress) OR FnLSL( 1, BitNum)</pre><p>To set a bit within a variable, use this method:</p><pre class="screen">    Dim my_variable as byte
    Dim my_bit_address_variable as byte

    'example
    my_variable = 0
    my_bit_address_variable = 7

    my_variable.my_bit_address_variable = 1   ' where 1 or 0 or any bit address is valid

    'Sets bit 7 of my_variable therefore 128</pre><p><span class="strong"><strong>String Variables</strong></span></p><p>Strings are defined as follows:</p><pre class="screen">    'Create buffer variables to store received messages

    Dim Buffer As String</pre><p>String variables default to the following rules and the RAM constraints
of a specific chip.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">10 bytes for chips with less than 16 bytes of RAM.</li><li class="listitem">20 bytes for chips with 16 to 367 bytes of RAM.</li><li class="listitem">40 bytes for devices with more RAM than 367 bytes.</li><li class="listitem">For chips that have less RAM then the required RAM to support the user define strings the strings (and therefore the RAM) will be NOT be allocated. Please reduce string size.</li></ul></div><p>You cannot store a string 20 characters long in a chip with 16 bytes of RAM.</p><p>You can change the default string size handled internally by the GCBASIC compiler by changing the <code class="literal">STRINGSIZE</code> constant:</p><pre class="screen">    'set the default string to 24 bytes
    #define STRINGSIZE 24</pre><p>Defining a length for the string is the best way to limit memory usage.  It is good practice if you need a string of a certain size to set the length of a strings, since the default length for a string variable changes depending on the amount of memory in the microcontroller (see
above).</p><p>To set the length of a string, see the example below:</p><pre class="screen">    'Create buffer variables to store received messages as 16 bytes long
    Dim OutBuffer As String * 16</pre><p>To place quotation marks (" ") in a string of text. For example:</p><pre class="screen">    She said, "You deserve a treat!"</pre><p>To place quotation marks (") in a string of text, use two quotation marks in a row instead of one for each quote mark.  The following example shows two ways of printing <code class="literal">She said, "You deserve a treat!"</code>.  This technique works for all output methods (HSerPrint, Print, etc.)</p><pre class="screen">    HSerPrint "She said, ""You deserve a treat!"" "

    Dim myString As String * 39
    myString = "She said, ""You deserve another treat!"" "
    HSerPrint myString</pre><p><span class="strong"><strong>Variable Aliases</strong></span></p><p>Some variables are aliases, which are used to refer to memory locations used by other variables. These are useful for joining predefined byte variables together to form a word variable.</p><p>Aliases are not like pointers in many languages - they must always refer to the same variable or variables and cannot be changed.</p><p>When setting a register/variable bit ( i.e  my_variable.my_bit_address_variable ) and using a alias for the variable then you must ensure the bytes that construct the variable are consective.</p><p>The coding approach should be to DIMension the variable (word, integer, or long) first, then create the byte aliases:</p><pre class="screen">    Dim my_variable as LONG
    Dim ByteOne   as Byte alias my_variable_E
    Dim ByteTwo   as Byte alias my_variable_U
    Dim ByteThree as Byte alias my_variable_H
    Dim ByteFour  as Byte alias my_variable

    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    'then, use the four byte variables as you need to.</pre><p>To set a series of registers that are not consecutive, it is recommended to use a mask variable then apply it to the registers:</p><pre class="screen">    Dim my_variable as LONG
    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    porta =  my_variable_E
    portb =  my_variable_E
    portc =  my_variable_E
    portd =  my_variable_E</pre><p><span class="strong"><strong>Casting</strong></span></p><p>Casting changes the type of a variable or value.  To tell the compiler to perform a type conversion, put the desired type in square brackets before the variable.  The following example will cause two byte variables added together to be treated as a word variable.</p><pre class="screen">    Dim MyWord As Word
    MyWord = [word]ByteVar + AnotherByteVar</pre><p>Why do this?   Suppose that <code class="literal">ByteVar</code> is 150, and <code class="literal">AnotherByteVar</code> is 231.  When added, this will come to 381 - which will overflow, leaving 125 in the result.  However, when the cast is added, GCBASIC will treat <code class="literal">ByteVar</code> as if it were a word, and so will use the word addition code.  This will cause the correct result to be calculated.</p><p>It is good practice to cast when calculating an average:</p><pre class="screen">    MyAverage = ([word]Value1 + Value2) / 2</pre><p>It&#8217;s also possible to cast the second value instead of the first:</p><pre class="screen">    MyAverage = (Value1 + [word]Value2) / 2</pre><p>The result will be exactly the same.</p><p><br>
To apply operations to individual bits of variables see, <a class="link" href="_set.html" title="Set">Set</a>, <a class="link" href="_rotate.html" title="Rotate">Rotate</a>
<br>
<br></p><p>To check variables and apply logic based on their value, see
<a class="link" href="_if.html" title="If">If</a>, <a class="link" href="_do.html" title="Do">Do</a>, <a class="link" href="_for.html" title="For">For</a>, <a class="link" href="_conditions.html" title="Conditions">Conditions</a>
<br></p><p><span class="strong"><strong>For more help, see:</strong></span> <a class="link" href="_dim.html" title="Dim">Declaring variables with DIM</a>, <a class="link" href="_setting_variables.html" title="Setting Variables">Setting Variables</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="variable_types"></span>Variable Types

</div>

</div>

</div>

<span class="strong">**About Variables and Variable Types**</span>

A variable is an area of memory on the microcontroller that can be used
to store a number or a series of letters. This is useful for many
purposes, such as taking a sensor reading and acting on it, or counting
the number of times the microcontroller has performed a particular task.

Each variable must be given a name, such as "MyVariable" or
"PieCounter". Choosing a name for a variable is easy - just don’t
include spaces or any symbols (other than \_), and make sure that the
name is at least 2 characters (letters and/or numbers) long.

<span class="strong">**Variable Types**</span>

There are several different types of variable, and each type can store a
different sort of information. These are the variable types that GCBASIC
can currently use:

<div class="informaltable">

| <span class="strong">**Variable type**</span> | <span class="strong">**Information that this variable can store**</span>     | <span class="strong">**Example uses for this type of variable**</span> |
|:----------------------------------------------|:-----------------------------------------------------------------------------|:-----------------------------------------------------------------------|
| Bit                                           | A bit (0 or 1)                                                               | Flags to track whether or not a piece of code has run                  |
| Byte                                          | A whole number between 0 and 255                                             | General purpose storage of data, such as counters                      |
| Word                                          | A whole number between 0 and 65535                                           | Storage of extra large numbers                                         |
| Integer                                       | A whole number between -32768 and 32767                                      | Anything where a negative number will occur                            |
| Long                                          | A whole number between 0 and 2<sup>32</sup> (4.29 billion)                   | Storing very, very big numbers                                         |
| Array                                         | A list of whole numbers, each of which may be a byte, word, integer, or long | Logs of sensor readings                                                |
| String                                        | A series of letters, numbers and symbols.                                    | Messages that are to be shown on a screen                              |

</div>

<span class="strong">**Using Variables**</span>

Byte variables do not need any special commands to set them up - just
put the name of the variable in to the command where the variable is
needed.

Other types of variable can be used in a very similar way, except that
they must be "dimensioned" first. This involves using the DIM command,
to tell GCBASIC that it is dealing with something other than a byte
variable.

A key feature of variables is that it is possible the have the
microcontroller check a variable, and only run a section of code if it
is a given value. This can be done with the IF command.

<span class="strong">**Number Variables**</span>

You can assign values to number variables using &\#160\`=\`.  

A simple, but typical example follows.  This is the typical for numeric
variable assignment.

``` screen
    myByteVarible = 127       'assign the value of 127
```

GCBASIC support bitwise assignments s follows:

``` screen
    portc.0 = !porta.1  'set a single bit to the value of another bit
```

The function `FnLSL` performs the shift operation found in other
languages. Here is an example:

``` screen
    MyVar = FnLSL( 1, BitNum)`  is Equivalent to `MyVar = 1<<BitNum`
```

To set a bit of a port and to prevent glitches during operations, use
`#option volatile` as folllows:

``` screen
    'add this option for a specific port.
    #option volatile portc.0

    'then in your code
    portc.0 = !porta.1
```

To set a bit of a port or variable, encapsulate it in the `SetWith`
method. Using this method also eliminates any glitches during the
update.

``` screen
    SetWith(MyPORT, MyPORT OR FnLSL( 1, BitNum))
```

To clear a bit of a port, use this method:

``` screen
    MyPORT = MyPORT AND NOT FnLSL( 1, BitNum))
```

To set a bit within an array, use this method:

``` screen
    video_buffer_A1(video_adress) = video_buffer_A1(video_adress) OR FnLSL( 1, BitNum)
```

To set a bit within a variable, use this method:

``` screen
    Dim my_variable as byte
    Dim my_bit_address_variable as byte

    'example
    my_variable = 0
    my_bit_address_variable = 7

    my_variable.my_bit_address_variable = 1   ' where 1 or 0 or any bit address is valid

    'Sets bit 7 of my_variable therefore 128
```

<span class="strong">**String Variables**</span>

Strings are defined as follows:

``` screen
    'Create buffer variables to store received messages

    Dim Buffer As String
```

String variables default to the following rules and the RAM constraints
of a specific chip.

<div class="itemizedlist">

-   10 bytes for chips with less than 16 bytes of RAM.
-   20 bytes for chips with 16 to 367 bytes of RAM.
-   40 bytes for devices with more RAM than 367 bytes.
-   For chips that have less RAM then the required RAM to support the
    user define strings the strings (and therefore the RAM) will be NOT
    be allocated. Please reduce string size.

</div>

You cannot store a string 20 characters long in a chip with 16 bytes of
RAM.

You can change the default string size handled internally by the GCBASIC
compiler by changing the `STRINGSIZE` constant:

``` screen
    'set the default string to 24 bytes
    #define STRINGSIZE 24
```

Defining a length for the string is the best way to limit memory usage.
It is good practice if you need a string of a certain size to set the
length of a strings, since the default length for a string variable
changes depending on the amount of memory in the microcontroller (see
above).

To set the length of a string, see the example below:

``` screen
    'Create buffer variables to store received messages as 16 bytes long
    Dim OutBuffer As String * 16
```

To place quotation marks (" ") in a string of text. For example:

``` screen
    She said, "You deserve a treat!"
```

To place quotation marks (") in a string of text, use two quotation
marks in a row instead of one for each quote mark. The following example
shows two ways of printing `She said, "You deserve a treat!"`. This
technique works for all output methods (HSerPrint, Print, etc.)

``` screen
    HSerPrint "She said, ""You deserve a treat!"" "

    Dim myString As String * 39
    myString = "She said, ""You deserve another treat!"" "
    HSerPrint myString
```

<span class="strong">**Variable Aliases**</span>

Some variables are aliases, which are used to refer to memory locations
used by other variables. These are useful for joining predefined byte
variables together to form a word variable.

Aliases are not like pointers in many languages - they must always refer
to the same variable or variables and cannot be changed.

When setting a register/variable bit ( i.e
my\_variable.my\_bit\_address\_variable ) and using a alias for the
variable then you must ensure the bytes that construct the variable are
consective.

The coding approach should be to DIMension the variable (word, integer,
or long) first, then create the byte aliases:

``` screen
    Dim my_variable as LONG
    Dim ByteOne   as Byte alias my_variable_E
    Dim ByteTwo   as Byte alias my_variable_U
    Dim ByteThree as Byte alias my_variable_H
    Dim ByteFour  as Byte alias my_variable

    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    'then, use the four byte variables as you need to.
```

To set a series of registers that are not consecutive, it is recommended
to use a mask variable then apply it to the registers:

``` screen
    Dim my_variable as LONG
    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    porta =  my_variable_E
    portb =  my_variable_E
    portc =  my_variable_E
    portd =  my_variable_E
```

<span class="strong">**Casting**</span>

Casting changes the type of a variable or value. To tell the compiler to
perform a type conversion, put the desired type in square brackets
before the variable. The following example will cause two byte variables
added together to be treated as a word variable.

``` screen
    Dim MyWord As Word
    MyWord = [word]ByteVar + AnotherByteVar
```

Why do this? Suppose that `ByteVar` is 150, and `AnotherByteVar` is 231.
When added, this will come to 381 - which will overflow, leaving 125 in
the result. However, when the cast is added, GCBASIC will treat
`ByteVar` as if it were a word, and so will use the word addition code.
This will cause the correct result to be calculated.

It is good practice to cast when calculating an average:

``` screen
    MyAverage = ([word]Value1 + Value2) / 2
```

It’s also possible to cast the second value instead of the first:

``` screen
    MyAverage = (Value1 + [word]Value2) / 2
```

The result will be exactly the same.

  
To apply operations to individual bits of variables see,
<a href="set" class="link" title="Set">Set</a>,
<a href="rotate" class="link" title="Rotate">Rotate</a>  
  

To check variables and apply logic based on their value, see
<a href="if" class="link" title="If">If</a>,
<a href="do" class="link" title="Do">Do</a>,
<a href="for" class="link" title="For">For</a>,
<a href="conditions" class="link" title="Conditions">Conditions</a>  

<span class="strong">**For more help, see:**</span>
<a href="dim" class="link" title="Dim">Declaring variables with DIM</a>,
<a href="setting_variables" class="link" title="Setting Variables">Setting Variables</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Wait</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_flow_control.html" title="Flow control"><link rel="prev" href="_select.html" title="Select"><link rel="next" href="_fixed_voltage_reference.html" title="Fixed Voltage Reference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_wait"></a>Wait</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><p><span class="strong"><strong><span class="emphasis"><em>Fixed Length Delay:</em></span></strong></span></p><pre class="screen">    Wait time units</pre><p><span class="strong"><strong><span class="emphasis"><em>Conditional Delay:</em></span></strong></span></p><pre class="screen">    Wait {While | Until} condition</pre><p><span class="strong"><strong><span class="emphasis"><em>Using a variable to specific US Delay with Warning supression:</em></span></strong></span></p><pre class="screen">    Wait timevalue US #OVERRIDEWARNING</pre><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers.</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">Wait</code> command will cause the program to wait for either a specified
amount of time (such as 1 second), or while/until a condition is true.</p><p>When using the fixed-length delay, there is a variety of units that are
available:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Unit</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Length of unit</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Delay range</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>us</p></td><td align="left" valign="top"><p>1 microsecond</p></td><td align="left" valign="top"><p>1 us - 65535 us</p></td></tr><tr><td align="left" valign="top"><p>10us</p></td><td align="left" valign="top"><p>10 microseconds</p></td><td align="left" valign="top"><p>10 us - 2.55 ms</p></td></tr><tr><td align="left" valign="top"><p>ms</p></td><td align="left" valign="top"><p>1 millisecond</p></td><td align="left" valign="top"><p>1 ms - 65535 ms</p></td></tr><tr><td align="left" valign="top"><p>10ms</p></td><td align="left" valign="top"><p>10 milliseconds</p></td><td align="left" valign="top"><p>10 ms - 2.55 s</p></td></tr><tr><td align="left" valign="top"><p>s</p></td><td align="left" valign="top"><p>1 second</p></td><td align="left" valign="top"><p>1 s - 255 s</p></td></tr><tr><td align="left" valign="top"><p>m</p></td><td align="left" valign="top"><p>1 minute</p></td><td align="left" valign="top"><p>1 min - 255 min</p></td></tr><tr><td align="left" valign="top"><p>h</p></td><td align="left" valign="top"><p>1 hour</p></td><td align="left" valign="top"><p>1 hour - 255 hours</p></td></tr></tbody></table></div><p>At one stage, GCBASIC variables could not hold more than 255. The <code class="literal">10us</code>
and <code class="literal">10ms</code> units were added as a way to work around this limit. There is
now no such limit (<code class="literal">Wait 1000 ms</code> will work for example), so these are not
really needed. However, you may see them in some older examples or
programs, and the <code class="literal">10us</code> units are sometimes the shortest delay that will
work accurately.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p><span class="strong"><strong>PIC Devices Only</strong></span><br>
MS Delays at Clock frequency&#8217;s below 28kHz are not supported and will silently fail.<br>
US Delays at Clock frequency&#8217;s below 250kHz are not supported and will silently fail.<br>
US Delays at lower Clock frequency&#8217;s is accurate ONLY when nn is divisible by 4. This is caused by the minimum ASM delay loop being a specific number of instructions.<br>
US Delays at lower Clock frequency&#8217; when not divisible by 4 will silently accept the nn value and incorrect delays will be produced. + Use <code class="literal">#OVERRIDEWARNING</code> to supress warnings.
Delays at Clock frequency&#8217;s below 500kHz may be impacted by previous instructions; testing of actual delays is advised.<br></p></div><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This code will wait until a button is pressed, then it will flash
    'a light every half a second and produce a 440 Hz tone.

    #chip 16F819, 8

    #define BUTTON PORTB.0
    #define SPEAKER PORTB.1
    #define LIGHT PORTB.2
    Dir BUTTON In
    Dir SPEAKER Out
    Dir LIGHT Out

    'Assumes Button switches on when pressed
    Wait Until BUTTON = 1
    Wait Until BUTTON = 0

    Do
      'Flash the light
      Set LIGHT On
      Wait 500 ms
      Set LIGHT Off

      'Produce the tone
      '440 Hz = 880 changes = tone on for 1.14 ms
      Repeat 440
        PulseOut SPEAKER, 1140 us
        Wait 114 10us 'Wait for 114 x 10 us (1.14 ms)
      End Repeat
    Loop</pre><p>To suppress warnings when using US.</p><pre class="screen">    dim timevariable as Word
    timevariable = 100 // 100 is an example value that assigns the variable.

    // Use #OVERRIDEWARNING to prevent warning messages
    wait timevariable US #OVERRIDEWARNING</pre><p><span class="strong"><strong>For more help, see <a class="link" href="_conditions.html" title="Conditions">Conditions</a></strong></span></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="wait"></span>Wait

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

<span class="strong">**<span class="emphasis">*Fixed Length
Delay:*</span>**</span>

``` screen
    Wait time units
```

<span class="strong">**<span class="emphasis">*Conditional
Delay:*</span>**</span>

``` screen
    Wait {While | Until} condition
```

<span class="strong">**<span class="emphasis">*Using a variable to
specific US Delay with Warning supression:*</span>**</span>

``` screen
    Wait timevalue US #OVERRIDEWARNING
```

<span class="strong">**Command Availability:**</span>

Available on all microcontrollers.

<span class="strong">**Explanation:**</span>

The `Wait` command will cause the program to wait for either a specified
amount of time (such as 1 second), or while/until a condition is true.

When using the fixed-length delay, there is a variety of units that are
available:

<div class="informaltable">

| <span class="strong">**Unit**</span> | <span class="strong">**Length of unit**</span> | <span class="strong">**Delay range**</span> |
|:-------------------------------------|:-----------------------------------------------|:--------------------------------------------|
| us                                   | 1 microsecond                                  | 1 us - 65535 us                             |
| 10us                                 | 10 microseconds                                | 10 us - 2.55 ms                             |
| ms                                   | 1 millisecond                                  | 1 ms - 65535 ms                             |
| 10ms                                 | 10 milliseconds                                | 10 ms - 2.55 s                              |
| s                                    | 1 second                                       | 1 s - 255 s                                 |
| m                                    | 1 minute                                       | 1 min - 255 min                             |
| h                                    | 1 hour                                         | 1 hour - 255 hours                          |

</div>

At one stage, GCBASIC variables could not hold more than 255. The `10us`
and `10ms` units were added as a way to work around this limit. There is
now no such limit (`Wait 1000 ms` will work for example), so these are
not really needed. However, you may see them in some older examples or
programs, and the `10us` units are sometimes the shortest delay that
will work accurately.

<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

### Warning

<span class="strong">**PIC Devices Only**</span>  
MS Delays at Clock frequency’s below 28kHz are not supported and will
silently fail.  
US Delays at Clock frequency’s below 250kHz are not supported and will
silently fail.  
US Delays at lower Clock frequency’s is accurate ONLY when nn is
divisible by 4. This is caused by the minimum ASM delay loop being a
specific number of instructions.  
US Delays at lower Clock frequency’ when not divisible by 4 will
silently accept the nn value and incorrect delays will be produced. +
Use `#OVERRIDEWARNING` to supress warnings. Delays at Clock frequency’s
below 500kHz may be impacted by previous instructions; testing of actual
delays is advised.  

</div>

<span class="strong">**Example:**</span>

``` screen
    'This code will wait until a button is pressed, then it will flash
    'a light every half a second and produce a 440 Hz tone.

    #chip 16F819, 8

    #define BUTTON PORTB.0
    #define SPEAKER PORTB.1
    #define LIGHT PORTB.2
    Dir BUTTON In
    Dir SPEAKER Out
    Dir LIGHT Out

    'Assumes Button switches on when pressed
    Wait Until BUTTON = 1
    Wait Until BUTTON = 0

    Do
      'Flash the light
      Set LIGHT On
      Wait 500 ms
      Set LIGHT Off

      'Produce the tone
      '440 Hz = 880 changes = tone on for 1.14 ms
      Repeat 440
        PulseOut SPEAKER, 1140 us
        Wait 114 10us 'Wait for 114 x 10 us (1.14 ms)
      End Repeat
    Loop
```

To suppress warnings when using US.

``` screen
    dim timevariable as Word
    timevariable = 100 // 100 is an example value that assigns the variable.

    // Use #OVERRIDEWARNING to prevent warning messages
    wait timevariable US #OVERRIDEWARNING
```

<span class="strong">**For more help, see
<a href="conditions" class="link" title="Conditions">Conditions</a>**</span>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Weak Pullups</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_miscellaneous_commands.html" title="Miscellaneous Commands"><link rel="prev" href="_poke.html" title="Poke"><link rel="next" href="_maths.html" title="Maths"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_weak_pullups"></a>Weak Pullups</h4></div></div></div><p><code class="literal">Weak pullups</code> provide a method within many microcontrollers such as the Atmel AVR and Microchip PIC microcontrollers to support internal/selectable pull-ups for convenience and reduced parts count.</p><p>If you require <code class="literal">Weak pullups</code> these internal pullups can provide a simple solution. For example, you can use them to ground input pins with a switch closure - with the pullup enabled, the pin is held in a high state until the input line pulls it to ground. Be aware of possible EMI interference and also make sure to use a debounce routine.</p><p>If you need your weak pullups to exactly control current (rare for most microcontroller applications), then you should consider 10k resistors (5V/10K = 500uA)  Why? If you review in the microcontroller data sheet, there is no resistance given for the weak pullups. That is because they are not weak pull-resistors they are weak pullups consisting of what appear to be high-resistance channel pFETs.  Their channel resistance will vary with temperature and between parts; not easy to characterize.</p><p>The data sheet gives a current range for the internals as 50-400uA (at 5V).</p><p>PORTs can have an individually controlled weak internal pullup. When set, each bit of the appropriate Microchip PIC register enables the corresponding pin pullup. There is a master bit within a specific register bit that enables pullups on all pins which also have their corresponding weak pull bit set.   Also when set, there is a weak pull register bit to disable all weak pullups.</p><p>The weak pullup is automatically turned off when the port pin is configured as an output.  The pullups are disabled on a Power-on Reset.</p><p>Each specific microcontroller has different registers/bits for this functionality.</p><p>You should review the datasheet for the method for a specific microcontroller.</p><p>The following code demonstrates how to set the weak pullups available on port B of an 18F25K20.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'A program to show the use of weak pullups on portb.
    'Set chip model
    #chip 18F25k20,16 'at 16 MHz
    #config MCLR = Off

    Set RBPU = 0 'enabling Port B pullups in general.
    SET WPUB1 = 1 'portb.1 pulled up
    Set WPUB2 = 1 'portb.2
    Set WPUB3 = 1 'portb.3
    Set WPUB4 = 1 'portb.4

    Dir Portb in
    Dir Portc out

    do
        portc.1 = portb.1 'in pin 22, out pin 12
        portc.2 = portb.2 'in pin 23, out pin 13
        portc.3 = portb.3 'in pin 24, out pin 14
        portc.4 = portb.4 'in pin 25, out pin 15

    loop 'jump back to the start of the program

    'main line ends here
    end</pre><p>Also, see I2C Slave Hardware for an example using a 16F microcontroller.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="weak_pullups"></span>Weak Pullups

</div>

</div>

</div>

`Weak pullups` provide a method within many microcontrollers such as the
Atmel AVR and Microchip PIC microcontrollers to support
internal/selectable pull-ups for convenience and reduced parts count.

If you require `Weak pullups` these internal pullups can provide a
simple solution. For example, you can use them to ground input pins with
a switch closure - with the pullup enabled, the pin is held in a high
state until the input line pulls it to ground. Be aware of possible EMI
interference and also make sure to use a debounce routine.

If you need your weak pullups to exactly control current (rare for most
microcontroller applications), then you should consider 10k resistors
(5V/10K = 500uA) Why? If you review in the microcontroller data sheet,
there is no resistance given for the weak pullups. That is because they
are not weak pull-resistors they are weak pullups consisting of what
appear to be high-resistance channel pFETs. Their channel resistance
will vary with temperature and between parts; not easy to characterize.

The data sheet gives a current range for the internals as 50-400uA (at
5V).

PORTs can have an individually controlled weak internal pullup. When
set, each bit of the appropriate Microchip PIC register enables the
corresponding pin pullup. There is a master bit within a specific
register bit that enables pullups on all pins which also have their
corresponding weak pull bit set. Also when set, there is a weak pull
register bit to disable all weak pullups.

The weak pullup is automatically turned off when the port pin is
configured as an output. The pullups are disabled on a Power-on Reset.

Each specific microcontroller has different registers/bits for this
functionality.

You should review the datasheet for the method for a specific
microcontroller.

The following code demonstrates how to set the weak pullups available on
port B of an 18F25K20.

<span class="strong">**Example:**</span>

``` screen
    'A program to show the use of weak pullups on portb.
    'Set chip model
    #chip 18F25k20,16 'at 16 MHz
    #config MCLR = Off

    Set RBPU = 0 'enabling Port B pullups in general.
    SET WPUB1 = 1 'portb.1 pulled up
    Set WPUB2 = 1 'portb.2
    Set WPUB3 = 1 'portb.3
    Set WPUB4 = 1 'portb.4

    Dir Portb in
    Dir Portc out

    do
        portc.1 = portb.1 'in pin 22, out pin 12
        portc.2 = portb.2 'in pin 23, out pin 13
        portc.3 = portb.3 'in pin 24, out pin 14
        portc.4 = portb.4 'in pin 25, out pin 15

    loop 'jump back to the start of the program

    'main line ends here
    end
```

Also, see I2C Slave Hardware for an example using a 16F microcontroller.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Windows .NET Support</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_graphical_gcbasic.html" title="Graphical GCBASIC"><link rel="prev" href="_code_documentation.html" title="Code Documentation"><link rel="next" href="_gcbasic_for_linux.html" title="GCBASIC for Linux"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_windows_net_support"></a>Windows .NET Support</h3></div></div></div><p>From Graphical GCBASIC version 0.941 supports use on newer Windows versions without having the pre-requisite of .NET 3.5.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="windows_net_support"></span>Windows .NET Support

</div>

</div>

</div>

From Graphical GCBASIC version 0.941 supports use on newer Windows
versions without having the pre-requisite of .NET 3.5.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>WordToBin</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_string_manipulation.html" title="String Manipulation"><link rel="prev" href="_longtobin.html" title="LongToBin"><link rel="next" href="_concatenation.html" title="Concatenation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_wordtobin"></a>WordToBin</h4></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">  <span class="emphasis"><em>stringvar</em></span> = WordToBin(<span class="emphasis"><em>bytevar</em></span>)</pre><p><span class="strong"><strong>Command Availability:</strong></span>
Available on all microcontrollers</p><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">WordToBin</code> function creates a string of a ANSI (8-byte) characters.
The function converts a number to a string consisting of ones and zeros that represents the binary value.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    <span class="emphasis"><em>string</em></span> = WordToBin(1)       ' Returns "0000000000000001"

    <span class="emphasis"><em>string</em></span> = WordToBin(37654)   ' Returns "1001001100010110"</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_bytetobin.html" title="ByteToBin">ByteToBin</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

#### <span id="wordtobin"></span>WordToBin

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
  stringvar = WordToBin(bytevar)
```

<span class="strong">**Command Availability:**</span> Available on all
microcontrollers

<span class="strong">**Explanation:**</span>

The `WordToBin` function creates a string of a ANSI (8-byte) characters.
The function converts a number to a string consisting of ones and zeros
that represents the binary value.

<span class="strong">**Example:**</span>

``` screen
    string = WordToBin(1)       ' Returns "0000000000000001"

    string = WordToBin(37654)   ' Returns "1001001100010110"
```

<span class="strong">**For more help, see**</span>
<a href="bytetobin" class="link" title="ByteToBin">ByteToBin</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#asmraw</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="_compiler_directives.html" title="Compiler Directives"><link rel="next" href="__chip.html" title="#chip"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__asmraw"></a>#asmraw</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #asmraw [label]
    #asmraw [Mnemonics | Directives | Macros] [Operands] ['comments]</pre><p>for ASM blocks use</p><pre class="screen">    #asmraw[
        [label]
        [Mnemonics | Directives | Macros] [Operands] ['comments]
    #asmraw]</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">#asmraw</code> directive is used to specify the assembly that GCBASIC will use.&nbsp;&nbsp;&nbsp;</p><p>Anything following this directive will be inserted into ASM source file with no changes other than trimming spaces - no replacement of constants.&nbsp;&nbsp;&nbsp;</p><p><br>
<br>
Assembly is a programming language you may use to develop the source code for your application.&nbsp;&nbsp;&nbsp;
The directive must conform to the following basic guidelines.&nbsp;&nbsp;&nbsp;
Each line of the source file may contain up to four types of information:&nbsp;&nbsp;&nbsp;</p><p>&#8226; Labels</p><p>&#8226; Mnemonics, Directives and Macros</p><p>&#8226; Operands</p><p>&#8226; Comments</p><p>The order and position of these are important. For ease of debugging, it is recommended that labels start in column one and mnemonics start in column two or
beyond.&nbsp;&nbsp;&nbsp;
Operands follow the mnemonic.&nbsp;&nbsp;&nbsp;</p><p>Comments may follow the operands, mnemonics or labels, and can start in any column. The maximum column width is 255 characters.&nbsp;&nbsp;&nbsp;</p><p>White space or a colon must separate the label and the mnemonic, and white space must separate the mnemonic and the operand(s).&nbsp;&nbsp;&nbsp;
Multiple operands must be separated by commas.&nbsp;&nbsp;&nbsp;</p><p>White space is one or more spaces or tabs. White space is used to separate pieces of a source line.&nbsp;&nbsp;&nbsp;
White space should be used to make your code easier for people to read.&nbsp;&nbsp;&nbsp;</p><p><br>
<span class="strong"><strong>Example 1</strong></span></p><pre class="screen">        #asmraw lds SysValueCopy,TCCR0B
        #asmraw andi SysValueCopy, 0xf8
        #asmraw inc SysValueCopy
        #asmraw sts TCCR0B, SysValueCopy</pre><p><span class="strong"><strong>Example 2</strong></span></p><pre class="screen">        #asmraw[
            lds SysValueCopy,TCCR0B
            andi SysValueCopy, 0xf8
            inc SysValueCopy
            sts TCCR0B, SysValueCopy
        #asmraw]</pre><p><br>
This example will generate the following in the ASM source file.</p><pre class="screen">        lds SysValueCopy,TCCR0B
        andi  SysValueCopy, 0xf8
        inc SysValueCopy
        sts TCCR0B, SysValueCopy</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_asmraw"></span>\#asmraw

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #asmraw [label]
    #asmraw [Mnemonics | Directives | Macros] [Operands] ['comments]
```

for ASM blocks use

``` screen
    #asmraw[
        [label]
        [Mnemonics | Directives | Macros] [Operands] ['comments]
    #asmraw]
```

<span class="strong">**Explanation:**</span>

The `#asmraw` directive is used to specify the assembly that GCBASIC
will use.   

Anything following this directive will be inserted into ASM source file
with no changes other than trimming spaces - no replacement of
constants.   

  
  
Assembly is a programming language you may use to develop the source
code for your application.    The directive must conform to the
following basic guidelines.    Each line of the source file may contain
up to four types of information:   

• Labels

• Mnemonics, Directives and Macros

• Operands

• Comments

The order and position of these are important. For ease of debugging, it
is recommended that labels start in column one and mnemonics start in
column two or beyond.    Operands follow the mnemonic.   

Comments may follow the operands, mnemonics or labels, and can start in
any column. The maximum column width is 255 characters.   

White space or a colon must separate the label and the mnemonic, and
white space must separate the mnemonic and the operand(s).    Multiple
operands must be separated by commas.   

White space is one or more spaces or tabs. White space is used to
separate pieces of a source line.    White space should be used to make
your code easier for people to read.   

  
<span class="strong">**Example 1**</span>

``` screen
        #asmraw lds SysValueCopy,TCCR0B
        #asmraw andi SysValueCopy, 0xf8
        #asmraw inc SysValueCopy
        #asmraw sts TCCR0B, SysValueCopy
```

<span class="strong">**Example 2**</span>

``` screen
        #asmraw[
            lds SysValueCopy,TCCR0B
            andi SysValueCopy, 0xf8
            inc SysValueCopy
            sts TCCR0B, SysValueCopy
        #asmraw]
```

  
This example will generate the following in the ASM source file.

``` screen
        lds SysValueCopy,TCCR0B
        andi  SysValueCopy, 0xf8
        inc SysValueCopy
        sts TCCR0B, SysValueCopy
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#chip</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__asmraw.html" title="#asmraw"><link rel="next" href="__config.html" title="#config"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__chip"></a>#chip</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #chip <span class="emphasis"><em>model</em></span>, <span class="emphasis"><em>frequency</em></span></pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">#chip</code> directive is used to specify the chip model and frequency that GCBASIC will use.</p><p>The <code class="literal"><span class="emphasis"><em>model</em></span></code> is the specific microcontroller  - examples are "16F819".</p><p>The <code class="literal"><span class="emphasis"><em>frequency</em></span></code> is the frequency of the chip in MHz, and is required for the delay and PWM routines.
The following constants simplify setting specific frequencies.
<code class="literal">31k</code>,  <code class="literal">32.768K</code>, <code class="literal">125k</code>, <code class="literal">250k</code> or <code class="literal">500k</code>.  Any of these constant can be used. As shown in the example below.</p><p>If <code class="literal">frequency</code> is not present the compiler will select a frequency default frequency that should work for the microcontroller.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">If the chip has an internal oscillator, the compiler will use that and pick the highest frequency it supports.</li><li class="listitem">If the chip does not have an internal oscillator, then GCBASIC will assume that the chip is being run at its maximum possible clock frequency using an external crystal.</li><li class="listitem">If you are using an external crystal then you must specify a chip frequency.</li></ol></div><p>When using an AVR, there is no need to specify "AT" before the name.</p><p><span class="strong"><strong>Examples:</strong></span></p><pre class="screen">    #chip 12F509, 4
    #chip 18F4550, 48
    #chip 16F88, 0.125
    #chip tiny2313, 1
    #chip mega8, 16
    #chip 12f1840, 31k
    #chip 12f1840, 500k
    #chip 12f1840, 250k
    #chip 12f1840, 125k

    'Select the internal low frequency oscillator. The microcontroller must have a low frequency oscillator option.  The internal oscillator is automatically selected.
    #chip 16f18326, 31k

    'Select the external SOSC clock source.
    #chip 16f18855, 32.768k
    #config osc=SOSC</pre><p><span class="strong"><strong>Setting Other Clock frequencies:</strong></span>
Some alternative compilers allow value of the clock frequency to be set with the numerical value in Hertz (<span class="emphasis"><em>i.e.</em></span> 24576000). This can be useful when using the clock frequencies other than standard frequencies.</p><p>GCBASIC requires clock frequencys to be specified in MHz, but will accept decimal points. For example, if you wanted to run a 16F1827 at 24576000 Hz, you would write the following:</p><pre class="screen">    #chip 16F1827, 24.576</pre><p><span class="strong"><strong>GCBASIC support for microcontrollers:</strong></span></p><p>Each microcontroller has a microcontroller data file.  This file is located in \GCBasic\chipdata\ folder when installed.</p><p>An example is 12F1840.dat</p><p>The there are two sections in the microcontroller data file that control the "chip frequency", they are:</p><pre class="literallayout">*[ChipData]* and *[ConfigOps]*</pre><p><span class="strong"><strong>ChipData section</strong></span></p><p>The ChipData section for 12F1840 microcontroller. The 12F1840 is used an example</p><pre class="screen">    [ChipData]
    Prog=4096
    EEPROM=256
    RAM=256
    I/O=6
    ADC=4
    MaxMHz=32
    IntOsc=32, 16, 8, 4, 2, 1, 0.5, 0.25, 0.125
    31kSupport=INTOSC,OSCCON,2
    Pins=8
    Family=15
    ConfigWords=2
    PSP=0
    MaxAddress=4095</pre><p>The IntOsc line specifies the supported internal clock frequencies -  The 12F1840 microcontroller supports nine internal frequencies (ChipMHz). #Chip is used as follows:
The 31kSupport line specifies the chip supports 31k for internal clock frequency.</p><pre class="screen">    #chip 12F1840, 32</pre><p>A ChipMHz of 32 does two things.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">When using the internal oscillator,  it tells the compiler to set the chip clock frequency (FOSC) to 32MHz</li><li class="listitem">It tells the compiler to calculate all delays (wait times) based upon FOSC of 32 MHz.
Unlike Picaxe Basic (and other compilers) GCBASIC delays ("wait") are correct regardless of the setting of FOSC.
If you set the internal oscillator to 4 MHz a "wait 1 ms" will still be 1 ms.</li></ol></div><p>If you set chipMHz to something other than the valid options in the [ChipData] IntOsc section of the microcontroller specific dat file, then, the compiler assumes that you are using an external oscillator and will calculate the delays according to the value you use. The wait times will be incorrect if you are not using an external oscillator at the same frequency as ChipMhz.</p><pre class="screen">    Example:  #chip 12F1840, 12</pre><p>Since "12" is not a valid internal osc frequency, the microcontroller FOSC will default to 8 MHz because there is no external crystal installed. However, the wait times will be incorrect as they will be calculated by the compiler based upon a 12 Mhz clock.</p><p><span class="strong"><strong>ConfigOps section</strong></span></p><p>The [ConfigOps] section of 12F1840.dat is towards the end of the chip data file. For the 12F1840 is looks like this</p><pre class="screen">    [ConfigOps]
    OSC=LP,XT,HS,EXTRC,INTOSC,ECL,ECM,ECH
    WDTE=OFF,SWDTEN,NSLEEP,ON
    PWRTE=ON,OFF
    MCLRE=OFF,ON
    CP=ON,OFF
    CPD=ON,OFF
    BOREN=OFF,SBODEN,NSLEEP,ON
    CLKOUTEN=ON,OFF
    IESO=OFF,ON
    FCMEN=OFF,ON
    WRT=ALL,HALF,BOOT,OFF
    PLLEN=OFF,ON
    STVREN=OFF,ON
    BORV=HI,LO,19
    LVP=OFF,ON</pre><p><code class="literal">OSC</code> specifies which oscillator options are available for the specific microcontroller.
<code class="literal">INTOSC</code> is the internal oscillator. All others are some form of external clock source.
<code class="literal">PLLEN</code> sets the internal Phase Lock Loop either on or off. With this chip the default clock frequency is 8 Mhz. The PLL multiplies this by 4. So to get 32 Mhz the basic internal oscillator will be 8 Mhz then multiplied by 4. For 16 MHz it wil be 4 multiplied by 2.</p><p>GCB sets the PLL automatically, so this option should generally be left alone. IF PLLEN is set to ON, then GCB may not be able to set the correct frewuency of the internal oscillator. Only set PLL = ON if you know what you are doing.</p><p>It is a good practice to set the oscillator source in #config at the beginning of your code when you are not using the internal oscillator.  This prevents potential errors. Example:</p><pre class="screen">    #Chip 12F1840, 16
    #Config OSC = INTOSC   'This is normally not required as the internal oscillator is the default oscillator.</pre><p>In  this example above, GCBASIC will automatically set the necessary OSC bits for the microcontroller. Frequency bits will be set to 4 MHz and the PLL will be turned on and wait times will be calculated on an FOSC of 16.</p><p>You can set the clock to other frequencies but you have to put the PIC into <code class="literal">EC</code> or <code class="literal">External Clock</code> mode and then supply that specific clock frequency to the OSC1 pin.</p><p>There are three EC modes on the PIC12F1840:</p><pre class="screen">    ECL - 0 MHz - 0.5 MHz
    ECM - 0.5 MHz - 4 MHz
    ECH = 4 MHz - 32MHz</pre><p>Example: For a 2.1 MHz clock you would need to set the #config and the clock frequency, and, provide the OSC1 pin with a 2.1 MHz signal.</p><pre class="screen">    #chip 12f1840,2.1
    #config OSC = ECM</pre><p><span class="strong"><strong>Notes</strong></span></p><p>When "#config osc=" is not specified in the source code, most microcontrollers will default to an external oscillator source. This means at runtime the chip is expecting an external clock signal.  If the external clock signal is not present, the chip detects a "failure" of the external clock and will  "falls back" to the default internal oscillator setting.</p><p>The PLLEN bit defaults to OFF. The PLL is enabled depending upon the ChipMhz in #Chip xxxxxx, ChipMhz.</p><p>The GCBASIC defaults - This is how the bits are set if there is no #config in the source code, GCBASIC does set certain bits.  To examine what bits are set on a particular chip you can omit #config in the source code, thenm compile the code and then use "Open ASM" in the GCBASIC IDE. The bits that are set will be in the config section. All other bits ( those not specifically set) with #Config will be at the POR setting as described below, The <code class="literal">POR</code> settings are shown in the datasheet for each microcontroller.</p><p>Currently GCBASIC sets the <code class="literal">LVP</code> bit <code class="literal">OFF</code> by default on many chips. This does not affect normal HV programming like a with a PicKit3.   The default of LVP = OFF  will prevent the microcontroller from being programmed with Low Voltage Programmer. This means that if a PIC microcontroller has previously been programmed with with "LVP =  OFF",  then it must be erased or reprogrammed with LVP = ON using a HVP programmer prior to using certain programming devices e.g. Curiosity development boards, or "NS"  programmers as these  required that LVP = ON.</p><p>When LVP = ON, the MCLR pin is automatically set to EXTERNAL MCLR.  This means that the MCLRE pin CANNOT be sue for general purpose I/O functions.</p><p>The native <code class="literal">POR</code> (Power On Reset) defaults. This is the state of the config bits after Power on if the ASM code has no configuration entries or on a blank factory chip. The only way to power up in this state with GCB code is to use " #option NoConfig" in the GCBASIC source code.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_chip"></span>\#chip

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #chip model, frequency
```

<span class="strong">**Explanation:**</span>

The `#chip` directive is used to specify the chip model and frequency
that GCBASIC will use.

The `model` is the specific microcontroller - examples are "16F819".

The `frequency` is the frequency of the chip in MHz, and is required for
the delay and PWM routines. The following constants simplify setting
specific frequencies. `31k`, `32.768K`, `125k`, `250k` or `500k`. Any of
these constant can be used. As shown in the example below.

If `frequency` is not present the compiler will select a frequency
default frequency that should work for the microcontroller.

<div class="orderedlist">

1.  If the chip has an internal oscillator, the compiler will use that
    and pick the highest frequency it supports.
2.  If the chip does not have an internal oscillator, then GCBASIC will
    assume that the chip is being run at its maximum possible clock
    frequency using an external crystal.
3.  If you are using an external crystal then you must specify a chip
    frequency.

</div>

When using an AVR, there is no need to specify "AT" before the name.

<span class="strong">**Examples:**</span>

``` screen
    #chip 12F509, 4
    #chip 18F4550, 48
    #chip 16F88, 0.125
    #chip tiny2313, 1
    #chip mega8, 16
    #chip 12f1840, 31k
    #chip 12f1840, 500k
    #chip 12f1840, 250k
    #chip 12f1840, 125k

    'Select the internal low frequency oscillator. The microcontroller must have a low frequency oscillator option.  The internal oscillator is automatically selected.
    #chip 16f18326, 31k

    'Select the external SOSC clock source.
    #chip 16f18855, 32.768k
    #config osc=SOSC
```

<span class="strong">**Setting Other Clock frequencies:**</span> Some
alternative compilers allow value of the clock frequency to be set with
the numerical value in Hertz (<span class="emphasis">*i.e.*</span>
24576000). This can be useful when using the clock frequencies other
than standard frequencies.

GCBASIC requires clock frequencys to be specified in MHz, but will
accept decimal points. For example, if you wanted to run a 16F1827 at
24576000 Hz, you would write the following:

``` screen
    #chip 16F1827, 24.576
```

<span class="strong">**GCBASIC support for microcontrollers:**</span>

Each microcontroller has a microcontroller data file. This file is
located in \\GCBasic\\chipdata\\ folder when installed.

An example is 12F1840.dat

The there are two sections in the microcontroller data file that control
the "chip frequency", they are:

``` literallayout
*[ChipData]* and *[ConfigOps]*
```

<span class="strong">**ChipData section**</span>

The ChipData section for 12F1840 microcontroller. The 12F1840 is used an
example

``` screen
    [ChipData]
    Prog=4096
    EEPROM=256
    RAM=256
    I/O=6
    ADC=4
    MaxMHz=32
    IntOsc=32, 16, 8, 4, 2, 1, 0.5, 0.25, 0.125
    31kSupport=INTOSC,OSCCON,2
    Pins=8
    Family=15
    ConfigWords=2
    PSP=0
    MaxAddress=4095
```

The IntOsc line specifies the supported internal clock frequencies - The
12F1840 microcontroller supports nine internal frequencies (ChipMHz).
\#Chip is used as follows: The 31kSupport line specifies the chip
supports 31k for internal clock frequency.

``` screen
    #chip 12F1840, 32
```

A ChipMHz of 32 does two things.

<div class="orderedlist">

1.  When using the internal oscillator, it tells the compiler to set the
    chip clock frequency (FOSC) to 32MHz
2.  It tells the compiler to calculate all delays (wait times) based
    upon FOSC of 32 MHz. Unlike Picaxe Basic (and other compilers)
    GCBASIC delays ("wait") are correct regardless of the setting of
    FOSC. If you set the internal oscillator to 4 MHz a "wait 1 ms" will
    still be 1 ms.

</div>

If you set chipMHz to something other than the valid options in the
\[ChipData\] IntOsc section of the microcontroller specific dat file,
then, the compiler assumes that you are using an external oscillator and
will calculate the delays according to the value you use. The wait times
will be incorrect if you are not using an external oscillator at the
same frequency as ChipMhz.

``` screen
    Example:  #chip 12F1840, 12
```

Since "12" is not a valid internal osc frequency, the microcontroller
FOSC will default to 8 MHz because there is no external crystal
installed. However, the wait times will be incorrect as they will be
calculated by the compiler based upon a 12 Mhz clock.

<span class="strong">**ConfigOps section**</span>

The \[ConfigOps\] section of 12F1840.dat is towards the end of the chip
data file. For the 12F1840 is looks like this

``` screen
    [ConfigOps]
    OSC=LP,XT,HS,EXTRC,INTOSC,ECL,ECM,ECH
    WDTE=OFF,SWDTEN,NSLEEP,ON
    PWRTE=ON,OFF
    MCLRE=OFF,ON
    CP=ON,OFF
    CPD=ON,OFF
    BOREN=OFF,SBODEN,NSLEEP,ON
    CLKOUTEN=ON,OFF
    IESO=OFF,ON
    FCMEN=OFF,ON
    WRT=ALL,HALF,BOOT,OFF
    PLLEN=OFF,ON
    STVREN=OFF,ON
    BORV=HI,LO,19
    LVP=OFF,ON
```

`OSC` specifies which oscillator options are available for the specific
microcontroller. `INTOSC` is the internal oscillator. All others are
some form of external clock source. `PLLEN` sets the internal Phase Lock
Loop either on or off. With this chip the default clock frequency is 8
Mhz. The PLL multiplies this by 4. So to get 32 Mhz the basic internal
oscillator will be 8 Mhz then multiplied by 4. For 16 MHz it wil be 4
multiplied by 2.

GCB sets the PLL automatically, so this option should generally be left
alone. IF PLLEN is set to ON, then GCB may not be able to set the
correct frewuency of the internal oscillator. Only set PLL = ON if you
know what you are doing.

It is a good practice to set the oscillator source in \#config at the
beginning of your code when you are not using the internal oscillator.
This prevents potential errors. Example:

``` screen
    #Chip 12F1840, 16
    #Config OSC = INTOSC   'This is normally not required as the internal oscillator is the default oscillator.
```

In this example above, GCBASIC will automatically set the necessary OSC
bits for the microcontroller. Frequency bits will be set to 4 MHz and
the PLL will be turned on and wait times will be calculated on an FOSC
of 16.

You can set the clock to other frequencies but you have to put the PIC
into `EC` or `External Clock` mode and then supply that specific clock
frequency to the OSC1 pin.

There are three EC modes on the PIC12F1840:

``` screen
    ECL - 0 MHz - 0.5 MHz
    ECM - 0.5 MHz - 4 MHz
    ECH = 4 MHz - 32MHz
```

Example: For a 2.1 MHz clock you would need to set the \#config and the
clock frequency, and, provide the OSC1 pin with a 2.1 MHz signal.

``` screen
    #chip 12f1840,2.1
    #config OSC = ECM
```

<span class="strong">**Notes**</span>

When "\#config osc=" is not specified in the source code, most
microcontrollers will default to an external oscillator source. This
means at runtime the chip is expecting an external clock signal. If the
external clock signal is not present, the chip detects a "failure" of
the external clock and will "falls back" to the default internal
oscillator setting.

The PLLEN bit defaults to OFF. The PLL is enabled depending upon the
ChipMhz in \#Chip xxxxxx, ChipMhz.

The GCBASIC defaults - This is how the bits are set if there is no
\#config in the source code, GCBASIC does set certain bits. To examine
what bits are set on a particular chip you can omit \#config in the
source code, thenm compile the code and then use "Open ASM" in the
GCBASIC IDE. The bits that are set will be in the config section. All
other bits ( those not specifically set) with \#Config will be at the
POR setting as described below, The `POR` settings are shown in the
datasheet for each microcontroller.

Currently GCBASIC sets the `LVP` bit `OFF` by default on many chips.
This does not affect normal HV programming like a with a PicKit3. The
default of LVP = OFF will prevent the microcontroller from being
programmed with Low Voltage Programmer. This means that if a PIC
microcontroller has previously been programmed with with "LVP = OFF",
then it must be erased or reprogrammed with LVP = ON using a HVP
programmer prior to using certain programming devices e.g. Curiosity
development boards, or "NS" programmers as these required that LVP = ON.

When LVP = ON, the MCLR pin is automatically set to EXTERNAL MCLR. This
means that the MCLRE pin CANNOT be sue for general purpose I/O
functions.

The native `POR` (Power On Reset) defaults. This is the state of the
config bits after Power on if the ASM code has no configuration entries
or on a blank factory chip. The only way to power up in this state with
GCB code is to use " \#option NoConfig" in the GCBASIC source code.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#config</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__chip.html" title="#chip"><link rel="next" href="__define.html" title="#DEFINE"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__config"></a>#config</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #config <span class="emphasis"><em>option1</em></span>, <span class="emphasis"><em>option2</em></span>, ... , <span class="emphasis"><em>optionN</em></span></pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">#config</code> directive is used to specify configuration options for the chip. There is a detailed explanation of <code class="literal">#config</code> in the Configuration section of help.</p><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_configuration.html" title="Configuration">Configuration</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_config"></span>\#config

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #config option1, option2, ... , optionN
```

<span class="strong">**Explanation:**</span>

The `#config` directive is used to specify configuration options for the
chip. There is a detailed explanation of `#config` in the Configuration
section of help.

<span class="strong">**See Also**</span>
<a href="configuration" class="link" title="Configuration">Configuration</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#DEFINE</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__config.html" title="#config"><link rel="next" href="__undefine.html" title="#UNDEFINE"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__define"></a>#DEFINE</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #DEFINE SYMBOL <span class="emphasis"><em>body</em></span></pre><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
<code class="literal">#DEFINE</code> allows to declare text-based preprocessor symbols.&nbsp;&nbsp;</p><p>Once the compiler has seen a #DEFINE, it will start replacing further occurrences of symbol with body. &nbsp;&nbsp;
Body may be empty.&nbsp;&nbsp;
The expansion is done recursively, until there is nothing more to expand and the compiler can continue analyzing the resulting code.</p><p>#UNDEFINE can be used to make the compiler forget about a #DEFINE.</p><p><br>
<br>
The compiler replaces a SYMBOL with the value, it then searches the line for constants again and will make any more replacements needed.&nbsp;&nbsp;
It will do this up to 100 times on a line, then it will stop replacing and show an error. &nbsp;&nbsp;The limitation of 100 iteractions is to prevent something like "#DEFINE Const_A Const_B" and then "#DEFINE Const_B Const_A" from causing an infinite loop in the compiler.</p><p><br>
<br></p><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_constants.html" title="Constants">DEFINEs</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_define"></span>\#DEFINE

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #DEFINE SYMBOL body
```

<span class="strong">**Explanation:**</span>  
  
`#DEFINE` allows to declare text-based preprocessor symbols.  

Once the compiler has seen a \#DEFINE, it will start replacing further
occurrences of symbol with body.    Body may be empty.   The expansion
is done recursively, until there is nothing more to expand and the
compiler can continue analyzing the resulting code.

\#UNDEFINE can be used to make the compiler forget about a \#DEFINE.

  
  
The compiler replaces a SYMBOL with the value, it then searches the line
for constants again and will make any more replacements needed.   It
will do this up to 100 times on a line, then it will stop replacing and
show an error.   The limitation of 100 iteractions is to prevent
something like "\#DEFINE Const\_A Const\_B" and then "\#DEFINE Const\_B
Const\_A" from causing an infinite loop in the compiler.

  
  

<span class="strong">**See Also**</span>
<a href="constants" class="link" title="Constants">DEFINEs</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#if</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__undefine.html" title="#UNDEFINE"><link rel="next" href="__ifnot.html" title="#ifnot"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__if"></a>#if</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #if <span class="emphasis"><em>Condition</em></span>
      ...
    [#else]
      ...
    #endif</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">#if</code> directive is used to prevent a section of code from compiling unless <code class="literal"><span class="emphasis"><em>Condition</em></span></code> is true.</p><p><code class="literal"><span class="emphasis"><em>Condition</em></span></code> has the same syntax as the condition in a normal GCBASIC if command. The only difference is that it uses constants instead of variables and does not use "then".</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will pulse an adjustable number of pins on PORTB
    'The number of pins is controlled by the FlashPins constant
    #chip 16F88, 8

    'The number of pins to flash
    #define FlashPins 2

    'Initialise
    Dir PORTB Out

    'Main loop
    Do
        #if FlashPins &gt;= 1
            PulseOut PORTB.0, 250 ms
        #endif
        #if FlashPins &gt;= 2
            PulseOut PORTB.1, 250 ms
        #endif
        #if FlashPins &gt;= 3
            PulseOut PORTB.2, 250 ms
        #endif
        #if FlashPins &gt;= 4
            PulseOut PORTB.3, 250 ms
        #endif
    Loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_if"></span>\#if

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #if Condition
      ...
    [#else]
      ...
    #endif
```

<span class="strong">**Explanation:**</span>

The `#if` directive is used to prevent a section of code from compiling
unless `Condition` is true.

`Condition` has the same syntax as the condition in a normal GCBASIC if
command. The only difference is that it uses constants instead of
variables and does not use "then".

<span class="strong">**Example:**</span>

``` screen
    'This program will pulse an adjustable number of pins on PORTB
    'The number of pins is controlled by the FlashPins constant
    #chip 16F88, 8

    'The number of pins to flash
    #define FlashPins 2

    'Initialise
    Dir PORTB Out

    'Main loop
    Do
        #if FlashPins >= 1
            PulseOut PORTB.0, 250 ms
        #endif
        #if FlashPins >= 2
            PulseOut PORTB.1, 250 ms
        #endif
        #if FlashPins >= 3
            PulseOut PORTB.2, 250 ms
        #endif
        #if FlashPins >= 4
            PulseOut PORTB.3, 250 ms
        #endif
    Loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#ifdef</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__ifnot.html" title="#ifnot"><link rel="next" href="__ifndef.html" title="#ifndef"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__ifdef"></a>#ifdef</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #ifdef <span class="emphasis"><em>Constant</em></span> | <span class="emphasis"><em>Constant Value</em></span> | Var(<span class="emphasis"><em>VariableName</em></span>)
      ...
    [#else]
      ...
    #endif</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">#ifdef</code> directive is used to selectively enable sections of code.</p><p>There are several ways in which it can be used:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Checking if a constant is defined<br></li><li class="listitem">Checking if a constant is defined and has a particular value<br></li><li class="listitem">Checking if a system variable exists<br></li><li class="listitem">Checking if a system bit has been defined</li></ul></div><p>The advantage of using <code class="literal">#ifdef</code> rather than an equivalent series of <code class="literal">IF</code> statements is the amount of code that is downloaded to the chip. <code class="literal">#ifdef</code> controls what code is compiled and downloaded, <code class="literal">IF</code> controls what is run once on the chip. <code class="literal">#ifdef</code> should be used whenever the value of a constant is to be checked.</p><p>GCBASIC also supports the <code class="literal">#ifndef</code> directive - this is the opposite of the <code class="literal">#ifdef</code> directive - it will remove code that <code class="literal">#ifdef</code> leaves, and vice versa.</p><p><span class="strong"><strong>Note:</strong></span>
The code in the following sections will not compile, as it is missing <code class="literal">#chip</code> directives and <code class="literal">Dir</code> commands. It is intended to act as an example only.</p><p><span class="strong"><strong>Example 1: <span class="emphasis"><em>Enabling code if a constant is defined</em></span></strong></span></p><pre class="screen">    #define Blink1

    #ifdef Blink1
        PulseOut PORTB.0, 1 sec
        Wait 1 sec
    #endif
    #ifdef Blink2
        PulseOut PORTB.1, 1 sec
        Wait 1 sec
    #endif</pre><p>This code will pulse <code class="literal">PORTB.0</code>, but not <code class="literal">PORTB.1</code>. This is because <code class="literal">Blink1</code> has been defined, but <code class="literal">Blink2</code> has not. If the line was added at the start of the program, then both pins would be pulsed.</p><pre class="screen">    #define Blink2</pre><p>The value of the constant defined is not important and can be left off of the <code class="literal">#define</code>.</p><p><span class="strong"><strong>Example 2: <span class="emphasis"><em>Enabling code if a constant is defined and has a given value</em></span></strong></span></p><pre class="screen">    #define PinsToFlash 2

    #ifdef PinsToFlash 1,2,3
      PulseOut PORTB.0, 1 sec
    #endif
    #ifdef PinsToFlash 2,3
      PulseOut PORTB.1, 1 sec
    #endif
    #ifdef PinsToFlash 3
      PulseOut PORTB.2, 1 sec
    #endif</pre><p>This program uses a constant called PinsToFlash that controls how many lights are pulsed. <code class="literal">PORTB.0</code> is pulsed when <code class="literal">PinsToFlash</code> is equal to 1, 2 or 3, <code class="literal">PORTB.1</code> is pulsed when <code class="literal">PinsToFlash</code> equals 2 or 3, and <code class="literal">PORTB.2</code> is flashed when <code class="literal">PinsToFlash</code> is 3.</p><p><span class="strong"><strong>Example 3: <span class="emphasis"><em>Enabling code if a system variable is defined</em></span></strong></span></p><pre class="screen">    #ifdef NoVar(ANSEL)
      SET ADCON1.PCFG3 OFF
      SET ADCON1.PCFG2 ON
      SET ADCON1.PCFG1 ON
      SET ADCON1.PCFG0 OFF
    #endif
    #ifdef Var(ANSEL)
      ANSEL = 0
    #endif</pre><p>The above section of code has been copied directly from a-d.h. It is used to disable the A/D function of pins, so that they can be used as standard digital I/O ports. If <code class="literal">ANSEL</code> is not declared as a system variable for a particular chip, then the program uses <code class="literal">ADCON1</code> to control the port modes. If <code class="literal">ANSEL</code> is defined, then the chip is newer and its ports can be set to digital by clearing <code class="literal">ANSEL</code>.</p><p><span class="strong"><strong>Example 4: <span class="emphasis"><em>Enabling code if a system bit is defined</em></span></strong></span></p><p>Similar to above, except with <code class="literal">Bit</code> and <code class="literal">NoBit</code> in the place of <code class="literal">Var</code> and <code class="literal">NoVar</code> respectively.</p><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_constants.html" title="Constants">Defines</a>, <a class="link" href="__define.html" title="#DEFINE">#define</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_ifdef"></span>\#ifdef

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #ifdef Constant | Constant Value | Var(VariableName)
      ...
    [#else]
      ...
    #endif
```

<span class="strong">**Explanation:**</span>

The `#ifdef` directive is used to selectively enable sections of code.

There are several ways in which it can be used:

<div class="itemizedlist">

-   Checking if a constant is defined  
-   Checking if a constant is defined and has a particular value  
-   Checking if a system variable exists  
-   Checking if a system bit has been defined

</div>

The advantage of using `#ifdef` rather than an equivalent series of `IF`
statements is the amount of code that is downloaded to the chip.
`#ifdef` controls what code is compiled and downloaded, `IF` controls
what is run once on the chip. `#ifdef` should be used whenever the value
of a constant is to be checked.

GCBASIC also supports the `#ifndef` directive - this is the opposite of
the `#ifdef` directive - it will remove code that `#ifdef` leaves, and
vice versa.

<span class="strong">**Note:**</span> The code in the following sections
will not compile, as it is missing `#chip` directives and `Dir`
commands. It is intended to act as an example only.

<span class="strong">**Example 1: <span class="emphasis">*Enabling code
if a constant is defined*</span>**</span>

``` screen
    #define Blink1

    #ifdef Blink1
        PulseOut PORTB.0, 1 sec
        Wait 1 sec
    #endif
    #ifdef Blink2
        PulseOut PORTB.1, 1 sec
        Wait 1 sec
    #endif
```

This code will pulse `PORTB.0`, but not `PORTB.1`. This is because
`Blink1` has been defined, but `Blink2` has not. If the line was added
at the start of the program, then both pins would be pulsed.

``` screen
    #define Blink2
```

The value of the constant defined is not important and can be left off
of the `#define`.

<span class="strong">**Example 2: <span class="emphasis">*Enabling code
if a constant is defined and has a given value*</span>**</span>

``` screen
    #define PinsToFlash 2

    #ifdef PinsToFlash 1,2,3
      PulseOut PORTB.0, 1 sec
    #endif
    #ifdef PinsToFlash 2,3
      PulseOut PORTB.1, 1 sec
    #endif
    #ifdef PinsToFlash 3
      PulseOut PORTB.2, 1 sec
    #endif
```

This program uses a constant called PinsToFlash that controls how many
lights are pulsed. `PORTB.0` is pulsed when `PinsToFlash` is equal to 1,
2 or 3, `PORTB.1` is pulsed when `PinsToFlash` equals 2 or 3, and
`PORTB.2` is flashed when `PinsToFlash` is 3.

<span class="strong">**Example 3: <span class="emphasis">*Enabling code
if a system variable is defined*</span>**</span>

``` screen
    #ifdef NoVar(ANSEL)
      SET ADCON1.PCFG3 OFF
      SET ADCON1.PCFG2 ON
      SET ADCON1.PCFG1 ON
      SET ADCON1.PCFG0 OFF
    #endif
    #ifdef Var(ANSEL)
      ANSEL = 0
    #endif
```

The above section of code has been copied directly from a-d.h. It is
used to disable the A/D function of pins, so that they can be used as
standard digital I/O ports. If `ANSEL` is not declared as a system
variable for a particular chip, then the program uses `ADCON1` to
control the port modes. If `ANSEL` is defined, then the chip is newer
and its ports can be set to digital by clearing `ANSEL`.

<span class="strong">**Example 4: <span class="emphasis">*Enabling code
if a system bit is defined*</span>**</span>

Similar to above, except with `Bit` and `NoBit` in the place of `Var`
and `NoVar` respectively.

<span class="strong">**See Also**</span>
<a href="constants" class="link" title="Constants">Defines</a>,
<a href="_define" class="link" title="#DEFINE">#define</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#ifndef</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__ifdef.html" title="#ifdef"><link rel="next" href="__include.html" title="#include"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__ifndef"></a>#ifndef</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #ifndef <span class="emphasis"><em>Constant</em></span> | <span class="emphasis"><em>Constant Value</em></span> | Var(<span class="emphasis"><em>VariableName</em></span>)
      ...
    [#else]
      ...
    #endif</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">#ifndef</code> directive is used to selectively enable sections of code. It is the opposite of the <code class="literal">#ifdef</code> directive - it will delete code in cases where <code class="literal">#ifdef</code> would leave it, and will leave code where <code class="literal">#ifdef</code> would delete it.</p><p><span class="strong"><strong>See</strong></span> the <a class="link" href="__ifdef.html" title="#ifdef">#ifdef</a> article for more information.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_ifndef"></span>\#ifndef

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #ifndef Constant | Constant Value | Var(VariableName)
      ...
    [#else]
      ...
    #endif
```

<span class="strong">**Explanation:**</span>

The `#ifndef` directive is used to selectively enable sections of code.
It is the opposite of the `#ifdef` directive - it will delete code in
cases where `#ifdef` would leave it, and will leave code where `#ifdef`
would delete it.

<span class="strong">**See**</span> the
<a href="_ifdef" class="link" title="#ifdef">#ifdef</a> article
for more information.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#ifnot</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__if.html" title="#if"><link rel="next" href="__ifdef.html" title="#ifdef"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__ifnot"></a>#ifnot</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #ifnot <span class="emphasis"><em>Condition</em></span>
      ...
    [#else]
      ...
    #endif</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">#ifnot</code> directive is used to prevent a section of code from compiling unless <code class="literal"><span class="emphasis"><em>Condition</em></span></code> is false.</p><p><code class="literal"><span class="emphasis"><em>Condition</em></span></code> has the same syntax as the condition in a normal GCBASIC if command. The only difference is that it uses constants instead of variables and does not use "then".</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'This program will set the constant to true only if NOT a PIC family
    #chip 16F88, 8

    #ifnot ChipFamily = 14

      #define myConstant True

    #endif</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_ifnot"></span>\#ifnot

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #ifnot Condition
      ...
    [#else]
      ...
    #endif
```

<span class="strong">**Explanation:**</span>

The `#ifnot` directive is used to prevent a section of code from
compiling unless `Condition` is false.

`Condition` has the same syntax as the condition in a normal GCBASIC if
command. The only difference is that it uses constants instead of
variables and does not use "then".

<span class="strong">**Example:**</span>

``` screen
    'This program will set the constant to true only if NOT a PIC family
    #chip 16F88, 8

    #ifnot ChipFamily = 14

      #define myConstant True

    #endif
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#include</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__ifndef.html" title="#ifndef"><link rel="next" href="__insert.html" title="#insert"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__include"></a>#include</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #include <span class="emphasis"><em>filename</em></span></pre><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">#include</code> tells GCBASIC to open up another file, read all of the subroutines and constants from it, and then copy them into the current program.</p><p>There are two forms of include; absolute and relative.</p><p>Absolute is used to refer to files in the <code class="literal">..\GCBASIC\include</code>  directory. The name of the file is specified in between &lt; and &gt; symbols. For instance, to include the file <code class="literal">srf04.h</code>, the directive is:</p><pre class="screen">    #include &lt;srf04.h&gt;</pre><p>Relative is used to read files in the same folder as the currently selected program. Filenames are given enclosed in quotation marks, such as where <code class="literal">mycode.h</code> is the name of the file that is to be read.</p><pre class="screen">    #include "mycode.h"</pre><p><span class="strong"><strong>NOTES:</strong></span>
It is not essential that the include file name ends in .h - the important thing is that the name given to GCBASIC is the exact name of the file to be included.</p><p>Those who are familiar with <code class="literal">#include</code> in assembly or C should bear in mind that <code class="literal">#include</code> in GCBASIC works differently to <code class="literal">#include</code> in most other languages - code is not inserted at the location of the <code class="literal">#include</code>, but rather at the end of the current program.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_include"></span>\#include

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #include filename
```

<span class="strong">**Explanation:**</span>

`#include` tells GCBASIC to open up another file, read all of the
subroutines and constants from it, and then copy them into the current
program.

There are two forms of include; absolute and relative.

Absolute is used to refer to files in the `..\GCBASIC\include`
directory. The name of the file is specified in between &lt; and &gt;
symbols. For instance, to include the file `srf04.h`, the directive is:

``` screen
    #include <srf04.h>
```

Relative is used to read files in the same folder as the currently
selected program. Filenames are given enclosed in quotation marks, such
as where `mycode.h` is the name of the file that is to be read.

``` screen
    #include "mycode.h"
```

<span class="strong">**NOTES:**</span> It is not essential that the
include file name ends in .h - the important thing is that the name
given to GCBASIC is the exact name of the file to be included.

Those who are familiar with `#include` in assembly or C should bear in
mind that `#include` in GCBASIC works differently to `#include` in most
other languages - code is not inserted at the location of the
`#include`, but rather at the end of the current program.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#insert</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__include.html" title="#include"><link rel="next" href="__script.html" title="#script"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__insert"></a>#insert</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #insert <span class="emphasis"><em>filename</em></span></pre><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">#insert</code> tells GCBASIC to open up another file, read all of the subroutines and constants from it, and then copy them into the current program at the specific line where the #insert directive is located.</p><p>There are two forms of include; absolute and relative.</p><p>Absolute is used to refer to files in the <code class="literal">..\GCBASIC\include</code>  directory. The name of the file is specified in between &lt; and &gt; symbols. For instance, to include the file <code class="literal">toolchain.il</code>, the directive is:</p><pre class="screen">    #insert &lt;"toolchain.il"&gt;</pre><p>Relative is used to read files in the same folder as the currently selected program. Filenames are given enclosed in quotation marks, such as where <code class="literal">mycode.h</code> is the name of the file that is to be read.</p><pre class="screen">    #insert "toolchain.il"</pre><p><span class="strong"><strong>Difference from #include:</strong></span></p><p>This is very different from #include.&nbsp;&nbsp;
With #include you can organize constant, method and macro definitions and then use #include directive to add them to any source file.&nbsp;&nbsp;
Include files are also useful for incorporating declarations of external variables and complex data types. The types may be defined and named only once in an include file created for that purpose. The compiler will optimise the include files to determine the best order/location in your program.</p><p>Using #insert you are determining the location of the code segment.&nbsp;&nbsp;
It will be inserted exactly where you specify.&nbsp;&nbsp;
The optimisation will only be applied to any methods that you insert but the rest of the code essentially exits at the point of insertion.</p><p><span class="strong"><strong>#Insert does not support Conversion:</strong></span></p><p>There is no conversion of the inserted file.&nbsp;&nbsp;For conversion use #Include.&nbsp;&nbsp;</p><p>If you need to convert a file from an external source then see the Converters section of the Help.</p><p><span class="strong"><strong>Usage Notes:</strong></span></p><p>The file must exist. An error message is issued if not found.&nbsp;&nbsp;
When an error is encountered in the inserted file the error line number is in the format of xxxxyyyy.&nbsp;&nbsp;
Where xxxx is the code line number in the user program and the yyyy is the the line number in the inserted file.</p><p>An example error message.&nbsp;&nbsp;Where the source insert instruction is on line 6 and the error in the inserted file is on line 4.</p><pre class="screen">    An error has been found:
     insertexample.gcb (60004): Error: Syntax Error
    The message has been logged to the file Errors.txt.</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_insert"></span>\#insert

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #insert filename
```

<span class="strong">**Explanation:**</span>

`#insert` tells GCBASIC to open up another file, read all of the
subroutines and constants from it, and then copy them into the current
program at the specific line where the \#insert directive is located.

There are two forms of include; absolute and relative.

Absolute is used to refer to files in the `..\GCBASIC\include`
directory. The name of the file is specified in between &lt; and &gt;
symbols. For instance, to include the file `toolchain.il`, the directive
is:

``` screen
    #insert <"toolchain.il">
```

Relative is used to read files in the same folder as the currently
selected program. Filenames are given enclosed in quotation marks, such
as where `mycode.h` is the name of the file that is to be read.

``` screen
    #insert "toolchain.il"
```

<span class="strong">**Difference from \#include:**</span>

This is very different from \#include.   With \#include you can organize
constant, method and macro definitions and then use \#include directive
to add them to any source file.   Include files are also useful for
incorporating declarations of external variables and complex data types.
The types may be defined and named only once in an include file created
for that purpose. The compiler will optimise the include files to
determine the best order/location in your program.

Using \#insert you are determining the location of the code segment.  
It will be inserted exactly where you specify.   The optimisation will
only be applied to any methods that you insert but the rest of the code
essentially exits at the point of insertion.

<span class="strong">**\#Insert does not support Conversion:**</span>

There is no conversion of the inserted file.  For conversion use
\#Include.  

If you need to convert a file from an external source then see the
Converters section of the Help.

<span class="strong">**Usage Notes:**</span>

The file must exist. An error message is issued if not found.   When an
error is encountered in the inserted file the error line number is in
the format of xxxxyyyy.   Where xxxx is the code line number in the user
program and the yyyy is the the line number in the inserted file.

An example error message.  Where the source insert instruction is on
line 6 and the error in the inserted file is on line 4.

``` screen
    An error has been found:
     insertexample.gcb (60004): Error: Syntax Error
    The message has been logged to the file Errors.txt.
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#mem</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__startup.html" title="#startup"><link rel="next" href="_other_directives.html" title="Other directives"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__mem"></a>#mem</h3></div></div></div><p><span class="strong"><strong>This directive is obsolete</strong></span>.</p><p>GCBASIC determines the amount of memory on a chip automatically, and will ignore the <code class="literal">#mem</code> directive.</p><p>It is recommended that this directive is removed from all programs.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_mem"></span>\#mem

</div>

</div>

</div>

<span class="strong">**This directive is obsolete**</span>.

GCBASIC determines the amount of memory on a chip automatically, and
will ignore the `#mem` directive.

It is recommended that this directive is removed from all programs.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#Option Bootloader</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_options.html" title="Compiler Options"><link rel="prev" href="__option_noconfig.html" title="#Option NoConfig"><link rel="next" href="__option_nocontextsave.html" title="#Option NoContextSave"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__option_bootloader"></a>#Option Bootloader</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #option bootloader <span class="emphasis"><em>address</em></span></pre><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">#option bootloader</code> prevents the overwriting of any pre-loaded bootloader code, vectors, etc. below the specified address. The GCBASIC code will start at specified <code class="literal"><span class="emphasis"><em>address</em></span></code>.</p><p>A bootloader is a program that stays in the microcontroller and communicates with the PC, typically through the serial interface. The bootloader receives a user program from the PC and writes it in the flash memory, then launches this program in execution. Bootloaders can only be used with those microcontrollers that can write their flash memory through software.</p><p>The bootloader itself must be written into the flash memory with an external programmer.</p><p>In order for the bootloader to be launched after each reset, a <code class="literal">goto bootloader</code> instruction must exist somewhere in the first 4 instructions; There are two types of bootloaders, some that require that the user reallocate the code and others that by themselves reallocate the first 4 instructions of the user program to another location and execute them when the bootloader exits.</p><p>The diagram below shows the architecture of a bootloader. The left hand is the operation of the instructions without a bootloader. The right hand shows the initial instruction of goto the bootoader, then, when the bootloader has initialised the execution of the start code.</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="./images/optionbootloaderb1.PNG" align="middle" alt="graphic"></div></div><p>See <a class="link" href="https://sourceforge.net/projects/tinypicbootload/files/" target="_top">example bootload software.</a></p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    #option bootloader 0x800</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_option_bootloader"></span>\#Option Bootloader

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #option bootloader address
```

<span class="strong">**Explanation:**</span>

`#option bootloader` prevents the overwriting of any pre-loaded
bootloader code, vectors, etc. below the specified address. The GCBASIC
code will start at specified `address`.

A bootloader is a program that stays in the microcontroller and
communicates with the PC, typically through the serial interface. The
bootloader receives a user program from the PC and writes it in the
flash memory, then launches this program in execution. Bootloaders can
only be used with those microcontrollers that can write their flash
memory through software.

The bootloader itself must be written into the flash memory with an
external programmer.

In order for the bootloader to be launched after each reset, a
`goto bootloader` instruction must exist somewhere in the first 4
instructions; There are two types of bootloaders, some that require that
the user reallocate the code and others that by themselves reallocate
the first 4 instructions of the user program to another location and
execute them when the bootloader exits.

The diagram below shows the architecture of a bootloader. The left hand
is the operation of the instructions without a bootloader. The right
hand shows the initial instruction of goto the bootoader, then, when the
bootloader has initialised the execution of the start code.

<div class="informalfigure">

<div class="mediaobject" align="center">

![graphic](./images/optionbootloaderb1.PNG)

</div>

</div>

See
<a href="https://sourceforge.net/projects/tinypicbootload/files/" class="link">example bootload software.</a>

<span class="strong">**Example:**</span>

``` screen
    #option bootloader 0x800
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#Option Explicit</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_options.html" title="Compiler Options"><link rel="prev" href="_compiler_options.html" title="Compiler Options"><link rel="next" href="__option_noconfig.html" title="#Option NoConfig"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__option_explicit"></a>#Option Explicit</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #option explicit</pre><p>This option ensures that all variables are dimensioned in the user program.  The scope is the user code only and no other code space like .h or include files.</p><p><code class="literal">#option explicit</code> requires all variables,including bytes, in the user program to be defined.</p><p>Variables can be defined and not used within your user program.  Unused variables will not allocate memory.</p><p><span class="strong"><strong>Introduction:</strong></span></p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip 16f877a

    'Example command
    #option explicit

    dim myuserflag as byte

    myuserflag = true</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_variable_lifecycle.html" title="Variable Lifecycle">Variable Lifecycle</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_option_explicit"></span>\#Option Explicit

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #option explicit
```

This option ensures that all variables are dimensioned in the user
program. The scope is the user code only and no other code space like .h
or include files.

`#option explicit` requires all variables,including bytes, in the user
program to be defined.

Variables can be defined and not used within your user program. Unused
variables will not allocate memory.

<span class="strong">**Introduction:**</span>

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip 16f877a

    'Example command
    #option explicit

    dim myuserflag as byte

    myuserflag = true
```

<span class="strong">**For more help, see**</span>
<a href="variable_lifecycle" class="link" title="Variable Lifecycle">Variable Lifecycle</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#Option NoConfig</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_options.html" title="Compiler Options"><link rel="prev" href="__option_explicit.html" title="#Option Explicit"><link rel="next" href="__option_bootloader.html" title="#Option Bootloader"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__option_noconfig"></a>#Option NoConfig</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #option NoConfig</pre><p>This option will prevent the generated assembler from generating _Config items.</p><p><code class="literal">#option NoConfig</code> is used when using a bootloader.</p><p><span class="strong"><strong>Introduction:</strong></span></p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip 16f877a

    'Example command
    #option NoConfig

    'User Code......</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_option_noconfig"></span>\#Option NoConfig

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #option NoConfig
```

This option will prevent the generated assembler from generating
\_Config items.

`#option NoConfig` is used when using a bootloader.

<span class="strong">**Introduction:**</span>

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip 16f877a

    'Example command
    #option NoConfig

    'User Code......
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#Option NoContextSave</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_options.html" title="Compiler Options"><link rel="prev" href="__option_bootloader.html" title="#Option Bootloader"><link rel="next" href="__option_nolatch.html" title="#Option NoLatch"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__option_nocontextsave"></a>#Option NoContextSave</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #option NoContextSave</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>Interrupts can occur at almost any time, and may interrupt another command as it runs. To ensure that the interrupted command can continue properly after the interrupt, some temporary variables (the context) must be saved.
Normally GCBASIC will do this automatically, but in some cases it may be necessary to prevent this. If porting some existing assembly code to GCBASIC, or creating a bootloader using GCBASIC that will call another program,</p><p><code class="literal">NoContextSave</code> can be used to prevent the context saving code from being added automatically.</p><p>Be very careful using this option - it is very easy to cause random corruption of variables. If creating your own context saving code, you may need to save several variables. These are:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">For Microchip PIC microcontrollers 12F/16F: W, STATUS, PCLATH</li><li class="listitem">For Microchip PIC microcontrollers 12F1/16F1/18F: W, STATUS, PCLATH, PCLATU, BSR</li><li class="listitem">For Atmel AVR microcontrollers: All 32 registers</li></ol></div><p>Other variables may also need to be saved, depending on what commands are used inside the interrupt handler.   Everything that is saved will also need to be restored manually when the interrupt handler finishes.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    ' This shows an example that could be used by a bootloader to call some application code.

    ' The application code must deal with context save and restore
    ' Suppose that application code starts at location 0x100, with interrupt vector at 0x108

    'Chip model
    #chip 18F2620

    'Do not save context automatically
    #option NoContextSave

    'Main bootloader routine
    Set PORTB.0 On
    'Do other stuff to make this an actual bootloader and not a trivial example
    'Transfer control to application code
    goto 0x100

    'Interrupt routine - this will be placed at the interrupt vector
    Sub Interrupt
        'If any interrupt occurs, jump straight to application interrupt vector
        goto 0x108
    End Sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_option_nocontextsave"></span>\#Option NoContextSave

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #option NoContextSave
```

<span class="strong">**Explanation:**</span>

Interrupts can occur at almost any time, and may interrupt another
command as it runs. To ensure that the interrupted command can continue
properly after the interrupt, some temporary variables (the context)
must be saved. Normally GCBASIC will do this automatically, but in some
cases it may be necessary to prevent this. If porting some existing
assembly code to GCBASIC, or creating a bootloader using GCBASIC that
will call another program,

`NoContextSave` can be used to prevent the context saving code from
being added automatically.

Be very careful using this option - it is very easy to cause random
corruption of variables. If creating your own context saving code, you
may need to save several variables. These are:

<div class="orderedlist">

1.  For Microchip PIC microcontrollers 12F/16F: W, STATUS, PCLATH
2.  For Microchip PIC microcontrollers 12F1/16F1/18F: W, STATUS, PCLATH,
    PCLATU, BSR
3.  For Atmel AVR microcontrollers: All 32 registers

</div>

Other variables may also need to be saved, depending on what commands
are used inside the interrupt handler. Everything that is saved will
also need to be restored manually when the interrupt handler finishes.

<span class="strong">**Example:**</span>

``` screen
    ' This shows an example that could be used by a bootloader to call some application code.

    ' The application code must deal with context save and restore
    ' Suppose that application code starts at location 0x100, with interrupt vector at 0x108

    'Chip model
    #chip 18F2620

    'Do not save context automatically
    #option NoContextSave

    'Main bootloader routine
    Set PORTB.0 On
    'Do other stuff to make this an actual bootloader and not a trivial example
    'Transfer control to application code
    goto 0x100

    'Interrupt routine - this will be placed at the interrupt vector
    Sub Interrupt
        'If any interrupt occurs, jump straight to application interrupt vector
        goto 0x108
    End Sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#Option NoLatch</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_options.html" title="Compiler Options"><link rel="prev" href="__option_nocontextsave.html" title="#Option NoContextSave"><link rel="next" href="__option_required.html" title="#Option Required"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__option_nolatch"></a>#Option NoLatch</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #option nolatch</pre><p>This option disables PORTx to LATx redirection.</p><p><span class="strong"><strong>Introduction:</strong></span></p><p>The GCBASIC compiler will  redirect all I/O pin writes from PORTx to LATx registers on 16F1/18F Microchip PIC microcontrollers.</p><p>The Microchip PIC mid-range microcontrollers use a sequence known as <span class="strong"><strong>Read-Modify-Write</strong></span> (RMW) when changing an output state  (1 or 0) on a pin.  This can cause unexpected behavior under certain circumstances.</p><p>When your program changes the state on a specific pin, for example RB0 in PORTB, the microcontroller first <span class="strong"><strong>READs</strong></span> all 8 bits of the PORTB register which represents the states of all 8 pins in PORTB (RB7-RB0).</p><p>The microcontroller then stores this data in the MCU. The bit associated with RB that you&#8217;ve commanded to <span class="strong"><strong>MODIFY</strong></span>  is changed, and then the microcontrollers <span class="strong"><strong>WRITEs</strong></span> all 8 bits (RB7- RB0) back to the PORTB register.</p><p>During the first reading of the PORT register, you will be reading the actual state of the physical pin.  The problem arises when an output pin is loaded in such a way that its logic state is affected by the load. Instances of such loads are LEDs without current-limiting resistors or loads with high capacitance or inductance.</p><p>For example, if a capacitor is attached between pin and ground, it will take a short while to charge when the pin is set to 1.  On the other hand, if the capacitor is discharged, it acts like a short circuit, forcing the pin to '0' state,  and, therefore, a read of the PORT register will return 0, even though we wrote a 1 to it.</p><p>GCBASIC resolves this issue using the LATx register when writing to ports, rather than using PORTx registers.  Writing to a LATx register is equivalent to writing to a PORTx register, but readings from LATx registers return
the data value held in the port latch, regardless of the state of the actual pin. So, for reading use PORTx.</p><p><span class="strong"><strong>Note:</strong></span></p><p>You can use the <code class="literal">#option nolatch</code> if problems occur with compiler redirection.</p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_option_nolatch"></span>\#Option NoLatch

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #option nolatch
```

This option disables PORTx to LATx redirection.

<span class="strong">**Introduction:**</span>

The GCBASIC compiler will redirect all I/O pin writes from PORTx to LATx
registers on 16F1/18F Microchip PIC microcontrollers.

The Microchip PIC mid-range microcontrollers use a sequence known as
<span class="strong">**Read-Modify-Write**</span> (RMW) when changing an
output state (1 or 0) on a pin. This can cause unexpected behavior under
certain circumstances.

When your program changes the state on a specific pin, for example RB0
in PORTB, the microcontroller first <span
class="strong">**READs**</span> all 8 bits of the PORTB register which
represents the states of all 8 pins in PORTB (RB7-RB0).

The microcontroller then stores this data in the MCU. The bit associated
with RB that you’ve commanded to <span class="strong">**MODIFY**</span>
is changed, and then the microcontrollers <span
class="strong">**WRITEs**</span> all 8 bits (RB7- RB0) back to the PORTB
register.

During the first reading of the PORT register, you will be reading the
actual state of the physical pin. The problem arises when an output pin
is loaded in such a way that its logic state is affected by the load.
Instances of such loads are LEDs without current-limiting resistors or
loads with high capacitance or inductance.

For example, if a capacitor is attached between pin and ground, it will
take a short while to charge when the pin is set to 1. On the other
hand, if the capacitor is discharged, it acts like a short circuit,
forcing the pin to '0' state, and, therefore, a read of the PORT
register will return 0, even though we wrote a 1 to it.

GCBASIC resolves this issue using the LATx register when writing to
ports, rather than using PORTx registers. Writing to a LATx register is
equivalent to writing to a PORTx register, but readings from LATx
registers return the data value held in the port latch, regardless of
the state of the actual pin. So, for reading use PORTx.

<span class="strong">**Note:**</span>

You can use the `#option nolatch` if problems occur with compiler
redirection.

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#Option Required</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_options.html" title="Compiler Options"><link rel="prev" href="__option_nolatch.html" title="#Option NoLatch"><link rel="next" href="__option_volatile.html" title="#Option Volatile"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__option_required"></a>#Option Required</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #option REQUIRED PIC|AVR CONSTANT %message.dat entry%
    #option REQUIRED PIC|AVR CONSTANT "Message string"</pre><p>This option ensure that the specific CONSTANT exists within a library to ensure a specific capability is available with the microcontroller.</p><p><span class="strong"><strong>Introduction:</strong></span></p><p>This is for developers only.</p><p>This will cause the compiler check the CONSTANT is a non zero value.&nbsp;&nbsp;If the CONSTANT does not exist it will be treated as a zero value.</p><p><span class="strong"><strong>Example:</strong></span></p><p>This example tests the CONSTANT <code class="literal">CHIPUSART</code> for both the PIC and AVR microcontrollers.&nbsp;&nbsp;If the CONSTANT is zero or does not exist then the string will be displayed as an error message.</p><pre class="screen">    #option REQUIRED PIC CHIPUSART "Hardware Serial operations. Remove USART commands to resolve errors."
    #option REQUIRED AVR CHIPUSART "Hardware Serial operations. Remove USART commands to resolve errors."</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_option_required"></span>\#Option Required

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #option REQUIRED PIC|AVR CONSTANT %message.dat entry%
    #option REQUIRED PIC|AVR CONSTANT "Message string"
```

This option ensure that the specific CONSTANT exists within a library to
ensure a specific capability is available with the microcontroller.

<span class="strong">**Introduction:**</span>

This is for developers only.

This will cause the compiler check the CONSTANT is a non zero value.  If
the CONSTANT does not exist it will be treated as a zero value.

<span class="strong">**Example:**</span>

This example tests the CONSTANT `CHIPUSART` for both the PIC and AVR
microcontrollers.  If the CONSTANT is zero or does not exist then the
string will be displayed as an error message.

``` screen
    #option REQUIRED PIC CHIPUSART "Hardware Serial operations. Remove USART commands to resolve errors."
    #option REQUIRED AVR CHIPUSART "Hardware Serial operations. Remove USART commands to resolve errors."
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#Option ReserveHighProg</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_options.html" title="Compiler Options"><link rel="prev" href="__option_volatile.html" title="#Option Volatile"><link rel="next" href="_using_assembler.html" title="Using Assembler"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__option_reservehighprog"></a>#Option ReserveHighProg</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #option ReserveHighProg [words]</pre><p>This option reserves program memory to be kept free at the top end of memory.&nbsp;&nbsp;This useful for HEF/SAF or bootloaders.</p><p>The option provided a reservation for the memory region that is normally assumed to be available to
the compiler for the application code storage. In order to avoid any possible conflict (overlapping code
and data usage), it is important to reserve the devices pecific memory range by using the compiler option (shown above)
in the project configuration.</p><p>Using the <code class="literal">#option ReserveHighProg [words] exposes the constant `ChipReserveHighProg</code> in the user program.</p><p><span class="strong"><strong>Defined constants</strong></span></p><p>The compiler has constants that can be used as an alternative to the parameter <code class="literal">[words]</code>.&nbsp;&nbsp;</p><p>The compiler constants are:  OPTIBOOT, OPTIBOOTUSB, ARDUINONANO, ARDUINOMEGA2560 or TINYBOOTLOADER.</p><p>Where these constants equate to:</p><pre class="screen">    OPTIBOOT        = 1024
    OPTIBOOTUSB     = 2048
    ARDUINONANO     = 1024
    ARDUINOMEGA2560 = 1024
    TINYBOOTLOADER  = 128
    TINYBOOTLOADER128  = 128
    TINYBOOTLOADER125  = 256</pre><p><span class="strong"><strong>Examples 1</strong></span></p><p>In the example below the region 0x1F80 to 0x1FFF (flash block for a
PIC16F1509 microcontroller) has been removed from the default space available for code storage using the compiler option.</p><pre class="screen">    'Set chip model
    #chip 16F1509

    'Directive
    #option ReserveHighProg 128</pre><p><span class="strong"><strong>Examples 2</strong></span></p><p>In the example below the bootloader area of Program Memory is protected.</p><p>This will ensure the program size does not overwrite the OptiBoot bootloader.</p><pre class="screen">    'Set chip model
    #chip MEGA328P

    'Directive
    #option ReserveHighProg OPTIBOOT</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_option_reservehighprog"></span>\#Option ReserveHighProg

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #option ReserveHighProg [words]
```

This option reserves program memory to be kept free at the top end of
memory.  This useful for HEF/SAF or bootloaders.

The option provided a reservation for the memory region that is normally
assumed to be available to the compiler for the application code
storage. In order to avoid any possible conflict (overlapping code and
data usage), it is important to reserve the devices pecific memory range
by using the compiler option (shown above) in the project configuration.

Using the
`` #option ReserveHighProg [words] exposes the constant `ChipReserveHighProg ``
in the user program.

<span class="strong">**Defined constants**</span>

The compiler has constants that can be used as an alternative to the
parameter `[words]`.  

The compiler constants are: OPTIBOOT, OPTIBOOTUSB, ARDUINONANO,
ARDUINOMEGA2560 or TINYBOOTLOADER.

Where these constants equate to:

``` screen
    OPTIBOOT        = 1024
    OPTIBOOTUSB     = 2048
    ARDUINONANO     = 1024
    ARDUINOMEGA2560 = 1024
    TINYBOOTLOADER  = 128
    TINYBOOTLOADER128  = 128
    TINYBOOTLOADER125  = 256
```

<span class="strong">**Examples 1**</span>

In the example below the region 0x1F80 to 0x1FFF (flash block for a
PIC16F1509 microcontroller) has been removed from the default space
available for code storage using the compiler option.

``` screen
    'Set chip model
    #chip 16F1509

    'Directive
    #option ReserveHighProg 128
```

<span class="strong">**Examples 2**</span>

In the example below the bootloader area of Program Memory is protected.

This will ensure the program size does not overwrite the OptiBoot
bootloader.

``` screen
    'Set chip model
    #chip MEGA328P

    'Directive
    #option ReserveHighProg OPTIBOOT
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#Option Volatile</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_options.html" title="Compiler Options"><link rel="prev" href="__option_required.html" title="#Option Required"><link rel="next" href="__option_reservehighprog.html" title="#Option ReserveHighProg"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__option_volatile"></a>#Option Volatile</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #option volatile `bit`</pre><p>This option ensure port setting are glitch-free.</p><p><span class="strong"><strong>Introduction:</strong></span></p><p>#option volatile bit where bit is an IO bit, like PORTB.0 appended.</p><p>This will cause the compiler to set the bit without any glitches when copying a value from another variable, but will increase code size slightly.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">    'Set chip model
    #chip 16f877a

    'Example command
    #option volatile portb.0

    dir portb.0 out

    do forever

      portb.0 = !portb.0

    loop</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_option_volatile"></span>\#Option Volatile

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #option volatile `bit`
```

This option ensure port setting are glitch-free.

<span class="strong">**Introduction:**</span>

\#option volatile bit where bit is an IO bit, like PORTB.0 appended.

This will cause the compiler to set the bit without any glitches when
copying a value from another variable, but will increase code size
slightly.

<span class="strong">**Example:**</span>

``` screen
    'Set chip model
    #chip 16f877a

    'Example command
    #option volatile portb.0

    dir portb.0 out

    do forever

      portb.0 = !portb.0

    loop
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#script</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__insert.html" title="#insert"><link rel="next" href="__startup.html" title="#startup"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__script"></a>#script</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #script
    [<span class="emphasis"><em>scriptcommand1</em></span>]
    [<span class="emphasis"><em>scriptcommand2</em></span>]
     ...
    [<span class="emphasis"><em>scriptcommandn</em></span>]
    #endscript</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>The <code class="literal">#script</code> block is used to create small sections of code which GCBASIC runs during compilation.
A detail explanation and example are included in the Scripts article.</p><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_scripts.html" title="Scripts">Scripts</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_script"></span>\#script

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #script
    [scriptcommand1]
    [scriptcommand2]
     ...
    [scriptcommandn]
    #endscript
```

<span class="strong">**Explanation:**</span>

The `#script` block is used to create small sections of code which
GCBASIC runs during compilation. A detail explanation and example are
included in the Scripts article.

<span class="strong">**See Also**</span>
<a href="scripts" class="link" title="Scripts">Scripts</a>

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#startup</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__script.html" title="#script"><link rel="next" href="__mem.html" title="#mem"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__startup"></a>#startup</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #startup <span class="emphasis"><em>SubName</em></span>  [<span class="emphasis"><em>priority</em></span>]</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p><code class="literal">#startup</code> is used in include files to automatically insert initialization routines. If a define or subroutine from the file is used in the program, then the specified subroutine will be called.</p><p>The <code class="literal">priority</code> to #startup support the setting of the priority of the subroutines for all the libraries in a project.</p><p>Subroutines will be called in order from smallest to largest priority number.</p><pre class="literallayout">InitSys has priority 80, lowlevel communication routines have the priority of 90
All other subroutines defaults to 100.</pre><p><span class="strong"><strong>Notes:</strong></span>
Limitations on this directive are:</p><p><code class="literal">startup</code> may only occur once within a source file.</p><p>No parameters can be passed the the subroutine that is specificed.</p><p><span class="strong"><strong>Example 1:</strong></span></p><p>This example from the hardware I2C library set the subroutine with the priority of 90.</p><pre class="screen">    #startup HIC2Init, 90</pre><p><span class="strong"><strong>Example 2:</strong></span></p><p>This example from would be included in user code to ensure the PPS setting are set prior to use of the MSSP or USART.</p><pre class="screen">    #chip 16f18855,32
    #option explicit

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      RC0PPS = 0x0010       'RC0-&gt;EUSART:TX;
      RXPPS  = 0x0011       'RC1-&gt;EUSART:RX;

      SSP1CLKPPS = 0x14     'RC3-&gt;MSSP1:SCL1;
      SSP1DATPPS = 0x13     'RC4-&gt;MSSP1:SDA1;
      RC3PPS = 0x15         'RC3-&gt;MSSP1:SCL1;
      RC4PPS = 0x14         'RC4-&gt;MSSP1:SDA1;
    End Sub</pre></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_startup"></span>\#startup

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #startup SubName  [priority]
```

<span class="strong">**Explanation:**</span>

`#startup` is used in include files to automatically insert
initialization routines. If a define or subroutine from the file is used
in the program, then the specified subroutine will be called.

The `priority` to \#startup support the setting of the priority of the
subroutines for all the libraries in a project.

Subroutines will be called in order from smallest to largest priority
number.

``` literallayout
InitSys has priority 80, lowlevel communication routines have the priority of 90
All other subroutines defaults to 100.
```

<span class="strong">**Notes:**</span> Limitations on this directive
are:

`startup` may only occur once within a source file.

No parameters can be passed the the subroutine that is specificed.

<span class="strong">**Example 1:**</span>

This example from the hardware I2C library set the subroutine with the
priority of 90.

``` screen
    #startup HIC2Init, 90
```

<span class="strong">**Example 2:**</span>

This example from would be included in user code to ensure the PPS
setting are set prior to use of the MSSP or USART.

``` screen
    #chip 16f18855,32
    #option explicit

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      RC0PPS = 0x0010       'RC0->EUSART:TX;
      RXPPS  = 0x0011       'RC1->EUSART:RX;

      SSP1CLKPPS = 0x14     'RC3->MSSP1:SCL1;
      SSP1DATPPS = 0x13     'RC4->MSSP1:SDA1;
      RC3PPS = 0x15         'RC3->MSSP1:SCL1;
      RC4PPS = 0x14         'RC4->MSSP1:SDA1;
    End Sub
```

</div>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>#UNDEFINE</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_compiler_directives.html" title="Compiler Directives"><link rel="prev" href="__define.html" title="#DEFINE"><link rel="next" href="__if.html" title="#if"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__undefine"></a>#UNDEFINE</h3></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><pre class="screen">    #UNDEFINE <span class="emphasis"><em>existing-symbol</em></span></pre><p><span class="strong"><strong>Explanation:</strong></span>
<br>
<br>
<code class="literal">#UNDEFINE</code> Undefines a symbol previously defined with #DEFINE.</p><p>Can be used to ensure that a symbol has a limited lifespan and does not conflict with a similar macro definition that may be defined later in the source code.</p><p>(Note: #UNDEFINE should not be used to undefine variable or function names used in the current program. The names are needed internally by the compiler and removing them can cause strange and unexpected results.)
<br>
<br></p><p><span class="strong"><strong>See Also</strong></span> <a class="link" href="_constants.html" title="Constants">Defines</a></p></div></body></html><div class="section">

<div class="titlepage">

<div>

<div>

### <span id="_undefine"></span>\#UNDEFINE

</div>

</div>

</div>

<span class="strong">**Syntax:**</span>

``` screen
    #UNDEFINE existing-symbol
```

<span class="strong">**Explanation:**</span>  
  
`#UNDEFINE` Undefines a symbol previously defined with \#DEFINE.

Can be used to ensure that a symbol has a limited lifespan and does not
conflict with a similar macro definition that may be defined later in
the source code.

(Note: \#UNDEFINE should not be used to undefine variable or function
names used in the current program. The names are needed internally by
the compiler and removing them can cause strange and unexpected
results.)  
  

<span class="strong">**See Also**</span>
<a href="constants" class="link" title="Constants">Defines</a>

</div>
