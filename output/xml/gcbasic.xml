<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>GCBASIC documentation</title>
<date>2024-07-12</date>
<author>
<personname>
<firstname>The GCBASIC development team @ 2024</firstname>
</personname>
</author>
<authorinitials>T</authorinitials>
</info>
<section xml:id="_introducing_gcbasic">
<title>Introducing GCBASIC</title>
<simpara>Hello, and welcome to GCBASIC help. This help file is intended
to provide you insights and knowledge to use GCBASIC.</simpara>
<simpara>For information on installing GCBASIC and several other programs that
may be helpful, please see <emphasis role="strong">Getting Started with GCBASIC</emphasis></simpara>
<simpara>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;http://gcbasic.sourceforge.net/starting.html</simpara>
<simpara>If you are new to programming, you should try the GCBASIC
demonstration programs these explains everything in a step-by-step manner, and assumes
no prior knowledge.</simpara>
<simpara>If you have programmed in another language, then the demonstration files on GitHub ( or within your installation )
and this command reference may be the best place to start.</simpara>
<simpara>If there is anything else that you need help on, please visit the <emphasis role="strong">GCBASIC forum</emphasis></simpara>
<simpara>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;http://sourceforge.net/forum/?group_id=169286</simpara>
</section>
<section xml:id="_using_gcbasic">
<title>Using GCBASIC</title>
<simpara>Need to compile a program with GCBASIC, but don&#8217;t know where to begin? Try these simple instructions:
<?asciidoc-br?>
<?asciidoc-br?>
 - Complete the installation using the default values - select all the programmers but not the portable mode.
<?asciidoc-br?>
<?asciidoc-br?>
 - The installer will automatically start the IDE.
<?asciidoc-br?>
<?asciidoc-br?>
 - When a GCBASIC source file is opened, check out the “GCB tools” menu ( IDE Tools / GCB tools ) - through this menu you can access the oneclick commands. Or try the right mouse button - this will access the same options.
<?asciidoc-br?>
<?asciidoc-br?>
 - The IDE Tools&#8230;&#8203; commands (function keys F5 - F8) starts a GCBASIC utility which calls the batchfiles for compiling sourcecode and programming
   ("flashing")<phrase role="small"><superscript>(1)</superscript></phrase> the target microcontroller.   You have to select the appropriate programmer in “Edit Programmer Preferences” ( IDE Tools / GCB tools / Edit Programmer Preferences or by pressing Ctrl+Alt+E ).  Find your programmer in the list and drag it to the top beneath the heading “Programmers to use (in order)”. GCBASIC will now attempt to flash the microcontroller with that programmer first when you click on "Make HEX and FLASH" ( F5 ) or "FLASH previous made hexfile" ( F8 ).
<?asciidoc-br?>
<?asciidoc-br?>
 - In the unlikely event that your programmer is not listed you can add it by pressing “Add…” in “Edit Programmer Preferences”.  You would have to know the working directory and command line options etc. for the programmer.  See the help tips at the bottom by clicking on the fields.
<?asciidoc-br?>
<?asciidoc-br?>
 - For project-specific flashing you can edit the current programmers in “Edit Programmer Preferences” to suit your needs by clicking on “Edit…”. Use the “Use If:” parameter to choose programmer preferences. See the help tips. The chip model is autodetected by the IDE for use in “Use IF:” or in command line options etc.
<?asciidoc-br?>
<?asciidoc-br?>
 - Some programmers use a .hex file to "flash" the microcontroller.  By selecting "Make HEX" ( F5 ), GCBASIC will compile the program and make a .hex file in the same directory as the GCBASIC file.  This method can also be used to check for errors in the GCBASIC program before flashing.
<?asciidoc-br?>
<?asciidoc-br?>
   - Included programmer software is:
<?asciidoc-br?>
   &#8201;&#8212;&#8201;Avrdude for AVR,
<?asciidoc-br?>
   &#8201;&#8212;&#8201;PICPgm for PIC,
<?asciidoc-br?>
   &#8201;&#8212;&#8201;PicKit2 and PicKit3
<?asciidoc-br?>
   &#8201;&#8212;&#8201;TinyBootLoader+
<?asciidoc-br?>
   &#8201;&#8212;&#8201;Arduino
<?asciidoc-br?>
   &#8201;&#8212;&#8201;Northern Software Programmer
<?asciidoc-br?>
   &#8201;&#8212;&#8201;Microchip Xpress Board and many, many more.</simpara>
<simpara><phrase role="small"><superscript>(1)</superscript> You need a suitable programmer to do this, and instructions should be
included with the programmer on how to download and connect the hardware to the microcontroller.</phrase>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Programmer Preferences</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The “Programmer Preferences” is a software tool to control and set-up the different programmers.  See below:
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">When using GC Code at the IDE</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
Select Terminal/Run Task or press function &lt;F4&gt; to see the menu
<?asciidoc-br?>
<?asciidoc-br?>
<inlinemediaobject>
<imageobject>
<imagedata fileref="./images/Prefs1.gif" contentwidth="640" contentdepth="480"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</inlinemediaobject>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Or, when using GC Code at the IDE</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
Select the drop down menu to see the menu
<?asciidoc-br?>
<?asciidoc-br?>
<inlinemediaobject>
<imageobject>
<imagedata fileref="./images/Prefs2.gif" contentwidth="640" contentdepth="480"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</inlinemediaobject>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">When using SynWrite at the IDE</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
<inlinemediaobject>
<imageobject>
<imagedata fileref="./images/PPtool.gif" contentwidth="640" contentdepth="480"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</inlinemediaobject>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_pic_users_and_beginners_start_here">
<title>PIC users and Beginners: Start Here</title>
<simpara>Welcome to GCBASIC.&#160;&#160;This document is especially important for experienced PIC users moving from MPASM or C so please spend a few seconds here before you start.&#160;&#160; It could save you hours of frustration.</simpara>
<simpara>As a PIC user most of us are conditioned, regardless of the Assembler or Compiler, to reach for the devices data sheet first and try to work out how to setup the Oscillator, interrupt vectors and Configuration bits.</simpara>
<simpara><emphasis role="strong">Do not DO IT</emphasis>.&#160;&#160; read this document first as it will give you some great insights. &#160;&#160; For the basic operation the only setup and configuration required for a GCBASIC program is the name of the target Device i.e. <literal>#Chip 16f1619</literal>.  &#160;&#160;   That is it, honestly, GCBASIC will do the rest and will determine the optimal Oscillator settings, interrupt vectors, Configuration bits etc</simpara>
<simpara>Next we would  start deciding on and including the Device files and libraries that we intend to use.&#160;&#160;<emphasis role="strong">STOP</emphasis>.&#160;&#160; Let GCBASIC decide. &#160;&#160; GCBASIC is creating Portable Code, it doesn’t care if you use a PIC12, PIC18 or an ATmega328.&#160;&#160;  You write in BASIC and at compile time GCBASIC will decide which core libraries to include based on the instructions you have used and the target device you specified in the #chip statement.</simpara>
<simpara>Finally we would decide on the pins to use, their port names, which register bits are needed to make them inputs or outputs and override any Analog function if a digital function is desired.</simpara>
<simpara>Again,  I say let GCBASIC DO IT&#8230;&#8203;&#8230;&#8203;&#8230;&#8203; <literal>Dir PortC.0 In</literal> - Will set Pin RC0 to a Digital Input. &#160;&#160; There is no need to manually set the TRIS register or see if there is an associated ADCON bit to set or clear.</simpara>
<simpara>Putting it all together: An example GCBASIC program.</simpara>
<screen>    #Chip 16f1619

    #Define LED PortC.0

    Dir LED Out

    Do
      LED = !LED
      Wait 500 ms
    Loop</screen>
<simpara>That is it. If you have an LED attached to PortC.0 (LED DS1 on the Low Pin Count Board that shipped with the PICKit 2 or PICKit 3 programmer).&#160;&#160;  It will start to Blink confirming that you have a working microcontroller and hardware.</simpara>
<simpara>To change target device or family just change the #Chip Entry along with the Pin you have the LED on and recompile.&#160;&#160; it Really IS as Simple as that to get started in GCBASIC.</simpara>
<simpara>You can manually override GCBASIC and set every register, every flag, every BIT, every Configuration ‘Fuse’ and every vector if you wish, but why bother doing it upfront? &#160;&#160;Rather get your code working with the default settings and then adjust from there, if needed, as your confidence grows.</simpara>
<simpara>One final bit of advice, the IDE tool bar has a “View Demos” button, use it, there are examples of all of the most common programming challenges and many different devices which, along with the Help files, will answer most of your questions. The Forum is a friendly place too, so do not be shy to introduce yourself and ask for help.</simpara>
</section>
<section xml:id="_changes">
<title>Changes</title>
<simpara><emphasis role="strong">Formal Release of GCBASIC Compiler v1.xx.xx</emphasis></simpara>
<simpara><?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="60%"?>
<?dbfo table-width="60%"?>
<?dblatex table-width="60%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="128*"/>
<colspec colname="col_2" colwidth="128*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Reference</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Time Stamp</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>ASCIIDOCs rendered</simpara></entry>
<entry align="center" valign="top"><simpara>2024-08-24<?asciidoc-br?>
09:08:07 GMT Summer Time</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Master ToC information</simpara></entry>
<entry align="center" valign="top"><simpara>2024-07-12<?asciidoc-br?>
16:17:36 GMT Summer Time</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?></simpara>
</section>
<section xml:id="_command_line_parameters">
<title>Command Line Parameters</title>
<simpara><emphasis role="strong">About the Command Line Parameters</emphasis></simpara>
<screen>    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/H:[Y/1 | N/0]] [/V] [/L] [/NP] [/M:[Y/1 | N/0]]  <emphasis>filename</emphasis>

    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/H:[Y/1 | N/0]] [/V] [/L] [/WX] [/M:[Y/1 | N/0]] [/NP] <emphasis>filename</emphasis>

    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/H:[Y/1 | N/0]] [/V] [/L] [/WX] [/M:[Y/1 | N/0]] [/S:Use.ini] [/NP] <emphasis>filename</emphasis>

    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/H:[Y/1 | N/0]] [/V] [/L] [/WX] [/M:[Y/1 | N/0]]  [/S:Use.ini] [/F[O]] [/NP] <emphasis>filename</emphasis>

    GCBASIC /version</screen>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="50*"/>
<colspec colname="col_3" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Switch</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>/O:<emphasis>filename</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the name of the assembly file generated to <literal><emphasis>filename</emphasis></literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Same name as the input file, but with a <literal>.asm</literal> extension.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/A:assembler</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Batch file used to call assembler<superscript>(1)</superscript>. If <literal>/A:GCASM</literal> is given, GCBASIC will use its internal assembler.</simpara></entry>
<entry align="left" valign="top"><simpara>The program will not be assembled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/CP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Exports the config bits automatically selected by the compiler to an output file called <literal>source_filename.config</literal>.  The output file is the source filename with the extension of config.</simpara></entry>
<entry align="left" valign="top"><simpara>None</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/H:[Y/1 | N/0]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the production, or not, of the hex output file.  /H:1 is the default.  To prevent production of the hex output file - use /H:0</simpara></entry>
<entry align="left" valign="top"><simpara>The default is to produce the hex output file</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/M:[Y/1 | N/0]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Mute the banner messages, or not.  /M:1 is the default.  To prevent banner messages - use /M:0</simpara></entry>
<entry align="left" valign="top"><simpara>The default is to output banner messages</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/P:programmer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Batch file used to call programmer<superscript>(1)</superscript>. This parameter is ignored if the program is not assembled.</simpara></entry>
<entry align="left" valign="top"><simpara>The program will not be downloaded.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/K:[C|A]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Keep original code in assembly output. <literal>/K:C</literal> will save comments, <literal>/K:A</literal> will preserve all input code.</simpara></entry>
<entry align="left" valign="top"><simpara>No original code left in output.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/V[:[0|F][1|T]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Verbose mode - compiler gives more detailed information about its activities.
/Vx will overide any configuration in the user ini file.</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/L</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Show license and exit.</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/NP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Do not pause on errors. Use with IDEs.</simpara></entry>
<entry align="left" valign="top"><simpara>Pause when an error occurs, and wait for the user to press a key.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/WX</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Force compiler to ensure all include files are valid.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Shown build date and version of the compiler.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/S:fsp</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Load the settings from a specified file, rather than use the defaults.</simpara></entry>
<entry align="left" valign="top"><simpara>/S:use.ini</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/F[:[0|F][1|T]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used to bypass compilation when not needed, compiler will verify that config settings in the already compiled file match those required for the programmer. If not, a recompilation will be forced.
 Skip compilation if the hex file is up to date and has correct config.
/F:x ( F or 0) to force a fresh compile regardless of what ini specifies.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/FO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used to bypass compilation and program only.  Compiler will verify that config settings in the already compiled file match those required for the programmer. If not, a recompilation will be forced.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>filename</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The file to compile.</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><phrase role="small"><superscript>(1)</superscript> For the <literal>/A:</literal> and <literal>/P:</literal> switches, there are special options available. If
<literal>%FILENAME%</literal> is present, it will be replaced by the name of the <literal>.asm</literal> file.
<literal>%FN_NOEXT%</literal> will be replaced by the name of the <literal>.asm</literal> file but without an
extension, and <literal>%CHIPMODEL%</literal> will be replaced with the name of the chip.
The name of the chip will be the same as that on the chip data file.</phrase></simpara>
<simpara>A batch file to load the <literal>ASM</literal> from GCBASIC into <literal>MPASM</literal>. Command line should be like this:</simpara>
<screen>    C:\progra~1\microc~1\mpasms~1\MPASMWIN /c- /o- /q+ /l- /x- /w1 %code%.asm</screen>
<simpara>A batch file to compile in GCBASIC then load the <literal>ASM</literal> from GCBASIC into <literal>GPASM</literal>. Command line should be like this:</simpara>
<screen>    gcbasic.exe %1 /NP /K:A /A:"..\gputils\bin\gpasm.exe %~d1%~p1%~n1.asm"</screen>
<simpara>To instruct MAKEHEX.BAT to use <literal>GPASM</literal>.   You have GPUTILS installed.  The batch file should be edited as follows:</simpara>
<screen>    REM Create the ASM
    gcbasic.exe /NP /K:A %1
    REM Use GPASM piping to the GCB error log
    gpasm.exe "%~d1%~p1%~n1.asm" -k -i -w1 &gt;&gt; errors.txt</screen>
<simpara>To summarise, you can use any of the following:</simpara>
<screen>    gcbasic.exe filetocompile.gcb /A:GCASM /P:"icprog -L%FILENAME%" /V /O:compiled.asm</screen>
<simpara>GCBASIC will compile the file, then assemble the program, and run this command:</simpara>
<screen>    `icprog -Lcompiled.hex`</screen>
<simpara>You can also create/edit the gcbasic.ini file :</simpara>
<screen>Assembler settings
    Assembler = C:\Program Files\Microchip\MPASM Suite\mpasmwin
    AssemblerParams = /c- /o- /q+ /l+ /x- /w1 "%FileName%"

Programmer settings
    Programmer = C:\Program Files\WinPic\Winpic.exe
    ProgrammerParams = /device=PIC%ChipModel% /p "%FileName%"</screen>
<simpara>This example will use MPASM to assemble the program. It will run the program specified in the assembler = line, and give it these parameters:</simpara>
<screen>    `/c- /o- /q+ /l+ /x- /w1 "compiled.asm"`</screen>
<simpara>Then, it will run the programmer, and give it these parameters when it calls it:</simpara>
<screen>    `/device=PIC16F88 /p "compiled.hex"`</screen>
<simpara><literal>%ChipModel%</literal> will get replaced with the chip you are using, so this the chip GCBASIC will pass to WinPIC.</simpara>
<simpara><emphasis role="strong">Errors.txt</emphasis></simpara>
<simpara>The compiler only produces the file errors.txt if there is an error. The creation of the errors.txt file makes it easier for IDEs to detect if the program compiled successfully - if the file was not produced then the IDE would be unalbe to present the error message to the user.</simpara>
<simpara>The file error.txt is always produced in the same folder as the compiler.  Typically: C:\GCStudio\GCBASIC\Errors.txt</simpara>
<simpara><emphasis role="strong">USE.INI</emphasis></simpara>
<simpara>USE.INI is the provided setup file for the compiler.&#160;&#160;The name of <literal>use.ini</literal> is historic and of no relevance.</simpara>
<simpara>USE.INI is generally updated by using the <literal>PREFERENCES EDITOR</literal>.&#160;&#160;</simpara>
<simpara>USE.INI is self documenting and open <literal>use.ini</literal> in an editor will shown the full capabilities of setting file.</simpara>
<simpara>The details below show the self documentation in a typical <literal>use.ini</literal></simpara>
<screen>Preferences file for GC BASIC
Location: GCB install (or custom) dir

Documentation for the [gcbasic] section of the use.ini file
    programmer = arduinouno   - the currently selected available programmers
    showprogresscounters = n  - show percent values as compiler runs. requires Verbose = y
    verbose = y               - show verbose compiler information
    preserve = n              - preservice source program in ASM
    warningsaserrors = n      - treat Warnings from scripts as errors.
    pauseaftercompile = n     - pause after compiler. Do not do this with IDEs
    flashonly = n             - Flash the chip is source older that hex file
    assembler = GCASM         - currently selected Assembler
    hexappendgcbmessage = n   - appends a message in the HEX file
    laxsyntax = n             - use lax syntax when Y, the compiler will not check that reserved words
    mutebanners = n           - mutes the post compilation messages
    evbs = n                  - show extra verbose compiler information, requires Verbose = y
    nosummary = n             - mutes almost all messages psot compilation
    extendedverbosemessages = n  - show even more verbose compiler information, requires Verbose = y
    conditionaldebugfile =    - creates CDF file
    columnwidth = 180         - ASM width before wrapping
    picasdebug = n            - adds PIC-AS preprocessor message to .S file
    datfileinspection = y     - inspects DAT for memory validation
    methodstructuredebug  = n - show method structure start &amp; end for validation
    floatcapability =  1      - 1 = singles
                             - 2 = doubles
                             - 4 = longint
                             - 8 = uLongINT
    compilerdebug =  0       - 1 = COMPILECALCADD
                             - 2 = VAR SET
                             - 4 = CALCOPS
                             - 8 = COMPILECALCMULT
                             - 16 = AUTOPINDIR
                             - 32 = ADRDX
                             - 64 = GCASM</screen>
</section>
<section xml:id="_frequent_errors">
<title>Frequent errors</title>
<simpara><phrase role="red">Frequent errors that may happen, from the initial creation of a program and onwards.</phrase></simpara>
<simpara><phrase role="red">Strange timings:</phrase>  You declared an oscillator frequency, different from the oscillator actually attached to the micrcontroller.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">No oscillator:</phrase>  Keep in mind that, besides the frequency, you must also set the type of oscillator, internal or external.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">No GCBASIC frequency stated:</phrase> If not declared in your source program - GCBASIC uses a preset frequency suitable for operating the microcontroller as the fastest practical.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">External oscillators:</phrase> It must be explicitly stated, if not stated GCBASIC  will attempt to setup the internal oscillator.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Ports:</phrase> GCBASIC will set the ports automatically but you may need to set the ports outputs or inputs when needed.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Analog levels:</phrase>  When applied on the ports defined as digital inputs. can cause current consumption in the input buffer, which is outside the device specifications. Beware.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Current drawn:</phrase> Current taken from the microcontroller outputs, exceeding the maximum allowed (not all pins supply the same current).  Beware of drawing to much current.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Watchdog Timer (WDT):</phrase> The WDT is a useful timer.  Enable to reset the microcontroller when processing can get stuck in a loop.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Interrupts:</phrase> A badly controlled interrupt (in some cases) will prevent the execution of the entire program.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">No action:</phrase> The circuit is not powered.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Still no action:</phrase> The microcontroller is not present or different from the device you expected.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Still no action:</phrase> The microcontroller inserted incorrectly in the appropriate socket.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Cannot program:</phrase> Incorrect programmer, Incorrect programmer parameters or circuit connections are incorrect.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Still Cannot program:</phrase> Values of excessively incorrect circuit resistances.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Serial Communcations:</phrase> The TX and RX pins of the serial port are exchanged, and/or the connections with the level converter, ttl / rs232 or ttl / usb.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Stlll no Serial Communcations:</phrase> Serial speed, different from the one set in the circuit with which it is intended to communicate or vice versa.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">No I2C/TWI:</phrase>  SDL and/or SCL pin exchanged on the I2C/TWI bus connection, and/or no pull-up resistors, and/or no common 0 voltage.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Incorrect timing:</phrase> Calculation of any timings related to the frequency of the external oscillator, without taking into account the division by 4.
<?asciidoc-br?>
<?asciidoc-br?>
<phrase role="red">Strange Numeric Values:</phrase> The variables declared are insufficient to contain the values ​​to be processed.
<?asciidoc-br?></simpara>
</section>
<section xml:id="_a_glossary">
<title>A Glossary</title>
<simpara><phrase role="red">ADC:</phrase> analogue digital converter.</simpara>
<simpara><phrase role="red">Negative power supply:</phrase> reference to the common point of the circuit power supply, called circuit ground.</simpara>
<simpara><phrase role="red">Alias:</phrase> alternative name assigned to a pre-existing entity.</simpara>
<simpara><phrase role="red">Array:</phrase> variable able to handle numbers from 0 to 255.</simpara>
<simpara><phrase role="red">ASCII:</phrase> acronym for the American Standard Code for information interchange. ASCII is a code for the representation of English characters as numbers.</simpara>
<simpara><phrase role="red">Assembler:</phrase> PC software application that converts assembly language into machine language.</simpara>
<simpara><phrase role="red">Binary:</phrase> numeric system with base 2, in which there are only two possible values for each digit#0 and 1.</simpara>
<simpara><phrase role="red">Bit:</phrase> the smallest element of computer memory. It is a single digit in a binary number (0 or 1). Bit is also a type of variable in GCBASIC.</simpara>
<simpara><phrase role="red">Bitwise:</phrase> dealing with bits and binary states instead of numbers or logic.</simpara>
<simpara><phrase role="red">Byte:</phrase> 8-bit variable, value from 0 to 255 (2^ 8-1). Is also a type of variable in GCBASIC.</simpara>
<simpara><phrase role="red">Boolean:</phrase> related to a combinatorial system designed by George Boole, which combines propositions with the logical operators AND, OR and IF THEN, except NOT.</simpara>
<simpara><phrase role="red">CC:</phrase> direct current.</simpara>
<simpara><phrase role="red">Machine cycle:</phrase> oscillator frequency / 4, for PIC (do not forget the PLL where present).</simpara>
<simpara><phrase role="red">Code:</phrase> the memory area in a PIC MCU or AVR that contains the program code.</simpara>
<simpara><phrase role="red">Comment:</phrase> reminder notes placed in the program.</simpara>
<simpara><phrase role="red">Compiler:</phrase> PC software application, which converts a high level language like BASIC into assembly language. In this guide "Compiler" refers to GCBASIC.</simpara>
<simpara><phrase role="red">Compile-Time:</phrase> acts during compilation, and is not executed as a command when the program is running on the microcontroller.</simpara>
<simpara><phrase role="red">Constant:</phrase> a name that stands for a value defined in the program. The value is replaced instead of the name when the program is compiled and assembled. It is not stored in RAM and cannot be changed during program execution.</simpara>
<simpara><phrase role="red">D:</phrase> Digital.</simpara>
<simpara><phrase role="red">Data Space:</phrase> is a memory space in a PIC or AVR that is intended for the storage of values ​​(EEPROM memory on chip). Data is accessible in GCBASIC using the EpRead and EpWrite commands for reading and writing.</simpara>
<simpara><phrase role="red">Dw:</phrase> referring to a button or actions for the variation of any value, is intended as "decrease".</simpara>
<simpara><phrase role="red">Debug:</phrase> used to locate errors, to solve problems encountered when the program is run.</simpara>
<simpara><phrase role="red">Decimal:</phrase> numerical system with base 10, composed of 10 numbers from 0 to 9 inclusive. The "point" in a number with base 10 separates the whole part from the bottom to 1.</simpara>
<simpara><phrase role="red">Device programmer:</phrase> it is a tool that "writes" the code in machine language in the PIC or AVR microcontroller.</simpara>
<simpara><phrase role="red">Directive:</phrase> instruction intended for the compiler or assembler. It is not a command or a compiler statement.</simpara>
<simpara><phrase role="red">Emdedded System:</phrase> device controlled by a program, able to independently perform even complex functions, communicate with other similar devices and different architecture, with the personal computer, with a local network and directly via the web.</simpara>
<simpara><phrase role="red">EPROM:</phrase> erasable programmable read only memory.</simpara>
<simpara><phrase role="red">EEPROM:</phrase> a type of memory that stores data even in the absence of voltage, can be deleted and rewritten about 100,000 times.</simpara>
<simpara><phrase role="red">Expression:</phrase> a variable, constant, or combination that represents a stored or calculated value.</simpara>
<simpara><phrase role="red">Firmware:</phrase> program compiled and assembled, suitable to be loaded into the program memory, of a programmable device.</simpara>
<simpara><phrase role="red">Fosc:</phrase> oscillator frequency.</simpara>
<simpara><phrase role="red">f.s.:</phrase> full scale.</simpara>
<simpara><phrase role="red">Hex:</phrase> extension of the assembled file.</simpara>
<simpara><phrase role="red">IDE:</phrase> integrated development environment, software environment that acts as a code editor, and controls the various programming tools to implement software development.</simpara>
<simpara><phrase role="red">Set:</phrase> write in a register or variable, the condition required by the function to be performed.</simpara>
<simpara><phrase role="red">I / O:</phrase> input / output.</simpara>
<simpara><phrase role="red">Integer:</phrase> 32-bit variable, whose value varies from -32768 to 32767. Is also a type of variable in GCBASIC.</simpara>
<simpara><phrase role="red">Interrupt:</phrase> the use of a predefined signal or condition that interrupts normal execution, in favor of a special procedure with high priority.</simpara>
<simpara><phrase role="red">Kbit / s:</phrase> one thousand bits per second.</simpara>
<simpara><phrase role="red">Keywords:</phrase> keywords for GCBASIC.</simpara>
<simpara><phrase role="red">Label:</phrase> word that marks a position in a program.</simpara>
<simpara><phrase role="red">Least-significant:</phrase> in reference to binary numbers, a bit or groups of bits that include the "proper" bit. The rightmost bit or bit group, when a number is written in binary.</simpara>
<simpara><phrase role="red">Assembly language:</phrase> the programming language that corresponds more closely with machine language codes.</simpara>
<simpara><phrase role="red">Voltage levels:</phrase> in this guide we refer to TTL levels, so about 0 Volts for the low level and about 5 Volts or the Vcc of the microcontroller for the high level.</simpara>
<simpara><phrase role="red">Level 0:</phrase> equivalent to the low level.</simpara>
<simpara><phrase role="red">Level 1:</phrase> equivalent to the high level.</simpara>
<simpara><phrase role="red">High level:</phrase> presence of voltage, referring to the particular one is talking about.</simpara>
<simpara><phrase role="red">Low level:</phrase> no voltage, voltage close to zero.</simpara>
<simpara><phrase role="red">Long:</phrase> numeric entity composed of 32 binary bits, value from 0 to 4294967295 (2^32-1).Is also a type of variable in GCBASIC.</simpara>
<simpara><phrase role="red">FLASH MEMORY:</phrase> non-volatile memory, electrically rewritable numerous times, also called flash / rom.</simpara>
<simpara><phrase role="red">Microchip:</phrase> company that produces PIC microcontrollers, now also AVR</simpara>
<simpara><phrase role="red">Mips:</phrase> Mega instructions per second.</simpara>
<simpara><phrase role="red">ms:</phrase> milliseconds.</simpara>
<simpara><phrase role="red">Modifier:</phrase> keyword that somehow changes the interpretation or behavior associated with a command or variable that is written before or after the modifier.</simpara>
<simpara><phrase role="red">Most-significant:</phrase> in reference to binary numbers, the bit or group of bits that include the bit that indicates the maximum power of two. The leftmost bit or group of bits when a number is written in binary.</simpara>
<simpara><phrase role="red">Nibble:</phrase> a 4-bit binary quantity, can often be used to refer to the 4 most significant or least significant bits of 8-bit bytes. A single hexadecimal digit represents a binary nibble. It is not a variable type in GCBASIC.</simpara>
<simpara><phrase role="red">ns:</phrase> nanoseconds.</simpara>
<simpara><phrase role="red">NC:</phrase> not connected or, normally closed (depending on the context).</simpara>
<simpara><phrase role="red">Overflow:</phrase> the event that occurs when a value in a variable is increased beyond the capacity of the variable type, resulting in an incorrect result.</simpara>
<simpara><phrase role="red">PC or pc:</phrase> program counter.</simpara>
<simpara><phrase role="red">Port:</phrase> microcontroller port</simpara>
<simpara><phrase role="red">Porta:</phrase> Port a.</simpara>
<simpara><phrase role="red">Portb:</phrase> Port b.</simpara>
<simpara><phrase role="red">Portc:</phrase> Port c.</simpara>
<simpara><phrase role="red">Portd:</phrase> Port d.</simpara>
<simpara><phrase role="red">Porte:</phrase> Port e.</simpara>
<simpara><phrase role="red">Pos or pos:</phrase> postscaler.</simpara>
<simpara><phrase role="red">Ps or ps:</phrase> Prescaler</simpara>
<simpara><phrase role="red">Programmer:</phrase> you. The person who writes the program.</simpara>
<simpara><phrase role="red">RAM:</phrase> the memory area in a PIC MCU that is used to contain the variables. Access to RAM is faster than other memory areas, RAM values ​are lost when the power is turned off.</simpara>
<simpara><phrase role="red">Register:</phrase> an 8-bit memory location that performs a special function in a microcontroller. Registers that (Microchip calls SFR) are integrated in the microcontroller and their functions are described in the technical data sheet published for the device.</simpara>
<simpara><phrase role="red">ROM:</phrase> Read Only Memory (read-only memory, can only be written once).</simpara>
<simpara><phrase role="red">Run-time:</phrase> executed by the microcontroller when the program is executed (when it is running).</simpara>
<simpara><phrase role="red">Save to context:</phrase> save and restore in the context of the interrupt, important variables in the SFR registers.</simpara>
<simpara><phrase role="red">SFR:</phrase> registers with special function. Able to represent or process negative and positive numbers.</simpara>
<simpara><phrase role="red">String:</phrase> able to deal with number, letters and symbols. Is also a type of variable in GCBASIC.</simpara>
<simpara><phrase role="red">TMR or tmr:</phrase> timer.</simpara>
<simpara><phrase role="red">TWI:</phrase> I²C Bus.</simpara>
<simpara><phrase role="red">Two&#8217;complement:</phrase> (complement of 2) a system that allows negative numbers to be represented in binary.</simpara>
<simpara><phrase role="red">Typecasting:</phrase> specify a type of variable for the compiler.</simpara>
<simpara><phrase role="red">Tp:</phrase> test point.</simpara>
<simpara><phrase role="red">Up:</phrase> referred to a button or actions to change any value, it is intended as "increase".</simpara>
<simpara><phrase role="red">Underflow:</phrase> the event that occurs when a value in an unsigned variable decreases below zero (negative number), or when a variable is decreased below the limit value in a negative sense, resulting in an incorrect result.</simpara>
<simpara><phrase role="red">Unsigned:</phrase> only able to represent or transform positive numbers. Negative numbers are not valid in integer variables.</simpara>
<simpara><phrase role="red">Variable:</phrase> a name that is a synonym of a value that is stored in RAM and can be read and modified during program execution.</simpara>
<simpara><phrase role="red">Word:</phrase> a numeric entity composed of 16 binary bits. Value from 0 to 65535 (2^16-1)</simpara>
<simpara><phrase role="red">V / I:</phrase> voltage / current.</simpara>
<simpara><phrase role="red">µs or us:</phrase> microseconds.</simpara>
</section>
<section xml:id="_frequently_asked_questions">
<title>Frequently Asked Questions</title>
<simpara><emphasis role="strong">Why doesn&#8217;t anything come up when I run GCBASIC.exe?</emphasis></simpara>
<simpara>GCBASIC IS a command line compiler. To compile a file, you can
drag and drop it onto the GCBASIC.exe icon.</simpara>
<simpara>If you use an Integrated Development Environment (IDE) you can edit your program and press an ICON  to send the program to the chip. Several are listed on the GCBASIC website.</simpara>
<simpara>The recommended IDE for Windows is GCCODE.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">What Microchip PIC, Atmel AVR or LGT microcontrollers does GCBASIC support?</emphasis></simpara>
<simpara>Hopefully, all 8 bit Microchip PIC, Atmel AVR and LGT microcontrollers and (those in the PIC10, PIC12, PIC16 and PIC18 families). If you find one that GCBASIC does not work with
properly, please post about it in the Compiler Problems section of the
GCBASIC forum.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Is GCBASIC case sensitive?</emphasis></simpara>
<simpara>No! For example, <literal>Set</literal>, <literal>SET</literal>, <literal>set</literal>, <literal>SeT</literal>, etc are all treated exactly the
same way by GCBASIC.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Can I specify the bit of a variable to alter using another variable?</emphasis></simpara>
<simpara>GCBASIC support bitwise assignments. As follows:</simpara>
<screen>    portc.0 = !porta.1</screen>
<simpara>You can also use a shift function.  As in other languages, by using the Shift Function FnLSL.  AN example is:</simpara>
<screen>    MyVar = FnLSL( 1, BitNum)`  is Equivalent to `MyVar = 1&lt;&lt;BitNum`</screen>
<simpara>To set a bit of a port and to prevent glitches during operations, use <literal>#option volatile</literal> as folllows.</simpara>
<screen>    'add this option for a specific port.
    #option volatile portc.0

    'then in your code
    portc.0 = !porta.1</screen>
<simpara>To set a bit of a port or variable. Encapsulate it in the SetWith method, this also eliminates any glitches during the update, use this method.</simpara>
<screen>    SetWith(MyPORT, MyPORT OR FnLSL( 1, BitNum))</screen>
<simpara>To clear a bit of a port, use this method.</simpara>
<screen>    MyPORT = MyPORT AND NOT FnLSL( 1, BitNum))</screen>
<simpara>To set a bit within an array, use this method.</simpara>
<screen>    video_buffer_A1(video_adress) = video_buffer_A1(video_adress) OR FnLSL( 1, BitNum)</screen>
<simpara>To set a bit within a variable, use this method.</simpara>
<screen>    Dim my_variable as byte
    Dim my_bit_address_variable as byte

    'example
    my_variable = 0
    my_bit_address_variable = 7

    my_variable.my_bit_address_variable = 1   ' where 1 or 0 or any bit address is valid

    'Sets bit 7 of my_variable therefore 128</screen>
<simpara>See also  <link linkend="_set">Set</link>, <link linkend="_fnlsl">FnLSL</link>, <link linkend="_fnlsr">FnLSR</link> and <link linkend="_rotate">Rotate</link>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Why is x feature not implemented?</emphasis></simpara>
<simpara>Because it has not been thought of, or no-one has been able to implement
it!</simpara>
<simpara>If there are any features that you would like to see in GCBASIC, please post them in the "Open Discussion" section of the GCBASIC forum. Or, if you can, have a go at adding the feature yourself!
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">When using an include file does this use lots of memory?</emphasis></simpara>
<simpara>When using include files, for instance the &lt;ds3231.h&gt; include, if
you are not using all the functions of the include file, GCBASIC knows
not to include the  unused functions within the user program when
compiling.</simpara>
<simpara><emphasis role="strong">If I am using the hardware I2C, does all the code related to hardware I2C still get compiled in the code?</emphasis></simpara>
<simpara>GCBASIC only compiles functions and subroutines if they are called.
GCBASIC starts by compiling the main routine, then anything called from
there. Each time it finds a new subroutine that is called, it compiles
it and anything that it calls. If a subroutine is not needed, it does
not get compiled.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">My LCD will not operate as expected?</emphasis></simpara>
<simpara>Try adding. <literal>#define LCD_SPEED SLOW</literal></simpara>
<simpara>This will slow the writing to the LCD.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Atmel AVR memory usage displayed is incorrect?</emphasis></simpara>
<simpara>Atmel AVR memory values are specified in WORDS in GCBASIC. The GCBASIC compiler uses words, not bytes, for consistency between Microchip PIC and Atmel AVR microcontrollers. This keeps parts of the compiler simpler.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">I cannot open the Window Help File?</emphasis></simpara>
<simpara>See <link xlink:href="http://digital.ni.com/public.nsf/allkb/B59D2B24D624B823862575FC0056F3D0">http://digital.ni.com/public.nsf/allkb/B59D2B24D624B823862575FC0056F3D0</link>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">How do I revert the FOR-NEXT loop to the Legacy FOR-NEXT method ?</emphasis></simpara>
<simpara>Some background.&#160;&#160;
In 2021 the GCBASIC compiler was updated to improve the operation of the FOR-NEXT loop.&#160;&#160;
The improvement did increase the size of the ASM generated.&#160;&#160;
The legacy FOR-NEXT loop had some major issues that included never ending loops, incorrect end loop and unexpected operations.&#160;&#160;
This was all caused by the compiler, not the user, and in 2021 the compiler was updated to resolve these issues.&#160;&#160;</simpara>
<simpara>However, there is a risk that the new FOR-NEXT method causes 1) larger ASM that will not fit in small microcontrollers or 2) the new code does not operate as expected.&#160;&#160;
In either case you can disable the new FOR-NEXT method by adding a constant as shown below.&#160;&#160;
Adding this constant will revert the FOR-NEXT loop asm generated to the legacy method.&#160;&#160;</simpara>
<screen>    #DEFINE USELEGACYFORNEXT</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_troubleshooting">
<title>Troubleshooting</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Problem</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Common Causes</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">More Assistance</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle" morerows="2"><simpara>Cannot compile a program</simpara></entry>
<entry align="left" valign="top"><simpara>There is an error in the program. Is GCBASIC complaining about a
particular line of code?</simpara></entry>
<entry align="left" valign="top"><simpara>GCBASIC Forums</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GCBASIC has not been installed correctly - reinstall it.</simpara></entry>
<entry align="left" valign="top"><simpara>GCBASIC Forums</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>There is a bug in GCBASIC</simpara></entry>
<entry align="left" valign="top"><simpara>Post on the GCBASIC Forums. Ensure you state the version of your compiler and attach your code as a ZIP.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>A program compiles and downloads fine, but will not run</simpara></entry>
<entry align="left" valign="top"><simpara>Oscillator not selected.</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="_configuration">Configuration</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_compiler_insights">
<title>Compiler Insights</title>
<simpara>This section will provide some insights into what the compiler does</simpara>
<simpara><emphasis role="strong">How does the compiler cope with read only registers in the Chip Family 12 range?</emphasis></simpara>
<simpara>Within this chip range the Option register is a write only register. Reading the register is not permitted.</simpara>
<simpara>GCBASIC needs to update this when the user wants to change the configuration - the Sleep process is an example of a user change.</simpara>
<simpara>The compiler handles this by the creation of the Option_reg byte variable. This byte is created by the compiler to manage the required write process.</simpara>
<simpara>The Option_reg variable is a cache that compiler will create if any bits of option_reg have been set manually.</simpara>
<simpara>If the user changes any of the bits in a program, then the compiler will find any uses of the option instruction and insert a "movwf OPTION_REG" immediately before the option instruction to cache the value in the buffer.</simpara>
<simpara>If Option_reg bits aren&#8217;t set individually anywhere, then option_reg doesn&#8217;t get created, and nothing special is done with the option instruction.</simpara>
<simpara>Essentially the compiler maintains a special variable and manages the whole process without the user being aware.</simpara>
<simpara><emphasis role="strong">How does the compiler cope with the TRIS register in the 10f products?</emphasis></simpara>
<simpara>The compiler ensures that a TRIS cache matches the actual TRIS register.  The TRIS cache is a byte variable called TRISIO.  The TRISIO cache is required as TRIS is a write-only register.</simpara>
<simpara>All ports default to input ( where all TRIS bits to 1) on reset.  Therefore, this is assumed to be the value 255.</simpara>
<simpara>TRISIO is updated when required by the user code and then used in the writing to the correct register.</simpara>
<simpara>The example user code and the associated assembly shows TRISIO cache in use.  This method complies with datasheet.</simpara>
<simpara>User Code</simpara>
<literallayout class="monospaced">'set as input
dir gpio.0 in
gpio0State = gpio.0
'set as output this will require TRIS GPIO to be set using the TRISIO cache.
dir gpio.0 out
gpio.0 = 1</literallayout>
<simpara>ASM</simpara>
<literallayout class="monospaced">;dir gpio.0 in
  bsf TRISIO,0
  movf  TRISIO,W
  tris  GPIO
;gpio0State = gpio.0
  clrf  GPIO0STATE
  btfsc GPIO,0
  incf  GPIO0STATE,F
;dir gpio.0 out
  bcf TRISIO,0
  movf  TRISIO,W
  tris  GPIO
;gpio.0 = 1
  bsf GPIO,0</literallayout>
<simpara>Anywhere that an individual TRIS bit is set/cleared by change the port direction, the bit in the cache is changed and then that gets written to the TRIS register.</simpara>
<simpara><emphasis role="strong">Forcing the ASM to contain comments</emphasis></simpara>
<simpara>It may be useful to force comments into the ASM file.  The verbose mode of creating the ASM will include ALL the source program as comments but it may be useful to have specific comments in the ASM to aid the understanding of code or to support debugging.</simpara>
<simpara>To force an assembly comment use the following:</simpara>
<screen>    asm showdebug  `comment`</screen>
<simpara>Where the <literal>comment</literal> will be placed into the ASM file.</simpara>
<simpara>Example.</simpara>
<simpara>The source file contains the following, where the comment text is <literal>OSCCON type is 100</literal></simpara>
<screen>    asm showdebug OSCCON type is 100
    OSCCON1 = 0x60</screen>
<simpara>The generated assembly will be as following - this assumes verbose mode is not selected.</simpara>
<screen>    INITSYS
    ;osccon type is 100
      movlw 96
      banksel OSCCON1</screen>
<simpara><emphasis role="strong">Constants, variables, subs and function and labels</emphasis></simpara>
<simpara>GCBASIC uses a single namespace.  A namespace is the set of names used to identify and refer to objects of various kinds.&#160;&#160;
In GCBASIC these can be constants, variables, methods, and labels.&#160;&#160;Wwhere a label is a true label like the start of sub, function or macro.&#160;&#160;
A namespace ensures that all of a given set of objects have unique names so that they can be identified.&#160;&#160;
This organises constants, variables, methods, labels etc into a single list - the single namespace.</simpara>
<simpara>The namespace includes all libraries and source GCBASIC source files. &#160;&#160;
If using MPASM this expands to chip specific INF file.&#160;&#160;
If using PICAS then all of the PICAS toolchain including non-chip specific files. &#160;&#160;There are changes already in place to resolve this issue for PICAS as HEX and LINE are reserved with PICAS toolchain and these conflict with GCBASIC methods.&#160;&#160;
These are automatically resolved by the GCBASIC compiler.</simpara>
<simpara>So, given that a constants, variables, methods, labels etc are number, the compiler does not know if that is a constant, a variable, a method, or a call to a label. Some are use cases using a constant called <literal>NORMAL</literal> follow.&#160;&#160;
<literal>NORMAL</literal> is defined as a constant with <literal>0</literal>.&#160;&#160;</simpara>
<simpara>#1. Code segment</simpara>
<screen>  #DEFINE NORMAL 0
  CALL Normal</screen>
<simpara>The compiler will issue no error.&#160;&#160;
The compiler will assume the following and will do as instructed.&#160;&#160;
Call normal - this calls normal which has a value of 0</simpara>
<simpara>Resulting ASM</simpara>
<screen>  ;CALL Normal
  call 0</screen>
<simpara>#2. Code segment</simpara>
<screen>  #DEFINE NORMAL 0
  CALL Normal()</screen>
<simpara>The compiler will issue no error.&#160;&#160;
The compiler will assume the following and will do as instructed.&#160;&#160;
Call normal() - this calls normal which has a value of 0</simpara>
<simpara>Resulting ASM</simpara>
<screen>    ;CALL Normal()
    call 0</screen>
<simpara>#3. Code segment</simpara>
<screen>  #DEFINE NORMAL 0
  Normal</screen>
<simpara>The compiler will issue an error message.&#160;&#160;
The compiler will try to resolve the constant normal to a sub but it cannot as it is a value of 0.</simpara>
<simpara>Resulting ASM</simpara>
<screen>    ;Normal
    0 ;?F1L8S0I8?</screen>
<simpara>#4. Code segment</simpara>
<screen>  #DEFINE NORMAL 0
  Normal()</screen>
<simpara>The compiler will issue an error message.&#160;&#160;
The compiler will try to resolve the constant normal to a sub but it cannot as it is a value of 0.</simpara>
<simpara>Resulting ASM</simpara>
<screen>    ;Normal()
    0() ;?F1L8S0I8?</screen>
<simpara>#5. Code segment</simpara>
<screen>  #DEFINE NORMAL 0
  Normal = 1</screen>
<simpara>The compiler will issue an error message.&#160;&#160;
This tries to assign a value to the object.</simpara>
<simpara>Resulting ASM</simpara>
<screen>  ;Normal = 1
  0 = 1</screen>
<simpara>#6. Code segment</simpara>
<screen>  #DEFINE NORMAL 0
  Goto normal</screen>
<simpara>The compiler will not issue an error message.&#160;&#160;
The compiler will <literal>goto</literal> (same for <literal>jmp</literal>) to the value of the object.</simpara>
<simpara>Resulting ASM</simpara>
<screen>    ;goto Normal
    goto 0</screen>
</section>
<section xml:id="_libraries_overview">
<title>Libraries Overview</title>
<simpara><emphasis role="strong">About Libraries</emphasis></simpara>
<simpara>GCBASIC (as with most other microcontroller programming languages) supports libraries.</simpara>
<simpara>You can create you own device specific library, you are not limited to those shown below.  If you create a new device specific library - please submit for inclusion in the next release via the GCBASIC forum.</simpara>
<simpara>Maintenance of these libraries is completed by the GCBASIC development team.  If you wish to adapt these libraries you should create a local copy, edit and save within your development file structure.  The development team may update these libraries as part of a release and we do not want you to lose your local changes.</simpara>
<simpara>To use a library, simple inlcude the following in your user code</simpara>
<screen>    #include &lt;3PI.H&gt;    'this will include the 3PI capabilities within your program</screen>
<simpara>To use a local copy of a library, simple inlcude the following in your user code</simpara>
<screen>    #include "C:\mydev\library\3pi.h"    'this will include a local copy of the the 3PI capabilities within your program</screen>
<simpara>GCBASIC supports the following device libraries.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Library</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Class</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Usage</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>3PI</simpara></entry>
<entry align="left" valign="top"><simpara>Polulu 3pi robot</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces the switch and the motors.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>47XXX_EERAM.H</simpara></entry>
<entry align="left" valign="top"><simpara>I2C EERAM memory</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for the Microchip EERAM device classs</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ALPS-EC11</simpara></entry>
<entry align="left" valign="top"><simpara>Rotary Encoder</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for a rotary encoder.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843</simpara></entry>
<entry align="left" valign="top"><simpara>Touch Shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces with the ADS7843 touch screen.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>BME280</simpara></entry>
<entry align="left" valign="top"><simpara>Temp, Humidity and Pressure sensor</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces with the BME280 and the BMP280 sensor.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>CHIPINO</simpara></entry>
<entry align="left" valign="top"><simpara>Shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces the Chipino board with Arduino like port addresses.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DHT</simpara></entry>
<entry align="left" valign="top"><simpara>Temperature and Humidity</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the DHT22 and the DHT11 Temperature and Humidity sensors.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS1307</simpara></entry>
<entry align="left" valign="top"><simpara>Clock</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the timer clock and NVRAM functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS1672</simpara></entry>
<entry align="left" valign="top"><simpara>Clock</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the timer clock and NVRAM functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS18B20</simpara></entry>
<entry align="left" valign="top"><simpara>Temperature</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the temperature functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS18SB0MultiPort</simpara></entry>
<entry align="left" valign="top"><simpara>Temperature</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the temperature functions with devices attached to multiple ports.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS18S20</simpara></entry>
<entry align="left" valign="top"><simpara>Temperature</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the temperature functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS2482</simpara></entry>
<entry align="left" valign="top"><simpara>Clock</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the I2C to Dallas OneWire functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS3231</simpara></entry>
<entry align="left" valign="top"><simpara>Clock</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the timer clock and NVRAM functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DUEMILANOVE</simpara></entry>
<entry align="left" valign="top"><simpara>Shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces the Duemilanove board with Arduino like port addresses.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EMC1001</simpara></entry>
<entry align="left" valign="top"><simpara>Temperature</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the temperature functions and the other device capabilities.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FRAM</simpara></entry>
<entry align="left" valign="top"><simpara>I2C Eeprom</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports memory functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GETUSERID</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip read ID</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the identification of Microchip microcontrollers.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EPD_EPD2In13</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical e-Paper display</simpara></entry>
<entry align="left" valign="top"><simpara>A core library for Graphical LCD support.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EPD_EPD7in5</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical e-Paper display</simpara></entry>
<entry align="left" valign="top"><simpara>A core library for Graphical LCD support.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_HX8347</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_ILI9340</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_ILI9341</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_ILI9481</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_ILI9486L</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_NT7108C</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_IMAGESANDFONTS_ADDIN3</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A library to increase the capabilities of the Graphical LCDs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_KS0108</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_NEXTION</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_PCD8544</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_SH1106</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_SSD1289</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_SSD1306</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_SSD1331</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_ST7735</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_ST7920</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_T6963_64</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical T6963 LCD with 240 x 64 pixels</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_T6963_128</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical T6963 LCD with 240 x 64 pixels</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HEFLASH</simpara></entry>
<entry align="left" valign="top"><simpara>HEF Memory Driver</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the HEF memory functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HMC5883L</simpara></entry>
<entry align="left" valign="top"><simpara>Triple-axis Magnetometer</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the magnetometer functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWI2C_ISR_HANDLER</simpara></entry>
<entry align="left" valign="top"><simpara>I2C Slave Driver</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the use of a Microchip microcontroller as an I2C slave.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWI2C_MESSAGEINTERFACE</simpara></entry>
<entry align="left" valign="top"><simpara>I2C Slave</simpara></entry>
<entry align="left" valign="top"><simpara>A support library that supports the use of a Microchip microcontroller as an I2C slave.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWI2C_ISR_HANDLERKMODE</simpara></entry>
<entry align="left" valign="top"><simpara>I2C Slave Driver</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the use of a Microchip microcontroller as an I2C slave.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWI2C_MESSAGEINTERFACEKMODE</simpara></entry>
<entry align="left" valign="top"><simpara>I2C Slave</simpara></entry>
<entry align="left" valign="top"><simpara>A support library that supports the use of a Microchip microcontroller as an I2C slave.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2CEEPROM</simpara></entry>
<entry align="left" valign="top"><simpara>I2C EEProm memory</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports memory functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LCD2SERIALREDIRECT</simpara></entry>
<entry align="left" valign="top"><simpara>LCD to Serial Handler</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the use of a serial and PC terminal as a psuedo LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LEGO-PF</simpara></entry>
<entry align="left" valign="top"><simpara>Lego Mindstorms shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the Lego Mindstorms robot</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LEGO</simpara></entry>
<entry align="left" valign="top"><simpara>Lego Mindstorms shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the Lego Mindstorms robot</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MATHS</simpara></entry>
<entry align="left" valign="top"><simpara>Maths routines</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports maths functions such as logs, power and atan.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MAX6675</simpara></entry>
<entry align="left" valign="top"><simpara>Temperature</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the temperature functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MAX7219_ledmatrix_driver</simpara></entry>
<entry align="left" valign="top"><simpara>LED 8*8 Matrix driver</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the MAX7219 8*8 LED matrixes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MCP23008</simpara></entry>
<entry align="left" valign="top"><simpara>i2C to serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the I2C to serial functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MCP23017</simpara></entry>
<entry align="left" valign="top"><simpara>i2C to serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the I2C to serial functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MCP4XXXDIGITALPOT</simpara></entry>
<entry align="left" valign="top"><simpara>Digital Pot</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the MCPxxxx range of digital potentiometers.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MCP7940N</simpara></entry>
<entry align="left" valign="top"><simpara>Clock</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the timer clock and NVRAM functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MILLIS</simpara></entry>
<entry align="left" valign="top"><simpara>Clock</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the 1000ms timer event cycle.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NUNCHUCK</simpara></entry>
<entry align="left" valign="top"><simpara>Game controller</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the NunChuck game controller.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PCA9685</simpara></entry>
<entry align="left" valign="top"><simpara>PWM</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for the 16channel PWM driver.  See the demonstrations for example on usage.
Support up to four devices via the I2C bus.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PCF8574</simpara></entry>
<entry align="left" valign="top"><simpara>GLCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PCF85X3</simpara></entry>
<entry align="left" valign="top"><simpara>Clock</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the timer clock and alarms.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SD</simpara></entry>
<entry align="left" valign="top"><simpara>SD Card</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an SD Card.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SMT_Timers</simpara></entry>
<entry align="left" valign="top"><simpara>Signal Measurment Timer</simpara></entry>
<entry align="left" valign="top"><simpara>A library for Signal Measurment Timer for specific Microchip microcontrollers.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SOFTSERIAL</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library for software serial.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SOFTSERIALCH1</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library for software serial.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SOFTSERIALCH2</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library for software serial.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SOFTSERIALCH3</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library for software serial.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SONGLAY</simpara></entry>
<entry align="left" valign="top"><simpara>Music</simpara></entry>
<entry align="left" valign="top"><simpara>A library for play music. Supports QBASIC and RTTTL format.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SONYREMOTE</simpara></entry>
<entry align="left" valign="top"><simpara>Infrared</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the functions of a Sony remote control.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SRF02</simpara></entry>
<entry align="left" valign="top"><simpara>Distance Sensor</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the SRF02 ultrasonic sensor.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SRAM</simpara></entry>
<entry align="left" valign="top"><simpara>Memory devices</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports 23LC1024, 23LCV1024, 23LC1024,  23A1024,  23LCV512,  23LC512,  23A512,  23K256,  23A256,  23A640 or 23K640 devices</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SRF04</simpara></entry>
<entry align="left" valign="top"><simpara>Distance Sensor</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the SRF04 ultrasonic sensor.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TEA5767</simpara></entry>
<entry align="left" valign="top"><simpara>I2C Radio</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the TEA5767 radio.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TM1637</simpara></entry>
<entry align="left" valign="top"><simpara>7 Segment LED display</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the TM1637 7-Segment LED displays</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TRIG2PLACES</simpara></entry>
<entry align="left" valign="top"><simpara>Maths functions</simpara></entry>
<entry align="left" valign="top"><simpara>A maths library that supports trignometry to two places.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TRIG3PLACES</simpara></entry>
<entry align="left" valign="top"><simpara>Maths functions</simpara></entry>
<entry align="left" valign="top"><simpara>A maths library that supports trignometry to three places</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TRIG4PLACES</simpara></entry>
<entry align="left" valign="top"><simpara>Maths functions</simpara></entry>
<entry align="left" valign="top"><simpara>A maths library that supports trignometry to four places</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>UNO_MEGA328P</simpara></entry>
<entry align="left" valign="top"><simpara>Shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces the shield with Arduino like port addresses.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>USB</simpara></entry>
<entry align="left" valign="top"><simpara>USB Supoort</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces the USB for 16f and 18f microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?></simpara>
<simpara><?asciidoc-br?>
GCBASIC supports the following core libraries.   These libraries are automatically included in your user program therefore you do not need to use '#include' to access the libraries capabilities.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Library</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Class</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Usage</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>7SEGMENT</simpara></entry>
<entry align="left" valign="top"><simpara>7 Segment LED display</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces the device. See also TM1637a library.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>A-D</simpara></entry>
<entry align="left" valign="top"><simpara>Analog to Digital</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the ADC functionality.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EEPROM</simpara></entry>
<entry align="left" valign="top"><simpara>EEProm</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports I2C eeprom devices.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWI2C</simpara></entry>
<entry align="left" valign="top"><simpara>I2C</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the MSSP and TWI hardware modules of I2C</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWI2C2</simpara></entry>
<entry align="left" valign="top"><simpara>I2C</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the MSSP and TWI hardware modules of I2C on channel two</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWSPI</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the MSSP and TWI hardware modules of SPI</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C</simpara></entry>
<entry align="left" valign="top"><simpara>I2C</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports software I2C</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>KEYPAD</simpara></entry>
<entry align="left" valign="top"><simpara>KeyPad</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports a keypad.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PS2</simpara></entry>
<entry align="left" valign="top"><simpara>I2C</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports keyboard functionality</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LCD</simpara></entry>
<entry align="left" valign="top"><simpara>LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports LCD functionality, library supports many different communications methods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PWM</simpara></entry>
<entry align="left" valign="top"><simpara>Pulse Width Modulation</simpara></entry>
<entry align="left" valign="top"><simpara>A library supports PWM functionality.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>RANDOM</simpara></entry>
<entry align="left" valign="top"><simpara>Random Numbers</simpara></entry>
<entry align="left" valign="top"><simpara>A library supports random number functionality.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>REMOTE</simpara></entry>
<entry align="left" valign="top"><simpara>Infrared</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the functions of a NEC remote control.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>RS232</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library for serial communications.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SOUND</simpara></entry>
<entry align="left" valign="top"><simpara>Tones</simpara></entry>
<entry align="left" valign="top"><simpara>A library for sound and tone generation</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>STDBASIC</simpara></entry>
<entry align="left" valign="top"><simpara>Utility Functions</simpara></entry>
<entry align="left" valign="top"><simpara>The library that contains many of the utility methods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>STRING</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>The library that contains the string methods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SYSTEM</simpara></entry>
<entry align="left" valign="top"><simpara>System</simpara></entry>
<entry align="left" valign="top"><simpara>The library that contains the system methods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TIMER</simpara></entry>
<entry align="left" valign="top"><simpara>Timers</simpara></entry>
<entry align="left" valign="top"><simpara>The library that contains the timer methods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>USART</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>The library that contains the hardware serial methods that use the MSSP or AVR equivilent hardware module.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>XPT2046</simpara></entry>
<entry align="left" valign="top"><simpara>Touch Shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces with the APT2026 and the ADS7843 touch sensors.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_acknowledgements">
<title>Acknowledgements</title>
<simpara><emphasis role="strong">Developers and Contributors:</emphasis></simpara>
<simpara>Hugh Considine - Main developer of GCBASIC</simpara>
<simpara>Stefano Bonomi - Two-wire LCD subroutines</simpara>
<simpara>Geordie Millar - Swap and Swap4 subroutines</simpara>
<simpara>Jacques Nilo - HEFM and help file conversion to asciidoc</simpara>
<simpara>Finn Stokes - 8-bit multiply routine, program memory access code</simpara>
<simpara>Evan Venn - Utilities, revised I2C routines, this help file and generally everything else!</simpara>
<simpara><emphasis role="strong">Translation Contributors:</emphasis></simpara>
<simpara>Stefano Delfiore - Italian</simpara>
<simpara>Pablo Curvelo - Spanish</simpara>
<simpara>Murat Inceer - Turkish</simpara>
<simpara><emphasis role="strong">Other Contributors:</emphasis></simpara>
<simpara>Russ Hensel - GCBASIC Notes.</simpara>
<simpara>Chuck Hellebuyck - His documentation for the GLCD and other pieces, see <link xlink:href="http://www.elproducts.com">http://www.elproducts.com</link>.</simpara>
<simpara>Frank Steinberg - GCode IDE for GCBASIC.</simpara>
<simpara>Alexy T. - SynWrite IDE used for GCB IDE, see <link xlink:href="http://www.uvviewsoft.com/synwrite">http://www.uvviewsoft.com/synwrite</link></simpara>
<simpara>Thomas Henry for the Select Case and the Sine Table examples.</simpara>
<simpara>William Roth for the LCD code and supporting diagrams.</simpara>
<simpara>Theo Loermans for the revised LCD sections and the serial library.</simpara>
<simpara>Chris Roper for the bitwise methods including the library including FnEquBit, FnNotBit, FnlslBit, FnlsrBit, SetWith and 47xxx.</simpara>
<simpara>Jberg2024 for the adaption of the Software Serial routines to improve usage.</simpara>
<simpara>Angel Mier for the USB driver installation</simpara>
<simpara><emphasis role="strong">Conversion of asciidoctor documentation files</emphasis>:</simpara>
<simpara>See the <link xlink:href="http://asciidoctor.org/">asciidoctor Web site</link> and the <link xlink:href="http://discuss.asciidoctor.org/">support forum</link>.</simpara>
</section>
<section xml:id="_tricks_and_tips">
<title>Tricks and Tips</title>
<simpara>This is a collation of tricks and tips that may be useful to you.
<?asciidoc-br?>
<?asciidoc-br?>
<link linkend="RAMVARIABLESANDRESETS">RAM, variables and resets</link></simpara>
<simpara><link linkend="FORNEXTLEGACY">Reverting the FOR-NEXT loop to the Legacy FOR-NEXT method</link></simpara>
<simpara><link linkend="REQUIRED">Change the compilers behaviour when the compiler states a capability is not available</link></simpara>
<simpara><link linkend="MINIMALASM">Create a minimal ASM source with no config and/or initsys</link></simpara>
<simpara><link linkend="PPSandUSARTs">PPS microconrollers and multiple USARTs</link>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara xml:id="RAMVARIABLESANDRESETS"><emphasis role="strong">TIP: RAM, variables and resets</emphasis></simpara>
<simpara>When you define a variable it will be mapped to a RAM location.&#160;&#160;
As you develop your solution your should always do the following to ensure the variable are initialised correctly.&#160;&#160;</simpara>
<itemizedlist>
<listitem>
<simpara>Always initialise variables to a known state</simpara>
</listitem>
</itemizedlist>
<simpara>A variable will not show up in the ASM source code unless it is used somewhere in code. &#160;&#160;
Adding <literal>Variable = 0</literal>  will assure that the variable is initialised and will show up in the ASM.&#160;&#160;
This is very useful for troubleshooting.&#160;&#160;
This is essential when debugging ASM to look at variables that are defined using "EQU".&#160;&#160;
If you do not initialise or use the variable then the variable will not be shown in the EQU list of variables.&#160;&#160;
So, initialise all your variables.</simpara>
<itemizedlist>
<listitem>
<simpara>Always power cycle the microcontroller after programming</simpara>
</listitem>
</itemizedlist>
<simpara>A soft reset when debugging/testing/programming will not reset the RAM to a known state.
This is essential when debugging ASM to look at variables that are defined using "EQU".&#160;&#160;
A soft reset  does not change the contents of RAM.&#160;&#160;
Where a hard reset reverts ram back to an undefined /random state!&#160;&#160;
So, a power cycle is good practice.&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara xml:id="FORNEXTLEGACY"><emphasis role="strong">TRICK: Reverting the FOR-NEXT loop to the Legacy FOR-NEXT method ?</emphasis></simpara>
<simpara>Why do this?  To reduce the PROGMEM size.&#160;&#160;
But, you must assure yourself that the loop variable cannot overflow as the legacy FOR-NEXT does not prevent an overflow of the loop variable.</simpara>
<simpara>Some background.&#160;&#160;
In 2021 the GCBASIC compiler was updated to improve the operation of the FOR-NEXT loop.&#160;&#160;
The improvement did increase the size of the ASM generated.&#160;&#160;
The legacy FOR-NEXT loop had some major issues that included never ending loops, incorrect end loop and unexpected operations.&#160;&#160;
This was all caused by the compiler, not the user, and in 2021 the compiler was updated to resolve these issues.&#160;&#160;</simpara>
<simpara>However, there is a risk that the new FOR-NEXT method causes 1) larger ASM that will not fit in small microcontrollers or 2) the new code does not operate as expected.&#160;&#160;
In either case you can disable the new FOR-NEXT method by adding a constant as shown below.&#160;&#160;
Adding this constant will revert the FOR-NEXT loop asm generated to the legacy method.&#160;&#160;</simpara>
<screen>    #DEFINE USELEGACYFORNEXT</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara xml:id="REQUIRED"><emphasis role="strong">TRICK: How to change the compilers behaviour when the compiler states a capability is not available when I know it is ?</emphasis></simpara>
<simpara>The compiler is issuing an error message that a EEPROM, HEF, SAF, PWM16 or hardware USART is not available&#8230;&#8203; but, it is.&#160;&#160;</simpara>
<simpara>This is caused by the microcontroller DAT file.&#160;&#160;
The microcontroller DAT file is missing key information that informs the compiler that a specific capability is available.&#160;&#160;
This information was added to prevent silent failures where you could use a capability when it is not available.&#160;&#160;</simpara>
<simpara>The compiler thinks your microcontroller does not have the selected capability. &#160;&#160;
Simply use the table below to resolve.&#160;&#160;
Adding the constant defined to your source program.&#160;&#160;</simpara>
<simpara>Then, let us know via the Forum so we can correct the source microcontroller DAT file.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>EEPROM</simpara>
</entry>
<entry>
<simpara><literal>#DEFINE CHIPEEPROM = 1</literal></simpara>
</entry>
</row>
<row>
<entry>
<simpara>HEF</simpara>
</entry>
<entry>
<simpara><literal>#DEFINE  CHIPHEFWORDS = 128</literal></simpara>
</entry>
</row>
<row>
<entry>
<simpara>SAF</simpara>
</entry>
<entry>
<simpara><literal>#DEFINE  CHIPSAFWORDS = 128</literal></simpara>
</entry>
</row>
<row>
<entry>
<simpara>PWM16</simpara>
</entry>
<entry>
<simpara><literal>#DEFINE  CHIPPWM16TYPE  = 1</literal></simpara>
</entry>
</row>
<row>
<entry>
<simpara>USART hardware</simpara>
</entry>
<entry>
<simpara><literal>#DEFINE  CHIPUSART  = 1</literal></simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara xml:id="MINIMALASM"><emphasis role="strong">TRICK: How do I create a minimal ASM source with no config and/or initsys?</emphasis></simpara>
<simpara>Very easy.&#160;&#160;
Simple add two <literal>#OPTION</literal> statements.&#160;&#160;</simpara>
<simpara><literal>#OPTION UserCodeOnly ENTERBOOTLOADER:</literal> &#160;&#160;This will instruct the compiler to NOT call the INITSYS() method.&#160;&#160;
And, to jump to a label.&#160;&#160;
The label is mandated.&#160;&#160;The label specified will be included in the ASM generated.</simpara>
<simpara><literal>#OPTION NoConfig</literal>&#160;&#160;This will instruct the compiler to NOT add the microcontroller specific config statements.</simpara>
<simpara>Example:</simpara>
<screen>    #chip 16f877a, 4
    #OPTION Explicit

    #OPTION UserCodeOnly ENTERBOOTLOADER:
    #OPTION NoConfig

    ENTERBOOTLOADER:</screen>
<simpara>The example above yields the following asm.&#160;&#160;
Comment lines have been removed for clarity.</simpara>
<screen>     LIST p=16F877A, r=DEC
    #include &lt;P16F877A.inc&gt;

    ;Vectors
      ORG 0
      pagesel ENTERBOOTLOADER
      goto  ENTERBOOTLOADER

    ;ORG 5


    ENTERBOOTLOADER

    ;ORG 2048
    ;ORG 4096
    ;ORG 6144

     END</screen>
<simpara xml:id="PPSandUSARTs"><emphasis role="strong">TIP: PPS and multiple USARTs</emphasis></simpara>
<simpara>You can set up multiple pins to simultaneously operate as a peripheral output on microcontrollers with Peripheral Pin Select (PPS).
<?asciidoc-br?>
<?asciidoc-br?>
PPS microcontrollers can set up to simultaneously output specific modules.&#160;&#160;
The example below shows the method to output two TX ports.&#160;&#160;
Hardware Serial (TX1) data will now be output on both B.6 and C.6
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    Sub InitPPS
            'Module: UART pin directions
            Dir PORTC.6 Out    ' Make TX1 pin an output
            Dir PORTB.6 Out    ' Make TX1 pin an output
            'Module: UART1 to two ports
            RC6PPS = 0x0020    'TX1 &gt; RC6
            RB6PPS = 0x0020    'TX1 &gt; RB6

    End Sub</screen>
<section xml:id="_uno_as_isp_programmer">
<title>UNO as ISP programmer</title>
<simpara>So, you have brought some ATtiny88 breakout boards online.&#160;&#160;
They are advertised as Nano equivalents but are inferior to the Nano in having low RAM (512 bytes vs 2048) and missing some other features.&#160;&#160;
Specifically the lack of a USB comport for programming.&#160;&#160;</simpara>
<simpara>The ATtiny88 USB interface only works in Arduino IDE with some tweaking, and, you are not in the mood for learning how to write sketches after being in the GCB environment for years.&#160;&#160;</simpara>
<simpara>This is an all-in-one tutorial for programming the ATtiny88 via AVRdude using GCB.&#160;&#160;</simpara>
<note>
<simpara>The only baud rate that works is 19200. Every other baud rate failed in testing</simpara>
</note>
<simpara>The process described will create a new programmer entry in the GCB Programmer Options to fully automate the compile &amp; program progress.</simpara>
<note>
<simpara>This refers to an ATtiny88 but you can use this method for many AVRs which used in conjunction with AvrDude.</simpara>
</note>
<simpara><emphasis role="strong">The Process</emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Obtain an Arduino UNO or mega.&#160;&#160;
Upload this <link xlink:href="https://sourceforge.net/p/gcbasic/discussion/chipfileforum/thread/088449090a/ed10/attachment/arduino_As_ISP_adafruit.hex">hex file</link> to convert the UNO into an ISP programmer or follow steps 2 -5 below.</simpara>
</listitem>
<listitem>
<simpara>Download the Arduino IDE software.&#160;&#160;
This is used to upload a sketch to the UNO that converts it into an ISP programmer.</simpara>
</listitem>
<listitem>
<simpara>Connect the UNO to your PC via USB.&#160;&#160;
In Arduino IDE goto Tools &#8594; Set board and select "Arduino UNO".&#160;&#160;
Select the correct com port for the Arduino Uno as show in device manager.</simpara>
</listitem>
<listitem>
<simpara>Goto file &#8594; examples &#8594; ArduinoISP to select the sketch that will convert the UNO to an ISP programmer. I found a better(?) working version at adafruit. Simply copy all the text from this link into a new sketch <link xlink:href="https://raw.githubusercontent.com/adafruit/ArduinoISP/master/ArduinoISP.ino">https://raw.githubusercontent.com/adafruit/ArduinoISP/master/ArduinoISP.ino</link> (or download the ino file attached and open it in Arduino IDE) and goto step 5</simpara>
</listitem>
<listitem>
<simpara>Click upload and confirm the sketch uploaded correctly by checking the status window at the bottom of the Arduino IDE</simpara>
</listitem>
<listitem>
<simpara>Build a cable to connect the ISP headers on the UNO and target (ATtiny88) board as described below. Search online for the UNO ISP header pinout, the ISP header happens to be labelled underneath the ATtiny88 breakout board.</simpara>
</listitem>
<listitem>
<simpara>Connect pin 10 of the UNO to the reset pin on target ISP header</simpara>
</listitem>
<listitem>
<simpara>Connect VCC to VCC, MOSI to MOSI, MISO to MISO, GND to GND, SCK to SCK.</simpara>
</listitem>
<listitem>
<simpara>Open Synwrite &#8594; "IDE tools" &#8594; "GCB tools" &#8594; "Edit Programmer preferences", or, in GCStudio "Edit Programmer preferences"</simpara>
</listitem>
<listitem>
<simpara>Click "add" and a program editor window opens</simpara>
</listitem>
<listitem>
<simpara>Enter name Arduino as ISP or similar</simpara>
</listitem>
<listitem>
<simpara>In the "Use if" box paste DEF(AVR)</simpara>
</listitem>
<listitem>
<simpara>In the "File" box paste %instdir%..\avrdude\avrdude.exe</simpara>
</listitem>
<listitem>
<simpara>In the "command line parameters" paste -c avrisp -p t88 -P %Port% -b 19200 -U flash:w:"%FileName%":a</simpara>
</listitem>
<listitem>
<simpara>Select the com port that corresponds to the connected UNO port</simpara>
</listitem>
<listitem>
<simpara>Click ok</simpara>
</listitem>
</orderedlist>
<simpara><emphasis>Enter the sample code here into GCB IDE</emphasis></simpara>
<screen>    #chip tiny88, 12

    dir portd.0 out

    Do
      set portd.0 on
      wait 500 ms
      set portd.0 off
      wait 500 ms
    Loop</screen>
<simpara>Now you can select "Hex/Flash" to upload the code to the Attiny88.&#160;&#160;
If all goes well the LED should blink on and off every second</simpara>
</section>
</section>
<section xml:id="_microcontroller_fundamentals">
<title>Microcontroller Fundamentals</title>
<section xml:id="_inputs_outputs">
<title>Inputs/Outputs</title>
<simpara><emphasis role="strong">About Inputs and Outputs</emphasis></simpara>
<simpara>Most general purpose pins on a microcontroller can function in one of
two modes: input mode, or output mode.</simpara>
<simpara>When acting as an input, the general purpose input/output pin will be placed in a high impedance state.
The microcontroller will then sense the general purpose input/output pin, and the program can read
the state of the general purpose input/output pin and make decisions based on it.</simpara>
<simpara>When in output mode, the microcontroller will connect the general purpose input/output pin to either
Vcc (the positive supply), or Vss (ground, or the negative supply). The
program can then set the state of the general purpose input/output pin to either high or low.</simpara>
<simpara>GCBASIC will attempt to determine the direction of each general purpose input/output pin, and set it
appropriately, when possible. GCBASIC will try to set the direction of the general purpose input/output pin.
However, if the general purpose input/output pin is read from and written to in your program, then
the general purpose input/output pin must be configured to input or output mode by the program, using
the appropriate <link linkend="_dir">Dir</link> commands.</simpara>
<simpara>Example of <literal>dir</literal> commands.</simpara>
<screen>    'The port address is microcontroller specific.  Portx.x is a general case for PICs and AVRs
    dir portb.0 in
    dir portb.1 out

    'The port address is microcontroller specific.  gpiox.x is a general case for some PICs
    dir gpio.0 in
    dir gpio.1 Out

    'Set the whole port as an output
    dir portb out
    dir gpio out

    'Set the whole port as an input
    dir portc in
    dir gpio in</screen>
<simpara><emphasis role="strong">Microchip specifics for read/write operations</emphasis></simpara>
<simpara>For the specific ports and general purpose input/output pins available for a specific microcontroller please refer to the datasheet.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Port</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>PORTx maps to the microcontrollers digital pins 0 to 7. Where x can be a,b,c,d,e,f or g</simpara></entry>
<entry align="left" valign="top"><simpara>Read:
</simpara><simpara>PORTx the port data register for a  read operation.</simpara></entry>
<entry align="left" valign="top"><simpara>uservar=PORTA
</simpara><simpara>uservar=PORTA.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PORTx maps to microcontrollers digital pins 0 to 7. Where x can be a,b,c,d,e,f or g</simpara></entry>
<entry align="left" valign="top"><simpara>Write:
</simpara><simpara>PORTx the port data register for a  write operation, and, where LATx is not required as GCBASIC will implement LATx when needed.
</simpara><simpara>See <link linkend="__option_nolatch">Option NoLatch</link> for more information on LAT registers and how to disable this automatic function.</simpara></entry>
<entry align="left" valign="top"><simpara>PORTA=255
</simpara><simpara>PORTA.1=1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>To read a general purpose input/output pin, you need to ensure the direction is correct <literal>DIR Portx IN</literal> is set (default is IN) or a specific set of port bits.
Where <literal>uservar = PORTx.n</literal> can be used.</simpara>
<simpara>Examples:</simpara>
<screen>    uservar = PORTb.0
    uservar = PORTb</screen>
<simpara>To write to a general purpose input/output pin, you need to ensure the direction is correct <literal>DIR Portx OUT</literal> for port or a specific set of port bits.
Where  <literal>PORTx.n = uservar</literal> can be used.</simpara>
<simpara>Examples:</simpara>
<screen>    PORTb.0 = uservar
    PORTb = uservar</screen>
<simpara><emphasis role="strong">ATMEL specifics for read/write operations</emphasis></simpara>
<simpara>Using a Mega328p as a general the following provides insights for the AVR devices.  For the specific ports and general purpose input/output pins available for a specific microcontroller please refer to the datasheet.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Port</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Write operation</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Read operation</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>PORTD maps to Mega328p (and, the AVR microcontrollers) digital pins 0 to 7</simpara></entry>
<entry align="left" valign="top"><simpara>PORTD - The Port D Data Register - write operation  (a read operation to a port will provide the pull-up status)</simpara></entry>
<entry align="left" valign="top"><simpara>PIND - The Port D Input Pins Register - read only</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PORTB maps to Mega328p (and, the AVR microcontrollers) digital pins 8 to 13. The two high bits (6 &amp; 7) map to the crystal pins and are not usable</simpara></entry>
<entry align="left" valign="top"><simpara>PORTB - The Port B Data Register - write operation  (a read operation to a port will provide the pull-up status)</simpara></entry>
<entry align="left" valign="top"><simpara>PINB - The Port B Input Pins Register - read only</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PORTC maps to Mega328p (and, the AVR microcontrollers) analog pins 0 to 5. Pins 6 &amp; 7 are only accessible on the Mega328p (and, the AVR microcontrollers) Mini</simpara></entry>
<entry align="left" valign="top"><simpara>PORTC - The Port C Data Register - write operation (a read operation to a port will provide the pull-up status)</simpara></entry>
<entry align="left" valign="top"><simpara>PINC - The Port C Input Pins Register - read only</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>To read a general purpose input/output pin, you need to ensure the direction is correct <literal>DIR Portx IN</literal> is set (default is IN) or a specific set of port bits.
Where <literal>uservar = PINx.n</literal> can be used and therefore to read data port use <literal>uservar = PINx</literal>.</simpara>
<simpara>Examples:</simpara>
<screen>    uservar = PINb.0
    uservar = PINb</screen>
<simpara>To write to a general purpose input/output pin you need to ensure the direction is correct <literal>DIR Portx OUT</literal> for port or a specific set of port bits.
Where <literal>PORTx.n = uservar</literal> can be used and therefore to write to a data port use <literal>PORTx = uservar</literal>.</simpara>
<simpara>Examples:</simpara>
<screen>    PORTb.0 = uservar
    PORTb = uservar</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Setting Ports and Port.bit</emphasis></simpara>
<simpara>You can set a port as shown above with a variable, or, you can set with a constant or any combination using the bitwise and logical operators.</simpara>
<screen>    #define InitStateofPort 0b11110000
    PORTb = InitStateofPort               'will unconditionally set bits 4:7

    PORTb = 0b11110000                    'will unconditionally set bits 4:7

    PORTb = uservar OR 0b11110000         'will OR bits 4:7 to ensure bits 4:7 are set</screen>
<simpara>The following is also valid - read a port.bit and then set port.bit with a variable or port value. As shown below.</simpara>
<screen>    dir portb out

    portb.0 = NOT  portb.0</screen>
<simpara>The user code above may cause issues with glitches when the read and write operations occurs.  Let us look at the generated assembler.</simpara>
<screen>    ;portb.0 = NOT  portb.0
      banksel SYSTEMP1
      clrf  SysTemp1
      btfsc PORTB,0
      incf  SysTemp1,F
      comf  SysTemp1,F
      bcf PORTB,0
      btfsc SysTemp1,0
      bsf PORTB,0</screen>
<simpara>To resolve any glitches add <literal>#option Volatile</literal> to your user code.</simpara>
<screen>    #option Volatile portb.0

    dir portb out

    portb.0 = NOT  portb.0</screen>
<simpara>This option provides the following assembler resolving the glitch issue.</simpara>
<screen>    ;portb.0 = NOT  portb.0
      banksel SYSTEMP1
      clrf  SysTemp1
      btfsc PORTB,0
      incf  SysTemp1,F
      comf  SysTemp1,F
      btfsc SysTemp1,0
      bsf PORTB,0
      btfss SysTemp1,0
      bcf PORTB,0</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">See also</emphasis>  <link linkend="_dir">Dir</link>, <link linkend="__option_volatile">#Option Volatile</link></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_configuration">
<title>Configuration</title>
<simpara><emphasis role="strong">About Microcontroller Configuration</emphasis></simpara>
<simpara><emphasis role="strong">For PICs</emphasis></simpara>
<simpara>This section applies to Microchip PIC microcontrollers.&#160;&#160;For AVR and LGT microcontrollers see the sections below.</simpara>
<simpara>Every Microchip PIC has a CONFIG word. This is an area of memory on the chip
that stores settings which govern the operation of the chip.</simpara>
<simpara>The following asects of the chip are governed by the CONFIG word:</simpara>
<itemizedlist>
<listitem>
<simpara>Oscillator selection - will the chip run from an internal oscillator,
or is an external one attached?</simpara>
</listitem>
<listitem>
<simpara>Automatic resets - should the chip reset if the power drops too low?
If it detects it is running the same piece of code over and over?</simpara>
</listitem>
<listitem>
<simpara>Code protection - what areas of memory must be kept hidden once
written to?</simpara>
</listitem>
<listitem>
<simpara>Pin usage - which pins are available for programming, resetting the
chip, or emitting PWM signals?</simpara>
</listitem>
</itemizedlist>
<simpara>The exact configuration settings vary amongst chips. To find out a list
of valid settings, please consult the datasheet for the microcontrollers that
you wish to use.</simpara>
<simpara>This can all be rather confusing - hence, GCBASIC will automatically set
some config settings, unless told otherwise:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Low Voltage Programming (LVP) is turned off.</emphasis> This enables the PGM
pin (usually B3 or B4) to be used as a normal I/O pin.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Watchdog Timer (WDT) is turned off.</emphasis> The WDT resets the chip if it
runs the same piece of code over and over - this can cause trouble with
some of the longer delay routines in GCBASIC.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Master Clear (MCLR) is disabled where possible.</emphasis> On many newer chips
this allows the MCLR pin (often PORTA.5) to be used as a standard input
port. It also removes the need for a pull-up resistor on the MCLR pin.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">An oscillator mode will be selected, based on the following rules:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>If the microcontroller has an internal oscillator, and the internal oscillator is
capable of generating the speed specified in the #chip line, then the
internal oscillator will be used.</simpara>
</listitem>
<listitem>
<simpara>If the clock speed is over 4 Mhz, the external HS oscillator is
selected</simpara>
</listitem>
<listitem>
<simpara>If the clock speed is 4 MHz or less, then the external XT oscillator
mode is selected.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Note that these settings can easily be individually overridden whenever
needed. For example, if the Watchdog Timer is needed, adding the line</simpara>
<screen>    #config WDT = ON</screen>
<simpara>This will enable the watchdog timer, without affecting any other
configuration settings.</simpara>
<simpara><emphasis role="strong">For AVR</emphasis></simpara>
<simpara>This section applies to Atmel AVR microcontrollers.&#160;&#160; Generally, Atmel AVR microcontrollers
do have a similar configuration settings, but they are controlled
through "Configuration Fuses". GCBASIC cannot set these -
you MUST use the programmer software.</simpara>
<simpara>The exception to the general case are the ATTiny4-5-9-10 and ATTiny102-104.  &#160;&#160;These microcontrollers have software selectable frequencies for the following frequencies:</simpara>
<literallayout class="monospaced">ChipMHz 8
ChipMHz 4
ChipMHz 2
ChipMHz 1
ChipMHz 0.5
ChipMHz 0.25
ChipMHz 0.125
ChipMHz 0.0625
ChipMHz 0.03125</literallayout>
<simpara>Therefore, you can use ( an example )</simpara>
<screen>    #chip tiny10, 0.25</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For LGT</emphasis></simpara>
<simpara>This section applies to LGT microcontrollers.</simpara>
<simpara>All LGT microcontroller have software selectable frequencies for the following frequencies:</simpara>
<literallayout class="monospaced">ChipMHz 8
ChipMHz 4
ChipMHz 2
ChipMHz 1
ChipMHz 0.5
ChipMHz 0.25
ChipMHz 0.125
ChipMHz 0.0625
ChipMHz 0.03125</literallayout>
<simpara>Therefore, you can use ( an example )</simpara>
<screen>    #chip #chip LGT8F328P, 0.25</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Using Configuration</emphasis></simpara>
<simpara>For PICs only.</simpara>
<simpara>Once the necessary CONFIG options have been determined, adding them to
the program is easy. On a new line type "#config" and then list the
desired options separated by commas, such as in this line:</simpara>
<screen>    #config OSC = RC, BODEN = OFF</screen>
<simpara>GCBASIC also supports this format on 10/12/16 series chips:</simpara>
<screen>    #config INTOSC_OSC_NOCLKOUT, BODEN_OFF</screen>
<simpara>However, for upwards compatibility with 18F chips, you should use the = style config settings.</simpara>
<simpara>It is possible to have several #config lines in a program - for
instance, one in the main program, and one in each of several #include
files. However, care must then be taken to ensure that the settings in
one file do not conflict with those in another.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="__config">#config Directive</link></simpara>
</section>
<section xml:id="_usb_drivers_installer">
<title>USB Drivers Installer</title>
<warning>
<simpara>Installing the USB driver is only required when using the GCBASIC USB library.</simpara>
</warning>
<simpara><emphasis role="strong">Description:</emphasis></simpara>
<simpara>The drivers for windows x86 and x64 correspond to the USB LIBKWIN capability of GCBasic for supported PIC microcontrollers.</simpara>
<simpara>For security reasons, in Microsoft windows for a driver to be installed, it is necessary that it be digitally signed by Microsoft.</simpara>
<simpara>Microsoft did make a special “Test” mode for developers to install MANUALLY unsigned drivers for debug and testing, being a technical advanced and not user-friendly procedure; at the same time the windows developers make efforts to disable the capability of doing this in an automated fashion by the concerns of being used as a vulnerability of the operating system.</simpara>
<simpara>This scenario will make installing test drivers difficult and frustrating for the uninitiated, at the same time for a useful Hobby project it will be not practical to make end users to take all this drama.</simpara>
<simpara>This driver installer method resolves the constraints imposed by the Windows operating system, and, therefore will allow you to install the drivers in the easiest way possible, almost like any driver of a well-known company.</simpara>
<simpara><emphasis role="strong">Usage:</emphasis></simpara>
<warning>
<simpara>The installer will reboot the system without notice. Please close all programs and save any work you have open before begin whit the driver install.</simpara>
</warning>
<simpara>1 - Open the installer, it will request admin rights.</simpara>
<simpara>2 - Navigate thru the wizard to automatically extract the driver files (there aren’t any options to select).</simpara>
<simpara>3 - At the end of the wizard, after you click the exit button, the system will restart automatically</simpara>
<warning>
<simpara>In the case where your computer has Secure Boot enabled, the installer will advise you of extra steps needed after reboot, at the end of this page you will find a graphic reflecting those steeps and what elements you need to select.</simpara>
</warning>
<simpara>4 - After restart and login in to your user account, a window will inform you that the driver is not signed and you will be asked if you want to install the driver, please allow it.</simpara>
<simpara>5 - when the driver has been installed, the computer will restart automatically.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Secure Boot Enabled, Boot menu steps</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/winresteepsm.png" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">USB Driver details</emphasis></simpara>
<simpara>The driver uses the following USB flags.</simpara>
<screen>    USB_VID 0x1209
    USB_PID 0x2006
    USB_REV 0x0000</screen>
<simpara>For others, need to modify and recompile the USB library.</simpara>
<simpara>USB_PRODUCT_NAME and USB_VENDOR_NAME can change without problem (windows device manager will show the name reported by the hardware not the driver</simpara>
<simpara><emphasis role="strong">Tested on (but not limited to)</emphasis></simpara>
<screen>    Windows 11 pro x64 secureboot disabled, os build Dev 21H2 22000.194
    Windows 11 pro x64 secureboot enabled, os build Dev rs_prerelease 22458.1000
    Windows 10 pro x64 secureboot disabled, os build stable 20H2 19042.867
    Windows 7 pro x86 secureboot disabled, os service pack 1 build 6.1.7601</screen>
</section>
</section>
<section xml:id="_variables">
<title>Variables</title>
<section xml:id="_data_types">
<title>Data Types</title>
<simpara>This section discusses the different types and sizes of data variables used by GCBASIC, and how they are interpreted or handled by GCBASIC methods.</simpara>
<simpara>The section also provides an insight of which type of variable to use and when.</simpara>
<simpara><emphasis role="strong">What variable sizes are suported by GCBASIC?</emphasis></simpara>
<simpara>GCBASIC implements support for Bit, Byte, Word, Integer and Long Variable Types, all of which are described below.</simpara>
<simpara>Supported variables are <emphasis role="strong">Bit</emphasis> (1 Bit), <emphasis role="strong">Byte</emphasis> (8 Bit), <emphasis role="strong">Word</emphasis> (16 Bit), <emphasis role="strong">Long</emphasis> (32 Bit).  GCBASIC does not support decimal numbers.</simpara>
<simpara><emphasis role="strong">Bit</emphasis> is used as a Flag or a Port Pin and has two states which may be:</simpara>
<screen>    ON or OFF
    TRUE or FALSE
    HIGH or LOW
    1 or 0
    SET or RESET</screen>
<simpara>other complementary states depending on how your application interprets and handles the data.</simpara>
<simpara><emphasis role="strong">Byte</emphasis> is the most common size in 8 Bit devices and could represent a Number, an ASCII Character, a Port, two Nibbles (as used by Hex or BCD number systems), an Internal Register, an 8 bit Variable or any user defined collection of to eight Bits such as a group of flags.</simpara>
<simpara><emphasis role="strong">Word</emphasis> is normally used for its Numeric value. 16 Bits will allow it to store Numbers from Zero to 65535 which is large enough to store the product of any two 8 bit Bytes without overflowing. &#160;&#160;However, it is not confined to being used as a numeric value.&#160;&#160; A Word may be used in any manner that your application needs depending on how it interprets the 16 Bits of data. Examples may be a memory address or a data pointer.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Note:</emphasis> The Word size of a device (as opposed to the Word Type above) is a representation of the number of Bits that it can manipulate simultaneously by the chip. &#160;&#160; The number of Bits for PIC and AVR Microcontrolers supported by GCBASIC are 8 Bits and so they are considered to have an 8 Bit Word.*</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Long</emphasis> is for situations where Values exceeding 65535 have to be handled and has a range of zero to 4294967295 (2^32-1).&#160;&#160;It is rarely used in 8 Bit devices but is invaluable on the rare occasions that it is needed. &#160;&#160; The Millis() is an example that  uses the Long Data Type to handle time periods of up to 50 days.</simpara>
<simpara>All of the above can be considered to be Integer Values of varying magnitude as they can hold non Fractional Positive Whole Numbers, but try not to confuse <emphasis role="strong">Integer Values</emphasis> with the <emphasis role="strong">Integer Variable Type</emphasis>, they are complementary but separate concepts as you will see below.</simpara>
<simpara>An <emphasis role="strong">integer</emphasis> is a whole number (not a fractional number) that can be Positive, Negative, or Zero.</simpara>
<simpara>In your application there may be a need to be able represent Negative Numbers in our variables and that is where the GCBASIC <emphasis role="strong">Integer Variable Type</emphasis> is useful.  An <emphasis role="strong">Integer Variable</emphasis> is similar to the <emphasis role="strong">Word Variable</emphasis> as they are both 16 bits. &#160;&#160; The difference how the GCBASIC compiler interprets the data bits that it contains.</simpara>
<simpara>The compiler will treat a <emphasis role="strong">Word Variable Type</emphasis> as a Variable that can store the values 0 &lt; 65535 but it will see the <emphasis role="strong">Integer Variable Type</emphasis> as a Variable that can store values of -32768 &lt; 0 &lt;32767.</simpara>
<simpara><emphasis role="strong">Variable size</emphasis></simpara>
<simpara>Each type of variable is defined in various bit lengths, in this case GCBASIC  these are:</simpara>
<screen>    Byte                 8 Bit
    Integer             16 Bit
    Word                16 Bit
    Long                32 Bit</screen>
<simpara>All four of the above are number types are true Integers. &#160;&#160;In that they are representations of a integer non fractional number as follows:</simpara>
<screen>    8  Bit - an 8 Bit number can be in the range of 0 to 255
    16 Bit - a 16 Bit number can be in the range of 0 to 65535
    32 Bit - a 32 Bit number can be in the range of 0 to 4294967295 (2^32-1)</screen>
<simpara>But, they can only represent positive numbers. &#160;&#160;In Mathematics there is a need for an Integer that can be Positive, Negative, or Zero. &#160;&#160;Note that Zero is always a Positive Whole Number.</simpara>
<simpara><emphasis role="strong">Two&#8217;s Complement</emphasis></simpara>
<simpara>To take the Two&#8217;s Complement of a number it is inverted then incremented:</simpara>
<screen>        MyVar = NOT MyVar + 1</screen>
<simpara>The increment, of adding 1, has two effects, it avoids the possible creation of a negative zero as a value of 1000000 would be seen as -128 and it allows subtraction to be achieved through addition.</simpara>
<simpara>If MyVar contained a value of 1 the 8 Bit representation would be:</simpara>
<screen>    00000001</screen>
<simpara>The NOT will make it</simpara>
<screen>    11111110</screen>
<simpara>Note that the Most significant Bit is now 1 so as a signed value it is negative.</simpara>
<simpara>The increment will result in a value of:</simpara>
<screen>    11111111</screen>
<simpara>So Minus one using an 8 Bit representation in Two&#8217;s Complement notation is 11111111</simpara>
<simpara>Let&#8217;s test it by adding -1 to plus 3</simpara>
<screen>    11111111    -1
    00000011 +   3
    ==============
    00000010     2</screen>
<simpara>We have successfully subtracted 1 from 3 by adding Minus 1 to 3 and obtaining a result of 2.</simpara>
<simpara>Notice that while a Byte is normally used to represent 0 &lt; 255 by making the MSB (Most Significant Bit) into a sign bit the maximum value is now 127.&#160;&#160; A signed 8 Bit integer can represent numbers in the range -128 &lt; 0 &lt; 127. &#160;&#160;That is still 256 values including Zero but they can now be Negative or Positive numbers.</simpara>
<simpara>The benefit of the two&#8217;s complement method is that it works for any size of variable:</simpara>
<screen>    MyByte = NOT MyByte +1
    MyWord = NOT MyWord +1
    MyLong = NOT MyLong +1</screen>
<simpara>All of the above will result in a Negated version of the original contents.</simpara>
<simpara>But not all, in fact relatively few, methods of a microcontroller require negative values so in situations where negative values are not required the loss of half of the magnitude of a Byte or Word can be significant. That is why it is necessary to be able to specify if a value is Signed or Unsigned, that is if the MSB is the sign bit or part of the value.</simpara>
<simpara>It is obviously important from the above that the user program ds need to know what sort of data to expect as a value of 0xFF could be considered to be both 255 and -1 depending on the interpretation of the variable. &#160;&#160; That is why it is important to have Signed and Unsigned Data Types so that the compiler can decide how to handle or interpret the contents. &#160;&#160;As show above in GCBASIC those types are referred to as Integer and Word respectively.</simpara>
<simpara><emphasis role="strong">Summary</emphasis></simpara>
<simpara>GCBASIC implements support for Bit, Byte, Word, Integer and Long Variable Types, all of which are described above.</simpara>
<simpara>And, that negative numbers are represented as two’s complement.&#160;&#160;</simpara>
</section>
<section xml:id="_variable_types">
<title>Variable Types</title>
<simpara><emphasis role="strong">About Variables and Variable Types</emphasis></simpara>
<simpara>A variable is an area of memory on the microcontroller that can be used
to store a number or a series of letters. This is useful for many
purposes, such as taking a sensor reading and acting on it, or counting
the number of times the microcontroller has performed a particular task.</simpara>
<simpara>Each variable must be given a name, such as "MyVariable" or
"PieCounter". Choosing a name for a variable is easy - just don&#8217;t
include spaces or any symbols (other than _), and make sure that the
name is at least 2 characters (letters and/or numbers) long.</simpara>
<simpara><emphasis role="strong">Variable Types</emphasis></simpara>
<simpara>There are several different types of variable, and each type can store a
different sort of information. These are the variable types that GCBASIC can currently use:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Variable type</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Information that this variable can store</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example uses for this type of variable</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Bit</simpara></entry>
<entry align="left" valign="top"><simpara>A bit (0 or 1)</simpara></entry>
<entry align="left" valign="top"><simpara>Flags to track whether or not a piece of code has run</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Byte</simpara></entry>
<entry align="left" valign="top"><simpara>A whole number between 0 and 255</simpara></entry>
<entry align="left" valign="top"><simpara>General purpose storage of data, such as counters</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Word</simpara></entry>
<entry align="left" valign="top"><simpara>A whole number between 0 and 65535</simpara></entry>
<entry align="left" valign="top"><simpara>Storage of extra large numbers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Integer</simpara></entry>
<entry align="left" valign="top"><simpara>A whole number between -32768 and 32767</simpara></entry>
<entry align="left" valign="top"><simpara>Anything where a negative number will occur</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Long</simpara></entry>
<entry align="left" valign="top"><simpara>A whole number between 0 and 2^32-1 (4.29 billion)</simpara></entry>
<entry align="left" valign="top"><simpara>Storing very, very big numbers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Array</simpara></entry>
<entry align="left" valign="top"><simpara>A list of whole numbers, each of which may be a byte, word, integer, or long</simpara></entry>
<entry align="left" valign="top"><simpara>Logs of sensor readings</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>A series of letters, numbers and symbols.</simpara></entry>
<entry align="left" valign="top"><simpara>Messages that are to be shown on a screen</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Using Variables</emphasis></simpara>
<simpara>Byte variables do not need any special commands to set them up - just
put the name of the variable in to the command where the variable is
needed.</simpara>
<simpara>Other types of variable can be used in a very similar way, except that
they must be "dimensioned" first. This involves using the DIM command,
to tell GCBASIC that it is dealing with something other than a
byte variable.</simpara>
<simpara>A key feature of variables is that it is possible the have the
microcontroller check a variable, and only run a section of code if it
is a given value. This can be done with the IF command.</simpara>
<simpara><emphasis role="strong">Number Variables</emphasis></simpara>
<simpara>You can assign values to number variables using&#160;&amp;#160`=`.&#160;&#160;</simpara>
<simpara>A simple, but typical example follows.&#160;&#160;This is the typical for numeric variable assignment.</simpara>
<screen>    myByteVarible = 127       'assign the value of 127</screen>
<simpara>GCBASIC support bitwise assignments s follows:</simpara>
<screen>    portc.0 = !porta.1  'set a single bit to the value of another bit</screen>
<simpara>The function <literal>FnLSL</literal> performs the shift operation found in other languages.  Here is an example:</simpara>
<screen>    MyVar = FnLSL( 1, BitNum)`  is Equivalent to `MyVar = 1&lt;&lt;BitNum`</screen>
<simpara>To set a bit of a port and to prevent glitches during operations, use <literal>#option volatile</literal> as folllows:</simpara>
<screen>    'add this option for a specific port.
    #option volatile portc.0

    'then in your code
    portc.0 = !porta.1</screen>
<simpara>To set a bit of a port or variable, encapsulate it in the <literal>SetWith</literal> method.  Using this method also eliminates any glitches during the update.</simpara>
<screen>    SetWith(MyPORT, MyPORT OR FnLSL( 1, BitNum))</screen>
<simpara>To clear a bit of a port, use this method:</simpara>
<screen>    MyPORT = MyPORT AND NOT FnLSL( 1, BitNum))</screen>
<simpara>To set a bit within an array, use this method:</simpara>
<screen>    video_buffer_A1(video_adress) = video_buffer_A1(video_adress) OR FnLSL( 1, BitNum)</screen>
<simpara>To set a bit within a variable, use this method:</simpara>
<screen>    Dim my_variable as byte
    Dim my_bit_address_variable as byte

    'example
    my_variable = 0
    my_bit_address_variable = 7

    my_variable.my_bit_address_variable = 1   ' where 1 or 0 or any bit address is valid

    'Sets bit 7 of my_variable therefore 128</screen>
<simpara><emphasis role="strong">String Variables</emphasis></simpara>
<simpara>Strings are defined as follows:</simpara>
<screen>    'Create buffer variables to store received messages

    Dim Buffer As String</screen>
<simpara>String variables default to the following rules and the RAM constraints
of a specific chip.</simpara>
<itemizedlist>
<listitem>
<simpara>10 bytes for chips with less than 16 bytes of RAM.</simpara>
</listitem>
<listitem>
<simpara>20 bytes for chips with 16 to 367 bytes of RAM.</simpara>
</listitem>
<listitem>
<simpara>40 bytes for devices with more RAM than 367 bytes.</simpara>
</listitem>
<listitem>
<simpara>For chips that have less RAM then the required RAM to support the user define strings the strings (and therefore the RAM) will be NOT be allocated. Please reduce string size.</simpara>
</listitem>
</itemizedlist>
<simpara>You cannot store a string 20 characters long in a chip with 16 bytes of RAM.</simpara>
<simpara>You can change the default string size handled internally by the GCBASIC compiler by changing the <literal>STRINGSIZE</literal> constant:</simpara>
<screen>    'set the default string to 24 bytes
    #define STRINGSIZE 24</screen>
<simpara>Defining a length for the string is the best way to limit memory usage.  It is good practice if you need a string of a certain size to set the length of a strings, since the default length for a string variable changes depending on the amount of memory in the microcontroller (see
above).</simpara>
<simpara>To set the length of a string, see the example below:</simpara>
<screen>    'Create buffer variables to store received messages as 16 bytes long
    Dim OutBuffer As String * 16</screen>
<simpara>To place quotation marks (" ") in a string of text. For example:</simpara>
<screen>    She said, "You deserve a treat!"</screen>
<simpara>To place quotation marks (") in a string of text, use two quotation marks in a row instead of one for each quote mark.  The following example shows two ways of printing <literal>She said, "You deserve a treat!"</literal>.  This technique works for all output methods (HSerPrint, Print, etc.)</simpara>
<screen>    HSerPrint "She said, ""You deserve a treat!"" "

    Dim myString As String * 39
    myString = "She said, ""You deserve another treat!"" "
    HSerPrint myString</screen>
<simpara><emphasis role="strong">Variable Aliases</emphasis></simpara>
<simpara>Some variables are aliases, which are used to refer to memory locations used by other variables. These are useful for joining predefined byte variables together to form a word variable.</simpara>
<simpara>Aliases are not like pointers in many languages - they must always refer to the same variable or variables and cannot be changed.</simpara>
<simpara>When setting a register/variable bit ( i.e  my_variable.my_bit_address_variable ) and using a alias for the variable then you must ensure the bytes that construct the variable are consective.</simpara>
<simpara>The coding approach should be to DIMension the variable (word, integer, or long) first, then create the byte aliases:</simpara>
<screen>    Dim my_variable as LONG
    Dim ByteOne   as Byte alias my_variable_E
    Dim ByteTwo   as Byte alias my_variable_U
    Dim ByteThree as Byte alias my_variable_H
    Dim ByteFour  as Byte alias my_variable

    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    'then, use the four byte variables as you need to.</screen>
<simpara>To set a series of registers that are not consecutive, it is recommended to use a mask variable then apply it to the registers:</simpara>
<screen>    Dim my_variable as LONG
    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    porta =  my_variable_E
    portb =  my_variable_E
    portc =  my_variable_E
    portd =  my_variable_E</screen>
<simpara><emphasis role="strong">Casting</emphasis></simpara>
<simpara>Casting changes the type of a variable or value.  To tell the compiler to perform a type conversion, put the desired type in square brackets before the variable.  The following example will cause two byte variables added together to be treated as a word variable.</simpara>
<screen>    Dim MyWord As Word
    MyWord = [word]ByteVar + AnotherByteVar</screen>
<simpara>Why do this?   Suppose that <literal>ByteVar</literal> is 150, and <literal>AnotherByteVar</literal> is 231.  When added, this will come to 381 - which will overflow, leaving 125 in the result.  However, when the cast is added, GCBASIC will treat <literal>ByteVar</literal> as if it were a word, and so will use the word addition code.  This will cause the correct result to be calculated.</simpara>
<simpara>It is good practice to cast when calculating an average:</simpara>
<screen>    MyAverage = ([word]Value1 + Value2) / 2</screen>
<simpara>It&#8217;s also possible to cast the second value instead of the first:</simpara>
<screen>    MyAverage = (Value1 + [word]Value2) / 2</screen>
<simpara>The result will be exactly the same.</simpara>
<simpara><?asciidoc-br?>
To apply operations to individual bits of variables see, <link linkend="_set">Set</link>, <link linkend="_rotate">Rotate</link>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>To check variables and apply logic based on their value, see
<link linkend="_if">If</link>, <link linkend="_do">Do</link>, <link linkend="_for">For</link>, <link linkend="_conditions">Conditions</link>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see:</emphasis> <link linkend="_dim">Declaring variables with DIM</link>, <link linkend="_setting_variables">Setting Variables</link></simpara>
</section>
<section xml:id="_advanced_variabletypes">
<title>Advanced VariableTypes</title>
<simpara><emphasis role="strong">About Advanced Variable Types</emphasis></simpara>
<simpara>A variable is an area of memory on the microcontroller that can be used to store a number or other data.&#160;&#160;
This is useful for many purposes, such as taking a sensor reading and acting on it, or counting the number of times the microcontroller has performed a particular task.</simpara>
<simpara>Each variable must be given a name, such as "MyVariable" or "PieCounter".&#160;&#160;
Choosing a name for a variable is easy - do not include spaces or any symbols (other than _), and make sure that the name is at least 2 characters (letters and/or numbers) long.</simpara>
<simpara><emphasis role="strong">Advanced Types</emphasis></simpara>
<simpara>There are a number different types of advanced variable types, and each type can store a different range of numeric information.&#160;&#160;</simpara>
<simpara>With respect to advanced variables GCBASIC supports:</simpara>
<itemizedlist>
<listitem>
<simpara>single floats which can be signed and unsigned.</simpara>
</listitem>
</itemizedlist>
<simpara>With respect to used advanced variables - please use Singles in your program as these have been tested.  The other types are documented for completeness and should be used by developers in libraries.</simpara>
<itemizedlist>
<listitem>
<simpara>double floats, and the large integers which can be signed &amp; unsigned</simpara>
</listitem>
</itemizedlist>
<simpara>Using advanced variable type maths is also much slower than integer maths when performing calculations and loops, therefore should be avoided if.&#160;&#160;
You should convert float calculations to integer maths to increase operation of your solution.&#160;&#160;
The example program (shown below) shows how use a float maths and you shuld try to do the same with integers and time the overall time for comparison.&#160;&#160;Typically, floats are 18%-20% slower than similar integer maths operations.
<?asciidoc-br?>
<?asciidoc-br?>
The advanced variable types that GCBASIC supports are:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="85*"/>
<colspec colname="col_2" colwidth="85*"/>
<colspec colname="col_3" colwidth="85*"/>
<colspec colname="col_4" colwidth="85*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Advanced Variable type</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Supported</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Information that this variable can store</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example uses for this type of variable</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Single</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>A numeric floating point values that range from -3.4x10 ^ 38 and +3.4x10 ^ 38  with up to seven significant digits.</simpara></entry>
<entry align="left" valign="top"><simpara>Storing decimal numbers that could be a negative number and positive.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Developers Only</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Developers Only</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Developers Only</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Developers Only</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LongINT</simpara></entry>
<entry align="left" valign="top"><simpara>Libraries only</simpara></entry>
<entry align="left" valign="top"><simpara>A list of whole numbers between - (2 ^ 63) and 2 ^ 63 - 1</simpara></entry>
<entry align="left" valign="top"><simpara>Storing very, very big integer numbers that could be a negative number.
</simpara><simpara>The GCBASIC range is -9999999999999990 to 9999999999999990.
</simpara><simpara>This range is an implementation constraint with the GCBASIC compiler.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>uLongINT</simpara></entry>
<entry align="left" valign="top"><simpara>Libraries only</simpara></entry>
<entry align="left" valign="top"><simpara>A whole number between 0 and 2 ^ 64 - 1</simpara></entry>
<entry align="left" valign="top"><simpara>Storing very, very, very big integer numbers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Double</simpara></entry>
<entry align="left" valign="top"><simpara>Libraries only</simpara></entry>
<entry align="left" valign="top"><simpara>A numeric floating point values that range from  -1.7x10 ^ 308 and +1.7x10 ^ 308 with up to 15 significant digits.</simpara></entry>
<entry align="left" valign="top"><simpara>Storing decimal numbers that could be a negative number and positive.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
The format for single and double floats is defined by the IEEE 754 standard.&#160;&#160;
Sign, exponent and mantissa are all in the positions described here: <link xlink:href="https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/">https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/</link></simpara>
<simpara><emphasis role="strong">Organisation of advanced variables</emphasis></simpara>
<simpara>GCBASIC stores advanced variables in bytes.&#160;&#160;
The format of these bytes is:</simpara>
<literallayout class="monospaced">_ D, _C, _B, _A, _E, _U, _H, variable_name  ( from high to Low)</literallayout>
<simpara>You can access the bytes within advanced variables using the following as a guide using the suffixes _A, _B, _C etc.</simpara>
<simpara>Example of accessing the lowest byte, the _H, _U and the _A bytes.</simpara>
<screen>    Dim workvariable as Single
    workvariable = 21845
    Dim lowb as byte
    Dim highb as byte
    Dim upperb as byte
    Dim lastb as byte


    lowb = workvariable
    highb = workvariable_H
    upperb = workvariable_U
    lastb = workvariable_A</screen>
<simpara><emphasis role="strong">Using the Byte components of Advanced Variables</emphasis></simpara>
<simpara>This is strict.  Accessing BYTE values of advanced variables requires the use cast.  Failure to use cast will cause issue with the low byte ( the low byte will tranformed into a Long integer and you will provide the low byte of the Long integer).</simpara>
<simpara>Example. Mandated  use of cast for single/float</simpara>
<screen>    Dim sNumC as Single

    HserPrint "Hex with [CAST] / "
    HSerPrint "0x"
    HserPrint Hex([BYTE]sNumC_E)
    HserPrint Hex([BYTE]sNumC_U)
    HserPrint Hex([BYTE]sNumC_H)
    HserPrint Hex([BYTE]sNumC)
    HserPrintCRLF</screen>
<simpara>Example assigning a HEX value to a single/float</simpara>
<screen>  //  Assing 0x3F19999A equates to 0.6

    [BYTE]mySingle  = 0x9A      // Strict usage of BYTE cast to ensure the correct value is assinged the low byte of the single variable.
    mySingle_H= 0x99            // Assign _H byte
    mySingle_U= 0x19            // Assign _U byte
    mySingle_E= 0x3f            // Assign _E byte</screen>
<simpara>Working example of assigning d0.5 or 0x3F000000 ( which is the IEEE574 hex value for d0.5 )</simpara>
<screen>    // Decimal assignement
      mySingle = 0.5

    // Hex assignment
        [BYTE]mySingle  = [single]0x00
        mySingle_H      = 0x00
        mySingle_U      = 0x00
        mySingle_E      = 0x3f</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Using Advanced Variables</emphasis></simpara>
<simpara>Advanced variables must be "DIMensioned" first.&#160;&#160;This involves using the DIM command,
to tell GCBASIC that it is dealing with an advanced variable.</simpara>
<screen>    Dim mySingle as Single
    mySingle= 1.1

    // The following types are for Libraries only

    Dim myLongInt as LongInt
    myLongInt = 9999999999999990          'see the Help for constraints

    Dim myuLongInt as uLongInt
    myuLongInt = 0xFFFFFFFFFFFFF          'see the Help for constraints

    Dim myDouble as Double
    myDouble=3.141592</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Using Advanced Variables</emphasis></simpara>
<simpara>Advanced variables are only supported by a subset of the functions of GCBASIC.&#160;&#160;</simpara>
<simpara>The functional characteristics are:</simpara>
<itemizedlist>
<listitem>
<simpara>Dimensioning of  longInt, ulongInt, single and double advanced variable types.</simpara>
</listitem>
<listitem>
<simpara>Assigning advanced variables creation of values from constants.</simpara>
</listitem>
<listitem>
<simpara>Assigning a single to double and double to single.</simpara>
</listitem>
<listitem>
<simpara>Assigning single to long and long to single.</simpara>
</listitem>
<listitem>
<simpara>Assigning double to long and long to double.</simpara>
</listitem>
<listitem>
<simpara>The assignment of a single or a double to a long also deals with byte and word.&#160;&#160; This is very inefficient.</simpara>
</listitem>
<listitem>
<simpara>Copying between variables of the same type (so double to double, and single to single and other advanced variables).</simpara>
</listitem>
<listitem>
<simpara>Extract of the unit value of a single or double variable to a long variable.</simpara>
</listitem>
<listitem>
<simpara>Setting of advanced variable bits.</simpara>
</listitem>
<listitem>
<simpara>Addition and subtraction of advanced variables.</simpara>
</listitem>
<listitem>
<simpara>Rotate of longInt &amp; ulongInt advanced variables.</simpara>
</listitem>
<listitem>
<simpara>Negate of longInt &amp; ulongInt advanced variables.</simpara>
</listitem>
<listitem>
<simpara>Boolean operators working on advanced variables.</simpara>
</listitem>
<listitem>
<simpara>Use of  float variable(s) as global variables. &#160;&#160;Passing float variable(s) as parameters to methods ( sub, function and macro) not supported.</simpara>
</listitem>
<listitem>
<simpara>Support for conditional statements</simpara>
</listitem>
<listitem>
<simpara>Support for overload subs/functions</simpara>
</listitem>
<listitem>
<simpara>Passing float variable(s) as parameters to methods ( sub, function and macro)</simpara>
</listitem>
<listitem>
<simpara>Extraction of mantissa value</simpara>
</listitem>
<listitem>
<simpara>Multiplication</simpara>
</listitem>
<listitem>
<simpara>Division</simpara>
</listitem>
<listitem>
<simpara>Modulo</simpara>
</listitem>
<listitem>
<simpara>SingleToString</simpara>
</listitem>
<listitem>
<simpara>StringToSingle</simpara>
</listitem>
<listitem>
<simpara>Advanced variable(s) to string functions</simpara>
</listitem>
<listitem>
<simpara>Math functions for float variable(s) ( plus pseudo functions shown below)</simpara>
</listitem>
</itemizedlist>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Assigning Values to Advanced Variables</emphasis></simpara>
<simpara>You can assign values to advanced variables using&#160;&#160;`=`.&#160;&#160;</simpara>
<simpara>A simple, but typical example follows.&#160;&#160;This is the typical for numeric variable assignment.</simpara>
<screen>    Dim mySingle as Single
    mySingle = 123.4567       'assign the value</screen>
<simpara>Another example is bitwise assignments as follows:</simpara>
<screen>    mySingle.16 = 1  'set the single bit to 1</screen>
<simpara> +<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">INT() and SINGLRROUND()</emphasis></simpara>
<simpara>Floating point numbers are not exact, and may yield unexpected results when compared using conditions (IF etc).&#160;&#160;
For example 6.0 / 3.0 may not equal 2.0.&#160;&#160;
Users should instead check that the absolute value of the difference between the numbers is less than some small number.
<?asciidoc-br?></simpara>
<simpara>These techniques can replace the INT() and SINGLEROUND() functions.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis>Alternative to INT()</emphasis></simpara>
<simpara>Assignment of a Single variable to an Interger variable is supported.&#160;&#160;</simpara>
<simpara>So, use the conversion from floating point to integer as this results in integer truncation.</simpara>
<screen>        dim mySingleVar as Single
        mySingleVar = 2.9  'A float type variable

        dim myLongVar as Long
        myLongVar = mySingleVar ' will set myLongVar to 2</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis>Alterntive tp ROUNDSSINGLE()</emphasis></simpara>
<simpara>As an alternative to using the ROUNDSSINGLE() function.&#160;&#160;</simpara>
<simpara>Create your own round conversion,  add 0.5 to return the nearest integer.&#160;&#160;As follows:</simpara>
<screen>        'Add 0.5 to a single or double and then assign to an integer variable

        dim mySingleVar as Single
        mySingleVar = 2.9

        dim myLongVar as Long
        myLongVar= mySingleVar + [single]0.5</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example Program</emphasis></simpara>
<simpara>This program shows the values of calculation of 4.5 * multiplied by a number ( 4.5 x a range of 0 to 40,000).&#160;&#160;
The program shows setting up the advanced variables, assigned a value and completing the multiplication of the initial value using a for-next loop.&#160;&#160;</simpara>
<screen>    HSerPrintCRLF 2
    HSerPrint "Maths test "
    HSerPrintCRLF 2

    DIM multiplier as Word
    DIM ccount as Single
    Dim result as Single

    HSerPrint "Use floats with multiplier maths"
    HSerPrintCRLF

    'Assign a value to the variable
    ccount   = 4.5

      'Do some maths... multiplier x ccount
      For  multiplier = 0 to 40000 step 2500

        HSerPrint SingleToString(ccount)
        HSerPrint " x "
        HSerPrint left(WordToString(multiplier)+"        ", 10 )
        HSerPrint " = "

        'Calculate the result
        result = multiplier * ccount
        HSerPrint left(SingleToString(result)+"          ", 10 )
        HSerPrintCRLF
      next

      Do Forever
      Loop</screen>
<simpara>To check variables and apply logic based on their value, see
<link linkend="_if">If</link>, <link linkend="_do">Do</link>, <link linkend="_for">For</link>, <link linkend="_conditions">Conditions</link>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see:</emphasis> <link linkend="_dim">Declaring variables with DIM</link>, <link linkend="_setting_variables">Setting Variables</link></simpara>
</section>
<section xml:id="_variable_memory_allocation">
<title>Variable Memory Allocation</title>
<simpara>This section discusses the allocation of variables to RAM ( GPR, SRAM or other TLA).</simpara>
<simpara>Variables in GCBASIC can be bits, bytes, words, integers, longs, arrays or reals. &#160;&#160;This section will NOT address reals as these are developmental variables only.</simpara>
<simpara>Variables can also be defined as Aliases - this is discussed later in this section.</simpara>
<simpara><emphasis role="strong">Basic variable allocation</emphasis></simpara>
<simpara>Variables of  type <emphasis>byte</emphasis>, <emphasis>word</emphasis>, <emphasis>integer</emphasis>, <emphasis>longs</emphasis> are placed in RAM using the following simple rules.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A RAM memory location  is automatically assigned starting at the first available memory location.</simpara>
</listitem>
<listitem>
<simpara>The first memory location is first RAM location as defined in the chip datasheet.</simpara>
</listitem>
<listitem>
<simpara>Once a variable is allocated the RAM location is marked as used and this specific location can be reviewed in the ASM source.</simpara>
</listitem>
<listitem>
<simpara>Bytes use a single  RAM location, words two  RAM locations, integer and longs four  RAM locations.</simpara>
</listitem>
<listitem>
<simpara>Subsequent variables of type byte, word, integer, longs are placed in RAM at the next available RAM location.</simpara>
</listitem>
</orderedlist>
<simpara>Variables of  <emphasis>array</emphasis> and <emphasis>strings</emphasis> type are placed in RAM using the following simple rules.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A RAM memory location is automatically assigned from the end of RAM less the ( size of the array + 1 byte ).</simpara>
</listitem>
<listitem>
<simpara>The last memory location is last RAM location as defined in the chip datasheet.</simpara>
</listitem>
<listitem>
<simpara>Once an array is allocated the RAM location is marked as used and the start of the array RAM location can be reviewed in the ASM source.</simpara>
</listitem>
<listitem>
<simpara>Subsequent variables of type array in RAM at the next available RAM location subtracted from the start the of previous RAM location minus the size of this next array.</simpara>
</listitem>
</orderedlist>
<simpara>Variables of <emphasis>bit</emphasis> type are placed in RAM using the following simple rules.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Bit memory location is automatically assigned to the first bit with the creation of a BYTE variable at a RAM memory location that is automatically assigned starting at the first available memory location. &#160;&#160; This byte can handle 8 bits.</simpara>
</listitem>
<listitem>
<simpara>Once a bit is allocated the byte is marked as used and this specific location can be reviewed in the ASM source.</simpara>
</listitem>
<listitem>
<simpara>Subsequent bits are allocation either to an existing byte variable, or when 8 bits are allocated to an existing byte variable another byte variable will be created.</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">Addressing Variables</emphasis></simpara>
<simpara>Addressing variable can be achieved by using the @ prefix. &#160;&#160; This will return the address of the variable (the same @ applies to table data).</simpara>
<simpara>The following example shows registers DMAnSSAU, DMAnSSAH, DMAnSSAL being loaded with the address of the array WaveArray.</simpara>
<screen>    ' Source start address
    Dim addressdummy as byte
    Dim DMAnSS as long ALIAS addressdummy, DMAnSSAU, DMAnSSAH, DMAnSSAL
    DMAnSS = @WaveArray</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">AT allocation</emphasis></simpara>
<simpara>The Dim variable command can be used to instruct GCBASIC to allocate variables  at a specific memory location using the parameter AT.</simpara>
<simpara>The compiler will inspect the provided AT memory location and if the memory location is already used ( by an existing variable), lower than the minimum memory location or greater than the maximum memory location an error will be issued.</simpara>
<simpara><?asciidoc-br?>
<emphasis role="strong">Variable Aliases</emphasis></simpara>
<simpara>Variable can be defined as  aliases. &#160;&#160; Aliases  are used to refer to existing memory locations SFR or RAM and aliases can be used to construct other variables.&#160;&#160;  Constructed variables can be a mix  ( or not ) of SFR or RAM.  &#160;&#160; These are useful for joining predefined byte variables together to form a word/long variable.</simpara>
<simpara>Aliases are not like pointers in many languages - they must always refer to an existing variable or variables and cannot be changed.</simpara>
<simpara>When setting a register/variable bit ( i.e  my_variable.my_bit_address_variable ) and using a alias for the variable then you must ensure the bytes that construct the variable are consecutive.</simpara>
<simpara>Aliases are shown in the ASM source in the ;ALIAS VARIABLES section.</simpara>
<simpara>The coding approach should be to DIMension the variable (word, integer, or long) first, then create the byte aliases:</simpara>
<screen>    Dim my_variable as LONG
    Dim ByteOne   as Byte alias my_variable_E
    Dim ByteTwo   as Byte alias my_variable_U
    Dim ByteThree as Byte alias my_variable_H
    Dim ByteFour  as Byte alias my_variable

    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    'then, use the four byte variables as you need to.</screen>
<simpara>To set a series of registers that are not consecutive, it is recommended to use a mask variable then apply it to the registers:</simpara>
<screen>    Dim my_variable as LONG
    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    porta =  my_variable_E
    portb =  my_variable_E
    portc =  my_variable_E
    portd =  my_variable_E</screen>
<simpara><emphasis role="strong">Memory Specification</emphasis></simpara>
<simpara>All memory specifics like RAM size, lower and upper RAM addresses are specified in the chip specific dat file.</simpara>
<simpara>The dat file details should be reviewed in PICINFO application.   See the PICINFO/CHIPDATA tab for RAM and MaxAddress etc.</simpara>
<simpara>A simple calculation is MaxAddress - RAM +1 = the 'first memory address'.  And, 'first memory address' + RAM -1 = 'the last memory address.</simpara>
<simpara>This can be confirmed by review the DAT file. See the section [FreeRAM] for the start and end of RAM.</simpara>
<simpara>The dat file also has a [NoBankRAM].  NoBankRAM is somewhat misnamed - it is used for the defintion of (any) access bank locations.&#160;&#160; If a memory location is defined in both NoBankRAM and FreeRAM, then the compiler knows that it is access bank RAM.&#160;&#160;If an SFR location is in one of the NoBankRAM ranges, then the compiler knows not to do any bank selection when accessing that register.</simpara>
<simpara>The [NoBankRAM] section includes two ranges, one for access bank RAM, one for access bank SFRs.
The first range MUST be the ACCESS RAM range
The first range is the FAST SFR range</simpara>
<simpara>If there are no ranges defined in NoBankRAM, the compiler will try to guess them.&#160;&#160;
On 18Fs, it will guess based on where the lowest SFR is, and from what the total RAM on the chip is.&#160;&#160; If there&#8217;s only one range defined. &#160;&#160; in the NoBankRAM locations, the compiler will assume that is the range for the RAM, and then will guess where the range for the access bank SFRs is.</simpara>
<screen>    'GCBASIC/GCGB Chip Data File
    'Chip: 18F27Q43

    [ChipData]

    .... many other data rows

    'This constant is exposed as ChipRAM
    RAM=8192             'Dec values

    .... many other data rows

    'This constant is exposed as ChipMaxAddress
    MaxAddress=9471      'Dec values

    .... many other data rows

    [FreeRAM]
    500:24FF             'Hex value

    [NoBankRAM]
    500:55F              'Hex value
    460:4FF              'Hex value

    .... many other data rows</screen>
<simpara><?asciidoc-br?></simpara>
<simpara>In the example shown above the following can be extracted.
<?asciidoc-br?></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>RAM size:              RAM = 8192d</simpara>
</listitem>
<listitem>
<simpara>Minimum RAM address:   FREERAM = 0x500</simpara>
</listitem>
<listitem>
<simpara>Maximum RAM address:   FREERAM = 0x24FF</simpara>
</listitem>
<listitem>
<simpara>Maximum RAM address:   MAXADDRESS=9471d or 0x24FF</simpara>
</listitem>
<listitem>
<simpara>ACCESS RAM:            NOBANKRAM = 0x500-0x55F</simpara>
</listitem>
<listitem>
<simpara>BANKED SFR:            NOBANKRAM = 0x460-0x4FF</simpara>
</listitem>
</orderedlist>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
</section>
<section xml:id="_reference_data">
<title>Reference Data</title>
<section xml:id="_efficient_implementation_of_lookup_reference_tables_in_gcbasic">
<title>Efficient Implementation of Lookup Reference Tables in GCBASIC</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>This section explores the efficient implementation of lookup reference tables in embedded systems, specificially GCBASIC, focusing on the use of PROGMEM memory to store fixed data sets. It addresses common misconceptions about data storage and initialization, compares different methods of data handling, and provides advanced techniques for optimizing memory usage.</simpara>
<simpara>Lookup reference tables are essential in embedded systems for storing fixed data sets that can be accessed during runtime. This section aims to clarify the correct implementation of these tables, debunking common myths and providing practical solutions for efficient data management.</simpara>
<simpara><emphasis role="strong">Conventional Misconceptions</emphasis></simpara>
<simpara>A common misconception is that the data required by a fixed lookup table is defined by its content and declared in a Dim statement, with its data filled at runtime. This implies that an array ( in RAM memory ) is empty initially and populated during initialization, leading to data duplication and wasted memory resources.</simpara>
<simpara><emphasis role="strong">Correct Implementation</emphasis></simpara>
<simpara>A fixed lookup table is a set of data (bytes, words, etc.) stored in the PROGMEM memory. The correct implementation involves using the TABLE and READTABLE commands:
* Definition: <literal>TABLE tablename&#8230;&#8203; data&#8230;&#8203; END TABLE</literal>
* Reading: <literal>READTABLE</literal>
There is no DIM in the definition process, and the data is part of the hex file, not filled at runtime.</simpara>
<simpara><emphasis role="strong">Memory Efficiency</emphasis></simpara>
<simpara>Storing data in PROGMEM ensures that there is only one copy of the data, avoiding duplication. Copying data to an array is redundant as reading the table can replace the array.</simpara>
<simpara><emphasis role="strong">Practical Solutions</emphasis></simpara>
<simpara>Using <literal>TABLE - END TABLE</literal> is the simplest way to handle data. For data sets smaller than the EEPROM in the chip, load the table directly to EEPROM and use <literal>READTABLE</literal> to read the data.</simpara>
<simpara><emphasis role="strong">Advanced Techniques</emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>PROGMEM Page Size Constraint: On the 16F, <literal>TABLE-END TABLE</literal> is constrained by PROGMEM page size (2048 items).</simpara>
</listitem>
<listitem>
<simpara>EEPROM Storage: Use <literal>EEPROM .. END EEPROM</literal> and a direct method like <literal>PROGREAD</literal>. Data is stored in EEPROM, constrained by its size and typically byte values.</simpara>
</listitem>
<listitem>
<simpara>Direct PROGMEM Storage: Use <literal>DATA .. END DATA</literal> and <literal>PROGREAD</literal>. Data is stored in PROGMEM, constrained by unused PROGMEM size and typically word values (max 0x3FFF for 16F chips).</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">Arrays in Embedded Systems</emphasis></simpara>
<simpara>An array is a special type of variable that can store multiple values, addressed individually using an index. Arrays can be bytes, longs, integers, or words, and are held in RAM. Loading an array can be done element by element or all at once.</simpara>
<simpara><emphasis role="strong">Comparison of Methods</emphasis></simpara>
<simpara>Using arrays can be costly in terms of RAM and PROGMEM. The following examples illustrate the difference:</simpara>
<simpara><emphasis role="strong">Using an Array</emphasis></simpara>
<simpara>64 words Progmem / 13 bytes RAM</simpara>
<screen>        #CHIP 18F2550
        #option Explicit

        Dim myResult, myIndex as Byte

        // Using an array 64 words Progmem / 13 bytes RAM
        Dim myArray(10)
            myArray = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
        For myIndex = 1 to 10
            myResult =  myArray(myIndex)
        Next</screen>
<simpara><emphasis role="strong">Using a Table</emphasis></simpara>
<simpara>56 words Progmem / 2 bytes RAM</simpara>
<screen>        #CHIP 18F2550
        #option Explicit

        Dim myResult, myIndex as Byte

        // Using a table 56 words Progmem / 2 bytes RAM
        For myIndex = 1 to 10
            ReadTable myTable, myIndex, myResult
        Next

        Table myTable
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10
        End Table</screen>
<simpara><emphasis role="strong">Usage</emphasis></simpara>
<simpara>The <literal>ReadTable</literal> method provides data set capabilities to chips with limited RAM, using fewer resources and offering faster performance. Advanced techniques and proper understanding of memory usage can significantly optimize embedded system performance.</simpara>
<simpara><emphasis role="strong">Notes</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>A byte array is handled similarly to a string, which can be resource-intensive.</simpara>
</listitem>
</itemizedlist>
<simpara>By following these guidelines, developers can efficiently implement lookup reference tables in embedded systems, optimizing memory usage and performance.</simpara>
</section>
</section>
<section xml:id="_syntax">
<title>Syntax</title>
<section xml:id="_arrays">
<title>Arrays</title>
<simpara><emphasis role="strong">About Arrays</emphasis></simpara>
<simpara>An array is a special type of variable - one which can store several values at once.&#160;&#160;It is essentially a list of numbers in which each one can be addressed individually through the use of an "index".</simpara>
<simpara>The numbers can be bytes (the default), longs, integers, or words.  &#160;&#160;The index is a value in brackets immediately after the name of the array.</simpara>
<simpara>All the numbers stored in an array must be of the same type.  &#160;&#160;For instance, you cannot store bytes and words in the same array.</simpara>
<simpara>Array are are 1-based. &#160;&#160;The first element is element zero.</simpara>
<simpara>Examples of array names are:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Array/Index</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Meaning</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Fish(10)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Definition of an array containing bytes with 10 elements called <literal>Fish</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>x(5) As Word</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Definition of an array containing words with 5 elements called <literal>x</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DataLog(2)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The second element in an array named <literal>DataLog</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ButtonList(Temp)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An element in the array <literal>ButtonList</literal> that is selected according to the
value in the variable <literal>Temp</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Defining an array</emphasis></simpara>
<simpara>Use the DIM command to define an array.</simpara>
<screen>    DIM array_title ( number_of_elements ) [As _type_]</screen>
<simpara>The number of elements can be number or a constant - not a variable.</simpara>
<simpara>The value for the number elements in an array must be a number or constant.
The compiler allocates RAM for arrays at compile time, and therefore you cannot use a variable because during compilation the value of a variable cannot be determined.</simpara>
<simpara><emphasis role="strong">Assigning values to an array</emphasis></simpara>
<simpara>It is possible to set several elements of a byte array with a single line of code. This short example shows how:</simpara>
<screen>    Dim TestVar(10)
    TestVar = 1, 2, 3, 4, 5, 6, 7, 8, 9</screen>
<simpara>When using this method above element 0 of the array TestVar will be set to the number of items in the list, which in this case is 9. &#160;&#160;Each element of the array will then be loaded with the corresponding value in the list - so in the example, TestVar(1) will be set to 1, TestVar(2) to 2, and so on.  &#160;&#160;Element 0 will only be set to number of items in the array when using this method.   &#160;&#160;For microcontrollers with less than 2048 bytes of RAM the limit is 250 elements or the array cannot exceed the microcontrollers RAM size.  &#160;&#160;For microcontrollers with more than 2048 bytes of RAM the limit is 255 elements.</simpara>
<simpara>This only works for <emphasis role="strong">byte</emphasis> arrays, however.  For arrays of type <literal>integer</literal>, <literal>word</literal>, or <literal>long</literal>, each element must be set separately:</simpara>
<screen>    Dim TestVar(5) As Word
    TestVar(1) = 20
    TestVar(2) = 50
    TestVar(3) = 60
    TestVar(4) = 80
    TestVar(5) = 100</screen>
<simpara>If each element has the same value, this can be shortened using a loop:</simpara>
<screen>    Dim TestVar(5) As Word
    For i = 1 to 5
        TestVar(i) = 0
    Next</screen>
<simpara><emphasis role="strong">Array Length</emphasis></simpara>
<simpara>Element 0 should not be used to obtain the length of the array.&#160;&#160; Element 0 will only be a consistent with respect to the length of the array when the array is set as shown above.</simpara>
<simpara>The correct method is to use a constant to set the array size and use the constant within your code to obtain the array length.</simpara>
<screen>    #Define ArraySizeConstant 500
    Dim TestVar( ArraySizeConstant )

    SerPrint ArraySizeConstant     'or, other usage</screen>
<simpara><emphasis role="strong">Using Arrays</emphasis></simpara>
<simpara>To use an array, its name is specified, then the index. Arrays can be used everywhere that a normal variable can be used.</simpara>
<simpara><emphasis role="strong">Maximum Array Size</emphasis></simpara>
<simpara>The limit on the array size is dependent on the chip type, the amount of RAM, and the number of other variable you use in your program.</simpara>
<simpara>Use the following simple program to determine the maximum array size. Set <literal>CHIP</literal> to your device, <literal>MAXSCOPE</literal> to a value which is less the total RAM, and the data type of <literal>test_array</literal> to the data type to be stored in the array.</simpara>
<simpara>The data type of <literal>imaxscope</literal> must be set to match the size of the constant <literal>MAXSCOPE</literal>.  If <literal>MAXSCOPE</literal> &#8656; 255, <literal>imaxscope</literal> should be a byte.&#160;&#160;  If <literal>MAXSCOPE</literal> &gt; 255, <literal>imaxscope</literal> should be a word.</simpara>
<simpara>If the array is too large to fit, the compiler will issue an error message.  &#160;&#160;Reduce MAXSCOPE until the error message is not issued.  &#160;&#160;The largest <literal>MAXSCOPE</literal> value without an error message is the largest useable array of this type for this chip.</simpara>
<screen>    #CHIP   12f1571
    #OPTION Explicit

    #DEFINE MAXSCOPE  111
    DIM     imaxscope As Byte
    DIM     test_array( MAXSCOPE ) As Byte


    For imaxscope = 0 to MAXSCOPE
      test_array( imaxscope ) = imaxscope
    Next</screen>
<simpara>For the Atmel AVR, LGT 328p or an 18F array sizes are limited to 10,000 elements.</simpara>
<simpara>If a memory limit is reached, the compiler will issue an error message.</simpara>
<simpara><emphasis role="strong">Get the most from the available memory</emphasis></simpara>
<simpara>Array RAM usage is determined by the architecture of the chip type. &#160;&#160;Getting most out of the available memory is determined by the allocation of the array within the available banks of memory.</simpara>
<simpara>An example is an array of 6 or 7 bytes when there is only 24 bytes of RAM  and the 24 bytes is split across multiple memory banks.  &#160;&#160;Assume in this example that 18 bytes have allocated to other variables and there is 29 bytes total available.  &#160;&#160;An array of 6 bytes will fit into the free space in one bank, but the array of 7 will not.</simpara>
<simpara>GCBASIC currently cannot split an array over banks, so if there are 6 bytes free in one bank and 5 in another, you cannot have an array of 7 bytes. &#160;&#160; This would be very hard to do efficiently on 12F/16F as there would be a series of special function registers in the middle of the array when using a 12F or 16F.   &#160;&#160;This constraint is not the case on 16F1/18F as linear addressing makes it easy to span banks because the SFRs are not making the problem (as with 12F/16F).</simpara>
<simpara><emphasis role="strong">Using Tables as an alternative.</emphasis></simpara>
<simpara>If there are many items in the array, it may be better to use a Lookup Table to store the items, and then copy some of the data items into a smaller array as needed.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_dim">Declaring arrays with DIM</link>,<link linkend="_alloc">Declaring memory with ALLOC</link></simpara>
</section>
<section xml:id="_comments">
<title>Comments</title>
<simpara><emphasis role="strong">About Comments</emphasis></simpara>
<simpara>Adding comments to your GCBASIC program can be done using a number of methods. &#160;&#160;
Explanatory notes embedded within the code.&#160;&#160;
Comments are used to remind yourself and to inform others about the function of your program.&#160;&#160;
Comments are ignored by the compiler</simpara>
<simpara>You can comment out sections of code if you want just by placing an apostrophe at
the beginning of each line. The GCBASIC IDE has a feature to do this automatically.
<?asciidoc-br?>
<?asciidoc-br?>
You can also use a REM (for REMark statement), a semi-colon or two forward slashes.
<?asciidoc-br?>
<?asciidoc-br?>
Multiline comments are support for large text descriptions of code or to comment out chunks of code while debugging applications.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    /*
      block comment
    */</screen>
<simpara>Warning: Graphical GCBASIC uses semi-colons to mark comments that it has
inserted automatically. It does not read these comments when opening a file, so any
comments in a GCBASIC program starting with a semi-colon will be deleted if the
program is opened using Graphical GCBASIC.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ' The number of pins to flash
    #define FlashPins 2

    REM You can create a header using an apostrophe before each line
    REM This is a great way to describe your program
    REM You can also use it to describe the hardware connections.

    ' You can place comments above the command or on the same line
    Dir PORTB Out ' Initialise PORTB to all Outputs

    ; The Main loop
    do
    PORTB = 0 ' All Pins off
    Wait 1 S ' Delay 1 second
    PORTB = 0xFF ' All pins on
    Wait 1 s ' Delay 1 second
    Loop</screen>
</section>
<section xml:id="_line_continuation">
<title>Line Continuation</title>
<simpara><emphasis role="strong">About Line Continuation</emphasis></simpara>
<simpara>A single _ (underscore) character at the end of a line of code tells the compiler that the line continues in the next line.  This allows a single statement (line of code) to be spread across multiple lines in the input file, which can provide nice formatting.</simpara>
<simpara>Be careful when adding the _ line continuation character right behind an identifier or keyword. It MUST be separated with at least <emphasis role="strong">one space</emphasis> character, otherwise it would be treated as part of the identifier or keyword.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    #CHIP 18f27k42

    Dim sMyString As String
        sMyString ="one _
                   two _
                   three _
                   four _
                   five _
                   six _
                   seven _
                   eight _
                   nine _
                   ten _
                   eleven _
                   twelve _
                   thirteen _
                   fourteen _
                   fifteen _
                   sixteen _
                   seventeen _
                   eighteen _
                   nineteen _
                   twenty _
                   twentyOne _
                   twentyTwo _
                   twentyThree _
                   twentyFour _
                   twentyFive"

    HSerPrint sMyString</screen>
<simpara>This example will print on the serial terminal the string "one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty twentyOne twentyTwo twentyThree twentyFour twentyFive"</simpara>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    Sub Aiguillages (In voie_principale As Byte, _
                     In voie_marchandises As Byte, _
                     In voie_gravier As Byte)

        ' code segment
        ' code segment
        ' code segment

    End Sub</screen>
<simpara>This example improves the layout of definition of the sub-routine.</simpara>
<simpara><emphasis role="strong">Example 3:</emphasis></simpara>
<screen> #DEFINE Ouvrir_voie_marchandises Aiguillages _
              (0, Marche_avant, Marche_arriere)</screen>
<simpara>This example creates a constants over two lines.  This improves readability.</simpara>
</section>
<section xml:id="_conditions">
<title>Conditions</title>
<simpara><emphasis role="strong">About Conditions</emphasis></simpara>
<simpara>In GCBASIC (and most other programming languages) a condition is a
statement that can be either true or false. Conditions are used when the
program must make a decision.
A condition is generally given as a value or variable, a relative
operator (such as = or &gt;), and another value or variable. Several
conditions can be combined to form one condition through the use of
logical operators such as AND and OR.</simpara>
<simpara>GCBASIC supports these relative operators:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="60%"?>
<?dbfo table-width="60%"?>
<?dblatex table-width="60%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="128*"/>
<colspec colname="col_2" colwidth="128*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Symbol</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Meaning</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara><literal>=</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Equal</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&lt;&gt;</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Not Equal</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&lt;</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Less Than</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&gt;</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Greater Than</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&#8656;</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Less than or equal to</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&gt;=</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Greater than or equal to</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>In addition, these logical operators can be used to combine several
conditions into one:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Name</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Abbreviation</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Condition true if</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara><literal>AND</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>&amp;</literal></simpara></entry>
<entry align="center" valign="top"><simpara>both conditions are true</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>OR</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>|</literal></simpara></entry>
<entry align="center" valign="top"><simpara>at least one condition is true</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>XOR</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>#</literal></simpara></entry>
<entry align="center" valign="top"><simpara>one condition is true</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>NOT</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>!</literal></simpara></entry>
<entry align="center" valign="top"><simpara>the condition is not true</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>NOT is slightly different to the other logical operators, in that it
only needs one other condition. Other arithmetic operators may be
combined in conditions, to change values before they are compared, for
example.</simpara>
<simpara>GCBASIC has two built in conditions - TRUE, which is always true, and
FALSE, which is always false. These can be used to create Conditional tests and infinite
loops.</simpara>
<simpara>The condition bit_variable = TRUE is treated as TRUE if the bit is on.&#160;&#160;Any non-zero value will be treated as equal to a high bit.
The condition bit_variable  = other_type_of_variable generates a warning.&#160;&#160;If the byte_variable is set to TRUE and then compared to the bit, it will always be FALSE because the high bit will be treated as a 1.&#160;&#160;But the new warning will be generated, "Comparison will fail if %nonbit% is any value other than 0 or 1"</simpara>
<simpara>It is also possible to test individual bits in conditions. To do this,
specify the bit to test, then 1 or 0 (or ON and OFF respectively).
Presently there is no way to combine bit tests with other conditions -
NOT, AND, OR and XOR will not work.</simpara>
<simpara><emphasis role="strong">Example conditions:</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Condition</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Comments</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Temp = 0</simpara></entry>
<entry align="left" valign="top"><simpara>Condition is true if Temp = 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Sensor &lt;&gt; 0</simpara></entry>
<entry align="left" valign="top"><simpara>Condition is true if Sensor is not 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Reading1 &gt; Reading2</simpara></entry>
<entry align="left" valign="top"><simpara>True if Reading1 is more than Reading2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Mode = 1 AND Time &gt; 10</simpara></entry>
<entry align="left" valign="top"><simpara>True if Mode is 1 and Time is more than 10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Heat &gt; 5 OR Smoke &gt; 2</simpara></entry>
<entry align="left" valign="top"><simpara>True if Heat is more than 5 or Smoke is more than 2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Light &gt;= 10 AND (NOT Time &gt; 7)</simpara></entry>
<entry align="left" valign="top"><simpara>True if Light is 10 or more, and Time is 7 or less</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Temp.0 ON</simpara></entry>
<entry align="left" valign="top"><simpara>True if Temp bit 0 is on</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Constraints when using Conditional Test</emphasis></simpara>
<simpara>As GCBASIC is very flexible with the use of variables type this can cause issues when testing constants and/or functions.</simpara>
<simpara>A few simple rules. <emphasis role="strong">Always put the function or constant first, or, always call the function with the addition of the braces.</emphasis></simpara>
<simpara>The example code below shows the correct method and an example that does compile but will not work as expected.</simpara>
<screen>    'Example A - works
    'Call the function by adding the braces
    '
    Do
    Loop While HSerReceive() &lt;&gt; 62

    'Example B - works
    'Please the constant first - this is the general rule - put the constant first.
    '
    Do
    Loop While 62 &lt;&gt; HSerReceive</screen>
<simpara>This fails as the function will not be called</simpara>
<screen>    'Example C - compiles but does not operate as expected
    Do
    Loop While HSerReceive &lt;&gt; 62</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_constants">
<title>Constants</title>
<simpara><emphasis role="strong">About Constants</emphasis></simpara>
<simpara>A constant tells the compiler to find a given
word, and replace it with another word or number. Define directives create constants.</simpara>
<simpara>Constants are useful for situations where a routine needs to be easily altered. For example, a
define could be used to specify the amount of time to run an alarm for
once triggered.</simpara>
<simpara>It is also possible to use defines to specify ports - thus defines can
be used to aid in the creation of code that can easily be adapted to run
on a different microcontroller with different ports.</simpara>
<simpara>GCBASIC makes considerable use of defines internally. For instance, the
LCD code uses defines to set the ports that it must use to communicate
with the LCD.</simpara>
<simpara><emphasis role="strong">About Defines</emphasis></simpara>
<simpara>To create a define is a matter of using the #define directive. Here are
some examples of defines:</simpara>
<screen>    #define Line 34
    #define Light PORTB.0
    #define LightOn Set PORTB.0 on</screen>
<simpara><literal>Line</literal> is a simple constant - GCBASIC will find <literal>Line</literal> in the program, and
replace it with the number 34. This could be used in a line following
program, to make it easier to calibrate the program for different
lighting conditions.</simpara>
<simpara><literal>Light</literal> is a port - it represents a particular pin on the microcontroller. This
would be of use if the program had many lines of code that controlled
the light, and there was a possibility that the port the light was
attached to would need to change in the future.</simpara>
<simpara><literal>LightOn</literal> is a define used to make the program more readable. Rather than
typing <literal>Set PORTB.0 on</literal> over and over, it would then be made possible to
type <literal>LightOn</literal>, and have the compiler do the hard work.</simpara>
<simpara><emphasis role="strong">GCBASIC Defined constants</emphasis></simpara>
<screen>    #define ON 1
    #define OFF 0
    #define TRUE 255
    #define FALSE 0

    'Names for symbols
    #define AND &amp;
    #define OR |
    #define XOR #
    #define NOT !
    #define MOD %</screen>
<simpara><emphasis role="strong">GCBASIC special constant</emphasis></simpara>
<simpara><literal>Forever</literal> is a special constant.  For Graphical GCBASIC users think of this as 'false'. For those not using Graphical GCBASIC think of this as a non numeric value that has no value.  You can use <literal>Forever</literal> in a DO-LOOP but not in a REPEAT-END REPEAT loop, as the in the later case the REPEAT will have no value and you will create an error condition.</simpara>
<simpara><emphasis role="strong">Precedence of Constants within GCBASIC.</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The <literal>#define</literal> command creates constants, and, a script can creates constants.
<?asciidoc-br?>
<?asciidoc-br?>
The precedence is as follows:
<?asciidoc-br?>
<?asciidoc-br?>
<literal>#define</literal> in the main program are read first,
<?asciidoc-br?>
<?asciidoc-br?>
then, the <literal>#define</literal> in the include files. Constants defined in the include files will be ignored if they conflict or are different to another constant in the main program,
<?asciidoc-br?>
<?asciidoc-br?>
then, the scripts are processed. Scripts that create constants always override any constant value previously defined.
<?asciidoc-br?>
<?asciidoc-br?>
Scripts are highest priority, then constants in the main program, then constants in include files from the main program, then constants in the standard libraries.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>See <emphasis role="strong"><link linkend="__define">#define</link></emphasis></simpara>
</section>
<section xml:id="_functions">
<title>Functions</title>
<screen>    Function identifier  [( arg1 [ as Type ], arg2... argx) ] [As return_type]
        statements
        ...
        identifier = return_value
        ...
    End Function</screen>
<simpara><emphasis role="strong">About Functions</emphasis></simpara>
<simpara>Functions are a special type of subroutine that can return a value.&#160;&#160;
This means that when the name of the function is used in the place of a
variable, GCBASIC will call the function, get a value from it, and then
put the value into the line of code in the place of the variable.</simpara>
<simpara>Functions are strict.&#160;&#160;The function MUST be assigned to an appropiate variable or passed to another subroutine.&#160;&#160;Calling a function with no assignment or returned value usage will raise an error condition.</simpara>
<simpara>Functions may have parameters - these are treated in exactly the
same way as parameters for subroutines.&#160;&#160;
The only exception is that brackets are required around any parameters when calling a function. &#160;&#160;The argument&#8217;s type is given by "As type" following the parameter. If a parameter in the declaration is given a default value, the parameter is optional. Array parameters are specified by following an identifier with an empty parenthesis.</simpara>
<simpara>Returning values : <literal>return_type</literal> specifies the data type returned by a function upon exit.&#160;&#160;If no data type is specified, then the function will return the default data type which is a byte.&#160;&#160;
Functions return values by assigning the Function keyword or the function&#8217;s <literal>identifier</literal> to the desired return value, this method do not cause the function to exit, however.&#160;&#160;</simpara>
<simpara>Exit Function keyword in a same function is unsupported when returning objects with constructors.&#160;&#160;Since functions return values, function calls evaluate to expressions. Thus, function calls can be made wherever an expression is expected, like in Assignments or If statements.&#160;&#160;Parentheses surrounding the argument list are required on function calls in expressions and even highly recommended if there are no arguments.</simpara>
<simpara><emphasis role="strong">Using Functions</emphasis></simpara>
<simpara>This program uses a function called <literal>AverageAD</literal> to take two analog
readings, and then make a decision based on the average:</simpara>
<screen>    'Select chip
    #chip 16F88, 20

    'Define ports
    #define LED PORTB.0
    #define Sensor AN0

    'Set port directions
    dir LED out
    dir PORTA.0 in

    'Main code
    Do
        Set PORTB.0 Off
        If AverageAD &gt; 128 Then Set PORTB.0 On
        wait 10 ms
    Loop

    Function AverageAD
        'Get 2 readings, divide by 2, store in AverageAD
        'Note the cast, the result of ReadAD needs to be converted to
        'a word before adding, or the result may overflow.
        AverageAD = ([word]ReadAD(Sensor) + ReadAD(Sensor)) / 2
    end function</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_subroutines">Subroutines</link>, <link linkend="_exit">Exit</link></simpara>
</section>
<section xml:id="_labels">
<title>Labels</title>
<simpara><emphasis role="strong">About Labels</emphasis></simpara>
<simpara>Labels are used as markers throughout the program. Labels are used to
mark a position in the program to ‘jump to’ from another position using
a goto, gosub or other command.</simpara>
<simpara>Labels can be any word (that is not already a reserved keyword) and may
contain digits and the underscore character. Labels must start with a
letter or underscore (not digit), and are followed directly by a colon
(:) at the marker position. The colon is not required within the actual
commands.</simpara>
<simpara>The compiler is not case sensitive. Lower and/or upper case may be used
at any time.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will flash the light until the button is pressed
    'off. Notice the label named SWITCH_OFF.

    #chip 16F628A, 4

    #define BUTTON PORTB.0
    #define LIGHT PORTB.1
    Dir BUTTON In
    Dir LIGHT Out

    Do
    PulseOut LIGHT, 500 ms
    If BUTTON = 1 Then Goto SWITCH_OFF
    Wait 500 ms
    If BUTTON = 1 Then Goto SWITCH_OFF
    Loop

    SWITCH_OFF:
    Set LIGHT Off
    'Chip will enter low power mode when program ends</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_goto">Goto</link>, <link linkend="_gosub">Gosub</link></simpara>
</section>
<section xml:id="_lookup_tables">
<title>Lookup Tables</title>
<simpara><emphasis role="strong">About Lookup Tables</emphasis></simpara>
<simpara>A lookup table is a list of values that are stored in the memory of the microcontroller, which then can be accessed using the <literal>ReadTable</literal> command.</simpara>
<simpara>The advantage of lookup tables is that they are memory efficient,
compared to an equivalent set of alternative command statements.</simpara>
<simpara>Data tables are defined as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>a single value on each line</simpara>
</listitem>
<listitem>
<simpara>byte, word, longs and integer values are valid.&#160;&#160;</simpara>
</listitem>
<listitem>
<simpara>Strings must be expressed as ASCII byte value(s)</simpara>
</listitem>
<listitem>
<simpara>multiple elements on a single line separated by commas</simpara>
</listitem>
<listitem>
<simpara>constants and calculations within the single line data table entries are permitted</simpara>
</listitem>
<listitem>
<simpara>an external data source file</simpara>
</listitem>
<listitem>
<simpara>decimal values are NOT supported
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">Defining Tables</emphasis></simpara>
<simpara><emphasis>Single data values</emphasis></simpara>
<simpara>A single value on each line with in the table.&#160;&#160;The example table, shown below, has the data on different line in within the table.</simpara>
<screen>    Table TestDataSource
        12
        24
        36
        48
        60
        72
    End Table

    Dim TableCounter, Invalue as byte

    CLS
    For TableCounter = 1 to 6
      ReadTable  TestDataSource, TableCounter, Invalue
      Print InValue
      Print ","
    Next</screen>
<simpara><emphasis>Multiple data values of the same line</emphasis></simpara>
<simpara>Multiple elements on a single line separated by commas.&#160;&#160;The example table, shown below, has the data separated by <literal>,</literal> and on different line in within the table.</simpara>
<screen>    Table TestDataSource
        12,  24, 36
        48,  60, 72
    End Table

    Dim TableCounter, Invalue as byte

    CLS
    For TableCounter = 1 to 6
      ReadTable  TestDataSource, TableCounter, Invalue
      Print InValue
      Print ","
    Next</screen>
<simpara><emphasis>Data values as constants, and, with data transformation</emphasis></simpara>
<simpara>Constants and calculations within the single line.  &#160;&#160;The example table, shown below, uses a defined constant to multiple the data with the table.</simpara>
<screen>#define calculation_constant 2

    Table TestDataSource
      1 * calculation_constant
      2 * calculation_constant
      3 * calculation_constant
      8 * calculation_constant
      4 * calculation_constant
      5 * calculation_constant
    End Table

    Dim TableCounter, Invalue as byte

    CLS
    For TableCounter = 1 to 6
      ReadTable  TestDataSource, TableCounter, Invalue
      Print InValue
      Print ","
    Next</screen>
<simpara>&#160;&#160;
&#160;&#160;</simpara>
<simpara><emphasis>Data values as Strings</emphasis></simpara>
<simpara>Strings can be defined.&#160;&#160;Strings are delimited by double quotes. &#160;&#160; The following examples show the methods.</simpara>
<simpara>Any ASCII characters between any two "    " (double quotes) will be converted to table data.&#160;&#160; Also see ASCII escape codes.</simpara>
<simpara>A source string can be one string per line or comma separated strings, therefore, on the same line.</simpara>
<simpara>Simple Example 1.</simpara>
<screen>    Table Test_1
     "ABCDEFGHIJ"
    End Table</screen>
<simpara>Simple Example 2.</simpara>
<screen>    '
    Table  MnuTxt_1  'Home disp
       "  Display_1    Display_2    Display_3  "
    End Table

    Table MnuTxt_2   'Main Menu
     "1: Display"       ' Main1
     "2: System Setup"  ' Main2
     "3: Config 1"      ' Main3
     "4: Config 2"      ' Main4
     "5: Data Log"      ' Main5
     "6: Diagnostic"    ' Main6
     "7: Help+"         ' Main7
    End Table</screen>
<simpara>The following 2 table lines produce the same table data.</simpara>
<screen>    "String1","String2", "String3"
    "String1String2String3"</screen>
<simpara>And, the following 3 table lines produce the same table data.</simpara>
<screen>    "String1"
    "String2"
    "String3"</screen>
<simpara><emphasis>ASCII Escape code</emphasis></simpara>
<simpara>Accepted escape strings are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Escape sequence</entry>
<entry align="left" valign="top">Meaning</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>\a</simpara></entry>
<entry align="left" valign="top"><simpara>beep</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\b</simpara></entry>
<entry align="left" valign="top"><simpara>backspace</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\f</simpara></entry>
<entry align="left" valign="top"><simpara>formfeed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\l or \n</simpara></entry>
<entry align="left" valign="top"><simpara>newline</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\r</simpara></entry>
<entry align="left" valign="top"><simpara>carriage return</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\t</simpara></entry>
<entry align="left" valign="top"><simpara>tab</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\0</simpara></entry>
<entry align="left" valign="top"><simpara>Nul value, equates to ASCII 0. Same as \&amp;000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\&amp;nnn</simpara></entry>
<entry align="left" valign="top"><simpara>ascii char in decimal</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\\</simpara></entry>
<entry align="left" valign="top"><simpara>backslash</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\"</simpara></entry>
<entry align="left" valign="top"><simpara>double quote</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\'</simpara></entry>
<entry align="left" valign="top"><simpara>single quote</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Using Lookup Tables</emphasis></simpara>
<simpara>First, the table must be created. The code to create a lookup table is
simple - a line that has <literal>Table</literal> and then the name of the table, a list
of numbers (up to 10,000 elements), and then <literal>End Table</literal>.</simpara>
<simpara>For tables with more than 255 elements it is mandated to used a WORD variable to read the size of the table. See below for an example.</simpara>
<simpara>Once the table is created, the <literal>ReadTable</literal> command is used to read data
from it. The <literal>ReadTable</literal> command requires the name of the table it is to
read, the location of the item to retrieve, and a variable to store the
retrieved number in.</simpara>
<simpara>Lookup tables can store byte, word, longs and integer values.&#160;&#160;
GCBASIC will try automatically detect the type of the table depending on the values in it.&#160;&#160;
GCBASIC can be explicitly instructed to cast the table to a variable type, as follows:</simpara>
<screen>    Table TestDataSource as [Byte | Word | Integer | Long ]
        12
        24
        36
        48
        60
        72
    End Table</screen>
<simpara><emphasis>Addresssing the Table Data</emphasis></simpara>
<simpara>Item 0 of a lookup table stores the size of the table.
If the <literal>ReadTable</literal> command attempts to read beyond the end (number of data items) of the table, the value 0 will be returned.
For tables with more than 255 elements it is <emphasis role="strong">mandatory</emphasis> to use a WORD variable to read the size of the table. See example below.</simpara>
<screen>    dim lengthoftable as word

    readtable TestDataSource , 0, lengthoftable
    print lengthoftable  ; will print the size as a word

    table TestDataSource
    'a table with more than 255 elements
    ... 'item 1
    ...
    ...
    ...  'item 1027
    end table</screen>
<simpara><emphasis>Importing External Text File for table conversion</emphasis></simpara>
<simpara>An external file can be used as the table data source.&#160;&#160;
The file will be read into the specified table name from the external file.&#160;&#160;
The source file will be treated as a byte value file.</simpara>
<simpara>An example file is shown below:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/lookuptablesb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The following program will import the external data file.</simpara>
<screen>    #chip 16f877a

    Table TestDataSource from "sourcefile.raw"

    for nn = 1 to 10
      ReadTable TestDataSource, nn, inc
      Print inc
    next</screen>
<simpara>And the program will out the following:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/lookuptablesb2.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis>Advanced use of Lookup Tables - using EEPROM for Table data storage</emphasis></simpara>
<simpara>You can use the <literal>Table</literal> statement to store the data table in EEPROM. If
the compiler is told to store a data table in "Data" memory, it will
store it in the EEPROM.</simpara>
<simpara><emphasis role="strong">NOTE</emphasis>
The limitation of of using EPPROM tables is that you can only
store BYTEs. You cannot store WORD values in the EEPROM tables.</simpara>
<simpara>Example code:</simpara>
<screen>    #chip 16F628

    'Read table item
    'Must use ReadTable and a variable for the index, or the table will not be downloaded to EEPROM

    TableLoc = 2
    ReadTable TestDataSource, TableLoc, SomeVar

    'Write to table , this is not required
    EPWrite 1, 45

    'Table of values to write to EEPROM
    'EEPROM location 0 will store length of table
    'Subsequent locations will each store a value

    Table TestDataSource Store Data
        12
        24
        36
        48
        60
        72
    End Table</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_readtable">ReadTable</link></simpara>
</section>
<section xml:id="_miscellaneous">
<title>Miscellaneous</title>
<simpara><emphasis role="strong">About Miscellaneous things&#8230;&#8203;.</emphasis></simpara>
<simpara>It is possible to combine multiple instructions on a single line, by
separating them with a colon. For example, this code:</simpara>
<screen>    Set PORTB.0 On
    Set PORTB.1 On
    Wait 1 sec
    Set PORTB.0 Off
    Set PORTB.0 Off</screen>
<simpara>could also be written as:</simpara>
<screen>    Set PORTB.0 On: Set PORTB.1 On
    Wait 1 sec
    Set PORTB.0 Off: Set PORTB.0 Off</screen>
<simpara>In most cases, it will make no difference if commands share a line or
not. However, special care should be taken with If commands, as this
code:</simpara>
<screen>    Set PORTB.0 Off
    Set PORTB.1 Off
    If Temp &gt; 10 Then Set PORTB.0 On: Set PORTB.1 On
    Wait 1 s</screen>
<simpara>Will be equivalent to this:</simpara>
<screen>    Set PORTB.0 Off
    Set PORTB.1 Off
    If Temp &gt; 10 Then
    Set PORTB.0 On
    Set PORTB.1 On
    End If
    Wait 1 s</screen>
<simpara>Also, the commands used to start and end subroutines, data tables and
functions must be alone on a line. For example, this is WRONG:</simpara>
<screen>    Sub Something: Set PORTB.0 Off: End Sub</screen>
</section>
<section xml:id="_readtable">
<title>ReadTable</title>
<simpara><emphasis role="strong">About ReadTable</emphasis></simpara>
<simpara>The <literal>ReadTable</literal> command is used to read information from lookup tables.
<literal><emphasis>TableName</emphasis></literal> is the name of the table that is to be read, <literal><emphasis>Item</emphasis></literal> is the
line of the table to read, and <literal><emphasis>Output</emphasis></literal> is the variable to write the
retrieved value in to.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ReadTable <emphasis>TableName, Item, Output</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal><emphasis>Item</emphasis></literal> is 1 for the first line of the table, 2 for the second, and so on.
If the Table is more than 256 elements then <literal><emphasis>Item</emphasis></literal> must be WORD variable.
Care must be taken to ensure that the program is not instructed to read beyond the end of the table as Zero will be returned.</simpara>
<simpara>The type of <literal><emphasis>Output</emphasis></literal> should match the type of data stored in the table.
For example, if the table contains Word values then <literal><emphasis>Output</emphasis></literal> should be a
Word variable. If the type does not match, GCBASIC will attempt to
convert the value.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Chip Settings
    #chip 16F88, 20

    'Hardware Settings
    #define LED PORTB.0
    Dir LED Out

    'Main Routine
    ReadTable TimesTwelve, 4, Temp
    Set LED Off
    If Temp = 48 Then Set LED On

    'Lookup table named "TimesTwelve"
    Table TimesTwelve
    12
    24
    36
    48
    60
    72
    84
    96
    108
    120
    132
    144
    End Table</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lookup_tables">Lookup Tables</link></simpara>
</section>
<section xml:id="_scripts">
<title>Scripts</title>
<simpara><emphasis role="strong">About Scripts</emphasis></simpara>
<simpara>A script is a small section of code that GCBASIC runs when it
starts to compile a program.  Uses include performing calculations
that are required to adjust the program for different chip frequencies.</simpara>
<simpara>Scripts are not compiled or downloaded to the microcontroller - GCBASIC
reads them, executes them, then removes them from the program and then the
results calculated can be used as <emphasis>constants</emphasis> in the user program.</simpara>
<simpara>Inside a script, <emphasis>constants</emphasis> are treated like variables.  Scripts can read
the values of <emphasis>constants</emphasis>, and set them to contain new values.</simpara>
<simpara><emphasis role="strong">Using Scripts</emphasis></simpara>
<simpara>Scripts start with <literal>#script</literal> and end with <literal>#endscript</literal>. Inside, they can
consist of the following commands:</simpara>
<screen>    If
    Assignment (=)
    Error
    Warning
    Int()</screen>
<simpara><literal>If</literal> is similar to the If command in normal GCBASIC code, except that it does not have an <literal>Else</literal> clause.
It is used to compare the values of the script constants.</simpara>
<simpara>The <literal>=</literal> sign is identical to that in GCBASIC programs.
The <emphasis>constant</emphasis> that is to be set goes on the left side of the <literal>=</literal> and the new value goes to the right of the <literal>=</literal>.</simpara>
<simpara><literal>Error</literal> is used to display an error message.
Anything after the <literal>Error</literal> command is displayed at the end of compilation, and is saved in the error log for the program.</simpara>
<simpara><literal>Warning</literal> is used to display a warning message. Anything after the <literal>Warning</literal> command is displayed at the end of compilation but warning does not halt compilation.</simpara>
<simpara><literal>Int()</literal> will calculate the integer value of a calculation. Using <literal>Int()</literal> is critical to set the <emphasis>constant</emphasis> to the integer component of the calculation.</simpara>
<simpara><emphasis role="strong">Notes:</emphasis></simpara>
<simpara>Use <literal>Warning</literal> to display constant values when creating and debugging scripts.</simpara>
<simpara>Scripts have a limited syntax and limited error checking when compiling.  The compiler may halt if you get something wrong.</simpara>
<simpara>Scripts that are incorrectly formatted may also halt the compiler or return unrelated error.</simpara>
<simpara>Scripts used for calculations should use the <literal>Int( expression )</literal> where you may have a floating point numbers returned.<?asciidoc-br?>
Scripts do use floating point for all calculations and a failure to use <literal>Int()</literal> may set the script constant and the resulting <emphasis>constant</emphasis> to 0.</simpara>
<simpara>Scripts may require that complex math expressions may require definition in multiple steps/line to simplify the calculation.<?asciidoc-br?>
The returned value could be incorrect if simplification is not implemented.</simpara>
<simpara>Scripts can only access existing <literal>constants</literal> both user and system defined.</simpara>
<simpara>User defines variables are not accessible within the scope of a script.</simpara>
<simpara>Scripts has precendence over #define.  A #define constant statements are read first, then scripts run.
So, a script will always overwrite a constant that was set with #define.</simpara>
<simpara>Use <literal>Warning</literal> to display constants values when creating and debugging scripts.</simpara>
<simpara><emphasis role="strong">Example Script</emphasis></simpara>
<simpara>This script is used in the pwm.h file.
It takes the values of the user defined <emphasis>constants</emphasis> PWM_Freq, PWM_Duty and system <emphasis>constant</emphasis> ChipMHz and calculates the results using the equations.
These calculation are based on information from a Microchip PIC datasheet to calculate the correct values to setup Pulse Width Modulation (PWM).</simpara>
<screen>    #script
        PR2Temp = INT((1/PWM_Freq)/(4*(1/(ChipMHz*1000))))
        T2PR = 1
        If PR2Temp &gt; 255 Then
            PR2Temp = INT((1 / PWM_Freq) / (16 * (1 / (ChipMHz * 1000))))
            T2PR = 4
            If PR2Temp &gt; 255 Then
                PR2Temp = INT(( 1 / PWM_Freq) / (64 * (1 / (ChipMHz * 1000))))
                T2PR = 16
                If PR2Temp &gt; 255 Then
                    Error Invalid PWM Frequency value
                End If
            End If
        End If

        DutyCycle = (PWM_Duty * 10.24) * PR2Temp / 1024
        DutyCycleH = (DutyCycle AND 1020) / 4
        DutyCycleL = DutyCycle AND 3
    #endscript</screen>
<simpara>During the execution of the script the calculations and assignment uses the constants in the script.</simpara>
<simpara>After this script has completed the <emphasis>constants</emphasis> <literal>PR2Temp</literal>, <literal>DutyCycleH</literal> and <literal>DutyCycleL</literal> are set using the constants and/or the calculations.</simpara>
<simpara>The <emphasis>constants</emphasis> assigned in this script, <literal>PR2Temp</literal>, <literal>DutyCycleH</literal> and <literal>DutyCycleL</literal>, are made available as <emphasis>constants</emphasis> in the user program.</simpara>
</section>
<section xml:id="_subroutines">
<title>Subroutines</title>
<simpara><emphasis role="strong">About Subroutines</emphasis></simpara>
<simpara>A subroutine is a small program inside of the main program. Subroutines
are typically used when a task needs to be repeated several times in
different parts of the main program.</simpara>
<simpara>There are two main uses for subroutines:</simpara>
<itemizedlist>
<listitem>
<simpara>Keeping programs neat and easy to read</simpara>
</listitem>
<listitem>
<simpara>Reducing the size of programs by allowing common sections of code to
be reused.</simpara>
</listitem>
</itemizedlist>
<simpara>When the microcontroller comes to a subroutine it saves its location in the current
program before jumping to the start of, or calling, the subroutine. Once
it reaches the end of the subroutine it returns to the main program, and
continues to run the code where it left off previously.</simpara>
<simpara>Normally, it is possible for subroutines to call other subroutines.
There are limits to the number of times that a subroutine can call
another sub, which vary from chip to chip:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Microcontroller Family</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Instruction Width</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Number of subs called</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>10F*, 12C5*, 12F5*, 16C5*, 16F5*</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>12C*, 12F*, 16C*, 16F*, except those above</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>18F*, 18C*</simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
<entry align="center" valign="top"><simpara>31</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These limits are due to the amount of memory on the microcontroller which saves its
location before it jumps to a new subroutine. Some GCBASIC commands are
subroutines, so you should always allow for 2 or 3 subroutine calls more
than your program has.</simpara>
<simpara>On 16F chips, the program memory is divided into pages. Each page holds 2048 instructions.&#160;&#160;&#160;
If the program jumps from code on one page to code on another, the compiler has to select the new page.&#160;&#160;&#160;Having to do this makes the program bigger, so try to avoid this.
To keep jumps between pages down, GCBASIC imposes a rule that each subroutine must be entirely within one page, so that only jumps to other subroutines require the page selection.&#160;&#160;&#160;
As an example, say you have two pages of memory, each 2048 instructions (words) long.<?asciidoc-br?>
If you have a main sub that is 1500 words, and four other subroutines each 600 words long, your total program size would be 3900 words and you might expect it to fit into the 4096 words available. &#160;&#160;&#160;
The problem though is that once the main routine takes 1500 words from page 1, nothing else will fit after it. Three of the 600 word subroutines would fit onto page 2, but that leaves one 600 word subroutine that will not fit into the 500 left on page 1 or the 200 left on page 2.&#160;&#160;&#160;
If you want to reduce the chance of this happening, the best option is to keep your subroutines smaller - move anything out of the main routine and into another one - this will resolve memory page constraints.&#160;&#160;&#160;</simpara>
<simpara>Atmel AVR microcontrollers have no fixed limit on how many subroutines can be
called at a time, but if too many are called then some variables on the
chip may be corrupted. To check if there are too many subroutines, work
out the most that will be called at once, then multiply that number by 2
and create an array of that size. If an out of memory error message
comes up, there are too many calls.</simpara>
<simpara>Another feature of subroutines is that they are able to accept
parameters. These are values that are passed from the main program to
the subroutine when it is called, and then passed back when the
subroutine ends.</simpara>
<simpara><emphasis role="strong">Using Subroutines</emphasis></simpara>
<simpara>To call a subroutine is very simple - all that is needed is the name of
the sub, and then a list of parameters. This code will call a subroutine
named "Buzz" that has no parameters:</simpara>
<screen>    Buzz</screen>
<simpara>If the sub has parameters, then they should be listed after the name of
the subroutine. This would be the command to call a subroutine named
"MoveArm" that has three parameters:</simpara>
<screen>    MoveArm NewX, NewY, 10</screen>
<simpara>Or, you may choose to put brackets around the parameters, like so:</simpara>
<screen>    MoveArm (NewX, NewY, 10)</screen>
<simpara>All that this does is change the appearance of the code - it doesn&#8217;t
make any difference to what the code does. Decide which one meets your
own personal preference, and then stick with it.</simpara>
<simpara><emphasis role="strong">Creating subroutines</emphasis></simpara>
<simpara>To create a subroutine is almost as simple as using one. There must be a
line at the start which has <literal>sub</literal>, and then the name of the subroutine.
Also, there needs to be a line at the end of the subroutine which reads
<literal>end sub</literal>. To create a subroutine called <literal>Buzz</literal>, this is the required
code:</simpara>
<screen>    sub Buzz

    'code for the subroutine goes here

    end sub</screen>
<simpara>If the subroutine has parameters, then they need to be listed after the
name. For example, to define the <literal>MoveArm</literal> sub used above, use this
code:</simpara>
<screen>    sub MoveArm(ArmX, ArmY, ArmZ)

    'code for the subroutine goes here

    end sub</screen>
<simpara>In the above sub, <literal>ArmX</literal>, <literal>ArmY</literal> and <literal>ArmZ</literal> are all variables. If the call
from above is used, the variables will have these values at the start of
the subroutine:</simpara>
<screen>    ArmX = NewX
    ArmY = NewY
    ArmZ = 10</screen>
<simpara>When the subroutine has finished running, GCBASIC will copy the values
back where possible. <literal>NewX</literal> will be assigned to <literal>ArmX</literal>, and <literal>NewY</literal> will be
assigned to <literal>ArmY</literal>. GCBASIC will not attempt to set the number 10 to <literal>ArmZ</literal>.</simpara>
<simpara><emphasis role="strong">Controlling the direction data moves in</emphasis></simpara>
<simpara>It is possible to instruct GCBASIC not to copy the value back after the
subroutine is called. If a subroutine is defined like this:</simpara>
<screen>    sub MoveArm(In ArmX, In ArmY, In ArmZ)
    'code for the subroutine goes here

    end sub</screen>
<simpara>Then GCBASIC will copy the values to the subroutine, but will not copy
them back.</simpara>
<simpara>GCBASIC can also be prevented from copying the values back, by adding
<literal>Out</literal> before the parameter name. This is used in the EEPROM reading
routines - there is no point copying a data value into the read
subroutine, so <literal>Out</literal> has been used to avoid wasting time and memory. The
EPRead routine is defined as <literal>Sub EPRead(In Address, Out Data)</literal>.</simpara>
<simpara>Many older sections of code use <literal>#NR</literal> at the end of the line where the
parameters are specified. The <literal>#NR</literal> means "No Return", and when used has
the same effect as adding <literal>In</literal> before every parameter. Use of <literal>#NR</literal> is
not recommended, as it does not give the same level of control.</simpara>
<simpara><emphasis role="strong">Using different data types for parameters</emphasis></simpara>
<simpara>It is possible to use any type of variable a as parameter for a
subroutine. Just add <literal>As</literal> and then the data type to the end of the
parameter name. For example, to make all of the parameters for the
<literal>MoveArm</literal> subroutine word variables, use this code:</simpara>
<screen>    sub MoveArm(ArmX As Word, ArmY As Word, ArmZ As Word)
    ...
    end sub</screen>
<simpara><emphasis role="strong">Optional parameters</emphasis></simpara>
<simpara>Sometimes, the same value may be used over and over again for a
parameter, except in a particular case. If this occurs, a default value
may be specified for the parameter, and then a value for that parameter
only needs to be given in a call if it is different to the default.</simpara>
<simpara>For example, suppose a subroutine to create an error beep is required.
Normally it emits ! 440 Hz tone, but sometimes a different tone is
required. To create the sub, this code would be use:</simpara>
<screen>    Sub ErrorBeep(Optional OutTone As Word = 440)
      Tone OutTone, 100
    End Sub</screen>
<simpara>Note the <literal>Optional</literal> before the parameter, and the <literal>= 440</literal> after it.
This tells GCBASIC that if no parameter is supplied, then set the
<literal>OutTone</literal> parameter to 440.</simpara>
<simpara>If called using this line:</simpara>
<screen>    ErrorBeep</screen>
<simpara>then a 440 Hz beep will be emitted. If called using this line:</simpara>
<screen>    ErrorBeep 1000</screen>
<simpara>then the sub will produce a 1000 Hz tone.</simpara>
<simpara>When using several parameters, it is possible to make any number of them
optional. If the optional parameter/s are at the end of the call, then
no value needs to be specified. If they are at the start or in the
middle, then you must insert commas to allow GCBASIC to tell where the
optional parameters are.</simpara>
<simpara><emphasis role="strong">Overloading</emphasis></simpara>
<simpara>It is possible to have 2 subroutines with the same name, but different
parameters. This is known as overloading, and GCBASIC will automatically
select the most appropriate subroutine for each call.</simpara>
<simpara>An example of this is the Print routine in the LCD routines. There are
actually several Print subroutines; for example, one has a byte
parameter, one a word parameter, and one a string parameter. If this
command is used:</simpara>
<screen>    Print 100</screen>
<simpara>Then the Print (byte) subroutine will be called. However, if this
command is used:</simpara>
<screen>    Print 30112</screen>
<simpara>Then the Print (word) subroutine will be called. If there is no exact
match for a particular call, GCBASIC will use the option that requires
the least conversion of variable types. For example, if this command is
used:</simpara>
<screen>    Print PORTB.0</screen>
<simpara>The byte print will be used. This is because byte is the closest type to
the single bit parameter.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_functions">Functions</link>, <link linkend="_exit">Exit</link></simpara>
</section>
<section xml:id="_converters">
<title>Converters</title>
<simpara><emphasis role="strong">About Converters</emphasis></simpara>
<simpara>Converters allow GCBASIC to read files that have been created by other programs.
A converter can convert these files into GCBASIC libraries or any GCBASIC instruction or a GCBASIC dataset.</simpara>
<simpara>A typical use case is when you have a data source file from another computer system and you want to consume the data within your GCBASIC program.
The data source file could be database, graphic, reference data or music file.
The converter will read these source files and convert them into a format that can be processed by GCBASIC.
The conversion process is completed by external application which can be written by the developer or you can use
one of the converters provided with the GCBASIC release.</simpara>
<simpara>The GCBASIC release includes the converter for BMP files and standard Text files.</simpara>
<simpara>With an appropriate Converter installed, and an associated <literal>#include</literal> to these non-GCBASIC files,
GCBASIC will detect that the file extension and hand the processing to the external converting program.
When the external converting program had complete, GCBASIC will then continue with the converted source file as a GCBASIC source file.</simpara>
<simpara>An example of a converter is to read an existing picture file, convert the picture file to a GCB table and then refer to the picture
file table to display the picture file on a GLCD.</simpara>
<simpara>Conversion is achieved by including a command within the source program to transform external data.
The command used is the instruction <literal>#include</literal> followed by the data source.  An example:</simpara>
<screen>    'Convert ManLooking.BMP to a GCBASIC usable format.

    #include &lt;..\converters\ManLooking.BMP&gt;</screen>
<simpara>The inclusion of the #include line within a GCBASIC  program will enable the commencement of the following process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>GCBASIC  will examine the <literal>..\converters</literal> folder structure for a configuration file that will handle the file extension specified in the include statement.</simpara>
</listitem>
<listitem>
<simpara>GCBASIC  will examine the configuration file(s) <literal>*.INI</literal> for command line instructions.</simpara>
</listitem>
<listitem>
<simpara>GCBASIC  will at stage examine the folder structure for the source file and the target transformed file.
If the source file is older than the transformed file the next step will not be executed, goto step 6.</simpara>
</listitem>
<listitem>
<simpara>GCBASIC  will execute the command as specified within the configuration file to transform the source file to the target file.</simpara>
<simpara>The Conversion program must create the output file extension as specified in the configuration file.  If the include statement as an extension
of <literal>.TXT</literal> and the configuration files states the input file extension as <literal>.TXT</literal> and the output as <literal>.GCB</literal> the converted file must have the extension of <literal>.GCB</literal>.</simpara>
<literallayout class="monospaced">#include &lt;..\converters\ManLooking.BMP&gt;</literallayout>
<simpara>Init file is input file as BMP and output as GCB, then the file expected is <literal>..\converters\ManLooking.GCB</literal></simpara>
</listitem>
<listitem>
<simpara>GCBASIC  will attempt to include the transformed target file (with the file extension as specified in the configuration file) within the GCBASIC  program.</simpara>
</listitem>
<listitem>
<simpara>GCBASIC  will resume normal processing of the GCBASIC program including the transformed target file, therefore, with normal compiling and errors handling.</simpara>
</listitem>
</orderedlist>
<simpara>For example programs see <link linkend="XX0">here</link>.</simpara>
<simpara><emphasis role="strong">More about Converters</emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The configuration file</simpara>
<simpara>The configuration file MUST have the extension of <literal>.INI</literal>.  No leading spaces are permitted in the configuration file.
Specification of the configuration file.
The file has four items: <literal>desc</literal>, <literal>in</literal>, <literal>out</literal> and <literal>exe</literal>. Where:</simpara>
<literallayout class="monospaced">desc         : Is the description shown in GCGB
in           : Is the source file extension to be transformed
out          : Is the target transformed file extension.
exe          : Is the executable to be run for this specific configuration file.
params       : Optional, is the required parameter to be passed from the compiler.  Example:  params = %filename% %chipmodel%
deletetarget : Optional, will always recreate the target transformed file. The default is to retain the target transformed file unless source has changed. Options are Y or N</literallayout>
<simpara>You can have multiple configuration files within the <literal>..\converters folder structure</literal>.</simpara>
<simpara>GCBASIC will examine all configuration file to match the extension as specified in the <literal>#include</literal> command.</simpara>
<simpara><emphasis role="strong">Example 1 :</emphasis></simpara>
<informalexample>
<simpara>BMP (Black and White) conversion configuration file is called <literal>BMP2GCBasic.ini</literal>.  The source extension is <literal>.bmp</literal>,
the transformed file extension is <literal>.GCB</literal>, and the executable is called <literal>BMP2GCBASIC.exe</literal>.</simpara>
<literallayout class="monospaced">desc = BMP file (*.bmp)
in = bmp
out = GCB
exe = BMP2GCBASIC .exe</literallayout>
<simpara>An example :</simpara>
<literallayout class="monospaced">#include &lt;..\converters\ManLooking.BMP&gt;</literallayout>
<simpara>Will be converted by the <literal>BMP2GCBASIC .EXE</literal> to <literal>..\converters\ManLooking.GCB</literal></simpara>
</informalexample>
<simpara><emphasis role="strong">Example 2 :</emphasis></simpara>
<informalexample>
<simpara>Data file conversion configuration file is called <literal>TXT2GCB.ini</literal>.  The source extension is <literal>.TXT</literal>, the transformed
file extension is <literal>.GCB</literal>, and the command line called <literal>AWKRUN.BAT</literal> .</simpara>
<literallayout class="monospaced">desc = Infrared Patterns (*.txt)
in = txt
out = GCB
exe = awkrun.bat</literallayout>
<simpara>An example :</simpara>
<literallayout class="monospaced">#include &lt;..\converters\InfraRedPatterns.TXT&gt;</literallayout>
<simpara>Will be converted by the <literal>AWKRUN.BAT</literal> to <literal>..\converters\ InfraRedPatterns.GCB</literal></simpara>
<simpara>The example would require a supporting batch file and a script process to complete the transformation.</simpara>
</informalexample>
</listitem>
<listitem>
<simpara>Conversion Executable</simpara>
<simpara>The conversion executable may be written in any language (compiled or interpreted).</simpara>
<simpara>The conversion executable MUST create the converted file with the correct file extension as specified in the configuration file.</simpara>
<simpara>The conversion executable will be passed one parameter - the source file name.
Using example #1 the conversion executable would be passed   <literal>..\converters\ManLooking.BMP</literal></simpara>
<simpara>The conversion executable MUST create a GCBASIC compatible source file.  Any valid commands/instruction are permitted.</simpara>
</listitem>
<listitem>
<simpara>Installation</simpara>
<simpara>The <literal>INI</literal> file, the source file and the conversion executable MUST be located in the <literal>..\converters folder</literal>.
The converters folder is relative to the <literal>GCBASIC.EXE</literal> compiler folder.</simpara>
</listitem>
</orderedlist>
<simpara xml:id="XX0"><emphasis role="strong">Example 3 : Converter Program</emphasis></simpara>
<informalexample>
<simpara>This program converts the <literal>InfraRedPatterns.TXT</literal> into <literal>InfraRedPatterns.GCB</literal> that will have a GCBASIC table called <literal>DataSource</literal>.
This example is located in the converter folder of the GCBASIC installation.</simpara>
<screen>  #chip16f877a, 16
  #include &lt;..\converters\InfraRedPatterns.TXT&gt;

  dir portb out

  ' These must be WORDs as this could be large table.
  dim TableReadPosition, TableLen as word

  dir portb out

  ' Read the table length
  TableReadPosition = 0
  ReadTable DataSource, TableReadPosition, TableLen


  Do Forever
      For TableReadPosition = 1 to TableLen step 2
          ReadTable DataSource, TableReadPosition, TransmissionPattern
          ReadTable DataSource, TableReadPosition+1 , PulseDelay
          portb = TransmissionPattern
          wait PulseDelay ms
      next
  Loop</screen>
</informalexample>
<simpara><emphasis role="strong">Example 4 : Dynamic Import</emphasis></simpara>
<informalexample>
<simpara>This program converts a chip specific configuration file into <literal>manifest.GCB</literal> that will have a GCBASIC functions called <literal>DataIn</literal> and <literal>DataOut</literal>.
This example is located in the converter folder of the GCBASIC installation.</simpara>
<screen>    #chip 16f18326

    #include &lt;..\converters\manifest.mcc&gt;

    DataOut ( TX, RA0 )  'this method is created during the convert process. They do not exist withiut the converter.
    DataIn  ( Rx, RC6 )  'this method is created during the convert process. They do not exist withiut the converter.</screen>
<simpara>This example would use the optional parameters of <literal>params</literal> and <literal>deletetarget</literal> in the converter configuration file as follows:</simpara>
<screen>    desc = PPS file (*.PPS)
    params = %filename% %chipmodel%
    in = mcc
    out = GCB
    exe = DataHandler.exe
    deletetarget= y</screen>
</informalexample>
<simpara><emphasis role="strong">Example 5 : Add build numbers and time/date details to your programs</emphasis></simpara>
<simpara>This converter is used to expose two string variables as follows:</simpara>
<screen>    GCBBuildStr
    GCBBuildTimeStr</screen>
<simpara>The user code is simple. Using the #include statement specify any filename with an extension must be <literal>cnt</literal>. As follows:</simpara>
<screen>    #include "GCBVersionNumber.cnt"</screen>
<simpara>Complete code would like this - this not optimised - this shows the use of the exposed strings.</simpara>
<screen>    #include "GCBVersionNumber.cnt"

    dim versionString as string * 40
    versionString = "Max7219 build"+GCBBuildStr
    versionString = versionString + "@"+GCBBuildTimeStr
    Print versionString</screen>
<simpara>This outputs the following - where #20 is the current build and the date/time is correct for build time.</simpara>
<screen>    Max7219 build20@01-06-2021 08:00:21
    Commence main program</screen>
<simpara>This works as the support INI file instructs the compiler to call a utility that automatically creates a build number tracker file and the supportting string functions.
The utility creates a tracker file and the methods files in the same folder as your source program - so, each tracker is specific to each project.
The converter requires the following files - these are included within your Installation.</simpara>
<screen>    GCBVersionStamp.exe - the utility called by the converter capability.
    cnt2gcb.ini - the supporting ini file used by the compiler to handle this converter.</screen>
</section>
</section>
<section xml:id="_command_references">
<title>Command References</title>
<section xml:id="_analog_digital_conversion">
<title>Analog/Digital conversion</title>
<simpara>This is the Analog/Digital conversion section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_analog_digital_conversion_overview">
<title>Analog/Digital Conversion Overview</title>
<simpara><emphasis role="strong">About Analog to Digital Conversion</emphasis></simpara>
<simpara>The analog to digital converter (ADC or A/D) module support is implemented by GCBASIC to provide 8-bit, 10-bit and 12-bit Single channel measurement mode and Differential Channel Measurement mode.</simpara>
<simpara>GCBASIC configures the analog to digital converter clock source, the programmed acquisition time and justification of the response byte, word or integer (as defined in the GCBASIC method).</simpara>
<simpara><emphasis role="strong">Normal or Single channel measurement mode</emphasis></simpara>
<simpara>The Single channel measurement mode is the default method for reading the ADC port.  The positive input is attached to suitable device (a light sensor or adjustable resistor) and the command ReadADC, ReadADC10, ReadADC12 with return a byte, word or word value respectively.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/adcoverviewb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The A/D module on most microcontrollers only supports single-ended mode. Single channel mode uses a single A/D port and the returned Value represents the difference between the voltage on the analog pin and a fixed negative reference which is usually ground or Vss.</simpara>
<simpara>The syntax for single-ended A/D is Returned_Value = ReadAD(Port)</simpara>
<simpara>Example</simpara>
<screen>  Print ReadAD10(AN3)</screen>
<simpara><emphasis role="strong">Differential channel measurement mode</emphasis></simpara>
<simpara>Some of the in the Microchip PIC family of devices also support differential analog to digital conversion. With differential conversion, the differential voltage between two channels is measured and converted to a digital value.  The returned value can be either positive or negative (therefore an integer value).</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/adcoverviewb2.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>When configured to differential channel measurement mode, the positive channel is connected to the defined positive analog pin (ANx), and the negative channel is connected to the defined negative analog pin. These two pins are internally connected (within the microcontroller) to a unity gain differential amplifier and once the amplifier has completed the comparison the result is returned as an integer.</simpara>
<simpara>The positive channel Input is selected using the CHSx bits and the negative channel input is selected using the CHSNx bits.  These bits are managed by GCBASIC.  The programmer only needs to supply the correct analog pin designators in the ReadADx commands.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/adcoverviewb3.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The 12-bit returned result is available on the ADRESH and ADRESL registers which is returned by the GCBASIC methods as an integer variable.</simpara>
<simpara>Some Microchip PIC microcontrollers have differential A/D modules and support differential Mode as well as 12-Bit A/D. With DIfferential mode the returned value can be either a positive or negative number that represents the voltage differential between the two A/D ports.</simpara>
<simpara>The syntax for differential A/D is ReadAD( PositiveANPort , NegativeANPort ).  Note: if "negative port" is omitted readAd() will perform a single-ended read on the positive AN port.</simpara>
<simpara>Example</simpara>
<screen>  Print ReadAD12( AN3, An4 )</screen>
<simpara><emphasis role="strong">Using Voltage Reference</emphasis></simpara>
<simpara>Voltage references come in many forms and offer different features across the PICs, AVR and LGTs microcontrollers.&#160;&#160;
But, in the end, accuracy and stability are a voltage reference’s most important features, as the main purpose of the reference is to provide a known output voltage.&#160;&#160;
Variation from this known value is an error.&#160;&#160;
Therefore, it is useful to use the internal voltage reference provided within the microcontroller.</simpara>
<simpara>To use a voltage reference source for ADC operation sett the <literal>AD_REF_SOURCE</literal> constant to your chosen source.&#160;&#160;
The defaults to the VCC pin, and there for the constant is set by default to <literal>AD_REF_AVCC</literal>.&#160;&#160;
The voltage reference is specific to the microcontroller but the options are as follows:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">AD_REF_SOURCEConstant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Reference Voltage</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AD_REF_AVCC</simpara></entry>
<entry align="left" valign="top"><simpara>VCC supplied Voltage</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AD_REF_1024</simpara></entry>
<entry align="left" valign="top"><simpara>1.024v internal reference source</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AD_REF_2048</simpara></entry>
<entry align="left" valign="top"><simpara>2.048v internal reference source</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AD_REF_4096</simpara></entry>
<entry align="left" valign="top"><simpara>4.096v internal reference source</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AD_REF_AREF</simpara></entry>
<entry align="left" valign="top"><simpara>Extenal voltage reference source</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AD_REF_256</simpara></entry>
<entry align="left" valign="top"><simpara>AD_REF_256 for ATMegas</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Optimising GCBASIC Code</emphasis></simpara>
<simpara>GCBASIC supports a wide range of A/D modules and the supporting library addresses up to 34 channels.
To reduce the size of the code produced you can define which channels are specifically supported.  See <link linkend="_analog_digital_conversion_code_optimisation">Optimising ADC code</link> for more details.</simpara>
<simpara>See also <link linkend="_readad">ReadAD</link>, <link linkend="_readad10">ReadAD10</link> and <link linkend="_readad12">ReadAD12</link></simpara>
<simpara>For the latest Microchip PIC microcontrollers that support Differential and 12-bit A/D please refer to Microchip MAPS or the microcontrollers datasheet.</simpara>
</section>
<section xml:id="_adformat_deprecated_do_not_use">
<title>ADFormat (Deprecated - Do not use)</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>ADFormat ( Format_Left | Format_Right )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available only on Microchip PIC microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Left justified means 8 bits in the high byte, 2 in the low. Right
justified means 2 in the high byte, and the remaining 8 in the low byte.
It&#8217;s only supported on Microchip PIC microcontrollers.</simpara>
</section>
<section xml:id="_adoff">
<title>ADOff</title>
<simpara><emphasis role="strong">This command is obsolete</emphasis>. There should be no need to call it. GCBASIC
will automatically disable the A/D converter and set all pins to digital
mode when starting the program, and after every use of the ReadAD
function.</simpara>
<simpara>It is recommended that this command be removed from all programs.</simpara>
</section>
<section xml:id="_readad">
<title>ReadAD</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara>For a normal ( also called a Single Channel )  read use.</simpara>
<screen>    byte_variable = ReadAD( ANX )</screen>
<simpara>For a Differential Channel read use the following.&#160;&#160;Where ANpX is the positive port, and ANnY is the negative port.</simpara>
<screen>    byte_variable = ReadAD( ANpX , ANnY )</screen>
<simpara>To obtain a byte value from an AD Channel use the following to force an 8 bit AD Channel to respond with a byte value [0 to 255].</simpara>
<screen>    byte_variable = ReadAD( ANX , TRUE )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>When using <emphasis role="strong">ReadAD</emphasis> ( ANx ) the returned value is an 8 bit number [0- 255].&#160;&#160;The byte variable assigned by the function can be a byte, word, integer or long.</simpara>
<simpara>When using <emphasis role="strong">ReadAD</emphasis> ( ANpX , ANnY ) the returned value is an integer, as negative values can be returned.</simpara>
<simpara>When using <emphasis role="strong">ReadAD</emphasis> ( ANpX , TRUE ) the returned value is an integer, but you should treat as a byte.</simpara>
<simpara>ReadAD is a function that can be used to read the built-in analog to digital converter that many microcontroller chips include.&#160;&#160;port should be specified as AN0, AN1, AN2, etc., up to the number of analog inputs available on the chip that is in use.&#160;&#160;Those familiar with Atmel AVR microcontrollers can also refer to the ports as ADC0, ADC1, etc.&#160;&#160;Refer to the datasheet for the microcontroller chip to find the number of ports available.&#160;&#160;(Note: it&#8217;s perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller)</simpara>
<simpara>Other functions that are similar are <emphasis role="strong">ReadAD10</emphasis> and <emphasis role="strong">ReadAD12</emphasis>.&#160;&#160;See the relevant Help page for the specific usage of each function.</simpara>
<simpara>The constant <emphasis role="strong">AD_Delay</emphasis> controls is the acquisition delay.&#160;&#160;The default value is 20 us.&#160;&#160;This can be changed by adding the following constant.</simpara>
<screen>    #define AD_Delay 2 10us</screen>
<simpara><emphasis role="strong">ADSpeed</emphasis> controls the source of the clock for the ADC module.&#160;&#160; It varies from one chip to another.&#160;&#160; InternalClock is a Microchip PIC microcontroller only option that will drive the ADC from an internal RC oscillator.&#160;&#160;The default value is 128.</simpara>
<simpara>Using ADSPEED</simpara>
<screen>    'default value
    #define ADSpeed MediumSpeed


    'pre-defined constants
    #define HighSpeed 255
    #define MediumSpeed 128
    #define LowSpeed 0</screen>
<simpara><emphasis role="strong">AD_VREF_DELAY</emphasis> controls the charging time for VRef capacitor on Atmel AVR microcontrollers only.&#160;&#160;This therefore controls the charge from internal VRef.&#160;&#160; ReadAD will not be accurate for internal reference without this.</simpara>
<simpara><emphasis role="strong">AD_Acquisition_Time_Select_bits</emphasis> also controls the Acquisition Time Select bits.&#160;&#160; Acquisition time is the duration that the AD charge
holding capacitor remains connected to AD channel from the instant the read is commenced is set until conversions begins.</simpara>
<simpara>The default value of AD_Acquisition_Time_Select_bits is 0b100 or decimal 4, where all three ACQT bits will be set.&#160;&#160;To change use the following.</simpara>
<screen>    'change the default value
    #define AD_Acquisition_Time_Select_bits 0b001    'this will only set ACQT bit 0, ACQT bits 1 and 2 will be cleared.</screen>
<simpara><emphasis role="strong">Example 1</emphasis></simpara>
<simpara>This example reads the ADC port and writes the output to the EEPROM.</simpara>
<screen>    #chip 16F819, 8

    'Set the input pin direction
    Dir PORTA.0 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        EPWrite CurrentAddress, ReadAD(AN0)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">Example 2</emphasis></simpara>
<simpara>This example reads the ADC port and writes the output to the EEPROM.&#160;&#160;The output value will be in the range of [0-255].</simpara>
<screen>    #chip 16F1789, 8


    'Set the input pin direction
    Dir PORTA.0 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        EPWrite CurrentAddress, ReadAD(AN0, TRUE)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">Example 3</emphasis></simpara>
<simpara>This example used the diffential capabilities of ADC port and writes the output to the EEPROM.&#160;&#160;The output value will be in the range of [-255 to 255].</simpara>
<simpara>AN0 and AN2 are used for the diffential ADC reading.</simpara>
<screen>    #chip 16F1789, 8


    'Set the input pin direction
    Dir PORTA.0 In
    Dir PORTA.2 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        EPWrite CurrentAddress, ReadAD( AN0, AN2 )

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_readad10">ReadAD10</link>, <link linkend="_readad12">ReadAD12</link></simpara>
</section>
<section xml:id="_readad10">
<title>ReadAD10</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara>For a normal ( also called a Single Channel )  read use.</simpara>
<screen>    word_variable = ReadAD10( ANX )</screen>
<simpara>For a Differential Channel read use the following.&#160;&#160;Where ANpX is the positive port, and ANnY is the negative port.</simpara>
<screen>    integer_variable = ReadAD10( ANpX , ANnY )</screen>
<simpara>To obtain a 10-bit value from an AD Channel use the following to force a 10 bit AD Channel to respond with the correct value, in terms of the range [0 to 1023]</simpara>
<screen>    integer_variable = ReadAD10( ANX , TRUE )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>ReadAD10 is a function that can be used to read the built-in analog to digital converter that many microcontroller chips include.&#160;&#160;The port should be specified as AN0, AN1, AN2, etc., up to the number of analog inputs available on the chip that is in use.&#160;&#160;Those familiar with Atmel AVR microcontrollers can also refer to the ports as ADC0, ADC1, etc.&#160;&#160;Refer to the datasheet for the microcontroller chip to find the number of ports available.&#160;&#160;(Note: it&#8217;s perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller.)</simpara>
<simpara>When using <emphasis role="strong">ReadAD10</emphasis> ( ANX ) the returned value is the <emphasis role="strong">full range</emphasis> of the ADC module.&#160;&#160;Therefore, the method will return an 8 bit value [0-255], or an 10 bit value [0-1023] or an 12 bit value [0-4095].&#160;&#160; This is dependent on the microcontrollers capabilities.&#160;&#160;  For a 10 bit value [0-1023] always to be returned use  user_variable = ReadAD10( ANX , TRUE ).&#160;&#160; The user variable can be a byte, word, integer or long but typically a word is recommnended.</simpara>
<simpara>When using <emphasis role="strong">ReadAD10</emphasis> ( ANpX , ANnY ), for differential ADC reading, the returned value is an integer as negative values will be returned.</simpara>
<simpara>When using <emphasis role="strong">ReadAD10</emphasis> ( ANpX , TRUE ), to force a 10 bit ADC reading, the returned value is an integer.</simpara>
<simpara>Other functions that are similar are <emphasis role="strong">ReadAD</emphasis> and <emphasis role="strong">ReadAD12</emphasis>.&#160;&#160;See the relevant Help page for the specific usage of each function.</simpara>
<simpara><emphasis role="strong">AD_Delay</emphasis> controls is the acquisition delay.&#160;&#160; The default value is 20 us.&#160;&#160;This can be changed to a longer acquisition delay by adding the following constant.</simpara>
<screen>    #define AD_Delay 4 10us</screen>
<simpara><emphasis role="strong">ADSpeed</emphasis>( controls the source of the clock for the ADC module.&#160;&#160; It varies from one chip to another.&#160;&#160; InternalClock is a microcontroller only option that will drive the ADC from an internal RC oscillator.&#160;&#160;The default value is 128.</simpara>
<screen>    'default value
    #define ADSpeed MediumSpeed


    'pre-defined constants
    #define HighSpeed 255
    #define MediumSpeed 128
    #define LowSpeed 0</screen>
<simpara><emphasis role="strong">AD_Acquisition_Time_Select_bits</emphasis> also controls the Acquisition Time Select bits.&#160;&#160; Acquisition time is the duration that the AD charge
holding capacitor remains connected to AD channel from the instant the read is commenced is set until conversions begins.</simpara>
<simpara>The default value of AD_Acquisition_Time_Select_bits is 0b100 or decimal 4, where all three ACQT bits will be set.&#160;&#160;To change use the following.</simpara>
<screen>    'change the default value
    #define AD_Acquisition_Time_Select_bits 0b001    'this will only set ACQT bit 0, ACQT bits 1 and 2 will be cleared.</screen>
<simpara><emphasis role="strong">Example 1 - Read 10-bit ADC</emphasis></simpara>
<screen>    #chip 16F819, 8

    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 reading
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD10(AN0))

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">Example 2 - Reading Reference Voltages:</emphasis></simpara>
<simpara>When selecting the  reference source for ADC on ATmega328 GCBASIC will overwrite anything that you put into te ADMUX register - but this option allow you change the ADC reference source on Atmel AVR microcontrollers.&#160;&#160; You can set the AD_REF_SOURCE constant to whatever you want to use.&#160;&#160; It defaults to the VCC pin, as example you can set the Atmel AVR to use the 1.1V reference with this:
<emphasis role="strong">#define AD_REF_SOURCE AD_REF_256</emphasis> where 256 refers to the 2.56V reference on some older AVRs, but the same code will select the 1.1V reference on an ATmega328p</simpara>
<screen>    ' Dynamically switching reference.
    #define AD_REF_SOURCE ADRefSource
    #define AD_VREF_DELAY 5 ms
    AdRefSource = AD_REF_AVCC
    HSerPrint ReadAD10(AN1)
    HSerPrint ", "
    AdRefSource = AD_REF_256
    HSerPrint ReadAD10(AN1)</screen>
<simpara>The example above sets the AD_REF_SOURCE to a variable, and then changes the value of the variable to select the source.&#160;&#160; With this approach, we also need to allow time to charge the reference capacitor to the correct voltage.</simpara>
<simpara><emphasis role="strong">Example 3 - Read 10-bit ADC forcing a 10-bit value to be returned</emphasis></simpara>
<screen>    #chip 16F1789, 8

    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 reading
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD10(AN0), TRUE)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">Example 4</emphasis></simpara>
<simpara>This example used the diffential capabilities of ADC port and writes the output to the EEPROM.&#160;&#160;The output value will be in the range of [-1023 to 1023].</simpara>
<simpara>AN0 and AN2 are used for the diffential ADC reading.</simpara>
<screen>    #chip 16F1789, 8

    'USART settings
    #define USART_BAUD_RATE 9600  'Initializes USART port with 9600 baud
    #define USART_TX_BLOCKING ' wait for tx register to be empty
    wait 100 ms

    'Set the input pin direction
    Dir PORTA.0 In
    Dir PORTA.2 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        HSerPrint ReadAD10( AN0, AN2 )
        HserPrintCRLF
        'Wait 10 minutes before getting another reading
        Wait 10 min

    Next</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_readad">ReadAD</link>, <link linkend="_readad12">ReadAD12</link></simpara>
</section>
<section xml:id="_readad12">
<title>ReadAD12</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara>For a normal ( also called a Single Channel )  read use.</simpara>
<screen>    user_variable = ReadAD12( ANX )</screen>
<simpara>For a Differential Channel read use the following.&#160;&#160;Where ANpX is the positive port, and ANnY is the negative port.</simpara>
<screen>    user_variable = ReadAD12( ANpX , ANnY )</screen>
<simpara>To obtain a 12-bit value from an AD Channel use the following to force a 12 bit AD Channel to respond with the correct value, in terms of the range of [0 to 4095]</simpara>
<screen>    user_variable = ReadAD12( ANX , TRUE )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>When using <emphasis role="strong">ReadAD12</emphasis> ( ANX ) the returned value is an 12 bit number [0-4095].&#160;&#160;The user variable can be a word, integer or long.</simpara>
<simpara>When using <emphasis role="strong">ReadAD12</emphasis> ( ANpX , ANnY ) the returned value is an integer as negative values can be returned.</simpara>
<simpara><emphasis role="strong">ReadAD12</emphasis>  is a function that can be used to read the built-in analog to digital converter that many microcontroller chips include.&#160;&#160;Port should be specified as AN0, AN1, AN2, etc., up to the number of analog inputs available on the chip that is in use.&#160;&#160;Those familiar with Atmel AVR microcontrollers can also refer to the ports as ADC0, ADC1, etc.&#160;&#160;Refer to the datasheet for the microcontroller chip to find the number of ports available.&#160;&#160;(Note: it&#8217;s perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller.)</simpara>
<simpara>Other functions that are similar are <emphasis role="strong">ReadAD</emphasis> and <emphasis role="strong">ReadAD10</emphasis>.&#160;&#160;See the relevant Help page for the specific usage of each function.</simpara>
<simpara><emphasis role="strong">AD_Delay</emphasis> controls is the acquisition delay.&#160;&#160; The default value is 20 us.&#160;&#160;This can be changed to a longer acquisition delay by adding the following constant.</simpara>
<screen>    #define AD_Delay 4 10us</screen>
<simpara><emphasis role="strong">ADSpeed</emphasis>( controls the source of the clock for the ADC module.&#160;&#160; It varies from one microcontroller to another.&#160;&#160; InternalClock is a Microchip PIC microcontroller only option that will drive the ADC from an internal RC oscillator.&#160;&#160;The default value is 128.</simpara>
<screen>    'default value
    #define ADSpeed MediumSpeed


    'pre-defined constants
    #define HighSpeed 255
    #define MediumSpeed 128
    #define LowSpeed 0</screen>
<simpara><emphasis role="strong">AD_Acquisition_Time_Select_bits</emphasis> also controls the Acquisition Time Select bits.&#160;&#160; Acquisition time is the duration that the AD charge
holding capacitor remains connected to AD channel from the instant the read is commenced is set until conversions begins.</simpara>
<simpara>The default value of AD_Acquisition_Time_Select_bits is 0b100 or decimal 4, where all three ACQT bits will be set.&#160;&#160;To change use the following.</simpara>
<screen>    'change the default value
    #define AD_Acquisition_Time_Select_bits 0b001    'this will only set ACQT bit 0, ACQT bits 1 and 2 will be cleared.</screen>
<simpara><emphasis role="strong">Example 1  - Read 12-bit ADC</emphasis></simpara>
<screen>    #chip 16F1788, 8

    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 readings
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD12(AN0))

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">Example 2  - Force a 12-bit value to be returned</emphasis></simpara>
<screen>    #chip 16F1788, 8


    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 readings
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD12(AN0), TRUE)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">Example 3</emphasis></simpara>
<simpara>This example used the diffential capabilities of ADC port and writes the output to the EEPROM.&#160;&#160;The output value will be in the range of [-4095 to 4095].</simpara>
<simpara>AN0 and AN2 are used for the diffential ADC reading.</simpara>
<screen>    #chip 16F1789, 8

    'USART settings
    #define USART_BAUD_RATE 9600  'Initializes USART port with 9600 baud
    #define USART_TX_BLOCKING ' wait for tx register to be empty
    wait 100 ms

    'Set the input pin direction
    Dir PORTA.0 In
    Dir PORTA.2 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        HSerPrint ReadAD12( AN0, AN2 )
        HserPrintCRLF
        'Wait 10 minutes before getting another reading
        Wait 10 min

    Next</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_readad">ReadAD</link>, <link linkend="_readad10">ReadAD10</link></simpara>
</section>
<section xml:id="_analog_digital_conversion_code_optimisation">
<title>Analog/Digital Conversion Code Optimisation</title>
<simpara><emphasis role="strong">About Analog/Digital Conversion Code Optimisation</emphasis></simpara>
<simpara>The analog to digital converter (ADC or A/D) module support is implemented by GCBASIC to provide 8-bit, 10-bit and 12-bit Single channel measurement mode and Differential Channel Measurement with support up to 34 channels.  For compatibility all channels are supported.</simpara>
<simpara>There are two methods to optimise the code.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>To mimise the code, use the contstants to disable support for a specfic channels</simpara>
</listitem>
<listitem>
<simpara>To adapt the ADC configuration by inserting specfic commands to set registers or register bits.</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">1. Minimise the code</emphasis></simpara>
<simpara>The example below would disable support for ADC port 0 (AD0).</simpara>
<screen>    #define USE_AD0 FALSE</screen>
<simpara>The following tables show the #defines that can be used to reduce the code size - these are the defines for the standard microcontrollers.
For 16f1688x and similar microcontrollers please see the second table.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Channel</entry>
<entry align="left" valign="top">Optimisation Value</entry>
<entry align="left" valign="top">Default Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD5</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD6</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD7</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD9</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD10</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD11</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD12</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD13</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD14</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD15</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD16</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD17</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD18</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD19</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD20</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD21</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD22</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD23</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD24</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD25</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD26</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD27</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD28</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD29</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD30</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD31</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD32</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD33</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD34</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For 16f1688x devices see the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Channel</entry>
<entry align="left" valign="top">Optimisation Value</entry>
<entry align="left" valign="top">Default Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA5</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA6</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA7</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC5</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC6</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC7</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD5</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD6</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD7</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADE0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADE1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADE2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This is a example - disables every channel except the specified channel by defining every channel except USE_AD0 as FALSE.</simpara>
<simpara>This will save 146 bytes of program memory.</simpara>
<screen>    #chip 16F1939

    'USART settings
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    'Set the input pin direction
    Dir PORTA.0 In

    'Print 255 reading
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        HSerPrint str(ReadAD10(AN0))

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next

    #define USE_AD0 TRUE
    #define USE_AD1 FALSE
    #define USE_AD2 FALSE
    #define USE_AD2 FALSE
    #define USE_AD3 FALSE
    #define USE_AD4 FALSE
    #define USE_AD5 FALSE
    #define USE_AD6 FALSE
    #define USE_AD7 FALSE
    #define USE_AD8 FALSE
    #define USE_AD9 FALSE
    #define USE_AD10 FALSE
    #define USE_AD11 FALSE
    #define USE_AD12 FALSE
    #define USE_AD13 FALSE
    #define USE_AD14 FALSE
    #define USE_AD15 FALSE
    #define USE_AD16 FALSE
    #define USE_AD17 FALSE
    #define USE_AD18 FALSE
    #define USE_AD19 FALSE
    #define USE_AD20 FALSE
    #define USE_AD21 FALSE
    #define USE_AD22 FALSE
    #define USE_AD23 FALSE
    #define USE_AD24 FALSE
    #define USE_AD25 FALSE
    #define USE_AD26 FALSE
    #define USE_AD27 FALSE
    #define USE_AD28 FALSE
    #define USE_AD29 FALSE
    #define USE_AD30 FALSE
    #define USE_AD31 FALSE
    #define USE_AD32 FALSE
    #define USE_AD33 FALSE
    #define USE_AD34 FALSE</screen>
<simpara>For 16f18855 family of microcontrollers this is a example.  This will save 149 bytes of program memory.</simpara>
<screen>    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCode
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: 13.3.2021
    '''


        'Chip Settings.
        #CHIP 16F18855,32
        #CONFIG MCLRE_ON
        #OPTION EXPLICIT

        '' -------------------LATA-----------------
        '' Bit#:  -7---6---5---4---3---2---1---0---
        '' LED:   ---------------|D5 |D4 |D3 |D1 |-
        ''-----------------------------------------
        ''

        #define USART_BAUD_RATE 19200
        #define USART_TX_BLOCKING

        #define LEDD2 PORTA.0
        #define LEDD3 PORTA.1
        #define LEDD4 PORTA.2
        #define LEDD5 PORTA.3
        Dir     LEDD2 OUT
        Dir     LEDD3 OUT
        Dir     LEDD4 OUT
        Dir     LEDD5 OUT

        #define SWITCH_DOWN         0
        #define SWITCH_UP           1

        #define SWITCH              PORTA.5


        'Setup an Interrupt event when porta.5 goes negative.
        IOCAN5 = 1
        On Interrupt PORTABChange  Call InterruptHandler

        do

         'Read the value from the EEPROM from register Zero in the EEPROM
          EPRead ( 0, OutValue )

          'Leave the Top Bytes alone and set the lower four bits
          PortA = ( PortA &amp; 0XF0 ) OR ( OutValue / 16 )
          Sleep

        loop


    sub InterruptHandler

        if IOCAF5 = 1 then                         'S2 was just pressed
            IOCAN5 = 0                             'Prevent the event from reentering the InterruptHandler routine
            IOCAF5 = 0                             'We must clear the flag in software

            wait 5 ms                              'debounce by waiting and seeing if still held down
            if ( SWITCH = SWITCH_DOWN ) then
                'Read the ADC
                adc_value = readad ( AN4 )
                'Write the value to register Zero in the EEPROM
                EPWrite ( 0, adc_value )
            end if
            IOCAN5 = 1                              'ReEnable the InterruptHandler routine

        end if

    end sub

    #define USE_ADA0 FALSE
    #define USE_ADA1 FALSE
    #define USE_ADA2 FALSE
    #define USE_ADA3 FALSE
    #define USE_ADA4 TRUE
    #define USE_ADA5 FALSE
    #define USE_ADA6 FALSE
    #define USE_ADA7 FALSE
    #define USE_ADB0 FALSE
    #define USE_ADB1 FALSE
    #define USE_ADB2 FALSE
    #define USE_ADB3 FALSE
    #define USE_ADB4 FALSE
    #define USE_ADB5 FALSE
    #define USE_ADB6 FALSE
    #define USE_ADB7 FALSE
    #define USE_ADC0 FALSE
    #define USE_ADC1 FALSE
    #define USE_ADC2 FALSE
    #define USE_ADC3 FALSE
    #define USE_ADC4 FALSE
    #define USE_ADC5 FALSE
    #define USE_ADC6 FALSE
    #define USE_ADC7 FALSE
    #define USE_ADD0 FALSE
    #define USE_ADD1 FALSE
    #define USE_ADD2 FALSE
    #define USE_ADD3 FALSE
    #define USE_ADD4 FALSE
    #define USE_ADD5 FALSE
    #define USE_ADD6 FALSE
    #define USE_ADD7 FALSE
    #define USE_ADE0 FALSE
    #define USE_ADE1 FALSE
    #define USE_ADE2 FALSE</screen>
<simpara><emphasis role="strong">2. Adapt the ADC configuration</emphasis></simpara>
<simpara>Example 1:</simpara>
<simpara>The following example will set the specific register bits.  The instruction will be added to the compiled code.</simpara>
<screen>    #define ADReadPreReadCommand  ADCON.2=0:ANSELA.0=1</screen>
<simpara>The constant <emphasis role="strong">ADReadPreReadCommand</emphasis> can be used to adapt the ADC methods. The constant can enable registers or register bit(s) that are required to managed for a specfic solution.</simpara>
<simpara>In the example above the following ASM will be added to your code.  This WILL be added just before the ADC is enabled and the setting of the acquisition delay.</simpara>
<screen>  ;ADReadPreReadCommand
  banksel ADCON
  bcf ADCON,2
  banksel ANSELA
  bsf ANSELA,0</screen>
<simpara>Example 2:</simpara>
<simpara>The following example can be used to change the ADMUX to support a sensor on ADC4.</simpara>
<simpara>This supports reading the internal temperature sensor on the ATTINY85.&#160; &#160;
This method will work on other similar chips.&#160; &#160;
Please refer the chip specific datasheet.</simpara>
<simpara>This will call a macro to change the ADMUX to read the ATTINY85 internal temperature sensor, set the reference voltage to 1v1 and then wait 100 ms.</simpara>
<screen>    #define ADREADPREREADCOMMAND ATTINY85ReadInternalTemperatureSensor

    Macro ATTINY85ReadInternalTemperatureSensor
    /*
    17.12 of the datasheet
    The temperature measurement is based on an on-chip temperature sensor that is coupled to a single ended ADC4
    channel. Selecting the ADC4 channel by writing the MUX[3:0] bits in ADMUX register to 1111 enables the temperature sensor. The internal 1.1V reference must also be selected for the ADC reference source in the
    temperature sensor measurement. When the temperature sensor is enabled, the ADC converter can be used in
    single conversion mode to measure the voltage over the temperature sensor.
    The measured voltage has a linear relationship to the temperature as described in Table 17-2 The sensitivity is
    approximately 1 LSB / ?C and the accuracy depends on the method of user calibration. Typically, the measurement
    accuracy after a single temperature calibration is ±10?C, assuming calibration at room temperature. Better
    accuracies are achieved by using two temperature points for calibration.
    */
      IF ADReadPort=4 then
          ADMUX = ( ADMUX and 0X20 ) or 0X8F
          wait 100 ms
      End if

    End Macro</screen>
<simpara>This will generate the following ASM.</simpara>
<screen>    ;ADREADPREREADCOMMAND  'adds user code below
      lds SysCalcTempA,ADREADPORT
      cpi SysCalcTempA,4
      brne  ENDIF2
      ldi SysTemp2,32
      in  SysTemp3,ADMUX
      and SysTemp3,SysTemp2
      mov SysTemp1,SysTemp3
      ldi SysTemp2,143
      or  SysTemp1,SysTemp2
      out ADMUX,SysTemp1
      ldi SysWaitTempMS,100
      ldi SysWaitTempMS_H,0
      rcall Delay_MS
    ENDIF2:</screen>
</section>
</section>
<section xml:id="_bitwise">
<title>Bitwise</title>
<simpara>This is the Bitwise section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_bitwise_operations_overview">
<title>Bitwise Operations Overview</title>
<simpara><emphasis role="strong">About Bitwise Operations</emphasis></simpara>
<simpara>GCBASIC (as with most other microcontroller programming languages) supports bitwise operations.</simpara>
<simpara>Bitwise operations are performed on one or more bit patterns at the level of their individual bits.</simpara>
<simpara>GCBASIC supports the following methods.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Method</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Meaning</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Set</simpara></entry>
<entry align="left" valign="top"><simpara>Assigns a Bit value of On or Off</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetWith</simpara></entry>
<entry align="left" valign="top"><simpara>Evaluates an expression and assigns the result</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FnLSL</simpara></entry>
<entry align="left" valign="top"><simpara>Performs a Bitwise LEFT shift</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FnLSR</simpara></entry>
<entry align="left" valign="top"><simpara>Performs a Bitwise RIGHT shift</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate</simpara></entry>
<entry align="left" valign="top"><simpara>Performs a rotation of a variable of one bit in a specified direction</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">For more help, see: <link linkend="_set">Set</link>, <link linkend="_setwith">SetWith</link>, <link linkend="_fnlsl">FnLSL</link>, <link linkend="_fnlsr">FnLSR</link> and <link linkend="_rotate">Rotate</link></emphasis></simpara>
</section>
<section xml:id="_fnlsl">
<title>FnLSL</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    BitsOut = FnLSL(BitsIn, NumBits)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>FnLSL</literal> (Logical Shift Left) will perform a Bitwise left shift.
<literal>FnLSL</literal> will return BitsIn shifted NumBits to the left, it is equivalent to the 'C' operation:</simpara>
<screen>    BitsOut = BitsIn &lt;&lt; NumBits</screen>
<simpara>Each left shift is the equivalent of multiplying BitsIn by 2.
BitsIn and NumBits may be may be a variable and of  type: Bit, Byte, Word, Long, Constant or another Function.
Zeros are shifted in from the right, Bits that are shifted out are lost.</simpara>
<simpara>It is useful for mathematical and logical operations, as well as creating serial data streams or manipulating I/O ports.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ' This program will shift the LEDs on the Microchip PIC Low Pin
    ' Count Demo Board from Right to Left, that is DS1(RC0) to
    ' DS4(RC3) and repeat

    #chip    16f690        ' declare the target Device

    #define  LEDPORT PORTC ' LEDs on pins 16, 15, 14 and 7

    Dim LEDMask as Byte    ' Pattern to be displayed
    LEDMask = 0b0001       ' Initialise the Patten
    Dir LEDPORT Out        ' Enable the LED Port.

    Do
        LEDMask = FnLSL(LEDMask, 1) &amp; 0x0F    ' Mask the lower 4 bits
        if LEDPORT.3 then LEDMask.0 = 1       ' Restart the sequence
        LEDPORT = LEDMask                     ' Display the Pattern
        wait 500 ms
    Loop
    End</screen>
<simpara><emphasis role="strong">See Also <link linkend="_bitwise_operations_overview">Bitwise Operations Overview</link></emphasis> and <emphasis role="strong"><link linkend="_conditions">Conditions</link></emphasis></simpara>
</section>
<section xml:id="_fnlsr">
<title>FnLSR</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    BitsOut = FnLSR(BitsIn, NumBits)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>FnLSR</literal> (Logical Shift Right) will perform a Bitwise right shift. <literal>FnLSR</literal> will return BitsIn shifted NumBits to the right, it is equivalent to the 'C' operation:</simpara>
<screen>    BitsOut = BitsIn &gt;&gt; NumBits</screen>
<simpara>Each right shift is the equivalent of dividing BitsIn by 2.</simpara>
<simpara>BitsIn and NumBits may be may be a variable and of  type: Bit, Byte, Word, Long, Constant or another Function.</simpara>
<simpara>Zeros are shifted in from the left, Bits that are shifted out are lost.</simpara>
<simpara>It is useful for mathematical and logical operations, as well as creating serial data streams or manipulating I/O ports.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ' This program will shift the LEDs on the Microchip PIC Low Pin Count Demo Board
    ' from Right to Left, that is DS4(RC3) to DS1(RC0) and repeat.

    #chip    16f690        ' declare the target Device

    #define  LEDPORT PORTC ' LEDs on pins 16, 15, 14 and 7

    Dim LEDMask as Byte    ' Pattern to be displayed
    LEDMask = 0b1000       ' Initialise the Patten
    Dir LEDPORT Out        ' Enable the LED Port.

    Do
      LEDPORT = LEDMask    ' Display the Pattern
      wait 500 ms
      LEDMask = FnLSR(LEDMask, 1) &amp; 0x0F ' Mask the lower 4 bits
      if LEDPORT.0 then LEDMask.3 = 1    ' Restart the sequence
    Loop
    End</screen>
<simpara><emphasis role="strong">See Also <link linkend="_bitwise_operations_overview">Bitwise Operations Overview</link></emphasis> and <emphasis role="strong"><link linkend="_conditions">Conditions</link></emphasis></simpara>
</section>
<section xml:id="_setwith">
<title>SetWith</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SetWith(TargetBit, Source)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>SetWith</literal> is an extended version of SET, it allows a Bit Field to be set or cleared by evaluating the content of Source. <literal>SetWith</literal> should always be used when TargetBit is an I/O Bit and Source is a Function, in order to avoid the possibility of I/O jitter.</simpara>
<simpara>Source may be a variable and of  type: Bit, Byte, Word or Long, a Constant, an expression or a Function.</simpara>
<simpara>It will SET  TargetBit  to 1 if Source evaluates to anything other than zero. TargetBit  will always be a 1 or a 0 regardless of the variable type of TargetBit.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ' This program will reflect the state of SW1(RA3) on LED DS1(RC0) of the Microchip
    ' Low Pin Count Demo Board. Notice that because SW1 is normally High the state has to
    ' be inverted to turn on the LED (DS1) when SW1 is pressed.

    #chip   16f690    ' declare the target Device

    #Define SW1 PORTA.3
    #Define DS1 PORTC.0

    DIR DS1 Out
    DIR SW1 In

    Do
      ' set the Bit DS1 to equal the Bit SW1
      SetWith( DS1, !SW1 )
    Loop
    END</screen>
<simpara><emphasis role="strong">See Also <link linkend="_bitwise_operations_overview">Bitwise Operations Overview</link></emphasis> and <emphasis role="strong"><link linkend="_conditions">Conditions</link></emphasis></simpara>
</section>
</section>
<section xml:id="_memory">
<title>Memory</title>
<simpara>This is the Memory section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_mcu_eeprom_dfm">
<title>MCU EEPROM ( DFM )</title>
<simpara>This is the EEPROM  ( PFM ) section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_epread">
<title>EPRead</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    EPRead <emphasis>location, store</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC and Atmel AVR microcontrollers with EEPROM data memory.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>EPRead</literal> is used to read information from the EEPROM data storage that many microcontroller chips are equipped with.
<literal><emphasis>location</emphasis></literal> represents the location to read data from, and varies from one chip to another.
<literal><emphasis>store</emphasis></literal> is the variable in which to store the data after it has been read from EEPROM.</simpara>
<simpara>Note
Do not exceed the location ( also known as the EEProm address ) of the physical EEProm.  If the EEProm size is 256 ensure location is in the range of 0 to 255;  If the EEProm size is 512 ensure location is in the range of 0 to 511 and use a Word variable as the location parameter.
Example:</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Program to turn a light on and off
    'Will remember the last status

    #chip tiny2313, 1
    #define Button PORTB.0
    #define Light PORTB.1

    Dir Button In
    Dir Light Out

    'Load saved status
    EPRead 0, LightStatus

    If LightStatus = 0 Then
      Set Light Off
    Else
      Set Light On
    End If

    Do
      'Wait for the button to be pressed
      Wait While Button = On
      Wait While Button = Off
      'Toggle value, record
      LightStatus = !LightStatus
      EPWrite 0, LightStatus

      'Update light
      If LightStatus = 0 Then
        Set Light Off
      Else
        Set Light On
      End If
    Loop</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_epwrite">EPWrite</link></emphasis></simpara>
</section>
<section xml:id="_epwrite">
<title>EPWrite</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    EPWrite <emphasis>location</emphasis>, <emphasis>data</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC and Atmel AVR microcontrollers with EEPROM data memory.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>EPWrite</literal> is used to write information to the EEPROM data storage, so that
it can be accessed later by a programmer on the PC, or by the <literal>EPRead</literal>
command. <literal><emphasis>location</emphasis></literal> represents the location to write data to, and the location varies
from one chip to another. <literal><emphasis>data</emphasis></literal> is the data that is to be written to the
EEPROM, and can be a value or a variable.</simpara>
<note>
<simpara>Do not exceed the location ( also known as the EEProm address ) of the physical EEProm.&#160;&#160;If the EEProm size is 256 ensure location is in the range of 0 to 255;&#160;&#160;If the EEProm size is 512 ensure location is in the range of 0 to 511 and use a Word variable as the location parameter.</simpara>
</note>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 16F819, 8

    'Set the input pin direction
    Dir PORTA.0 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

    'Take a reading and log it
    EPWrite CurrentAddress, ReadAD(AN0)

    'Wait 10 minutes before getting another reading
    Wait 10 min

    Next</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_epread">EPRead</link>,<link linkend="_lookup_tables">Creating EEProm data from a Lookup Table</link></emphasis></simpara>
</section>
<section xml:id="_dataset_for_eeprom">
<title>Dataset for EEPROM</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>        EEPROM DataSetName [[,]address]
            // multiples values, strings etc.
            0,1,2,3
        END EEPROM</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC microcontrollers with EEPROM memory.
AVR support required use of AVR-ASM assembler.&#160;&#160;GCASM does not support AVR EEPROM operations.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The EEPROM construct creates an EEPROM dataset for use with the specific microcontroller.&#160;&#160;An EEPROM dataset is a list of values that are stored in the EEPROM memory of the microcontroller, which then can be accessed using the EPREAD() command or other EEPROM read operations.</simpara>
<simpara>The advantage of an EEPROM dataset is that they are memory efficient being loaded directly into the EEPROM during programming operations.</simpara>
<simpara>EEPROM datasets are defined as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Byte values,</simpara>
</listitem>
<listitem>
<simpara>EEPROM addresses and EEPROM datasets CANNOT overlap,</simpara>
</listitem>
<listitem>
<simpara>EEPROM addresses must not overlap TABLE data,</simpara>
</listitem>
<listitem>
<simpara>TABLE data has precedence from address 0x00 until the the end of TABLE all data,</simpara>
</listitem>
<listitem>
<simpara>Strings must be expressed as ASCII byte value(s),</simpara>
</listitem>
<listitem>
<simpara>Multiple elements on a single line separated by commas,</simpara>
</listitem>
<listitem>
<simpara>Constants and calculations within the single line dataset entries are permitted,</simpara>
</listitem>
<listitem>
<simpara>Decimal values are NOT supported,</simpara>
</listitem>
<listitem>
<simpara>Access is via EPRread(), not supported by READTABLE().</simpara>
</listitem>
<listitem>
<simpara>18F devices must use even address for EEPROM location, and, 18F will pad (with 0x00) datasets to even number length.&#160;&#160;This is MPASM constraint and therefore the compiler and assembler will isssue specific error messages for odd EEPROM locations.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">Defining EEPROM datasets</emphasis></simpara>
<simpara><emphasis>Single data values</emphasis></simpara>
<simpara>A single value on each line with in the dataset.&#160;&#160;The example dataset, shown below, has the data on different line in within the set.</simpara>
<simpara>Simple example: This creates an EEPROM dataset at the first EEPROM location, then, the values of 12, 24, &#8230;&#8203; 72 are the consecutive values.</simpara>
<screen>        EEPROM EEDataSet
            12
            24
            36
            48
            60
            72
        End EEPROM</screen>
<simpara><emphasis>Multiple data values of the same line</emphasis></simpara>
<simpara>The following example creates the EEPROM dataset at EEPROM offset address of 0x10.&#160;&#160;</simpara>
<simpara>Multiple elements on a single line separated by commas.&#160;&#160;The example dataset, shown below, has the data separated by <literal>,</literal> and on different line in within the dataset.</simpara>
<screen>        EEPROM EEDataSource  0x10
            12,  24, 36
            48,  60, 72
        End EEPROM</screen>
<simpara><emphasis>Data values as constants, and, with data transformation</emphasis></simpara>
<simpara>Constants and calculations within the single line.  &#160;&#160;The example dataset, shown below, uses a defined constant to multiple the data with the dataset.</simpara>
<screen>        #define calculation_constant 2

        EEPROM EEDataSource  0x20
        1 * calculation_constant
        2 * calculation_constant
        3 * calculation_constant
        8 * calculation_constant
        4 * calculation_constant
        5 * calculation_constant
        End EEPROM</screen>
<simpara>&#160;&#160;
&#160;&#160;</simpara>
<simpara><emphasis>Data values as Strings</emphasis></simpara>
<simpara>Strings can be defined.&#160;&#160;Strings are delimited by double quotes. &#160;&#160; The following examples show the methods.</simpara>
<simpara>Any ASCII characters between any two "    " (double quotes) will be converted to dataset data.&#160;&#160; Also see ASCII escape codes.</simpara>
<simpara>A source string can be one string per line or comma separated strings, therefore, on the same line.</simpara>
<simpara>Example:</simpara>
<screen>    EEPROM Test_1
     "ABCDEFGHIJ"
    End EEPROM</screen>
<simpara><emphasis>ASCII Escape code</emphasis></simpara>
<simpara>Accepted escape strings are shown in the dataset below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Escape sequence</entry>
<entry align="left" valign="top">Meaning</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>\a</simpara></entry>
<entry align="left" valign="top"><simpara>beep</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\b</simpara></entry>
<entry align="left" valign="top"><simpara>backspace</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\f</simpara></entry>
<entry align="left" valign="top"><simpara>formfeed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\l or \n</simpara></entry>
<entry align="left" valign="top"><simpara>newline</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\r</simpara></entry>
<entry align="left" valign="top"><simpara>carriage return</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\t</simpara></entry>
<entry align="left" valign="top"><simpara>tab</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\0</simpara></entry>
<entry align="left" valign="top"><simpara>Null value, equates to ASCII 0. Same as \&amp;000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\&amp;nnn</simpara></entry>
<entry align="left" valign="top"><simpara>ascii char in decimal</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\\</simpara></entry>
<entry align="left" valign="top"><simpara>backslash</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\"</simpara></entry>
<entry align="left" valign="top"><simpara>double quote</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\'</simpara></entry>
<entry align="left" valign="top"><simpara>single quote</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Complete working example program</emphasis></simpara>
<simpara>This example creates several EEPROM datasets.&#160;&#160;The example also create a lookup table.&#160;&#160;The EEPROM dataset are addressed with the additional parameter to ensure there is no EEPROM dataset overlap.&#160;&#160;</simpara>
<screen>        #chip 16F886
        #option explicit

        #DEFINE USART_BAUD_RATE 9600
        #DEFINE USART_TX_BLOCKING
        #DEFINE USART_DELAY OFF

        Dim EEdataaddress, myvar as Byte
        EEdataaddress = 2

        Readtable TwoBytes,EEdataaddress,myVar
        HSerPrint myVar


        // *********************** EXAMPLE EE DATA ************************
        // * THIS IS ONLY ACCESSIBLE VIA EPREAD or other EE read functions.
        /*
        Usage:      EEProm EEPromBlockName [[,] OffSet Address ]
                    OffSet address defaults to 0x00 if not stated.

                    Addresses and datasets CANNOT overlap.
                    Addresses must not overlap TABLE data.
                    TABLE data has precendence from address 0x00 until the the end of TABLE data
        */


        EEProm EEDataSet1 0x10    // Locate EE Data at address
        3,2,1
        End EEProm

        EEProm VersionData 0x20   // Locate EE Data at address
        "    PWM2Laser   "
        "  Fabrice ENGEL "
        "   Version 1.4  "
        "  November 2023 "
        End EEProm

        EEProm EEDataSet2 0x0D    // Locate EE Data at address
        1,2,3
        End EEProm

        EEProm EEDataSet 0X04     // Locate EE Data at address
        1,2,3
        End EEProm

        // **********************  EXAMPLE TABLE DATA BEING LOADED INTO EE BY THE COMIPILER
        // *                       THIS IS ONLY ACCESSIBLE VIA READTABLE

        Table TwoBytes STORE data // EE Data Address Allocated by compiler
            0X55,0XAA,0X55
        End Table</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_epread">EPRead</link>, <link linkend="_lookup_tables">Creating EEProm data from a Lookup Table</link></emphasis></simpara>
</section>
</section>
<section xml:id="_hefm_pfm">
<title>HEFM ( PFM )</title>
<simpara>This is the HEFM ( PFM ) section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_hefm_overview">
<title>HEFM Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>Some enhanced mid-range Microchip PIC devices support High-Endurance Flash (HEF) memory. These devices lack the data EEPROM found on other devices.&#160;&#160;&#160;
Instead, they implement an equivalent amount of special flash memory, called HEF memory, that can provide an endurance comparable to that of a traditional data EEPROM.&#160;&#160;&#160;
HEF memory can be erased and written 100,000 times.&#160;&#160;&#160;
HEF memory appears in the regular program memory space and can be used for any purpose, like regular flash program memory.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
As with all flash memory, data must be erased before it can be written and writing this memory will stall the device.&#160;&#160;&#160;
Methods to read, write and erase the HEF memory are included in GCBASIC and they are described in this introduction.&#160;&#160;&#160;Also see Microchip application note AN1673, Using the PIC16F1XXX High-Endurance Flash (HEF) Block.
<?asciidoc-br?>
<?asciidoc-br?>
The <literal>hefsaf.h</literal> library supports HEF operations for GCBASIC.
<?asciidoc-br?>
<?asciidoc-br?>
Note:  By default, GCBASIC will use HEF memory for regular executable code unless it is told otherwise.&#160;&#160;&#160;
If you wish to store data here, you should reserve the HEF memory by using the compiler option, as shown below to reserve 128 words of HEF memory:</simpara>
<screen>    #option ReserveHighProg 128</screen>
<simpara>HEF memory is a block of memory locations found at the top of the flash program memory.    &#160;&#160;&#160;
Each memory location can be used to hold a 8-bit byte value.    &#160;&#160;&#160;
To further explain, the PIC 16F Enhanced Midrange Sevices memory architecture is 14-bits wide. &#160;&#160;&#160;   Therefore, for a single 14-bit memory location it is only practical to store an 8-bit byte value, and two 14-bit memory locations to hold one 16-bit word value.    &#160;&#160;&#160;
This is because the memory architecture only allows the use of the the lower 8-bits  of each 14-bit flash memory location for HEF usage
<?asciidoc-br?>
<?asciidoc-br?>
The main difference between HEF memory and EEPROM is that EEPROM allows byte-by-byte erase whereas the HEF memory does not.&#160;&#160;&#160;
With HEF memory, data must be erased before a write and the erase can only be performed in blocks of memory.&#160;&#160;&#160;
The blocks, also called rows, are a fixed size associated with the specific device.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
GCBASIC handles the erase operation automatically.&#160;&#160;&#160;
When a write operation is used by a user the GCBASIC library reads to a cache, updates the cache, erase the block and finally write the caches.&#160;&#160;&#160;
The complexity of using HEF memory is reduced with the automatically handling of these operations.&#160;&#160;&#160;</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The <literal>hefsaf.h</literal> library provides a set of methods to support the use of HEF memory.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="54*"/>
<colspec colname="col_3" colwidth="170*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Method</simpara></entry>
<entry align="left" valign="top"><simpara>Parameters</simpara></entry>
<entry align="left" valign="top"><simpara>Usage</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEFWrite</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the parameters: location, byte value</simpara></entry>
<entry align="left" valign="top"><simpara>HEFWrite ( location, byte_variable )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEFWriteWord</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the parameters: location, word_value</simpara></entry>
<entry align="left" valign="top"><simpara>HEFWriteWord ( location, word_variable  )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEFRead</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a function with the parameters: location returns a byte value</simpara></entry>
<entry align="left" valign="top"><simpara>byte_variable = HEFRead ( location  )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEFRead</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the paramers: location, byte_value</simpara></entry>
<entry align="left" valign="top"><simpara>HEFRead ( location , out_byte_variable )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEFReadWord</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a function with the parameters: location returns a word value</simpara></entry>
<entry align="left" valign="top"><simpara>word_variable = HEFRead ( location  )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEFReadWord</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the parameters: location, word_value</simpara></entry>
<entry align="left" valign="top"><simpara>HEFRead ( location , out_word_variable )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEFEraseBlock</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the parameters: block_number</simpara></entry>
<entry align="left" valign="top"><simpara>HEFEraseBlock ( 0 )
<?asciidoc-br?>
<?asciidoc-br?>
A value of 0,1,2,3 etc.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEFWriteBlock</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the parameters: block_number, buffer() [, HEF_ROWSIZE_BYTES ]</simpara></entry>
<entry align="left" valign="top"><simpara>HEFWriteBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String
<?asciidoc-br?>
<?asciidoc-br?>
The Array or a String will contain the values to be wrttin to the HEFM.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEFReadBlock</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the parameters: block_number, buffer() [, HEF_ROWSIZE_BYTES ]</simpara></entry>
<entry align="left" valign="top"><simpara>HEFReadBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String.
<?asciidoc-br?>
<?asciidoc-br?>
The Array or a String will contain the values from the HEFM.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The library also defines a set constants that are specific to the device.&#160;&#160;&#160;
These may be useful in the user program.&#160;&#160;&#160;
These constants are used by the library.&#160;&#160;&#160;
A user may use these public constants.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="54*"/>
<colspec colname="col_3" colwidth="170*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Usage</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEF_ROWSIZE_BYTES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Byte</simpara></entry>
<entry align="left" valign="top"><simpara>Size of an HEFM block in words</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEF_WORDS</literal> and <literal>HEF_BYTES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Word or a Byte</simpara></entry>
<entry align="left" valign="top"><simpara>ChipHEFMemWords parameter from the device .dat file</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEF_START_ADDR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Word</simpara></entry>
<entry align="left" valign="top"><simpara>Starting address of HEFM</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEF_NUM_BLOCKS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Byte</simpara></entry>
<entry align="left" valign="top"><simpara>Number of blocks of HEFM</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPWORDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Word</simpara></entry>
<entry align="left" valign="top"><simpara>Device specific constant for the total flash size</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPHEFMEMWORDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Word</simpara></entry>
<entry align="left" valign="top"><simpara>Device specific constant for the number of HEFM words available</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPERASEROWSIZEWORDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Word</simpara></entry>
<entry align="left" valign="top"><simpara>Device specific constant for the number of HEFM in an erase row</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Warning</emphasis></simpara>
<simpara>Whenever you update the hex file of your Microchip PIC micro-controller with your programmer you MAY erase the data that are stored in HEF memory.&#160;&#160;&#160;
If you want to avoid that you will have to flash your Microchip PIC micro-controller with software that allows memory exclusion when flashing.&#160;&#160;&#160;
This is the case with Microchip PIC MPLAB IPE (Go to <literal>Advanced Mode/Enter password/Select Memory/Tick “Preserve Flash on Program”/
Enter Start and End address</literal> of your HEFM).&#160;&#160;&#160;Or, simply use the PICkitPlus suite of software to preserve HEF memory during programming.
<?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_hefread">HEFRead</link>,
<link linkend="_hefreadword">HEFReadWord</link>,
<link linkend="_hefwrite">HEFWrite</link>,
<link linkend="_hefwriteword">HEFWriteWord</link>,
<link linkend="_hefreadblock">HEFReadBlock</link>,
<link linkend="_hefwriteblock">HEFWriteBlock</link>,
<link linkend="_heferaseblock">HEFEraseBlock</link></simpara>
</section>
<section xml:id="_hefread">
<title>HEFRead</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    'as a subroutine
    HEFRead ( location, data )

    'as a function
    data = HEFRead ( location )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with HEFM memory</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
HEFRead is used to read information, byte values, from HEFM, so that it can be accessed for use in a user program.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>location</literal> represents the location or relative address to read.  The location will range from location 0 to HEF_BYTES - 1, or for all practical purposes 0-127 since all PIC Microcontrollers with HEF support 128 bytes of HEF Memory. HEF_BYTES is a GCBASIC constant that represents the number of bytes of HEF Memory.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
<literal>data</literal> is the data that is to be read from the HEFM data storage area.&#160;&#160;&#160;
This can be a byte value or a byte variable.
<?asciidoc-br?>
<?asciidoc-br?>
This method reads data from HEFM given the specific relative location.&#160;&#160;&#160;
This method is similar to the EPRead method for EEPROM.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup PPS
     '... code to setup serial

    'The following example reads the HEFM data value into the byte variable “byte_value” using a subroutine.

    Dim data_byte as byte

    ;Write a byte of data to HEFM Location 34
    HEFWrite( 34, 144)

    ;Read the byte back from HEFM location 34
    HEFread( 34, byte_value )

    ;Display the data on a terminal
    HserPrint "byte_value = "
    Hserprint byte_value</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    '... code preamble to select part '... code preamble to select part
    '... code to setup PPS
     '... code to setup serial

    'The following example reads the HEFM data value into the byte variable “byte_value” using a function.

    Dim data_byte as byte

    ;Write a byte of data to HEF Location 34
    HEFWrite( 34, 144)

    ;Read the byte back from HEF location 34
    byte_value = HEFread( 34 )

    ;Display the data on a terminal
    HserPrint "byte_value = "
    Hserprint byte_value</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_hefm_overview">HEFM Overview</link>,
<link linkend="_hefread">HEFRead</link>,
<link linkend="_hefreadword">HEFReadWord</link>,
<link linkend="_hefwrite">HEFWrite</link>,
<link linkend="_hefwriteword">HEFWriteWord</link>,
<link linkend="_hefreadblock">HEFReadBlock</link>,
<link linkend="_hefwriteblock">HEFWriteBlock</link>,
<link linkend="_heferaseblock">HEFEraseBlock</link></simpara>
</section>
<section xml:id="_hefreadword">
<title>HEFReadWord</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    'as a subroutine
    HEFReadWord ( location, data_word_variable )

    'as a function
    data_word_variable = HEFReadWord ( location )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with HEFM memory</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
HEFReadWord is used to read information, word values, from HEFM so that it can be accessed for use in a user program.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>location</literal> represents the location or relative address to read.  The location will range from location 0 to HEF_BYTES - 1, or for all practical purposes 0-127 since all PIC Microcontrollers with HEF support 128 bytes of HEF Memory. HEF_BYTES is a GCBASIC constant that represents the number of bytes of HEF Memory.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
<literal>data</literal> is the data that is to be read from the HEFM data storage.&#160;&#160;&#160;
This must be a word variable.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
This method reads data from HEFM given the specific relative location.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial

    'The following example reads the HEFM value into the word variable “data_word_variable” by initially writing some word values.

    dim data_word_variable as word
    HEFWriteWord( 254, 4660 )

    HEFReadWord( 254, data_word_variable )

    HSerPrint "Value = "
    HSerPrint data_word_variable
    HSerPrintCRLF</screen>
<simpara><?asciidoc-br?>
If example 1 were displayed on a serial terminal.&#160;&#160;&#160;The result would show:</simpara>
<screen>    Value = 4660</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial

    'The following example uses a function to read the HEFM value into the word variable “data_word_variable”.

    dim data_word_variable as word
    HEFWriteWord( 254, 17185 )

    data_word_variable = HEFReadWord( 254 )

    HSerPrint "Value = "
    HSerPrint data_word_variable
    HSerPrintCRLF</screen>
<simpara><?asciidoc-br?>
If example 2 were displayed on a serial terminal.&#160;&#160;&#160;The result would show:</simpara>
<screen>    Value = 17185</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_hefm_overview">HEFM Overview</link>,
<link linkend="_hefread">HEFRead</link>,
<link linkend="_hefreadword">HEFReadWord</link>,
<link linkend="_hefwrite">HEFWrite</link>,
<link linkend="_hefwriteword">HEFWriteWord</link>,
<link linkend="_hefreadblock">HEFReadBlock</link>,
<link linkend="_hefwriteblock">HEFWriteBlock</link>,
<link linkend="_heferaseblock">HEFEraseBlock</link></simpara>
</section>
<section xml:id="_hefwrite">
<title>HEFWrite</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HEFWrite ( location, data )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with HEFM memory</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
HEFWrite is used to write information, byte values, to HEFM so that it can be accessed later for use in a user program.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>location</literal> represents the location or relative address to write. The location will range from location 0 to HEF_BYTES - 1, or for all practical purposes 0-127 since all PIC Microcontrollers with HEF support 128 bytes of HEF Memory. HEF_BYTES is a GCBASIC constant that represents the number of bytes of HEF Memory.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>data</literal> is the data that is to be written to the HEFM location.&#160;&#160;&#160;
This can be a byte value or a byte variable.
<?asciidoc-br?>
<?asciidoc-br?>
This method writes information to the HEFM given the specific location.
This method is similar to the EPWrite method for EEPROM.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial

    'The following example writes a byte value of 126 into HEFM location 34

     HEFWrite( 34, 126 )</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial

    'This example will populate all 128 bytes of HEF memory with a value that is same as the HEFM location

     Dim Rel_Address, DataByte as Byte
     Dim NVM_Address as Long
     Dim  DataWord, as Word
     Dim HEFaddress as Byte

    For Rel_Address = 0 to 127
        HEFWrite ( Rel_Address, Rel_Address )
    Next
    HEFM_DUMP

    End

  ; This subroutine displays the High Endurance Flash Memory on a terminal.
  ; Words are in reverse byte order relative to address.
  ; HEF data resides in the low byte of each 14bit program memory word.
  ; The high byte is not HEF and should always read "3F".

  Sub HEFM_DUMP

    Dim Blocknum as Byte
    NVM_Address  = HEF_START_ADDR
    BlockNum = 0

    Repeat  HEF_BYTES  ;128

        If NVM_Address % HEF_ROWSIZE_BYTES = 0 then
            If BlockNum &gt; 0 then   HSERPRINTCRLF
           HSerprintCRLF
           HserPrint "Block"
           HSerprint BlockNum
           HSerprint "     0     1     2     3     4     5     6     7"
           BlockNum++
        End if

        IF NVM_Address  % 8 = 0 then
           HSerPrintCRLF
           hserprint hex(NVM_Address_H)
           hserprint hex(NVM_ADDRESS)
           hserprint "     "
        end if

        Rel_Address = (NVM_ADDRESS - HEF_START_ADDR)
        HEFRead(Rel_Address, DataWord)

        hserprint hex(DataWord_H)
        hserprint hex(DataWord)
        hserprint "  "

        NVM_Address++
    End Repeat
    HserPrintCRLF
End sub</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
If example 2 were displayed on a serial terminal.&#160;&#160;&#160;The result would show:</simpara>
<screen>Block0     0     1     2     3     4     5     6     7
3F80     3F00  3F01  3F02  3F03  3F04  3F05  3F06  3F07
3F88     3F08  3F09  3F0A  3F0B  3F0C  3F0D  3F0E  3F0F
3F90     3F10  3F11  3F12  3F13  3F14  3F15  3F16  3F17
3F98     3F18  3F19  3F1A  3F1B  3F1C  3F1D  3F1E  3F1F

Block1     0     1     2     3     4     5     6     7
3FA0     3F20  3F21  3F22  3F23  3F24  3F25  3F26  3F27
3FA8     3F28  3F29  3F2A  3F2B  3F2C  3F2D  3F2E  3F2F
3FB0     3F30  3F31  3F32  3F33  3F34  3F35  3F36  3F37
3FB8     3F38  3F39  3F3A  3F3B  3F3C  3F3D  3F3E  3F3F

Block2     0     1     2     3     4     5     6     7
3FC0     3F40  3F41  3F42  3F43  3F44  3F45  3F46  3F47
3FC8     3F48  3F49  3F4A  3F4B  3F4C  3F4D  3F4E  3F4F
3FD0     3F50  3F51  3F52  3F53  3F54  3F55  3F56  3F57
3FD8     3F58  3F59  3F5A  3F5B  3F5C  3F5D  3F5E  3F5F

Block3     0     1     2     3     4     5     6     7
3FE0     3F60  3F61  3F62  3F63  3F64  3F65  3F66  3F67
3FE8     3F68  3F69  3F6A  3F6B  3F6C  3F6D  3F6E  3F6F
3FF0     3F70  3F71  3F72  3F73  3F74  3F75  3F76  3F77
3FF8     3F78  3F79  3F7A  3F7B  3F7C  3F7D  3F7E  3F7F</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_hefm_overview">HEFM Overview</link>,
<link linkend="_hefread">HEFRead</link>,
<link linkend="_hefreadword">HEFReadWord</link>,
<link linkend="_hefwrite">HEFWrite</link>,
<link linkend="_hefwriteword">HEFWriteWord</link>,
<link linkend="_hefreadblock">HEFReadBlock</link>,
<link linkend="_hefwriteblock">HEFWriteBlock</link>,
<link linkend="_heferaseblock">HEFEraseBlock</link></simpara>
</section>
<section xml:id="_hefwriteword">
<title>HEFWriteWord</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HEFWriteWord ( location, data_word_value )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with HEFM memory</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
HEFWriteWord is used to write information, word values, to HEFM, so that it can be accessed in a user program via the HEFReadWord command.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>location</literal> presents the location or relative address to write write. A data Word requires 2 HEF Locations, therefore the location will range from 0 to 126 in steps of 2.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>data</literal> is the data that is to be written to the HEFM location.&#160;&#160;&#160;This can be a word value or a word variable.
<?asciidoc-br?>
<?asciidoc-br?>
This method writes information to the HEFM given the specific location in the HEFM data storage .
This method is similar to the methods for EEPROM but this method supports Word values.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial

    'The following example stores a word value in HEFM location 0

    HEFWrite( 0, 0x1234)</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial

    'This example will write two word values to two specific locations.
    HEFWriteWord (16, 0xAA01)
    HEFWriteWord (18, 0xBB02)</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
If example 2 were displayed on a serial terminal.&#160;&#160;&#160;The result would show, where <literal>--</literal> is the existing value.</simpara>
<screen>    Block0
    3F00   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    3F10   01 AA 02 BB -- -- -- -- -- -- -- -- -- -- -- --
    3F20   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    3F30   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_hefm_overview">HEFM Overview</link>,
<link linkend="_hefread">HEFRead</link>,
<link linkend="_hefreadword">HEFReadWord</link>,
<link linkend="_hefwrite">HEFWrite</link>,
<link linkend="_hefwriteword">HEFWriteWord</link>,
<link linkend="_hefreadblock">HEFReadBlock</link>,
<link linkend="_hefwriteblock">HEFWriteBlock</link>,
<link linkend="_heferaseblock">HEFEraseBlock</link></simpara>
</section>
<section xml:id="_hefreadblock">
<title>HEFReadBlock</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HEFReadBlock ( block_number,  buffer(), [, num_bytes] )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with HEFM memory.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
HEFReadBlock is used to read information from the HEFM data storage into the buffer.&#160;&#160;&#160;
Once the buffer is populated it can be accessed for use within a user program.
<?asciidoc-br?>
<?asciidoc-br?>
The parameters are as follows:
<?asciidoc-br?>
<?asciidoc-br?>
<literal>block_number</literal> represents the block to be written to.&#160;&#160;&#160;
The block_number parameter is used to calculate the physical memory location(s) that are updated.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>buffer()</literal> represents an array or string.&#160;&#160;&#160;
The buffer will be used as the data target for the block read operation.&#160;&#160;&#160;
The  buffer is handled as a buffer of bytes values.&#160;&#160;&#160;
In most cases the buffer should be the same size as a row/block of HEFM.&#160;&#160;&#160;
For most PIC Microcontrollers this will be 32 bytes.&#160;&#160;&#160;
For PIC microcontrollers with 2KW or less of Flash Program Memory this will be 16 Bytes.&#160;&#160;&#160;
Once data is read into the buffer from HEFM, the user program must handle the data as Byte, Word or String values, as appropriate.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>num_bytes</literal> is an optional parameter, and can be used to specify number of bytes to read from HEFM, starting at the first location in the selected HEFM block.&#160;&#160;&#160;
This parameter is not normally required as the default is set to the GCBASIC constant <literal>HEF_ROWSIZE_BYTES</literal>.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial

      Dim My_Buffer(HEF_ROWSIZE_BYTES)
      Dim index as byte

      ;Write some data to Block 2
      My_Buffer = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32
      HEFWriteBlock(2, My_Buffer())

      ;Read the data back from HEFM using HEFReadBock
      HEFReadBlock( 2 , My_buffer() )

     ;Send the data to a terminal in decimal format
      index = 1
      Repeat HEF_ROWSIZE_BYTES
          Hserprint(My_Buffer(index))
          HserPrint " "
          index++
     End Repeat</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_hefm_overview">HEFM Overview</link>,
<link linkend="_hefread">HEFRead</link>,
<link linkend="_hefreadword">HEFReadWord</link>,
<link linkend="_hefwrite">HEFWrite</link>,
<link linkend="_hefwriteword">HEFWriteWord</link>,
<link linkend="_hefreadblock">HEFReadBlock</link>,
<link linkend="_hefwriteblock">HEFWriteBlock</link>,
<link linkend="_heferaseblock">HEFEraseBlock</link></simpara>
</section>
<section xml:id="_hefwriteblock">
<title>HEFWriteBlock</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HEFWriteBlock ( block_number,  buffer(), [, num_bytes] )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with HEFM memory.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
HEFWriteBlock is used to write information from a user buffer to HEFM.&#160;&#160;&#160;
Once the block is written  it can be accessed for use within a user program.
<?asciidoc-br?>
<?asciidoc-br?>
The parameters are as follows:
<?asciidoc-br?>
<?asciidoc-br?>
<literal>block_number</literal> represents the block to be written to.&#160;&#160;&#160;
The block_number parameter is used to calculate the physical memory location(s) that are updated.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>buffer()</literal> represents an array or string.&#160;&#160;&#160;
The buffer will be used as the data source that is written to the HEFM block.&#160;&#160;&#160;
The buffer is handled as a buffer of bytes values.&#160;&#160;&#160;
In most cases the buffer should be the same size as a row/block of HEFM.&#160;&#160;&#160;
For most PIC Microcontrollers this will be 32 bytes.&#160;&#160;&#160;
For PIC microcontrollers with 2KW or less of Flash Program Memory this will be 16 Bytes.&#160;&#160;&#160;
Best practice is to size the buffer using the HEF_ROWSIZE_BYTES constant.&#160;&#160;&#160;
If the size of the buffer exceeds the device specific HEF_ROWSIZE_BYTES, the excess data will not be handled and the buffer will be truncated at the HEF_ROWSIZE_BYTES limit.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
<literal>num_bytes</literal> is an optional parameter, and can be used to specify number of bytes to write to HEFM, starting at the first location in the selected HEFM block.&#160;&#160;&#160;
This parameter is not normally required as the default is set to the GCBASIC constant <literal>HEF_ROWSIZE_BYTES</literal>.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial

   Dim My_Buffer(HEF_ROWSIZE_BYTES)

   My_Buffer = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32

    'HEFwriteBlock operation!!
    HEFwriteBlock(2, My_Buffer)

    'A utility method to show the contents of HEFM.
     HEFM_Dump</screen>
<simpara>For HEFM_Dump routine,  see <link linkend="_hefread">HEFRead</link>
<?asciidoc-br?>
<?asciidoc-br?>
If example 1 were displayed on a serial terminal using HEFM_Dump.&#160;&#160;&#160;
The result would show. Note the value display at the start of block 2 @ 0x3F80.</simpara>
<screen>Block0  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F00    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F10    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F20    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F30    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF

Block1  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F40    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F50    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F60    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7F70    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF

Block2  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F80    0201  0403  0605  0807  0A09  0C0B  0E0D  100F
7F90    1211  1413  1615  1817  1A19  1C1B  1E1D  201F
7FA0    2120  2322  2524  2726  2928  2B2A  2D2C  2F2E
7FB0    3130  3332  3534  3736  3938  3B3A  3D3C  3F3E

Block3  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7FC0    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7FD0    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7FE0    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF
7FF0    FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF  FFFF</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_hefm_overview">HEFM Overview</link>,
<link linkend="_hefread">HEFRead</link>,
<link linkend="_hefreadword">HEFReadWord</link>,
<link linkend="_hefwrite">HEFWrite</link>,
<link linkend="_hefwriteword">HEFWriteWord</link>,
<link linkend="_hefreadblock">HEFReadBlock</link>,
<link linkend="_hefwriteblock">HEFWriteBlock</link>,
<link linkend="_heferaseblock">HEFEraseBlock</link></simpara>
</section>
<section xml:id="_heferaseblock">
<title>HEFEraseBlock</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HEFEraseBlock ( block_number )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with HEFM memory.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
HEFEraseBlock is used to erase all data locations within the HEFM block.&#160;&#160;&#160; HEFM data within the HEFM block to the erase state value of the device.&#160;&#160;&#160;
This Value is 0xFF and will read 0x3FFF if the entire 14bit program memory word is displayed.
Use Caution. Once the HEFM block is erased, the HEFM data is gone forever and cannot be recovered unless it was previpusly saved.
<?asciidoc-br?>
<?asciidoc-br?>
The single parameter is as follows:</simpara>
<simpara><literal>block_number</literal> represents the block to be erased.&#160;&#160;&#160;
The block_number parameter is used to calculate the physical memory location(s) that are updated.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<simpara>Erase a specific block of HEFM.</simpara>
<screen>    '... code preamble to select part
    '... code to setup serial, if needed


    'Erase block 2 of HEFM
    HEFEraseBlock ( 2)</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_hefm_overview">HEFM Overview</link>,
<link linkend="_hefread">HEFRead</link>,
<link linkend="_hefreadword">HEFReadWord</link>,
<link linkend="_hefwrite">HEFWrite</link>,
<link linkend="_hefwriteword">HEFWriteWord</link>,
<link linkend="_hefreadblock">HEFReadBlock</link>,
<link linkend="_hefwriteblock">HEFWriteBlock</link>,
<link linkend="_heferaseblock">HEFEraseBlock</link></simpara>
</section>
</section>
<section xml:id="_progmem_pfm">
<title>PROGMEM ( PFM )</title>
<simpara>This is the PROGMEM ( PFM ) section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_pfmread">
<title>PFMRead</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PFMRead (<emphasis>location, store</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC microcontrollers with PFM self write capability.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>PFMRead</literal> reads information from the program memory on chips that
support this feature. <literal><emphasis>location</emphasis></literal> is a word variable, and <literal><emphasis>store</emphasis></literal> can be a byte of word.</simpara>
<simpara>The largest value possible for <literal><emphasis>location</emphasis></literal> depends on the amount of
program memory on the Microchip PIC microcontroller.</simpara>
<simpara>This is an advanced command which should only be used by advanced
developers.</simpara>
<simpara><emphasis role="strong">For more help, see <link linkend="_pfmwrite">PFMWrite</link></emphasis></simpara>
</section>
<section xml:id="_pfmwrite">
<title>PFMWrite</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PFMWrite (<emphasis>location</emphasis>, <emphasis>value</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC microcontrollers with PFM self write capability.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>PFMWrite</literal> writes information to the program memory on chips that
support this feature. <literal><emphasis>location</emphasis></literal> is a word variable, and <literal><emphasis>store</emphasis></literal> can be a byte of word.</simpara>
<simpara>The largest value possible for <literal><emphasis>location</emphasis></literal> depends on the amount of
program memory on the microcontroller.</simpara>
<simpara>This is an advanced command which should only be used by advanced
developers.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara><emphasis role="strong">For more help, see *<link linkend="_pfmread">PFMRead</link></emphasis></simpara>
</section>
<section xml:id="_data">
<title>DATA</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>        DATA DataSetName [as Byte | Word]
            // multiples values, strings etc.
            0,1,2,3
        END DATA</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC microcontrollers with DATA memory.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The DATA construct creates an DATA dataset for use with the specific microcontroller.&#160;&#160;An DATA dataset is a list of values that are stored in the PROGMEM memory of the microcontroller, which then can be accessed using the ProgRead() command or other DATA read operations.</simpara>
<simpara>The advantage of an DATA dataset is that they are memory efficient being loaded directly into the DATA during programming operations.</simpara>
<simpara>DATA datasets are defined as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Byte or Word values,</simpara>
</listitem>
<listitem>
<simpara>Multiple numeric elements on a single line separated by commas,</simpara>
</listitem>
<listitem>
<simpara>Constants and calculations within the single line dataset entries are permitted,</simpara>
</listitem>
<listitem>
<simpara>Decimal values are NOT supported,</simpara>
</listitem>
<listitem>
<simpara>Access is via ProgRead().
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">Defining DATA datasets</emphasis></simpara>
<simpara><emphasis>Single data values</emphasis></simpara>
<simpara>A single value on each line with in the dataset.&#160;&#160;The example dataset, shown below, has the data on different line in within the set.</simpara>
<simpara>Simple example: This creates an DATA dataset at the first DATA location, then, the values of 12, 24, &#8230;&#8203; 72 are the consecutive values.</simpara>
<screen>        DATA EEDataSet as Byte
            12
            24
            36
            48
            60
            72
        End DATA</screen>
<simpara><emphasis>Multiple data values of the same line</emphasis></simpara>
<simpara>The following example creates the DATA dataset at DATA offset address of 0x10.&#160;&#160;</simpara>
<simpara>Multiple elements on a single line separated by commas.&#160;&#160;The example dataset, shown below, has the data separated by <literal>,</literal> and on different line in within the dataset.</simpara>
<screen>        DATA EEDataSource  as Byte
            12,  24, 36
            48,  60, 72
        End DATA</screen>
<simpara><emphasis>Data values as constants, and, with data transformation</emphasis></simpara>
<simpara>Constants and calculations within the single line.  &#160;&#160;The example dataset, shown below, uses a defined constant to multiple the data with the dataset.</simpara>
<screen>        #define calculation_constant 2

        DATA EEDataSource as Word
        1 * calculation_constant
        2 * calculation_constant
        3 * calculation_constant
        8 * calculation_constant
        4 * calculation_constant
        5 * calculation_constant
        End DATA</screen>
<simpara>&#160;&#160;
&#160;&#160;</simpara>
<simpara><emphasis>Data values as Strings</emphasis></simpara>
<simpara>Strings can be defined.&#160;&#160;Strings are delimited by double quotes. &#160;&#160; The following examples show the methods.</simpara>
<simpara>Any ASCII characters between any two "    " (double quotes) will be converted to dataset data.&#160;&#160; Also see ASCII escape codes.</simpara>
<simpara>A source string can be one string per line or comma separated strings, therefore, on the same line.</simpara>
<simpara>Example:</simpara>
<screen>    DATA Test_1 as Byte
     "ABCDEFGHIJ"
    End DATA</screen>
<simpara><emphasis>ASCII Escape code</emphasis></simpara>
<simpara>Accepted escape strings are shown in the dataset below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Escape sequence</entry>
<entry align="left" valign="top">Meaning</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>\a</simpara></entry>
<entry align="left" valign="top"><simpara>beep</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\b</simpara></entry>
<entry align="left" valign="top"><simpara>backspace</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\f</simpara></entry>
<entry align="left" valign="top"><simpara>formfeed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\l or \n</simpara></entry>
<entry align="left" valign="top"><simpara>newline</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\r</simpara></entry>
<entry align="left" valign="top"><simpara>carriage return</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\t</simpara></entry>
<entry align="left" valign="top"><simpara>tab</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\0</simpara></entry>
<entry align="left" valign="top"><simpara>Null value, equates to ASCII 0. Same as \&amp;000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\&amp;nnn</simpara></entry>
<entry align="left" valign="top"><simpara>ascii char in decimal</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\\</simpara></entry>
<entry align="left" valign="top"><simpara>backslash</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\"</simpara></entry>
<entry align="left" valign="top"><simpara>double quote</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>\'</simpara></entry>
<entry align="left" valign="top"><simpara>single quote</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Complete working example program</emphasis></simpara>
<simpara>This example creates several DATA datasets.&#160;&#160;The example also create a lookup table.&#160;&#160;The DATA dataset are addressed with the additional parameter to ensure there is no DATA dataset overlap.&#160;&#160;</simpara>
<screen>        #chip 16F886
        #option explicit

        #DEFINE USART_BAUD_RATE 9600
        #DEFINE USART_TX_BLOCKING
        #DEFINE USART_DELAY OFF

        Dim dataaddress, datavalue as Byte

        DATA DataSet1 as Byte
            3,2,1
        End DATA

        DATA VersionData as Byte
        "    PWM2Laser   "
        "  Fabrice ENGEL "
        "   Version 1.4  "
        "  November 2023 "
        End DATA

        For dataaddress = 0 to 2
            ProgramRead  ( @DataSet1 + dataaddress , datavalue )
            HserPrint datavalue
        Next</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_ProgramRead">ProgramRead</link>, <link linkend="_lookup_tables">Creating DATA data from a Lookup Table</link></emphasis></simpara>
</section>
<section xml:id="_programerase">
<title>ProgramErase</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ProgramErase (<emphasis>location</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC microcontrollers with self write capability. Not available on
Atmel AVR at present.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>ProgramErase</literal> erases information from the program memory on chips that
support this feature. The largest value possible for <literal><emphasis>location</emphasis></literal> depends
on the amount of program memory on the Microchip PIC microcontroller, which is given on the
datasheet.</simpara>
<simpara>This command must be called before writing to a block of memory. It is
slow in comparison to other GCBASIC commands. Note that it erases memory
in 32-byte blocks - see the relevant Microchip PIC microcontroller datasheet for more information.</simpara>
<simpara>This is an advanced command which should only be used by advanced
developers. Care must be taken with this command, as it can easily erase
the program that is running on the microcontroller.</simpara>
<simpara><emphasis role="strong">For more help, see <link linkend="_programread">ProgramRead</link></emphasis> and <emphasis role="strong"><link linkend="_programwrite">ProgramWrite</link></emphasis></simpara>
</section>
<section xml:id="_programread">
<title>ProgramRead</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ProgramRead (<emphasis>location, store</emphasis>)

    or for the 18FxxQ41 family of chips use:
    PFMRead (<emphasis>location, store</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC microcontrollers with self write capability. Not available on
Atmel AVR at present.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>ProgramRead</literal> reads information from the program memory on chips that
support this feature. <literal><emphasis>location</emphasis></literal> and <literal><emphasis>store</emphasis></literal> are both word variables,
meaning that they can store values over 255.</simpara>
<simpara>The largest value possible for <literal><emphasis>location</emphasis></literal> depends on the amount of
program memory on the Microchip PIC microcontroller, which is given on the datasheet. <literal><emphasis>store</emphasis></literal> is
14 bits wide, and thus can store values up to <literal>16383</literal>.</simpara>
<simpara>This is an advanced command which should only be used by advanced
developers.</simpara>
<simpara><emphasis role="strong">For more help, see <link linkend="_programerase">ProgramErase</link></emphasis> and <emphasis role="strong"><link linkend="_programwrite">ProgramWrite</link></emphasis></simpara>
</section>
<section xml:id="_programwrite">
<title>ProgramWrite</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ProgramWrite (<emphasis>location</emphasis>, <emphasis>value</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC microcontrollers with self write capability. Not available on
Atmel AVR at present.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>ProgramWrite</literal> writes information to the program memory on chips that
support this feature. <literal><emphasis>location</emphasis></literal> and <literal><emphasis>value</emphasis></literal> are both word variables.</simpara>
<simpara>The largest value possible for <literal><emphasis>location</emphasis></literal> depends on the amount of
program memory on the microcontroller , which is given on the datasheet. <literal><emphasis>value</emphasis></literal> is
14 bits wide, and thus can store values up to 16383.</simpara>
<simpara>This is an advanced command which should only be used by advanced
developers. ProgramErase must be used to clear a block of memory BEFORE
<literal>ProgramWrite</literal> is called.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara><emphasis role="strong">For more help, see <link linkend="_programerase">ProgramErase</link></emphasis> and <emphasis role="strong"><link linkend="_programread">ProgramRead</link></emphasis></simpara>
</section>
</section>
<section xml:id="_progmem_mcu_configuration">
<title>PROGMEM ( MCU Configuration )</title>
<simpara>This is the PROGMEM ( MCU Configuration ) section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_deviceconfigurationread">
<title>DeviceConfigurationRead</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    deviceconfigurationRead (<emphasis>location, store</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC microcontrollers with self read capability. Not available on
Atmel AVR at present.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>deviceconfigurationRead</literal> reads information from the configurations area of the  memory on chips that
support this feature. <literal><emphasis>location</emphasis></literal> and <literal><emphasis>store</emphasis></literal> are both word variables,
meaning that they can be values greater than 255.</simpara>
<simpara>The  <literal><emphasis>location</emphasis></literal> depends on the amount Microchip PIC microcontroller, which is given on the datasheet. <literal><emphasis>store</emphasis></literal> is
14 bits wide, and thus can store values up to <literal>16383</literal>.</simpara>
<simpara>This is an advanced command which should only be used by advanced developers.</simpara>
</section>
</section>
<section xml:id="_safm">
<title>SAFM</title>
<simpara>This is the SAFM section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_safm_overview">
<title>SAFM Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>Some Advanced (18F) and some Enhanced Mid-Range (16F) Microchip PIC devices support Storage Area Flash (SAF) memory. These devices also include EEPROM memory.&#160;&#160;&#160;
SAF memory is not High Endurance, meaning it does not have an endurance of 100K write cyces.&#160;&#160;&#160;
SAF has the same endurance as regular flash memmory, usually specified as 10K write cycles.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
SAF memory appears at the top of program memory space and can be used for any purpose, like regular flash program memory.&#160;&#160;&#160;
Storage Area Flash is intended to be used to store data, such a device calibration data, RF device register settings, and other data. SAFEM can be Read as frequently as necessary.&#160;&#160;&#160; However,  it is not intended to be written frequently like EEPROM. If non-volatile memory need to be written frequenily, it is best to use the EEPROM on these devices.
<?asciidoc-br?>
<?asciidoc-br?>
As with all flash memory, data must be erased before it can be written and writing this memory will stall the device for a few ms. &#160;&#160;&#160;
Methods to read, write and erase the SAF memory are included in GCBASIC and they are described in this introduction.
<?asciidoc-br?>
<?asciidoc-br?>
The <literal>hefsaf.h</literal> library supports SAF operations for GCBASIC.
<?asciidoc-br?>
<?asciidoc-br?>
Note:  By default, GCBASIC will use SAF memory for regular executable code unless it is told otherwise.&#160;&#160;&#160;
If you wish to store data here, you should reserve the SAF memory by using the compiler option, as shown below to reserve 128 Words of SAF memory:&#160;&#160;&#160;This equates to 256 bytes on PIC 18F microcontrollers and 128 Bytes on PIC 16F microcontrollers</simpara>
<screen>    #option ReserveHighProg 128</screen>
<simpara>SAF memory is a block of memory locations found at the top of the Flash program memory.&#160;&#160;&#160;
Each memory location can be used to hold a variable value, either a byte or a word dependent on the specific device.&#160;&#160;&#160;
The main difference between SAF memory and EEPROM is that EEPROM allows byte-by-byte erase whereas the SAF memory does not.&#160;&#160;&#160;
With SAF memory data must be erased before a write and the erase can only be performed in blocks of memory.&#160;&#160;&#160;
The blocks, also called rows, are a fixed size associated with the specific device.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
GCBASIC handles the erase operation automatically.&#160;&#160;&#160;
When a write operation is used by a user the GCBASIC library reads to a buffer, update the buffer, erase the block and finally write the buffer back to SAFM.&#160;&#160;&#160;
The complexity of using SAF memory is reduced with the automatically handling of these operations.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
The library provides a set of methods to support use of SAF memory.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="54*"/>
<colspec colname="col_3" colwidth="170*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Method</simpara></entry>
<entry align="left" valign="top"><simpara>Parameters</simpara></entry>
<entry align="left" valign="top"><simpara>Usage</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAFWrite</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the parameters: location, byte value</simpara></entry>
<entry align="left" valign="top"><simpara>SAFWrite ( location, byte_variable )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAFWriteWord</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the parameters: location, word_value</simpara></entry>
<entry align="left" valign="top"><simpara>SAFWriteWord ( location, word_variable  )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAFRead</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a function with the parameters: location returns a byte value</simpara></entry>
<entry align="left" valign="top"><simpara>byte_variable = SAFRead ( location  )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAFRead</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the paramers: location, byte_value</simpara></entry>
<entry align="left" valign="top"><simpara>SAFRead ( location , out_byte_variable )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAFReadWord</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a function with the parameters: location returns a word value</simpara></entry>
<entry align="left" valign="top"><simpara>word_variable = SAFRead ( location  )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAFReadWord</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the parameters: location, word_value</simpara></entry>
<entry align="left" valign="top"><simpara>SAFRead ( location , word_variable )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAFEraseBlock</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the parameters: block_number</simpara></entry>
<entry align="left" valign="top"><simpara>SAFEraseBlock ( 0 )
<?asciidoc-br?>
<?asciidoc-br?>
A value of 0,1,2,3 etc.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAFWriteBlock</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the parameters: block_number, buffer() [,num_blocks ]</simpara></entry>
<entry align="left" valign="top"><simpara>SAFWriteBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String
<?asciidoc-br?>
<?asciidoc-br?>
The Array or a String will contain the values to be wrttin to the SAFM.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAFReadBlock</literal></simpara></entry>
<entry align="left" valign="top"><simpara>a subroutine with the parameters: block_number, buffer() [, num_blocks ]</simpara></entry>
<entry align="left" valign="top"><simpara>SAFReadBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String.
<?asciidoc-br?>
<?asciidoc-br?>
The Array or a String will contain the values from the SAFM.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The library also defines a set constants that are specific to the device.&#160;&#160;&#160;
These may be useful in the user program.&#160;&#160;&#160;
These constants are used by the library.&#160;&#160;&#160;
A user may use these public constants.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="54*"/>
<colspec colname="col_3" colwidth="170*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Usage</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAF_ROWSIZE_BYTES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Byte</simpara></entry>
<entry align="left" valign="top"><simpara>Size of an SAFM block in bytes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAF_WORDS</literal> and <literal>SAF_BYTES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Word or a Byte</simpara></entry>
<entry align="left" valign="top"><simpara>ChipSAFMemWords parameter from the device .dat file</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAF_START_ADDR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Word</simpara></entry>
<entry align="left" valign="top"><simpara>Starting address of SAFM</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SAF_NUM_BLOCKS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Byte</simpara></entry>
<entry align="left" valign="top"><simpara>Number of block of SAFM</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPWORDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Word</simpara></entry>
<entry align="left" valign="top"><simpara>Device specific constant for the total flash size</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPSAFMEMWORDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Word</simpara></entry>
<entry align="left" valign="top"><simpara>Device specific constant for the number of SAFM words available</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPERASEROWSIZEWORDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Word</simpara></entry>
<entry align="left" valign="top"><simpara>Device specific constant for the number of SAFM in an erase row</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<emphasis role="strong">Warning</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
Whenever you update the hex file of your Microchip PIC micro-controller with your programmer you MAY erase the data that are stored in SAF memory.&#160;&#160;&#160;
If you want to avoid that you will have to flash your Microchip PIC micro-controller with software that allows memory exclusion when flashing.&#160;&#160;&#160;
This is the case with Microchip PIC MPLAB IPE (Go to <literal>Advanced Mode/Enter password/Select Memory/Tick “Preserve Flash on Program”/
Enter Start and End address</literal> of your SAFM).&#160;&#160;&#160;Or, simply use the PICkitPlus suite of software to preserve SAF memory during programming.
<?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_safread">SAFRead</link>,
<link linkend="_safreadword">SAFReadWord</link>,
<link linkend="_safwrite">SAFWrite</link>,
<link linkend="_safwriteword">SAFWriteWord</link>,
<link linkend="_safreadblock">SAFReadBlock</link>,
<link linkend="_safwriteblock">SAFWriteBlock</link>,
<link linkend="_saferaseblock">SAFEraseBlock</link></simpara>
</section>
<section xml:id="_safread">
<title>SAFRead</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    'as a subroutine
    SAFRead ( location, data )

    'as a function
    data = SAFRead ( location )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with SAFM memory</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
SAFRead is used to read information, byte values, from SAFM, so that it can be accessed for use in a user program.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>location</literal> represents the location or relative address to read.  The location will range from location 0 to SAF_BYTES - 1. This cab be from 0-127 or 0-255m depending upon the specific device. HEF_BYTES is a GCBASIC constant that represents the number of bytes of SAF Memory.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
<literal>data</literal> is the data that is to be read from the SAFM data storage area.&#160;&#160;&#160;
This can be a byte value or a byte variable.
<?asciidoc-br?>
<?asciidoc-br?>
This method reads data from SAFM given the specific relative location.&#160;&#160;&#160;
This method is similar to the EPRead method for EEPROM.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial
    '... code to setup PPS

    'The following example reads the SAFM data value into the byte variable “byte_value” using a subroutine.

    Dim data_byte as byte

    ;Write a byte of data to SAF Location 34
    SAFWrite( 34, 144)

    ;Read the byte back from SAF location 34
    byte_value = SAFread( 34 )

    ;Display the data on a terminal
    HserPrint "byte_value = "
    Hserprint byte_value</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial
    '... code to setup PPS

    'The following example reads the SAFM data value into the byte variable “byte_value” using a function.

    Dim data_byte as byte

    ;Write a byte of Data to SAF Location 34
    SAFWrite( 34, 144)

    ;Read the byte back from SAF location 34
    byte_value = SAFread( 34 )

    ;Display the data on a terminal
    HserPrint "byte_value = "
    Hserprint byte_value</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_safm_overview">SAFM Overview</link>,
<link linkend="_safread">SAFRead</link>,
<link linkend="_safreadword">SAFReadWord</link>,
<link linkend="_safwrite">SAFWrite</link>,
<link linkend="_safwriteword">SAFWriteWord</link>,
<link linkend="_safreadblock">SAFReadBlock</link>,
<link linkend="_safwriteblock">SAFWriteBlock</link>,
<link linkend="_saferaseblock">SAFEraseBlock</link></simpara>
</section>
<section xml:id="_safreadword">
<title>SAFReadWord</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    'as a subroutine
    SAFReadWord ( location, data_word_variable )

    'as a function
    data_word_variable = SAFReadWord ( location )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with SAFM memory</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
SAFReadWord is used to read information, word values, from SAFM so that it can be accessed for use in a user program.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>location</literal> represents the location or relative address to read. The location will range from 0 to SAF_BYTES -1.&#160;&#160;&#160;
Each data Word requires 2 SAF Locations, therefore the location will range from either 0 to 254 or 0 to 126 (in steps of 2),  depending upon the device.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>data</literal> is the word data that is to be read from the SAFM location.&#160;&#160;&#160;
This must be a word variable.
<?asciidoc-br?>
<?asciidoc-br?>
This method reads word information from SAFM given the relative location in SAFM.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial

    'The following example uses a subroutine to read an SAFM location into a word variable.

    dim data_word_variable as word

    ;Write a word to SAF location 64
    SAFWriteWord(  64, 0x1234 )

    ; Read the Word from SAF location 64
    SAFReadWord ( 64, data_word_variable  )

    HSerPrint "Value = "
    HSerPrint data_word_variable
    HSerPrintCRLF</screen>
<simpara><?asciidoc-br?>
If example 1 were displayed on a serial terminal.&#160;&#160;&#160;The result would show:</simpara>
<screen>    Value = 4660</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial

    'The following example uses a function to read an SAFM location into a word variable.

    dim data_word_variable as word

    ;Write a word to SAF location 64
    SAFWriteWord(  64, 0x4321 )

    ; Read the Word from SAF location 64
    data_word_variable = SAFReadWord ( 64 )

    HSerPrint "Value = "
    HSerPrint data_word_variable
    HSerPrintCRLF</screen>
<simpara><?asciidoc-br?>
If example 2 were displayed on a serial terminal.&#160;&#160;&#160;The result would show:</simpara>
<screen>    Value = 17185</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_safm_overview">SAFM Overview</link>,
<link linkend="_safread">SAFRead</link>,
<link linkend="_safreadword">SAFReadWord</link>,
<link linkend="_safwrite">SAFWrite</link>,
<link linkend="_safwriteword">SAFWriteWord</link>,
<link linkend="_safreadblock">SAFReadBlock</link>,
<link linkend="_safwriteblock">SAFWriteBlock</link>,
<link linkend="_saferaseblock">SAFEraseBlock</link></simpara>
</section>
<section xml:id="_safwrite">
<title>SAFWrite</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SAFWrite ( location, data )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with SAFM memory</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
SAFWrite is used to write information, byte values, to SAFM so that it can be accessed later for use in a user program.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>location</literal> represents the location or relative address to write. The location will range from location 0 to SAF_BYTES - 1, or for all practical purposes 0-255 since all PIC Microcontrollers with SAFM support 256 bytes of SAF Memory.&#160;&#160;&#160;
HEF_BYTES is a GCBASIC constant that represents the number of bytes of SAF Memory.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>data</literal> is the data that is to be written to the SAFM location.&#160;&#160;&#160;
This can be a byte value or a byte variable.
<?asciidoc-br?>
This method writes information to SAFM given the specific location.
This method is similar to the EPWrite method for EEPROM.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>     #chip 18F24K42, 16
    '... code to setup PPS
    '... code to setup serial

    'The following example writes a byte value of 126 into HEFM location 34

    SAFWrite( 34,126 )</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    #chip 18F24K42, 16
    '... code to setup PPS
    '... code to setup serial

    'This example will populate the 256 bytes of SAF memory with a value that is same as the SAFM location

     Dim Rel_Address, DataByte as Byte
     Dim NVM_Address as Long
     Dim  DataWord, as Word

    For Rel_Aaddress = 0 to 255
        SAFWrite ( Rel_Address, Rel_Address )
    Next

    SAFM_Dump
    end

    ; This subroutine displays the SAF Flash Memory on a terminal
    ; Words in reverse byte order relative to address
    sub SAFM_Dump

    Dim Blocknum as Byte
    NVM_Address  = SAF_START_ADDR
    BlockNum = 0

    Repeat SAF_WORDS    ;128
        If NVM_Address % SAF_ROWSIZE_BYTES = 0 then
           If BlockNum &gt; 0 then   HSERPRINTCRLF
           HSerprintCRLF

           HserPrint "Block"
           HSerprint BlockNum
           HSerprint "  1 0   3 2   5 4   7 6   9 8   B A   D C   F E"
           BlockNum++
        End if

        IF NVM_Address  % 16 = 0 then
           HSerPrintCRLF
           hserprint hex(NVM_Address_H)
           hserprint hex(NVM_Address)
           hserprint "    "
        end if

        Rel_Address = NVM_ADDRESS - SAF_START_ADDR
        SAFReadWord(Rel_Address,DataWord)

        hserprint hex(DataWord_H)
        hserprint hex(DataWord)
        hserprint "  "

        NVM_Address+=2 ' Next "WORD"
    End Repeat
End sub</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
If example 2 were displayed on a serial terminal.&#160;&#160;&#160;The result would show:</simpara>
<screen>Block0  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F00    0100  0302  0504  0706  0908  0B0A  0D0C  0F0E
7F10    1110  1312  1514  1716  1918  1B1A  1D1C  1F1E
7F20    2120  2322  2524  2726  2928  2B2A  2D2C  2F2E
7F30    3130  3332  3534  3736  3938  3B3A  3D3C  3F3E

Block1  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F40    4140  4342  4544  4746  4948  4B4A  4D4C  4F4E
7F50    5150  5352  5554  5756  5958  5B5A  5D5C  5F5E
7F60    6160  6362  6564  6766  6968  6B6A  6D6C  6F6E
7F70    7170  7372  7574  7776  7978  7B7A  7D7C  7F7E

Block2  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7F80    8180  8382  8584  8786  8988  8B8A  8D8C  8F8E
7F90    9190  9392  9594  9796  9998  9B9A  9D9C  9F9E
7FA0    A1A0  A3A2  A5A4  A7A6  A9A8  ABAA  ADAC  AFAE
7FB0    B1B0  B3B2  B5B4  B7B6  B9B8  BBBA  BDBC  BFBE

Block3  1 0   3 2   5 4   7 6   9 8   B A   D C   F E
7FC0    C1C0  C3C2  C5C4  C7C6  C9C8  CBCA  CDCC  CFCE
7FD0    D1D0  D3D2  D5D4  D7D6  D9D8  DBDA  DDDC  DFDE
7FE0    E1E0  E3E2  E5E4  E7E6  E9E8  EBEA  EDEC  EFEE
7FF0    F1F0  F3F2  F5F4  F7F6  F9F8  FBFA  FDFC  FFFE</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_safm_overview">SAFM Overview</link>,
<link linkend="_safread">SAFRead</link>,
<link linkend="_safreadword">SAFReadWord</link>,
<link linkend="_safwrite">SAFWrite</link>,
<link linkend="_safwriteword">SAFWriteWord</link>,
<link linkend="_safreadblock">SAFReadBlock</link>,
<link linkend="_safwriteblock">SAFWriteBlock</link>,
<link linkend="_saferaseblock">SAFEraseBlock</link></simpara>
</section>
<section xml:id="_safwriteword">
<title>SAFWriteWord</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SAFWriteWord ( location, data_word_value )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with SAFM memory</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
SAFWriteWord is used to write information, word values, to the SAFM data storage, so that it can be accessed later by a programmer on a Personal, or by the SAFRead commands.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>location</literal> presents the location or relative address to write. The location will range from 0 to SAF_BYTES -1.&#160;&#160;&#160;
Each data Word requires 2 SAF Locations, therefore the location will range from either 0 to 254 or 0 to 126 (in steps of 2),  depending upon the device.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>data</literal> is the data that is to be written to the SAFM location.&#160;&#160;&#160;This can be a word value or a word variable.
<?asciidoc-br?>
<?asciidoc-br?>
This method writes information to SAFM given the specific location in SAFM.&#160;&#160;&#160;
This method is similar to the methods for EEPROM, but supports Word values.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    '... code preamble to select part
    '... code to setup serial

    'The following example stores in the word value of 0x1234 as SAFM location 34

    SAFWriteWord( 34, 0x1234 )</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    #chip 18F24K42, 16
    '... code to setup PPS
    '... code to setup serial

    'This example will write two word values to two specific locations.

     dim Word_Variable1 as Word
     dim Word_Variable2 as Word

    ;Write the data
    SAFWriteWord (16, 0x1234)   'location 16, in this device, equates to 0x7F10
    SAFWriteWord (18, 0x4321)   'location 18, in this device, equates to 0x7F12

   ;Read the data and send to terminal
    SAFReadWord(16, Word_Variable1 )
    SAFReadWord(18, Word_Variable2 )

   HserPrint "Word_Variable1 = "
   Hserprint Word_Variable1
   HSerPrintCRLF
   HserPrint "Word_Variable2 = "
   Hserprint Word_Variable2
   HSerPrintCRLF</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
If example 2 were displayed on a serial terminal.&#160;&#160;&#160;The result would show, where <literal>----</literal> is the existing value.</simpara>
<screen>Word_Variable1 = 4660
Word_Variable2 = 17185</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_safm_overview">SAFM Overview</link>,
<link linkend="_safread">SAFRead</link>,
<link linkend="_safreadword">SAFReadWord</link>,
<link linkend="_safwrite">SAFWrite</link>,
<link linkend="_safwriteword">SAFWriteWord</link>,
<link linkend="_safreadblock">SAFReadBlock</link>,
<link linkend="_safwriteblock">SAFWriteBlock</link>,
<link linkend="_saferaseblock">SAFEraseBlock</link></simpara>
</section>
<section xml:id="_safreadblock">
<title>SAFReadBlock</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SAFReadBlock ( block_number,  buffer(), [,  num_bytes] )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with SAFM memory.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
HEFReadBlock is used to read information from the HEFM data storage into the buffer.&#160;&#160;&#160;
Once the buffer is populated it can be accessed for use within a user program.
<?asciidoc-br?>
<?asciidoc-br?>
The parameters are as follows:
<?asciidoc-br?>
<?asciidoc-br?>
<literal>block_number</literal> represents the block to be written to.&#160;&#160;&#160;
The block_number parameter is used to calculate the physical memory location(s) that are updated.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>buffer()</literal> represents an array or string.&#160;&#160;&#160;
The buffer will be used as the data target for the block read operation.&#160;&#160;&#160;
The  buffer is handled as a buffer of bytes values.&#160;&#160;&#160;
In most cases the buffer should be the same size as a row/block of SAFM.&#160;&#160;&#160;
For most PIC Microcontrollers with SAFM this will be 32 bytes.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
<literal>num_bytes</literal> is an optional parameter, and can be used to specify number of bytes to read from SAFM, starting at the first location in the selected SAFM block.&#160;&#160;&#160;
This parameter is not normally required as the default is set to the GCBASIC constant <literal>SAF_ROWSIZE_BYTES</literal>.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    #chip 18F24K42, 16
    '... code preamble to setup PPS
    '... code to setup serial

      Dim My_Buffer(HEF_ROWSIZE_BYTES)
      Dim index as byte

      ;Write some data to Block 2
      My_Buffer = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32
      SAFWriteBlock(2, My_Buffer())

      ;Read the data back from SAFM using SAFReadBock
      SAFReadBlock( 2 , My_buffer() )

     ;Send the data to a terminal in decimal format
      index = 1
      Repeat SAF_ROWSIZE_BYTES
          Hserprint(My_Buffer(index))
          HserPrint " "
          index++
     End Repeat</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_safm_overview">SAFM Overview</link>,
<link linkend="_safread">SAFRead</link>,
<link linkend="_safreadword">SAFReadWord</link>,
<link linkend="_safwrite">SAFWrite</link>,
<link linkend="_safwriteword">SAFWriteWord</link>,
<link linkend="_safreadblock">SAFReadBlock</link>,
<link linkend="_safwriteblock">SAFWriteBlock</link>,
<link linkend="_saferaseblock">SAFEraseBlock</link></simpara>
</section>
<section xml:id="_safwriteblock">
<title>SAFWriteBlock</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SAFWriteBlock ( block_number,  buffer(), [, num_bytes] )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with SAFM memory.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
SAFWriteBlock is used to write information from a user buffer to SAFM.&#160;&#160;&#160;
Once the block is written  it can be accessed for use within a user program.
<?asciidoc-br?>
<?asciidoc-br?>
The parameters are as follows:
<?asciidoc-br?>
<?asciidoc-br?>
<literal>block_number</literal> represents the block to be written to.&#160;&#160;&#160;
The block_number parameter is used to calculate the physical memory location(s) that are updated.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>buffer()</literal> represents an array or string.&#160;&#160;&#160;
The buffer will be used as the data source that is written to the SAFM block.&#160;&#160;&#160;
The buffer is handled as a buffer of bytes values.&#160;&#160;&#160;
In most cases the buffer should be the same size as a row/block of SAFM.&#160;&#160;&#160;
For most PIC Microcontrollers this will be 32 bytes.&#160;&#160;&#160;
Best practice is to size the buffer using the SAF_ROWSIZE_BYTES constant.&#160;&#160;&#160;
If the size of the buffer exceeds the device specific SAF_ROWSIZE_BYTES, the excess data will not be handled and the buffer will be truncated at the SAF_ROWSIZE_BYTES limit.&#160;&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
<literal>num_bytes</literal> is an optional parameter, and can be used to specify the number of bytes to write to HEFM, starting at the first location in the selected HEFM block.&#160;&#160;&#160;
This parameter is not normally required as the default is set to the GCBASIC constant <literal>HEF_ROWSIZE_BYTES</literal>.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    #chip 18F24K42, 16
    '... code preamble to setup PPS
    '... code to setup serial

      Dim My_Buffer(HEF_ROWSIZE_BYTES)
      Dim index as byte

      ;Write some data to Block 2
      My_Buffer = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32
      SAFWriteBlock(2, My_Buffer())

      ;Read the data back from SAFM using SAFReadBock
      SAFReadBlock( 2 , My_buffer() )

     ;Send the data to a terminal in decimal format
      index = 1
      Repeat SAF_ROWSIZE_BYTES
          Hserprint(My_Buffer(index))
          HserPrint " "
          index++
     End Repeat</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_safm_overview">SAFM Overview</link>,
<link linkend="_safread">SAFRead</link>,
<link linkend="_safreadword">SAFReadWord</link>,
<link linkend="_safwrite">SAFWrite</link>,
<link linkend="_safwriteword">SAFWriteWord</link>,
<link linkend="_safreadblock">SAFReadBlock</link>,
<link linkend="_safwriteblock">SAFWriteBlock</link>,
<link linkend="_saferaseblock">SAFEraseBlock</link></simpara>
</section>
<section xml:id="_saferaseblock">
<title>SAFEraseBlock</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SAFEraseBlock ( block_number )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all PIC micro-controllers with SAFM memory.
<emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
SAFEraseBlock is used to erase all data locations within the SAFM block.&#160;&#160;&#160; HEFM data within the HEFM block to the erase state value of the device.&#160;&#160;&#160;
This Value is 0xFF for each location and will read 0xFFFF if the program memory word is displayed.
Use Caution. Once the SAFM block is erased, the SAFEM data is gone forever and cannot be recovered unless it was previpusly saved.
<?asciidoc-br?>
<?asciidoc-br?>
The single parameter is as follows:</simpara>
<simpara><literal>block_number</literal> represents the block to be erased.&#160;&#160;&#160;
The block_number parameter is used to calculate the physical memory location(s) that are updated.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<simpara>Erase a specific block of SAFEM.</simpara>
<screen>    '... code preamble to select part
    '... code to setup PPS, if needed
    '... code to setup serial, if needed

    'Erase block 2 of HEFM
    HEFEraseBlock ( 2)</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
See also
<link linkend="_safm_overview">SAFM Overview</link>,
<link linkend="_safread">SAFRead</link>,
<link linkend="_safreadword">SAFReadWord</link>,
<link linkend="_safwrite">SAFWrite</link>,
<link linkend="_safwriteword">SAFWriteWord</link>,
<link linkend="_safreadblock">SAFReadBlock</link>,
<link linkend="_safwriteblock">SAFWriteBlock</link>,
<link linkend="_saferaseblock">SAFEraseBlock</link></simpara>
</section>
</section>
<section xml:id="_eeram_device">
<title>EERAM ( Device )</title>
<simpara>This is the EERAM section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_47xxx_eeram_devices">
<title>47xxx EERam Devices</title>
<simpara>This section covers the 47xxx EERam devices.</simpara>
<simpara>The 47xxx EERam device is a memory device is organized as 512 x 8 bits or 2,048 x 8 bits of memory and utilizes the I2C serial interface.</simpara>
<simpara>The 47xxx provides infinite read and write cycles to the SRAM while EEPROM cells provide
high-endurance nonvolatile storage of data with more than one million store cycles to EEPROM &amp; a Data retention of &gt; 200 years.</simpara>
<simpara>With an external capacitor (~10uF), SRAM data is automatically transferred to the EEPROM upon loss of power, giving the advantages of NVRAM whilst eliminating the need for backup batteries.</simpara>
<simpara>Data can also be backed up manually by using either the Hardware Store pin (HS) or software control.</simpara>
<simpara>On power-up, the EEPROM data is automatically recalled to the SRAM.   EEPROM data Recall can also be initiated through software control.</simpara>
<simpara>Connectivity is shown below:</simpara>
<screen>            __ __
    Vcap--&gt;|  U  |&lt;-- Vcc
     A1 --&gt;|     |&lt;-- HS
     A2 --&gt;|     |&lt;-&gt; SCL
    Vss --&gt;|_____|&lt;-&gt; SDA</screen>
<simpara><emphasis role="strong">Modes of Operation</emphasis></simpara>
<simpara>The SRAM allows for fast reads and writes and unlimited
endurance. As long as power is present, the data
stored in the SRAM can be updated as often as
desired.</simpara>
<simpara>To preserve the SRAM image, the AutoStore function
copies the entire SRAM image to an EEPROM array
whenever it detects that the voltage drops below a predetermined
level. The power for the AutoStore process
is provided by the externally connected VCAP capacitor.
Upon power-up, the entire memory contents are
restored by copying the EEPROM image to the SRAM.
This automatic restore operation is completed in milliseconds
after power-up, at the same time as when
other devices would be initializing.</simpara>
<simpara>There is no latency in writing to the SRAM. The SRAM
can be written to starting at any random address, and
can be written continuously throughout the array, wrapping
back to the beginning after the end is reached.
There is a small delay, specified as TWC in the data
sheet, when writing to the nonvolatile configuration bits
of the STATUS Register (SR).</simpara>
<simpara>Besides the AutoStore function, there are two other
methods to store the SRAM data to EEPROM:</simpara>
<simpara>• One method is the Hardware Store, initiated by a
rising edge on the HS pin.</simpara>
<simpara>• The other method is the Software Store, initiated
by writing the correct instruction to the
command register via I2C.</simpara>
<simpara><subscript>The_paragraph_above_is_copyright_Microchip:_AN2047</subscript><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Explanation</emphasis></simpara>
<simpara>The GCBASIC constants and commands shown below control the configuration of the 47xxx EE-RAM device. &#160;&#160;&#160;GCBASIC supports I2C hardware and software connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the 47xxx driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;47xxx_EERAM.H&gt;

    ; ----- Define Hardware settings for EERAM Module
    #define I2C_Adr_EERAM 0x30 		; EERAM base Address
    #define EERAM_HS PortB.1   		; Optional hardware Store Pin

    Dir EERAM_HS Out           		; Rising edge initiates Backup

    EERAM_AutoStore(ON) 			; Enable Automatic Storage on power loss


    'EERAM_AutoStore(OFF) 			; Disable Automatic Storage on power loss</screen>
<simpara>The device parameters for the device are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="6">
<colspec colname="col_1" colwidth="16*"/>
<colspec colname="col_2" colwidth="16*"/>
<colspec colname="col_3" colwidth="16*"/>
<colspec colname="col_4" colwidth="16*"/>
<colspec colname="col_5" colwidth="16*"/>
<colspec colname="col_6" colwidth="16*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Part Number</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Density (bits)</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">VCC Range</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Max. I2C Frequency</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Tstore Delay</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Trecall Delay</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>47L04</simpara></entry>
<entry align="left" valign="top"><simpara>4K</simpara></entry>
<entry align="left" valign="top"><simpara>2.7-3.6V</simpara></entry>
<entry align="left" valign="top"><simpara>1 MHz</simpara></entry>
<entry align="left" valign="top"><simpara>8ms</simpara></entry>
<entry align="left" valign="top"><simpara>25ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>47C04</simpara></entry>
<entry align="left" valign="top"><simpara>4K</simpara></entry>
<entry align="left" valign="top"><simpara>4.5-5.5V</simpara></entry>
<entry align="left" valign="top"><simpara>1 MHz</simpara></entry>
<entry align="left" valign="top"><simpara>8ms</simpara></entry>
<entry align="left" valign="top"><simpara>2ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>47L16</simpara></entry>
<entry align="left" valign="top"><simpara>16K</simpara></entry>
<entry align="left" valign="top"><simpara>2.7-3.6V</simpara></entry>
<entry align="left" valign="top"><simpara>1 MHz</simpara></entry>
<entry align="left" valign="top"><simpara>25ms</simpara></entry>
<entry align="left" valign="top"><simpara>5ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>47C16</simpara></entry>
<entry align="left" valign="top"><simpara>16K</simpara></entry>
<entry align="left" valign="top"><simpara>4.5-5.5V</simpara></entry>
<entry align="left" valign="top"><simpara>1 MHz</simpara></entry>
<entry align="left" valign="top"><simpara>25ms</simpara></entry>
<entry align="left" valign="top"><simpara>5ms</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control of the device are:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Context</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>EERAM_I2C_Adr</simpara></entry>
<entry align="left" valign="top"><simpara>8-bit I2C Address of device</simpara></entry>
<entry align="left" valign="top"><simpara>#define I2C_Adr_EERAM 0x30</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 0x30. This is mandated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_HS</simpara></entry>
<entry align="left" valign="top"><simpara>Optional hardware Store Pin</simpara></entry>
<entry align="left" valign="top"><simpara>#define EERAM_HS portb.1</simpara></entry>
<entry align="left" valign="top"><simpara>No default - this is not mandated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Tstore</simpara></entry>
<entry align="left" valign="top"><simpara>Delay period for write to device</simpara></entry>
<entry align="left" valign="top"><simpara>#define EERAM_Tstore 25</simpara></entry>
<entry align="left" valign="top"><simpara>25 (ms)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Trecall</simpara></entry>
<entry align="left" valign="top"><simpara>Delay period to read from device</simpara></entry>
<entry align="left" valign="top"><simpara>#define EERAM_Trecall  5</simpara></entry>
<entry align="left" valign="top"><simpara>5 (ms)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands for control of the device are:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Context</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>EERAM_AutoStore</simpara></entry>
<entry align="left" valign="top"><simpara>Enable Automatic Storage on power loss or Disable Automatic Storage on power loss</simpara></entry>
<entry align="left" valign="top"><simpara>EERAM_AutoStore(ON), or EERAM_AutoStore(OFF)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Status</simpara></entry>
<entry align="left" valign="top"><simpara>Read the Status Register</simpara></entry>
<entry align="left" valign="top"><simpara>User_byte_variable = EERAM_Status()</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Backup</simpara></entry>
<entry align="left" valign="top"><simpara>Backup / Store Now</simpara></entry>
<entry align="left" valign="top"><simpara>EERAM_Backup()</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Recall</simpara></entry>
<entry align="left" valign="top"><simpara>Restore Now</simpara></entry>
<entry align="left" valign="top"><simpara>EERAM_Recall()</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_HWStore</simpara></entry>
<entry align="left" valign="top"><simpara>Force Backup with HS Pin</simpara></entry>
<entry align="left" valign="top"><simpara>EERAM_HWStore()</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Write</simpara></entry>
<entry align="left" valign="top"><simpara>Write a Byte of Data to address at the specified address.  The address must be a word value and the data is byte value.</simpara></entry>
<entry align="left" valign="top"><simpara>ERAM_Write( EERAM_Address_word, EERAM_Data_byte)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Read</simpara></entry>
<entry align="left" valign="top"><simpara>Read a Byte of Data from address.  The address must be a word value and returned data is byte value.</simpara></entry>
<entry align="left" valign="top"><simpara>User_byte_variable = EERAM_Read(EERAM_Address_word)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This example shows how to use the device.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #CHIP 16F18855,32
    #OPTION EXPLICIT

    #INCLUDE &lt;47XXX_EERAM.H&gt;

    #startup InitPPS, 85

    Sub InitPPS
          'PPS is explicit to a specific chip.  Use PPSTool to ensure the PPS settings are correct.

          'Module: EUSART
              RC0PPS = 0x0010 'TX &gt; RC0
              TXPPS  = 0x0008 'RC0 &gt; TX (bi-directional)
          'Module: MSSP1
              SSP1DATPPS = 0x0013 'RC3 &gt; SDA1
              RC3PPS = 0x0015 'SDA1 &gt; RC3 (bi-directional)
              RC4PPS = 0x0014 'SCL1 &gt; RC4
              SSP1CLKPPS = 0x0014 'RC4 &gt; SCL1 (bi-directional)

        End Sub

    ; ----- Define Hardware Serial Print

    #DEFINE USART_BAUD_RATE 115200
    #DEFINE USART_TX_BLOCKING

    ; ----- Define Hardware settings for hwi2c

    #DEFINE HI2C_BAUD_RATE 400
    #DEFINE HI2C_DATA  PORTC.3
    #DEFINE HI2C_CLOCK PORTC.4

    'I2C pins need to be input for legacy I2C modules
    DIR HI2C_DATA  IN
    DIR HI2C_CLOCK IN

    'Initialise I2C Master
    hi2cMode Master

    ; ----- Define Hardware settings for EERAM Module

    #define EERAM_I2C_Adr 0x30      ; EERAM base Address
    #define EERAM_HS PortB.1        ; Optional hardware Store Pin

    Dir EERAM_HS Out                ; Rising edge initiates Backup

    'Library function
    EERAM_AutoStore(ON)             ; Enable Automatic Storage on power loss

    ; ----- Main body of program commences here.

    dim Idx as Byte

    HserPrintCRLF 2

    HserPrint "Hardware I2C EERAM Read Test at I2C Adr 0x"
    HserPrint  Hex(EERAM_I2C_Adr)
    HserPrint  " Reading RAM addresses 0x0 to 0xF" : HserPrintCRLF 2

    for Idx = 0x0 to 0xF

      HserPrint hex(Idx) + " = " : HserPrint Hex(EERAM_Read(Idx))
      If Idx = 7 or Idx = 0xf then
        HserPrintCRLF
      Else
        HserPrint " : "
      End if

    next

    HserPrintCRLF : HserPrint "Control Byte = " Hex(EERAM_Status()) : HserPrintCRLF 2

    wait 100 ms                     ; time for serial operations to complete
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_i2c_overview">Software I2C</link> or <link linkend="_hi2c_overview">Hardware I2C</link></simpara>
</section>
</section>
<section xml:id="_sram_device">
<title>SRAM  ( Device )</title>
<simpara>This is the SRAM section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_sram_overview">
<title>SRAM Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>Serial SRAM is a standalone volatile memory that provides an easy and inexpensive way to add more RAM to application.&#160;&#160;These are 8-pin low-power devices.&#160;&#160;
They are high-performance devices have unlimited endurance and zero write times, making them ideal for applications involving continuous data transfer, buffering, data logging, audio, video, internet, graphics and other math and data-intensive functions.&#160;&#160;</simpara>
<simpara>These devices are available from 64 Kbit up to 1 Mbit in density and support SPI, SDI and SQI™ bus modes.&#160;&#160;</simpara>
<simpara>The GCBASIC library only supports SPI bus mode.&#160;&#160;  The GCBASIC library supports hardware and software SPI - this is controlled via a constant, see below.</simpara>
<simpara>To use the SRAM libray simply include the following in your user code.&#160;&#160;</simpara>
<simpara>This will initialise the driver.&#160;&#160;</simpara>
<screen>    #define SPISRAM_CS      Porta.2      'Also known as SS, or Slave Select
    #define SPISRAM_SCK     Portc.3      'Also known as CLK
    #define SPISRAM_DO      Portc.5      'Also known as MOSI
    #define SPISRAM_DI      Portc.4      'Also known as MISO

    #define SPISRAM_HARDWARESPI
    #define SPISRAM_TYPE     SRAM_23LC1024</screen>
<simpara>SRAM memory operations.&#160;&#160;&#160;</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The library exposes a set of method to support use of SRAM memory.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="37*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="187*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Method</simpara></entry>
<entry align="left" valign="top"><simpara>Parameters</simpara></entry>
<entry align="left" valign="top"><simpara>Usage</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SRAMWrite</simpara></entry>
<entry align="left" valign="top"><simpara>eepAddr as long, eepromVal as byte</simpara></entry>
<entry align="left" valign="top"><simpara>A subroutine that required the address and the value to be written to SRAM.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SRAMRead</simpara></entry>
<entry align="left" valign="top"><simpara>eepAddr as long, eepromVal as byte</simpara></entry>
<entry align="left" valign="top"><simpara>A subroutine that required the address and variable to updated with the byte value from the specified SRAM address.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SRAMRead</simpara></entry>
<entry align="left" valign="top"><simpara>eepAddr as long</simpara></entry>
<entry align="left" valign="top"><simpara>A function that required the address. The function returns a byte value from the specified SRAM address.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The library requires a set of constants to support use of SRAM memory.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="54*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="170*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Parameters</simpara></entry>
<entry align="left" valign="top"><simpara>Usage</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPISRAM_TYPE</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the type of SRAM.</simpara></entry>
<entry align="left" valign="top"><simpara>Requires one of the following constants
</simpara><simpara>SRAM_23LC1024,<?asciidoc-br?>
SRAM_23LCV1024,<?asciidoc-br?>
SRAM_23LC1024,<?asciidoc-br?>
SRAM_23A1024,<?asciidoc-br?>
SRAM_23LCV512,<?asciidoc-br?>
SRAM_23LC512, <?asciidoc-br?>
SRAM_23A512, <?asciidoc-br?>
SRAM_23K256, <?asciidoc-br?>
SRAM_23A256, <?asciidoc-br?>
SRAM_23A640, or <?asciidoc-br?>
SRAM_23K640</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPISRAM_CS</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the port for the chip select port.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPISRAM_SCK</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the port for the SPI clock port.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPISRAM_DO</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the port for the SPI data out, or MOSI, port.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPISRAM_DI</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the port for the data in, or MISO, port.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWSPIMode</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the speed of the SPI communications for Hardware SPI only.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional defaults to MASTERFAST.
</simpara><simpara>Options are MASTERSLOW,<?asciidoc-br?>
MASTER,<?asciidoc-br?>
MASTERFAST, or<?asciidoc-br?>
MASTERULTRAFAST for specific AVRs only.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPISRAM_HARDWARESPI</simpara></entry>
<entry align="left" valign="top"><simpara>Instructs the library to use hardware SPI, remove or comment out if you want to use software SPI.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The library also exposes a constant that is specific to the device.&#160;&#160;&#160;</simpara>
<simpara>These may be useful in the user program.&#160;&#160;&#160;</simpara>
<simpara>This constant is used by the library.&#160;&#160;&#160;</simpara>
<simpara>A user may use this public constant.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="41*"/>
<colspec colname="col_2" colwidth="85*"/>
<colspec colname="col_3" colwidth="211*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Usage</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPISRAM_CAPACITY</simpara></entry>
<entry align="left" valign="top"><simpara>Long value</simpara></entry>
<entry align="left" valign="top"><simpara>Use to determine the size of the SRAM device</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Examples</emphasis></simpara>
<screen>    #include &lt;uno_mega328p.h&gt;
    #option explicit

   ' USART settings
    #define USART_BAUD_RATE 57600
    #define USART_DELAY 0 ms
    #define USART_BLOCKING
    #define USART_TX_BLOCKING


    'SD card attached to SPI bus as follows:
    '
    'UNO:    MOSI - pin 11, MISO - pin 12, CLK - pin 13, CS - pin 4 (CS pin can be changed) and pin #10 (SS) must be an output
    'Mega:   MOSI - pin 51, MISO - pin 50, CLK - pin 52, CS - pin 4 (CS pin can be changed) and pin #52 (SS) must be an output
    'Leonardo: Connect to hardware SPI via the ICSP header

    #define SPISRAM_CS      DIGITAL_5     'Also known as SS, or Slave Select
    #define SPISRAM_SCK      DIGITAL_13    'Also known as CLK
    #define SPISRAM_DO      DIGITAL_11    'Also known as MOSI
    #define SPISRAM_DI      DIGITAL_12    'Also known as MISO

    #define SPISRAM_HARDWARESPI
    #define SPISRAM_TYPE     SRAM_23LC1024

    #define HWSPIMode MASTERULTRAFAST       'MASTERSLOW | MASTER | MASTERFAST | MASTERULTRAFAST for specific AVRs only. Defaults to MASTERFAST


  '********************************************************************************

  'Main program

    'Wait 2 seconds to open the serial terminal
    wait 2 s

    HSerPrintCRLF 2
    HSerPrint "Writing..."
    HSerPrintCRLF
    For SRAM_location=0 to SPISRAM_CAPACITY - 1
     SRAMWrite ( [long]SRAM_location, SRAM_location and 255 )
    Next


    dim spirambyteread as Byte
    spirambyteread = 11
    HSerPrintCRLF 2
    dim SRAM_location as long
    HSerPrint "Reading..."
    HSerPrintCRLF
    For SRAM_location=0 to SPISRAM_CAPACITY - 1
     'choose one....
     'SRAMread ( SRAM_location, spirambyteread )
    'or, as a function
     spirambyteread = SRAMread ( SRAM_location )

     if spirambyteread = ( SRAM_location and 255 ) then
       HSerPrint hex(spirambyteread)
     else
       HSerPrint "**"
     end if
     HSerPrint ":"
    Next
    HSerPrintCRLF
    HSerPrint "Wait..."
    HSerPrintCRLF
    Wait 2 s

    HSerPrint "Rewriting to 0x00 ..."
    HSerPrintCRLF
    For SRAM_location=0 to SPISRAM_CAPACITY - 1
     SRAMWrite ( [long]SRAM_location, 0 )
    Next

    Dim errorcount as long
    errorcount = 0
    For SRAM_location=0 to SPISRAM_CAPACITY - 1
     SRAMRead ( SRAM_location, spirambyteread )
     if spirambyteread &lt;&gt; 0 then
       errorcount++
     end if
    Next
    HSerPrint "Error Count (should be 0) = "
    HSerPrint errorcount
    HSerPrintCRLF
    HSerPrint "End..."
    HSerPrintCRLF
    end</screen>
<simpara>or, for a PIC with PPS</simpara>
<screen>    'Chip Settings.
   #chip 18F47k42, 64
   #config MCLRE = ON
   #option explicit


   'PPS Tool version: 0.0.5.27
   'PinManager data: v1.78
   'Generated for 18F47K42
   '
   'Template comment at the start of the config file
   '
   #startup InitPPS, 85
   #define PPSToolPart 18F47K42

   Sub InitPPS
      'This has been added to turn off PPS SPI when in SPI software mode
       #ifdef SPISRAM_HARDWARESPI
         'Module: SPI1
         RC3PPS = 0x001E  'SCK1 &gt; RC3
         SPI1SCKPPS = 0x0013  'RC3 &gt; SCK1 (bi-directional)
         RC5PPS = 0x001F  'SDO1 &gt; RC5
         SPI1SDIPPS = 0x0014  'RC4 &gt; SDI1
         'Module: UART pin directions
       #endif
       'Module: UART pin directions
       Dir PORTC.6 Out  ' Make TX1 pin an output
       'Module: UART1
       RC6PPS = 0x0013  'TX1 &gt; RC6
   End Sub
   'Template comment at the end of the config file


   ' USART settings
   #define USART_BAUD_RATE 57600
   #define USART_DELAY 0 ms
   #define USART_BLOCKING
   #define USART_TX_BLOCKING

   #define SPISRAM_CS      Porta.2      'Also known as SS, or Slave Select
   #define SPISRAM_SCK      Portc.3      'Also known as CLK
   #define SPISRAM_DO      Portc.5      'Also known as MOSI
   #define SPISRAM_DI      Portc.4      'Also known as MISO

   #define SPISRAM_HARDWARESPI
   #define SPISRAM_TYPE     SRAM_23LC1024

   '********************************************************************************

   'Main program

   'Wait 2 seconds to open the serial terminal
   wait 2 s
   dim sizeofSPIRAM as long
   sizeofSPIRAM = SPISRAM_CAPACITY
   HSerPrintCRLF 2
   HSerPrint "Writing...SPISRAM_CAPACITY = 0x"
   HSerPrint hex(sizeofSPIRAM_U)
   HSerPrint hex(sizeofSPIRAM_H)
   HSerPrint hex(sizeofSPIRAM)
   HSerPrintCRLF
   wait 100 ms

   dim SRAM_location as long
   For SRAM_location=0 to SPISRAM_CAPACITY - 1
    SRAMWrite ( [long]SRAM_location, SRAM_location and 255 )
   Next


   dim spirambyteread as Byte
   spirambyteread = 11 'could be any number....
   HSerPrintCRLF 2

   HSerPrint "Reading..."
   HSerPrintCRLF
   For SRAM_location=0 to SPISRAM_CAPACITY - 1
    'choose one....
    'SRAMRead ( SRAM_location, spirambyteread )
   'or, as a function
    spirambyteread = SRAMRead ( SRAM_location )

    if spirambyteread = ( SRAM_location and 255 ) then
      HSerPrint hex(spirambyteread)
    else
      HSerPrint "**"
    end if
    HSerPrint ":"
   Next
   HSerPrintCRLF
   HSerPrint "Wait..."
   HSerPrintCRLF
   Wait 2 s

   HSerPrint "Rewriting to 0x00 ..."
   HSerPrintCRLF
   For SRAM_location=0 to SPISRAM_CAPACITY - 1
    SRAMWrite ( [long]SRAM_location, 0 )
   Next

   Dim errorcount as long
   errorcount = 0
   For SRAM_location=0 to SPISRAM_CAPACITY - 1
    SRAMRead ( SRAM_location, spirambyteread )
    if spirambyteread &lt;&gt; 0 then
      errorcount++
    end if
   Next
   HSerPrint "Error Count (should be 0) = "
   HSerPrint errorcount
   HSerPrintCRLF
   HSerPrint "End..."
   HSerPrintCRLF

   do

   loop</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_sramread">SRAMRead</link> or <link linkend="_sramwrite">SRAMWrite</link></emphasis></simpara>
</section>
<section xml:id="_sramread">
<title>SRAMRead</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SRAMRead <emphasis>location, store</emphasis>

    or

    <emphasis>store = SRAMRead location</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC and Atmel AVR microcontrollers with SRAM data memory attached.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>SRAMRead</literal> is the method, a function or a subroutine, used to read information from the SRAM data storage.</simpara>
<simpara><literal><emphasis>location</emphasis></literal> represents the location to read data from.</simpara>
<simpara><literal><emphasis>store</emphasis></literal> is the variable in which to store the data after it has been read from SRAM.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;uno_mega328p.h&gt;
    #option explicit

    'Set up SRAM
    #define SPISRAM_CS      DIGITAL_5     'Also known as SS, or Slave Select
    #define SPISRAM_SCK     DIGITAL_13    'Also known as CLK
    #define SPISRAM_DO      DIGITAL_11    'Also known as MOSI
    #define SPISRAM_DI      DIGITAL_12    'Also known as MISO

    #define SPISRAM_HARDWARESPI
    #define SPISRAM_TYPE     SRAM_23LC1024

  '********************************************************************************

  'Main program

  dim in_byte as byte

  'Using a function:  Read from SRAM location 0x10 and place the results in the variable in_byte
  in_byte = SRAMRead ( 0x10 )

  'Using a subroutine:  Read from SRAM location 0x10 and place the results in the variable in_byte
  SRAMRead ( 0x10, in_byte )</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_sram_overview">SRAM Overview</link> or <link linkend="_sramwrite">SRAMWrite</link></emphasis></simpara>
</section>
<section xml:id="_sramwrite">
<title>SRAMWrite</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SRAMWrite <emphasis>location</emphasis>, <emphasis>data</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC and Atmel AVR microcontrollers with SRAM data memory attached.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>SRAMWrite</literal> is the method used to write information to the SRAM data storage, so that
it can be accessed by the <literal>SRAMRead</literal> command.</simpara>
<simpara><literal><emphasis>location</emphasis></literal> represents the location to read data from, and this location will vary
from one application/solution to another.</simpara>
<simpara><literal><emphasis>data</emphasis></literal> is the data that is to be written to the SRAM, a byte value or a byte variable.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;uno_mega328p.h&gt;
    #option explicit

    'Set up SRAM
    #define SPISRAM_CS      DIGITAL_5     'Also known as SS, or Slave Select
    #define SPISRAM_SCK     DIGITAL_13    'Also known as CLK
    #define SPISRAM_DO      DIGITAL_11    'Also known as MOSI
    #define SPISRAM_DI      DIGITAL_12    'Also known as MISO

    #define SPISRAM_HARDWARESPI
    #define SPISRAM_TYPE     SRAM_23LC1024

  '********************************************************************************

  'Main program

  dim out_byte as byte

  'A subroutine:  Weite to SRAM location 0x10 and the variable out_byte
  SRAMRead ( 0x10, out_byte )</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_sram_overview">SRAMOverview</link> or <link linkend="_sramread">SRAMRead</link></emphasis></simpara>
</section>
</section>
</section>
<section xml:id="_flow_control">
<title>Flow control</title>
<simpara>This is the Flow control section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_do">
<title>Do</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Do [{While | Until} <emphasis>condition</emphasis>]
    ...
    <emphasis>program code</emphasis>
    ...
    <emphasis>&lt;condition&gt;</emphasis> Exit Do
    ...
    Loop [{While | Until} <emphasis>condition</emphasis>]</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Do</literal> command will cause the code between the <literal>Do</literal> and the <literal>Loop</literal> to run
repeatedly while <literal><emphasis>condition</emphasis></literal> is true or until <literal><emphasis>condition</emphasis></literal> is true,
depending on whether <literal>While</literal> or <literal>Until</literal> has been specified.</simpara>
<simpara>Note that the <literal>While</literal> or <literal>Until</literal> and the condition can only be specified
once, or not at all. If they are not specified, then the code will
repeat endlessly.</simpara>
<simpara>Optionally, you can specify a condition to <literal>EXIT</literal> the <literal>Do-Loop</literal> immediately.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This code will flash a light until the button is pressed
    #chip 12F629, 4

    #define BUTTON GPIO.3
    #define LIGHT GPIO.5

    Dir BUTTON In
    Dir LIGHT Out

    Do Until BUTTON = 1
      PulseOut LIGHT, 1 s
      Wait 1 s
    Loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<simpara>This code will also flash a light until the button is pressed. This
example uses <literal>EXIT DO</literal> within a continuous loop.</simpara>
<screen>    #chip 12F629, 4

    #define BUTTON GPIO.3
    #define LIGHT GPIO.5

    Dir BUTTON In
    Dir LIGHT Out

    Do
      PulseOut LIGHT, 1 s
      Wait 1 s
      if BUTTON = 1 then EXIT DO
    Loop</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_conditions">Conditions</link></emphasis></simpara>
</section>
<section xml:id="_end">
<title>End</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    End</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>When the <literal>End</literal> command is used, the program will immediately stop running.
There are very few cases where this command is needed - generally, the
program should be an endless loop.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will turn on the red light, but not the green light
    Set RED On
    End
    Set GREEN On</screen>
</section>
<section xml:id="_exit">
<title>Exit</title>
<simpara><emphasis role="strong">Syntax options:</emphasis></simpara>
<screen>    Exit Sub | Exit Function | Exit Do | Exit For | Exit Repeat</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will make the program exit the routine it is currently in,
as it would if it came to the end of the routine.</simpara>
<simpara>Applies to Subroutines, Functions, For-Next loops, Do-Loop loops and
Repeat loops.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip tiny13, 1

    #define SENSOR PORTB.0
    #define BUZZER PORTB.1
    #define LIGHT PORTB.2
    Dir SENSOR In
    Dir BUZZER Out
    Dir LIGHT Out

    Do
      Burglar
    Loop

    'Burglar Alarm subroutine
    Sub Burglar
      If SENSOR = 0 Then
        Set BUZZER Off
        Set LIGHT Off
        Exit Sub
      End If
      Set BUZZER On
      Set LIGHT On
    End Sub</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_do">Do</link>, <link linkend="_for">For</link>, <link linkend="_subroutines">Sub</link>,
<link linkend="_functions">Functions</link></emphasis> and <emphasis role="strong"><link linkend="_repeat">Repeat</link></emphasis></simpara>
</section>
<section xml:id="_for">
<title>For</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    For <emphasis>counter</emphasis> = <emphasis>start</emphasis> To <emphasis>end</emphasis> [Step <emphasis>increment</emphasis>]
    ...
    <emphasis>program code</emphasis>
    ...
    &lt;<emphasis>condition</emphasis>&gt; Exit For
    ...
    Next</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The For command is ideal for situations where a piece of code needs to
be run a set number of times, and where it is necessary to keep track of
how many times the code has run. When the For command is first executed,
<literal><emphasis>counter</emphasis></literal> is set to <literal><emphasis>start</emphasis></literal>. Then, each successive time the program
loops, <literal><emphasis>increment</emphasis></literal> is added to <literal><emphasis>counter</emphasis></literal>, until <literal><emphasis>counter</emphasis></literal> is equal to
<literal><emphasis>end</emphasis></literal>. Then, the program continues beyond the Next.</simpara>
<simpara><literal><emphasis>Step</emphasis></literal> and <literal><emphasis>increment</emphasis></literal> are optionals. If Step is not specified, GCBASIC
will increment <literal><emphasis>counter</emphasis></literal> by 1 each time the code is run.</simpara>
<simpara>Step is an integer value.&#160;&#160;Step value can positive of negative.&#160;&#160;When using advanced variable you must cast the step value as an integer, see the example below.</simpara>
<simpara><literal><emphasis>increment</emphasis></literal> can be a positive or negative constant or an integer.</simpara>
<simpara>The <literal>Exit For</literal> is optional and can be used to exit the loop upon a specific
condition.</simpara>
<warning>
<simpara><literal>#define USELEGACYFORNEXT</literal> to enable legacy FOR-NEXT support.&#160;&#160;
The GCBASIC compiler was revised in 2021 to improve the handling of the FOR-NEXT support.&#160;&#160;
You can revert to the legacy FOR-NEXT support by using <literal>#DEFINE USELEGACYFORNEXT</literal> but using this legacy support will cause your program to operate incorrectly. &#160;&#160;
The use of <literal>#DEFINE USELEGACYFORNEXT</literal> is NOT recommended.</simpara>
</warning>
<simpara><emphasis role="strong">Examples.</emphasis></simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This code will flash a green light 6 times.

    #chip 16F88, 8

    #define LED PORTB.0
    Dir LED Out

    For LoopCounter = 1 to 6

      PulseOut Led, 1 s
      Wait 1 s

    Next</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>'This code will flash alternate LEDS until the switch is pressed.

    #chip 16F88, 8

    #define LED1 PORTB.0
    Dir LED1 Out
    #define LED2 PORTB.2
    Dir LED2 Out

    #define SWITCH1 PORTA.0
    Dir SWITCH1 In
    main:
    PulseOut LED1, 1 s
    For LoopCounterOut = 1 to 250

      PulseOut LED2, 4 Ms
      if switch = On then Exit For

    Next
    Set LED2 OFF
    goto main</screen>
<simpara><emphasis role="strong">Example 3:</emphasis></simpara>
<simpara>This example show casting the step value as an integer.&#160;&#160;The step value in this example is the integer value of 2.</simpara>
<screen>    #script
        // Create a constant
        Pi = 22/7
    #endscript

    Dim myCircumference, myRadius as Single
    Dim myDiameter as Single Alias myCircumference_E, myCircumference_U, myCircumference_H, myCircumference

    HserPrintCRLF

    For MyRadius = 0.5 to 10.5 step [integer]2
        myCircumference=myRadius * Pi * 2
        HSerPrint "myRadius = " + ltrim(SingleToString(myRadius))
        HSerPrintStringCRLF " myCircumference = " + ltrim(SingleToString(myCircumference))
    next</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_repeat">Repeat</link></emphasis></simpara>
</section>
<section xml:id="_gosub">
<title>Gosub</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Gosub <emphasis>label</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Gosub</literal> command is used to jump to a label as a subroutine, in a
similar way to <literal>Goto</literal>. The difference is that <literal>Return</literal> can then be used to
return to the line of code after the <literal>Goto</literal>.</simpara>
<simpara><emphasis role="strong">NOTE</emphasis></simpara>
<simpara><literal>Gosub</literal> should NOT be used if it can be avoided. It is not
required to call a subroutine that has been defined using
<link linkend="_subroutines">Sub</link>, just write the name of the subroutine.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will flash an LED on portb bit 0 and play a beep on
    'porta bit 4. until the microcontroller is turned off.

    #chip 16F628A, 4 'Change this to suit your circuit

    #define SOUNDOUT PORTA.4
    #define LIGHT PORTB.0
    Dir LIGHT Out

    Do
    	'Flash Light
    	PulseOut LIGHT, 1 s
    	Wait 1 s
    	'Beep
    	Gosub PlayBeep
    Loop

    PlayBeep:
    Tone 200, 10
    Tone 100, 10
    Return</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_goto">Goto</link></emphasis> and <emphasis role="strong"><link linkend="_labels">Labels</link></emphasis></simpara>
</section>
<section xml:id="_goto">
<title>Goto</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Goto <emphasis>label</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Goto</literal> command will make the microcontroller jump to the line specified, and
continue running the program from there. The <literal>Goto</literal> command is mainly
useful for exiting out of loops - if you need to create an infinite
loop, use the <literal>Do</literal> command instead.</simpara>
<simpara>Be careful how you use <literal>Goto</literal>. If used too much, it can make programs very
hard to read.</simpara>
<simpara>To define a label, put the name of the label alone on a line, with just
a colon (:) after it.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will flash the light until the button is pressed
    'off. Notice the label named SWITCH_OFF.

    #chip 16F628A, 4 'Change this line to suit your circuit

    #define BUTTON PORTB.0
    #define LIGHT PORTB.1
    Dir BUTTON In
    Dir LIGHT Out

    Do
    	PulseOut LIGHT, 500 ms
    	If BUTTON = 1 Then Goto SWITCH_OFF
    	Wait 500 ms
    	If BUTTON = 1 Then Goto SWITCH_OFF
    Loop

    SWITCH_OFF:
    Set LIGHT Off
    'Chip will enter low power mode when program ends</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_gosub">Gosub</link></emphasis> and <emphasis role="strong"><link linkend="_labels">Labels</link></emphasis></simpara>
</section>
<section xml:id="_if">
<title>If</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen><emphasis role="strong"><emphasis>Short form:</emphasis></emphasis>

    If <emphasis>condition</emphasis> Then <emphasis>command</emphasis>

<emphasis role="strong"><emphasis>Long form:</emphasis></emphasis>

    If <emphasis>condition</emphasis> Then
    ...
    <emphasis>program code</emphasis>
    ...
    End If

<emphasis role="strong"><emphasis>Using Else:</emphasis></emphasis>

    If <emphasis>condition</emphasis> Then
      <emphasis>code to run if true</emphasis>
    Else
      <emphasis>code to run if false</emphasis>
    End If

<emphasis role="strong"><emphasis>Using If Else:</emphasis></emphasis>

    If <emphasis>condition</emphasis> Then
      <emphasis>code to run if true</emphasis>
    Else if <emphasis>nextcondition</emphasis> then
      <emphasis>code to run if nextcondition true</emphasis>
    Else
      <emphasis>code to run if false</emphasis>
    End If</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>If</literal> command is the most common command used to make decisions. If
<literal><emphasis>condition</emphasis></literal> is <literal>true</literal>, then <literal><emphasis>command</emphasis></literal> (short) or <literal><emphasis>program code</emphasis></literal> (long)
will be run. If it is <literal>false</literal>, then the microcontroller will skip to the code
located on the next line (short) or after the <literal>End If</literal> (long form).</simpara>
<simpara>If <literal>Else</literal> is used, then the condition between <literal>If</literal> and <literal>Else</literal> will run if the
condition is <literal>true</literal>, and the code between <literal>Else</literal> and <literal>End If</literal> will run if the
condition is <literal>false</literal>.</simpara>
<simpara>If <literal>Else if</literal> is used, then the condition after the  <literal>Else if</literal> will run if the
condition is <literal>true</literal>.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
<literal>Else</literal> must be on a separate line in the source code.</simpara>
<simpara>Supported:</simpara>
<screen>    &lt;instruction&gt; 'is supported
    Else
    &lt;instruction&gt;</screen>
<screen>    &lt;instruction&gt; Else 'Not Supported, but will compile
    &lt;instruction&gt;</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Turn a light on or off depending on a light sensor

    #chip 12F683, 8

    #define LIGHT GPIO.1
    #define SENSOR AN3
    #define SENSOR_PORT GPIO.4

    Dir LIGHT Out
    Dir SENSOR_PORT In

    Do
      If ReadAD(SENSOR) &gt; 128 Then
        Set LIGHT Off
      Else
        Set LIGHT On
      End If
    Loop</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_conditions">Conditions</link></emphasis></simpara>
</section>
<section xml:id="_indcall">
<title>IndCall</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    IndCall <emphasis>Address</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>IndCall</literal> provides a basic implementation of function pointers. <literal><emphasis>Address</emphasis></literal>
is the program memory location of the subroutine that is to be called.
There are two ways to specify this - either by providing a direct
reference to the subroutine using the @ operator, or by specifying a
word variable that contains the address.</simpara>
<simpara>This command is useful for callbacks. For example, a particular
subroutine might read bytes from a serial connection, but different
actions may need to be taken at different times. A different subroutine
could be created for each action, and then the subroutine for the
appropriate action could be passed to the serial connection reading
routine each time it is called.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
Calling subroutines that have parameters using <literal>IndCall</literal> is not
supported. Errors may occur. If data needs to be passed, use a variable
instead.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Flash an LED using an indirect call
    #chip 12F683

    'Create a word variable, and set it to the memory location of the
    'Blink subroutine.
    Dim FlashingSub As Word
    FlashingSub = @Blink

    'Main loop
    Do
    'Indirect call to subroutine at location FlashingSub
    	IndCall FlashingSub
    Loop

    'LED flashing subroutine
    Sub Blink
    	PulseOut GPIO.0, 500 ms
    	Wait 500 ms
    End Sub</screen>
</section>
<section xml:id="_pause">
<title>Pause</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen><emphasis role="strong"><emphasis>Fixed Length Delay:</emphasis></emphasis>
    Pause time_ms</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The Pause command will cause the program to pause for a specified time in milliseconds.
The only unit of time permitted is milliseconds.</simpara>
<simpara>Please use the <literal>wait</literal> command to use other units of time.</simpara>
<simpara><emphasis role="strong">For more help, see <link linkend="_wait">Wait</link></emphasis></simpara>
</section>
<section xml:id="_repeat">
<title>Repeat</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Repeat <emphasis>times</emphasis>
    ...
    <emphasis>program code</emphasis>
    ...
    &lt;<emphasis>condition</emphasis>&gt; Exit Repeat
    ...
    End Repeat</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Repeat</literal> command is ideal for situations where a piece of code needs
to be run a set number of times. It uses less memory and runs faster
than the <literal>For</literal> command, and should be used wherever it is not necessary to
count how many times the code has run.</simpara>
<simpara>Optionally, you can specify a condition to <literal>Exit</literal> the Repeat-Loop
immediately.</simpara>
<simpara>Repeat has a maximum repeat value of 65535.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This code will flash a green light 6 times.

    #chip 16F88, 20

    #define LED PORTB.0
    dir LED out

    Repeat 6
    PulseOut LED, 1 s
    Wait 1 s
    End Repeat</screen>
<simpara><emphasis role="strong">See Also <link linkend="_for">For</link></emphasis></simpara>
</section>
<section xml:id="_select">
<title>Select</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Select Case <emphasis>var</emphasis>

    Case <emphasis>value1</emphasis>
      <emphasis>code1</emphasis>

    Case <emphasis>value2</emphasis>
      <emphasis>code2</emphasis>

    Case <emphasis>value_3 To _value4</emphasis>
      <emphasis>code3</emphasis>

    Case Else
      <emphasis>code4</emphasis>

    End Select</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The Select Case control structure is used to select and run a particular
section of code, based on the value of <literal><emphasis>var</emphasis></literal>. If <literal><emphasis>var</emphasis></literal> equals <literal><emphasis>value1</emphasis></literal>
then <literal><emphasis>code1</emphasis></literal> will be run. Once <literal><emphasis>code1</emphasis></literal> has run, the chip will jump to
the <literal>End Select</literal> command and continue running the program. If none of the
other conditions are true, then the code under the <literal>Case Else</literal> section
will be run.</simpara>
<simpara><literal>Case <emphasis>var</emphasis> TO <emphasis>var</emphasis></literal> is a range of values. If the value is within the range the code section will be executed.</simpara>
<simpara><literal>Case Else</literal> is optional, and the program will function correctly without
it.</simpara>
<simpara>If there is only one line of code after the <literal>Case</literal>, the code may look
neater if the line is placed after the <literal>Case</literal>. This is shown below in the
example, for cases 3, 4 and 5.</simpara>
<simpara>It is important to note that <emphasis role="strong">only one section of code will be run</emphasis> when
using <literal>Select Case</literal>.</simpara>
<simpara>There are two examples shown below.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'Program to read a value from a potentiometer, and display a
    'different word based on the result

      #chip 16F877a, 4

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_NO_RW
    #define LCD_Enable PORTD.2

    DIR PORTA.0 IN
    Do
      Temp = ReadAD(AN0) / 20
      CLS
      Select Case Temp
        Case 0
          Print "None!"
        Case 1
          Print "One"
        Case 2
          Print "Two"
        Case 3: Print "Three"
        Case 4: Print "Four"
        Case 5: Print "Five"
        Case Else
          Print "A lot!"
      End Select
      Wait 250 ms
    Loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<simpara>This code demonstrates how to receive codes from a handheld remote
control unit. This has been tested and supports a Sony TV remote and
also a universal remote set to Sony TV mode.</simpara>
<simpara>The program gets both the device number and the key number, and also
translates the key number to English. The received results are displayed
on an LCD.</simpara>
<simpara>The circuit for the IR receiver and the chip is shown below.</simpara>
<screen>    'A program to receive IR codes sent by a Sony
    'compatible handheld remote control.

    #chip 16F88, 8                    'PIC16F88 running at 8 MHz
    #config mclr=off                  'reset handled internally

    '----- Constants

    #define LCD_IO      4             '4-bit mode
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS      PortB.2       'pin 8 is Register Select
    #define LCD_Enable  PortB.3       'pin 9 is Enable
    #define LCD_DB4     PortB.4       'DB4 on pin 10
    #define LCD_DB5     PortB.5       'DB5 on pin 11
    #define LCD_DB6     PortB.6       'DB6 on pin 12
    #define LCD_DB7     PortB.7       'DB7 on pin 13
    #define LCD_NO_RW                 'ground RW line on LCD
    #define IR          PortA.0       'sensor on pin 17

    '----- Variables

    dim device, cmd, count, i as byte
    dim pulse(12)                     'pulse count array
    dim button as string              'ASCII for button label

    '----- Program

    dir PortA in                      'A.0 is IR input
    dir PortB out                     'B.2 - B.6 for LCD

    cls                               'clear the LCD
    print "Dev:    Cmd:"              'logo for top line
    locate 1,0
    print "Button:"                   'logo for second line

    do
      getIR, cmd                      'wait for IR signal
      printCmd                        'show device and command
      printKey                        'show key label
      wait 10 mS                      'ignore any repeats
    loop                              'repeat forever

    '----- Subroutines

    sub getIR
      tarry1:
        count = 0                     'wait for start bit
        do while IR = 0               'measure width (active low)
          wait 100 uS                 '24 X 100 uS = 2.4 mS
          count += 1
        loop
      if count &lt; 20 then goto tarry1  'less than this so wait

      for i=1 to 12                   'read/store the 12 pulses
        tarry2:
          count = 0
          do while IR = 0             'zero = 6 units = 0.6 mS
            wait 100 uS               'one = 12 units = 1.2 mS
            count += 1
          loop
        if count &lt; 4 then goto tarry2 'too small to be legit
        pulse(i) = count              'else store pulse width
      next

      cmd = 0                         'command built up here
      for i = 1 to 7                  '1st seven bits are the cmd
        cmd = cmd / 2                 'shift into place
        if pulse(i) &gt; 10 then         'longer than 10 mS
           cmd = cmd + 64             'so call it a one
        end if
      next

      device = 0                      'device number built up here
      for i=8 to 12                   'next 5 bits are device number
        device = device / 2
        if pulse(i) &gt; 10 then
           device = device + 16
        end if
      next
    end sub

    sub printCmd            'print device number
      locate 0,5
      print "   "
      locate 0,5
      print device

      locate 0,13           'print raw command number
      print "   "
      locate 0,13
      print cmd
    end sub

    sub PrintKey            'print translated button
      locate 1,9
      print "       "
      locate 1,9

      select case cmd       'translate command code
        case 0
          button = "One"
        case 1
          button = "Two"
        case 2
          button = "Three"
        case 3
          button = "Four"
        case 4
          button = "Five"
        case 5
          button = "Six"
        case 6
          button = "Seven"
        case 7
          button = "Eight"
        case 8
          button = "Nine"
        case 9
          button = "Zero"
        case 10
          button = "#####"
        case 11
          button = "Enter"
        case 12
          button = "#####"
        case 13
          button = "#####"
        case 14
          button = "#####"
        case 15
          button = "#####"
        case 16
          button = "Chan+"
        case 17
          button = "Chan-"
        case 18
          button = "Vol+"
        case 19
          button = "Vol-"
        case 20
          button = "Mute"
        case 21
          button = "Power"
        case else
          button = "     "
      end select
      print button
    end sub</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/selectb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_wait">
<title>Wait</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara><emphasis role="strong"><emphasis>Fixed Length Delay:</emphasis></emphasis></simpara>
<screen>    Wait time units</screen>
<simpara><emphasis role="strong"><emphasis>Conditional Delay:</emphasis></emphasis></simpara>
<screen>    Wait {While | Until} condition</screen>
<simpara><emphasis role="strong"><emphasis>Using a variable to specific US Delay with Warning supression:</emphasis></emphasis></simpara>
<screen>    Wait timevalue US #OVERRIDEWARNING</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Wait</literal> command will cause the program to wait for either a specified
amount of time (such as 1 second), or while/until a condition is true.</simpara>
<simpara>When using the fixed-length delay, there is a variety of units that are
available:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Unit</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Length of unit</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Delay range</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>us</simpara></entry>
<entry align="left" valign="top"><simpara>1 microsecond</simpara></entry>
<entry align="left" valign="top"><simpara>1 us - 65535 us</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10us</simpara></entry>
<entry align="left" valign="top"><simpara>10 microseconds</simpara></entry>
<entry align="left" valign="top"><simpara>10 us - 2.55 ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ms</simpara></entry>
<entry align="left" valign="top"><simpara>1 millisecond</simpara></entry>
<entry align="left" valign="top"><simpara>1 ms - 65535 ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10ms</simpara></entry>
<entry align="left" valign="top"><simpara>10 milliseconds</simpara></entry>
<entry align="left" valign="top"><simpara>10 ms - 2.55 s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>s</simpara></entry>
<entry align="left" valign="top"><simpara>1 second</simpara></entry>
<entry align="left" valign="top"><simpara>1 s - 255 s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>m</simpara></entry>
<entry align="left" valign="top"><simpara>1 minute</simpara></entry>
<entry align="left" valign="top"><simpara>1 min - 255 min</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>h</simpara></entry>
<entry align="left" valign="top"><simpara>1 hour</simpara></entry>
<entry align="left" valign="top"><simpara>1 hour - 255 hours</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>At one stage, GCBASIC variables could not hold more than 255. The <literal>10us</literal>
and <literal>10ms</literal> units were added as a way to work around this limit. There is
now no such limit (<literal>Wait 1000 ms</literal> will work for example), so these are not
really needed. However, you may see them in some older examples or
programs, and the <literal>10us</literal> units are sometimes the shortest delay that will
work accurately.</simpara>
<warning>
<simpara><emphasis role="strong">PIC Devices Only</emphasis><?asciidoc-br?>
MS Delays at Clock frequency’s below 28kHz are not supported and will silently fail.<?asciidoc-br?>
US Delays at Clock frequency’s below 250kHz are not supported and will silently fail.<?asciidoc-br?>
US Delays at lower Clock frequency’s is accurate ONLY when nn is divisible by 4. This is caused by the minimum ASM delay loop being a specific number of instructions.<?asciidoc-br?>
US Delays at lower Clock frequency’ when not divisible by 4 will silently accept the nn value and incorrect delays will be produced. + Use <literal>#OVERRIDEWARNING</literal> to supress warnings.
Delays at Clock frequency’s below 500kHz may be impacted by previous instructions; testing of actual delays is advised.<?asciidoc-br?></simpara>
</warning>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This code will wait until a button is pressed, then it will flash
    'a light every half a second and produce a 440 Hz tone.

    #chip 16F819, 8

    #define BUTTON PORTB.0
    #define SPEAKER PORTB.1
    #define LIGHT PORTB.2
    Dir BUTTON In
    Dir SPEAKER Out
    Dir LIGHT Out

    'Assumes Button switches on when pressed
    Wait Until BUTTON = 1
    Wait Until BUTTON = 0

    Do
      'Flash the light
      Set LIGHT On
      Wait 500 ms
      Set LIGHT Off

      'Produce the tone
      '440 Hz = 880 changes = tone on for 1.14 ms
      Repeat 440
        PulseOut SPEAKER, 1140 us
        Wait 114 10us 'Wait for 114 x 10 us (1.14 ms)
      End Repeat
    Loop</screen>
<simpara>To suppress warnings when using US.</simpara>
<screen>    dim timevariable as Word
    timevariable = 100 // 100 is an example value that assigns the variable.

    // Use #OVERRIDEWARNING to prevent warning messages
    wait timevariable US #OVERRIDEWARNING</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_conditions">Conditions</link></emphasis></simpara>
</section>
</section>
<section xml:id="_fixed_voltage_reference">
<title>Fixed Voltage Reference</title>
<simpara>This is the  Fixed Voltage Reference section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_fvrinitialize">
<title>FVRInitialize</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    FVRInitialize ( FVR_OFF | FVR_1x | FVR_2x | FVR_4x  )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip microcontrollers with the  Fixed Voltage Reference (FVR) module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The method is a subroutine that sets the state of the FVR.&#160;&#160;&#160;</simpara>
<simpara><literal>FVR_Off</literal>&#160;=&#160;&#160;Fixed Voltage Reference is set to OFF</simpara>
<simpara><literal>FVR_1x</literal>&#160;&#160;=&#160; Fixed Voltage Reference is set to 1.024v</simpara>
<simpara><literal>FVR_2x</literal>&#160;&#160;=&#160; Fixed Voltage Reference is set to 2.048v</simpara>
<simpara><literal>FVR_4x</literal>&#160;&#160;=&#160; Fixed Voltage Reference is set to 4.096v</simpara>
<simpara>Using the the following device&#8217;s datasheet, as a general case, &#160;&#160;&#160;<link xlink:href="http://ww1.microchip.com/downloads/en/DeviceDoc/40001419F.pdf">http://ww1.microchip.com/downloads/en/DeviceDoc/40001419F.pdf</link> &#160;&#160;&#160;that can be downloaded from the device&#8217;s page,&#160;&#160;&#160;<link xlink:href="http://www.microchip.com/wwwproducts/en/pic16f1828">http://www.microchip.com/wwwproducts/en/pic16f1828</link>
parameter AD06 in table 30-8 at page 359, and the corresponding Note 4, tell us that the Vref voltage (Vref+ minus Vref-) should not be less than 1.8V, regardless of the reference voltage used, in order for the ADC module to work within the datasheet specifications.
&#160;&#160;Also, as Vref- cannot be a negative voltage (voltages below GND) the lowest voltage on it is 0V. &#160;&#160;Then an FVR of 1.024V cannot be used as VREF+ for the ADC, but only 2.048 and 4.098 values.</simpara>
<simpara>The 1.024V FVR value exists for usage with other modules not just the ADC module.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    '// use FVR 4096 as Reference
    FVRInitialize ( FVR_4x )
    wait while FVRIsOutputReady = false
    ADVal = ReadAd(AN0)

    '// Turn off FVR
    FVRInitialize ( FVR_Off )</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_fvrisoutputready">FVRIsOutputReady</link></simpara>
</section>
<section xml:id="_fvrisoutputready">
<title>FVRIsOutputReady</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    user_var = FVRIsOutputReady()</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip microcontrollers with the  Fixed Voltage Reference (FVR) module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The method is a function that returns the state of the FVR.&#160;&#160;&#160;The returned value can be assigned to a variable to used as function.</simpara>
<simpara>The method returns 0 or 1.&#160;&#160;&#160;As follows:</simpara>
<simpara>0 = Fixed Voltage Reference output is not ready or not enabled</simpara>
<simpara>1 = Fixed Voltage Reference output is ready for use</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    '// use FVR 4096 as Reference
    FVRInitialize ( FVR_4x )
    wait while FVRIsOutputReady = false
    ADVal = ReadAd(AN0)</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_fvrinitialize">FVRInitialize</link></simpara>
</section>
</section>
<section xml:id="_interrupts">
<title>Interrupts</title>
<simpara>This is the Interrupt section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_interrupts_overview">
<title>Interrupts overview</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>Interrupts are a feature of many microcontrollers. They allow the
microcontroller to temporarily pause (interrupt) the code it is running
and then start running another piece of code when some event occurs.
Once it has dealt with the event, it will return to where it was and
continue running the program.</simpara>
<simpara>Many events can trigger an interrupt, such as a timer reaching its
limit, a serial message being received, or a special pin on the
microcontroller receiving a signal.</simpara>
<simpara><emphasis role="strong">Using Interrupts</emphasis></simpara>
<simpara>There are two ways to use interrupts in GCBASIC. The first way is to use
the On Interrupt command. This will automatically enable a given
interrupt, and run a particular subroutine when the interrupt occurs.</simpara>
<simpara>The other way to deal with interrupts is to create a subroutine called
Interrupt. GCBASIC will call this subroutine whenever an interrupt
occurs, and then your code can check the "flag" bits to determine which
interrupt has occured, and what should be done about it. If you use this
approach, then you&#8217;ll need to enable the desired interrupts manually. It
is also essential that your code clears the flag bits, or else the
interrupt routine will be called repeatedly.</simpara>
<simpara>Some combination of these two methods is also possible - the code
generated by On Interrupt with check to see if the interrupt is one it
recognises. If the interrupt is recognised, On Interrupt will deal with
it - if not, the Interrupt subroutine will be called to deal with the
interrupt.</simpara>
<simpara>The recommended way is to use On Interrupt, as it is both more efficient
and easier to set up.</simpara>
<simpara>During some sections of code, it is desirable not to have any interrupts
occur. If this is the case, then use the IntOff command to disable
interrupts at the start of the section, and IntOn to re-enable them at
the end. If any interrupt events occur while interrupts are disabled,
then they will be processed as soon as interrupts are re-enabled. If the
program does not use interrupts, IntOn and IntOff will be removed
automatically by GCBASIC.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_intoff">IntOff</link>, <link linkend="_inton">IntOn</link>,
<link linkend="_on_interrupt">On Interrupt</link></simpara>
</section>
<section xml:id="_intoff">
<title>IntOff</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    IntOff</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC and Atmel AVR microcontrollers with interrupt support. Will
be automatically removed on chips without interrupts.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>IntOff</literal> is used to disable interrupts on the microcontroller. It should
be used at the start of code which is timing-sensitive, and which would
not function correctly if paused and restarted.</simpara>
<simpara>It is essential that <literal>IntOn</literal> is used to turn interrupts on again after the
timing-sensitive code has finished running. If not, no interrupts will
be handled.</simpara>
<simpara>It is recommended that IntOff be placed before all code that is timing
sensitive, in case interrupts are implemented later.</simpara>
<simpara><literal>IntOff</literal> will be removed from the assembler if no interrupts are used.</simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_inton">IntOn</link>, <link linkend="_interrupts">Interrupts</link></simpara>
</section>
<section xml:id="_inton">
<title>IntOn</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    IntOn</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC and Atmel AVR microcontrollers with interrupt support. Will
be automatically removed on chips without interrupts.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>IntOn</literal> is used to enable interrupts on the microcontroller after <literal>IntOff</literal>
has disabled them. It should be used at the end of code which is
timing-sensitive.</simpara>
<simpara><literal>IntOn</literal> will be removed from the assembler if no interrupts are used.</simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_intoff">IntOff</link>, <link linkend="_interrupts_overview">Interrupts</link></simpara>
</section>
<section xml:id="_on_interrupt">
<title>On Interrupt</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    On Interrupt event Call handler
    On Interrupt event Ignore</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC and Atmel AVR microcontrollers with interrupt support.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>On Interrupt will add code to call the subroutine <emphasis>handler</emphasis> whenever the
interrupt <emphasis>event</emphasis> occurs. When Call is specified, GCBASIC will enable
the interrupt, and call the interrupt handler when it occurs. When
Ignore is specified, GCBASIC will disable the interrupt handler and
prevent it from being called when the event occurs. If the event occurs
while the handler is disabled, then the handler will be called as soon
as it is re-enabled. The only way to prevent this from happening is to
manually clear the flag bit for the interrupt.</simpara>
<simpara>There are many possible interrupt events that can occur, and the events
vary greatly from chip to chip. GCBASIC will display an error if a given
chip cannot support the specified event.</simpara>
<simpara>On Interrupt may require the setting or clearing of the interrupt register bit(s), and, On Interrupt may require setting of explicit enable register bits. You should always consult the device datasheet for these On Interrupt additional specific settings of register bits.  Typically, you will need define the 1) source event register bit(s) in the main program, and, 2) clear or set the register bit at the start of the of the interrupt handler subroutine.</simpara>
<simpara>GCBASIC has many demonstrations showing how to set and enable appropiate interrupt register bits to support the On Interrupt method.</simpara>
<simpara>If On Interrupt is used to handle an event, then the Interrupt()
subroutine will not be called for that event. However, it will still be
called for any events not dealt with by On Interrupt.</simpara>
<simpara><emphasis role="strong">Events:</emphasis></simpara>
<simpara>GCBASIC supports the events shown on the table below. Some events are
only implemented on a few specialised chips. Events in <phrase role="gray"><emphasis role="strong">grey</emphasis></phrase> are
supported by Microchip PIC and Atmel AVR microcontrollers, events in <phrase role="blue"><emphasis role="strong">blue</emphasis></phrase> are only supported by some
Microchip PIC microcontrollers, and events in <phrase role="red"><emphasis role="strong">red</emphasis></phrase> are only supported by Atmel AVR microcontrollers.</simpara>
<simpara>Note that GCBASIC doesn&#8217;t fully support all of the hardware which can
generate interrupts - some work may be required with various system
variables to control the unsupported peripherals.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Event Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Supported</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">ADCReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The analog/digital converter has finished a conversion</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">BatteryFail</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The battery has failed in some way. This is only implemented on the ATmega406</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANActivity</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>CAN bus activity is taking place</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANBadMessage</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>A bad CAN message has been received</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">CANError</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Some CAN error has occured</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANHighWatermark</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>CAN high watermark reached</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANRx0Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>New message present in buffer 0</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANRx1Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>New message present in buffer 1</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANRx2Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>New message present in buffer 2</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANRxReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>New message present</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">CANTransferComplete</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Transfer of data has been completed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANTx0Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Buffer 0 has been sent</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANTx1Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Buffer 1 has been sent</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANTx2Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Buffer 2 has been sent</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANTxReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Sending has completed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">CCADCAccReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>CC ADC accumulate conversion finished (ATmega406 only)</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">CCADCReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>CC ADC instantaneous conversion finished (ATmega406 only)</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">CCADCRegular</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>CC ADC regular conversion finished (ATmega406 only)</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CCP1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The CCP1 module has captured an event</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CCP2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The CCP2 module has captured an event</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CCP3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The CCP3 module has captured an event</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CCP4</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The CCP4 module has captured an event</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CCP5</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The CCP5 module has captured an event</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Comp0Change</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The output of comparator 0 has changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Comp1Change</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The output of comparator 1 has changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Comp2Change</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The output of comparator 2 has changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Crypto</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The KEELOQ module has generated an interrupt</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">EEPROMReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An EEPROM write has finished</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Ethernet</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The Ethernet module has generated an interrupt. This must be dealt within the handler.</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">ExtInt0</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 0 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">ExtInt1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 1 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">ExtInt2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 2 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">ExtInt3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 3 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">ExtInt4</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 4 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">ExtInt5</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 5 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">ExtInt6</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 6 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">ExtInt7</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 7 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">GPIOChange</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The pins on port GPIO have changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">LCDReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The LCD is about to draw a segment</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">LPWU</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The Low Power Wake Up has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">OscillatorFail</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The external oscillator has failed, and the microcontroller is running from an internal oscillator.</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange0</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT0 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT1 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT2 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT3 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange4</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT4 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange5</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT5 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange6</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT6 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange7</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT7 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">PMPReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>A Parallel Master Port read or write has finished</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">PORTChange</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The pins on ports ABCEDEF have changed.  This is generic port change interrupt.  You must inspect the source to ensure you are handlign the correct interrupt.</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">PORTAChange</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The pins on port A have changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">PORTABChange</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The pins on port A and/or B have changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">PORTBChange</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The pins on port B have changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PSC0Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The counter for Power Stage Controller 0 matches the value in a compare
register, the value of the counter has been captured, or a
synchronisation error has occurred</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PSC0EndCycle</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Power Stage Controller 0 has reached the end of its cycle</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PSC1Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The counter for Power Stage Controller 1 matches the value in a compare
register, the value of the counter has been captured, or a
synchronisation error has occurred</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PSC1EndCycle</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Power Stage Controller 1 has reached the end of its cycle</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PSC2Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The counter for Power Stage Controller 2 matches the value in a compare
register, the value of the counter has been captured, or a
synchronisation error has occurred</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PSC2EndCycle</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Power Stage Controller 2 has reached the end of its cycle</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">PSPReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>A Parallel Slave Port read or write has finished</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">PWMTimeBase</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The PWM time base matches the PWM Time Base Period register (PTPER)</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">SPIReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The SPI module has finished the previous transfer</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">SPMReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>A write to program memory by the spm instruction has finished</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">SPPReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>A SPP read or write has finished</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">SSP1Collision</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>SSP1 has detected a bus collision</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">SSP1Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The SSP/SSP1/MSSP1 module has finished sending or receiving</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">SSP2Collision</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>SSP2 has detected a bus collision</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">SSP2Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The SSP2/MSSP2 module has finished sending or receiving</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer0Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input event on the pin ICP0 has caused the value of Timer 0 to be
captured in the ICR0 register</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer0Match1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 0 matches the Timer 0 output compare register A (OCR0A)</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer0Match2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 0 matches the Timer 0 output compare register B (OCR0B)</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Timer0Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 0 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer1Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input event on the pin ICP1 has caused the value of Timer 1 to be
captured in the ICR1 register</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer1Error</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The Timer 1 Fault Protection unit has been detected by an input on the INT0
pin</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer1Match1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 1 matches the Timer 1 output compare register A (OCR1A)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer1Match2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 1 matches the Timer 1 output compare register B (OCR1B)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer1Match3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 1 matches the Timer 1 output compare register C (OCR1C)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer1Match4</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 1 matches the Timer 1 output compare register D (OCR1D)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Timer1Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 1 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer2Match</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 2 matches the Timer 2 output compare register (PR2)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer2Match1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 2 matches the Timer 2 output compare register A (OCR2A)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer2Match2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 2 matches the Timer 2 output compare register B (OCR2B)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer2Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 2 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer3Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input event on the pin ICP3 has caused the value of Timer 3 to be
captured in the ICR3 register</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer3Match1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 3 matches the Timer 3 output compare register A (OCR3A)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer3Match2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 3 matches the Timer 3 output compare register B (OCR3B)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer3Match3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 3 matches the Timer 3 output compare register C (OCR3C)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Timer3Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 3 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer4Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input event on the pin ICP4 has caused the value of Timer 4 to be
captured in the ICR4 register</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer4Match</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 4 matches the Timer 4 output compare register (PR4)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer4Match1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 4 matches the Timer 4 output compare register A (OCR4A)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer4Match2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 4 matches the Timer 4 output compare register B (OCR4B)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer4Match3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 4 matches the Timer 4 output compare register C (OCR4C)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer4Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 4 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer5CAP1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input on the CAP1 pin has caused the value of Timer 5 to be captured
in CAP1BUF</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer5CAP2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input on the CAP2 pin has caused the value of Timer 5 to be captured
in CAP2BUF</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer5CAP3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input on the CAP3 pin has caused the value of Timer 5 to be captured
in CAP3BUF</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer5Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input event on the pin ICP5 has caused the value of Timer 5 to be
captured in the ICR5 register</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer5Match1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 5 matches the Timer 5 output compare register A (OCR5A)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer5Match2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 5 matches the Timer 5 output compare register B (OCR5B)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer5Match3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 5 matches the Timer 5 output compare register C (OCR5C)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Timer5Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 5 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer6Match</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 6 matches the Timer 6 output compare register (PR6)</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer7Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 7 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer8Match</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 8 matches the Timer 8 output compare register (PR8)</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer10Match</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 10 matches the Timer 10 output compare register (PR10)</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer12Match</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 12 matches the Timer 12 output compare register (PR12)</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">TWIConnect</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The Atmel AVR has been connected to or disconnected from the TWI (I2C) bus</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">TWIReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The TWI has finished the previous transmission and is ready to send or
receive more data</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">UsartRX1Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 1 has received data</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">UsartRX2Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 2 has received data</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartRX3Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 3 has received data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartRX4Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 4 has received data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">UsartTX1Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 1 is ready to send data</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartTX1Sent</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 1 has finished sending data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">UsartTX2Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 2 is ready to send data</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartTX2Sent</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 2 has finished sending data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartTX3Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 3 is ready to send data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartTX3Sent</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 3 has finished sending data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartTX4Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 4 is ready to send data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartTX4Sent</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 4 has finished sending data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">USBEndpoint</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>A USB endpoint has generated an interrupt</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">USB</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The USB module has generated an interrupt. This must be dealt with in
the handler.</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">USIOverflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The USI counter has overflowed from 15 to 0</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">USIStart</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The USI module has detected a start condition</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">VoltageFail</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The input voltage has dropped too low</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">VoltageRegulator</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An interrupt has been generated by the voltage regulator (ATmega16HVA only)</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">WakeUp</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The Wake-Up timer has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">WDT</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An interrupt has been generated by the Watchdog Timer</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This program increments a counter every time Timer1 overflows
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    InitTimer1 Osc, PS1_1/8
    StartTimer 1
    CounterValue = 0

    Wait 100 ms
    Print "Int Test"

    On Interrupt Timer1Overflow Call IncCounter

    Do
        CLS
        Print CounterValue
        Wait 100 ms
    Loop

    Sub IncCounter
        CounterValue ++
    End Sub</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    'This example reflects the input signal on the output port.
    #chip mega328p, 16
    #option explicit

    'set out SOURCE interrupt port as an output
    dir portb.0 in

    'set/enable the mask for the specific input port
    'this is crutial - for a lot of the On Interrupt methods you will need to specify the interrupt source via a mask.bit.
    PCINT0 = 1

    'set out signal port as an output
    dir portB.5 out

    'setup the On Interrupt method
    On Interrupt PinChange0 Call TogglePin

    'maintain a loop
    do

    loop

    'handle the output signal
    'Note. The AVR automatically clears the Interrupt. Please study the datasheet for each specific microcontroller

    sub togglePin
        portb.5 =  !pinb.5
    end sub</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 3:</emphasis></simpara>
<screen>    'This example reflects the input signal on the output port from the external interrupt port.
    #Chip mega328p, 16
    #option explicit

    'Set external interrupt INTO input pin as an input
    dir portd.2 in

    'set out signal port as an output
    dir portB.5 out

    'hardware interrupt on Port D2
    INT0 = 1

    'set interrupt to a failing or rising edge
    'interrupt on falling edge
    EICRA = b'00000010'
        'or, alternatively you can set to a rising edge
    'EICRA = b'00000011'

    'set out signal port as an output
    dir portB.5 out

    'setup the On Interrupt method on external interrupt 0
    On Interrupt EXTINT0 Call togglePin

    'maintain a loop
    do

    loop

    'handle the output signal
    'Note. The AVR automatically clears the Interrupt. Please study the datasheet for each specific microcontroller

    sub togglePin
        portb.5 =  !pinb.5
    end sub</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_inittimer0">InitTimer0</link> article contains
an example of using Timer 0 and On Interrupt to generate a Pulse Width
Modulation signal to control a motor.</simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_intoff">IntOff</link>, <link linkend="_inton">IntOn</link></simpara>
</section>
<section xml:id="_on_interrupt_the_default_handler">
<title>On Interrupt: The default handler</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>GCBASIC supports a default interrupt handler in two modes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>You can define the interrupt flags and the default handler (a sub routine) will executed</simpara>
</listitem>
<listitem>
<simpara>You can define an On Interrupt  event Call handler  where the handler is executed that matches the event
and where all other define/valid events are handled by the default handler (a sub routine),
The easiest way to write an interrupt handler is to write it in GCBASIC in conjunction with the On Interrupt statement.
On Interrupt tells microcontroller to activate its internal interrupt handling and to jump to a predetermined interrupt
handler (a sub routine that has been defined) when the interrupt handler (the sub routine) has completed processing returns
to correct address in the program.  See <link linkend="_on_interrupt">On Interrupt</link>.</simpara>
</listitem>
</orderedlist>
<simpara>This method of supports the handling interrupts by enabling a default interrupt subroutine.</simpara>
<simpara><emphasis role="strong">Example 1</emphasis></simpara>
<simpara>This example shows if an event occurs the microcontroller will be program to jump to the interrupt vector and the program will not know the event type, it will simple execute the Interrupt subroutine.
This code is not intended as a meaningful solution and intended to show the functionality only.
An LED is attached to PORTB.1 via a suitable resistor.  It will light up when the Interrupt event has occurred.</simpara>
<screen>    #chip 16f877a, 4
    dir PORTB.1 out
    Set PORTB.1 Off

    'Note: there is NO On Interrupt handler
    InitTimer1 Osc, PS1_8
    SetTimer 1, 1
    StartTimer 1
    'Manually set Timer1Overflow to the overflow event
    'this will event will be handled by the Interrupt sub routine
    TMR1IE = 1
    end

    Sub Interrupt
      Set PORTB.1 On
      TMR1IF = 0
    End Sub</screen>
<simpara><emphasis role="strong">Example 2</emphasis></simpara>
<simpara>Any events that are not dealt with by On Interrupt will result in the code in the Interrupt subroutine executing.
This example shows the operation of two interrupt handlers - is not intended as a meaningful solution.</simpara>
<simpara>LEDs are attached to PORTB.1 and PORTB.2 via suitable resistors.  They will light up when the Interrupt events occur.</simpara>
<screen>    #chip 16f877a, 4
    On Interrupt Timer1Overflow call Overflowed

    dir PORTB.1 out
    Set PORTB.1 Off

    dir PORTB.2 out
    Set PORTB.2 Off

    InitTimer1 Osc, PS1_8
    SetTimer 1, 1
    StartTimer 1

    InitTimer2 PS2_16, PS2_16
    SetTimer 2, 255
    StartTimer 2

    'Manually set Timer2Overflow to create a second event
    'this will event will be handled by the Interrupt sub routine
    TMR2IE = 1
    end

    Sub Interrupt
      Set PORTB.2 On
      TMR2IF = 0
    End Sub

    Sub Overflowed
      Set PORTB.1 On
      TMR1IF = 0
    End Sub</screen>
</section>
</section>
<section xml:id="_keypad">
<title>Keypad</title>
<simpara>This is the Keypad section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_keypad_overview">
<title>Keypad Overview</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>The keypad routines allow for a program to read from a 4 x 4 matrix
keypad.</simpara>
<simpara>There are two ways that the keypad routines can be set up. One option is
to connect the wires from the keypad in a particular order, and then to
set the KeypadPort constant. The other option is to connect the keypad
in whatever way is easiest, and then set the <literal>KEYPAD_ROW_x</literal> and
<literal>KEYPAD_COL_x</literal> constants. The option (setting <literal>KeypadPort</literal>) will
generate slightly more efficient code.</simpara>
<simpara><emphasis role="strong">Configuration using</emphasis> <literal>KEYPAD_ROW_x</literal> <emphasis role="strong">and</emphasis> <literal>KEYPAD_COL_x</literal>:</simpara>
<simpara>These constants must be set:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_ROW_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Row 1 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_ROW_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Row 2 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_ROW_3</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Row 3 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_ROW_4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Row 4 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_COL_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Col 1 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_COL_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Col 2 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_COL_3</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Col 3 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_COL_4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Col 4 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>If using a 3 x 3 keypad, do not set the <literal>KEYPAD_ROW_4</literal> or <literal>KEYPAD_COL_4</literal>
constants.</simpara>
<simpara><emphasis role="strong">Configuration using</emphasis> <literal>KeypadPort</literal>:</simpara>
<simpara>When setting up the keypad code using the <literal>KeypadPort</literal> constant, only
<literal>KeypadPort</literal> needs to be set.</simpara>
<simpara>Pull-ups or pull-downs go on the columns only, and are typically 4.7k to
10k in value.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>KeypadPort</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The port on the microcontroller chip that the keypad is connected to.</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Configuration when using Pull down resistors</emphasis></simpara>
<simpara>The keypad routine has a feature when using pull-down resistors, simply
add the constant to your program and the and the scan logic will be
inverted appropriately.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_PULLDOWN</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Support pull down resistors.</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For this to work, the keypad must be connected as follows:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Microcontroller port pin</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Keypad connector</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>Row 1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Row 2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>Row 3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>Row 4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>Column 1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>Column 2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>Column 3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>Column 4</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Note: To use a 3 x 3 keypad in this mode, the pins on the
microcontroller for any unused columns must be pulled up.</simpara>
</section>
<section xml:id="_keypaddata">
<title>KeypadData</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>var</emphasis> = KeypadData</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This function will return a value corresponding to the key that is
pressed on the keypad. Note that if two or more keys are pressed, then
only one value will be returned.
<literal><emphasis>var</emphasis></literal> can have one of the following values:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Value</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Key Pressed</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>0</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>3</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>4</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>5</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>6</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>7</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>8</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>9</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>10</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_A</simpara></entry>
<entry align="center" valign="top"><simpara>A</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>11</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_B</simpara></entry>
<entry align="center" valign="top"><simpara>B</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>12</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_C</simpara></entry>
<entry align="center" valign="top"><simpara>C</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>13</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_D</simpara></entry>
<entry align="center" valign="top"><simpara>D</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>14</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_STAR</simpara></entry>
<entry align="center" valign="top"><simpara>Asterisk/Star (*)</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>15</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_HASH</simpara></entry>
<entry align="center" valign="top"><simpara>Hash (#)</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>255</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_NONE</simpara></entry>
<entry align="center" valign="top"><simpara>None</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Program to show the value of the last pressed key on the LCD
    #chip 18F4550, 20

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Keypad connection settings
    #define KeypadPort PORTB

    'Main loop
    Do
        'Get key
        Temp = KeypadData

        'If a key is pressed, then display it
        If Temp &lt;&gt; KEY_NONE Then
            CLS
            Print Temp
            Wait 100 ms
        End If
    Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_keypad_overview">Keypad Overview</link></simpara>
</section>
<section xml:id="_keypadraw">
<title>KeypadRaw</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>largevar</emphasis> = KeypadRaw</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This function will return a 16 bit value, in which each bit corresponds
to a key on the keypad. If the key is pressed its bit will hold 1, and
if it is released its bit will contain a 0.</simpara>
<simpara>This table shows the key that each bit corresponds to:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Bit</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Key Position (row, col)</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Common Key Symbol</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>15</simpara></entry>
<entry align="center" valign="top"><simpara>1,1</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>14</simpara></entry>
<entry align="center" valign="top"><simpara>1,2</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>13</simpara></entry>
<entry align="center" valign="top"><simpara>1,3</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>12</simpara></entry>
<entry align="center" valign="top"><simpara>1,4</simpara></entry>
<entry align="center" valign="top"><simpara>A</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>11</simpara></entry>
<entry align="center" valign="top"><simpara>2,1</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>10</simpara></entry>
<entry align="center" valign="top"><simpara>2,2</simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>9</simpara></entry>
<entry align="center" valign="top"><simpara>2,3</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>8</simpara></entry>
<entry align="center" valign="top"><simpara>2,4</simpara></entry>
<entry align="center" valign="top"><simpara>B</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>7</simpara></entry>
<entry align="center" valign="top"><simpara>3,1</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>6</simpara></entry>
<entry align="center" valign="top"><simpara>3,2</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>5</simpara></entry>
<entry align="center" valign="top"><simpara>3,3</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>4</simpara></entry>
<entry align="center" valign="top"><simpara>3,4</simpara></entry>
<entry align="center" valign="top"><simpara>C</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>3</simpara></entry>
<entry align="center" valign="top"><simpara>4,1</simpara></entry>
<entry align="center" valign="top"><simpara>*</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="center" valign="top"><simpara>4,2</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="center" valign="top"><simpara>4,3</simpara></entry>
<entry align="center" valign="top"><simpara>#</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>0</simpara></entry>
<entry align="center" valign="top"><simpara>4,4</simpara></entry>
<entry align="center" valign="top"><simpara>D</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Program to show the keypad status using LEDs
    #chip 16F877A, 20

    'Keypad connection settings
    #define KeypadPort PORTB

    'LEDs
    #define LED1 PORTC
    #define LED2 PORTD
    Dir LED1 Out
    Dir LED2 Out

    'Declare a 16 bit variable for the key value
    Dim KeyStatus As Word

    'Main loop
    Do
        'Get key
        KeyStatus = KeypadRaw

        'Display
        LED1 = KeyStatus_H 'High Byte
        LED2 = KeyStatus 'Low Byte
    Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_keypad_overview">Keypad Overview</link></simpara>
</section>
</section>
<section xml:id="_graphical_lcd">
<title>Graphical LCD</title>
<simpara>This is the GLCD section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_glcd_overview">
<title>GLCD Overview</title>
<simpara>The GLCD commands are used to control a Graphical Liquid Crystal Display (GLCD)
based on the a number of GLCD chipsets. These are often 128x64 pixel displays but the size can vary.
GLCD devices draw graphical elements by enabling or disabling pixels.</simpara>
<simpara>A GLCD is an upgrade from the
popular 16x2 LCDs (see <link linkend="_lcd_overview">Liquid Crystal
Display Overview</link> ) but the GLCD allows full graphical control of the
display.</simpara>
<simpara>Typical displays are</simpara>
<itemizedlist>
<listitem>
<simpara>Color or mono displays</simpara>
</listitem>
<listitem>
<simpara>Low power white LED, OLED with or without back-light</simpara>
</listitem>
<listitem>
<simpara>e-Paper with low power consumption</simpara>
</listitem>
<listitem>
<simpara>Driven by on-board interface chipsets amd/or interface controllers</simpara>
</listitem>
<listitem>
<simpara>The GLCDs are very common and well documented</simpara>
</listitem>
<listitem>
<simpara>Small to large view areas</simpara>
</listitem>
<listitem>
<simpara>Typically requires from 3-pin to 36-pin header connections and 10K contrast pot</simpara>
</listitem>
<listitem>
<simpara>Typically have back-lit pixels</simpara>
</listitem>
<listitem>
<simpara>Require memory in the microcontroller to support graphial operations or can be used in text and picture mode</simpara>
</listitem>
</itemizedlist>
<simpara>GCBASIC makes this type of device easier to control with the
commands for the GLCD.</simpara>
<simpara><emphasis role="strong">Microcontroller Requirements:</emphasis>
Specific GLCDs require different configurations of a microcontroller.  Parameters include</simpara>
<itemizedlist>
<listitem>
<simpara>Communications protocol: These incldue 8 wire bus, I2C, SPI etc</simpara>
</listitem>
<listitem>
<simpara>Operating votlage: These are typically 3.3v or 5.v</simpara>
</listitem>
<listitem>
<simpara>Memory required: For full GLCD capabilites you will require 1k or more, for text only and JPG mode low memory devices are supported</simpara>
</listitem>
</itemizedlist>
<simpara>Review your choice of microcontroller and GLCD carefully before commencing your project.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="12">
<colspec colname="col_1" colwidth="8*"/>
<colspec colname="col_2" colwidth="8*"/>
<colspec colname="col_3" colwidth="8*"/>
<colspec colname="col_4" colwidth="8*"/>
<colspec colname="col_5" colwidth="8*"/>
<colspec colname="col_6" colwidth="8*"/>
<colspec colname="col_7" colwidth="8*"/>
<colspec colname="col_8" colwidth="8*"/>
<colspec colname="col_9" colwidth="8*"/>
<colspec colname="col_10" colwidth="8*"/>
<colspec colname="col_11" colwidth="8*"/>
<colspec colname="col_12" colwidth="8*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">#</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">ChipSet</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Size</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Pixels</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Depth</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Type</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">I/O</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Support</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Operating</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Comments</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Requirements</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Assessment</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>KS0108</simpara></entry>
<entry align="left" valign="top"><simpara>2.9 inch and less. various sizes</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>LCD typically with backlight</simpara></entry>
<entry align="left" valign="top"><simpara>8-bit parallel PIC and AVR: Software device specific protocol</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications 8-bit bus required.</simpara></entry>
<entry align="left" valign="top"><simpara>Bit 7 of the bus is read/write – this could cause potential lockup – this is low risk.&#160;&#160;&#160;Uses the KS0107B (or NT7107C) a 64-channel common driver which generates the timing signal to control the two KS0108B segment drivers.</simpara></entry>
<entry align="left" valign="top"><simpara>Requires 12 ports/connections.</simpara></entry>
<entry align="left" valign="top"><simpara>These are low cost mono devices.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>ILI9481</simpara></entry>
<entry align="left" valign="top"><simpara>3.2inch</simpara></entry>
<entry align="left" valign="top"><simpara>320 * 240</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD  8-bit parallel</simpara></entry>
<entry align="left" valign="top"><simpara>PIC: Set per bit. AVR: via Shield set via AND PORT command</simpara></entry>
<entry align="left" valign="top"><simpara>+VCC from 2.7 to  5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>UNO shield is excellent. Very fast display.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good GLCD with very good GLCD performance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>PCD8544</simpara></entry>
<entry align="left" valign="top"><simpara>1.77inch</simpara></entry>
<entry align="left" valign="top"><simpara>Nokia 3310 or 5110</simpara></entry>
<entry align="left" valign="top"><simpara>160 * 128</simpara></entry>
<entry align="left" valign="top"><simpara>Small  Mono  LCD with LED</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Device specific SPI command, all in software.</simpara></entry>
<entry align="left" valign="top"><simpara>Display can operate in text mode only for low RAM microcontrollers as full GLCD capabilities requires 512bytes of RAM. +VCC 3.3.  Always check voltage specifications  Nice display.
Sensitive to operating voltages.</simpara></entry>
<entry align="left" valign="top"><simpara>Minimum RAM required is 512 bytes then add user variables for graphics mode, this display can operate in text mode only for low RAM microcontrollers.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good for cost and performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>ILI9341</simpara></entry>
<entry align="left" valign="top"><simpara>2.8 Inch or 3.2 Inch</simpara></entry>
<entry align="left" valign="top"><simpara>320 * 240</simpara></entry>
<entry align="left" valign="top"><simpara>Medium</simpara></entry>
<entry align="left" valign="top"><simpara>Color TFT</simpara></entry>
<entry align="left" valign="top"><simpara>SPI  PIC and AVR: Hardware and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>+VCC from 2.7 to 5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>Very nice display.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good  for cost and performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>SSD1289</simpara></entry>
<entry align="left" valign="top"><simpara>3.2inch</simpara></entry>
<entry align="left" valign="top"><simpara>240 * 320</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>16-bit parallel  AVR: Software device specific protocol.</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>Mega2560 shield required.</simpara></entry>
<entry align="left" valign="top"><simpara>Connectivity requires 20 ports.</simpara></entry>
<entry align="left" valign="top"><simpara>Good for Mega2560 type shields</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>ST7735</simpara></entry>
<entry align="left" valign="top"><simpara>1.8 Inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications Very nice display.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good for cost and performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>ST7735R</simpara></entry>
<entry align="left" valign="top"><simpara>1.8 Inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 160</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications Very nice display.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good for cost and performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>ST7735R_160_80</simpara></entry>
<entry align="left" valign="top"><simpara>1.8 Inch</simpara></entry>
<entry align="left" valign="top"><simpara>160 * 80</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications Very nice display.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good for cost and performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>9</simpara></entry>
<entry align="left" valign="top"><simpara>ILI9340</simpara></entry>
<entry align="left" valign="top"><simpara>2.2 Inch</simpara></entry>
<entry align="left" valign="top"><simpara>240 * 320</simpara></entry>
<entry align="left" valign="top"><simpara>Medium</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good for cost and performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>ILI9486L or ILI9486</simpara></entry>
<entry align="left" valign="top"><simpara>4inch</simpara></entry>
<entry align="left" valign="top"><simpara>RPI   240 * 320</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>SPI and 8Bit Bus</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software SPI
AVR: 8Bit Bus using an UNO Shield.  PIC: 8bit port suppported.</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications Great pixel display.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.
8Bit Bus requires 8 ports plus 4 control ports. Typically 13 in total using an 8bit bus solution.</simpara></entry>
<entry align="left" valign="top"><simpara>An expensive option</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>11</simpara></entry>
<entry align="left" valign="top"><simpara>Nexion</simpara></entry>
<entry align="left" valign="top"><simpara>ITEAD Nexion</simpara></entry>
<entry align="left" valign="top"><simpara>240 * 320 to
800 * 480</simpara></entry>
<entry align="left" valign="top"><simpara>Large - 2.4 to 7inches</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>Serial - hardware or software serial is supported.</simpara></entry>
<entry align="left" valign="top"><simpara>Nextion specfic and GLCD command set</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5 with external power supply. Always check voltage specifications  Great command set, you need to learn the GUI and then interface to GCBASIC.</simpara></entry>
<entry align="left" valign="top"><simpara>2 ports for the read/write serial operations.</simpara></entry>
<entry align="left" valign="top"><simpara>A very nice option but if you need flexibility then the best!</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>SH1106</simpara></entry>
<entry align="left" valign="top"><simpara>1.3 inch or 0.96inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Small</simpara></entry>
<entry align="left" valign="top"><simpara>Mono OLED</simpara></entry>
<entry align="left" valign="top"><simpara>I2C</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software I2C</simpara></entry>
<entry align="left" valign="top"><simpara>Always at 3.3v. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>RAM for Full Mode GLCD is 1024 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.</simpara></entry>
<entry align="left" valign="top"><simpara>I2C requires 2 ports.</simpara></entry>
<entry align="left" valign="top"><simpara>Good OLED display, excellent value for money</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>13</simpara></entry>
<entry align="left" valign="top"><simpara>SDD1306</simpara></entry>
<entry align="left" valign="top"><simpara>0.96inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Small</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>OLED</simpara></entry>
<entry align="left" valign="top"><simpara>I2C and SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software I2C, and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>RAM for Full Mode GLCD is 1024 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.
Typically operates at VCC 5. Always check voltage specifications  Very good OLED display. Driver supports gaming. Minimum RAM required is  1024 bytes then add user variables for graphics mode.
</simpara><simpara>Display can operate in text mode only for low RAM microcontrollers</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.
</simpara><simpara>I2C requires 2 ports.</simpara></entry>
<entry align="left" valign="top"><simpara>Good OLED display, excellent value for money</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>14</simpara></entry>
<entry align="left" valign="top"><simpara>SDD1306 Twin Screen</simpara></entry>
<entry align="left" valign="top"><simpara>0.96inch * 2</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 128</simpara></entry>
<entry align="left" valign="top"><simpara>Small</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>OLED</simpara></entry>
<entry align="left" valign="top"><simpara>I2C and SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software I2C, and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>RAM for Full Mode GLCD is 2048 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.
Typically operates at VCC 5. Always check voltage specifications  Very good OLED display. Driver supports gaming. Minimum RAM required is  1024 bytes then add user variables for graphics mode.
</simpara><simpara>Display can operate in text mode only for low RAM microcontrollers</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 3 ports. Typically 7 in total.
</simpara><simpara>I2C requires 2 ports.</simpara></entry>
<entry align="left" valign="top"><simpara>Good OLED display, excellent value for money</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>15</simpara></entry>
<entry align="left" valign="top"><simpara>SDD1306_32</simpara></entry>
<entry align="left" valign="top"><simpara>0.96inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 32</simpara></entry>
<entry align="left" valign="top"><simpara>Very small</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>OLED</simpara></entry>
<entry align="left" valign="top"><simpara>I2C and SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software I2C, and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>RAM for Full Mode GLCD is 512 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.
Typically operates at VCC 5. Always check voltage specifications  Best small OLED display. Driver supports gaming.  Minimum RAM required is  512 bytes then add user variables for graphics mode, this display can operate in text mode only for low RAM microcontrollers</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.
</simpara><simpara>I2C requires 2 ports.</simpara></entry>
<entry align="left" valign="top"><simpara>Good OLED display, excellent value for money</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>ST7920</simpara></entry>
<entry align="left" valign="top"><simpara>2.9inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>LCD typically with backlight 8-bit parallel</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR:  Software device specific protocol.</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>8-bit bus required.  Bit 7 of the bus is read/write – this could cause potential lockup – this is low risk.
</simpara><simpara>This looks like a KS0108 but it is NOT! Supports Chinese font set.</simpara></entry>
<entry align="left" valign="top"><simpara>Requires 12 ports.</simpara></entry>
<entry align="left" valign="top"><simpara>A very slow device.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>17</simpara></entry>
<entry align="left" valign="top"><simpara>HX8347G</simpara></entry>
<entry align="left" valign="top"><simpara>2.2inch</simpara></entry>
<entry align="left" valign="top"><simpara>240 * 320</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>AVR 8 bit bus</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications Great pixel display.</simpara></entry>
<entry align="left" valign="top"><simpara>Controller requires 8 ports plus 5 control ports. Typically 13 in total with an UNO shield.</simpara></entry>
<entry align="left" valign="top"><simpara>An very nice display</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>18</simpara></entry>
<entry align="left" valign="top"><simpara>SDD1331</simpara></entry>
<entry align="left" valign="top"><simpara>0.96inch</simpara></entry>
<entry align="left" valign="top"><simpara>96 * 48</simpara></entry>
<entry align="left" valign="top"><simpara>Small</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>OLED</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software I2C, and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Very good color OLED display, excellent value for money</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>19</simpara></entry>
<entry align="left" valign="top"><simpara>ILI9326</simpara></entry>
<entry align="left" valign="top"><simpara>3.00inch</simpara></entry>
<entry align="left" valign="top"><simpara>400 * 320</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>OLED</simpara></entry>
<entry align="left" valign="top"><simpara>8 bit bus</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: 8 bit bus</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 3.3. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>Requires typically 13 in total plus 0v, VCC and LED.</simpara></entry>
<entry align="left" valign="top"><simpara>Good color OLED display, good value for money as it is fast.  But, the rotate is all executed in software and this does slow down processing.
</simpara><simpara><?asciidoc-br?>
The LED connected is typically to ground.  You can solder the GND connect to make the backlite permanently on.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>20</simpara></entry>
<entry align="left" valign="top"><simpara>NT7108C</simpara></entry>
<entry align="left" valign="top"><simpara>2.9 inch and less. various sizes</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>LCD typically with backlight</simpara></entry>
<entry align="left" valign="top"><simpara>8-bit parallel PIC and AVR: Software device specific protocol</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications 8-bit bus required.</simpara></entry>
<entry align="left" valign="top"><simpara>Look similar to KS0108, but, it is NOT the same, hence this driver.&#160;&#160;&#160;Uses the Winstar’s WDG0151-TMI module, which is a 128×64 pixel monochromatic display.&#160;&#160;&#160;This uses two Neotic display controller chips:&#160;NT7108C and NT7107C. The WDG0151 module contains two sets of it to drive 128 segments.&#160;&#160;&#160;On the other hand, the KS0107B (or NT7107C) is a 64-channel common driver which generates the timing signal to control the two KS0108B segment drivers.
<?asciidoc-br?>
<?asciidoc-br?>
The NT7108C is very sensitive with respect to clock timing.&#160;&#160;&#160;You may have to adjust to ensure the display operates as correctly.</simpara></entry>
<entry align="left" valign="top"><simpara>Requires 12 ports/connections.</simpara></entry>
<entry align="left" valign="top"><simpara>These are medium cost mono devices.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>21</simpara></entry>
<entry align="left" valign="top"><simpara>T6963_64</simpara></entry>
<entry align="left" valign="top"><simpara>4inches by 2inches</simpara></entry>
<entry align="left" valign="top"><simpara>240 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>LCD typically with backlight</simpara></entry>
<entry align="left" valign="top"><simpara>8-bit parallel PIC and AVR: Software device specific protocol</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications 8-bit bus required.</simpara></entry>
<entry align="left" valign="top"><simpara>Operating similar to KS0108 and an LCD.  segment drivers.
<?asciidoc-br?>
<?asciidoc-br?></simpara></entry>
<entry align="left" valign="top"><simpara>Requires 12 ports/connections.</simpara></entry>
<entry align="left" valign="top"><simpara>These are medium cost mono devices.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>22</simpara></entry>
<entry align="left" valign="top"><simpara>T6963_128</simpara></entry>
<entry align="left" valign="top"><simpara>4inches by 2inches</simpara></entry>
<entry align="left" valign="top"><simpara>240 * 128</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>LCD typically with backlight</simpara></entry>
<entry align="left" valign="top"><simpara>8-bit parallel PIC and AVR: Software device specific protocol</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications 8-bit bus required.</simpara></entry>
<entry align="left" valign="top"><simpara>Operating similar to KS0108 and an LCD.  segment drivers.
<?asciidoc-br?>
<?asciidoc-br?></simpara></entry>
<entry align="left" valign="top"><simpara>Requires 12 ports/connections.</simpara></entry>
<entry align="left" valign="top"><simpara>These are medium cost mono devices.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>23</simpara></entry>
<entry align="left" valign="top"><simpara>UC1601</simpara></entry>
<entry align="left" valign="top"><simpara>4.00inch</simpara></entry>
<entry align="left" valign="top"><simpara>132 * 22</simpara></entry>
<entry align="left" valign="top"><simpara>Medium</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>OLED</simpara></entry>
<entry align="left" valign="top"><simpara>I2C and SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software I2C, and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>RAM for Full Mode GLCD is 396 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.
Typically operates at VCC 2.8v. Always check voltage specifications  Very good display. Driver supports gaming. Minimum RAM required is 396 bytes then add user variables for graphics mode.</simpara></entry>
<entry align="left" valign="top"><simpara>Requires up to 5 ports/connections.</simpara></entry>
<entry align="left" valign="top"><simpara>Low cost device</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>24</simpara></entry>
<entry align="left" valign="top"><simpara>SDD1351</simpara></entry>
<entry align="left" valign="top"><simpara>1.50inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 128</simpara></entry>
<entry align="left" valign="top"><simpara>Small</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>OLED</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software I2C, and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 3.3 or 5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Very good color OLED display, excellent value for money</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>25</simpara></entry>
<entry align="left" valign="top"><simpara>Waveshare e-Paper</simpara></entry>
<entry align="left" valign="top"><simpara>Various Size from 2.13 to 7.5 inches</simpara></entry>
<entry align="left" valign="top"><simpara>104 * 112 to 640 * 384</simpara></entry>
<entry align="left" valign="top"><simpara>Small to very large</simpara></entry>
<entry align="left" valign="top"><simpara>Black and White</simpara></entry>
<entry align="left" valign="top"><simpara>Microencapsulated Electrophoretic Display</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software I2C, and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 3.3. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Very good color e-Paper displays, excellent value for money
Display can operate in text mode only for low RAM microcontrollers using SRAM solution.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>26</simpara></entry>
<entry align="left" valign="top"><simpara>ST7789</simpara></entry>
<entry align="left" valign="top"><simpara>2.0 Inch</simpara></entry>
<entry align="left" valign="top"><simpara>240 * 240 or 320 * 240</simpara></entry>
<entry align="left" valign="top"><simpara>Medium</simpara></entry>
<entry align="left" valign="top"><simpara>Color TFT</simpara></entry>
<entry align="left" valign="top"><simpara>SPI  PIC and AVR: Hardware and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at 3v3. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>+VCC from 3v3. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>Very nice display.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 3 ports (data, clock &amp; command/data) plus 1 port ( reset ). Typically 4 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good  for cost and performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>27</simpara></entry>
<entry align="left" valign="top"><simpara>ST7735R_160_80</simpara></entry>
<entry align="left" valign="top"><simpara>1.8 Inch</simpara></entry>
<entry align="left" valign="top"><simpara>160 * 80</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates only at VCC 3.3. Always check voltage specifications Very nice display.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good for cost and performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>28</simpara></entry>
<entry align="left" valign="top"><simpara>ILI9488</simpara></entry>
<entry align="left" valign="top"><simpara>3.2inch</simpara></entry>
<entry align="left" valign="top"><simpara>320 * 240</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD  SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC/&amp;AVR: SPI Only</simpara></entry>
<entry align="left" valign="top"><simpara>+VCC from 3v3 to  5. GLCD I/O is ONLY 3v3. Always check voltage specifications.</simpara></entry>
<entry align="left" valign="top"><simpara>Display is good, however, slower than comparable (size) GLCDs as the color definitions are four bytes ( typical color definitions are two bytes)</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Acceptable GLCD performance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>29</simpara></entry>
<entry align="left" valign="top"><simpara>ST7567</simpara></entry>
<entry align="left" valign="top"><simpara>1.9inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Medium</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>LCD</simpara></entry>
<entry align="left" valign="top"><simpara>I2C and SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Software I2C, and, hardware software SPI.  Harware IC2 fails as the ST7567 does not comply witht the I2C standard.</simpara></entry>
<entry align="left" valign="top"><simpara>+VCC from 3v3 to  5. GLCD I/O is ONLY 3v3. Always check voltage specifications.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.
</simpara><simpara>I2C requires 2 ports.</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 3v3 but may support 5v0. Always check voltage specifications  Very good LCD display. Driver supports gaming. Minimum RAM required is 1024 bytes then add user variables for graphics mode.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Setup:</emphasis></simpara>
<simpara>You <emphasis role="strong">must</emphasis> include the <literal>glcd.h</literal> file at the top of your program. The file
needs to be in brackets as shown below.</simpara>
<screen>    #include &lt;GLCD.h&gt;</screen>
<simpara><emphasis role="strong">Defines:</emphasis></simpara>
<simpara>There are several connections that must be defined to use the GLCD
commands with a GLCD display. The <emphasis>I/O pin</emphasis> is the pin on the Microchip PIC or the Atmel AVR microcontroller
that is connected to that specific pin on the graphical LCD.</simpara>
<simpara><emphasis role="strong">Example: KS0108 connectivity</emphasis></simpara>
<screen>    #define GLCD_RW   _I/O pin_ ‘Read/Write pin connection
    #define GLCD_RESET  _I/O pin_ ‘Reset pin connection
    #define GLCD_CS1  _I/O pin_ ‘CS1 pin connection
    #define GLCD_CS2  _I/O pin_ ‘CS2 pin connection
    #define GLCD_RS   _I/O pin_ ‘RS pin connection
    #define GLCD_ENABLE _I/O pin_ ‘Enable pin Connection
    #define GLCD_DB0  _I/O pin_ ‘Data pin 0 Connection
    #define GLCD_DB1  _I/O pin_ ‘Data pin 1 Connection
    #define GLCD_DB2  _I/O pin_ ‘Data pin 2 Connection
    #define GLCD_DB3  _I/O pin_ ‘Data pin 3 Connection
    #define GLCD_DB4  _I/O pin_ ‘Data pin 4 Connection
    #define GLCD_DB5  _I/O pin_ ‘Data pin 5 Connection
    #define GLCD_DB6  _I/O pin_ ‘Data pin 6 Connection
    #define GLCD_DB7  _I/O pin_ ‘Data pin 7 Connection
    #define GLCD_PROTECTOVERRUN 'prevent screen overdrawing     'SSD1306 GLCD only
    #define GLCDDirection       'Invert GLCD Y axis             'KS0108 GCD only</screen>
<simpara>Common commands supported across the range of supported GLCDs are:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable</literal> )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>Public variable supported across the range of supported GLCDs are shown in the table below.
These variables control the user definable parameters of a specific GLCD.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Variable</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Type</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDBackground</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Color of GLCD background.</simpara></entry>
<entry align="left" valign="top"><simpara>Can be monochrome or color.<?asciidoc-br?>
For mono GLCDs the default is White or 0x0001.
For color GLCDs the default is White or 0xFFFF.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDForeground</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Color of GLCD foreground.</simpara></entry>
<entry align="left" valign="top"><simpara>Can be monochrome or color.<?asciidoc-br?>
For mono GLCDs the default is non-white or 0x0000.
For color GLCDs the default is Black or 0x0000.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Width of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 6 pixels.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 0.+
This equates to the standard GCB font set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefaultsize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 1.+
This equates to the 8 pixel high.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For color TFT displays any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF., see <link xlink:href="http://www.barth-dev.de/online/rgb565-color-picker/">http://www.barth-dev.de/online/rgb565-color-picker/</link> for a wider range of color parameters.</simpara>
<simpara>The following color constants are prevent-defined.</simpara>
<screen>    TFT_BLACK       0x0000
    TFT_NAVY        0x000F
    TFT_DARKGREEN   0x03E0
    TFT_DARKCYAN    0x03EF
    TFT_MAROON      0x7800
    TFT_PURPLE      0x780F
    TFT_OLIVE       0x7BE0
    TFT_LIGHTGREY   0xC618
    TFT_DARKGREY    0x7BEF
    TFT_BLUE        0x001F
    TFT_GREEN       0x07E0
    TFT_CYAN        0x07FF
    TFT_RED         0xF800
    TFT_MAGENTA     0xF81F
    TFT_YELLOW      0xFFE0
    TFT_WHITE       0xFFFF
    TFT_ORANGE      0xFD20
    TFT_GREENYELLOW 0xAFE5
    TFT_PINK        0xF81F</screen>
<simpara>This example shows how to drive a KS0108 based Graphic LCD module with
the built in commands of GCBASIC. See
<link xlink:href="http://www.greatcowbasic.com/sample-projects.html">Graphic LCD</link> for
details, this is an external web site.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F886,16
    '#config MCLRE = on 'enable reset switch on CHIPINO
    #include &lt;GLCD.h&gt;

    ;Defines (Constants)
    #define GLCD_RW PORTB.1  'D9 to pin 5 of LCD
    #define GLCD_RESET PORTB.5 'D13 to pin 17 of LCD
    #define GLCD_CS1 PORTB.3 'D12 to actually since CS1, CS2 can be inverted
    #define GLCD_CS2 PORTB.4 'D11 to actually since CS1, CS2 can be inverted
    #define GLCD_RS PORTB.0  'D8 to pin 4 D/I pin on LCD
    #define GLCD_ENABLE PORTB.2 'D10 to Pin 6 on LCD
    #define GLCD_DB0 PORTC.7 'D0 to pin 7 on LCD
    #define GLCD_DB1 PORTC.6 'D1 to pin 8 on LCD
    #define GLCD_DB2 PORTC.5 'D2 to pin 9 on LCD
    #define GLCD_DB3 PORTC.4 'D3 to pin 10 on LCD
    #define GLCD_DB4 PORTC.3 'D4 to pin 11 on LCD
    #define GLCD_DB5 PORTC.2 'D5 to pin 12 on LCD
    #define GLCD_DB6 PORTC.1 'D6 to pin 13 on LCD
    #define GLCD_DB7 PORTC.0 'D7 to pin 14 on LCD

    Start:
    GLCDCLS
    GLCDPrint 0,10,"Hello"        'Print Hello
    wait 5 s
    GLCDPrint 0,10, "ASCII #:"    'Print ASCII #:
    Box 18,30,28,40               'Draw Box Around ASCII Character
    for char = 15 to 129          'Print 0 through 9
      GLCDPrint 17, 20 , Str(char)+"  "
      GLCDdrawCHAR 20,30, char
      wait 125 ms
    next
    line 0,50,127,50               'Draw Line using line command
    for xvar = 0 to 80             'Draw line using Pset command
        pset xvar,63,on                    '
    next                                        '
    Wait 1 s
    GLCDPrint 0,10,"End  "          'Print Hello
    wait 1 s
    Goto Start</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_graphical_lcd_demonstration">Graphical LCD Demonstration</link>,
<link linkend="_glcdcls">GLCDCLS</link>,
<link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>,
<link linkend="_glcdreadbyte">GLCDReadByte</link>,
<link linkend="_glcdwritebyte">GLCDWriteByte</link>, <link linkend="_pset">Pset</link></simpara>
<section xml:id="_fonts_and_characters">
<title>Fonts and Characters</title>
<simpara>This section covers GLCD fonts and characters.</simpara>
<simpara><emphasis role="strong">GLCD Support for Fonts</emphasis></simpara>
<simpara>lorem ipsum.&#160;&#160;</simpara>
<simpara><emphasis role="strong">GLCD Support for Characters</emphasis></simpara>
<simpara>lorem ipsum.&#160;&#160;</simpara>
<simpara><emphasis role="strong">GLCD Character Table</emphasis></simpara>
<simpara>lorem ipsum.&#160;&#160;</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/OLEDASCIIcharacter.png" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">GLCD Controlling Constants</emphasis></simpara>
<simpara>The GCBASIC constants for control of fonts and characters are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>CONSTANT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Words</simpara></entry>
<entry align="left" valign="top"><simpara>Explaination</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ANOTHER CONSTANT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Words</simpara></entry>
<entry align="left" valign="top"><simpara>Explaination</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link></simpara>
</section>
<section xml:id="_e_paper_controllers">
<title>e-Paper Controllers</title>
<simpara>This section covers GLCD devices known as e-Papers.</simpara>
<simpara>An e-paper device is a Microencapsulated Electrophoretic Display, MED.</simpara>
<simpara>A MED display uses tiny spheres, in which the charged color pigments are suspending in the transparent oil and would move depending on the electronic charge.&#160;&#160;
The e-paper screen display patterns by reflecting the ambient light, so it has no background light requirement.&#160;&#160;
Under sunshine, the e-paper screen still has high visibility with a wide viewing angle of 180 degree.&#160;&#160;
It is the ideal choice for e-reading or providing information that can be refeshed at a slow rate of change.&#160;&#160;</simpara>
<simpara><emphasis role="strong">GLCD Support for e-Papers</emphasis></simpara>
<simpara>GCBASIC supports covers the full range of GLCD capabilities like line, circle, print.</simpara>
<simpara>GCBASIC supports SPI communications for the e-Papers - both hardware and software.  And, GCBASIC suppors low memory configurations and SRAM for the display buffer.</simpara>
<simpara>See the demonstration programs to show you how to use these GCLD capabilities.</simpara>
<simpara><emphasis role="strong">Memory Usage</emphasis></simpara>
<simpara>The GCBASIC library uses RAM to buffer the e-paper display.&#160;&#160;
The amount of RAM used is specific the the total pixel of the specific e-paper display.&#160;&#160;
You can control to amount of RAM used as the buffer using the device specific constants, see below.&#160;&#160;
Each device specific library has four memory options.&#160;&#160;
Each of the memory options uses different amount RAM.&#160;&#160;
The greater the amount of RAM used the faster the process of updating the e-paper display.&#160;&#160;
Conversely, the smaller the amount of RAM used the slower the process of updating the e-paper display.&#160;&#160;</simpara>
<simpara><emphasis role="strong">GLCD Page Transactions</emphasis></simpara>
<simpara>To make the operation of the library seamless - the library supports GLCDTransaction.&#160;&#160;
GLCDTransaction automatically manages the methods to update the e-paper via the buffer, where the buffer can be small.&#160;&#160;
The process of transaction send GLCD commands to the e-paper display on a page and page basis.&#160;&#160;
Each page is the size of the buffer and for a large e-paper display the number of pages may be equivilent to the numbers of pixels high (height).</simpara>
<simpara>GLCDTransaction simplies the operation by ensure the buffer is setup correctly, handles the GLCD appropiately, handles the sending of the buffer and then close out the process to update to the display.</simpara>
<simpara>To use GLCDTransaction use the followng two methods.</simpara>
<screen>        GLCD_Open_PageTransaction
            ....
            glcd commands
            .....

        GLCD_Close_PageTransaction</screen>
<simpara>It recommended to use GLCDTransactions at all times.&#160;&#160;These methods remove the complexity of the e-paper update process.</simpara>
<simpara>When using GLCDTransaction you must start the transaction with`GLCD_Open_PageTransaction` then include a series of GLCD commands and then terminate the transaction with <literal>GLCD_Close_PageTransaction</literal>.</simpara>
<simpara><emphasis role="strong">GLCDTransaction Insight</emphasis>: When using GLCDtransactions the number of buffer pages is probably be greater then 1 (unless using the SRAM option), so the process of incrementing variables and calls to non-GLCD methods must be considered carefully. &#160;&#160; The transaction process <emphasis role="strong">will</emphasis> increment variables and call non-GLCD methods the same number of times as the number of pages.&#160;&#160;Therefore, design GLCDTransaction operations with this is mind.</simpara>
<simpara><emphasis role="strong">SRAM as the e-paper buffer</emphasis></simpara>
<simpara>To improve memory usage the e-paper the e-Paper libraries support the use of SRAM.&#160;&#160;
SRAM can be used as an alternative to the microcontrollers RAM.&#160;&#160;
Using SRAM does have a small performance impact but does free up the critical resource of the microcontroller RAM.&#160;&#160;
The use of SRAM within the e-paper library is transparent to the user.&#160;&#160;
To use SRAM as the e-paper buffer you will need to set-up the SRAM library.&#160;&#160;
See the SRAM library for more details on SRAM usage. &#160;&#160;</simpara>
<simpara>When using SRAM for the e-paper buffer it is still remcommend to use GLCDTransaction as this ensure the SRAM buffer is correctly initialised.</simpara>
<simpara><emphasis role="strong">Refresh mode</emphasis></simpara>
<simpara>This library uses Full refresh:&#160;&#160;The e-Paper will flicker when full refreshing.&#160;&#160;
This flicker removes the ghost image from the display.&#160;&#160;
You could use Partial refresh as this doesnot flicker.&#160;&#160;
Note that you cannot use Partial refresh all the time, you should full refresh e-paper regularly, otherwise, the ghost problem will get worse and even damage the display.&#160;&#160;</simpara>
<simpara><emphasis role="strong">Refresh rate</emphasis></simpara>
<simpara>When using the e-Paper library, you should set the update interval at least 180seconds, except when using Partial mode.&#160;&#160;</simpara>
<simpara>Please set the e-Paper to sleep mode in software or remove the power directly, otherwise, the e-Paper will be damaged because of working in high voltage for extendedtime periods.&#160;&#160;
You need to update the content of the e-Paper at least once every 24 hours to avoid from burn-in problem.&#160;&#160;</simpara>
<simpara><emphasis role="strong">Operating Voltages</emphasis></simpara>
<simpara>The e-Paper should be driven with 3V3 operating voltages and signals.&#160;&#160;</simpara>
<simpara>If your Microcontroller (PIC, AVR and therefore an Arduino)cannot drive the e-Paper successfully.&#160;&#160;
You must convert the level to 3.3V. &#160;&#160;
The I/O level of Arduino is 5V.&#160;&#160; HEALTH WARNING:You can also try to connect the Vcc pin to the 5V of Arduino to see whether the e-Paper works, but we recommend you not to use 5V for a long time.&#160;&#160;</simpara>
<simpara><emphasis role="strong">The e-Paper looks a little black or grey</emphasis></simpara>
<simpara>You can try to change the value of Vcom the library by setting the VCOM_AND_DATA_INTERVAL constant.&#160;&#160;
See the Vcom and data interval in the dataheet.&#160;&#160;VCOM_AND_DATA_INTERVAL can be 0x00 to 0x0F</simpara>
<simpara><emphasis role="strong">GCBASIC library supports Black/White NOT Black/White/Red</emphasis></simpara>
<simpara>The default is Black/White. To support Black/White/Red add `#define PANEL_SETTING_KWR 0x00`to you user program.&#160;</simpara>
<simpara>The constant are the TFT_BLACK and TFT_WHITE constants.</simpara>
<simpara><emphasis role="strong">The e-paper has ghosting problem after working for some days</emphasis></simpara>
<simpara>Please set the e-paper to sleep mode or disconnect it if you do not refresh the e-paper but need to power on your solution.&#160;&#160;</simpara>
<simpara>Do NOT leave power on for extended periods, otherwise, the voltage of panel remains high and it will damage the e-paper display.&#160;&#160;</simpara>
<simpara><emphasis role="strong">e-Paper Guidelines</emphasis></simpara>
<simpara>Remove power if practical.</simpara>
<simpara>ALWAYS use <literal>GLCDDisplay Off</literal> or sleep mode.</simpara>
<simpara>When in storage CLEAR the screen&#8230;&#8203;. avoid burn it - use</simpara>
<screen>    GLCDCLD TFT_WHITE
    GLCDDisplay Off</screen>
<simpara>The recommended method is:</simpara>
<screen>    GLCDCLS TFT_WHITE
    GLCDDisplay Off
    do
    loop</screen>
<simpara><emphasis role="strong">Using the e-Paper Library</emphasis></simpara>
<simpara>To use the e-Paper driver for a specific simply include the following in your user code.&#160;&#160;</simpara>
<simpara>This will initialise the driver.&#160;&#160;</simpara>
<screen>    'Setup for the e-Paper
     #include &lt;glcd.h&gt;

     #define GLCD_TYPE GLCD_TYPE_EPD_EPD7in5
     #define GLCD_EXTENDEDFONTSET1
     #define GLCD_OLED_FONT
     #define GLCD_TYPE_EPD7in5_LOWMEMORY4_GLCD_MODE fastest but uses a lot of RAM
     '#define GLCD_TYPE_EPD7in5_LOWMEMORY3_GLCD_MODE
     '#define GLCD_TYPE_EPD7in5_LOWMEMORY2_GLCD_MODE
     '#define GLCD_TYPE_EPD7in5_LOWMEMORY1_GLCD_MODEslowest uses the least amount of RAM


    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC portA.0 ' Data(hight)/ command(low) line
    #define GLCD_CS portC.1 ' Chip select line (negate)
    #define GLCD_RESETportD.2 ' Reset line (negate)
    #define GLCD_DO portC.5 ' GLCD MOSI connect to MCU SDO
    #define GLCD_SCKportC.3 ' Clock Line
    #define GLCD_Busy portC.0 ' Busy Line

    'The following should be used for hardware SPI remove or comment out if you want to use software SPI.
    #define EPD_HardwareSPI</screen>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_EPD_EPD7in5</literal></simpara></entry>
<entry align="left" valign="top"><simpara>GLCD_TYPE_EPD_EPD7in5 and GLCD_TYPE_EPD_EPD2in13D supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_&lt;device_memory_mode&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Memory usage for the display buffer.&#160;&#160;
</simpara><simpara>Memory management is crutial when using the e-paper displays.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_EPD7in5_LOWMEMORY4_GLCD_MODE</literal> &#8230;&#8203;  <literal>GLCD_TYPE_EPD7in5_LOWMEMORY1_GLCD_MODE</literal>,
</simpara><simpara>or,
</simpara><simpara><literal>GLCD_TYPE_EPD2in13D_LOWMEMORY4_GLCD_MODE</literal> &#8230;&#8203;  <literal>GLCD_TYPE_EPD2in13D_LOWMEMORY1_GLCD_MODE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS) on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on
the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_BUSY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Busy pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>EPD_HardwareSPI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Instructs the library to use hardware SPI, remove or comment out if you want to use software SPI.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>#define EPD_HardwareSPI</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HWSPIMode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the speed of the SPI communications for Hardware SPI only.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional defaults to MASTERFAST.
</simpara><simpara>Options are MASTERSLOW,<?asciidoc-br?>
MASTER,<?asciidoc-br?>
MASTERFAST, or<?asciidoc-br?>
MASTERULTRAFAST for specific AVRs only.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara>Specific to the e-Paper selected<?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara>Specific to the e-Paper selected<?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="center" valign="top"><simpara><literal>6</literal> or <literal>5</literal> for the OLED font set.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDisplay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enables sleep mode, or, enables operations</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDisplay Off</literal>, or, <literal>GLCDDisplay On</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Open_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands with memory buffer management.  Must be followed a  <literal>GLCD_Close_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_Open_PageTransaction</literal>. Parameters may be passed where the two parameters are the range of pages to be updated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Terminate a series of GLCD commands.  Must follow a <literal>GLCD_Open_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction</literal>. Terminates the GLCDTransaction.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example Usage:</emphasis></simpara>
<screen>#chip mega328p, 16
#include &lt;uno_mega328p.h&gt;
#option explicit

 '******************************************************************************************************

'Setup the E-Paper
 #include &lt;glcd.h&gt;

 #define HWSPIMode ULTRAFAST

 #define GLCD_TYPE GLCD_TYPE_EPD_EPD2in13D
 #define GLCD_EXTENDEDFONTSET1
 #define GLCD_TYPE_EPD2in13D_LOWMEMORY4_GLCD_MODE
 #define GLCD_OLED_FONT
 #define GLCD_PROTECTOVERRUN



 'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
 #define GLCD_DC DIGITAL_9
 #define GLCD_CS DIGITAL_10
 #define GLCD_RESETDIGITAL_8
 #define GLCD_DO DIGITAL_11
 #define GLCD_SCKDIGITAL_13
 #define GLCD_Busy DIGITAL_7

 #define EPD_HARDWARESPI

 '***********************************************************************************************


'Main program

GLCDForeground=TFT_BLACK
GLCDBackground=TFT_WHITE


 GLCD_Open_PageTransaction
    GLCDPrintStringLN ("GCBASIC")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("Test of the e-Paper")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("December 2021")
 GLCD_Close_PageTransaction
 GLCDDisplay Off

 wait 2 s
 GLCDDisplay On
 GLCDCLS
 GLCDDisplay off

 do

 loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link>, <link linkend="_pset">Pset</link> or <link linkend="_glcdtransaction">GLCDTransaction</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_hx8347g_controllers">
<title>HX8347G Controllers</title>
<simpara>This section covers GLCD devices that use the HX8347G graphics controller.</simpara>
<simpara>HX8347G is a 262k-color single-chip SoC driver for a-TFT liquid crystal display with resolution of 240&#160;RGB&#160;x&#160;320&#160;
dots.</simpara>
<simpara>The HX8347-G is designed to provide a single-chip solution that combines a gate
driver, a source driver, power supply circuit for 262k colors to drive a TFT panel
with 240RGBx320 dots at maximum.</simpara>
<simpara>GCBASIC supports 65K-color mode operations.</simpara>
<simpara>The HX8347-G can be operated in low-voltage (1.4V) condition for the interface and
integrated internal boosters that produce the liquid crystal voltage, breeder resistance
and the voltage follower circuit for liquid crystal driver. In addition, The HX8347-G also
supports various functions to reduce the power consumption of a LCD system via
software control.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the HX8347G controller.
&#160;&#160;&#160;The GCBASIC constants for control and data line connections are shown
in the table below.</simpara>
<simpara>Connectivity is via an 8-bit bus.  Where 8 pins are connected between the microcontroller and the GLCD to control the
data bus plus 5 control pins.  This is simple when using an Arduino GLCD Shield.</simpara>
<simpara>To use the HX8347G driver simply include the following in your user code.  This will initialise the driver.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">8-bit mode</emphasis></simpara>
<screen>    'This GLCD driver supports 8 bit only. UNO ports can be replaced with porta.b constants.

    #include &lt;glcd.h&gt;
    #include &lt;UNO_mega328p.h &gt;
    #define GLCD_TYPE GLCD_TYPE_HX8347

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line

    #define GLCD_DB0       DIGITAL_8
    #define GLCD_DB1       DIGITAL_9
    #define GLCD_DB2       DIGITAL_2
    #define GLCD_DB3       DIGITAL_3
    #define GLCD_DB4       DIGITAL_4
    #define GLCD_DB5       DIGITAL_5
    #define GLCD_DB6       DIGITAL_6
    #define GLCD_DB7       DIGITAL_7</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The GCBASIC constants for the interface to the controller are shown in the table below.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_HX8347</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB0..7</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the  pin that is connected to DB0..7 IO pin on the GLCD (8 bit DBI).</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RST</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (RW or WDR) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RD</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (RD or RDR) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The GCBASIC constants for control display characteristics are shown in the table below.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>480</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6</literal> for GCB fonts, and <literal>5</literal> for OLED fonts.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_OLED_FONT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the use of the optional OLED font set.
</simpara><simpara>The GLCDfntDefaultsize can be set to 1 or 2 only.
</simpara><simpara><literal>GLCDfntDefaultsize=  1</literal>.   A small 8 height pixel font with variable width.
<literal>GLCDfntDefaultsize=  2</literal>.   A larger 10 width * 16 height pixel font.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS  [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDRotate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the display</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LANDSCAPE</literal>, <literal>PORTRAIT_REV</literal>, <literal>LANDSCAPE_REV</literal> and <literal>PORTRAIT</literal> are supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HX8347G_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?>
</simpara><simpara></simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    HX8347G_BLACK   'hexidecimal value 0x0000
    HX8347G_RED     'hexidecimal value 0xF800
    HX8347G_GREEN   'hexidecimal value 0x0400
    HX8347G_BLUE    'hexidecimal value 0x001F
    HX8347G_WHITE   'hexidecimal value 0xFFFF
    HX8347G_PURPLE  'hexidecimal value 0xF11F
    HX8347G_YELLOW  'hexidecimal value 0xFFE0
    HX8347G_CYAN    'hexidecimal value 0x07FF
    HX8347G_D_GRAY  'hexidecimal value 0x528A
    HX8347G_L_GRAY  'hexidecimal value 0x7997
    HX8347G_SILVER  'hexidecimal value 0xC618
    HX8347G_MAROON  'hexidecimal value 0x8000
    HX8347G_OLIVE   'hexidecimal value 0x8400
    HX8347G_LIME    'hexidecimal value 0x07E0
    HX8347G_AQUA    'hexidecimal value 0x07FF
    HX8347G_TEAL    'hexidecimal value 0x0410
    HX8347G_NAVY    'hexidecimal value 0x0010
    HX8347G_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>These examples show how to drive a HX8347G based Graphic LCD module with the built in commands of GCBASIC.  The 8 bit DBI example uses a UNO shield, this can easily adapted to Microchip architecture.  The 16 bit DBI
example uses a Mega2560 board.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip mega328p, 16
    #option explicit


    #include &lt;glcd.h&gt;
    #include &lt;UNO_mega328p.h &gt;

    #define GLCD_TYPE GLCD_TYPE_HX8347
    #define GLCD_OLED_FONT

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line



    #define GLCD_DB0       DIGITAL_8
    #define GLCD_DB1       DIGITAL_9
    #define GLCD_DB2       DIGITAL_2
    #define GLCD_DB3       DIGITAL_3
    #define GLCD_DB4       DIGITAL_4
    #define GLCD_DB5       DIGITAL_5
    #define GLCD_DB6       DIGITAL_6
    #define GLCD_DB7       DIGITAL_7


    GLCDRotate ( Portrait )
    GLCDCLS HX8347_RED
    GLCDPrint(0, 0, "Test of the HX8347G Device")
    end</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>,  <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link>
<?asciidoc-br?>
<?asciidoc-br?>
Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ili9326_controllers">
<title>ILI9326 Controllers</title>
<simpara>This section covers GLCD devices that use the ILI9326 graphics controller.  The ILI9326 is a TFT LCD Single Chip Driver with 400RGBx320 Resolution and 262K colors.</simpara>
<simpara>GCBASIC supports 65K-color mode operations.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the ILI9326 controller. &#160;&#160;&#160;GCBASIC supports 8 bit bus connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the ILI9326 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9326

    'Pin mappings for ILI9326 - these MUST be specified
    #define GLCD_RD       porta.3        ' read command line
    #define GLCD_WR       porta.2         ' write command line
    #define GLCD_RS       porta.1         ' Command/Data line
    #define GLCD_CS       porta.0         ' Chip select line
    #define GLCD_RST      porta.5         ' Reset line
    #define GLCD_DataPort portD</screen>
<simpara>The GCBASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ILI9326</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RD</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to RD IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to WR on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to RS pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to CS pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RST</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to RST pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DataPort</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output port that is connected to DB0 to DB7 pins on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>240</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6</literal> for GCB fonts, and <literal>5</literal> for OLED fonts.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_OLED_FONT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the use of the optional OLED font set.
</simpara><simpara>The GLCDfntDefaultsize can be set to 1 or 2 only.
</simpara><simpara><literal>GLCDfntDefaultsize=  1</literal>.   A small 8 height pixel font with variable width.
<literal>GLCDfntDefaultsize=  2</literal>.   A larger 10 width * 16 height pixel font.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS  [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDRotate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the display</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LANDSCAPE</literal>, <literal>PORTRAIT_REV</literal>, <literal>LANDSCAPE_REV</literal> and <literal>PORTRAIT</literal> are supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9326_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>    ILI9326_BLACK   'hexidecimal value 0x0000
    ILI9326_RED     'hexidecimal value 0xF800
    ILI9326_GREEN   'hexidecimal value 0x07E0
    ILI9326_BLUE    'hexidecimal value 0x001F
    ILI9326_WHITE   'hexidecimal value 0xFFFF
    ILI9326_PURPLE  'hexidecimal value 0xF11F
    ILI9326_YELLOW  'hexidecimal value 0xFFE0
    ILI9326_CYAN    'hexidecimal value 0x07FF
    ILI9326_D_GRAY  'hexidecimal value 0x528A
    ILI9326_L_GRAY  'hexidecimal value 0x7997
    ILI9326_SILVER  'hexidecimal value 0xC618
    ILI9326_MAROON  'hexidecimal value 0x8000
    ILI9326_OLIVE   'hexidecimal value 0x8400
    ILI9326_LIME    'hexidecimal value 0x07E0
    ILI9326_AQUA    'hexidecimal value 0x07FF
    ILI9326_TEAL    'hexidecimal value 0x0410
    ILI9326_NAVY    'hexidecimal value 0x0010
    ILI9326_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara>For a ILI9326 datasheet, please refer to Google.</simpara>
<simpara>This example shows how to drive a ILI9326 based Graphic LCD module with the built in commands of GCBASIC.</simpara>
<simpara><emphasis role="strong">Example #1</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F1789,32

    #config MCLRE=on
    #option explicit
    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_ILI9326

    #define GLCD_RD       porta.3        ' read command line
    #define GLCD_WR       porta.2         ' write command line
    #define GLCD_RS       porta.1         ' Command/Data line
    #define GLCD_CS       porta.0         ' Chip select line
    #define GLCD_RST      porta.5         ' Reset line
    #define GLCD_DataPort portD

    GLCDPrint(0, 0, "Test of the ILI9326 Device")
    end</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example #2</emphasis>
This example shows how to drive a ILI3941 with the OLED fonts.  Note the use of the <literal>GLCDfntDefaultSize</literal> to select the size of the OLED font in use.
<?asciidoc-br?></simpara>
<screen>  'Chip Settings
    #chip 16F1789,32

    #config MCLRE=on
    #option explicit
    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_ILI9326

    #define GLCD_RD       porta.3        ' read command line
    #define GLCD_WR       porta.2         ' write command line
    #define GLCD_RS       porta.1         ' Command/Data line
    #define GLCD_CS       porta.0         ' Chip select line
    #define GLCD_RST      porta.5         ' Reset line
    #define GLCD_DataPort portD

    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ILI9326" )
    GLCDPrint ( 0, 34, "Size: 400 x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ili9340_controllers">
<title>ILI9340 Controllers</title>
<simpara>This section covers GLCD devices that use the ILI9340 graphics controller.  The ILI9340 is a TFT LCD Single Chip Driver with 240RGBx320 Resolution and 262K colors.</simpara>
<simpara>GCBASIC supports 65K-color mode operations.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the ILI9340 controller. &#160;&#160;&#160;GCBASIC supports SPI hardware and software connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the ILI9340 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9340

    'Pin mappings for ILI9340 - these MUST be specified
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting</screen>
<simpara>The GCBASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ILI9340</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.
#define GLCD_SCK    porta.5           'example port setting</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HWSPIMode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>User can specify the hardware SPI mode.  Must be one of MasterSlow, Master, Masterfast</simpara></entry>
<entry align="left" valign="top"><simpara>Optional. Defaults to Masterfast when chipMhz is less than 64mhz</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal>+
Cannot be changed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>240</literal>+
Cannot be changed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS  [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDRotate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the display</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LANDSCAPE</literal>, <literal>PORTRAIT_REV</literal>, <literal>LANDSCAPE_REV</literal> and <literal>PORTRAIT</literal> are supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9340_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?>
</simpara><simpara></simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>    ILI9340_BLACK   'hexidecimal value 0x0000
    ILI9340_RED     'hexidecimal value 0xF800
    ILI9340_GREEN   'hexidecimal value 0x07E0
    ILI9340_BLUE    'hexidecimal value 0x001F
    ILI9340_WHITE   'hexidecimal value 0xFFFF
    ILI9340_PURPLE  'hexidecimal value 0xF11F
    ILI9340_YELLOW  'hexidecimal value 0xFFE0
    ILI9340_CYAN    'hexidecimal value 0x07FF
    ILI9340_D_GRAY  'hexidecimal value 0x528A
    ILI9340_L_GRAY  'hexidecimal value 0x7997
    ILI9340_SILVER  'hexidecimal value 0xC618
    ILI9340_MAROON  'hexidecimal value 0x8000
    ILI9340_OLIVE   'hexidecimal value 0x8400
    ILI9340_LIME    'hexidecimal value 0x07E0
    ILI9340_AQUA    'hexidecimal value 0x07FF
    ILI9340_TEAL    'hexidecimal value 0x0410
    ILI9340_NAVY    'hexidecimal value 0x0010
    ILI9340_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara>For a ILI9340 datasheet, please refer <link xlink:href="http://gcbasic.sourceforge.net/library/DISPLAY/ILI9340.pdf">here</link>.</simpara>
<simpara>This example shows how to drive a ILI9340 based Graphic LCD module with the built in commands of GCBASIC.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F1937,32
    #config MCLRE_ON     'microcontroller specific configuration

    #include &lt;glcd.h&gt;

    'Defines for ILI9340
    #define GLCD_TYPE GLCD_TYPE_ILI9340

    'Pin mappings for ILI9340
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the ILI9340 Device")
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ili9341_controllers">
<title>ILI9341 Controllers</title>
<simpara>This section covers GLCD devices that use the ILI9341 graphics controller.  The ILI9341 is a TFT LCD Single Chip Driver with 240RGBx320 Resolution and 262K colors.</simpara>
<simpara>GCBASIC supports 65K-color mode operations.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the ILI9341 controller. &#160;&#160;&#160;GCBASIC supports SPI hardware and software connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the ILI9341 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9341

    'Pin mappings for ILI9341 - these MUST be specified
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting</screen>
<simpara>The GCBASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ILI9341</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HWSPIMode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the speed of the SPI communications for Hardware SPI only.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional defaults to MASTERFAST.
</simpara><simpara>Options are MASTERSLOW,<?asciidoc-br?>
MASTER,<?asciidoc-br?>
MASTERFAST, or<?asciidoc-br?>
MASTERULTRAFAST for specific AVRs only.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>240</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6</literal> for GCB fonts, and <literal>5</literal> for OLED fonts.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_OLED_FONT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the use of the optional OLED font set.
</simpara><simpara>The GLCDfntDefaultsize can be set to 1 or 2 only.
</simpara><simpara><literal>GLCDfntDefaultsize=  1</literal>.   A small 8 height pixel font with variable width.
<literal>GLCDfntDefaultsize=  2</literal>.   A larger 10 width * 16 height pixel font.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS  [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDRotate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the display</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LANDSCAPE</literal>, <literal>PORTRAIT_REV</literal>, <literal>LANDSCAPE_REV</literal> and <literal>PORTRAIT</literal> are supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9341_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ReadPixel</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read the pixel color at the specified XY coordination.  Returns long variable with Red, Green and Blue encoded in the lower 24 bits.</simpara></entry>
<entry align="left" valign="top"><simpara>ReadPixel( Xosition , Yposition ) or ReadPixel_ILI9341( Xosition , Yposition )
</simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>    ILI9341_BLACK   'hexidecimal value 0x0000
    ILI9341_RED     'hexidecimal value 0xF800
    ILI9341_GREEN   'hexidecimal value 0x07E0
    ILI9341_BLUE    'hexidecimal value 0x001F
    ILI9341_WHITE   'hexidecimal value 0xFFFF
    ILI9341_PURPLE  'hexidecimal value 0xF11F
    ILI9341_YELLOW  'hexidecimal value 0xFFE0
    ILI9341_CYAN    'hexidecimal value 0x07FF
    ILI9341_D_GRAY  'hexidecimal value 0x528A
    ILI9341_L_GRAY  'hexidecimal value 0x7997
    ILI9341_SILVER  'hexidecimal value 0xC618
    ILI9341_MAROON  'hexidecimal value 0x8000
    ILI9341_OLIVE   'hexidecimal value 0x8400
    ILI9341_LIME    'hexidecimal value 0x07E0
    ILI9341_AQUA    'hexidecimal value 0x07FF
    ILI9341_TEAL    'hexidecimal value 0x0410
    ILI9341_NAVY    'hexidecimal value 0x0010
    ILI9341_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara>For a ILI9341 datasheet, please refer <link xlink:href="http://gcbasic.sourceforge.net/library/DISPLAY/ILI9341.pdf">here</link>.</simpara>
<simpara>This example shows how to drive a ILI9341 based Graphic LCD module with the built in commands of GCBASIC.</simpara>
<simpara><emphasis role="strong">Example #1</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F1937,32
    #config MCLRE_ON      'microcontroller specific configuration

    #include &lt;glcd.h&gt;

    'Defines for ILI9341
    #define GLCD_TYPE GLCD_TYPE_ILI9341

    'Pin mappings for ILI9341
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the ILI9341 Device")
    end</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example #2</emphasis>
This example shows how to drive a ILI3941 with the OLED fonts.  Note the use of the <literal>GLCDfntDefaultSize</literal> to select the size of the OLED font in use.
<?asciidoc-br?></simpara>
<screen>    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ILI9341" )
    GLCDPrint ( 0, 34, "Size: 320 x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example #2</emphasis>
This example shows how to disable the large OLED Fontset.  This disables the font to reduce memory usage.</simpara>
<simpara>When the extended OLED fontset is disabled every character will be shown as a block character.
<?asciidoc-br?></simpara>
<screen>    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts
    #define GLCD_Disable_OLED_FONT2       'The constant to disable the extended OLED fontset.

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ILI9341" )
    GLCDPrint ( 0, 34, "Size: 320 x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ili9481_controllers">
<title>ILI9481 Controllers</title>
<simpara>This section covers GLCD devices that use the ILI9481 graphics controller.</simpara>
<simpara>ILI9481 is a 262k-color single-chip SoC driver for a-TFT liquid crystal display with resolution of 320&#160;RGB&#160;x&#160;480&#160;
dots, comprising a 960-channel source driver, a 480-channel gate driver, 345,600 bytes GRAM for graphic data.</simpara>
<simpara>GCBASIC supports 65K-color mode operations.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the ILI9481controller.
&#160;&#160;&#160;The GCBASIC constants for control and data line connections are shown
in the table below. Two options are available for connectivity:</simpara>
<simpara>1)  The 8-bit mode where 8 pins are connected between the microcontroller and the GLCD to control the
data bus.</simpara>
<simpara>2)  The 16-bit mode where two data ports (8 pins each) are connected between  the microcontroller and the GLCD to control the data bus.</simpara>
<simpara>To use the ILI9481 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">8-bit mode</emphasis></simpara>
<screen>    'Pin mappings for Data Bus Interface (DBI)
    'this GLCD driver supports 8 bit and 16 bit parallel data lines

    '8 bit DBI
    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9481

    '8 bit control and parallel data lines (UNO Board)
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line

    #define GLCD_DB0       DIGITAL_8        'Data port'
    #define GLCD_DB1       DIGITAL_9        'Data port'
    #define GLCD_DB2       DIGITAL_2        'Data port'
    #define GLCD_DB3       DIGITAL_3        'Data port'
    #define GLCD_DB4       DIGITAL_4        'Data port'
    #define GLCD_DB5       DIGITAL_5        'Data port'
    #define GLCD_DB6       DIGITAL_6        'Data port'
    #define GLCD_DB7       DIGITAL_7        'Data port'</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">16-bit mode</emphasis></simpara>
<screen>    '16 bit DBI
    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_ILI9481
    #define GLCD_ILI9481_16bit

    '16 bit control and dual data port lines (Mega2560 Board)
    #define ILI9481_GLCD_CS PortG.1    'Chip Select line
    #define ILI9481_GLCD_RS PortD.7    'DC data command line
    #define ILI9481_GLCD_WR PortG.2    'Write command line
    #define ILI9481_GLCD_RST PortG.0    'Reset line

    #define ILI9481_DataPortH PortA    'DB[15:8]
    #define ILI9481_DataPortL PortC    'DB[7:0]</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The GCBASIC constants for the interface to the controller are shown in the table below.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ILI9481</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_ILI9481_16bit</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies 16 bit DBI mode</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB0..7</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the  pin that is connected to DB0..7 IO pin on the GLCD (8 bit DBI).</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9481_DataPortH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the  port DB[15:8] pins on the GLCD (16 bit DBI).</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9481_DataPortL</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the  port DB[7:0] pins on the GLCD (16 bit DBI).</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RST</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (RW or WDR) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RD</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (RD or RDR) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The GCBASIC constants for control display characteristics are shown in the table below.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>480</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS  [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDRotate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the display</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LANDSCAPE</literal>, <literal>PORTRAIT_REV</literal>, <literal>LANDSCAPE_REV</literal> and <literal>PORTRAIT</literal> are supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9481_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?>
</simpara><simpara></simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    ILI9481_BLACK   'hexidecimal value 0x0000
    ILI9481_RED     'hexidecimal value 0xF800
    ILI9481_GREEN   'hexidecimal value 0x0400
    ILI9481_BLUE    'hexidecimal value 0x001F
    ILI9481_WHITE   'hexidecimal value 0xFFFF
    ILI9481_PURPLE  'hexidecimal value 0xF11F
    ILI9481_YELLOW  'hexidecimal value 0xFFE0
    ILI9481_CYAN    'hexidecimal value 0x07FF
    ILI9481_D_GRAY  'hexidecimal value 0x528A
    ILI9481_L_GRAY  'hexidecimal value 0x7997
    ILI9481_SILVER  'hexidecimal value 0xC618
    ILI9481_MAROON  'hexidecimal value 0x8000
    ILI9481_OLIVE   'hexidecimal value 0x8400
    ILI9481_LIME    'hexidecimal value 0x07E0
    ILI9481_AQUA    'hexidecimal value 0x07FF
    ILI9481_TEAL    'hexidecimal value 0x0410
    ILI9481_NAVY    'hexidecimal value 0x0010
    ILI9481_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>These examples show how to drive a ILI9481 based Graphic LCD module with the built in commands of GCBASIC.  The 8 bit DBI example uses a UNO shield, this can easily adapted to Microchip architecture.  The 16 bit DBI
example uses a Mega2560 board.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Examples:</emphasis></simpara>
<screen>    '8 bit DBI
    #include &lt;glcd.h&gt;
    #include &lt;UNO_mega328p.h &gt;

    #define GLCD_TYPE GLCD_TYPE_ILI9481

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line

    #define GLCD_DB0       DIGITAL_8
    #define GLCD_DB1       DIGITAL_9
    #define GLCD_DB2       DIGITAL_2
    #define GLCD_DB3       DIGITAL_3
    #define GLCD_DB4       DIGITAL_4
    #define GLCD_DB5       DIGITAL_5
    #define GLCD_DB6       DIGITAL_6
    #define GLCD_DB7       DIGITAL_7

    GLCDPrint(0, 0, "Test of the ILI9481 Device")
    end</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    '16 bit DBI
    #chip mega2560, 16
    #include &lt;glcd.h&gt;

    #define GLCD_TYPE GLCD_TYPE_ILI9481
    #define GLCD_ILI9481_16bit

    #define ILI9481_GLCD_CS PortG.1
    #define ILI9481_GLCD_RS PortD.7
    #define ILI9481_GLCD_WR PortG.2
    #define ILI9481_GLCD_RST PortG.0
    #define ILI9481_DataPortH PortA
    #define ILI9481_DataPortL PortC

    #define ILI9481_YELLOW1   0xFFC1
    #define ILI9481_BlueViolet  0x895C

    GLCDCLS_ILI9481 ILI9481_Black
    wait 1 s
    GLCDCLS_ILI9481 ILI9481_White
    wait 1 s

    GLCDfntDefaultsize = 3
    GLCDBackground = ILI9481_BlueViolet
    GLCDForeground = ILI9481_Yellow1
    GLCDCLS
    wait 1 s

    Start:

    'demonstrate screen rotation
    GLCDRotate (Portrait)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 - 24, "ILI9481 Driver")
    wait 5 s

    GLCDRotate (Landscape)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 -24, "ILI9481 Driver")
    wait 5 s

    GLCDRotate (Portrait_REV)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 - 24, "ILI9481 Driver")
    wait 5 s

    GLCDRotate (Landscape_REV)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 - 24, "ILI9481 Driver")
    wait 5 s

    goto Start</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>,  <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link>
<?asciidoc-br?>
<?asciidoc-br?>
Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ili9486_l_controllers">
<title>ILI9486(L) Controllers</title>
<simpara>This section covers GLCD devices that use the ILI9486(L) graphics controller.</simpara>
<simpara>The ILI9486(L) is a 262kcolor single-chip SoC driver for a-Si TFT liquid crystal display with resolution of
320RGBx480 dots, comprising a 960-channel source driver, a 480-channel gate driver, 345,600bytes GRAM for
graphic data of 320RGBx480 dots.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the ILI9486(L) controller. &#160;&#160;&#160;GCBASIC supports 1) SPI using the SPI hardware module, 2) software SPI, 3) UNO shields and 4) an 8bit port bus - this is detailed in the tables below.</simpara>
<simpara>GCBASIC supports 65K-color mode operations.</simpara>
<simpara>To use the ILI9486(L) driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9486L</screen>
<simpara>The GCBASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ILI9486L</literal> or <literal>GLCD_TYPE_ILI9486</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SLK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for the communicaton protocol for the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="27*"/>
<colspec colname="col_2" colwidth="36*"/>
<colspec colname="col_3" colwidth="36*"/>
<thead>
<row>
<entry align="left" valign="top"><literal>Communications Constants</literal></entry>
<entry align="left" valign="top">Use</entry>
<entry align="left" valign="top">Comments</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9486L_HardwareSPI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that hardware SPI will be used</simpara></entry>
<entry align="left" valign="top"><simpara>SPI ports MUST be defined that match the SPI module for each specific microcontroller
</simpara><simpara>    <emphasis role="strong">#define ILI9486L_HardwareSPI</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HWSPIMode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the speed of the SPI communications for Hardware SPI only.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional defaults to MASTERFAST.
</simpara><simpara>Options are MASTERSLOW,<?asciidoc-br?>
MASTER,<?asciidoc-br?>
MASTERFAST, or<?asciidoc-br?>
MASTERULTRAFAST for specific AVRs only.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>UNO_8bit_Shield</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that a UNO shield will be used</simpara></entry>
<entry align="left" valign="top"><simpara>The shield will use 13 ports.  These ports are pre-defined by the shield. These ports must be specified.
</simpara><simpara>    <emphasis role="strong">#define UNO_8bit_Shield</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DataPort</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that a full 8 port will be used</simpara></entry>
<entry align="left" valign="top"><simpara>The microcontroller will use 13 ports.  These port is defined as 8 contigous bits. These control port and the data port must be specified.
</simpara><simpara>    <emphasis role="strong">#define GLCD_DataPort portb</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>480</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2  [,Optional In LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDRotate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the display</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LANDSCAPE</literal>, <literal>PORTRAIT_REV</literal>, <literal>LANDSCAPE_REV</literal> and <literal>PORTRAIT</literal> are supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9486L_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?>
</simpara><simpara></simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>    TFT_BLACK   'hexidecimal value 0x0000
    TFT_RED     'hexidecimal value 0xF800
    TFT_GREEN   'hexidecimal value 0x07E0
    TFT_BLUE    'hexidecimal value 0x001F
    TFT_WHITE   'hexidecimal value 0xFFFF
    TFT_PURPLE  'hexidecimal value 0xF11F
    TFT_YELLOW  'hexidecimal value 0xFFE0
    TFT_CYAN    'hexidecimal value 0x07FF
    TFT_D_GRAY  'hexidecimal value 0x528A
    TFT_L_GRAY  'hexidecimal value 0x7997
    TFT_SILVER  'hexidecimal value 0xC618
    TFT_MAROON  'hexidecimal value 0x8000
    TFT_OLIVE   'hexidecimal value 0x8400
    TFT_LIME    'hexidecimal value 0x07E0
    TFT_AQUA    'hexidecimal value 0x07FF
    TFT_TEAL    'hexidecimal value 0x0410
    TFT_NAVY    'hexidecimal value 0x0010
    TFT_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara>For a ILI9486L datasheet, please refer to Google.</simpara>
<simpara>This example shows how to drive a ILI9486L based Graphic LCD module with the built in commands of GCBASIC.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip mega328p, 16
    #option explicit

    #include &lt;glcd.h&gt;
    #include &lt;UNO_mega328p.h &gt;

    #define GLCD_TYPE GLCD_TYPE_ILI9486L

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       DIGITAL_8           ' Data command line
    #define GLCD_CS       DIGITAL_10          ' Chip select line
    #define GLCD_RST      DIGITAL_9           ' Reset line

    #define GLCD_DI       DIGITAL_13          ' Data in | MISO
    #define GLCD_DO       DIGITAL_11          ' Data out | MOSI
    #define GLCD_SCK      DIGITAL_13          ' Clock Line

    #define ILI9486L_HardwareSPI              ' Remove/comment out if you want to use software SPI.


    GLCDPrint(0, 0, "Test of the ILI9486L Device")
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ili9488_controllers">
<title>ILI9488 Controllers</title>
<simpara>This section covers GLCD devices that use the ILI9488 graphics controller.</simpara>
<simpara>ILI9488 is a 262k-color single-chip SoC driver for a-TFT liquid crystal display with resolution of 320 x 240 resolution, 16.7M-color and with internal GRAM .</simpara>
<simpara>GCBASIC supports 65K-color mode operations.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the ILI9488 controller.
&#160;&#160;&#160;The GCBASIC constants for control and data line connections are shown
in the table below. Only SPI is available for connectivity:</simpara>
<simpara>To use the ILI9488 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">SPI mode</emphasis></simpara>
<screen>    'Pin mappings for SPI

    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9488

    #DEFINE GLCD_DC       PORTB.3           ' Data command line
    #DEFINE GLCD_CS       PORTB.5           ' Chip select line
    #DEFINE GLCD_RST      PORTB.4           ' Reset line

    #DEFINE GLCD_DI       PORTB.2          ' Data in | MISO
    #DEFINE GLCD_DO       PORTB.0          ' Data out | MOSI
    #DEFINE GLCD_SCK      PORTB.1          ' Clock Line</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The GCBASIC constants for the interface to the controller are shown in the table below.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>GLCD_TYPE_ILI9488</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9488_HARDWARESPI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies to use the microcontrollers SPI module.
For PPS microcontrollers the libary assumes PPS for SPI has been configured.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HWSPIMODE MASTERFAST</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the speed of the SPI communications.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RST</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (RW or WDR) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (RD or RDR) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The GCBASIC constants for control display characteristics are shown in the table below.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>480</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;Always review the appropiate library for the latest full set of supported commands.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS  [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDRotate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the display</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LANDSCAPE</literal>, <literal>PORTRAIT_REV</literal>, <literal>LANDSCAPE_REV</literal> and <literal>PORTRAIT</literal> are supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9488__TFT_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below, butm you can use the generic TFT color scheme.<?asciidoc-br?>
</simpara><simpara></simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    ILI9488_TFT_BLACK       //0x000000
    ILI9488_TFT_RED         //0xFC0000
    ILI9488_TFT_GREEN       //0x00FC00
    ILI9488_TFT_BLUE        //0x0000FC
    ILI9488_TFT_WHITE       //0xFFFFFF

    ILI9488_TFT_CYAN        //0x003F3F
    ILI9488_TFT_DARKCYAN    //0x00AFAF
    ILI9488_TFT_DARKGREEN   //0x002100
    ILI9488_TFT_DARKGREY    //0xAAAAAA
    ILI9488_TFT_GREENYELLOW //0x93FC33
    ILI9488_TFT_LIGHTGREY   //0xC9C9C9
    ILI9488_TFT_MAGENTA     //0xCC00CC
    ILI9488_TFT_MAROON      //0x7E007E
    ILI9488_TFT_NAVY        //0x00003E
    ILI9488_TFT_OLIVE       //0x783E00
    ILI9488_TFT_ORANGE      //0xFC2900
    ILI9488_TFT_PINK        //0xFC000F
    ILI9488_TFT_PURPLE      //0xF01F9E
    ILI9488_TFT_YELLOW      //0xFC7E00</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>These examples show how to drive a ILI9488 based Graphic LCD module with the built in commands of GCBASIC.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Examples - PPS Enabled</emphasis></simpara>
<screen>    #chip 18F26K83, 64
    #option Explicit

    'Generated by PIC PPS Tool for GCBASIC
    #startup InitPPS, 85
    #DEFINE PPSToolPart 18f26k83

    Sub InitPPS
        'Module: UART pin directions
        Dir PORTC.7 Out    ' Make TX1 pin an output
        'Module: UART1
        RC7PPS = 0x0013    'TX1 &gt; RC7

        #IFDEF ILI9488_HardwareSPI
            UNLOCKPPS
            'Module: SPI1
            RB0PPS = 0x001F    'SDO1 &gt; RB0
            RB1PPS = 0x001E    'SCK1 &gt; RB1
            SPI1SCKPPS = 0x0009    'RB1 &gt; SCK1 (bi-directional)
            SPI1SDIPPS = 0x000A    'RB2 &gt; SDI1
        #ELSE
            RB0PPS = 0
            RB1PPS = 0
        #ENDIF
    End Sub
    // Template comment at the end of the config file

    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9488
    #DEFINE ILI9488_HARDWARESPI
    #DEFINE HWSPIMODE MASTERFAST
    #DEFINE GLCD_DC       PORTB.3           ' Data command line
    #DEFINE GLCD_CS       PORTB.5           ' Chip select line
    #DEFINE GLCD_RST      PORTB.4           ' Reset line

    #DEFINE GLCD_DI       PORTB.2          ' Data in | MISO
    #DEFINE GLCD_DO       PORTB.0          ' Data out | MOSI
    #DEFINE GLCD_SCK      PORTB.1          ' Clock Line

    '''********************************************************************************

    'main program start here

    // Set the background
    #DEFINE DEFAULT_GLCDBACKGROUND TFT_WHITE


    GLCDPrint 0, 0, "Test of the ILI9488 Device", TFT_BLACK
    end</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Examples - Legacy non PPS microcontroller</emphasis></simpara>
<screen>    #chip 16F1939
    #option Explicit



    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9488
    #DEFINE GLCD_DC       PORTB.3           ' Data command line
    #DEFINE GLCD_CS       PORTB.5           ' Chip select line
    #DEFINE GLCD_RST      PORTB.4           ' Reset line

    #DEFINE GLCD_DI       PORTB.2          ' Data in | MISO
    #DEFINE GLCD_DO       PORTB.0          ' Data out | MOSI
    #DEFINE GLCD_SCK      PORTB.1          ' Clock Line

    '''********************************************************************************

    'main program start here

    // Set the background
    #DEFINE DEFAULT_GLCDBACKGROUND TFT_WHITE


    GLCDPrint 0, 0, "Test of the ILI9488 Device", TFT_BLACK
    end</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen></screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>,  <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link>
<?asciidoc-br?>
<?asciidoc-br?>
Supported in &lt;GLCD.H&gt;</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Developer Notes</emphasis></simpara>
<simpara>The ILI9488 library implemented uses BRG color scheme which is different from other GLCD libraries.</simpara>
<simpara>The ILI9488 library implemented also uses 18bits for color definition where the color scheme is defined as shown below:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/ili9488.png" contentdepth="100%" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The ILI9488 library implemented there has the following differences from a typical GLCD library.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The colors are defined as RGB left justified 6 bits.</simpara>
</listitem>
<listitem>
<simpara>The colors are defined as Longs ( not Words other GLCDs are Words).</simpara>
</listitem>
<listitem>
<simpara>The color information uses a 18bit macro for SPI communications.&#160;&#160;Color information is sent to the GLCD in three bytes.</simpara>
</listitem>
<listitem>
<simpara>The color contraints are based on the SPI constraints specified in the ILI9488 datasheet.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_ks0108_controllers">
<title>KS0108 Controllers</title>
<simpara>This section covers GLCD devices that use the KS0108 graphics controller.</simpara>
<simpara>The KS0108 is an LCD is driven by on-board 5V parallel interface chipset KS0108 and KS0107. They are extremely common and well documented</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the KS0108 controller. &#160;&#160;&#160;The only connectivity option is the 8-bit mode where 8 connections (for the data) are required between the microcontroller and the GLCD to control the data bus.</simpara>
<simpara>The KS0108 is a monochrome device.</simpara>
<simpara>To use the KS0108 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_KS0108


    #define GLCD_RW       PORTB.1            'chip specific configuration
    #define GLCD_RESET    PORTB.5            'chip specific configuration
    #define GLCD_CS1      PORTB.3            'chip specific configuration
    #define GLCD_CS2      PORTB.4            'chip specific configuration
    #define GLCD_RS       PORTB.0            'chip specific configuration
    #define GLCD_ENABLE   PORTB.2            'chip specific configuration
    #define GLCD_DB0      PORTC.7            'chip specific configuration
    #define GLCD_DB1      PORTC.6            'chip specific configuration
    #define GLCD_DB2      PORTC.5            'chip specific configuration
    #define GLCD_DB3      PORTC.4            'chip specific configuration
    #define GLCD_DB4      PORTC.3            'chip specific configuration
    #define GLCD_DB5      PORTC.2            'chip specific configuration
    #define GLCD_DB6      PORTC.1            'chip specific configuration
    #define GLCD_DB7      PORTC.0            'chip specific configuration</screen>
<simpara>The GCBASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_KS0108</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Register Select on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the GLCD.
The R/W pin can be disabled.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis> <emphasis>(unless R/W is disabled)<?asciidoc-br?>
see</emphasis> <literal>GLCD_NO_RW</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>CS1</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>CS2</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_ENABLE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>Enable</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB0</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB0</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB1</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB2</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB3</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB3</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB4</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB5</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB5</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB6</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB6</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB7</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB7</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_NO_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disables read/write inspection of the device during read/write
operations</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, but recommend NOT to set.
The R/W pin can be disabled by setting the <literal>GLCD_NO_RW</literal> constant. If this
is done, there is no need for the R/W to be connected to the chip, and
no need for the <literal>LCD_RW</literal> constant to be set. Ensure that the R/W line on
the LCD is connected to ground if not used.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DATA_PORT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Not Available for this controller.</simpara></entry>
<entry align="left" valign="top"><simpara>Not applicable.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants defined for the controller type are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>128</literal>
This constant cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>64</literal>
This constant cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDirection</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defining this will invert the Y Axis</simpara></entry>
<entry align="center" valign="top"><simpara>Not defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KS0108ReadDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read delay</simpara></entry>
<entry align="center" valign="top"><simpara>Default is   9
</simpara><simpara>Can be set to improve overall performance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KS0108WriteDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Write delay</simpara></entry>
<entry align="center" valign="top"><simpara>Default is   1
</simpara><simpara>Can be set to improve performance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KS0108ClockDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clock Delay</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 1
</simpara><simpara>Can be set to improve performance.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Variables</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Width of the current GLCD font.</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 6 pixels.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 0.
</simpara><simpara>This equates to the standard GCB font set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefaultsize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 1.
</simpara><simpara>This equates to the 8 pixel high.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the
table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a KS0108 datasheet, please refer
<link xlink:href="http://www.vishay.com/docs/37329/37329.pdf">here.</link></simpara>
<simpara>This example shows how to drive a KS0108 based Graphic LCD module with
the built in commands of GCBASIC. See
<link xlink:href="http://www.greatcowbasic.com/sample-projects.html">Graphic LCD</link> for
details, this is an external web site.</simpara>
<screen>    ;Chip Settings
    #chip 16F886,16
    '#config MCLRE = on 'enable reset switch on CHIPINO
    #include &lt;GLCD.h&gt;

    ;Defines (Constants)
    #define GLCD_RW PORTB.1  'D9 to pin 5 of LCD
    #define GLCD_RESET PORTB.5 'D13 to pin 17 of LCD
    #define GLCD_CS1 PORTB.3 'D12 to actually since CS1, CS2 can be reversed on some devices
    #define GLCD_CS2 PORTB.4 'D11 to actually since CS1, CS2 can be reversed on some devices
    #define GLCD_RS PORTB.0  'D8 to pin 4 D/I pin on LCD
    #define GLCD_ENABLE PORTB.2 'D10 to Pin 6 on LCD
    #define GLCD_DB0 PORTC.7 'D0 to pin 7 on LCD
    #define GLCD_DB1 PORTC.6 'D1 to pin 8 on LCD
    #define GLCD_DB2 PORTC.5 'D2 to pin 9 on LCD
    #define GLCD_DB3 PORTC.4 'D3 to pin 10 on LCD
    #define GLCD_DB4 PORTC.3 'D4 to pin 11 on LCD
    #define GLCD_DB5 PORTC.2 'D5 to pin 12 on LCD
    #define GLCD_DB6 PORTC.1 'D6 to pin 13 on LCD
    #define GLCD_DB7 PORTC.0 'D7 to pin 14 on LCD

    Do forever
        GLCDCLS
        GLCDPrint 0,10,"Hello" 'Print Hello
        wait 5 s
        GLCDPrint 0,10, "ASCII #:" 'Print ASCII #:
        Box 18,30,28,40                    'Draw Box Around ASCII Character
        for char = 15 to 129            'Print 0 through 9
          GLCDPrint 17, 20 , Str(char)+"  "
          GLCDdrawCHAR 20,30, char
          wait 125 ms
        next
        line 0,50,127,50                'Draw Line using line command
        for xvar = 0 to 80            'draw line using Pset command
            pset xvar,63,on                    '
        next                                        '
        Wait 1 s
        GLCDPrint 0,10,"End  " 'Print Hello
        wait 1 s
    Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_nextion_controllers">
<title>NEXTION Controllers</title>
<simpara>This section covers GLCD devices that use the serially attached Nextion graphics displays.</simpara>
<simpara>Nextion includes hardware part (a series of TFT boards) and software part (the Nextion
editor (<link xlink:href="http://nextion.itead.cc/)">http://nextion.itead.cc/)</link>).</simpara>
<simpara>The Nextion TFT board uses only one serial port to communicate. &#160;&#160;It lets you avoid the hassle of wiring.&#160;&#160;Nextion
editor has mass components such as button, text, progress bar, slider, instrument panel etc.
to enrich your interface design.&#160;&#160; And, the drag-and-drop function ensures that you spend less
time in programming</simpara>
<simpara>The Nextion displays are 2.4 to 7.0 inches and range from 320*240 to 800*480 pixels.&#160;&#160; The connections are 5v, 0v, SerialIn and SerialOut.&#160;&#160; GCBASIC supports hardware and software serial connectivity.</simpara>
<simpara>See GITHUB for the set of GCBASIC demonstrations fro the Nextion displays.  See <link xlink:href="https://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/GLCD%20%20Solutions/GLCD%20Nextion%20Solutions">Nextion demonstrations on GITHUB</link>.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
To use the Nextion driver simply include the following in your user code.  This will initialise the driver.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Setup for Hardware Serial</emphasis></simpara>
<screen>' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #option explicit

' ----- Set up the Nextion GLCD
    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_Nextion


    ;VERY IMPORTANT!!
    ;Change the width and height to match the rotation in the Nextion Editor
    #define GLCD_WIDTH  320   'could be 320 | 400 | 272 | 480 but any valid dimension will work.
    #define GLCD_HEIGHT 240  'could be 240 | 480 | 800 but any valid dimension will work.


    ;VERY IMPORTANT!!
    ;Fonts installed in the Nextion MUST match the fonts parameters loading to the GLCD.
    ;Obtain parameters from Nextion Editor/Font dialog.
    #define NextionFont0      0, 8, 16    'Arial 8x16
    #define NextionFont1      1, 12, 24   '24point 12x24 charset
    #define NextionFont2      2, 16, 32   '32point 16x32 charset

' ----- End of set up for Nextion GLCD

' ----- Set up for Hardware Serial
    ;VERY IMPORTANT!!
    ;The Nextion MUST be setup for 9600 bps.
    #define USART_BAUD_RATE 9600
    #define USART_BLOCKING

    ;VERY IMPORTANT!!
    ;These two are optional. These constants are set in the library.
    #define GLCD_NextionSerialPrint HSerPrint
    #define GLCD_NextionSerialSend  HSerSend

' ----- End of set up for Serial


    'Generated by PIC PPS Tool for GCBASIC
    'PPS Tool version: 0.0.5.11
    'PinManager data: v1.55
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: EUSART
            RXPPS = 0x0016    'RC6 &gt; RX

            'Module: EUSART
            RC0PPS = 0x0010    'TX &gt; RC0
            TXPPS = 0x0010    'RC0 &gt; TX (bi-directional)
            RC5PPS = 0x0010    'TX &gt; RC5
            TXPPS = 0x0015    'RC5 &gt; TX (bi-directional)

    End Sub
    'Template comment at the end of the config file


' ----- Main program starts
....</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Setup for Software Serial</emphasis></simpara>
<screen>' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #option explicit

' ----- Set up the Nextion GLCD
    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_Nextion


    ;VERY IMPORTANT!!
    ;Change the width and height to match the rotation in the Nextion Editor
    #define GLCD_WIDTH  320   'could be 320 | 400 | 272 | 480 but any valid dimension will work.
    #define GLCD_HEIGHT 240  'could be 240 | 480 | 800 but any valid dimension will work.


    ;VERY IMPORTANT!!
    ;Fonts installed in the Nextion MUST match the fonts parameters loading to the GLCD.
    ;Obtain parameters from Nextion Editor/Font dialog.
    #define NextionFont0      0, 8, 16    'Arial 8x16
    #define NextionFont1      1, 12, 24   '24point 12x24 charset
    #define NextionFont2      2, 16, 32   '32point 16x32 charset

' ----- End of set up for Nextion GLCD

' ----- Set up for Software Serial - this is optional - shown to explain the method.
    ;Remove Hardware Serial before using Software serial
    ;You MUST also remove PPS setup, for hardware serial, when using Software serial
    #include &lt;SoftSerial.h&gt;

    ; ----- Config Serial UART for sending:
    #define SER1_BAUD 9600     ; baudrate must be defined
    #define SER1_TXPORT PORTC ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 5       ; portbit  must be defined

    ;VERY IMPORTANT!!
    ;These two constants are required to support the the library.
    #define GLCD_NextionSerialPrint        Ser1Print
    #define GLCD_NextionSerialSend         Ser1Send
'
' ----- End of set up for Serial

' ----- Main program starts</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The GCBASIC constants shown below control the configuration of the Nextion controller.
&#160;&#160;&#160;The GCBASIC constants for control and data line connections are shown
in the table below.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_Nextion</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_NextionSerialPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Default is <literal>HSerPrint</literal> for hardware serial can be <literal>SernPrint</literal> when using software serial.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_NextionSerialSend</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Default is <literal>HSerSend</literal> for hardware serial can be <literal>SernSend</literal> when using software serial.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The GCBASIC constants for control display characteristics are shown in the table below.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Mandated. The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Mandated. The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>480</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The GCBASIC Nextion specific commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint_Nextion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using Nextion font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable [,NextionFont] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDLocateString_Nextion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Locate the screen coordinates at a specific location.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDLocateString_Nextion( Xposition, Yposition)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrintString_Nextion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using Nextion font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrintString_Nextion( Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrintStringLn_Nextion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using Nextion font set adding a newline and carriage return to move cursort to start of next line.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrintStringLn_Nextion( Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDSendOpInstruction_Nextion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Send the Nextion display a specific command and a specific value</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDSendOpInstruction_Nextion( Nextion_command, command_value )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDUpdateObject_Nextion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Update a Nextion display object with a specific value</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDUpdateObject_Nextion( Nextion_object, object_value )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>myReturnedWordValue  = GLCDGetTouch_Nextion( "nextion_command_string" )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A function that returns a long, that can be treated as word variable, value of the Touch event..&#160;&#160;As follows:
<?asciidoc-br?>
<?asciidoc-br?>
"tch0" for current x co-ordinate touched
</simpara><simpara>"tch1" for current y co-ordinate touched
</simpara><simpara>"tch2" for last x co-ordinate touched
</simpara><simpara>"tch3" for last y co-ordinate touched
<?asciidoc-br?>
<?asciidoc-br?>
The function is non-blocking.
</simpara><simpara>1. Checks for three bytes of 0xFF. If Four 0xff are received then exit = non-block.
</simpara><simpara>2. If at any time a 0x71 is recieved then we have data for the event.
</simpara><simpara>3. If seven bytes arrive, but the method did not receive a 0x71  then exit = non-block.
</simpara><simpara>4. The method supports software and hardware serial. As does all the other methods.
</simpara><simpara>5. The method uses a function to receive the data not a sub-routine.
</simpara><simpara>6. The method returns 0xBEEF if there is an invalid read, and, functional value for GLCDGetTouch_Nextion will also be set to 0xDEADBEEF</simpara></entry>
<entry align="left" valign="top"><simpara>myReturnedWordValue  = GLCDGetTouch_Nextion( "tch2")
</simpara><simpara>or,
</simpara><simpara>myReturnedWordValue  = GLCDGetTouch_Nextion( "tch3")</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The GCBASIC commonn commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS  [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    TFT_BLACK   'hexidecimal value 0x0000
    TFT_RED     'hexidecimal value 0xF800
    TFT_GREEN   'hexidecimal value 0x0400
    TFT_BLUE    'hexidecimal value 0x001F
    TFT_WHITE   'hexidecimal value 0xFFFF
    TFT_PURPLE  'hexidecimal value 0xF11F
    TFT_YELLOW  'hexidecimal value 0xFFE0
    TFT_CYAN    'hexidecimal value 0x07FF
    TFT_D_GRAY  'hexidecimal value 0x528A
    TFT_L_GRAY  'hexidecimal value 0x7997
    TFT_SILVER  'hexidecimal value 0xC618
    TFT_MAROON  'hexidecimal value 0x8000
    TFT_OLIVE   'hexidecimal value 0x8400
    TFT_LIME    'hexidecimal value 0x07E0
    TFT_AQUA    'hexidecimal value 0x07FF
    TFT_TEAL    'hexidecimal value 0x0410
    TFT_NAVY    'hexidecimal value 0x0010
    TFT_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>
<?asciidoc-br?>
<?asciidoc-br?>
Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_nt7108c_controllers">
<title>NT7108C Controllers</title>
<simpara>This section covers GLCD devices that use the NT7108C graphics controller.
<?asciidoc-br?>
<?asciidoc-br?>
The NT7108C is an GLCD is driven by on-board 5V parallel interface chipset NT7108C.&#160;&#160;&#160;They are similar to the KS0108.
<?asciidoc-br?>
<?asciidoc-br?>
The GLCD controller is the Winstar WDG0151-TMI module, which is a 128×64 pixel monochromatic display.&#160;&#160;&#160;
It uses two Neotic display controller chips: NT7108C and NT7107C, which are similar with Samsung KS0108B and KS0107B controllers.&#160;&#160;&#160;
The controller uses a dot matrix LCD segment driver with 64 channel output, and therefore, the WDG0151 module contains two sets of it to drive 128 segments.
<?asciidoc-br?>
<?asciidoc-br?>
The GCBASIC constants shown below control the configuration of the NT7108C controller.&#160;&#160;&#160;
The connectivity options are as follows, This is required between the microcontroller and the GLCD to control the data bus.:</simpara>
<itemizedlist>
<listitem>
<simpara>A  full port mode.&#160;&#160; Where a full data port therefore eight contiguous port.bits.&#160;&#160;  The port is used the data communications.</simpara>
</listitem>
<listitem>
<simpara>Eight port.bits mode.&#160;&#160;  This option allows for greater flexibility with the configuration but will operate slower then the full port mode.&#160;&#160;    These port.bits are used the data communications.
<?asciidoc-br?>
To use the NT7108C driver simply include the following in your user code.  This will initialise the driver.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
<screen>    ;Full port mode
    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_NT7108C


   #define GLCD_DATA_PORT PORTD       'Data Port

   #define GLCD_CS1 PORTC.1           'CS1 control line
   #define GLCD_CS2 PORTC.0           'CS2 control line
   #define GLCD_RS PORTe.0            'RS control line
   #define GLCD_Enable PORTe.2        'Enable control line
   #define GLCD_RW PORTc.3            'RW control line
   #define GLCD_RESET PORTC.2         'Reset control line</screen>
<simpara>or</simpara>
<screen>    ;Eight port.bits mode
    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_NT7108C


    ;Defines (Constants)
    ;Define port as 8 port,bit(s)
    #define GLCD_DB0 PORTA.2    'Data Port.bit 0
    #define GLCD_DB1 PORTC.0    'Data Port.bit 1
    #define GLCD_DB2 PORTC.1    'Data Port.bit 2
    #define GLCD_DB3 PORTC.2    'Data Port.bit 3
    #define GLCD_DB4 PORTB.4    'Data Port.bit 4
    #define GLCD_DB5 PORTB.5    'Data Port.bit 5
    #define GLCD_DB6 PORTB.6    'Data Port.bit 6
    #define GLCD_DB7 PORTB.7    'Data Port.bit 7
    ;End of define as 8 port,bit(s)

    #define GLCD_CS1 PORTC.7    'CS1 control line
    #define GLCD_CS2 PORTC.6    'CS2 control line
    #define GLCD_RS PORTC.5     'RS control line
    #define GLCD_ENABLE PORTA.4 'Enable control line
    #define GLCD_RW PORTC.4     'RW control line
    #define GLCD_RESET PORTC.3  'Reset control line</screen>
<simpara>The GCBASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_NT7108C</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Register Select on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>CS1</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>CS2</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_ENABLE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>Enable</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Full port mode</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DATA_PORT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the port that is connected to 8 connections on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required when using full port mode</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Eight port.bits mode</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB0</literal><?asciidoc-br?>
<literal>GLCD_DB1</literal><?asciidoc-br?>
..<?asciidoc-br?>
<literal>GLCD_DB7</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the port.bit that is connected to a single connection on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required when using eight port.bits mode</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants defined for the controller type are shown in the table below.  The NT7108C is very sensitive to clock timings.&#160;&#160;&#160;You may to adjust the clock timing to ensure the display operates correctly.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>128</literal>
This constant cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>64</literal>
This constant cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDirection</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defining this will invert the Y Axis</simpara></entry>
<entry align="center" valign="top"><simpara>Not defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NT7108CReadDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read delay</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 7
</simpara><simpara>Can be set to improve overall performance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NT7108CWriteDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Write delay</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 7
</simpara><simpara>Can be set to improve performance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NT7108CClockDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clock Delay</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 7
</simpara><simpara>Can be set to improve performance.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Variables</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Width of the current GLCD font.</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 6 pixels.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 0.
</simpara><simpara>This equates to the standard GCB font set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefaultsize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 1.
</simpara><simpara>This equates to the 8 pixel high.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the
table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a NT7108C datasheet, please refer
<link xlink:href="http://www.farnell.com/datasheets/1878006.pdf">here.</link></simpara>
<simpara>This example shows how to drive a NT7108C based Graphic LCD module with
the built in commands of GCBASIC. See <link xlink:href="https://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/">Graphic LCD</link> for
details, this is an external web site.</simpara>
<screen>  ;Chip Settings
  #chip 16F1939,32
  #option explicit
  #config MCLRE_On

   #include &lt;glcd.h&gt;
   #define GLCD_TYPE GLCD_TYPE_NT7108C               ' Specify the GLCD type
   #define GLCDDirection 0                           ' Flip the GLCD   0 do not flip, 1 flip

   'Setup the device
   #define GLCD_CS1 PORTC.1    'D12 to actually since CS1, CS2 can be reversed on some devices
   #define GLCD_CS2 PORTC.0
   #define GLCD_DATA_PORT PORTD
   #define GLCD_RS PORTe.0
   #define GLCD_Enable PORTe.2
   #define GLCD_RW PORTc.3
   #define GLCD_RESET PORTC.2

   GLCDPrint ( 4,   1, "GCBASIC 2021")                                ; Print some text

   Box  0, 0, 127, 10
   Line 63, 10, 63, 63
   Line 0, 37, 127, 37
   Circle 63, 37, 15

   End</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_pcd8544_controllers">
<title>PCD8544 Controllers</title>
<simpara>This section covers GLCD devices that use the PCD844 graphics controller.<?asciidoc-br?></simpara>
<simpara>The PCD8544 is a low power CMOS LCD controller/driver,
designed to drive a graphic display of 48 rows and
84 columns.  All necessary functions for the display are
provided in a single chip, including on-chip generation of
LCD supply and bias voltages, resulting in a minimum of
external components and low power consumption.
The PCD8544 interfaces to microcontrollers through a
serial bus interface.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the PCD844 controller. &#160;&#160;&#160;GCBASIC supports SPI software connectivity only - this is shown in the tables below.</simpara>
<simpara>The PCD8544 is a monochrome device.</simpara>
<simpara>The PCD844can operate in two modes. Full GLCD mode and Text/JPG mode the full GLCD mode requires a minimum of 512 bytes.  For microcontrollers with limited memory the text only can be selected by setting the correct constant.</simpara>
<simpara>To use the PCD844 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_PCD8544

    ' Pin mappings for software SPI for Nokia 3310 Device
    #define GLCD_DO     portc.5              'example port setting
    #define GLCD_SCK    portc.3              'example port setting
    #define GLCD_DC     portc.2              'example port setting
    #define GLCD_CS     portc.1              'example port setting
    #define GLCD_RESET  portc.0              'example port setting</screen>
<simpara>The GCBASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_PCD8544</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS) on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_D0</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on
the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_PCD8544_CHARACTER_MODE_ONLY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in text mode and BMP
draw mode only.<?asciidoc-br?>
For microcontrollers with less then 1kb of RAM this will be set be
default.</simpara></entry>
<entry align="center" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PCD8544ClockDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the clock delay, if required for slower microcontroller,</simpara></entry>
<entry align="center" valign="top"><simpara>Optional. Set to 0 as the default value</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PCD8544WriteDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the write delay, if required for slower microcontroller,</simpara></entry>
<entry align="center" valign="top"><simpara>Optional. Set to 0 as the default value</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara>160<?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara>128<?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>*For a PCD8544 datasheet, please refer
<link xlink:href="https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CCMQFjAA&amp;url=https%3A%2F%2Fwww.sparkfun.com%2Fdatasheets%2FLCD%2FMonochrome%2FNokia5110.pdf&amp;ei=bmjDVKePM83datDIgYgH&amp;usg=AFQjCNFa7N9WMhSg849oXejlfP3FRvQqpA&amp;sig2=ZFpG-ubTxvrBRAV4dRvhVw">here</link><?asciidoc-br?></simpara>
<simpara>This example shows how to drive a PCD8544 based Graphic LCD module with the built in commands of GCBASIC.</simpara>
<simpara>Example:</simpara>
<screen>      #chip 16lf1939,32
      #option Explicit
      #config MCLRE_ON

      #include &lt;glcd.h&gt;

      #DEFINE GLCD_TYPE GLCD_TYPE_PCD8544

      ' Pin mappings for software SPI for Nokia 3310 Device
      #define GLCD_DO portc.5
      #define GLCD_SCK portc.3
      #define GLCD_DC portc.2
      #define GLCD_CS portc.1
      #define GLCD_RESET portc.0

      Dim outString as string
      Dim ccount, byteNumber as Byte
      Dim longNumber as Long
      Dim wordNumber as Word
      GLCDCLS

      DO forever
         for CCount = 31 to 127
              GLCDPrint (0, 0, "PrintStr")
              GLCDDrawString (0, 9, "DrawStr")
              GLCDPrint ( 44 ,  21, "     ")
              GLCDPrint ( 44 ,  29, "     ") ' word value
              GLCDPrint ( 44 ,  37, "   ") ' Byte value

              outstring = hex( longNumber_U)
              GLCDPrint ( 44 , 21,outstring )
              outstring = hex( longNumber_H)
              GLCDPrint ( 55 , 21, outstring)
              outstring = hex( longNumber)
              GLCDPrint ( 67 , 21,  outstring )
              GLCDPrint ( 44 , 29, mid( str(wordNumber),1, 6))
              GLCDPrint ( 44 , 37, byteNumber)

              box 46,9,57,19
              GLCDDrawChar(48, 9, CCount )
              outString = str( CCount )
              ' draw a box to overwrite existing strings
              FilledBox(58,9,GLCD_WIDTH-1,17,GLCDBackground )
              GLCDDrawString(58, 9, outString )

               box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1
               box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH- 1, GLCD_HEIGHT-1
               filledbox 2,30,6,38, wordNumber
               Circle( 25,30,8,1)            ;center
               FilledCircle( 25,30,4,longNumber xor 1) ;center

               line 0,  GLCD_HEIGHT-1 , GLCD_WIDTH/2, (GLCD_HEIGHT /2) +1
               line  GLCD_WIDTH/2, (GLCD_HEIGHT /2) +1 ,0, (GLCD_HEIGHT /2) +1


              longNumber = longNumber + 7
              wordNumber = wordNumber + 3
              byteNumber++
          NEXT
      LOOP

      end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt; and &lt;glcd_PCD8544.h&gt;</simpara>
</section>
<section xml:id="_sdd1289_controllers">
<title>SDD1289 Controllers</title>
<simpara>This section covers GLCD devices that use the SDD1289 graphics controller.  The SDD1289 is a 240 x 320 single chip controller driver IC for 262k color (RGB) amorphous TFT LCD.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the SDD1289 controller. &#160;&#160;&#160;GCBASIC supports SPI hardware and software connectivity  - this is shown in the tables below.</simpara>
<simpara>GCBASIC supports 65K-color mode operations.</simpara>
<simpara>To use the SDD1289 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_SDD1289
    'Pin mappings for SDD1289
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting</screen>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SDD1289</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="27*"/>
<colspec colname="col_2" colwidth="36*"/>
<colspec colname="col_3" colwidth="36*"/>
<thead>
<row>
<entry align="left" valign="top">Constant</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara>Set automatically</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara>Set automatically</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2,  [Optional In LineColour as 0 or 1]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2,  [Optional In LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2,  [Optional In LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SDD1289_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?>
</simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>      SSD1289_BLACK   'hexidecimal value 0x0000
      SSD1289_RED     'hexidecimal value 0xF800
      SSD1289_GREEN   'hexidecimal value 0x07E0
      SSD1289_BLUE    'hexidecimal value 0x001F
      SSD1289_WHITE   'hexidecimal value 0xFFFF
      SSD1289_PURPLE  'hexidecimal value 0xF11F
      SSD1289_YELLOW  'hexidecimal value 0xFFE0
      SSD1289_CYAN    'hexidecimal value 0x07FF
      SSD1289_D_GRAY  'hexidecimal value 0x528A
      SSD1289_L_GRAY  'hexidecimal value 0x7997
      SSD1289_SILVER  'hexidecimal value 0xC618
      SSD1289_MAROON  'hexidecimal value 0x8000
      SSD1289_OLIVE   'hexidecimal value 0x8400
      SSD1289_LIME    'hexidecimal value 0x07E0
      SSD1289_AQUA    'hexidecimal value 0x07FF
      SSD1289_TEAL    'hexidecimal value 0x0410
      SSD1289_NAVY    'hexidecimal value 0x0010
      SSD1289_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara>For a SDD1289 datasheet, please refer <link xlink:href="http://gcbasic.sourceforge.net/library/DISPLAY/SDD1289.pdf">here</link>.<?asciidoc-br?></simpara>
<simpara>This example shows how to drive a SDD1289 based Graphic LCD module with the built in commands of GCBASIC.<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F1937,32
    #config MCLRE_ON

    #include &lt;glcd.h&gt;

    'Defines for SDD1289
    #define GLCD_TYPE GLCD_TYPE_SDD1289
    'Pin mappings for SDD1289
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the SDD1289 Device")
    end</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> OR <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_sh1106_controllers">
<title>SH1106 Controllers</title>
<simpara>This section covers GLCD devices that use the SH1106 graphics controller.  THe SH1106 is a single-chip CMOS OLED/PLED driver with controller for organic/polymer light emitting diode dot-matrix graphic display system.  SH1106 consists of 132 segments, 64 commons that can support a maximum display resolution of 132 X 64. It is designed for Common Cathode type OLED panel.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the SH1106 controller. &#160;&#160;&#160;GCBASIC supports i2C hardware and software connectivity  - this is shown in the tables below.</simpara>
<simpara>The SH1106 is a monochrome device.</simpara>
<simpara>To use the SH1106 driver simply include the following in your user code.  This will initialise the driver.  You can select Full Mode GLCD, Low Memory Mode GLCD or Text mode these require 1024, 128 or 0 byte GLCD buffer respectively - you microcontroller requires sufficient RAM to support the selected mode of GLCD operation.</simpara>
<screen>    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SH1106
    #define GLCD_I2C_Address 0x78
    '#define GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE        'select Low Memory mode of operation
    '#define GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY        'select Text mode of operation

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master</screen>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SH1106</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_I2C_Address</literal></simpara></entry>
<entry align="left" valign="top"><simpara>I2C address of the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HI2C_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>HI2C_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>400 or 100</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HI2C_DATA</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>HI2C_DATA</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Mandated, plus<?asciidoc-br?>
<literal>HI2CMode Master</literal> is required.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>128</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="center" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in text mode and BMP
draw mode only.<?asciidoc-br?>
For microcontrollers with low RAM this will be set be
default.<?asciidoc-br?>
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <literal>GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in Low Memory mode.</simpara></entry>
<entry align="center" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte (LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Open_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands when in low memory mode.  Must be followed a  <literal>GLCD_Close_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction 0, 7</literal> where 0 and 7 are the range of pages to be updated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands when in low memory mode.  Must follow a <literal>GLCD_Open_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The additional GCBASIC commands for this GLCD are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDSetDisplayInvertMode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Inverts the display</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDSetDisplayNormalMode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the display to normal mode</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDSetContrast ( dim_state )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the constrast between 0 and 255. The contrast increases as the value increases.<?asciidoc-br?>
Parameter is dim value</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a SH1106 datasheet, please refer <link xlink:href="http://gcbasic.sourceforge.net/library/DISPLAY/SH1106.pdf">here</link>.</simpara>
<simpara>This example shows how to drive a SH1106 based Graphic LCD module with the built in commands of GCBASIC.</simpara>
<screen>; ----- Configuration
    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SH1106
    #define GLCD_I2C_Address 0x78

    GLCDCLS
    GLCDPrint 0, 0, "GCBASIC"
    GLCDPrint (0, 16, "Anobium 2021")

    wait 3 s
    GLCDCLS

    ' Prepare the static components of the screen
    GLCDPrint ( 0,   0, "PrintStr") ; Print some text
    GLCDPrint ( 64,  0, "@")
    ; Print some more text
    GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
    GLCDPrint ( 86, 0, "Mhz") ; Print some text
    GLCDDrawString( 0,8,"DrawStr") ; Draw some text
    box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    Circle( 44,41,15) ; Draw a circle
    line 64,31,0,31 ; Draw a line

    DO forever
       for CCount = 31 to 127
            GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
            GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
            GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
            GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
            GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

            GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
            GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

            box (46,9,56,19) ; Draw a Box
            GLCDDrawChar(48, 9, CCount ) ; Draw a character
            outString = str( CCount ) ; Prepare a string
            GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

            filledbox 3,43,11,51, wordNumber ; Draw a filled box

            FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
            line 0,63,64,31 ; Draw a line

            ; Do some simple maths
            longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
        NEXT
    LOOP
    end</screen>
<simpara>This example shows how to drive a SH1106 based Graphic I2C LCD module with the built in commands of GCBASIC using Low Memory Mode GLCD.</simpara>
<simpara>Note the use of <literal>GLCD_Open_PageTransaction</literal> and <literal>GLCD_Close_PageTransaction</literal> to support the Low Memory Mode of operation and the contraining of all GLCD commands with the transaction commands.  The use Low Memory Mode GLCD the two defines <literal>GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE</literal> and <literal>GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY</literal> are included in the user program.</simpara>
<screen>    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SH1106  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x78
    #define GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS
    GLCD_Open_PageTransaction 0,7
       GLCDPrint 0, 0, "GCBASIC"
       GLCDPrint (0, 16, "Anobium 2021")
    GLCD_Close_PageTransaction
    wait 3 s
    GLCDCLS

    DO forever

      for CCount = 31 to 127

        outString = str( CCount ) ; Prepare a string

        GLCD_Open_PageTransaction 0,7

           ' Prepare the static components of the screen
           GLCDPrint ( 0,   0, "PrintStr") ; Print some text
           GLCDPrint ( 64,  0, "@")
           ; Print some more text
           GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
           GLCDPrint ( 86, 0, "Mhz") ; Print some text
           GLCDDrawString( 0,8,"DrawStr") ; Draw some text
           box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           Circle( 44,41,15) ; Draw a circle
           line 64,31,0,31 ; Draw a line

           GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
           GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
           GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
           GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
           GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

           GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
           GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

           box (46,8,56,19) ; Draw a Box
           GLCDDrawChar(48, 9, CCount ) ; Draw a character

           GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

           filledbox 3,43,11,51, wordNumber ; Draw a filled box

           FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
           line 0,63,64,31 ; Draw a line

        GLCD_Close_PageTransaction

        ; Do some simple maths
        longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
       NEXT
    LOOP
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ssd1306_controllers">
<title>SSD1306 Controllers</title>
<simpara>This section covers GLCD devices that use the SSD1306 graphics controller.</simpara>
<simpara>The SSD1306 is a single-chip CMOS OLED/PLED driver with controller for organic / polymer light emitting diode dot-matrix graphic display system. It consists of 128 segments and 64 commons. This IC is designed for Common Cathode type OLED panel.</simpara>
<simpara>The SSD1306 embeds with contrast control, display RAM and oscillator, which reduces the number of external components and power consumption. It has 256-step brightness control. Data/Commands are sent from general MCU through the hardware selectable 6800/8000 series compatible Parallel Interface, I2C interface or Serial Peripheral Interface. It is suitable for many compact portable applications, such as mobile phone sub-display, MP3 player and calculator, etc.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the SSD1306 controller. &#160;&#160;&#160;GCBASIC supports SPI and I2C hardware &amp; software connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the SSD1306 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<simpara>The SSD1306 library supports 128 * 64 pixels or 128 * 32 pixels.  The default is 128 * 64 pixels.</simpara>
<simpara>The SSD1306 is a monochrome device.</simpara>
<simpara>The SSD1306 can operate in three modes. Full GLCD mode, Low Memory GLCD mode or Text/JPG mode the full GLCD mode requires a minimum of 1k bytes or 512 bytes for the 128x64 and the 128x32 devices respectively in Full GLCD mode.  For microcontrollers with limited memory the third mode of operation - Text mode.  These can be selected by setting the correct constant.</simpara>
<simpara>To use the SSD1306 drivers simply include one of the following configuration.  You can select Full Mode GLCD, Low Memory Mode GLCD or Text mode these require 1024, 128 or 0 byte GLCD buffer respectively - you microcontroller requires sufficient RAM to support the selected mode of GLCD operation.</simpara>
<simpara>Performance of the SSD1306 has been validated at 16Mhz and 400Hz I2C baud.&#160;&#160;Using other frequencies should be fully tested.</simpara>
<screen>    'An I2C configuration
    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306
    #define GLCD_I2C_Address 0x78
    '#define GLCD_TYPE_SH1306_LOWMEMORY_GLCD_MODE       'select Low Memory mode of operation
    '#define GLCD_TYPE_SH1306_CHARACTER_MODE_ONLY       'select Text mode of operation


    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master</screen>
<simpara>or,</simpara>
<screen>    'An SPI configuration'
    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306

    ; ----- Define Hardware settings
    #define S4Wire_DATA

    #define MOSI_SSD1306 PortB.1
    #define SCK_SSD1306  PortB.2
    #define DC_SSD1306   PortB.3
    #define CS_SSD1306   PortB.4
    #define RES_SSD1306  PortB.5</screen>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_I2C_Address</literal></simpara></entry>
<entry align="left" valign="top"><simpara>I2C address of the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for SPI/S4Wire control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required to support 128 * 64 pixels.  Mutualy exclusive to GLCD_TYPE_SSD1306_32</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SSD1306_32</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required to support 128 * 32 pixels.  Mutualy exclusive to GLCD_TYPE_SSD1306</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>S4Wire_Data</literal></simpara></entry>
<entry align="left" valign="top"><simpara>4 wire SPI Mode</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MOSI_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to serial data in D1 pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SCK_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to serial clock D0 pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DC_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to data control DC pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CS_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to chip select CS pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>RES_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to reset RES pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>128</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>64</literal> or <literal>32</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_PROTECTOVERRUN</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Define this constant to restrict pixel operations with the pixel limits</simpara></entry>
<entry align="left" valign="top"><simpara>Not defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Rotate GCLD Constants</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDYFLIP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Define this constant to rotate the GLCD  display</simpara></entry>
<entry align="left" valign="top"><simpara>Not defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDXFLIP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Define this constant to rotate the GLCD  display</simpara></entry>
<entry align="left" valign="top"><simpara>Not defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDXYFLIP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Define this constant to rotate the GLCD  display</simpara></entry>
<entry align="left" valign="top"><simpara>Not defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Memory Management Constants</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SSD1306_CHARACTER_MODE_ONLY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in text mode and BMP
draw mode only.<?asciidoc-br?>
For microcontrollers with low RAM this will be set be
default.<?asciidoc-br?>
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <literal>GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in Low Memory mode.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC variables for control display characteristics are shown in the table below.
These variables control the user definable parameters of a specific GLCD.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Variable</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Type</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_OLED_FONT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the use of the optional OLED font set.
</simpara><simpara>The GLCDFNTDEFAULTSIZE can be set to 1 or 2 only.
</simpara><simpara><literal>GLCDFNTDEFAULTSIZE=  1</literal>.   A small 8 height pixel font with variable width.
<literal>GLCDFNTDEFAULTSIZE=  2</literal>.   A larger 10 width * 16 height pixel font.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDBACKGROUND</literal></simpara></entry>
<entry align="left" valign="top"><simpara>GLCD background state.</simpara></entry>
<entry align="left" valign="top"><simpara>A monochrome value.<?asciidoc-br?>
For mono GLCDs the default is White or 0x0001.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFOREGROUND</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Color of GLCD foreground.</simpara></entry>
<entry align="left" valign="top"><simpara>A monochrome value.<?asciidoc-br?>
For mono GLCDs the default is non-white or 0x0000.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFONTWIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Width of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 6 pixels.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFNTDEFAULT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 0.
</simpara><simpara></simpara><simpara>This equates to the standard GCB font set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFNTDEFAULTSIZE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 1.
</simpara><simpara></simpara><simpara>This equates to the 8 pixel high.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the
table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte (LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Open_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands when in low memory mode.  Must be followed a  <literal>GLCD_Close_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction 0, 7</literal> where 0 and 7 are the range of pages to be updated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands when in low memory mode.  Must follow a <literal>GLCD_Open_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC specific commands for this GLCD are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Stopscroll_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Stops all scrolling</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Startscrollright_SSD1306 ( start , stop [,scrollspeed] )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Activate a right handed scroll for rows start through stop
Hint, the display is 16 rows tall. To scroll the whole display, execute:<?asciidoc-br?>
<literal>startscrollright_SSD1306(0x00, 0x0F)</literal><?asciidoc-br?>
Parameters are <literal>Start row</literal>, <literal>End row</literal>, optionally <literal>Scrollspeed</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Startscrollleft_SSD1306 ( start , stop [,scrollspeed] )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Activate a left handed scroll for rows start through stop
Hint, the display is 16 rows tall. To scroll the whole display, execute:<?asciidoc-br?>
<literal>startscrollleft_SSD1306(0x00, 0x0F)</literal><?asciidoc-br?>
Parameters are <literal>Start row</literal>, <literal>End row</literal>, optionally <literal>Scrollspeed</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Startscrolldiagright_SSD1306 ( start , stop [,scrollspeed] )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Activate a diagright handed scroll for rows start through stop
Hint, the display is 16 rows tall. To scroll the whole display, execute:<?asciidoc-br?>
<literal>startscrolldiagright_SSD1306(0x00, 0x0F)</literal><?asciidoc-br?>
Parameters are <literal>Start row</literal>, <literal>End row</literal>, optionally <literal>Scrollspeed</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Startscrolldiagleft_SSD1306 ( start , stop [,scrollspeed] )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Activate a diagleft handed scroll for rows start through stop
Hint, the display is 16 rows tall. To scroll the whole display, execute:<?asciidoc-br?>
<literal>startscrolldiagleft_SSD1306(0x00, 0x0F)</literal><?asciidoc-br?>
Parameters are <literal>Start row</literal>,<literal>End row</literal>, optionally <literal>Scrollspeed</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDSetContrast ( dim_state )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the constrast between 0 and 255. The contrast increases as the value increases.<?asciidoc-br?>
Parameter is dim value</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a SSD1306 datasheet, please refer <link xlink:href="http://gcbasic.sourceforge.net/library/DISPLAY/SSD1306.pdf">here</link>.</simpara>
<simpara>This example shows how to drive a SSD1306 based Graphic I2C LCD module with the built in commands of GCBASIC using Full Mode GLCD</simpara>
<screen>    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x78

    dim outString as string * 21

    GLCDCLS
    GLCDPrint 0, 0, "GCBASIC"
    GLCDPrint (0, 16, "Anobium 2021")

    wait 3 s
    GLCDCLS

    ' Prepare the static components of the screen
    GLCDPrint ( 0,   0, "PrintStr") ; Print some text
    GLCDPrint ( 64,  0, "@")
    ; Print some more text
    GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
    GLCDPrint ( 86, 0, "Mhz") ; Print some text
    GLCDDrawString( 0,8,"DrawStr") ; Draw some text
    box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    Circle( 44,41,15) ; Draw a circle
    line 64,31,0,31 ; Draw a line

    DO forever
       for CCount = 31 to 127
            GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
            GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
            GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
            GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
            GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

            GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
            GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

            box (46,9,56,19) ; Draw a Box
            GLCDDrawChar(48, 9, CCount ) ; Draw a character
            outString = str( CCount ) ; Prepare a string
            GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

            filledbox 3,43,11,51, wordNumber ; Draw a filled box

            FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
            line 0,63,64,31 ; Draw a line

            ; Do some simple maths
            longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
        NEXT
    LOOP
    end</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
This example shows how to drive a SSD1306 based Graphic I2C LCD module with the built in commands of GCBASIC using Low Memory Mode GLCD.
<?asciidoc-br?>
Note the use of <literal>GLCD_Open_PageTransaction</literal> and <literal>GLCD_Close_PageTransaction</literal> to support the Low Memory Mode of operation and the contraining of all GLCD commands with the transaction commands.  The use Low Memory Mode GLCD the two defines <literal>GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE</literal> and <literal>GLCD_TYPE_SSD1306_CHARACTER_MODE_ONLY</literal> are included in the user program.
<?asciidoc-br?></simpara>
<screen>    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x78
    #define GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_SSD1306_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS

    'To clarify - page udpates
    '0,7 correspond with the Text Lines from 0 to 7 on a 64 Pixel Display
    'In this example Code would be GLCD_Open_PageTransaction 0,1 been enough
    'But it is allowed to use GLCD_Open_PageTransaction 0,7 to show the full screen update
    GLCD_Open_PageTransaction 0,7
       GLCDPrint 0, 0, "GCBASIC"
       GLCDPrint (0, 16, "Anobium 2021")
    GLCD_Close_PageTransaction
    wait 3 s
    DO forever

      for CCount = 31 to 127

        outString = str( CCount ) ; Prepare a string

        GLCD_Open_PageTransaction 0,7

           ' Prepare the static components of the screen
           GLCDPrint ( 0,   0, "PrintStr") ; Print some text
           GLCDPrint ( 64,  0, "@")
           ; Print some more text
           GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
           GLCDPrint ( 86, 0, "Mhz") ; Print some text
           GLCDDrawString( 0,8,"DrawStr") ; Draw some text
           box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           Circle( 44,41,15) ; Draw a circle
           line 64,31,0,31 ; Draw a line

           GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
           GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
           GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
           GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
           GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

           GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
           GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

           box (46,8,56,19) ; Draw a Box
           GLCDDrawChar(48, 9, CCount ) ; Draw a character

           GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

           filledbox 3,43,11,51, wordNumber ; Draw a filled box

           FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
           line 0,63,64,31 ; Draw a line

        GLCD_Close_PageTransaction

        ; Do some simple maths
        longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
       NEXT
    LOOP
    end</screen>
<simpara><?asciidoc-br?>
This example shows how to drive a SSD1306 based Graphic SPI LCD module with the built in commands of GCBASIC.
<?asciidoc-br?></simpara>
<screen>    'Chip model
    #chip mega328p, 16
    #include &lt;glcd.h&gt;

    'Defines for a 7 pin SPI module
    'RES pin is pulsed low in glcd_SSD1306.h for proper startup
    #define MOSI_SSD1306 PortB.1
    #define SCK_SSD1306 PortB.2
    #define DC_SSD1306 PortB.3
    #define CS_SSD1306 PortB.4
    #define RES_SSD1306 PortB.5
    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306   'for 128 * 64 pixels support
    #define S4Wire_DATA

    dim longnumber as Long
    longnumber = 123456
    dim wordnumber as word
    wordnumber = 62535
    dim bytenumber as Byte
    bytenumber =255

    #define led PortB.0
    dir led out


    Do
         SET led ON
         wait 1 s
         SET led OFF

        GLCDCLS
        GLCDPrint (30, 0, "Hello World!")
        Circle (18,24,10)
        FilledCircle (48,24,10)
        Box (70,14,90,34)
        FilledBox (106,14,126,34)
        GLCDDrawString (32,35,"Draw String")
        GLCDPrint (0,46,longnumber)
        GLCDPrint (94,46,wordnumber)
        GLCDPrint (52,55,bytenumber)
        Line (0,40,127,63)
        Line (0,63,127,40)
        wait 3 s

    Loop</screen>
<simpara><?asciidoc-br?>
This example shows how to drive a SSD1306 based Graphic I2C LCD module with 128 * 32 pixel support.
<?asciidoc-br?></simpara>
<screen>    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306_32  'for 128 * 32 pixels support
    #define GLCD_I2C_Address 0x78

    GLCDCLS
    GLCDPrint 0, 0, "GCBASIC"
    GLCDPrint (0, 16, "Anobium 2021")</screen>
<simpara><?asciidoc-br?>
This example shows how to drive a SSD1306 with the OLED fonts.  Note the use of the <literal>GLCDfntDefaultSize</literal> to select the size of the OLED font in use.
<?asciidoc-br?></simpara>
<screen>    #define GLCD_OLED_FONT

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  SSD1306" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</screen>
<simpara><?asciidoc-br?>
This example shows how to set the SSD1306 OLED the lowest constrast level by using a OLED chip specific command.
<?asciidoc-br?></simpara>
<screen>    'Use the GCB command to set the lowest constrast
    GLCDSetContrast ( 0 )
      'Then, use the Write command to set the output between 0 and 255
      Write_Command_SSD1306(SSD1306_SETVCOMDETECT)
      Write_Command_SSD1306(15)      ' 0x40 default, to lower the contrast, put 0 for lowest and 255 for highest.


    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  SSD1306" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</screen>
<simpara><?asciidoc-br?></simpara>
<simpara>This example shows how to disable the large OLED Fontset.  This disables the font to reduce memory usage.</simpara>
<simpara>When the large OLED fontset is disabled every character will be shown as a block character.
<?asciidoc-br?></simpara>
<screen>    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts
    #define GLCD_Disable_OLED_FONT2       'The constant to disable the large fontset.

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  SSD1306" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ssd1331_controllers">
<title>SSD1331 Controllers</title>
<simpara>This section covers GLCD devices that use the SSD1331 graphics controller.  The SSD1331 is a single-chip controller/driver for 262K-color, graphic type OLED-LCD.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the SSD1331 controller. &#160;&#160;&#160;GCBASIC supports SPI, hardware and software SPI, connectivity. This is shown in the tables below.</simpara>
<simpara>GCBASIC supports 65K-color mode operations.</simpara>
<simpara>To use the SSD1331 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>        #include &lt;glcd.h&gt;
        #include &lt;UNO_mega328p.h &gt;

        #define GLCD_TYPE GLCD_TYPE_SSD1331

        'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
        #define GLCD_DC       portb.0           ' Data command line
        #define GLCD_CS       portb.2           ' Chip select line
        #define GLCD_RESET    portb.1           ' Reset line
        #define GLCD_DO       portb.3           ' Data out | MOSI
        #define GLCD_SCK      portb.5           ' Clock Line

        #define SSD1331_HardwareSPI    ' remove/comment out if you want to use software SPI.</screen>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SSD1331</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS) on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on
the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SSD1331_HardwareSPI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that hardware SPI will be used</simpara></entry>
<entry align="left" valign="top"><simpara>SPI ports MUST be defined that match the SPI module for each specific microcontroller
</simpara><simpara>    <emphasis role="strong">#define SSD1331_HardwareSPI</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWSPIMode</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the speed of the SPI communications for Hardware SPI only.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional defaults to MASTERFAST.
</simpara><simpara>Options are MASTERSLOW,<?asciidoc-br?>
MASTER,<?asciidoc-br?>
MASTERFAST, or<?asciidoc-br?>
MASTERULTRAFAST for specific AVRs only.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>96</literal><?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>48</literal><?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="center" valign="top"><simpara><literal>6</literal> or <literal>5</literal> for the OLED font set.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal>
</simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>   SSD1331_BLACK   'hexidecimal value 0x0000
   SSD1331_BLUE    'hexidecimal value 0xF800
   SSD1331_RED     'hexidecimal value 0x001F
   SSD1331_GREEN   'hexidecimal value 0x07E0
   SSD1331_CYAN    'hexidecimal value 0xFFE0
   SSD1331_MAGENTA 'hexidecimal value 0xF81F
   SSD1331_YELLOW  'hexidecimal value 0x07FF
   SSD1331_WHITE   'hexidecimal value 0xFFFF</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip mega328p, 16
    #option explicit

    #include &lt;glcd.h&gt;
    #include &lt;UNO_mega328p.h &gt;

    #define GLCD_TYPE GLCD_TYPE_SSD1331

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       portb.0           ' Data command line
    #define GLCD_CS       portb.2           ' Chip select line
    #define GLCD_RESET    portb.1           ' Reset line
    #define GLCD_DO       portb.3           ' Data out | MOSI
    #define GLCD_SCK      portb.5           ' Clock Line

    #define SSD1331_HardwareSPI    ' remove/comment out if you want to use software SPI.

    'GLCD selected OLED font set.
    #define GLCD_OLED_FONT
    GLCDfntDefaultsize = 1

    GLCDCLS
    GLCDPrintStringLN ("GCBASIC")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("Test of the SSD1331")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("Anobium 2021")
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ssd1351_controllers">
<title>SSD1351 Controllers</title>
<simpara>This section covers GLCD devices that use the SSD1351 graphics controller.  The SSD1351 is a single-chip controller/driver for 262K-color, graphic type OLED-LCD.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the SSD1351 controller. &#160;&#160;&#160;GCBASIC supports SPI, hardware and software SPI, connectivity. This is shown in the tables below.</simpara>
<simpara>GCBASIC supports 65K-color mode operations.</simpara>
<simpara>To use the SSD1351 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>        #include &lt;glcd.h&gt;
        #define GLCD_TYPE GLCD_TYPE_SSD1351

        'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
        #define GLCD_DC       portb.0           ' Data command line
        #define GLCD_CS       portb.2           ' Chip select line
        #define GLCD_RESET    portb.1           ' Reset line
        #define GLCD_DO       portb.3           ' Data out | MOSI
        #define GLCD_SCK      portb.5           ' Clock Line

        #define SSD1351_HardwareSPI    ' remove/comment out if you want to use software SPI.  If you are using PPS to setup the SPI - ensure that PPS SPI is disabled to use software SPI.</screen>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SSD1351</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS) on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on
the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SSD1351_HardwareSPI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that hardware SPI will be used</simpara></entry>
<entry align="left" valign="top"><simpara>SPI ports MUST be defined that match the SPI module for each specific microcontroller
</simpara><simpara>    <emphasis role="strong">#define SSD1351_HardwareSPI</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWSPIMode</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the speed of the SPI communications for Hardware SPI only.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional defaults to MASTERFAST.
</simpara><simpara>Options are MASTERSLOW,<?asciidoc-br?>
MASTER,<?asciidoc-br?>
MASTERFAST, or<?asciidoc-br?>
MASTERULTRAFAST for specific AVRs only.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>128</literal><?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>128</literal><?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="center" valign="top"><simpara><literal>6</literal> or <literal>5</literal> for the OLED font set.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal>
</simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>   SSD1351_BLACK   'hexidecimal value 0x0000
   SSD1351_BLUE    'hexidecimal value 0xF800
   SSD1351_RED     'hexidecimal value 0x001F
   SSD1351_GREEN   'hexidecimal value 0x07E0
   SSD1351_CYAN    'hexidecimal value 0xFFE0
   SSD1351_MAGENTA 'hexidecimal value 0xF81F
   SSD1351_YELLOW  'hexidecimal value 0x07FF
   SSD1351_WHITE   'hexidecimal value 0xFFFF</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip mega328p, 16
    #option explicit

    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_SSD1351

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       portb.0           ' Data command line
    #define GLCD_CS       portb.2           ' Chip select line
    #define GLCD_RESET    portb.1           ' Reset line
    #define GLCD_DO       portb.3           ' Data out | MOSI
    #define GLCD_SCK      portb.5           ' Clock Line

    #define SSD1351_HardwareSPI    ' remove/comment out if you want to use software SPI.

    'GLCD selected OLED font set.
    #define GLCD_OLED_FONT
    GLCDfntDefaultsize = 1

    GLCDCLS
    GLCDPrintStringLN ("GCBASIC")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("Test of the SSD1351")
    GLCDPrintStringLN ("")
    GLCDPrintStringLN ("October 2021")
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_st7567_controllers">
<title>ST7567 Controllers</title>
<simpara>This section covers GLCD devices that use the ST7567 graphics controller.</simpara>
<simpara>The ST7567 is a single-chip CMOS LCD driver with controller for organic / polymer light emitting diode dot-matrix graphic display system. It consists of 128 segments and 64 commons. This IC is designed for Common Cathode type LCD panel.</simpara>
<simpara>ST7567 is a single-chip dot matrix LCD driver which incorporates LCD controller and common/segment drivers.
A ST7567 can be connected directly to a microprocessor with I2C or 4-line serial interface (SPI-4).
Display data sent from microprocessor is stored in the internal Display Data RAM (DDRAM) of 65x132 bits.
The display data bits which are stored in DDRAM are directly related to the pixels of LCD panel.
The ST7567 contains 132 segment-outputs, 64 common-outputs and 1 icon-common-output, however the address pixels are 128 * 64.
The ST7567 has built-in oscillation circuit and low power consumption power circuit, ST7567 generates LCD driving signal without external clock or power, so that it is possible to make a display system with the fewest components and minimal power consumption.</simpara>
<simpara>There are different types of ST75xx GLCDs.&#160;&#160;&#160;The table below shows the different types and the GCBASIC support.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Index</entry>
<entry align="left" valign="top">GLCD MPU</entry>
<entry align="left" valign="top">Interfaces</entry>
<entry align="left" valign="top">Datasheet Ref</entry>
<entry align="left" valign="top">Support</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>ST7565</simpara></entry>
<entry align="left" valign="top"><simpara>Parallel 8080&amp;6080</simpara></entry>
<entry align="left" valign="top"><simpara>Ver 1.0a;Page 12</simpara></entry>
<entry align="left" valign="top"><simpara>Not supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>ST7565S</simpara></entry>
<entry align="left" valign="top"><simpara>Parallel 8080&amp;6080</simpara></entry>
<entry align="left" valign="top"><simpara>Ver 0.6b;Page 23</simpara></entry>
<entry align="left" valign="top"><simpara>Not supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>ST7567</simpara></entry>
<entry align="left" valign="top"><simpara>4 Pin SPI;Parallel 8080&amp;6080</simpara></entry>
<entry align="left" valign="top"><simpara>Ver1.4b;Page 12</simpara></entry>
<entry align="left" valign="top"><simpara>3&amp;4 Pin SPI</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>ST7567S</simpara></entry>
<entry align="left" valign="top"><simpara>3&amp;4 Pin SPI;I2C;Parallel 8080&amp;6080</simpara></entry>
<entry align="left" valign="top"><simpara>Ver1.4;Page 17</simpara></entry>
<entry align="left" valign="top"><simpara>3&amp;4 Pin SPI &amp; I2C</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>ST7576</simpara></entry>
<entry align="left" valign="top"><simpara>3&amp;4 Pin SPI;I2C;Parallel 8080&amp;6080</simpara></entry>
<entry align="left" valign="top"><simpara>Ver1;Page 18</simpara></entry>
<entry align="left" valign="top"><simpara>3&amp;4 Pin SPI &amp; I2C</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The ST7567 embeds with contrast control, display RAM and it is suitable for many compact portable applications, such as mobile phone sub-display, MP3 player and calculator, etc.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the ST7567 controller. &#160;&#160;&#160;GCBASIC supports SPI and I2C software connectivity  - this is shown in the tables below.</simpara>
<simpara>The ST7567 library supports 128 * 64 pixels.</simpara>
<simpara>The ST7567 is a monochrome device.
The library supports difference bias settings for the different types of LCD.
See the constant <literal>ST7567_BIAS</literal> for the options.</simpara>
<simpara>The ST7567 can operate in three modes. Full GLCD mode, Low Memory GLCD mode or Text/JPG mode the full GLCD mode requires a minimum of 1k bytes or 512 bytes for the 128x64 respectively in Full GLCD mode.  For microcontrollers with limited memory the third mode of operation - Text mode.  These can be selected by setting the correct constant.</simpara>
<simpara>To use the ST7567 drivers simply include one of the following configuration.  You can select Full Mode GLCD, Low Memory Mode GLCD or Text mode these require 1024, 128 or 0 bytes GLCD buffer respectively - you microcontroller requires sufficient RAM to support the selected mode of GLCD operation.</simpara>
<simpara>To use the ST7567 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    'An I2C configuration
    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_ST7567
    #define GLCD_I2C_Address 0x7E
    #define ST7567_BIAS     ST7567_SET_BIAS_7    ' ST7567_SET_BIAS_7 or ST7567_SET_BIAS_9


    ; ----- Define software IC2 settings
    #DEFINE I2C_MODE MASTER
    #DEFINE I2C_DATA PORTB.4
    #DEFINE I2C_CLOCK PORTB.6
    #DEFINE I2C_DISABLE_INTERRUPTS ON</screen>
<simpara>or,</simpara>
<screen>    'An SPI configuration'
    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_ST7567

    ; ----- Define Hardware settings
    #define S4Wire_DATA

    #define MOSI_ST7567 PortB.1
    #define SCK_ST7567  PortB.2
    #define DC_ST7567   PortB.3
    #define CS_ST7567   PortB.4
    #define RES_ST7567  PortB.5</screen>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ST7567</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_I2C_Address</literal></simpara></entry>
<entry align="left" valign="top"><simpara>I2C address of the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required defaults to 0x7E</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for SPI/S4Wire control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ST7567</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required to support 128 * 64 pixels.  Mutualy exclusive to GLCD_TYPE_ST7567_32</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ST7567_BIAS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Bias ratio of the voltage required to driving the LCD at a fixes duty of 1/65 ( see the datasheet)</simpara></entry>
<entry align="left" valign="top"><simpara>Defaults to <literal>ST7567_SET_BIAS_7</literal>.  Can be either <literal>ST7567_SET_BIAS_7</literal> or <literal>ST7567_SET_BIAS_9</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>S4Wire_Data</literal></simpara></entry>
<entry align="left" valign="top"><simpara>4 wire SPI Mode</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MOSI_ST7567</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to serial data in D1 pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SCK_ST7567</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to serial clock D0 pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DC_ST7567</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to data control DC pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CS_ST7567</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to chip select CS pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>RES_ST7567</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to reset RES pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>128</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_PROTECTOVERRUN</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Define this constant to restrict pixel operations with the pixel limits</simpara></entry>
<entry align="left" valign="top"><simpara>Not defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ST7567_CHARACTER_MODE_ONLY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in text mode and BMP
draw mode only.<?asciidoc-br?>
For microcontrollers with low RAM this will be set be
default.<?asciidoc-br?>
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <literal>GLCD_TYPE_ST7567_LOWMEMORY_GLCD_MODE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ST7567_LOWMEMORY_GLCD_MODE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in Low Memory mode.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_OLED_FONT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the use of the optional OLED font set.
</simpara><simpara>The GLCDfntDefaultsize can be set to 1 or 2 only.
</simpara><simpara><literal>GLCDfntDefaultsize=  1</literal>.   A small 8 height pixel font with variable width.
<literal>GLCDfntDefaultsize=  2</literal>.   A larger 10 width * 16 height pixel font.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC variables for control display characteristics are shown in the table below.
These variables control the user definable parameters of a specific GLCD.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Variable</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Type</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDBackground</literal></simpara></entry>
<entry align="left" valign="top"><simpara>GLCD background state.</simpara></entry>
<entry align="left" valign="top"><simpara>A monochrome value.<?asciidoc-br?>
For mono GLCDs the default is White or 0x0001.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDForeground</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Color of GLCD foreground.</simpara></entry>
<entry align="left" valign="top"><simpara>A monochrome value.<?asciidoc-br?>
For mono GLCDs the default is non-white or 0x0000.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Width of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 6 pixels.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 0.
</simpara><simpara></simpara><simpara>This equates to the standard GCB font set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefaultsize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 1.
</simpara><simpara></simpara><simpara>This equates to the 8 pixel high.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the
table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte (LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Open_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands when in low memory mode.  Must be followed a  <literal>GLCD_Close_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction 0, 7</literal> where 0 and 7 are the range of pages to be updated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands when in low memory mode.  Must follow a <literal>GLCD_Open_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC specific commands for this GLCD are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDSetContrast ( dim_state )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the constrast between 0 and 255. The contrast increases as the value increases.<?asciidoc-br?>
Parameter is dim value</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This example shows how to drive a ST7567 based Graphic I2C LCD module with the built in commands of GCBASIC using Full Mode GLCD</simpara>
<screen>    #CHIP 18F26Q71
    #OPTION Explicit

    #startup InitPPS, 85
        #define PPSToolPart 18F26Q71

        Sub InitPPS
            // Ensure PPS is NOT set for Software I2C
            UNLOCKPPS
            RB6PPS = 0
            RB4PPS = 0
        End Sub
        'Template comment at the end of the config file


    '' -------------------PORTA----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' IO:   ----------------------------------
    ''-----------------------------------------
    ''

    '' -------------------PORTB----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' IO:    ----SCL-----SDA------------------
    ''-----------------------------------------
    ''

    '' ------------------PORTC-----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' IO:    ---------------------------------
    ''-----------------------------------------

    ' Define Software I2C settings
        #DEFINE I2C_MODE MASTER
        #DEFINE I2C_DATA PORTB.4
        #DEFINE I2C_CLOCK PORTB.6
        #DEFINE I2C_DISABLE_INTERRUPTS ON

    '*****************************************************************************************************
    'Main program commences here.. everything before this is setup for the chip.

        Dim DeviceID As Byte
        Dim DISPLAYNEWLINE As Byte

        #include &lt;glcd.h&gt;
        #DEFINE GLCD_TYPE GLCD_TYPE_ST7567
        #DEFINE GLCDDIRECTION INVERTED

    ; ----- Define variables
        Dim BYTENUMBER, CCOUNT as Byte

        CCount = 0
        dim longNumber as long
        longNumber = 123456 ' max value = 4294967290
        dim wordNumber as Word
        dim outstring as string
        wordNumber = 0
        byteNumber = 0

    ; ----- Main program

        GLCDPrint 0, 0,   "GCBASIC"
        GLCDPrint (0, 16, "Anobium 2024")
        GLCDPrint (0, 32, "Portability Demo")
        GLCDPrint (0, 48, ChipNameStr )

        wait 3 s
        GLCDCLS

        ' Prepare the static components of the screen
        GLCDPrint ( 2,   2, "PrintStr")                                   ; Print some text
        GLCDPrint ( 64,  2, "@")                                          ; Print some more text
        GLCDPrint ( 72,  2, ChipMhz)                                      ; Print chip speed
        GLCDPrint ( 86, 2, "Mhz")                                         ; Print some text
        GLCDDrawString( 2,10,"DrawStr")                                    ; Draw some text
        box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1                               ; Draw a box
        box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1       ; Draw a box
        Circle( 44,41,15)                                                 ; Draw a circle
        line 64,31,0,31                                                   ; Draw a line

        DO forever

            for CCount = 32 to 127

                GLCDPrint ( 64 ,  36,  hex(longNumber_E ) )                 ; Print a HEX string
                GLCDPrint ( 76 ,  36,  hex(longNumber_U ) )                 ; Print a HEX string
                GLCDPrint ( 88 ,  36,  hex(longNumber_H ) )                 ; Print a HEX string
                GLCDPrint ( 100 ,  36, hex(longNumber   ) )                 ; Print a HEX string
                GLCDPrint ( 112 ,  36, "h" )                                ; Print a HEX string


                GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) )           ; Print a padded string
                GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) )           ; Print a padded string


                box (46,9,56,19)                                           ; Draw a Box
                GLCDDrawChar(48, 10, CCount )                               ; Draw a character
                outString = str( CCount )                                  ; Prepare a string
                GLCDDrawString(64, 10, pad(outString,3) )                   ; Draw a string

                filledbox 3,43,11,51, wordNumber                           ; Draw a filled box

                FilledCircle( 44,41,9, longNumber xor 1)                   ; Draw a filled box
                line 0,63,64,31                                            ; Draw a line

                                                                            ; Do some simple maths
                longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
            NEXT
        LOOP
        end</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
This example shows how to drive a ST7567 based Graphic I2C LCD module with the built in commands of GCBASIC using Low Memory Mode GLCD.
<?asciidoc-br?>
Note the use of <literal>GLCD_Open_PageTransaction</literal> and <literal>GLCD_Close_PageTransaction</literal> to support the Low Memory Mode of operation and the contraining of all GLCD commands with the transaction commands.  The use Low Memory Mode GLCD the two defines <literal>GLCD_TYPE_ST7567_LOWMEMORY_GLCD_MODE</literal> and <literal>GLCD_TYPE_ST7567_CHARACTER_MODE_ONLY</literal> are included in the user program.
<?asciidoc-br?></simpara>
<screen>    #chip {any valid chip}
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #DEFINE I2C_MODE MASTER
    #DEFINE I2C_DATA PORTB.4
    #DEFINE I2C_CLOCK PORTB.6
    #DEFINE I2C_DISABLE_INTERRUPTS ON

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_ST7567  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x7E
    #define GLCD_TYPE_ST7567_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_ST7567_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS

    'To clarify - page udpates
    '0,7 correspond with the Text Lines from 0 to 7 on a 64 Pixel Display
    'In this example Code would be GLCD_Open_PageTransaction 0,1 been enough
    'But it is allowed to use GLCD_Open_PageTransaction 0,7 to show the full screen update
    GLCD_Open_PageTransaction 0,7
       GLCDPrint 0, 0, "GCBASIC"
       GLCDPrint (0, 16, "Anobium 2024")
    GLCD_Close_PageTransaction
    wait 3 s
    DO forever

      for CCount = 31 to 127

        outString = str( CCount ) ; Prepare a string

        GLCD_Open_PageTransaction 0,7

           ' Prepare the static components of the screen
           GLCDPrint ( 0,   0, "PrintStr") ; Print some text
           GLCDPrint ( 64,  0, "@")
           ; Print some more text
           GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
           GLCDPrint ( 86, 0, "Mhz") ; Print some text
           GLCDDrawString( 0,8,"DrawStr") ; Draw some text
           box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           Circle( 44,41,15) ; Draw a circle
           line 64,31,0,31 ; Draw a line

           GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
           GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
           GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
           GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
           GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

           GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
           GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

           box (46,8,56,19) ; Draw a Box
           GLCDDrawChar(48, 9, CCount ) ; Draw a character

           GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

           filledbox 3,43,11,51, wordNumber ; Draw a filled box

           FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
           line 0,63,64,31 ; Draw a line

        GLCD_Close_PageTransaction

        ; Do some simple maths
        longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
       NEXT
    LOOP
    end</screen>
<simpara><?asciidoc-br?>
This example shows how to drive a ST7567 based Graphic SPI LCD module with the built in commands of GCBASIC.
<?asciidoc-br?></simpara>
<screen>    #chip  {any valid chip}
    #include &lt;glcd.h&gt;

    'Defines for a 7 pin SPI module
    'RES pin is pulsed low in glcd_ST7567.h for proper startup
    #define MOSI_ST7567 PortB.1
    #define SCK_ST7567 PortB.2
    #define DC_ST7567 PortB.3
    #define CS_ST7567 PortB.4
    #define RES_ST7567 PortB.5
    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_ST7567   'for 128 * 64 pixels support
    #define S4Wire_DATA

    dim longnumber as Long
    longnumber = 123456
    dim wordnumber as word
    wordnumber = 62535
    dim bytenumber as Byte
    bytenumber =255

    #define led PortB.0
    dir led out


    Do
         SET led ON
         wait 1 s
         SET led OFF

        GLCDCLS
        GLCDPrint (30, 0, "Hello World!")
        Circle (18,24,10)
        FilledCircle (48,24,10)
        Box (70,14,90,34)
        FilledBox (106,14,126,34)
        GLCDDrawString (32,35,"Draw String")
        GLCDPrint (0,46,longnumber)
        GLCDPrint (94,46,wordnumber)
        GLCDPrint (52,55,bytenumber)
        Line (0,40,127,63)
        Line (0,63,127,40)
        wait 3 s

    Loop</screen>
<simpara><?asciidoc-br?>
This example shows how to drive a ST7567 with the OLED fonts.  Note the use of the <literal>GLCDfntDefaultSize</literal> to select the size of the OLED font in use.
<?asciidoc-br?></simpara>
<screen>    #define GLCD_OLED_FONT

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7567" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</screen>
<simpara><?asciidoc-br?>
This example shows how to set the ST7567 OLED the lowest constrast level by using a OLED chip specific command.
<?asciidoc-br?></simpara>
<screen>    'Use the GCB command to set the lowest constrast
    GLCDSetContrast ( 0 )

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7567" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</screen>
<simpara><?asciidoc-br?></simpara>
<simpara>This example shows how to disable the large OLED Fontset.  This disables the font to reduce memory usage.</simpara>
<simpara>When the large OLED fontset is disabled every character will be shown as a block character.
<?asciidoc-br?></simpara>
<screen>    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts
    #define GLCD_Disable_OLED_FONT2       'The constant to disable the large fontset.

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7567" )
    GLCDPrint ( 0, 34, "Size: 128x64" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_st7735_controllers">
<title>ST7735 Controllers</title>
<simpara>This section covers GLCD devices that use the ST7735 graphics controller.  The ST7735 or ST7735R is a single-chip controller/driver for 262K-color, graphic type TFT-LCD.</simpara>
<simpara>GCBASIC supports 65K-color mode operations.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the ST7735 or ST7735R controller. &#160;&#160;&#160;GCBASIC supports an 8 bit bus connectivity. The 8 bit must be a single port of consective bits  - this is shown in the tables below.</simpara>
<simpara>To use the ST7735 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_ST7735R
    #define ST7735TABCOLOR ST7735_BLACKTAB  ; can also be ST7735_GREENTAB or ST7735_REDTAB or GLCD_TYPE_ST7735R_160_80

    'Pin mappings for ST7735
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS    porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting</screen>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ST7735</literal> or <literal>GLCD_TYPE_ST7735R</literal> or <literal>GLCD_TYPE_ST7735R_160_80</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ST7735TABCOLOR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the type of ST7735 chipset.  The default is <literal>ST7735_BLACKTAB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Options are <literal>ST7735_BLACKTAB</literal>, <literal>ST7735_GREENTAB</literal> or <literal>ST7735_REDTAB</literal>.  Each tab is a different ST7735 configuration. If you do not know  your type try each constant and test.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DATA_PORT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Not Available for this controller.</simpara></entry>
<entry align="left" valign="top"><simpara>Not applicable.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS) on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (GLCD out) pin on
the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_D0</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on
the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SLK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ST7735_HardwareSPI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that hardware SPI will be used</simpara></entry>
<entry align="left" valign="top"><simpara>SPI ports MUST be defined that match the SPI module for each specific microcontroller
</simpara><simpara>    <emphasis role="strong">#define ST7735_HardwareSPI</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWSPIMode</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the speed of the SPI communications for Hardware SPI only.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional defaults to MASTERFAST.
</simpara><simpara>Options are MASTERSLOW,<?asciidoc-br?>
MASTER,<?asciidoc-br?>
MASTERFAST, or<?asciidoc-br?>
MASTERULTRAFAST for specific AVRs only.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ST7735_XSTART</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the adjustment made to the X axis when writing to the GLCD.  This is used to correct any geometry correction required for specific GLCDs.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional.  Defaults are set for each specific GLCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ST7735_YSTART</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the adjustment made to the Y axis when writing to the GLCD.  This is used to correct any geometry correction required for specific GLCDs.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional.  Defaults are set for each specific GLCD.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>160</literal><?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>128</literal><?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="center" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte (LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ST7735_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF., see <link xlink:href="http://www.barth-dev.de/online/rgb565-color-picker/">http://www.barth-dev.de/online/rgb565-color-picker/</link> for a wider range of color parameters.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a ST7735 datasheet, please refer
<link xlink:href="http://www.crystalfontz.com/controllers/ST7735_V2.1_20100505.pdf">here.</link></simpara>
<simpara>For a ST7735R datasheet, please refer
<link xlink:href="https://cdn-shop.adafruit.com/datasheets/ST7735R_V0.2.pdf">here.</link></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F1937,32
    #config MCLRE_ON

    #include &lt;glcd.h&gt;

    'Defines for ST7735
GLCD_TYPE GLCD_TYPE_ST7735R
    'Pin mappings for ST7735
GLCD_DC porta.0
GLCD_CS porta.1
GLCD_RESET porta.2
GLCD_DI porta.3
GLCD_DO porta.4
GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the ST7735 Device")
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_st7789_controllers">
<title>ST7789 Controllers</title>
<simpara>This section covers GLCD devices that use the ST7789 graphics controller.  The ST7789 is a TFT LCD Single Chip Driver with 240x240 or 320x240 Resolution and 65K colors.</simpara>
<simpara>GCBASIC supports 65K-color mode operations.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the ST7789 controller. &#160;&#160;&#160;GCBASIC supports SPI hardware and software connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the ST7789 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE       GLCD_TYPE_ST7789_240_240
    //  #DEFINE GLCD_TYPE   GLCD_TYPE_ST7789_320_240

    'Pin mappings for ST7789 - these MUST be specified
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting

    'Optional to use the following - please check the datasheet for the specific GLCD.
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_DI     porta.3           'example port setting</screen>
<simpara>The GCBASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ST7789_240_240</literal> or <literal>GLCD_TYPE_ST7789_320_240</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Select one option to set geometry</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HWSPIMode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the speed of the SPI communications for Hardware SPI only.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional defaults to MASTERFAST.
</simpara><simpara>Options are MASTERSLOW,<?asciidoc-br?>
MASTER,<?asciidoc-br?>
MASTERFAST, or<?asciidoc-br?>
MASTERULTRAFAST for specific AVRs only.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal> or <literal>240</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>240</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the GCBASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6</literal> for GCB fonts, and <literal>5</literal> for OLED fonts.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_OLED_FONT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the use of the optional OLED font set.
</simpara><simpara>The GLCDfntDefaultsize can be set to 1 or 2 only.
</simpara><simpara><literal>GLCDfntDefaultsize=  1</literal>.   A small 8 height pixel font with variable width.
<literal>GLCDfntDefaultsize=  2</literal>.   A larger 10 width * 16 height pixel font.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS  [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDRotate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the display</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LANDSCAPE</literal>, <literal>PORTRAIT_REV</literal>, <literal>LANDSCAPE_REV</literal> and <literal>PORTRAIT</literal> are supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ST7789_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ReadPixel</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read the pixel color at the specified XY coordination.  Returns long variable with Red, Green and Blue encoded in the lower 24 bits.</simpara></entry>
<entry align="left" valign="top"><simpara>ReadPixel( Xosition , Yposition ) or ReadPixel_ST7789( Xosition , Yposition )
</simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>    TFT_BLACK       0x0000
    TFT_NAVY        0x000F
    TFT_DARKGREEN   0x03E0
    TFT_DARKCYAN    0x03EF
    TFT_MAROON      0x7800
    TFT_PURPLE      0x780F
    TFT_OLIVE       0x7BE0
    TFT_LIGHTGREY   0xC618
    TFT_DARKGREY    0x7BEF
    TFT_BLUE        0x001F
    TFT_GREEN       0x07E0
    TFT_CYAN        0x07FF
    TFT_RED         0xF800
    TFT_MAGENTA     0xF81F
    TFT_YELLOW      0xFFE0
    TFT_WHITE       0xFFFF
    TFT_ORANGE      0xFD20
    TFT_GREENYELLOW 0xAFE5
    TFT_PINK        0xF81F</screen>
<simpara>This example shows how to drive a ST7789 based Graphic LCD module with the built in commands of GCBASIC.</simpara>
<simpara>The library support PIC, AVR and LGT - change to suit your configuration.</simpara>
<simpara><emphasis role="strong">Example #1</emphasis></simpara>
<screen>    #chip LGT8F328P
    #include &lt;LGT8F328P.h&gt;
    #option explicit

    #include &lt;glcd.h&gt;
    #include &lt;glcd_st7789.h&gt;
    #define ST7789_HardwareSPI
    #define HWSPIMode MASTERULTRAFAST

    // Can be either pixels geometry
        #define GLCD_TYPE GLCD_TYPE_ST7789_240_240
        //#define GLCD_TYPE GLCD_TYPE_ST7789_320_240

    //Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       DIGITAL_8           ' Data command line
    #define GLCD_CS       DIGITAL_10          ' Chip select line
    #define GLCD_RESET    DIGITAL_9           ' Reset line
    #define GLCD_DI       DIGITAL_12          ' Data in | MISO    - Not used therefore not really required
    #define GLCD_DO       DIGITAL_11          ' Data out | MOSI
    #define GLCD_SCK      DIGITAL_13          ' Clock Line

    #define GLCD_EXTENDEDFONTSET1
    GLCDBackground = TFT_BLACK
    GLCDCLS TFT_BLACK

    GLCDfntDefaultsize = 2

    GLCDRotate Portrait_Rev
    GLCDPrint (0,0,"Hello World",TFT_GREEN)

    GLCDRotate Portrait
    GLCDPrint (0,0,"Hello World",TFT_GREEN)

    GLCDROTATE Landscape
    GLCDPrint (0,0,"Hello World",TFT_GREEN)

    GLCDROTATE Landscape_Rev
    GLCDPrint (0,0,"Hello World",TFT_GREEN)</screen>
<simpara><emphasis role="strong">Example #2</emphasis></simpara>
<simpara>This example shows how to drive a ST7789 using a PIC with PPS.</simpara>
<screen>    #chip 16F15376
    #option Explicit

        #startup InitPPS, 85

        Sub InitPPS
            #ifdef ST7789_HardwareSPI

                'This #ifdef is added to enable easy change from hardware SPI (using PPS) to software PPS that just uses the port assignments shown below.

                SSP1CLKPPS = 0x1    //RC3-&gt;MSSP1:SCK1
                RC3PPS = 0x15       //RC3-&gt;MSSP1:SCK1
                RC5PPS = 0x16       //RC5-&gt;MSSP1:SDO1
                SSP1DATPPS = 0x14   //RC4-&gt;MSSP1:SDI1

            #endif
        End Sub

    ' ********************** Setup the GLCD ************************************************

        #INCLUDE &lt;glcd.h&gt;
        #define GLCD_TYPE        GLCD__TYPE_ST7789_240_240
        // #define GLCD_TYPE     GLCD__TYPE_ST7789_320_240


        'This is a PPS chip, so, need to make the DO/SDO &amp; SCK match the PPS assignments
        #DEFINE GLCD_DO     portC.5
        #DEFINE GLCD_SCK    portC.3

        'Additinal pin assignments for GLCD
        #DEFINE GLCD_DC     portA.4
        #DEFINE GLCD_RESET  portA.1
        'It is optional on the ST7789 to set the GLCD_CS... therefore, here but commented out
        '#DEFINE GLCD_CS     porte.0

        'Uncomment out the next line... enable or disable the PPS!!!
        #DEFINE ST7789_HardwareSPI    ' remove/comment out if you want to use software SPI.0

    ' ********************** DEMO REALLY STARTS HERE ************************************************
    GLCDPrint(0, 0, "Test of the ST7789 Device")
    end</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example #3</emphasis></simpara>
<simpara>This example shows how to drive a ILI3941 with the OLED fonts.  Note the use of the <literal>GLCDfntDefaultSize</literal> to select the size of the OLED font in use.
<?asciidoc-br?></simpara>
<screen>    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7789" )
    GLCDPrint ( 0, 34, "Size: "+ Str(GLCD_WIDTH) +" x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example #4</emphasis></simpara>
<simpara>This example shows how to disable the large OLED Fontset.  This disables the font to reduce memory usage.</simpara>
<simpara>When the extended OLED fontset is disabled every character will be shown as a block character.</simpara>
<screen>    #define GLCD_OLED_FONT                'The constant is required to support OLED fonts
    #define GLCD_Disable_OLED_FONT2       'The constant to disable the extended OLED fontset.

    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    GLCDPrint ( 40, 0, "OLED" )
    GLCDPrint ( 0, 18, "Typ:  ST7789" )
    GLCDPrint ( 0, 34, "Size: "+ Str(GLCD_WIDTH) +" x 240" )

    GLCDfntDefaultSize = 1
    GLCDPrint(20, 56,"https://goo.gl/gjrxkp")</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_st7920_controllers">
<title>ST7920 Controllers</title>
<simpara>This section covers GLCD devices that use the ST7920 graphics controller.</simpara>
<simpara>The GCBASIC constants for control of the connectivity are shown
in the table below. The only connectivity option the 8-bit mode where 8
pins are connected between the microcontroller and the GLCD to control the
data bus.<?asciidoc-br?></simpara>
<simpara>The ST7920 GLCD is graphics and character mixed mode display.<?asciidoc-br?></simpara>
<simpara>ST7920 LCD controller/driver IC can display alphabets, numbers, Chinese
fonts and self-defined characters.&#160;&#160;&#160;It supports 3 kinds of bus interface,
namely 8-bit, 4-bit and serial.&#160;&#160;&#160;GCBASIC is currently supports
8-bit only. For LCD only operations (text characters only) you can use
the GCBASIC LCD routines.<?asciidoc-br?></simpara>
<simpara>All functions, including display RAM, Character Generation ROM, LCD
display drivers and control circuits are all in a one-chip solution.
With a minimum system configuration, a Chinese character display system
can be easily achieved.<?asciidoc-br?></simpara>
<simpara>The ST7920 includes character ROM with 8192 16x16 dots Chinese fonts and
126 16x8 dots half-width alphanumerical fonts.&#160;&#160;&#160;It supports 64x256 dots
graphic display area for graphic display (GDRAM).&#160;&#160;&#160;Mix-mode display with
both character and graphic data is possible.&#160;&#160;&#160;ST7920 has built-in CGRAM
and provide 4 sets software programmable 16x16 fonts.<?asciidoc-br?></simpara>
<simpara>To use the ST7920 driver simply include the following in your user code.  This will initialise the driver.<?asciidoc-br?></simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ST7920

    #define GLCD_Enable     PORTA.1           'example port setting
    #define GLCD_RS         PORTa.0           'example port setting
    #define GLCD_RW         PORTA.2           'example port setting
    #define GLCD_RESET      PORTA.3           'example port setting
    #define GLCD_DATA_PORT  PORTD             'example port setting</screen>
<simpara>The GCBASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ST7920</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DATA_PORT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output port that is connected between the microcontroller
and the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Register Select on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the GLCD.
The R/W pin can be disabled*.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis> <emphasis>unless R/W is disabled), see</emphasis> <literal>GLCD_NO_RW</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RESET</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_ENABLE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Enable on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_NO_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disables read/write inspection of the device during read/write
operations</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, but recommend NOT to set.
The R/W pin can be disabled by setting the <literal>GLCD_NO_RW</literal> constant. If this
is done, there is no need for the <literal>R/W</literal> to be connected to the chip, and
no need for the <literal>LCD_RW</literal> constant to be set. Ensure that the <literal>R/W</literal> line on
the LCD is connected to ground if not used.</simpara></entry>
</row>
<row>
<entry align="left" valign="top" namest="col_1" nameend="col_3"><simpara>Constants that control the timing of the library</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ST7920READDELAY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the time delay between read data transmissions.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, set to <literal>20</literal> us as the default value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ST7920WRITEDELAY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the time delay between write data transmissions.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, set to <literal>2</literal> us as the default value.
</simpara><simpara></simpara><simpara>    ' read delay of 25 is required at 32mhz, this can be reduced to 0 for slower clock speeds
    #DEFINE ST7920READDELAY 25
    ' write delay of 2 is required at 32mhz.  this can be reduced to 1 for slower clock speeds
    #DEFINE ST7920WRITEDELAY 2</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below. <?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>128</literal>&#160;&#160;cannot be changed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>64</literal>&#160;&#160;cannot be changed.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the
table below. For device specific see the commands with the prefix of
ST7920*.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top" namest="col_1" nameend="col_3"><simpara>The following methods ( calls ) are available for expert use.
<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte (LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a TS7920 datasheet, please refer
<link xlink:href="http://www.crystalfontz.com/controllers/ST7920.pdf">here.</link></simpara>
<simpara>This example shows how to drive a ST7920 based Graphic LCD module with
the built in commands of GCBASIC. See
<link xlink:href="http://www.greatcowbasic.com/sample-projects.html">Graphic LCD</link> for
details, this is an external web site.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    ;Chip Settings
    #CHIP 16F1937,32
    #CONFIG  MCLRE_ON

    #INCLUDE &lt;GLCD.H&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ST7920
    #DEFINE GLCD_IO 8
    #DEFINE GLCD_WIDTH 128
    #DEFINE GLCD_HEIGHT 160
    ' read delay of 25 is required at 32mhz, this can be reduced to 0 for slower clock speeds
    #DEFINE ST7920READDELAY 25
    ' write delay of 2 is required at 32mhz.  this can be reduced to 1 for slower clock speeds
    #DEFINE ST7920WRITEDELAY 2

    #DEFINE GLCD_RS PORTA.0
    #DEFINE GLCD_ENABLE PORTA.1
    #DEFINE GLCD_RW PORTA.2
    #DEFINE GLCD_RESET PORTA.3
    #DEFINE GLCD_DATA_PORT PORTD

    ST7920GLCDEnableGraphics
    GLCDClearGraphics_ST7920
    GLCDPrint 0, 1, "GCBASIC "
    wait 1 s

    GLCDCLS
    GLCDClearGraphics_ST7920

    rrun = 0
    dim msg1 as string * 16

    dim  xradius, yordinate , radiusErr, incrementalxradius, orginalxradius, orginalyordinate as Integer


    Do forever
        GLCDCLS
        GLCDClearGraphics_ST7920          ;clear screen
        GLCDDrawString 30,0,"ChipMhz@"    ;print string
        GLCDDrawString 78,0, str(ChipMhz) ;print string
        Circle(10,10,10,0)            ;upper left
        Circle(117,10,10,0)           ;upper right
        Circle(63,31,10,0)            ;center
        Circle(63,31,20,0)            ;center
        Circle(10,53,10,0)            ;lower left
        Circle(117,53,10,0)           ;lower right
        GLCDDrawString 30,54,"PIC16F1937" ;print string
        wait 1 s                  ;wait
        FilledBox( 0,0,128,63)          ;create box
        for ypos = 0 to 63              ;draw row by row
             Line 0,ypos,128, 0      ;draw line
        next
        wait 1 s                  ;wait
        GLCDClearGraphics_ST7920          ;clear
    loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    ;Chip Settings
    #CHIP 16F1937,32
    #CONFIG MCLRE_ON

    #INCLUDE &lt;GLCD.H&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ST7920
    #DEFINE GLCD_IO 8
    #DEFINE GLCD_WIDTH 128
    #DEFINE GLCD_HEIGHT 160

    ' read delay of 25 is required at 32mhz, this can be reduced to 0 for slower clock speeds
    #DEFINE ST7920READDELAY 25
    ' write delay of 2 is required at 32mhz.  this can be reduced to 1 for slower clock speeds
    #DEFINE ST7920WRITEDELAY 2

    #DEFINE GLCD_RS PORTA.0
    #DEFINE GLCD_ENABLE PORTA.1
    #DEFINE GLCD_RW PORTA.2
    #DEFINE GLCD_RESET PORTA.3
    #DEFINE GLCD_DATA_PORT PORTD

    WAIT 1 S
    GLCDEnableGraphics_ST7920
    GLCDClearGraphics_ST7920
    Tile_ST7920 "A"
    GLCDPrint 0, 1, "GCBASIC "

    GLCDCLS

    rrun = 0
    dim msg1 as string * 16

    do forever

    GLCDEnableGraphics_ST7920
    GLCDClearGraphics_ST7920
    GTile_ST7920 0x55, 0x55
    wait 1 s

    GLCDClearGraphics_ST7920
    Lineh_ST7920(0, 0, GLCD_WIDTH)
    Lineh_ST7920(0, GLCD_HEIGHT - 1, GLCD_WIDTH)
    Linev_ST7920(0, 0, GLCD_HEIGHT)
    Linev_ST7920(GLCD_WIDTH - 1, 0, GLCD_HEIGHT)

    Box 18,30,28,40

    WAIT 2 S

    FilledBox 18,30,28,40

    GLCDClearGraphics_ST7920

    Start:

    GLCDDrawString 0,10,"Hello" 'Print Hello
    wait 1 s
    GLCDDrawString 0,10, "ASCII #:" 'Print ASCII #:
    Box 18,30,28,40 'Draw Box Around ASCII Character
    for char = 0x30 to 0x39        'Print 0 through 9
          GLCDDrawString 16, 20 , Str(char)+"  "
          GLCDdrawCHAR 20, 30, char
          wait 250 ms
    next
    line 0,50,127,50    'Draw Line using line command
    for xvar = 0 to 80  'draw line using Pset command
            pset xvar,63,on                    '
    next
    FilledBox 18,30,28,40 'Draw Box Around ASCII Character
    Wait 1 s
    GLCDClearGraphics_ST7920
    GLCDDrawString 0,10,"End  "
    wait 1 s
    GLCDClearGraphics_ST7920

    workingGLCDDrawChar:
    GLCDEnableGraphics_ST7920
    dim gtext as string
    gtext = "ST7920 @QC12864B"

    for xchar = 1 to gtext(0)  'Print 0 through 9
          xxpos = (1+(xchar*6)-6)
          GLCDDrawChar xxpos , 0 , gtext(xchar)
    next

    GLCDDrawString  1, 9, "GCBASIC"
    GLCDDrawString  1, 18,"GLCD 128*64"
    GLCDDrawString  1, 27,"Using GLCD.H from GCB"
    GLCDDrawString  1, 37,"Using GLCD.H GCB"
    GLCDDrawString  1, 45,"GLCDDrawChar method"
    GLCDDrawString  1, 54,"Test Routines"
    wait 1 s

    GLCDClearGraphics_ST7920
    ST7920GLCDDisableGraphics
    GLCDCLS

    msg1 = "Run = " +str(rrun)
    rrun++
    GLCDPrint 0, 0, "ST7920 @QC12864B"
    GLCDPrint 0, 1, "GCBASIC "
    GLCDPrint 0, 2, "GLCD 128*64"
    GLCDPrint 0, 3, msg1
    wait 5 s
    GLCDCLS

    ' show all chars... takes some time!
    ST7920CallBuiltinChar

    wait 1 s
    GLCDCLS

    ' See http://www.khngai.com/chinese/charmap/tblbig.php?page=0
    ' and see https://sourceforge.net/projects/vietunicode/files/hannom/hannom%20v2005/ for the FONTS!!

    dim BIG5code as word

    'ST7920 can display half-width HCGROM fonts, user- defined CGRAM fonts and full 16x16 CGROM fonts. The
    'character codes in 0000H~0006H will use user- defined fonts in CGRAM. The character codes in 02H~7FH will use
    'half-width alpha numeric fonts. The character code larger than A1H will be treated as 16x16 fonts and will be
    'combined with the next byte automatically. The 16x16 BIG5 fonts are stored in A140H~D75FH while the 16x16 GB
    'fonts are stored in A1A0H~F7FFH. In short:
    '1. To display HCGROM fonts:
    'Write 2 bytes of data into DDRAM to display two 8x16 fonts. Each byte represents 1 character.
    'The data is among 02H~7FH.
    '2. To display CGRAM fonts:
    'Write 2 bytes of data into DDRAM to display one 16x16 font.
    'Only 0000H, 0002H, 0004H and 0006H are acceptable.
    '3. To display CGROM fonts:
    'Write 2 bytes of data into DDRAM to display one 16x16 font.
    'A140H~D75FH are BIG5 code, A1A0H~F7FFH are GB code.

    'To display HCGROM fonts
    ' Write 2 bytes of data into DDRAM to display two 8x16 fonts. Each byte represents 1 character.
    ' The data is among 02H~7FH.
    ' The english characters set...

    linetest1:

      GLCDEnableGraphics_ST7920

      wait 1 s
      GLCDClearGraphics_ST7920

    'lineh test
    LineH_ST7920(0, 0, GLCD_WIDTH)
    LineH_ST7920(0, GLCD_HEIGHT - 1, GLCD_WIDTH)
    LineV_ST7920(0, 0, GLCD_HEIGHT)
    LineV_ST7920(GLCD_WIDTH - 1, 0, GLCD_HEIGHT)

    ' box test
    LineH_ST7920(10 ,0 , 118 )
    LineH_ST7920(0 ,8 , 128)
    LineH_ST7920(16 ,16 , 96 )
    LineH_ST7920(10 ,32 , 108 )
    LineH_ST7920(0, 16, GLCD_WIDTH)
    LineH_ST7920(0, 24, GLCD_WIDTH)
    LineH_ST7920(0, 32, GLCD_WIDTH)
    LineH_ST7920(0, 40, GLCD_WIDTH)
    LineH_ST7920(0, 48, GLCD_WIDTH)
    LineH_ST7920(0, 56, GLCD_WIDTH)
    LineH_ST7920(0, 63, GLCD_WIDTH)
    LineV_ST7920(16, 0, GLCD_HEIGHT)
    LineV_ST7920(17, 0, GLCD_HEIGHT)
    LineV_ST7920(15, 0, GLCD_HEIGHT)

    LineV_ST7920(46, 0, GLCD_HEIGHT)
    LineV_ST7920(47, 0, GLCD_HEIGHT)
    LineV_ST7920(48, 0, GLCD_HEIGHT)

    LineV_ST7920(46, 0, GLCD_HEIGHT)
    LineV_ST7920(47, 0, GLCD_HEIGHT)
    LineV_ST7920(48, 0, GLCD_HEIGHT)

    LineV_ST7920(96, 0, GLCD_HEIGHT)
    LineV_ST7920(97, 0, GLCD_HEIGHT)
    LineV_ST7920(98, 0, GLCD_HEIGHT)

    for HCGROM = 0 to GLCD_WIDTH step 8
        LineV_ST7920(HCGROM, 0, GLCD_HEIGHT)
    next

    GraphicTestPlace:

      GLCDClearGraphics_ST7920
      GraphicTest_ST7920
      GLCDClearGraphics_ST7920

      ' Test draw a line
      for yrowpos = 0 to 63 step 4
        LineH_ST7920(0, yrowpos, GLCD_WIDTH)
      next

      GLCDClearGraphics_ST7920
      ST7920GLCDDisableGraphics
      GLCDCLS

      SetIcon_ST7920( 1, 0x55 )

    loop

    sub ST7920CallBuiltinChar
        ' 0xA140 ~ 0xA15F
          for ii = 0 to 31

              WriteData_ST7920( 0xA1)
              WriteData_ST7920( 0x40 + ii)

          next

          wait 1 s

          GLCDCLS

          ' 0xA140 ~ 0xA15F
          for ii = 0 to 31

              WriteData_ST7920( 0xA1)
              WriteData_ST7920( 0xb0 + ii)

          next
          wait 1 s
          GLCDCLS

          ' 0xA140 ~ 0xA15F
          for ii = 0 to 31

              WriteData_ST7920( 0xA4)
              WriteData_ST7920( 0x40 + ii)

          next
          wait 1 s
          GLCDCLS
    end sub</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
<section xml:id="_st7920glcdcleargraphics">
<title>ST7920GLCDClearGraphics</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GLCDClearGraphics</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command clears the GCLD display.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920GLCDClearGraphics 'clear the screen</screen>
</section>
<section xml:id="_st7920glcddisablegraphics">
<title>ST7920GLCDDisableGraphics</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GLCDDisableGraphics</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command sets the GCLD display controller to text mode.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920GLCDDisableGraphics 'Set to text mode</screen>
</section>
<section xml:id="_st7920glcdenablegraphics">
<title>ST7920GLCDEnableGraphics</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GLCDEnableGraphics</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command sets the GCLD display controller to text mode.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920GLCDEnableGraphics 'Set to text mode</screen>
</section>
<section xml:id="_st7920graphictest">
<title>ST7920GraphicTest</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GraphicTest</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command tests the graphics functionality of the GLCD display.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920GraphicTest ‘Test the display</screen>
</section>
<section xml:id="_st7920linehs">
<title>ST7920LineHs</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920LineHs ( Xpos, Ypos, XLength, Style)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command draws a line with a specific style. The style is based on
the bits value of the byte passed to the routine.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920LineHs ( 0, 31,128 , 0x55) ‘will draw a dashed line</screen>
</section>
<section xml:id="_st7920locate">
<title>ST7920Locate</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920Locate ( Xpos, Ypos)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command locates the pixel at the specific X and Y location of the
text screen. Subsequent printing to the GLCD will place a character to
the GLCD controller on the specified row and column. Due to the design
of the ST7920 controller (to accomodate Mandarin and Cyrillic), you must
place the text on the column according to the numbers above the diagram
below. The addressing is handle by the command.</simpara>
<screen>|--0--|--1--|--2--|...      ...|--7--|

+--+--+--+--+--+---------------------+

|H |e |l |l |o |  ...                | &lt;- row 0 (address 0x80)

+--+--+--+--+--+---------------------+

|T |h |i |s |  |i ...                | &lt;- row 1 (address 0x90)

+--+--+--+--+--+---------------------+

|' |' |' |' |' |' ...                | &lt;- row 2 (address 0x88)

+--+--+--+--+--+---------------------+

|- |- |- |- |- |- ...                | &lt;- row 3 (address 0x98)

+--+--+--+--+--+---------------------+</screen>
<simpara>Writing 'a' onto the 1st column, and 1st row:</simpara>
<screen>|--0--|--1--|--2--|...      ...|--7--|

+--+--+--+--+--+---------------------+

|  |  |  |  |  |  ...                | &lt;- row 0 (address 0x80)

+--+--+--+--+--+---------------------+

|  |  |a |  |  |  ...                | &lt;- row 1 (address 0x90)

+--+--+--+--+--+---------------------+

|  |  |  |  |  |  ...                 | &lt;- row 2 (address 0x88)

+--+--+--+--+--+---------------------+

|  |  |  |  |  |  ...                | &lt;- row 3 (address 0x98)

+--+--+--+--+--+---------------------+</screen>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920Locate ( 64, 31) ‘the pixel at the mid screen point</screen>
</section>
<section xml:id="_st7920tile">
<title>ST7920Tile</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920Tile ( word variable )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command tiles the screen with the word value provided.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    Dim tileValue as word
    tileValue = (0x55 * 256 ) + 0x55
    ST7920Tile (tileValue) ‘tile the screen with a nice cross hatch</screen>
</section>
<section xml:id="_st7920ctile">
<title>ST7920cTile</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  ST7920cTile ( word variable )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Tiles screen with a Chinese Symbol.</simpara>
<simpara>This required 2 bytes of data into DDRAM to display one 16x16 font from
memory location A140H~D75FH are BIG5 code, A1A0H~F7FFH are GB code.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    Dim CTileValue as word
    cTileValue = (0xA140H * 256 ) + 0xA140H
    ST7920Tile (CTileValue) ‘tile the screen with a nice cross hatch</screen>
</section>
<section xml:id="_st7920glocate">
<title>ST7920gLocate</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920gLocate ( Xpos, Ypos)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command locates the pixel at the specific X and Y location of the
graphical screen.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920gLocate ( 64, 31) ‘the pixel at the mid screen point</screen>
</section>
<section xml:id="_st7920gtile">
<title>ST7920gTile</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920gTile ( byte variable , byte variable)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Tile LCD screen with two bytes in Graphic Mode.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920gTile (0x55, 0x85) ‘tile the screen with an odd cross hatch</screen>
</section>
<section xml:id="_st7920lineh">
<title>ST7920lineh</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920lineh ( Xpos, Ypos, xUnitsStyle, )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command draws a horizontal line with the specific style. The style
can be ON or OFF. Default is ON.</simpara>
<simpara>This is called by the GLCD common routines.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920lineh ( 0, 31,128 , ON) ‘will draw a line</screen>
</section>
<section xml:id="_st7920linev">
<title>ST7920linev</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920lineh ( Xpos, Ypos, xUnitsStyle, )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command draws a vertical line with the specific style. The style
can be ON or OFF. Default is ON</simpara>
<simpara>This is called by the GLCD common routines.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920lineh ( 0, 31,128 , ON) ‘will draw a line</screen>
</section>
<section xml:id="_st7920glcdreadbyte">
<title>ST7920GLCDReadByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    byte_variable = ST7920GLCDReadByte</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This function return the word value (16 bits) of the GLCD display for
the current XY position.</simpara>
<simpara>This is called by the GLCD common routines.</simpara>
<simpara>See the data sheet for more information.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    SET GLCD_RS OFF

    ST7920WriteByte( SysCalcPositionY )
    ST7920WriteByte( SysCalcPositionX )
    ' read data
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = (GLCDDataTempWord*256) + ST7920GLCDReadByte</screen>
</section>
<section xml:id="_st7920writebyte">
<title>ST7920WriteByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GLCDWriteByte</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command write to the appropriate location as specified by the
current XY position.</simpara>
<simpara>This is called by the GLCD common routines.</simpara>
<simpara>See the data sheet for more information.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ...

    SET GLCD_RS OFF

    ST7920WriteByte( SysCalcPositionY )
    ST7920WriteByte( SysCalcPositionX )
    ' read data
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = (GLCDDataTempWord*256) + ST7920GLCDReadByte
    ...</screen>
</section>
<section xml:id="_st7920writecommand">
<title>ST7920WriteCommand</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GWriteCommand ( byte_variable)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command writes a command to the controller.</simpara>
<simpara>See the data sheet for more information.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ...
    ST7920WriteCommand(0x36) ' set the graphics mode on
    GLCD_TYPE_ST7920_GRAPHICS_MODE = true
    ...</screen>
</section>
<section xml:id="_st7920writedata">
<title>ST7920WriteData</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GWriteData ( byte_variable)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command writes data to the controller.</simpara>
<simpara>See the data sheet for more information.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ...
    for yy = 0 to ( GLCD_HEIGHT - 1 )
      ST7920gLocate(0, yy)
      for xx = 0 to ( GLCD_COLS -1 )
        ST7920WriteData( 0x55 )
        T7920WriteData( 0x55 )
      next
    next
    ...</screen>
</section>
<section xml:id="_st7920greaddata">
<title>ST7920gReaddata</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    byte_variable = ST7920gReaddata</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This function return the word value (16 bits) of the GLCD display for
the current XY position.</simpara>
<simpara>See the data sheet for more information.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ...
    ' Read a word from the display device.
    word_variable = ST7920GLCDReadData</screen>
</section>
</section>
<section xml:id="_t6963_controllers">
<title>T6963 Controllers</title>
<simpara>This section covers Graphical Liquid Crystal Display (GLCD) devices that use the Toshiba T6963 graphics controller.&#160;&#160;&#160;The T6963 is a monochrome device that typically is blue or white.&#160;&#160;&#160;The GLCD can be provided in a number of pixels sizes - 240 * 64 or 240 * 128.
<?asciidoc-br?>
<?asciidoc-br?>
The Toshiba T6963 is a very popular LCD controller for use in small graphics modules. It is capable of controlling displays with a resolution up to 240x128. Because of its low power and
small outline it is most suitable for mobile applications such as PDAs, MP3 players or mobile measurement equipment.
<?asciidoc-br?>
<?asciidoc-br?>
A number of GLCD  modules have this controller built-in these include the SP12N002 &amp; SP14N001. Although this controller is small, it has the capability of displaying
and merging text and graphics and it manages all the interfacing signals to the displays Row and Column drivers.&#160;&#160;&#160;The GCBASIC library supports the complex capabilities of the T6963.
<?asciidoc-br?>
<?asciidoc-br?>
The T6963 is an LCD is driven by on-board 5V parallel interface chipset T6963.&#160;&#160;&#160;For the specific operating voltage always verify the operating voltages in the device specific datasheet.
<?asciidoc-br?>
<?asciidoc-br?>
The GCBASIC connectivity option is the 8-bit mode - where 8 connections (for the data) are required between the microcontroller and the GLCD to control the data bus.
<?asciidoc-br?>
<?asciidoc-br?>
To use the T6963 driver simply include the following in your user code.  &#160;&#160;&#160;This will initialise the driver.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    #chip 16f1939,32
    #option explicit

    '***********************************************************************************************
    'Specify this GLCD - a 240 x 64 pixels display
    #include &lt;glcd.h&gt;
     #define GLCD_TYPE GLCD_TYPE_T6963_64

    '***********************************************************************************************
    'define the connectivity - the 8bit port
    #define GLCD_DATA_PORT PORTD             'Library support contigous 8-bit port

  '  or
  '  #define GLCD_DB0      PORTD.0            'chip specific configuration where the ibrary supports 8-bit port defined via 8 constants
  '  #define GLCD_DB1      PORTD.1            'chip specific configuration
  '  #define GLCD_DB2      PORTD.2            'chip specific configuration
  '  #define GLCD_DB3      PORTD.3            'chip specific configuration
  '  #define GLCD_DB4      PORTD.4            'chip specific configuration
  '  #define GLCD_DB5      PORTD.5            'chip specific configuration
  '  #define GLCD_DB6      PORTD.6            'chip specific configuration
  '  #define GLCD_DB7      PORTD.7            'chip specific configuration

     #define GLCD_CS        PORTa.7           'Chip Enable (Active Low)
     #define GLCD_CD        PORTa.0           'Command or Data conrol line port
     #define GLCD_RD        PORTA.1           'Read control line  port
     #define GLCD_WR        PORTA.2           'Write control line port
     #define GLCD_RESET     PORTA.3           'Reset port
     #define GLCD_FS        PORTA.5           'FS port
     #define GLCD_FS_SELECT 1                 'FS1 Font Select port. 6x8 font: FS1=“High”=1 8x8 font FS1=“Low”=0 for GLCD_FS_SELECT

    '***********************************************************************************************
    '*
    '* Note    :   The T6963 controller's RAM address space from $0000 - $7FFF, total 32kbyte RAM, or it could be 64kbyte RAM best check!!
    '*
    '***********************************************************************************************
     #define TEXT_HOME_ADDR      0x0000                                                         'This is specific to the GLCD display
     #define GRH_HOME_ADDR       0x3FFF                                                         'This is specific to the GLCD display
     #define CG_HOME_ADDR        0x77FF                                                         'This is specific to the GLCD display
     #define COLUMN              40    'Set column number to be 40 , 32, 30 etc.                 This is specific to the GLCD display
     #define MAX_ROW_PIXEL       64    'MAX_ROW_PIXEL the physical matrix length (y direction)   This is specific to the GLCD display
     #define MAX_COL_PIXEL       240   'MAX_COL_PIXEL the physical matrix width (x direction)    This is specific to the GLCD display

    '***********************************************************************************************
    '* End of configuration
    '***********************************************************************************************</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The GCBASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_TYPE_T6963_64</literal> or <literal>GLCD_TYPE_T6963_128</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DATA_PORT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A full 8-bit port.  8 contigous input/outputs.</simpara></entry>
<entry align="left" valign="top"><simpara>or use GLCD_DB0..GLCD_DB7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB0..7</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A 8-bit port using 8 input/outputs.</simpara></entry>
<entry align="left" valign="top"><simpara>or use GLCD_DATA_PORT</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CD</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Command/Data on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RD</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Write on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RESET</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_FS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to FS  on the GLCD.  The FS specifies the font size.  Please set to 6 setting  GLCD_FS_SELECT = 1</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_FS_SELECT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to FS  on the GLCD.  The FS specifies the font size.  Please set to 6 setting  GLCD_FS_SELECT = 1</simpara></entry>
<entry align="left" valign="top"><simpara>Required.  Can be 1 or 0.  Default setting is 1.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The T6963 differs from most other GLCD controllers in its use of the display RAM.&#160;&#160;&#160; Where a fixed area
of memory is normally allocated for text, graphics and the external character generator, but with
the T6963 the size for each area <emphasis role="strong">MUST</emphasis> be set by software commands.&#160;&#160;&#160; This means that the area for
text, graphics and external character generator can be freely allocated within the external
memory, up to 64 kByte.&#160;&#160;&#160;Check the specific device for the amount of memory available.&#160;&#160;&#160;This can range from 4 kbyte to 64 kbyte.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
For more information on memory management refer the device specific datasheet.
<?asciidoc-br?>
<?asciidoc-br?>
The GCBASIC constants control the memory configuration of the T6963 controller.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Comments</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>TEXT_HOME_ADDR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>0x0000</simpara></entry>
<entry align="left" valign="top"><simpara>This is specific to the GLCD display</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GRH_HOME_ADDR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>0x3FFF</simpara></entry>
<entry align="left" valign="top"><simpara>This is specific to the GLCD display</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CG_HOME_ADDR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>0x77FF</simpara></entry>
<entry align="left" valign="top"><simpara>This is specific to the GLCD display</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>COLUMN</literal></simpara></entry>
<entry align="left" valign="top"><simpara>40</simpara></entry>
<entry align="left" valign="top"><simpara>Set column number to be 40 , 32, 30 etc.  This is specific to the GLCD display</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MAX_ROW_PIXEL</literal></simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
<entry align="left" valign="top"><simpara>MAX_ROW_PIXEL the physical matrix length (y direction)   This is specific to the GLCD display</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MAX_COL_PIXEL</literal></simpara></entry>
<entry align="left" valign="top"><simpara>240</simpara></entry>
<entry align="left" valign="top"><simpara>MAX_COL_PIXEL the physical matrix width (x direction)    This is specific to the GLCD display</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The GCBASIC library supports the following capabilities.&#160;&#160;&#160;Please refer to the relevant Help section and the device specific demonstrations.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Commands Supported for the LCD and GLCD</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The GLCD command set covers the standard GLCDCLS, Line, Circle and all the GLCD methods and the  LCD command set: CLS, Locate, Print, LCDHEX etc.  The demonstrations show how to load BMP loading via external data sources and GLCD and LCD page swapping.
<?asciidoc-br?>
<?asciidoc-br?>
The table below shows the specific implementations of the command set for this device.&#160;&#160;&#160;Refer to the GLCD and LCD in the Help for the generic GLCD and LCD commands.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="66*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Commands</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Usage</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>CLS</simpara></entry>
<entry align="left" valign="top"><simpara>Clear the screen of the current LCD page</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LOCATE</simpara></entry>
<entry align="left" valign="top"><simpara>Locate the cursor at a specific screen position</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PRINT</simpara></entry>
<entry align="left" valign="top"><simpara>Print numbers or strings</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PUT</simpara></entry>
<entry align="left" valign="top"><simpara>Put a specific ASCII code at a specific screen position</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LCDHOME</simpara></entry>
<entry align="left" valign="top"><simpara>Set output position of 0, 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LCDcmd</simpara></entry>
<entry align="left" valign="top"><simpara>Send specific command to the device to control the device.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LCDdata</simpara></entry>
<entry align="left" valign="top"><simpara>Send specific data to the device to control the device.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LCDHex</simpara></entry>
<entry align="left" valign="top"><simpara>Print Hex value of a number to the LCD screen</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LCDSpace</simpara></entry>
<entry align="left" valign="top"><simpara>Print a number of space to the LCD screen</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LCDCursor</simpara></entry>
<entry align="left" valign="top"><simpara>Send specific commands to the device to control the cursor</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCDCLS</simpara></entry>
<entry align="left" valign="top"><simpara>Clear the screen of the current GLCD page</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCDRotate</simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the GLCD screen. Only Landscape rotation is supported.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SelectGLCDPage_T6963</simpara></entry>
<entry align="left" valign="top"><simpara>Select a specific GLCD page.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SelectLCDPage_T6963</simpara></entry>
<entry align="left" valign="top"><simpara>Select a specific LCD page.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">GLCD and LCD page swapping</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
To support GLCD and LCD page swapping - this can be used to support fixed pages of information, BMPs or scrolling the following constants have are available to the user.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>For GLCD memory addressing</simpara>
<screen>  GLCDPage0_T6963
  GLCDPage1_T6963
  GLCDPage2_T6963
  ... etc
  GLCDPage10_T6963</screen>
<simpara>Ten pages are automatically created but the number of pages available is constrained by the memory configuration.
<?asciidoc-br?>
<?asciidoc-br?>
For LCD memory addressing</simpara>
<screen>  LCDPage0_T6963
  LCDPage1_T6963
  LCDPage2_T6963
  ...etc
  LCDPage10_T6963</screen>
<simpara>Ten pages are automatically created but the number of pages available is constrained by the memory configuration.
<?asciidoc-br?>
To use add the following to you user program.&#160;&#160;&#160;See the demonstration programs for more detailed usage.&#160;&#160;&#160;After calling the <literal>SelectGLCDPage</literal> or <literal>SelectLCDPage</literal> methods all GLCD or LCD commands will be applied to the current GLCD or LCD page.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    'Select the GLCD page 1 memory
    SelectGLCDPage ( GLCDPage1_T6963 )

    'Select the LCD page 2 memory
    SelectLCDPage ( LCDPage2_T6963 )</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The <literal>SelectLCDPage</literal> and <literal>SelectLCDPage</literal> and "Set Text Home Address" methods change the screen being viewed on the device.</simpara>
<simpara>The key is to establish what you want your memory map to look like.  &#160;&#160;&#160; Below is a map for one of my 240 x 64 pixel  device.   &#160;&#160;&#160; The default is for 10 screen pages (some newer LCD&#8217;s may have more RAM for more screens). &#160;&#160;&#160; If you write the appropriate value (0x1000, or 0x11b0, or 0x1360, etc) to the text home address, the display will instantly change to that screen - using <literal>SelectLCDPage</literal> and <literal>SelectLCDPage</literal> method with the appropiate constant as parameter.</simpara>
<simpara>You can write your screens "ahead of time", in my case during the "splash screen" delay interval, and instantly change to them later as desired. &#160;&#160;&#160; You can do this by setting <emphasis role="strong">current_grh_home_addr</emphasis> to the appropiate page. &#160;&#160;&#160;And, then execute the GLCD commands you would normal use.</simpara>
<simpara>The graphic and text screens are independant but can be overlaid for a variety of useful effects.</simpara>
<simpara>Although, not tested,  the LCD text screens can be scrolled 1 full text line at a time, while the GLCD screens can be scrolled 1 pixel row at a time, provided you&#8217;ve set up your memory map accordingly with adequate RAM for the graphic area.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Default Memory Map</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>            '
            '*******************************************************
            '
            ' LCD MEMORY MAP
            '
            '*******************************************************
            '
            '
            '
            ' --------------------
            ' |                  | 0x0000
            ' |                  |
            ' | TEXT RAM AREA    | Each page has the numnbers of bytes + extra
            ' | ( 10 SCREENs )   | few bytes need to attributes. This is
            ' |                  | mentioned in the datasheet but imperical
            ' |                  | testing shows... you need the extra bytes
            ' --------------------
            ' |                  |
            ' | xx bytes unused  |
            ' |                  |
            ' --------------------
            ' |                  | 0x3fff
            ' |                  |
            ' |                  |
            ' |  GCLD RAM AREA   |
            ' |  ( 10 SCREENS )  |
            ' |                  |
            ' |                  |
            ' |          |
            ' --------------------
            ' |                  | 0x77ff
            ' |   CG RAM AREA    | (Sacrosanct)
            ' |                  |
            ' -------------------- 0x7ffff
            '</screen>
<simpara><emphasis role="strong">Other methods and constants</emphasis>
<?asciidoc-br?>
There are many other methods and constants that support this device.&#160;&#160;&#160;Reviewing the library will assist in understanding how these private methods and constants support the overal solution for this library.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
<simpara>&#160;&#160;&#160;</simpara>
</section>
<section xml:id="_uc1601_controllers">
<title>UC1601 Controllers</title>
<simpara>This section covers GLCD devices that use the UC1601 graphics controller.</simpara>
<simpara>The UC1601 is an advanced high-voltage mixed signal CMOS IC, especially designed for the display needs of ultra-low power hand-held devices.</simpara>
<simpara>The UC1601 embeds with contrast control, display RAM and oscillator, which reduces the number of external components and power consumption.&#160;&#160; It has 256-step brightness control. Data/Commands are sent from general MCU through the hardware selectable 6800/8000 series compatible Parallel Interface, I2C interface or Serial Peripheral Interface. It is suitable for many compact portable applications, such as mobile phone sub-display, MP3 player and calculator, etc.</simpara>
<simpara>The UC1601 library supports 132 * 22 pixels.&#160;&#160;  The UC1601 library  supports monochrome devices.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/UC1601.gif" contentwidth="396" contentdepth="66"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</inlinemediaobject></simpara>
<simpara>The UC1601 can operate in three modes.&#160;&#160; Full GLCD mode, Low Memory GLCD mode or Text/JPG mode the full GLCD mode requires a minimum of 396 bytes or 128 bytes for the respective modes.&#160;&#160;For microcontrollers with limited memory the third mode of operation - Text mode.  These can be selected by setting the correct constant.</simpara>
<simpara>To use the UC1601 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<simpara>The GCBASIC constants shown below control the configuration of the UC1601 controller. &#160;&#160;&#160;GCBASIC supports hardware I2C &amp; software I2C connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the UC1601 drivers simply include one of the following configuration.</simpara>
<screen>    'An I2C configuration
    #include &lt;glcd.h&gt;

    #define GLCD_TYPE GLCD_TYPE_UC1601
    #define GLCD_I2C_Address      0x70                   'I2C address
    #define GLCD_RESET            portc.0                'Hard Reset pin connection
    #define GLCD_PROTECTOVERRUN
    #define GLCD_OLED_FONT

    ; ----- Define Hardware settings for I2C
    ' Define I2C settings - CHANGE PORTS
    #define I2C_MODE Master
    #define I2C_DATA PORTb.5
    #define I2C_CLOCK PORTb.7
    #define I2C_DISABLE_INTERRUPTS ON</screen>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_UC1601</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_I2C_Address</literal></simpara></entry>
<entry align="left" valign="top"><simpara>I2C address of the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Fixed at 0x70.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>132</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>22</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_PROTECTOVERRUN</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Define this constant to restrict pixel operations with the pixel limits</simpara></entry>
<entry align="left" valign="top"><simpara>Recommended</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_UC1601_CHARACTER_MODE_ONLY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in text mode and BMP
draw mode only.<?asciidoc-br?>
For microcontrollers with low RAM this will be set be
default.<?asciidoc-br?>
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <literal>GLCD_TYPE_UC1601_LOWMEMORY_GLCD_MODE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_UC1601_LOWMEMORY_GLCD_MODE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in Low Memory mode.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_OLED_FONT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the use of the optional OLED font set.
</simpara><simpara>The GLCDfntDefaultsize can be set to 1 or 2 only.
</simpara><simpara><literal>GLCDfntDefaultsize=  1</literal>.   A small 8 height pixel font with variable width.
<literal>GLCDfntDefaultsize=  2</literal>.   A larger 10 width * 16 height pixel font.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC variables for control display characteristics are shown in the table below.
These variables control the user definable parameters of a specific GLCD.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Variable</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Type</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDBackground</literal></simpara></entry>
<entry align="left" valign="top"><simpara>GLCD background state.</simpara></entry>
<entry align="left" valign="top"><simpara>A monochrome value.<?asciidoc-br?>
For mono GLCDs the default is White or 0x0001.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDForeground</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Color of GLCD foreground.</simpara></entry>
<entry align="left" valign="top"><simpara>A monochrome value.<?asciidoc-br?>
For mono GLCDs the default is non-white or 0x0000.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Width of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 6 pixels.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 0.
</simpara><simpara></simpara><simpara>This equates to the standard GCB font set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefaultsize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 1.
</simpara><simpara></simpara><simpara>This equates to the 8 pixel high.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this GLCD are shown in the
table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Open_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands when in low memory mode.  Must be followed a  <literal>GLCD_Close_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction 0, 3</literal> where 0 and 3 are the range of pages to be updated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands when in low memory mode.  Must follow a <literal>GLCD_Open_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Open_Transaction_UC1601</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Send command instruction to GLCD.  Handles I2C and SPI protocols.</simpara></entry>
<entry align="left" valign="top"><simpara>Transaction must be closed by using <literal>Close_Transaction_UC1601</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Open_Transaction_Data_UC1601</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Send data instruction to GLCD.  Handles I2C and SPI protocols.</simpara></entry>
<entry align="left" valign="top"><simpara>Transaction must be closed by using <literal>Close_Transaction_UC1601</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Write_Transaction_Data_UC1601</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Send transactional, a stream of, data to GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Transaction must be opened and closed by using transaction commands.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Close_Transaction_UC1601</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Close the communications to the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Transaction must be opened by using <literal>Open_Transaction_UC1601</literal> or <literal>Open_Transaction_Data_UC1601</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC specific commands for this GLCD are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Stopscroll_UC1601</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Stops all scrolling</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Startscroll_UC1601 ( start  )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Activates a vertical scroll for rows start.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDSetContrast ( contrast_state )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the constrast between 0 and 255. The contrast increases as the value increases.<?asciidoc-br?>
Parameter is contrast value</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a UC1601 datasheet, please refer <link xlink:href="http://gcbasic.sourceforge.net/library/DISPLAY/UC1601.pdf">here</link>.</simpara>
<simpara>This example shows how to drive a UC1601 based Graphic I2C LCD module with the built in commands of GCBASIC using Full Mode GLCD</simpara>
<screen>        ; ----- Configuration
        #chip 16f18446, 32
        #option explicit


    ; ----- Define GLCD Hardware settings
        #include &lt;glcd.h&gt;

        #define GLCD_TYPE GLCD_TYPE_UC1601
        #define GLCD_I2C_Address      0x70                   'I2C address
        #define GLCD_RESET            portc.0                'Hard Reset pin connection
        #define GLCD_PROTECTOVERRUN
        #define GLCD_OLED_FONT

    ; ----- Define Hardware settings

        ' Define I2C settings - CHANGE PORTS
        #define I2C_MODE Master
        #define I2C_DATA PORTb.5
        #define I2C_CLOCK PORTb.7
        #define I2C_DISABLE_INTERRUPTS ON

    ; ----- Define variables

    ; ----- Main program

        'You can treat the GLCD like an LCD....
        GLCDPrintStringLN "User the GLCD like an LCD...."
        GLCDPrintStringLN "The GLCDPrintString commands...."
        GLCDPrintString "Enjoy....."
        wait 4 s

    end</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
This example shows how to drive a UC1601 based Graphic I2C LCD module with the built in commands of GCBASIC using Low Memory Mode GLCD.
<?asciidoc-br?>
Note the use of <literal>GLCD_Open_PageTransaction</literal> and <literal>GLCD_Close_PageTransaction</literal> to support the Low Memory Mode of operation and the contraining of all GLCD commands with the transaction commands.  The use Low Memory Mode GLCD the two defines <literal>GLCD_TYPE_UC1601_LOWMEMORY_GLCD_MODE</literal> and <literal>GLCD_TYPE_UC1601_CHARACTER_MODE_ONLY</literal> are included in the user program.
<?asciidoc-br?></simpara>
<screen>    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_UC1601
    #define GLCD_TYPE_UC1601_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_UC1601_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS

    'To clarify - page udpates
    '0,7 correspond with the Text Lines from 0 to 3 on a 22 Pixel Display
    'In this example Code would be GLCD_Open_PageTransaction 0,1 been enough
    'But it is allowed to use GLCD_Open_PageTransaction 0,3 to show the full screen update
    GLCD_Open_PageTransaction 0,3
       GLCDPrint 0, 0, "GCBASIC"
       GLCDPrint (0, 16, "Anobium 2021")
    GLCD_Close_PageTransaction

    end</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
</section>
<section xml:id="_box">
<title>Box</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Box(LineX1,LineY1, LineX2, LineY2 [, LineColour ] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a box on a graphic LCD from the upper corner of pixel position X1, Y1 location to
pixel position X2,Y2 location.</simpara>
<simpara><literal>LineColour</literal> can be specified.  Typical the value is 0 or 1 for GLCDForeGround and GLCDBackGround respectively.</simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_filledbox">FilledBox</link></simpara>
</section>
<section xml:id="_circle">
<title>Circle</title>
<simpara><emphasis role="strong">Circle:</emphasis></simpara>
<screen>    Circle(XPixelPosition, YPixelPosition, Radius [ [,Optional LineColour] [,Optional Rounding] ] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a circle on a GLCD at <literal>XPixelPosition</literal>, <literal>YPixelPosition</literal> with a specific <literal>Radius</literal>.</simpara>
<simpara>The constant <literal>GLCD_PROTECTOVERRUN</literal> can be added to prevent circles from
re-drawing at the screen edges. Ensure the <literal>GLCD_Width</literal> and <literal>GLCD_HEIGHT</literal>
constants are set correctly when using this additional constant.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    circle(10,10,10)  ;upper left
    circle(117,10,10) ;upper right
    circle(63,31,10)  ;center
    circle(63,31,20)  ;center
    circle(10,53,10)  ;lower left
    circle(117,53,10) ;lower right</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/circleb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_ellipse">
<title>Ellipse</title>
<simpara><emphasis role="strong">Ellipse:</emphasis></simpara>
<screen>    Ellipse(XPixelPosition, YPixelPosition, XRadius, YRadius [,Optional LineColour] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a Ellipse on a GLCD at <literal>XPixelPosition</literal>, <literal>YPixelPosition</literal> with a specific vertex of <literal>XRadius</literal> and <literal>YRadius</literal>.</simpara>
<simpara>The constant <literal>GLCD_PROTECTOVERRUN</literal> can be added to prevent Ellipses from
re-drawing at the screen edges. Ensure the <literal>GLCD_Width</literal> and <literal>GLCD_HEIGHT</literal>
constants are set correctly when using this additional constant.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    Ellipse(63, 31, 20, 10)</screen>
</section>
<section xml:id="_filledbox">
<title>FilledBox</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    FilledBox(LineX1,LineY1, LineX2, LineY2, Optional LineColour = 1)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a filled box on a graphic LCD from the upper corner of pixel X1, Y1
location to pixel X2,Y2 location.<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_box">Box</link></simpara>
</section>
<section xml:id="_filledcircle">
<title>FilledCircle</title>
<simpara><emphasis role="strong">Circle:</emphasis></simpara>
<screen>    FilledCircle(XPixelPosition, YPixelPosition, Radius [,Optional LineColour] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a circle on a GLCD at <literal>XPixelPosition</literal>, <literal>YPixelPosition</literal> with a specific <literal>Radius</literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    filledcircle(10,10,10)  ;upper left
    filledcircle(117,10,10) ;upper right
    filledcircle(63,31,10)  ;center
    filledcircle(63,31,20)  ;center
    filledcircle(10,53,10)  ;lower left
    filledcircle(117,53,10) ;lower right</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/filledcircleb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_filledellipse">
<title>FilledEllipse</title>
<simpara><emphasis role="strong">FilledEllipse:</emphasis></simpara>
<screen>    FilledEllipse(XPixelPosition, YPixelPosition, XRadius, YRadius [,Optional LineColour] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a FilledEllipse on a GLCD at <literal>XPixelPosition</literal>, <literal>YPixelPosition</literal> with a specific vertex of <literal>XRadius</literal> and <literal>YRadius</literal>.</simpara>
<simpara>The constant <literal>GLCD_PROTECTOVERRUN</literal> can be added to prevent FilledEllipses from
re-drawing at the screen edges. Ensure the <literal>GLCD_Width</literal> and <literal>GLCD_HEIGHT</literal>
constants are set correctly when using this additional constant.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    FilledEllipse(63, 31, 20, 10)</screen>
</section>
<section xml:id="_filledtriangle">
<title>FilledTriangle</title>
<simpara><emphasis role="strong">FilledTriangle:</emphasis></simpara>
<screen>    FilledTriangle( XPixelPosition1, YPixelPosition1, XPixelPosition2, YPixelPosition2, XPixelPosition3, YPixelPosition3 [,Optional LineColour] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a FilledTriangle on a GLCD at <literal>XPixelPositionN</literal>, <literal>YPixelPositionN</literal>.</simpara>
<simpara>The constant <literal>GLCD_PROTECTOVERRUN</literal> can be added to prevent FilledTriangles from
re-drawing at the screen edges. Ensure the <literal>GLCD_Width</literal> and <literal>GLCD_HEIGHT</literal>
constants are set correctly when using this additional constant.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    FilledTriangle(0, 0, 31, 63, 127, 0 )</screen>
</section>
<section xml:id="_glcdcls">
<title>GLCDCLS</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDCLS [GLCDBackground]</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Clears the screen of a Graphic LCD.  This command is supported by all GLCD displays.</simpara>
<simpara>For colour GLCD displays only.  The optional parameter can be used to clear the screen to a specific colour.  Using this additional parameter will also change the GLCDBackground colour to this same colour.</simpara>
<simpara>Specific to the ST7920 GLCD devices. This command supports the clearing the GLCD to either text mode or graphics mode.</simpara>
</section>
<section xml:id="_glcddisplay">
<title>GLCDDisplay</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDDisplay Off | On</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Places the GLCD in sleep mode or enables the GLCD for normal operations.</simpara>
<simpara>The options are:</simpara>
<screen>    OFF
    ON</screen>
</section>
<section xml:id="_glcddrawchar">
<title>GLCDDrawChar</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDDrawChar(CharLocX, CharLocY, CharCode [, Optional Colour] )</screen>
<simpara><literal>CharLocX</literal> is the <literal>X</literal> coordinate location for the character<?asciidoc-br?>
<literal>CharLocY</literal> is the <literal>Y</literal> coordinate location for the character<?asciidoc-br?>
<literal>CharCode</literal> is the ASCII number of the character to display. Can be decimal
hex or binary.</simpara>
<simpara>Colour can be <literal>ON</literal> or <literal>OFF</literal>. For the ST7735 devices this an be any word
value that represents the color palette.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Displays an ASCII character at a specified X and Y location.
On a 128x64 Graphic LCD:</simpara>
<simpara>X = 1 to 128<?asciidoc-br?>
Y = 1 to 64<?asciidoc-br?></simpara>
</section>
<section xml:id="_glcddrawstring">
<title>GLCDDrawString</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDDrawString(CharLocX, CharLocY, String [, Optional Colour] )</screen>
<simpara><literal>CharLocX</literal> is the X corrdinate location for the character<?asciidoc-br?>
<literal>CharLocY</literal> is the Y coordinate location for the character<?asciidoc-br?>
<literal>String</literal> is the string of characters to display<?asciidoc-br?>
<literal>Colour</literal> can be ON or OFF. For the ST7735 devices this an be any word
value that represents the color palette</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Displays an ASCII character at a specified X and Y location.<?asciidoc-br?>
On a 128x64 Graphic LCD :<?asciidoc-br?>
X = 1 to 128<?asciidoc-br?>
Y = 1 to 64<?asciidoc-br?></simpara>
</section>
<section xml:id="_glcdprint">
<title>GLCDPrint</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDPrint(PrintLocX, PrintLocY, PrintData_Byte [, Optional Colour] )    ',or
    GLCDPrint(PrintLocX, PrintLocY, PrintData_Word [, Optional Colour] )    ',or
    GLCDPrint(PrintLocX, PrintLocY, PrintData_Long [, Optional Colour] )    ',or

    GLCDPrint(PrintLocX, PrintLocY, PrintData_String [, Optional Colour] )</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<literal>PrintLocX</literal> is the X corrdinate location for the data<?asciidoc-br?>
<literal>PrintLocY</literal> is the Y coordinate location for the data<?asciidoc-br?>
<literal>PrintData_[type]</literal> is a variable or constant to be displayed
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
Prints data values (byte, word, long or string) at a specified location on the GLCD screen.
<?asciidoc-br?>
<?asciidoc-br?>
To display an integer use:
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    GLCDPrint(PrintLocX, PrintLocY, strinteger(integer_value) )</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_glcdprintlargefont">
<title>GLCDPrintLargeFont</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDPrintLargeFont( PrintLocX, PrintLocY, PrintData_String [, Optional Colour] )</screen>
<simpara>GLCD supports for a larger fixed font of 13 pixels.&#160;&#160;  GLCDPrintLargeFont supports strings only.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<literal>PrintLocX</literal> is the X corrdinate location for the data<?asciidoc-br?>
<literal>PrintLocY</literal> is the Y coordinate location for the data<?asciidoc-br?>
<literal>PrintData_[type]</literal> is a variable or constant to be displayed
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
Prints data values (byte, word, long or string) at a specified location on the GLCD screen.
<?asciidoc-br?>
<?asciidoc-br?>
To display an integer use:
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    GLCDPrintLargeFont( 0, 0, "13 Pixels Fixed Font" )</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_glcdprintwithsize">
<title>GLCDPrintWithSize</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_Byte , FontSize [, Color ] )    ',or
    GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_Word , FontSize [, Color ] )    ',or
    GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_Long , FontSize [, Color ] )    ',or

    GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_String , FontSize [, Color ] )</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<literal>PrintLocX</literal> is the X corrdinate location for the data<?asciidoc-br?>
<literal>PrintLocY</literal> is the Y coordinate location for the data<?asciidoc-br?>
<literal>PrintData_[type]</literal> is a variable or constant to be displayed<?asciidoc-br?>
<literal>FontSize</literal> is the GLCD fontsize.&#160;&#160; Typical values are 1, 2 or 3<?asciidoc-br?>
<literal>Color</literal> is an optional parameter to change the color the GLCD printed text.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
Prints data values (byte, word, long or string) at a specified location on the GLCD screen with a specific font size.
<?asciidoc-br?>
<?asciidoc-br?>
To display a string using font size two use:
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    GLCDPrintWithSize(PrintLocX, PrintLocY, "Using font size #2", 2 )</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_glcdlocatestring">
<title>GLCDLocateString</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDLocateString(PrintLocX, PrintLocY )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Moves the GLCD string pointer to the specified location on the GLCD screen.</simpara>
<simpara><literal>PrintLocX</literal> is the X corrdinate location for the data<?asciidoc-br?>
<literal>PrintLocY</literal> is the Y coordinate location for the data<?asciidoc-br?></simpara>
<simpara>For the purpose of this command. The screen addressing is the first line equates to the parameter 1, the second line equates to the paramter 2 etc.</simpara>
<simpara>An example:</simpara>
<screen>    GLCDLocateString( 0, 1 )    'The first line of the display
    GLCDLocateString( 0, 6 )    'The sixth line of the display</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    GLCDPrintStringLn ( "1.First Ln" )
    GLCDPrintStringLn ( "2.Second Ln" )
    GLCDPrintStringLn ( "" )
    GLCDPrintStringLn ( "4.Forth Ln" )
    GLCDLocateString( 0, 5 )
    GLCDPrintString ( "5." )
    GLCDPrintStringLn ( "Fifth Ln" )

    GLCDPrintStringLn ( "6.Sixth Ln" )
    GLCDLocateString( 0, 3 )
    dim val3 as Byte
    val3 = 3
    GLCDPrintStringLn ( str( val3 ) + ".Third Ln" )</screen>
</section>
<section xml:id="_glcdprintstring">
<title>GLCDPrintString</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDPrintString( String )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Prints string character(s) at a current XY location on the GLCD screen.</simpara>
<simpara>Where <literal>String</literal> is a String or String variable of the data to display</simpara>
<simpara>This command will <emphasis role="strong">NOT</emphasis> move the to start of the next line after the string has been displayed</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    GLCDPrintStringLn ( "1.First Ln" )
    GLCDPrintStringLn ( "2.Second Ln" )
    GLCDPrintStringLn ( "" )
    GLCDPrintStringLn ( "4.Forth Ln" )
    GLCDLocateString( 0, 5 )
    GLCDPrintString ( "5." )
    GLCDPrintStringLn ( "Fifth Ln" )

    GLCDPrintStringLn ( "6.Sixth Ln" )
    GLCDLocateString( 0, 3 )
    dim val3 as Byte
    val3 = 3
    GLCDPrintStringLn ( str( val3 ) + ".Third Ln" )</screen>
</section>
<section xml:id="_glcdprintstringln">
<title>GLCDPrintStringLn</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDPrintStringLn( String )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Prints string character(s) at a current XY location on the GLCD screen.</simpara>
<simpara>Where <literal>String</literal> is a String or String variable of the data to display</simpara>
<simpara>This command will move to the start of the next line after the string has been displayed</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    GLCDPrintStringLn ( "1.First Ln" )
    GLCDPrintStringLn ( "2.Second Ln" )
    GLCDPrintStringLn ( "" )
    GLCDPrintStringLn ( "4.Forth Ln" )
    GLCDLocateString( 0, 5 )
    GLCDPrintString ( "5." )
    GLCDPrintStringLn ( "Fifth Ln" )

    GLCDPrintStringLn ( "6.Sixth Ln" )
    GLCDLocateString( 0, 3 )
    dim val3 as Byte
    val3 = 3
    GLCDPrintStringLn ( str( val3 ) + ".Third Ln" )</screen>
</section>
<section xml:id="_glcdrotate">
<title>GLCDRotate</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDROTATE LANDSCOPE | PORTRAIT_REV | LANDSCAPE_REV  | PORTRAIT</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Rotate the GLCD display to a relative position.</simpara>
<simpara>GLCD rotation needs to be supported by the GLCD chipset. <emphasis role="strong">NOT</emphasis> all GLCD chipset support these commands.</simpara>
<simpara>The options are:</simpara>
<screen>    LANDSCAPE
    PORTRAIT_REV
    LANDSCAPE_REV
    PORTRAIT</screen>
<simpara>The command will rotate the screen and set the following variables using the global variables shown below.</simpara>
<screen>    GLCD_WIDTH
    GLCD_HEIGHT</screen>
<simpara>The command is supported by the following global constants.</simpara>
<screen>    #define LANDSCAPE       1
    #define PORTRAIT_REV    2
    #define LANDSCAPE_REV   3
    #define PORTRAIT        4</screen>
</section>
<section xml:id="_glcdreadbyte">
<title>GLCDReadByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    byte_variable = GLCDReadByte</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Reads a byte of data from the Graphic LCD memory</simpara>
</section>
<section xml:id="_glcdtimedelay">
<title>GLCDTimeDelay</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDTime</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This will call the delay routine that delays data transmissions. By
default this is set to <literal>20</literal>, which equate to <literal>20 us</literal>. <literal>GLCDTimeDelay</literal> default
of <literal>20us</literal> is for 32Mhz support. The can be reduced for slower chip speeds
by change the constant <literal>ST7920WriteDelay</literal>.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    GLCDTime                       'call the delay routine
    #define ST7920WriteDelay 1     'set the delay to 1 us</screen>
</section>
<section xml:id="_glcdtransaction">
<title>GLCDTransaction</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCD_Open_PageTransaction
      ....
        additional number of other GLCD methods
      ....
    GLCD_Close_PageTransaction</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>To make the operation of GLCD seamless - specific library supports GLCDTransaction.&#160;&#160;
GLCDTransaction automatically manages the methods to update the GLCD display via a RAM memory buffer, where this buffer can be small relative to the size of the total number of GLCD pixels.</simpara>
<simpara>The process of GLCDtransaction sends GLCD commands to the GLCD display on a page and page basis.&#160;&#160;
Each page is the size of the buffer and for a large GLCD display the number of pages may be equivilent to the numbers of pixels high (height).</simpara>
<simpara>GLCDTransaction simplies the operation by ensure the buffer is setup correctly, handles the GLCD appropiately, handles the sending of the buffer and then close out the update to the display.</simpara>
<simpara>To use GLCDTransaction use the followng methods.</simpara>
<screen>    GLCD_Open_PageTransaction
      ....
      additional number of other GLCD methods
      ....
    GLCD_Close_PageTransaction</screen>
<simpara>It recommended to use GLCDTransactions at all times when using the e-Paper libraries.&#160;&#160;
Other GLCD libraries support GLCDTransaction to reduce the memory requirement.&#160;&#160;</simpara>
<simpara>Thes GLCDTransactions methods remove the complexity of the GLCD display update process when RAM within the microcontroller is limited.</simpara>
<simpara>When using GLCDTransaction you must commence with GLCD_Open_PageTransaction then a series of GLCD commands and then terminate with GLCD_Close_PageTransaction.</simpara>
<simpara><emphasis role="strong">GLCDTransaction Insight</emphasis>: When using GLCDtransactions the number of buffer pages is probably be greater then 1 (unless using the SRAM option), so the process of incrementing variables and calls to non-GLCD methods must be considered carefully.    The transaction process will increment variables and call non-GLCD methods the same number of times as the number of pages.  Therefore, design GLCDTransaction operations with this is mind.</simpara>
<simpara><emphasis role="strong">SRAM as the display buffer</emphasis></simpara>
<simpara>To improve memory usage the e-paper the e-Paper libraries support the use of SRAM.   SRAM can be used as an alternative to the microcontrollers RAM.   Using SRAM does have a small performance impact but does free up the critical resource of the microcontroller RAM.   The use of SRAM within the e-paper library is transparent to the user.   To use SRAM as the e-paper buffer you will need to set-up the SRAM library.   See the SRAM library for more details on SRAM usage.</simpara>
<simpara>When using SRAM for the e-paper buffer it is still remcommend to use GLCDTransaction as this ensure the SRAM buffer is correctly initialised.</simpara>
<simpara><emphasis role="strong">Optional GLCD_Open_Transaction parameters</emphasis></simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCD_Open_PageTransaction ( low_page, high_page )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>You can optionally pass <literal>GLCD_Open_PageTransaction</literal> two parmeters.  The parameters will constrain the GLCD display update process to the specific pages.</simpara>
<simpara>This can be used when only updating a potion of the screen to improve performance.</simpara>
</section>
<section xml:id="_glcdwritebyte">
<title>GLCDWriteByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDWriteByte (LCDByte)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Writes a byte of data to the Graphic LCD memory</simpara>
</section>
<section xml:id="_line">
<title>Line</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Line(LineX1,LineY1, LineX2, LineY2, Optional LineColour = 1)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a line on a GLCD from pixel X1, Y1 location to pixel X2,Y2 location.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    line 0,0,127,63
    line 0,63,127,0
    line 40,0,87,63
    line 40,63,87,0</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/lineb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_hyperbole">
<title>Hyperbole</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Hyperbole (x,  y,  a_axis,  b_axis,  type, ModeStop, optional LineColour=GLCDForeground)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws on a GLCD an hyperbole with equation (x/(a)<superscript>2-(y/(b)</superscript>2=1, centered at  pixel positions (x, y)  with axis a and b.</simpara>
<simpara>The hyperbole can be aligned either along the x axis or along the y axis.</simpara>
<simpara>Both cases a_axis&gt;=b:axis and a_axis&lt;b_axis are accepted.</simpara>
<simpara>The hyperbole is an unbounded curve made by four branches</simpara>
<simpara>Drawing hyperbole on the screen can be stopped by following two different criteria:
  -  a branch has reached a border of the display
  -  all branches have reached the display border</simpara>
<simpara>For an hyperbole centered on the display these criteria are equivalent.</simpara>
<simpara><emphasis role="strong">Input parameters:</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Parameter</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>x</literal></simpara></entry>
<entry align="left" valign="top"><simpara>X coordinates  of hyperbole center (in pixel positions)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>y</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Y coordinates  of hyperbole center (in pixel positions)
</simpara><simpara></simpara><simpara>The x or y coordinates are Word value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>a_axis</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The a axis of the hyperbole</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>b_axis</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The b axis of the hyperbole</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>type</literal></simpara></entry>
<entry align="left" valign="top"><simpara>type=1 the hyperbole is aligned along x axis
<?asciidoc-br?>
type=2 the hyperbole is aligned along y axis</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>modestop</literal></simpara></entry>
<entry align="left" valign="top"><simpara>modestop=1 drawing stops when a display border is encountered by a hyperbole branch.
<?asciidoc-br?>
modestop=2 drawing stops when all the reachable display borders are encountered by all the hyperbole branches</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LineColour</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Color of the hyperbole</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Example for a 240x320 pixels GLCD

    #include &lt;glcd.h&gt;

    Hyperbole(120, 160, 40,20, 1, 2, GLCDForeground)   ; centered, a=40, b=20, x_axis alined, stops when all branches have reached a a border
    Hyperbole(120, 160, 40,20, 1, 1, GLCDForeground)   ; centered, a=40, b=20, x_axis alined, stops when a border is reached
    Hyperbole(120, 160, 40,20, 2, 1, GLCDForeground)   ; centered, a=40, b=20, y_axis alined, stops when a border is reached,

    Hyperbole(180, 80, 40,20, 1, 1, GLCDForeground)   ; upper right, a=40, b=20, x_axis alined, stops when a border is reached,
    Hyperbole(60, 240, 40,20, 1, 2, GLCDForeground)   ; lower left, a=40, b=20, x_axis alined, stops when all branches have reached a border

    Hyperbole(180, 80, 40,20, 2, 1, GLCDForeground)   ; upper right, a=40, b=20, y_axis alined, stops when a border is reached,
    Hyperbole(60, 240, 40,20, 2, 2, GLCDForeground)   ; lower left, a=40, b=20, y_axis alined, stops when all branches have reached a border</screen>
</section>
<section xml:id="_parabola">
<title>Parabola</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Parabola (x,  y,  p_factor,  type, modestop, optional LineColour=GLCDForeground)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws on a GLCD a parabola with equation y^2=2*p_factor*x, centered at  pixel positions (x, y) .</simpara>
<simpara>The parabola is an unbounded curve.</simpara>
<simpara>The parabola can be alined either along the x axis or along the y axis.</simpara>
<simpara>Drawing parabola on the screen can be constrained by following two different criteria:
  - a branch has reached a border of the display.
  - both branches have reached the display border.</simpara>
<simpara>For a parabola centered on the display these criteria are equivalent.</simpara>
<simpara><emphasis role="strong">Input parameters:</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Parameter</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>x, y</literal></simpara></entry>
<entry align="left" valign="top"><simpara>X, Y coordinates of the parabola vertex.  X is the minimum x value of the parabola when alined along X.
             Y is the minimum y value of the parabola when alined along y &#160;&#160;in pixel positions
</simpara><simpara></simpara><simpara></simpara><simpara>The x or y coordinates are Word value, p_factor is word value, type and ModeStop are byte values .</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>p_factor</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The factor such that y^2=2*p_factor*x is the equation of the parabola</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>type</literal></simpara></entry>
<entry align="left" valign="top"><simpara>type=1 the parabola is aligned along x axis
<?asciidoc-br?>
type=2 the parabola is aligned along y axis</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>modestop</literal></simpara></entry>
<entry align="left" valign="top"><simpara>modestop=1 drawing stops when a display border is encountered by a parabola branch.
<?asciidoc-br?>
modestop=2 drawing stops when all the parabolla branches encountered a border</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LineColour</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Color of the parabola</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Example for a 240x320 pixels GLCD

    #include &lt;glcd.h&gt;

    Parabola(120, 160, 20, 1, 2, GLCDForeground)   ;  centered, p_factor=20, x_axis alined, stops when all branches have reached a a border
    Parabola(120, 160 ,20, 1, 1, GLCDForeground)   ; centered, p_factor=20, x_axis alined, stops when a border is reached
    Parabola(120, 160, 20, 2, 1, GLCDForeground)   ; centered, p_factor=20, y_axis alined, stops when a border is reached,

    Parabola(180, 80, 20, 1, 1, GLCDForeground)   ; upper right, p_factor=20, x_axis alined, stops when a border is touched,
    Parabola(60, 240, 20, 1, 2, GLCDForeground)   ; lower left, p_factor=20, x_axis alined, stops when all branches have reached a border

    Parabola(180, 80, 20, 2, 1, GLCDForeground)   ; upper right, p_factor=20, y_axis alined, stops when a border is touched,
    Parabola(60, 240, 20, 2, 2, GLCDForeground)   ; lower left, p_factor=20, y_axis alined, stops when all branches have reached a border</screen>
</section>
<section xml:id="_pset">
<title>Pset</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PSet(XPosition, YPosition, GLCDState)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Sets or Clears a Pixel at the specified XPosition, YPosition.  Use
GLCDState set to 1 to set the pixel and a 0 clears the pixel.</simpara>
</section>
<section xml:id="_triangle">
<title>Triangle</title>
<simpara><emphasis role="strong">Triangle:</emphasis></simpara>
<screen>    Triangle(XPixelPosition1, YPixelPosition1, XPixelPosition2, YPixelPosition2, XPixelPosition3, YPixelPosition3 [,Optional LineColour] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a Triangle on a GLCD at <literal>XPixelPositionN</literal>, <literal>YPixelPositionN</literal>.</simpara>
<simpara>The constant <literal>GLCD_PROTECTOVERRUN</literal> can be added to prevent Triangles from
re-drawing at the screen edges. Ensure the <literal>GLCD_Width</literal> and <literal>GLCD_HEIGHT</literal>
constants are set correctly when using this additional constant.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    Triangle(0, 0, 31, 63, 127, 0 )</screen>
</section>
</section>
<section xml:id="_touch_screen">
<title>Touch Screen</title>
<simpara>This is the Touch Screen section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_ads_7843_serial_driver">
<title>ADS 7843 Serial Driver</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ADS7843_Init

    ADS7843_GetXY

    ADS7843_SetPrecision</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers. Requires the inclusion of the following:</simpara>
<screen>    #include &lt;ADS7843.h&gt;</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The ADS7843 device is a 12-bit sampling Analog-to-Digital Converter (ADC) with a synchronous serial interface and low on resistance switches for driving touch screens.</simpara>
<simpara>The GCBASIC driver is integrated with the SDD1289 GLCD driver.  To use the ADS7843 driver the following is required to added to the GCBASIC source file.</simpara>
<simpara><literal>ADS7843_Init</literal> is required to initialise the touch screen. This is mandated.</simpara>
<simpara><literal>ADS7843_GetXY</literal> this sub-routine returns the X and Y coordinates of touched point.</simpara>
<simpara><literal>ADS7843_SetPrecision</literal> this sub-routine sets the level of precision of the touch screen.</simpara>
<simpara><emphasis role="strong">Required Constants:</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls/Direction</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ADS7843_DOUT (IN)</simpara></entry>
<entry align="left" valign="top"><simpara>The chip output pin</simpara></entry>
<entry align="left" valign="top"><simpara>Mandated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843_IRQ (IN)</simpara></entry>
<entry align="left" valign="top"><simpara>The interrupt pin</simpara></entry>
<entry align="left" valign="top"><simpara>Mandated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843_CS (OUT)</simpara></entry>
<entry align="left" valign="top"><simpara>The chip select pin</simpara></entry>
<entry align="left" valign="top"><simpara>Mandated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843_CLK (OUT)</simpara></entry>
<entry align="left" valign="top"><simpara>The clock pin</simpara></entry>
<entry align="left" valign="top"><simpara>Mandated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843_DIN (OUT)</simpara></entry>
<entry align="left" valign="top"><simpara>The chip input pin</simpara></entry>
<entry align="left" valign="top"><simpara>Mandated</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC commands supported for this chip are:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ADS7843_Init</simpara></entry>
<entry align="left" valign="top"><simpara>Initialise the device.</simpara></entry>
<entry align="left" valign="top"><simpara>ADS7843_Init [Optional precision = PREC_EXTREME]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843_GetXY</simpara></entry>
<entry align="left" valign="top"><simpara>Returns the X and Y coordinates of touched point.</simpara></entry>
<entry align="left" valign="top"><simpara>ADS7843_GetXY (TP_X, TP_Y )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843_SetPrecision</simpara></entry>
<entry align="left" valign="top"><simpara>Set the precision of the conversion result.</simpara></entry>
<entry align="left" valign="top"><simpara>ADS7843_SetPrecision(precision)<?asciidoc-br?>
(with PREC_EXTREME the conversion error is less than 3%)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Precision can be set to four values as shown in the table below.
Passing a parameter of ADS7843_SetPrecision changes the precision controls.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Defined  Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>#define PREC_LOW</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>#define PREC_MEDIUM</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>#define PREC_HI</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>#define  PREC_EXTREME</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Default Value</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>For more information see <link xlink:href="http://www.ti.com/product/ads7843">http://www.ti.com/product/ads7843</link>.</simpara>
<simpara>This example shows how to drive a SDD1289 based Graphic LCD module with ADS7843 touch controller.</simpara>
<screen>    'Chip Settings
    #chip mega2560, 16

    'Include for GLCD
    #include &lt;glcd.h&gt;

    'Include for ADS7843
    #include  &lt;ADS7843.h&gt;

    'GLCD Device Selection
    #DEFINE GLCD_TYPE GLCD_TYPE_SSD1289
    'Define ports for the SSD1289 display - ALL are required
    #DEFINE GLCD_WR   PORTG.2
    #DEFINE GLCD_CS   PORTG.1
    #DEFINE GLCD_RS   PORTD.7
    #DEFINE GLCD_RST  PORTG.0

    #DEFINE GLCD_DB0  PORTC.0
    #DEFINE GLCD_DB1  PORTC.1
    #DEFINE GLCD_DB2  PORTC.2
    #DEFINE GLCD_DB3  PORTC.3
    #DEFINE GLCD_DB4  PORTC.4
    #DEFINE GLCD_DB5  PORTC.5
    #DEFINE GLCD_DB6  PORTC.6
    #DEFINE GLCD_DB7  PORTC.7
    #DEFINE GLCD_DB8  PORTA.0
    #DEFINE GLCD_DB9  PORTA.1
    #DEFINE GLCD_DB10 PORTA.2
    #DEFINE GLCD_DB11 PORTA.3
    #DEFINE GLCD_DB12 PORTA.4
    #DEFINE GLCD_DB13 PORTA.5
    #DEFINE GLCD_DB14 PORTA.6
    #DEFINE GLCD_DB15 PORTA.7

    'GLCD font control
    #DEFINE GLCD_EXTENDEDFONTSET1

    'Define ports for ADS7843
    #define ADS7843_DOUT   PORTE.5  ' Arduino Mega D3
    #define ADS7843_IRQ    PORTE.4  ' Arduino Mega D2
    #define ADS7843_CS     PORTE.3  ' Arduino Mega D5
    #define ADS7843_CLK    PORTH.3  ' Arduino Mega D6
    #define ADS7843_DIN    PORTG.5  ' Arduino Mega D4
    #define ADS7843_BUSY   PORTH.4  ' Arduino Mega D7

    Wait 100 ms
    num=0
    Do Forever

      'Library function
      if ADS7843_IRQ=0 then

         num++
         GLCDPrint  10, 15,  str(num),SSD1289_YELLOW, 2

         'Libary sub routine - returns two variables
         ADS7843_GetXY ( TP_X , TP_Y )

         if TP_X&gt;=100 then GLCDPrint  100, 50, Str(TP_X),SSD1289_YELLOW, 2
         if TP_X&gt;=10 and TP_X&lt;100 then GLCDPrint  100, 50, Str(TP_X)+" ",SSD1289_YELLOW, 2
         if TP_X&lt;10 then GLCDPrint  100, 50,  Str(TP_X)+" ",SSD1289_YELLOW, 2
         if TP_Y&gt;=100 then GLCDPrint  100, 70, Str(TP_Y),SSD1289_YELLOW, 2
         if TP_Y&gt;=10 and TP_Y&lt;100 then GLCDPrint  100, 70, Str(TP_Y)+" ", SSD1289_YELLOW, 2
         if TP_Y&lt;10 then GLCDPrint  100, 70,  Str(TP_Y)+" ",SSD1289_YELLOW, 2

         'Set the pixel to yellow using the GLCD PSET sub routine
         Pset TP_X,  TP_Y, SSD1289_YELLOW

      end if
      Wait 1 ms

    Loop</screen>
</section>
</section>
<section xml:id="_liquid_crystal_display">
<title>Liquid Crystal Display</title>
<simpara>This is the LCD section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_lcd_overview">
<title>LCD Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>The LCD routines in this section allow GCBASIC programs to control an
alphanumeric Liquid Crystal Displays based on the <emphasis role="strong">HD44780</emphasis> IC. This
covers most 16 x 1, 16 x 2, 20 x 4 and 40 x 4 LCD displays.</simpara>
<simpara>The GCBASIC methods allow the displays to be connected to the microcontroller</simpara>
<simpara><emphasis role="strong">Connection Modes:</emphasis></simpara>
<simpara>The table below shows the connection modes.  These modes support the connection to the LCD using differing methods.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top">Connection Mode</entry>
<entry align="left" valign="top">Required Connections</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>No configuration is required directly by this method. The LCD routines
<emphasis role="strong">must</emphasis> be provided with other subroutines which will handle the
communication. This is useful for communicating with LCDs connected
through RS232 or I2C.
<?asciidoc-br?>
This is an advanced method of driving an LCD.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Uses a combined data and clock line. This mode is used when the LCD is connected through a
shift register 74HC595, as detailed at <link xlink:href="http://gcbasic.sourceforge.net/library/DIAGRAMS/1-Wire%20LCD/"><emphasis role="strong">here</emphasis></link>.
<?asciidoc-br?>
This method of driving an LCD requires an additional integrated circuit and other passive components.
This is not recommended for the beginner.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>Uses separated Data and Clock lines. This mode is used when the LCD is connected
through a 74LS174 shift register IC, as detailed at
<link xlink:href="http://gcbasic.sourceforge.net/library/DIAGRAMS/2-Wire%20LCD/"><emphasis role="strong">here</emphasis></link>
<?asciidoc-br?>
This method of driving an LCD requires additional integrated circuits
and other passive components. This is not recommended for the beginner.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara><literal>DB</literal>, <literal>CB</literal>, <literal>EB</literal> are connected to the microcontroller as the Data, Clock and Enable Bits.
<?asciidoc-br?>
This a common method to connect a microcontroller to an LCD. This
requires 3 data ports on the microcontroller.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>R/W</literal>, <literal>RS</literal>, <literal>Enable</literal> and the highest 4 data lines (<literal>DB4</literal> through <literal>DB7</literal>) are
connected to the microcontroller. The use of the R/W line is optional.
<?asciidoc-br?>
This a common method to connect a microcontroller to an LCD. This
requires 7(6) data ports on the microcontroller.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>R/W</literal>, <literal>RS</literal>, <literal>Enable</literal> and all 8 data lines. The data lines must all be
connected to the same I/O port, in sequential order. For example, <literal>DB0</literal> to
<literal>PORTB.0</literal>, <literal>DB1</literal> to <literal>PORTB.1</literal> and so on, with`DB7` going to <literal>PORTB.7</literal>.
<?asciidoc-br?>
This is a common method to connect a microcontroller to a LCD. This
requires 11(10) data ports on the microcontroller.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>The LCD is controlled via I2C. A type 10 LCD 12C adapter. Set <literal>LCD_IO</literal> to
<literal>10</literal> for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter
<?asciidoc-br?>
This is a common method and requires two data ports on the microcontroller.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>The LCD is controlled via I2C. A type 12 LCD 12C adapter. Set <literal>LCD_IO</literal> to
`12`for the Ywmjkdz I2C adapter with a potentiometer (variable resistance) bent over top of chip.
<?asciidoc-br?>
This is a common method and requires two data ports on the microcontroller.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>107</simpara></entry>
<entry align="left" valign="top"><simpara>The LCD is controlled via serial. Set <literal>LCD_IO</literal> to
<literal>107</literal> or <literal>K107</literal>.
<?asciidoc-br?>
The K107 requires one serial data ports on the microcontroller.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<note>
<title>Supported LCDs mapped to Connection Mode</title>
<simpara>The support of various types of LCD displays are shown in the following table.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Supported LCD Type<?asciidoc-br?>
number of characters x number of lines</entry>
<entry align="left" valign="top">Connection Mode</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>16 x 1, 16 x 2, 20 x 2, 20 x 4 type LCD displays,<?asciidoc-br?>
also known as 1601, 1602, 2002, 2004 type LCD displays.</simpara></entry>
<entry align="left" valign="top"><simpara>0,1,2,4,8,10 and 12</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>40 x 4 LCD displays,<?asciidoc-br?>
also known as 4004 type LCD displays.</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>16 x 1 LCD displays, with a non-standard/non-consective memory map.<?asciidoc-br?>
</simpara><simpara>This LCD sub type is supported using a specific constant.
</simpara><simpara>Use <literal><emphasis role="strong">#define LCD_VARIANT 1601a</emphasis></literal> to use this sub variant.
</simpara><simpara>Also known as 1601 type LCD displays.</simpara></entry>
<entry align="left" valign="top"><simpara>Supports any LCD_IO mode.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</note>
<note>
<title>Communication Performance</title>
<simpara>There may be a need to change the communication performance for a specific LCD as some LCD&#8217;s are slower to operate.  GCBASIC supports change the communications speed.</simpara>
<simpara>To change the performance (communications speed) of the LCD use <literal>#DEFINE LCD_SPEED</literal>.  This method allows the timing to be optimised.</simpara>
<simpara><emphasis>Example</emphasis></simpara>
<screen> #DEFINE LCD_SPEED  FAST</screen>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Define</entry>
<entry align="left" valign="top">Performance Characteristics</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_SPEED</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FAST</literal>     - The speed is approximately 20,000 CPS.<?asciidoc-br?>
<literal>MEDIUM</literal>   - The speed is approximately 15,000 CPS.<?asciidoc-br?>
<literal>SLOW</literal>     - The speed is approximately 10,000 CPS.<?asciidoc-br?>
<literal>OPTIMAL</literal>  - The speed is approximately 30,000 CPS.<?asciidoc-br?></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>If <literal>LCD_SPEED</literal> is not defined, the speed defaults to <literal>SLOW</literal>
<?asciidoc-br?>
<?asciidoc-br?>
&#160;&#160;
&#160;&#160;</simpara>
</note>
<formalpara>
<title>Using LCD_Speed OPTIMAL<?asciidoc-br?></title>
<para>&#160;&#160;</para>
</formalpara>
<note>
<simpara>&#160;&#160;
<literal>OPTIMAL</literal> disables fixed delays and allows the LCD operate as fast as it can.&#160;&#160;In this mode, The the busy flag is polled before each byte is sent to the HD44780 controller. &#160;&#160;This not only optimizes speed, but also assures that data is not sent to the diplay controler until it is ready to receive the data.</simpara>
<simpara>With most displays this equates to a speed of about 30,000 characters per second.&#160;&#160;For comparision about 10 times faster than I2C using a PC8574 Expander (See LCD_IO 10 or  See LCD_IO 112)</simpara>
<simpara><literal>OPTIMAL</literal> is only supported in LCD_IO 4,8 and only when LCD_NO_RW is not defined  (RW Mode).&#160;&#160;When <literal>#DEFINE LCD_NO_RW</literal> is defined, reading data from the HD44780 is not possible since this disables Read Mode on the controller.&#160;&#160;In this case busy flag checking is not available and the GET subroutine is not avaiable.</simpara>
<simpara>In order to enable busy flag checking, and, therefore to use the <literal>GET</literal> command the following criteria must be true.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>LCD I/O Mode must be either 4-wire or 8-wire</simpara>
</listitem>
<listitem>
<simpara><literal>#DEFINE LCD_NO_RW</literal> is not defined</simpara>
</listitem>
<listitem>
<simpara>An I\O pin is connected between the microcontroller and the RW connection on the LCD Display</simpara>
</listitem>
<listitem>
<simpara><literal>'DEFINE LCD_RW  port.pin</literal> is defined in the GCBASIC source code</simpara>
</listitem>
</orderedlist>
<simpara>Example:</simpara>
<screen>  #DEFINE LCD_IO 4
  #DEFINE LCD_SPEED OPTIMAL

  #DEFINE LCD_DB7 PORTB.5
  #DEFINE LCD_DB6 PORTB.4
  #DEFINE LCD_DB5 PORTB.3
  #DEFINE LCD_DB4 PORTB.2

  #DEFINE LCD_RW PORTA.3    'Must be defined for RW Mode
  #DEFINE LCD_RS PORTA.2
  #DEFINE LCD_ENABLE PORTA.1</screen>
</note>
<note>
<title>Changing the LCD Width</title>
<simpara>To change the LCD width characteristics use <literal>#define LCD_WIDTH</literal></simpara>
</note>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>See the separate sections of the Help file for the specifics of each Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>, <link linkend="_lcd_io_3">LCD_IO 3</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO_2 74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO_2 74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
<simpara><emphasis role="strong">and,</emphasis></simpara>
<simpara><link linkend="_lcd_width">LCD_Width</link>, <link linkend="_lcd_speed">LCD_Speed</link></simpara>
<section xml:id="_lcd_io_0">
<title>LCD_IO 0</title>
<simpara><emphasis role="strong">Using connection mode 0:</emphasis></simpara>
<simpara>To use connection mode 0, a subroutine to write a byte to the LCD <emphasis role="strong">must</emphasis> be provided.</simpara>
<simpara>Optionally, another subroutine to read a byte from the LCD can also be
defined.  If the LCD was to be read, the function <literal>LCDReadByte</literal> would be set to the name of a function that reads the LCD and returns the data byte from the LCD.
If there is no way (or no requirement) to read from the LCD, then the <literal>LCD_NO_RW</literal> constant must be set.</simpara>
<simpara>In connection mode 0, the <literal>LCD_RS</literal> constant will be set automatically to an unused bit variable.
The higher level LCD commands (such as <literal>Print</literal> and <literal>Locate</literal>) will set it, and the subroutine is responsible for writing to the LCD.
The subroutine should handle the process and then set the RS pin on the LCD appropriately.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>Specific constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC.  To set these constants the main program should specific constants to support the connection mode using #define.</simpara>
<simpara>When using connection mode 0 only one constant must be set - all others are optional or can be ignored.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>0</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a code example of connection mode 0 program, download <link xlink:href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%200.gcb">here</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>,<link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_1">
<title>LCD_IO 1</title>
<simpara><emphasis role="strong">Using connection mode 1:</emphasis></simpara>
<simpara>This approach uses a single connectivity line that supports a combined data
and clock signal between the microcontroller and the LCD display. This approach
is used when the LCD is connected through a shift register 74HC595, as detailed
at <link xlink:href="http://gcbasic.sourceforge.net/library/DIAGRAMS/1-Wire%20LCD/1-wire%20LCD%2074HC595%20for%20GCB.jpg">here</link>.
This connection method is also called a 1-wire connection.</simpara>
<simpara>This solution approach recognises the original work provided in the Elektor Magazine.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>Specific constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC. To set these constants the main program should specific constants to support the connection mode using #define.</simpara>
<simpara>When using connection mode 1, only two constants must be set - all others are optional or can be ignored.</simpara>
<simpara>How to connect and control the LCD background led: see <link linkend="_lcdbacklight">LCDBacklight</link>.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_CD</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock/data pin used in 1-bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>LCD.h supports in 1-wire mode the control of pin 4 of the 74HC595 for the background led.</simpara>
<simpara>For a code example download <link xlink:href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%201.gcb">One Wire LCD Example</link>.</simpara>
<simpara>See for further code examples see <link xlink:href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions">0,1 and 2 Wire LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_2_74xx164">
<title>LCD_IO 2_74xx164</title>
<simpara><emphasis role="strong">Using connection mode 2_74XX164:</emphasis></simpara>
<simpara>Use a Data and a Clock line. This manner is used when the LCD is
connected through a  shift register IC either using a 74HC164 or a 74LS164,
as detailed at <link xlink:href="http://gcbasic.sourceforge.net/library/DIAGRAMS/2-Wire%20LCD/">here</link>.
This connection method is also called a 2-wire connection.</simpara>
<simpara>This is the preferred two wire method to connect via a shift register to an LCD display.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>Specific constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC.  To set these constants the main program should specific constants to support the connection mode using #define.</simpara>
<simpara>When using connection mode 2_74XX164 only three constants must be set - all others are optional or can be ignored.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The data pin used in 2-bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_CB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock pin used in 2- bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>LCD.h supports in connection mode 2_74XX164 via the control of pin 11 of the 74HC164 / 74LS164 the background led/backlight.</simpara>
<simpara>How to connect and control the LCD background led: see <link xlink:href="http://gcbasic.sourceforge.net/help/_lcdbacklight.html">http://gcbasic.sourceforge.net/help/_lcdbacklight.html</link></simpara>
<simpara>For a code example download <link xlink:href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%202.gcb">Two Wire LCD Example</link>.</simpara>
<simpara>See for further code examples see <link xlink:href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions">Two Wire LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx74</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_2">
<title>LCD_IO 2</title>
<simpara><emphasis role="strong">Using connection mode 2:</emphasis></simpara>
<simpara>This method uses a Data and a Clock line via a shift register to control the LCD display.
This method is used when the LCD is connected through a shift register IC either using a 74HC164 or a 74LS174, as detailed at <link xlink:href="http://gcbasic.sourceforge.net/library/DIAGRAMS/2-Wire%20LCD/">here</link>.
This connection method is also called a 2-wire connection.</simpara>
<simpara>This is a <emphasis role="strong">deprecated</emphasis> method mode to connect an LCD display to a microcontroller via a shift registry either a 74LS174 (or a 74LS164 with diode connected to pin 11).   This method does not support backlight control and has no additional input/output pin.</simpara>
<simpara>If you have used the 2-wire mode prior to August 2015, please choose this method for your existing code.</simpara>
<simpara>See <link linkend="_lcd_io_2_74xx164">LCD_IO 2 74xx164</link> for the preferred method to connect an LCD display to a microcomputer via a shift register.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>Specific constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC. To set these constants the main program should specific constants to support the connection mode using #define.
When using 2-bit mode only three constants must be set - all others are optional or can be ignored.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The data pin used in 2-bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_CB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock pin used in 2- bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a code example download <link xlink:href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/">Two Wire LCD Example</link>.</simpara>
<simpara>See for further code examples see <link xlink:href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions">Two Wire LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_3">
<title>LCD_IO 3</title>
<simpara><emphasis role="strong">Using connection mode 3:</emphasis></simpara>
<simpara>This method uses a Data and a Clock line via a shift register to control the LCD display plus an Enable line.
This method is used when the LCD is connected through a shift register IC using a LS74574.</simpara>
<simpara>This connection method is also called a 3-wire connection.</simpara>
<simpara>The diagram below shows a method to connect the LCD  to a microcontroller.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/lcd_io3.jpg"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</inlinemediaobject></simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>Specific constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC. To set these constants the main program should specific constants to support the connection mode using #define.
When using 3-bit mode only three constants must be set.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The data pin used in 3-bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_CB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock pin used in 3- bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_EB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The enable pin used in 3- bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 16f628a, 4
    #option explicit

    ;Setup LCD Parameters
    #define LCD_IO 3

    'Change ports as necessary
    #define LCD_DB     PORTb.3            ; databit
    #define LCD_CB     PORTb.4            ; clockbit
    #define LCD_EB     PORTa.0            ; enable bit

      Dim BV as Byte


    'Program Start

     PRINT "GCBASIC"
     Locate 1,0
     PRINT "@2021"
     Wait 4 s

      DO Forever
           CLS
           WAIT 2 s
           PRINT "Test LCDHex "
           wait 3 s
           CLS
           wait 1 s


       for bv = 0 to 16
         locate 0,0
         Print "DEC " : Print BV
         locate 1,0
         Print "HEX "
         LCDHex BV
         Locate 1, 8
         LCDHEX BV, LeadingZeroActive

         wait 500 ms
       next
           CLS
           wait 1 s
           Print "END TEST"
      LOOP</screen>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_2_74xx174">
<title>LCD_IO 2_74xx174</title>
<simpara>LCD_IO 2_74xx174 has been deprecated as preferred method mode to connect an
LCD display to a microcontroller via a shift register either a 74LS174 (or a 74LS164 with
diode connected to pin 11). This method does not support backlight control and has no additional input/output pin.</simpara>
<simpara>See <link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>  for the preferred method to connect
an LCD display to a microcontroller via a shift register.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_4">
<title>LCD_IO 4</title>
<simpara><emphasis role="strong">Using connection mode 4:</emphasis></simpara>
<simpara>To use connection mode 4 the R/W, RS, Enable control lines and the highest 4 data lines (DB4 through DB7) must be connected to the microcontroller.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>Specific constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC.  To set these constants the main program should specific constants to support the connection mode using #define.
Constants required for connection mode 4.</simpara>
<simpara>Constants are required for 4-bit mode as follows.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_SPEED</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FAST</literal>, <literal>MEDIUM</literal> or <literal>SLOW</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>MEDIUM</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Must be <emphasis role="strong">4</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Register Select on the
LCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined as <literal>port.bit</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the LCD. The
R/W pin can be disabled*.</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined as <literal>port.bit</literal> <emphasis>(unless R/W is disabled)</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_Enable</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the LCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined as <literal>port.bit</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output pin used to interface with bit 4 of the LCD data bus</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined as <literal>port.bit</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB5</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output pin used to interface with bit 5 of the LCD data bus</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined as <literal>port.bit</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB6</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output pin used to interface with bit 6 of the LCD data bus</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined as <literal>port.bit</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB7</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output pin used to interface with bit 7 of the LCD data bus</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined as <literal>port.bit</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_VFD_DELAY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies a delay between transmission of data nibbles to LCD or VFD.
</simpara><simpara>Usage must include number value and unit of time.
</simpara><simpara><literal>#DEFINE LCD_VFD_DELAY 1 ms</literal>
</simpara><simpara>Only applicable when using LCD_IO 4</simpara></entry>
<entry align="left" valign="top"><simpara>None.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The <literal>R/W</literal> pin can be disabled by setting the <literal>LCD_NO_RW</literal> constant. If this
is done, there is no need for the <literal>R/W</literal> to be connected to the chip, and
no need for the <literal>LCD_RW</literal> constant to be set. Ensure that the <literal>R/W</literal> line on
the LCD is connected to ground if not used.</simpara>
<simpara>For a code example download <link xlink:href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%204.gcb">Four Wire LCD Example</link>.</simpara>
<simpara>Also see for further code examples see <link xlink:href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions">Four Wire LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_8">
<title>LCD_IO 8</title>
<simpara><emphasis role="strong">Using connection mode 8:</emphasis></simpara>
<simpara>Using connection mode will require <literal>R/W</literal>, <literal>RS</literal>, <literal>Enable</literal> and all 8 data
lines.</simpara>
<simpara>The data lines must all be connected to the same I/O port, in sequential
order. For example, <literal>DB0</literal> to <literal>PORTB.0</literal>, <literal>DB1</literal> to <literal>PORTB.1</literal> and so on, with <literal>DB7</literal>
going to <literal>PORTB.7</literal>.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set them, place a line in the
main program file that uses <literal>#define</literal> to assign a value to the particular
constant.</simpara>
<simpara>Constants are required for 8-bit mode as follows.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_SPEED</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FAST</literal>, <literal>MEDIUM</literal> or <literal>SLOW</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>MEDIUM</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode. Can be 2, 4 or 8.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>8</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Register Select on the
LCD.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the LCD. The
R/W pin can be disabled*.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis> <emphasis>(unless R/W is disabled)</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_Enable</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the LCD.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DATA_PORT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output port used to interface with LCD data bus</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_LAT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Drives the port with <literal>LATx</literal> support. Resolves issues with faster Mhz and
the Microchip PIC read/write/modify feature. See example below.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The <literal>R/W</literal> pin can be disabled by setting the <literal>LCD_NO_RW</literal> constant. If this
is done, there is no need for the <literal>R/W</literal> to be connected to the chip, and
no need for the <literal>LCD_RW</literal> constant to be set. Ensure that the R/W line on
the LCD is connected to ground if not used.</simpara>
<simpara>For a code example download <link xlink:href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%208.gcb">Eight Wire LCD example</link>.</simpara>
<simpara>For code examples see <link xlink:href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions">Eight Wire Examples</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_10">
<title>LCD_IO 10</title>
<simpara><emphasis role="strong">Using connection mode 10:</emphasis></simpara>
<simpara>The LCD is controlled via I2C of a type 10 LCD 12C adapter.
Use LCD_IO 10 for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter.
To use mode 10 you must define the I2C ports as normal in your GCBASIC code.
Then, define the LCD type, set the I2C_address of the LCD adapter and the LCD speed, if required.
Finally, set the backlight control, if required.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the Liquid Crystal Display routines included with GCBASIC. To set them, place a line in the main program file that uses #define to assign a value to the particular constant.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode. Must be 10</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Default <literal>0x4E</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_3</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For code examples see <link xlink:href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions">I2C LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>, <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
<section xml:id="_lcd_io_10_port_configuration">
<title>LCD_IO 10 Port Configuration</title>
<simpara><emphasis role="strong">Using mode 10</emphasis></simpara>
<simpara>When using I2C LCD mode 10 the target I2C device address is setup as
shown below. Each bit of the the variable i2c_lcd_byte is defined to
address the correct LCD display port.</simpara>
<screen>    i2c_lcd_e = i2c_lcd_byte.2
    i2c_lcd_rw = i2c_lcd_byte.1
    i2c_lcd_rs = i2c_lcd_byte.0
    i2c_lcd_bl = i2c_lcd_byte.3
    i2c_lcd_d4 = i2c_lcd_byte.4
    i2c_lcd_d5 = i2c_lcd_byte.5
    i2c_lcd_d6 = i2c_lcd_byte.6
    i2c_lcd_d7 = i2c_lcd_byte.7</screen>
<simpara>If you have an I2C LCD display adapter with a different set of
connection of the adapter then change this configuration to suit the
specific of the adapter as follows. This should be done in the your main
program code.</simpara>
<screen>    #define i2c_lcd_e i2c_lcd_byte.1
    #define i2c_lcd_rw i2c_lcd_byte.2
    #define i2c_lcd_rs i2c_lcd_byte.0
    #define i2c_lcd_bl i2c_lcd_byte.3
    #define i2c_lcd_d4 i2c_lcd_byte.7
    #define i2c_lcd_d5 i2c_lcd_byte.6
    #define i2c_lcd_d6 i2c_lcd_byte.5
    #define i2c_lcd_d7 i2c_lcd_byte.4</screen>
</section>
</section>
<section xml:id="_lcd_io_12">
<title>LCD_IO 12</title>
<simpara><emphasis role="strong">Using connection mode 12:</emphasis></simpara>
<simpara>The LCD is controlled via I2C.
A type 12 is the Ywmjkdz I2C adapter with potentiometer  variable resistor) bent over top of chip.
To use mode 12 you must define the I2C ports as normal in your GCB code.
Then, define the LCD type, set the I2C_address of the LCD adapter and the LCD speed, if required.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set them, place a line in the
main program file that uses <literal>#define</literal> to assign a value to the particular
constant.</simpara>
<simpara>When using 2-bit mode only three constants must be set - all others can
be ignored.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>I/O mode</simpara></entry>
<entry align="left" valign="top"><simpara><literal>12</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Default <literal>0x4E</literal><?asciidoc-br?>
 could also be <literal>0x27</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>To set the correct address see the picture below:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/lcd_io12b1.JPG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For code examples see <link xlink:href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions">I2C LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link></simpara>
<section xml:id="_lcd_io_12_port_configuration">
<title>LCD_IO 12 Port Configuration</title>
<simpara><emphasis role="strong">Using mode 12:</emphasis></simpara>
<simpara>When using I2C LCD mode 12 the target I2C device address is setup as
shown below. Each bit of the the variable <literal>i2c_lcd_byte</literal> is defined to
address the correct LCD display port.</simpara>
<screen>    i2c_lcd_e = i2c_lcd_byte.4
    i2c_lcd_rw = i2c_lcd_byte.5
    i2c_lcd_rs = i2c_lcd_byte.6
    i2c_lcd_bl = i2c_lcd_byte.7
    i2c_lcd_d4 = i2c_lcd_byte.0
    i2c_lcd_d5 = i2c_lcd_byte.1
    i2c_lcd_d6 = i2c_lcd_byte.2
    i2c_lcd_d7 = i2c_lcd_byte.3</screen>
<simpara>If you have an I2C LCD display adapter with a different set of
connection of the adapter then change this configuration to suit the
specific of the adapter as follows. This should be done in the your main
program code.</simpara>
<screen>    #define i2c_lcd_e i2c_lcd_byte.4
    #define i2c_lcd_rw i2c_lcd_byte.5
    #define i2c_lcd_rs i2c_lcd_byte.6
    #define i2c_lcd_bl i2c_lcd_byte.7
    #define i2c_lcd_d4 i2c_lcd_byte.3
    #define i2c_lcd_d5 i2c_lcd_byte.2
    #define i2c_lcd_d6 i2c_lcd_byte.1
    #define i2c_lcd_d7 i2c_lcd_byte.0</screen>
</section>
</section>
<section xml:id="_lcd_io_14">
<title>LCD_IO 14</title>
<simpara><emphasis role="strong">Using connection mode 14:</emphasis></simpara>
<simpara>Using this LCD IO methof the LCD is controlled via an SPI expander.</simpara>
<simpara>To use mode 14 you must define the SPI ports as normal in your GCB code.
Then, define the LCD type, set the SPI address of the SPI expander, and, the LCD speed, if required.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/lcd_io_14_1.png" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the LCD routines included with GCBASIC.&#160;&#160; To set them, place a line in the main program file that uses <literal>#define</literal> to assign a value to the particular constant.</simpara>
<simpara>When using this mode only three constants are mandated - all others can be ignored.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>I/O mode</simpara></entry>
<entry align="left" valign="top"><simpara><literal>14</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_SPI_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Microcontroller SPI data out port</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_SPI_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Microcontroller SPI clock out port</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_SPI_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Microcontroller SPI chip select port</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Connectivity</emphasis></simpara>
<simpara>The connectivity is shown below.&#160;&#160;The microcontroller connections are as shown below.&#160;&#160;This is an example using the Microchip Explorer 8 board.</simpara>
<screen>    RC3 &gt; Expander SPI SCK ( clock)
    RC5 &gt; Expander SPI SI (slave in)
    RA2 &gt; Expander SPI CS ( chip select) - could be set to 0v0
    RB5 &gt; Expander Reset ( optional)</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/lcd_io_14_2.png" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Optional configuration</emphasis></simpara>
<simpara>There are some options you can tweak. See the example setup below. You can play with the use of hardware or software SPI, SPI frequency ( HWSPIMODE MASTERFAST). LED speed, the connectivity between the expander and the LCD and otheroptions.</simpara>
<screen>        //Constants - LCD connectivity type; controls whether to use HW SPI; The inter character delay
        #define LCD_IO 14
        #define LCD_HARDWARESPI
        #define LCD_SPEED FAST
        #define HWSPIMODE MASTERFAST

        //These are the phyiscal connections from the expander to the LCD.  These are automatically set in the library and are shown here purely for clarity.
        #define     LCD_SPI_EXPD_ADDRESS        0x40     // address of the expander
        #define LCD_SPI_EXPANDER_E_ADDRESS      0x40     // GPA6 on the expander
        #define LCD_SPI_EXPANDER_RS_ADDRESS     0x80     // GPA7 on the expander

        //Pin mappings for LCD IO SPI Expander
        #define LCD_SPI_DO          portc.5             // constant is mandated
        #define LCD_SPI_SCK         portc.3             // constant is mandated
        #define LCD_SPI_CS          porta.2             // constant is required.
        // Optional(s) reset Port.Pin connection to expander, select one.
            // #define LCD_SPI_RESET_IN       portb.5
            #define LCD_SPI_RESET_OUT      portb.5</screen>
<simpara>For code examples see <link xlink:href="http://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions">LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link>, <link linkend="_lcd_io_10">LCD_IO 12</link></simpara>
<section xml:id="_lcd_io_14_port_configuration">
<title>LCD_IO 14 Port Configuration</title>
<simpara><emphasis role="strong">Using mode 14:</emphasis></simpara>
<simpara>When using LCD mode 14 this is an example program to show a working solution,</simpara>
<screen>        #chip 18F67K40, 8
        #option explicit

            'PPS Tool version: 0.0.6.3
            // Generated for 18f67k40

            #startup InitPPS, 85
            #define PPSToolPart 18f67k40

            Sub InitPPS

                    #ifdef LCD_HARDWARESPI
                        SSP1CLKPPS = 0x13;   //RC3-&gt;MSSP1:SCK1;
                        RC3PPS = 0x19;   //RC3-&gt;MSSP1:SCK1;
                        RC5PPS = 0x1A;   //RC5-&gt;MSSP1:SDO1;
                        SSP1DATPPS = 0x14;   //RC4-&gt;MSSP1:SDI1;
                    #endif

                End Sub

            //Constants - LCD connectivity type
            #define LCD_IO 14

            //Comment out to use software SPI
            #define LCD_HARDWARESPI

            #define LCD_SPEED FAST

            //Optional. Can also select MASTERSLOW or MASTER.  The compiler will set automatically.
            #define HWSPIMODE MASTERFAST

            //These are phyiscal connections from the expander to the LCD.  These are automatically set in the library and are shown here purely for clarity.
                #define     LCD_SPI_EXPD_ADDRESS        0x40
                #define LCD_SPI_EXPANDER_E_ADDRESS      0x40     // GPA6 on the expander
                #define LCD_SPI_EXPANDER_RS_ADDRESS     0x80     // GPA7 on the expander

            //Mandated Pin mappings for LCD IO SPI Expander
            #define LCD_SPI_DO          portc.5
            #define LCD_SPI_SCK         portc.3
            #define LCD_SPI_CS          porta.2
            // Optional(s) reset Port.Pin connection to expander, select one.
                // #define LCD_SPI_RESET_IN       portb.5
                #define LCD_SPI_RESET_OUT      portb.5


        ; ----- Main body of program commences here.

        ClS
        Print "Hello World"</screen>
</section>
</section>
<section xml:id="_lcd_io_107">
<title>LCD_IO 107</title>
<simpara><emphasis role="strong">Using connection mode 107:</emphasis></simpara>
<simpara>The LCD is controlled via the serial port.
A type 107 is a K107 serial adapter.
To use mode 107 you must define the serial port as normal in your GCB code.
Then, serial speed to match the K107 adapter.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the Liquid Crystal
Display routines included with GCBASIC. To set them, place a line in the
main program file that uses <literal>#define</literal> to assign a value to the particular
constant.</simpara>
<simpara>When using 107 mode only one constants must be set - all others can
be ignored.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>I/O mode</simpara></entry>
<entry align="left" valign="top"><simpara><literal>107</literal> or <literal>K107</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example Code:</emphasis></simpara>
<screen>    #chip 16f18313
    #option Explicit

    'Generated by PIC PPS Tool for GCBASIC
    'Generated for 16f18313
    '
    #startup InitPPS, 85
    #define PPSToolPart 16f18313

    Sub InitPPS

            'Module: EUSART
            RA5PPS = 0x0014    'TX &gt; RA5

    End Sub
    'Template comment at the end of the config file

    'USART settings for USART1
    #define USART_BAUD_RATE 115200
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF

    #define LCD_IO 107   'K107


    do Forever
      CLS
      Print "GCBASIC 2021"
      Locate 1, 0
      Print "Reading ADC ANA0"

      Locate 3, 0
      Print "Scaled = "
      Print Scale( ReadAD( ANA0 ), 0, 236, 0, 100 )
      wait 100 ms
    loop</screen>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link></simpara>
</section>
<section xml:id="_lcd_variant">
<title>LCD_VARIANT</title>
<simpara><emphasis role="strong">Using LCD_VARIANT:</emphasis></simpara>
<simpara>Some LCDs are non-standard.&#160;&#160;
The non-standard LCDs may have a different memory architecture where the memory is non-consective or different delay timing is required  for the LCD IC.&#160;&#160;
Use <literal>LCD_VARIANT</literal> to change the operating behaviour of GCBASIC with respect to LCD operations.&#160;&#160;
If a <literal>LCD_VARIANT</literal> adaption has been created in the library then the non-standard LCD can be supported.</simpara>
<simpara><emphasis role="strong">#DEFINE LCD_VARIANT 1601a</emphasis></simpara>
<simpara>Use <literal>#define LCD_VARIANT 1601a</literal> to use this sub variant. Requires a LCD_IO then this sub type modifier.&#160;&#160;
This variant has a non consective memory as shown in the diagram below.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/Variant_1601a_LCD_Solution-Memory_Map.png" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example shows how to use the LCD_VARIANT constant.&#160;&#160;
This example shows the use of software I2C - any LCD mode can be used not just software I2C.&#160;&#160;</simpara>
<screen>    #chip tiny84,1

    'Set up LCD
    #define LCD_IO 10
    #define LCD_VARIANT 1601a
    #define LCD_WIDTH 16

    'You may need to use SLOW or MEDIUM if your LCD is a slower device.
    #define LCD_SPEED FAST

    ' ----- Define Hardware settings
    ' Define I2C settings - CHANGE PORTS FOR YOUR NEEDS
    #define LCD_I2C_Address 0x0E
    #define I2C_MODE Master
    #define I2C_DATA PORTA.4
    #define I2C_CLOCK PORTA.5
    #define I2C_DISABLE_INTERRUPTS ON

    'You may need to invert these states. Dependent of LCD I2C adapter.
    #define LCD_Backlight_On_State  1
    #define LCD_Backlight_Off_State 0

    ; ----- Main body of program commences here.
    Locate 0,0
    PRINT "GCBASIC"


    Do
    Loop</screen>
<simpara>For code examples see <link xlink:href="https://github.com/Anobium/Great-Cow-BASIC-Demonstration-Sources/tree/master/LCD_Solutions/Variant1601a_LCD_Solutions">I2C Variants LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link></simpara>
</section>
<section xml:id="_lcd_speed">
<title>LCD_SPEED</title>
<simpara><emphasis role="strong">Using LCD_SPEED:</emphasis></simpara>
<simpara>The communication performance of a LCD display can be controlled via a <literal>#DEFINE</literal>.
This method allows the timing to be optimised.</simpara>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<literallayout class="monospaced">#DEFINE LCD_SPEED  FAST</literallayout>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Define</entry>
<entry align="left" valign="top">Required Connections</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_SPEED</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Options are:<?asciidoc-br?>
<literal>FAST</literal>     - The speed is approximately 20,000 CPS.<?asciidoc-br?>
<literal>MEDIUM</literal>   - The speed is approximately 15,000 CPS.<?asciidoc-br?>
<literal>SLOW</literal>     - The speed is approximately 10,000 CPS.<?asciidoc-br?>
<literal>OPTIMAL</literal>  - The speed is approximately 30,000 CPS.<?asciidoc-br?></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>If <literal>LCD_SPEED</literal> is not defined, the speed defaults to <literal>SLOW</literal>
<?asciidoc-br?>
<?asciidoc-br?>
To change the performance (communications speed) of the LCD use <literal>#DEFINE LCD_SPEED</literal>.  This method allows the timing to be optimised.</simpara>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<screen>  #DEFINE LCD_SPEED  FAST</screen>
<simpara>If <literal>LCD_SPEED</literal> is not defined, the speed defaults to <literal>SLOW</literal></simpara>
<simpara><emphasis role="strong">Speed Parameter  OPTIMAL</emphasis></simpara>
<simpara>WHEN LCD_NO_RW is not defined,  OPTIMAL disables fixed delays and allows the LCD operate as fast as it can.</simpara>
<simpara>In this mode, The the busy flag is polled before each byte is sent to the HD44780 controller. &#160;&#160;This not only optimizes speed, but also assures that data is not sent to the diplay controler until it is ready to receive the data.</simpara>
<simpara>With most displays this equates to a speed of about 30,000 characters per second.  For comparision about 10 times faster than I2C using a PC8574 Expander (See LCD_IO 10 or  See LCD_IO 112)</simpara>
<simpara><literal>OPTIMAL</literal> is only supported in LCD_IO 4,8 and only when LCD_NO_RW is not defined  (RW Mode)</simpara>
<simpara>When <literal>#DEFINE LCD_NO_RW</literal> is defined, reading data from the HD44780 is not possible since this disables Read Mode on the controller.&#160;&#160;In this case busy flag checking is not available and the GET subroutine is not avaiable.</simpara>
<simpara>In order to enable busy flag checking, and, therefore to use the <literal>GET</literal> command the following criteria must be true.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>LCD I/O Mode must be either 4-wire or 8-wire</simpara>
</listitem>
<listitem>
<simpara><literal>#DEFINE LCD_NO_RW</literal> is not defined</simpara>
</listitem>
<listitem>
<simpara>An I\O pin is connected between the microcontroller and the RW connection on the LCD Display</simpara>
</listitem>
<listitem>
<simpara><literal>'DEFINE LCD_RW  port.pin</literal> is defined in the GCBASIC source code</simpara>
</listitem>
</orderedlist>
<simpara>Example:</simpara>
<screen>  #DEFINE LCD_IO 4
  #DEFINE LCD_SPEED OPTIMAL
  #DEFINE LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
  #DEFINE LCD_DB7 PORTB.5
  #DEFINE LCD_DB6 PORTB.4
  #DEFINE LCD_DB7 PORTB.3
  #DEFINE LCD_DB6 PORTB.2

  #DEFINE LCD_RW PORTA.3    'Must be defined for RW Mode
  #DEFINE LCD_RS PORTA.2
  #DEFINE LCD_ENABLE PORTA.1</screen>
</section>
<section xml:id="_lcd_width">
<title>LCD_WIDTH</title>
<simpara><emphasis role="strong">Using LCD_WIDTH:</emphasis></simpara>
<simpara>This constant changes the width characteristics of a LCD display.  &#160;&#160;&#160;The standard width is assumed to be 20 characters.</simpara>
<simpara>This constant allows the width to be optimised for specific LCD chipsets.</simpara>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<literallayout class="monospaced">#DEFINE LCD_WIDTH  16</literallayout>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Define</entry>
<entry align="left" valign="top">Required Connections</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Default is 20<?asciidoc-br?>
<literal>16</literal>   - Set the WIDTH 16 characters<?asciidoc-br?></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>If <literal>LCD_WIDTH</literal> is not defined, the WIDTH defaults to <literal>20</literal></simpara>
</section>
</section>
<section xml:id="_cls">
<title>CLS</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    CLS</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>CLS</literal> command clears the contents of the LCD, and returns the cursor
to the top left corner of the screen</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>        'A Flashing text "Hello World" program for GCBASIC

        'General hardware configuration
        #chip 16F877A, 20

        'LCD connection settings
        #define LCD_IO 8
        #define LCD_DATA_PORT PORTC
        #define LCD_RS PORTD.0
        #define LCD_RW PORTD.1
        #define LCD_Enable PORTD.2
        #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width


        'Main routine
        Do
            Print "Hello World"
            Wait 1 sec
            CLS
            Wait 1 sec
        Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_get">
<title>Get</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    var = Get(Line, Column)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with the LCD R/W line (pin 5) connected and if the following constant definition is used;
<literal>#define LCD_RW</literal>. Only available when the LCD is connected using the 4 or 8 bit mode and when the constant definition
<literal>#define LCD_NO_RW</literal> is NOT used.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Get</literal> function reads the ASCII character code at a given location on
the LCD.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_put">Put</link>,
<link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdbacklight">
<title>LCDBacklight</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDBacklight ( On | Off )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Sets the LCD backlight on or off</simpara>
<simpara>Do not connect the LCD backlight directly to the microcontroller! Always refer to
the datasheet for the correct method to drive the LCD backlight.</simpara>
<simpara>For 0, 4, 8, 404 LCD types you <emphasis role="strong">must</emphasis> define the controlling port.pin for the LCD backlight.</simpara>
<screen>        'this port.pin is connected to the LCD backlight via a suitable circuit
        #define LCD_Backlight porta.4
        ...
        ...
        ...
        ...
        LCDBacklight ( On )

        .... more user code...
        LCDBacklight ( Off )</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Inverting the State of the LCD</emphasis></simpara>
<simpara>You may need to invert the state of the LCD backlight control port.  This can be achieved by setting the following constants.</simpara>
<screen>        'Invert the LCD Backlight States to suit the circuit board
        #define LCD_Backlight_On_State  0    'the default constant value is 1
        #define LCD_Backlight_Off_State 1    'the default constant value is 0</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The diagram below shows a method to connect the LCD backlight to a microcontroller.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/lcdbacklightb1.JPG"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</inlinemediaobject>
The diagram above was provided by William Roth, January 2015.</simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdcreatechar">
<title>LCDCreateChar</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDCreateChar <emphasis>char, chardata()</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The LCDCreateChar command is used to send a custom character to the LCD.</simpara>
<simpara>Each character on the LCD is made up from an 8 row by 5 column (5x8)
matrix of pixels. The data to be sent to the LCD is composed of an 8
element array, where each element corresponds to a row. Inside each
element, the 5 lowest bits make up the data for the corresponding row.
When a bit is set a dot will be drawn at the matching location; when it
is cleared, no dot will appear.</simpara>
<simpara>An array of more than 8 elements may be used, but only the first 8 will
be read.</simpara>
<simpara><literal><emphasis>char</emphasis></literal> is the ASCII value of the character to create. ASCII codes 0
through 7 are usually used to store custom characters.<?asciidoc-br?>
<literal><emphasis>chardata()</emphasis></literal> is an array containing the data for the character.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program draws a smiling face character

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Create an array to store the character until it is copied
    Dim CharArray(8)

    'Set the array to hold the character
    'Binary has been used to improve the readability of the code, but is not essential
    CharArray(1) = b'00011011'
    CharArray(2) = b'00011011'
    CharArray(3) = b'00000000'
    CharArray(4) = b'00000100'
    CharArray(5) = b'00000000'
    CharArray(6) = b'00010001'
    CharArray(7) = b'00010001'
    CharArray(8) = b'00001110'

    'Copy the character from the array to the LCD
    LCDCreateChar 0, CharArray()

    'Draw the custom character
    LCDWriteChar 0</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lcdcreatechar">LCDWriteChar</link>,
<link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdcreategraph">
<title>LCDCreateGraph</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDCreateGraph <emphasis>value</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The LCDCreateGraph command will create a graph like character which can
then be displayed on the LCD</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F88,8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Locate 0,0
    Print "Reset"
    wait 1 s
    cls

    Graph_Tests:

    cls
    'Draw the custom character - fill the LCD
    repeat 64
          LCDWriteChar 0
    end Repeat

    ' Update the characters at high speed without re-printing on LCD
    for graphvalue = 0 to 8
        LCDCreateGraph ( 0 ,  graphvalue )
        wait 100 ms
    next</screen>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdcmd">
<title>LCDCmd</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDCMD <emphasis>value</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command set LCD specific instructions to the LCD display. As shown
in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">INSTRUCTION</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Decimal</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Hexadecimal</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Scroll display one character right (all lines)</simpara></entry>
<entry align="center" valign="top"><simpara>28</simpara></entry>
<entry align="center" valign="top"><simpara>1E</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Scroll display one character left (all lines)</simpara></entry>
<entry align="center" valign="top"><simpara>24</simpara></entry>
<entry align="center" valign="top"><simpara>18</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Home (move cursor to top/left character position)</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Move cursor one character left</simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Move cursor one character right</simpara></entry>
<entry align="center" valign="top"><simpara>20</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Turn on visible underline cursor</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
<entry align="center" valign="top"><simpara>0E</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Turn on visible blinking-block cursor</simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
<entry align="center" valign="top"><simpara>0F</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Make cursor invisible</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
<entry align="center" valign="top"><simpara>0C</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Blank the display (without clearing)</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
<entry align="center" valign="top"><simpara>08</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Restore the display (with cursor hidden)</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
<entry align="center" valign="top"><simpara>0C</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Clear Screen</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="center" valign="top"><simpara>01</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Set cursor position (DDRAM address)</simpara></entry>
<entry align="center" valign="top"><simpara>128 + addr</simpara></entry>
<entry align="center" valign="top"><simpara>80+ addr</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Set pointer in character-generator RAM (CG RAM address)</simpara></entry>
<entry align="center" valign="top"><simpara>64 + addr</simpara></entry>
<entry align="center" valign="top"><simpara>40+ addr</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F88,8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Locate 0,0
    Print "Reset"
    wait 1 s
    cls

    LCD_Command_Tests:

    locate 0,8
    print "123456"
    'Scroll display one character right (all lines)       28
    '
    lcdcmd 28
    wait 1 s
    lcdcmd 28
    wait 1 s
    lcdcmd 28
    wait 1 s
    lcdcmd 28
    wait 1 s

    'Scroll display one character left (all lines)        24
    '
    lcdcmd 24
    wait 1 s
    lcdcmd 24
    wait 1 s
    lcdcmd 24
    wait 1 s
    lcdcmd 24
    wait 1 s


    'Home (move cursor to top/left character position)    2
    '
    lcdcursor flash
    lcdcmd 2
    wait 1 s

    'Move cursor one character left                       16
    '
    lcdcursor flash
    locate 0,8

    lcdcmd 16
    wait 1 s
    lcdcmd 16
    wait 1 s
    lcdcmd 16
    wait 1 s
    lcdcmd 16
    wait 1 s

    'Move cursor one character right                      20
    '
    lcdcmd 20
    wait 1 s
    lcdcmd 20
    wait 1 s
    lcdcmd 20
    wait 1 s
    lcdcmd 20
    wait 1 s</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    #chip 16F877A,20
    #option Explicit

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

    ;Here are various LCD commands which can be used.
    ;These are the LCD commands for the HD44780 controller
    #define clrHome = 1     ;clear the display, home the cursor
    #define home    = 2     ;home the cursor only
    #define RtoL    = 4     ;print characters right to left
    #define insR    = 5     ;insert characters to right
    #define LtoR    = 6     ;print characters left to right
    #define insL    = 7     ;insert characters to left
    #define lcdOff  = 8     ;LCD screen off
    #define lcdOn   = 12    ;LCD screen on, no cursor
    #define curOff  = 12    ;an alias for the above
    #define block   = 13    ;LCD screen on, block cursor
    #define under   = 14    ;LCD screen on, underline cursor
    #define undblk  = 15    ;LCD screen on, blinking and underline cursor
    #define CLeft   = 16    ;cursor left
    #define CRight  = 20    ;cursor right
    #define panR    = 24    ;pan viewing window right
    #define panL    = 28    ;pan viewing window left
    #define bus4    = 32    ;4-bit data bus mode
    #define bus8    = 48    ;8-bit data bus mode
    #define mode1   = 32    ;one-line mode (alias)
    #define mode2   = 40    ;two-line mode
    #define line1   = 128   ;go to start of line 1
    #define line2   = 192   ;go to start of line 2
    ;----- Variables
    dim char, msn, lsn, index, ii as byte
    ;----- Main Program
    LoadEeprom              ;load the EEprom with strings

    do forever
        printMsg(0)             ;print first message
        wait 3 S                ;pause 3 seconds
        printMsg(2)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 5                ;blink it five times
          LCDCmd(lcdOff)       ;display off
          wait 500 mS           ;pause
          LCDCmd(lcdOn)        ;display on
          wait 500 mS           ;pause
        end repeat
        wait 1 S                ;pause before next demo
        ;demonstrate panning
        printMsg(4)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 16
          LCDCmd(panL)         ;pan left a step at a time
          wait 300 mS           ;slow down to avoid blur
        end repeat
        repeat 16
          LCDCmd(panR)         ;then pan right
          wait 300 mS
        end repeat
        wait 1 S                ;pause before next demo
                                ;demonstrate moving the cursor
        printMsg(6)             ;print next message
        wait 3 S                ;pause 3 seconds
        LCDHome
        LCDCmd(under)          ;choose underline cursor
        for ii = 0 to 15         ;move cursor across first line
          LCDCmd(line1+ii)
          wait 200 mS
        next i
        for ii = 0 to 15         ;move cursor across second line
          LCDCmd(line2+ii)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over second line
          LCDCmd(line2+ii)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over first line
          LCDCmd(line1+ii)
          wait 200 mS
        next i
        wait 3 S
        ;demonstrate blinking block cursor
        printMsg(8)             ;print next message
        LCDHome                  ;home the cursor
        LCDCmd(block)          ;choose blinking block cursor
        wait 4 S                ;pause 4 seconds
        LCDCmd(mode1)          ;change to one long line mode
        LCDHome                  ;home the cursor again
        LCDCmd(curOff)         ;and disable it


        ;demonstrate scrolling a lengthy one-line marquee
        for ii = 0xd0 to 0xff    ;print next message - the remaining EEPROM
          EPread ii, char        ;fetch directly from eeprom
          print chr(char)
        next i
        wait 1 S
        LCDHome                  ;home cursor once more
        repeat 141               ;scroll message twice
          LCDCmd(panR)
          wait 250 mS
        end repeat
        wait 2 S
        LCDCmd(mode2)          ;change back to two line mode
        CLS                   ;clear the screen
        ;demonstrate all of the characters
        printMsg(11)             ;print next message
        for ii = 33 to 127       ;print first batch of ASCII characters
          LCDCmd(line1+12)       ;overwrite each character displayed
          print chr(ii)          ;this is the ASCII code
          wait 500 mS
        next i
        for ii = 161 to 255      ;print next batch of ASCII characters
          LCDCmd(line1+12)
          print chr(ii)
          wait 500 mS
        next i
        ;say good-bye
        LCDCmd(line2)
        printMsg(11)             ;print next message
        LCDHome                  ;home the cursor
    loop
    end

    ;----- Print a message to the LCD
    ;The parameter 'row' points to the start of the string.
    sub printMsg(in row as byte, in Optional StringLength As Byte = 15)
      Locate 0, 0              ;get set for first line

      for ii = 0 to StringLength
        index = row*16+ii
        EPread index, char        ;fetch next character and
        print chr(char)             ;transmit to the LCD
      next

      Locate 1,0              ;get set for second line
      for ii = 0 to StringLength
        index = (row+1)*16+ii
        EPread index, char        ;fetch next character and
        print chr(char)             ;transmit to the LCD
      next
    end sub

    sub loadEeprom

    ' Strings for EEPROM, Strings should be limited to 16 characters for the first 13 sstrings, then a long string to fill eeprom
    WriteEeprom "First we'll show"
    WriteEeprom "this message.   "
    WriteEeprom "Then we'll blink"
    WriteEeprom "five times.     "
    WriteEeprom "Now lets pan    "
    WriteEeprom "left and right. "
    WriteEeprom "Watch the line  "
    WriteEeprom "cursor move.    "
    WriteEeprom "A block cursor  "
    WriteEeprom "is available.   "
    WriteEeprom "Characters:     "
    WriteEeprom "Bye!            "
    WriteEeprom "in one line mode"
    WriteEeprom "Next well scroll this long message as a marquee"
    end sub


    ; Write to the device eeprom
    sub WriteEeprom ( in Estring() )

        Dim eeLocation as Byte 'if the EEPROM size was larger than 256 bytes then this would need to be a WORD

        for eeLocation = 1 to len ( Estring )
            HSersend Estring( eeLocation )
            epwrite eeLocation, Estring( eeLocation )
        next
    end sub</screen>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdcursor">
<title>LCDCursor</title>
<simpara><emphasis role="strong">Syntax</emphasis>:</simpara>
<screen>    LCDCursor value</screen>
<simpara><emphasis role="strong">Command Availability</emphasis>:</simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The LCDCursor command will accept the following parameters:</simpara>
<simpara><literal>LCDON</literal>, <literal>LCDOFF</literal>, <literal>CURSORON</literal>, <literal>CURSOROFF</literal>, <literal>FLASHON</literal>, <literal>FLASHOFF</literal></simpara>
<simpara><literal>FLASH</literal>, and <literal>ON/OFF</literal> have been retained for backward compatibility with
older releases of GCB.</simpara>
<simpara><literal>LCDON</literal>  will turn on (restore) the LCD display.<?asciidoc-br?>
<literal>LCDOFF</literal>  will turn off (hide) the LCD display.<?asciidoc-br?>
<literal>CURSORON</literal>  will turn on the cursor.<?asciidoc-br?>
<literal>CURSOROFF</literal>  will turn off the cursor.<?asciidoc-br?>
<literal>FLASHON</literal>  will flash the cursor.<?asciidoc-br?>
<literal>FLASHOFF</literal>  will stop flashing the cursor.</simpara>
<simpara><emphasis role="strong">Example :</emphasis>																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												#config osc = intrc</simpara>
<screen>    #chip 16f877a, 8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Start:
    CLS
    WAIT 3 s
    PRINT "START DEMO"
    locate 1,0
    PRINT "DISPLAY ON"

    wait 3 s

    CLS
    Locate 0,0
    Print "Cursor ON"
    Locate 1,0
    LCDcursor CursorOn
    wait 3 S

    CLS
    LCDcursor CursorOFF
    locate 0,0
    Print "Cursor OFF"
    wait 3 s

    CLS
    Locate 0,0
    Print "FLASH ON"
    Locate 1,0
    LCDcursor FLASHON
    wait 3 s

    CLS
    locate 0,0
    Print "FLASH OFF"
    LCDCURSOR FLASHOFF
    wait 3 sec

    Locate 0,0
    Print "CURSOR&amp;FLASH ON" 'Both are on at the same time
    locate 1,0
    LCDCURSOR CURSORON
    LCDCURSOR FLASHON
    Wait 3 sec

    Locate 0,0
    Print "CURSOR FLASH OFF"
    locate 1,0
    LCDCURSOR CursorOFF
    LCDCURSOR FLASHOFF
    Wait 3 sec

    CLS
    Locate 0,4
    PRINT "Flashing"
    Locate 1,4
    Print "Display"
    wait 500 ms

    repeat 5
        LCDCURSOR LCDOFF
        wait 500 ms
        LCDCURSOR LCDON
        wait 500 ms
    end repeat

    CLS
    Locate 0,0
    Print "DISPLAY OFF"
    Locate 1,0
    Print "FOR 5 SEC"
    Wait 2 SEC
    LCDCURSOR LCDOFF
    WAIT 5 s

    CLS
    Locate 0,0
    LCDCURSOR LCDON
    Print "END DEMO"
    wait 3 s
    goto start</screen>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdhex">
<title>LCDHex</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDHex value

    LCDHex value, <emphasis role="strong">LeadingZeroActive</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The LCDHex will display the byte value as a 1 or 2 character HEX string.</simpara>
<simpara><literal>value</literal> is a byte value from 0 to 255.</simpara>
<simpara><literal>LeadingZeroActive</literal> is a constant or byte value of 2.</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    ;Set chip model required:
    #chip mega328p, 16
    ;Setup LCD Parameters
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_NO_RW
    #define LCD_Speed MEDIUM 'FAST IS OK ON ARDUINO UNO R3

    'Change as necessary
    #define LCD_RS PortC.0
    #define LCD_Enable PortC.1
    #define LCD_DB4 PortC.2
    #define LCD_DB5 PortC.3
    #define LCD_DB6 PortC.4
    #define LCD_DB7 PortC.5

    '  #chip 16f877a, 8
    '  ;Setup LCD Parameters
    '  #define LCD_IO 4
    '  #define LCD_NO_RW
    '  #define LCD_Speed fast 'FAST IS OK ON 16f877a
    '
    '  ;Change as necessary
    '  #define LCD_RS PortB.2
    '  #define LCD_Enable PortB.3
    '  #define LCD_DB4 PortB.4
    '  #define LCD_DB5 PortB.5
    '  #define LCD_DB6 PortB.6
    '  #define LCD_DB7 PortB.7

    'Program Start
    DO Forever
       CLS
       WAIT 2 s
       PRINT "Test LCDHex "
       wait 3 s
       CLS
       wait 1 s

       for bv = 0 to 255
          locate 0,0
          Print "DEC " : Print BV
          locate 1,0
          Print "HEX "
          LCDHex BV, LeadingZeroActive ; dislay leading Zero
        ' LCDHex BV         ; do not display leading zero
          wait 1 s
       next
       CLS
       wait 1 s
       Print "END TEST"
    LOOP</screen>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdhome">
<title>LCDHome</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDHome</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>LCDHome</literal> command will return the cursor to home position.</simpara>
<simpara>The currentcontents of the LCD screen will be retained.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F88,8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Locate 0,0
    Print "Reset"
    wait 1 s
    ClS

    Cursor_Home_Tests:

    cls
    lcdcursor flash
    print "Test Home Cmd"
    LCDHome
    wait 3 s</screen>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcddisplayon">
<title>LCDDisplayOn</title>
<simpara><emphasis role="strong">Syntax</emphasis>:</simpara>
<screen>    LCDDisplayOn</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Will turn on (restore) the LCD display</simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_lcdcursor">LCDCursor</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcddisplayoff">
<title>LCDDisplayOff</title>
<simpara><emphasis role="strong">Syntax</emphasis>:</simpara>
<screen>    LCDDisplayOff</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Will turn off (hide) the LCD display.</simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_lcdcursor">LCDCursor</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdspace">
<title>LCDSpace</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDSpace value</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The LCDSpace command will print the required number of spaces on the LCD
display</simpara>
<simpara><literal>value</literal> is a byte value from 1 to 255. Where the <literal>value</literal> is the number of spaces required.</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    Locate 0,0
    Print "Reset"
    wait 1 s
    cls

    LCD_Space_Tests:

    lcdcursor flash

    lcdspace 12

    print "*"</screen>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdwritechar">
<title>LCDWriteChar</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDWriteChar <emphasis>char</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>LCDWriteChar</literal> command will show the specified character on the LCD,
at the current cursor position.</simpara>
<simpara><literal><emphasis>char</emphasis></literal> is the ASCII value of the character to show. On most LCDs,
characters 0 through 7 are user defined, and can be set using the
<literal>LCDCreateChar</literal> command.</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    'This program draws a smiling face character

    'Create an array to store the character until it is copied
    Dim CharArray(8)

    'Set the array to hold the character
    CharArray(1) = b'00011011'
    CharArray(2) = b'00011011'
    CharArray(3) = b'00000000'
    CharArray(4) = b'00000100'
    CharArray(5) = b'00000000'
    CharArray(6) = b'00010001'
    CharArray(7) = b'00010001'
    CharArray(8) = b'00001110'

    'Copy the character from the array to the LCD
    LCDCreateChar 0, CharArray()

    'Draw the custom character
    LCDWriteChar 0</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lcdcreatechar">LCDCreateChar</link>,
<link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_locate">
<title>Locate</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Locate <emphasis>Line, Column</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The Locate command is used to move the cursor on the LCD to the given
location.</simpara>
<simpara><literal>Line</literal> is line number on the LCD display. A byte value from 0 to 255.</simpara>
<simpara><literal>Column</literal> is column number on the LCD display. A byte value from 0 to 255.</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    'A Hello World program for GCBASIC.
    'Uses Locate to show "World" on the second line

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Main routine
    Print "Hello"
    Locate 1, 5
    Print "World"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_print">
<title>Print</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Print <emphasis>string</emphasis>
    Print <emphasis>byte</emphasis>
    Print <emphasis>word</emphasis>
    Print <emphasis>long</emphasis>
    Print <emphasis>integer</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The Print command will show the contents of a variable on the LCD. It
can display string, word, byte, long or integer variables.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'A Light Meter program.

    'General hardware configuration
    #chip 16F877A, 20
    #define LightSensor AN0

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    CLS
    Print "Light Meter"
    Locate 1,2
    Print "A GCBASIC Demo"
    Wait 2 s

    Do
        CLS
        Print "Light Level: "
        Print ReadAD(LightSensor)
        Wait 250 ms
    Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_put">
<title>Put</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Put <emphasis>Line</emphasis>, <emphasis>Column</emphasis>, <emphasis>Character</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The Put command writes the given ASCII character code to the current location on
the LCD.</simpara>
<simpara><literal>Line</literal> is line number on the LCD display. A byte value from 0 to 255.</simpara>
<simpara><literal>Column</literal> is column number on the LCD display. A byte value from 0 to 255.</simpara>
<simpara><literal>Character</literal> is the requried ASCII code.  A byte value from 0 to 255.</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    'A scrolling star for GCBASIC

    'Misc Settings
    #define SCROLL_DELAY 250 ms

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Main routine
    For StarPos = 0 To 16
        If StarPos = 0 Then
            Put 0, 16, 32
            Put 0, 0, 42
        Else
            Put 0, StarPos - 1, 32
            Put 0, StarPos, 42
        End If
        Wait SCROLL_DELAY
    Next</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_examples">
<title>Examples</title>
<section xml:id="_lcd_io_2_example">
<title>LCD_IO 2 Example</title>
<simpara>This a connection mode 2 Serial Driver to demonstrate LCD features. This for the 16F877A, but, it can easily be adapted for other microcontrollers.</simpara>
<simpara>A 2 by 16 LCD is assumed.</simpara>
<simpara>Based on the works by Thomas Henry and then revised Evan R. Venn</simpara>
<screen>    #chip 16F877A,20

    #define LCD_IO 2
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_DB portb.2
    #define LCD_CB portb.0
    #define LCD_NO_RW
                ;Here are various LCD commands which can be used.
                ;These are the LCD commands for the HD44780 controller

    #define clrHome = 1     ;clear the display, home the cursor
    #define home    = 2     ;home the cursor only
    #define RtoL    = 4     ;print characters right to left
    #define insR    = 5     ;insert characters to right
    #define LtoR    = 6     ;print characters left to right
    #define insL    = 7     ;insert characters to left
    #define lcdOff  = 8     ;LCD screen off
    #define lcdOn   = 12    ;LCD screen on, no cursor
    #define curOff  = 12    ;an alias for the above
    #define block   = 13    ;LCD screen on, block cursor
    #define under   = 14    ;LCD screen on, underline cursor
    #define undblk  = 15    ;LCD screen on, blinking and underline cursor
    #define CLeft   = 16    ;cursor left
    #define CRight  = 20    ;cursor right
    #define panR    = 24    ;pan viewing window right
    #define panL    = 28    ;pan viewing window left
    #define bus4    = 32    ;4-bit data bus mode
    #define bus8    = 48    ;8-bit data bus mode
    #define mode1   = 32    ;one-line mode (alias)
    #define mode2   = 40    ;two-line mode
    #define line1   = 128   ;go to start of line 1
    #define line2   = 192   ;go to start of line 2
    ;----- Variables
    dim char, msn, lsn, index, ii as byte
    ;----- Main Program
    LoadEeprom              ;load the EEprom with strings

    do forever
          printMsg(0)             ;print first message
          wait 3 S                ;pause 3 seconds
          printMsg(2)             ;print next message
          wait 3 S                ;pause 3 seconds
          repeat 5                ;blink it five times
            LCDCmd(lcdOff)       ;display off
            wait 500 mS           ;pause
            LCDCmd(lcdOn)        ;display on
            wait 500 mS           ;pause
          end repeat
          wait 1 S                ;pause before next demo
          ;demonstrate panning
          printMsg(4)             ;print next message
          wait 3 S                ;pause 3 seconds
          repeat 16
            LCDCmd(panL)         ;pan left a step at a time
            wait 300 mS           ;slow down to avoid blur
          end repeat
          repeat 16
            LCDCmd(panR)         ;then pan right
            wait 300 mS
          end repeat
          wait 1 S                ;pause before next demo
                                  ;demonstrate moving the cursor
          printMsg(6)             ;print next message
          wait 3 S                ;pause 3 seconds
          doHome                  ;home cursor
          LCDCmd(under)          ;choose underline cursor
          for ii = 0 to 15         ;move cursor across first line
            LCDCmd(line1+i)
            wait 200 mS
          next i
          for ii = 0 to 15         ;move cursor across second line
            LCDCmd(line2+i)
            wait 200 mS
          next i
          for ii = 15 to 0 step -1 ;move cursor back over second line
            LCDCmd(line2+i)
            wait 200 mS
          next i
          for ii = 15 to 0 step -1 ;move cursor back over first line
            LCDCmd(line1+i)
            wait 200 mS
          next i
          wait 3 S
          ;demonstrate blinking block cursor
          printMsg(8)             ;print next message
          doHome                  ;home the cursor
          LCDCmd(block)          ;choose blinking block cursor
          wait 4 S                ;pause 4 seconds
          LCDCmd(mode1)          ;change to one long line mode
          doHome                  ;home the cursor again
          LCDCmd(curOff)         ;and disable it


          ;demonstrate scrolling a lengthy one-line marquee
          for ii = 0xd0 to 0xff    ;print next message - the remaining EEPROM
            EPread ii, char        ;fetch directly from eeprom
            print chr(char)
          next i
          wait 1 S
          doHome                  ;home cursor once more
          repeat 141              ;scroll message twice
            LCDCmd(panR)
            wait 250 mS
          end repeat
          wait 2 S
          LCDCmd(mode2)          ;change back to two line mode
          doClr                   ;clear the screen
          ;demonstrate all of the characters
          printMsg(11)             ;print next message
          for ii = 33 to 127       ;print first batch of ASCII characters
            LCDCmd(line1+12)     ;overwrite each character displayed
            print chr(ii)            ;this is the ASCII code
            wait 500 mS
          next i
          for ii = 161 to 255      ;print next batch of ASCII characters
            LCDCmd(line1+12)
            print chr(ii)
            wait 500 mS
          next i
          ;say good-bye
          LCDCmd(line2)
          printMsg(11)             ;print next message
          doHome                  ;home the cursor
    loop

    end

    ;----- Clear the screen
    sub doClr
        LCDCmd(clrHome)
        wait 5 mS                   ;this command takes extra time
    end sub

    ;----- Home the cursor
    sub doHome
        LCDCmd(home)
        wait 5 mS                   ;and so does this one
    end sub

    ;----- Print a message to the LCD
    ;The parameter 'row' points to the start of the string.
    sub printMsg(in row as byte, in Optional StringLength As Byte = 15)
        LCDCmd(line1)              ;get set for first line

        for ii = 0 to StringLength
          index = row*16+ii
          EPread index, char        ;fetch next character and
          print chr(char)             ;transmit to the LCD
        next
        LCDCmd(line2)              ;get set for second line
        for ii = 0 to StringLength
          index = (row+1)*16+ii
          EPread index, char        ;fetch next character and
          print chr(char)             ;transmit to the LCD
        next
    end sub

    sub loadEeprom

        ' Strings for EEPROM, Strings should be limited to 16 characters for the first 13 sstrings, then a long string to fill eeprom
        location = 0
        WriteEeprom "First we'll show"
        WriteEeprom "this message.   "
        WriteEeprom "Then we'll blink"
        WriteEeprom "five times.     "
        WriteEeprom "Now lets pan    "
        WriteEeprom "left and right. "
        WriteEeprom "Watch the line  "
        WriteEeprom "cursor move.    "
        WriteEeprom "A block cursor  "
        WriteEeprom "is available.   "
        WriteEeprom "Characters:     "
        WriteEeprom "Bye!            "
        WriteEeprom "in one line mode"
        WriteEeprom "Next well scroll this long message as a marquee"

    end sub

    ; Write to the device eeprom
    sub WriteEeprom ( in Estring() ) as string * 64

        for ee = 1 to len ( Estring )
            HSersend Estring(ee)
            epwrite location, Estring(ee)
            location++
        next

    end sub</screen>
</section>
<section xml:id="_lcd_io_4_example">
<title>LCD_IO 4 Example</title>
<simpara>This is a connection mode 4 Driver to demonstrate LCD features. This for the 16F877A, but, it can easily be adapted for other microcontrollers.</simpara>
<simpara>A 2 by 16 LCD is assumed.</simpara>
<screen>    #chip 16F877A,20

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width

    ;----- Main Program

    do forever

            Print "GCBASIC 2021"
            wait 3 s
            CLS

    loop
    end</screen>
</section>
<section xml:id="_lcd_io_8_example">
<title>LCD_IO 8 Example</title>
<simpara>This is an connection mode 8 Driver to demonstrate LCD features. This for the 16F877A, but, it can easily be adapted for other microcontrollers.</simpara>
<simpara>A 2 by 16 LCD is assumed.</simpara>
<simpara>Based on the works by Thomas Henry and then revised Evan R. Venn</simpara>
<screen>    #chip 16F877A,20


    'Use LCD in 8 pin mode and define LCD pins
    #define LCD_IO 8
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_Data_Port PORTD
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width

    ;Here are various LCD commands which can be used.
    ;These are the LCD commands for the HD44780 controller
    #define clrHome = 1     ;clear the display, home the cursor
    #define home    = 2     ;home the cursor only
    #define RtoL    = 4     ;print characters right to left
    #define insR    = 5     ;insert characters to right
    #define LtoR    = 6     ;print characters left to right
    #define insL    = 7     ;insert characters to left
    #define lcdOff  = 8     ;LCD screen off
    #define lcdOn   = 12    ;LCD screen on, no cursor
    #define curOff  = 12    ;an alias for the above
    #define block   = 13    ;LCD screen on, block cursor
    #define under   = 14    ;LCD screen on, underline cursor
    #define undblk  = 15    ;LCD screen on, blinking and underline cursor
    #define CLeft   = 16    ;cursor left
    #define CRight  = 20    ;cursor right
    #define panR    = 24    ;pan viewing window right
    #define panL    = 28    ;pan viewing window left
    #define bus4    = 32    ;4-bit data bus mode
    #define bus8    = 48    ;8-bit data bus mode
    #define mode1   = 32    ;one-line mode (alias)
    #define mode2   = 40    ;two-line mode
    #define line1   = 128   ;go to start of line 1
    #define line2   = 192   ;go to start of line 2
    ;----- Variables
    dim char, msn, lsn, index, ii as byte
    ;----- Main Program
    LoadEeprom              ;load the EEprom with strings

    do forever
        printMsg(0)             ;print first message
        wait 3 S                ;pause 3 seconds
        printMsg(2)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 5                ;blink it five times
          LCDCmd(lcdOff)       ;display off
          wait 500 mS           ;pause
          LCDCmd(lcdOn)        ;display on
          wait 500 mS           ;pause
        end repeat
        wait 1 S                ;pause before next demo
        ;demonstrate panning
        printMsg(4)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 16
          LCDCmd(panL)         ;pan left a step at a time
          wait 300 mS           ;slow down to avoid blur
        end repeat
        repeat 16
          LCDCmd(panR)         ;then pan right
          wait 300 mS
        end repeat
        wait 1 S                ;pause before next demo
                                ;demonstrate moving the cursor
        printMsg(6)             ;print next message
        wait 3 S                ;pause 3 seconds
        doHome                  ;home cursor
        LCDCmd(under)          ;choose underline cursor
        for ii = 0 to 15         ;move cursor across first line
          LCDCmd(line1+i)
          wait 200 mS
        next i
        for ii = 0 to 15         ;move cursor across second line
          LCDCmd(line2+i)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over second line
          LCDCmd(line2+i)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over first line
          LCDCmd(line1+i)
          wait 200 mS
        next i
        wait 3 S
        ;demonstrate blinking block cursor
        printMsg(8)             ;print next message
        doHome                  ;home the cursor
        LCDCmd(block)          ;choose blinking block cursor
        wait 4 S                ;pause 4 seconds
        LCDCmd(mode1)          ;change to one long line mode
        doHome                  ;home the cursor again
        LCDCmd(curOff)         ;and disable it


        ;demonstrate scrolling a lengthy one-line marquee
        for ii = 0xd0 to 0xff    ;print next message - the remaining EEPROM
          EPread ii, char        ;fetch directly from eeprom
          print chr(char)
        next i
        wait 1 S
        doHome                  ;home cursor once more
        repeat 141              ;scroll message twice
          LCDCmd(panR)
          wait 250 mS
        end repeat
        wait 2 S
        LCDCmd(mode2)          ;change back to two line mode
        doClr                   ;clear the screen
        ;demonstrate all of the characters
        printMsg(11)             ;print next message
        for ii = 33 to 127       ;print first batch of ASCII characters
          LCDCmd(line1+12)     ;overwrite each character displayed
          print chr(ii)            ;this is the ASCII code
          wait 500 mS
        next i
        for ii = 161 to 255      ;print next batch of ASCII characters
          LCDCmd(line1+12)
          print chr(ii)
          wait 500 mS
        next i
        ;say good-bye
        LCDCmd(line2)
        printMsg(11)             ;print next message
        doHome                  ;home the cursor
    loop
    end

    ;----- Clear the screen
    sub doClr
        LCDCmd(clrHome)
        wait 5 mS                   ;this command takes extra time
    end sub

    ;----- Home the cursor
    sub doHome
        LCDCmd(home)
        wait 5 mS                   ;and so does this one
    end sub

    ;----- Print a message to the LCD
    ;The parameter 'row' points to the start of the string.
    sub printMsg(in row as byte, in Optional StringLength As Byte = 15)
          LCDCmd(line1)              ;get set for first line

          for ii = 0 to StringLength
            index = row*16+ii
            EPread index, char        ;fetch next character and
            print chr(char)             ;transmit to the LCD
          next
          LCDCmd(line2)              ;get set for second line
          for ii = 0 to StringLength
            index = (row+1)*16+ii
            EPread index, char        ;fetch next character and
            print chr(char)             ;transmit to the LCD
          next
    end sub

    sub loadEeprom

        ' Strings for EEPROM, Strings should be limited to 16 characters for the first 13 sstrings, then a long string to fill eeprom
        location = 0
        WriteEeprom "First we'll show"
        WriteEeprom "this message.   "
        WriteEeprom "Then we'll blink"
        WriteEeprom "five times.     "
        WriteEeprom "Now lets pan    "
        WriteEeprom "left and right. "
        WriteEeprom "Watch the line  "
        WriteEeprom "cursor move.    "
        WriteEeprom "A block cursor  "
        WriteEeprom "is available.   "
        WriteEeprom "Characters:     "
        WriteEeprom "Bye!            "
        WriteEeprom "in one line mode"
        WriteEeprom "Next well scroll this long message as a marquee"
    end sub


    ; Write to the device eeprom
    sub WriteEeprom ( in Estring() ) as string * 64
        for ee = 1 to len ( Estring )
            HSersend Estring(ee)
            epwrite location, Estring(ee)
            location++
        next
    end sub</screen>
</section>
<section xml:id="_lcd_io_10_example">
<title>LCD_IO 10 Example</title>
<simpara>This is an connection mode 10 I2C Driver to demonstrate LCD features. This for the 16F877A, but, it can easily be adapted for other microcontrollers.</simpara>
<simpara>A 2 by 16 LCD is assumed with the LCD being driven using an LCD I2C adapter.
Two types are supported the YwRobot LCD1602 IIC V1 / a Sainsmart LCD_PIC I2C adapter or the Ywmjkdz I2C adapter with pot bent over top of chip.</simpara>
<simpara>The demonstrates reading a DS18B20 and showing the results on the LCD.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip mega328p, 16
    #include &lt;DS18B20.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings - CHANGE PORTS
     #define I2C_MODE Master
     #define I2C_DATA PORTC.4
     #define I2C_CLOCK PORTC.5
     #define I2C_DISABLE_INTERRUPTS ON

    '''Set up LCD
     #define LCD_IO 10
     #define LCD_I2C_Address_1 0x4E                ; LCD 1
     #define LCD_I2C_Address_2 0x4C                ; LCD 2

    ; ----- Constants
    ' DS18B20 port settings - this is required
       #define DQ PortC.3

    ; ----- Quick Command Reference:

    '''Set LCD_10 to 10 for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter
    '''Set LCD_10 to 12 for the Ywmjkdz I2C adapter with pot bent over top of chip

    ; ----- Variables
    dim TempC_100 as word   ' a variabler to handle the temperature calculations
    dim DSdataRaw as Integer


    ; ----- Main body of program commences here.

    'Change to the correct LCD by setting     LCD_I2C_Address_Current to the correct address then write to LCD.
    LCD_I2C_Address_Current = LCD_I2C_Address_1: DisplayInformation ( 1 )
    LCD_I2C_Address_Current = LCD_I2C_Address_2: DisplayInformation ( 1 )
    wait 4 s
    LCD_I2C_Address_Current = LCD_I2C_Address_1:  CLS
    LCD_I2C_Address_Current = LCD_I2C_Address_2:  CLS

    ccount = 0
    Do forever

        ' The function readtemp12 returns the raw value of the sensor.
        ' The sensor is read as a 12 bit value therefore each unit equates to 0.0625 of a degree
        DSdataRaw = readtemp12    ; save to this variable to prevent the delay bewtween screen up dates
        ' The function readtemp returns the integer value of the sensor
        DSdata = readtemp

        LCD_I2C_Address_Current = LCD_I2C_Address_1: DisplayInformation ( 2 )  ; update LCD1
        LCD_I2C_Address_Current = LCD_I2C_Address_2: DisplayInformation ( 2 )  ; update LCD2
        DSdata = DSdataRaw ; Set the data
        LCD_I2C_Address_Current = LCD_I2C_Address_1: DisplayInformation ( 3 )  ; update LCD1
        DSdata= DSdataRaw ; Set the data
        LCD_I2C_Address_Current = LCD_I2C_Address_2: DisplayInformation ( 3 )  ; update LCD2

        ccount++

        wait 1 s

    loop
    End

    Sub DisplayInformation ( LCDCommand )

        Select case LCDCommand

        Case 1
          CLS
          print "GCBASIC 2021"
          locate 1,0
          print "DS18B20 Demo"

        Case 2
           ' Display the integer value of the sensor on the LCD
           locate 0,0
           print hex(ccount)
           print " Ceil"
           locate 0,8
           print DSdata
           print chr(223)+"C"+"  "

         Case 3

           ' Display the integer and decimal value of the sensor on the LCD

           SignBit = DSdata / 256 / 128
           If SignBit = 0 Then goto Positive
           ' its negative!
           DSdata = ( DSdata # 0xffff ) + 1 ' take twos comp

        Positive:

           ' Convert value * 0.0625. Mulitple value by 6 then add result to multiplication of the value with 25 then divide result by 100.
           TempC_100 =  DSdata * 6
           DSdata = ( DSdata * 25 ) / 100
           TempC_100 = TempC_100 + DSdata

           Whole = TempC_100 / 100
           Fract = TempC_100 % 100
           If SignBit = 0 Then goto DisplayTemp
           Print "-"

        DisplayTemp:
           locate 1,0
           print hex(ccount)
           print " Real"
           locate 1,8
           print str(Whole)
           print "."
          ' To ensure the decimal part is two digits
           Dig = Fract / 10
           print Dig
           Dig = Fract % 10
           print Dig
           print chr(223)
           print "C"+"  "

        End Select

    end sub</screen>
</section>
</section>
</section>
<section xml:id="_pulse_width_modulation">
<title>Pulse width modulation</title>
<simpara>This is the Pulse width modulation section of the Help file.  Please refer the sub-sections for details using the contents/folder view for the MicroChip PIC PWM capabilities and the ATMEL AVR PWM capabilities.</simpara>
<section xml:id="_microchip_pic_pwm_overview">
<title>Microchip PIC PWM Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>The methods described in this section allow the generation of Pulse
Width Modulation (PWM) signals. PWM signals enables the microcontroller to control
items like the speed of a motor, or the brightness of a LED or lamp.<?asciidoc-br?></simpara>
<simpara>The methods can also be used to generate the appropriate frequency signal to drive an
infrared LED for remote control applications.<?asciidoc-br?></simpara>
<simpara>GCBASIC support the four different method shown below:<?asciidoc-br?>
&#160;&#160;&#160; - Two methods use the microcontroller CCP module<?asciidoc-br?>
&#160;&#160;&#160; - One method uses the microcontroller PWM module, and<?asciidoc-br?>
&#160;&#160;&#160; - One method is a software emulation of PWM.<?asciidoc-br?></simpara>
<simpara><emphasis role="strong"><emphasis>Hardware PWM using a CCP module</emphasis></emphasis></simpara>
<simpara>Using PWM with the CCP module:  This option requires a CCP module within the microcontroller.<?asciidoc-br?></simpara>
<simpara>Hardware PWM is only available through the "CCP" or "CCPx" pin. This is a hardware limitation of Microchip PIC microcontrollers.<?asciidoc-br?></simpara>
<simpara>Microcontrollers with PPS can change the pin - use the PPS tool to set the desired output pin.<?asciidoc-br?></simpara>
<simpara>This method uses three parameters to setup the PWM.</simpara>
<screen>    'HPWM channel, frequency, duty cycle
    HPWM 1, 76, 80</screen>
<simpara><emphasis role="strong"><emphasis>Hardware PWM using a PWM module</emphasis></emphasis></simpara>
<simpara>Using microcontroller PWM module.  This option requires a PWM module within the microcontroller
Microcontrollers with PPS can change the pin - use the PPS tool to set the desired output pin.<?asciidoc-br?></simpara>
<simpara>This method uses four parameters to setup the PWM.</simpara>
<screen>    'HPWM channel, frequency, duty cycle, timer
    HPWM 5, 76, 80, 2</screen>
<simpara><emphasis role="strong"><emphasis>Hardware PWM using the CCP1 in fixed mode</emphasis></emphasis></simpara>
<simpara>Using Hardware PWM on fixed mode PWM requires a CCP1 module.</simpara>
<simpara>The fixed mode can use CCP1 only, and, the parameters of the PWM cannot be dynamically changed in the user program.&#160;&#160;&#160;The parameters are fixed by the definition of two constants.</simpara>
<screen>    #define PWM_Freq 76    'Set frequency in KHz
    #define PWM_Duty 80    'Set duty cycle to 80 %

    HPWMOn

    wait 5 s

    HPWMOff</screen>
<simpara><emphasis role="strong"><emphasis>Software PWM</emphasis></emphasis></simpara>
<simpara>Using Software PWM on requires no specific modules with the microcontroller.<?asciidoc-br?></simpara>
<simpara>The PWM parameters for duty and the number of pulses can be changed dynamically in the user program.<?asciidoc-br?></simpara>
<simpara>The PWM is <emphasis role="strong">only</emphasis> operational for the number of cycles stated in the calling method.<?asciidoc-br?></simpara>
<screen>    'A call to use the software PWM on the specific port, with a duty of 127 for 100 cycles

    ; ----- Constants
    'PWM constant. This is a required constant.
    #define PWM_Out1 portb.0

  ; ----- Define Hardware settings
    'PWM port out.  This is not required but a good practice.
    dir PWM_Out1 out

    'Pulse the PWM
    PWMOut 1, 127, 100</screen>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>A number of constants are used to control settings for the PWM hardware module of the microcontroller.
To set them, place a line in the main program file that uses #define to assign a value to the particular
constant.<?asciidoc-br?></simpara>
<section xml:id="_pwm_software_mode">
<title>PWM Software Mode</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PWMOut <emphasis>channel, duty cycle, cycles</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.  This method does NOT require a PWM module within the microcontroller.</simpara>
<simpara>This command uses a software PWM routine within GCBASIC to produce
a PWM signal on the selected port of the chip.</simpara>
<simpara>The method <literal>PWMOut</literal> does not make use of any special hardware within the microcontroller.
The PWM signal is generated only while the <literal>PWMOut</literal> command is executing - therefore, when the <literal>PWMOut</literal> is not executing
by moving onto the next command, the PWM signal will stop.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmout">PWMOut</link></simpara>
<section xml:id="_pwmout">
<title>PWMOut</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PWMOut <emphasis>channel, duty cycle, cycles</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.  This method does NOT require a PWM module within the microcontroller.</simpara>
<simpara>This command uses a software PWM routine within GCBASIC to produce
a PWM signal on the selected port of the chip.</simpara>
<simpara>The method <literal>PWMOut</literal> does not make use of any special hardware within the microcontroller.
The PWM signal is generated only while the <literal>PWMOut</literal> command is executing - therefore, when the <literal>PWMOut</literal> is not executing
by moving onto the next command, the PWM signal will stop.</simpara>
<simpara><emphasis role="strong">Explanation :</emphasis></simpara>
<simpara><literal><emphasis>channel</emphasis></literal> sets the channel that the PWM is to be generated on. This must
have been defined previously by setting the constants <literal>PWM_Out1</literal><?asciidoc-br?></simpara>
<simpara><literal>PWM_Out2</literal>, <literal>PWM_Out3</literal> or <literal>PWM_Out4</literal>. The maximum number of channels available
is 4.<?asciidoc-br?></simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the PWM duty cycle, and ranges from 0 to 255. 255
corresponds to 100%, 127 to 50%, 63 to 25%, and so on.<?asciidoc-br?></simpara>
<simpara><literal><emphasis>cycles</emphasis></literal> is used to set the amount of PWM pulses to supply. This is
useful for situations in which a pulse of a specific length is required.<?asciidoc-br?></simpara>
<simpara>The formula for calculating the time taken for one cycle is:<?asciidoc-br?></simpara>
<screen>    T<subscript>CYCLE</subscript> = (28 + 10C)T<subscript>OSC</subscript>+ (255 * PWM_Delay)</screen>
<simpara>where: <?asciidoc-br?></simpara>
<simpara>&#160;&#160;&#160;-C is the number of channels used<?asciidoc-br?>
&#160;&#160;&#160;-T<subscript>OSC</subscript> is the length of time taken to execute 1 instruction on the chip (0.2 us on a 20 MHz chip, 1
us on a 4 Mhz chip)<?asciidoc-br?>
&#160;&#160;&#160;-PWM_Delay is a length of time specified using the <literal>PWM_Delay</literal> constant<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example 1 :</emphasis></simpara>
<screen>    'This program controls the brightness of an LED on PORTB.0
    'using the software PWM routine and a potentiometer.
    #chip 16f877a, 20

    ; ----- Constants
    'PWM constant. This is a required constant.
    #define PWM_Out1 portb.0

    ; ---- Optional Constant to add an delay after PWM pulse
    ''#Define PWM_Delay 1 us


    ; ----- Define Hardware settings
    'PWM port out.  This is not required but good practice.
    dir PWM_Out1 out

    'A potentiometer is attached to ANO

    ; ----- Variables
    ' No Variables specified in this example.

    ; ----- Main body of program commences here.
      do
          '100 cycles is a purely arbitrary value as the loop will maintain a relatively constant PWM
          PWMOut 1, ReadAD(AN0), 100
      loop

end</screen>
<simpara><emphasis role="strong">Example 2 :</emphasis></simpara>
<screen>    'This program controls the brightness of an LED on gpio.1
    'using the software PWM routine and a potentiometer.
    #chip 12f675, 4

    ; ----- Constants
      'PWM constant. This is a required constant.
      #define PWM_Out1 gpio.1

    ; ----- Define Hardware settings
      'PWM port out.  This is not required but good practice.
      dir PWM_Out1 out

      'A potentiometer is attached to ANO

    ; ----- Variables
      ' No Variables specified in this example.

    ; ----- Main body of program commences here.
        do
          '100 cycles is a purely arbitrary value
            PWMOut 1, ReadAD(AN0), 100
        loop
    end</screen>
</section>
</section>
<section xml:id="_hpwm_ccp">
<title>HPWM CCP</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWM <emphasis>channel, frequency, duty cycle</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available on Microchip PIC microcontrollers with Capture/Compare/PWM (CCP)
module.</simpara>
<simpara>This command supports the CCP 8 bit support with <emphasis role="strong">Timer 2 only</emphasis>.<?asciidoc-br?></simpara>
<simpara>For CCP/PWM support for timers 2, 4 and 6, if the specific devices supports alternative CCP/PWM clock sources - see here <link linkend="_hpwm_ccptimern">HPWM_CCPTimerN</link></simpara>
<simpara>For PWM 10 Bit support with other timers - see here <link linkend="_hpwm_10_bit">HPWM 10 Bit</link></simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle.<?asciidoc-br?></simpara>
<simpara>If you only need one particular frequency and duty cycle, you should use PWMOn and
the constants PWM_Freq and PWM_Duty instead.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is 1, 2, 3, 4 or 5, and corresponds to the pins CCP1, CCP2, CCP3, CCP4 and CCP5
respectively. On chips with only one CCP port, pin CCP or CCP1 is always
used, and <literal><emphasis>channel</emphasis></literal> is ignored. (It should be set to 1 anyway to allow
for future upgrades to more powerful microcontrollers.)</simpara>
<simpara><literal><emphasis>frequency</emphasis></literal> sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 255 KHz. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller (ie 40 Khz on
a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the best duty cycle
resolution possible.</simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 255 where 255 is 100% duty cycle.</simpara>
<simpara>To stop the PWM signal use the <literal>HPWMOff</literal> method with the parameter of the channel.</simpara>
<screen>    'Stop the CCP/PWM signal
    HPWMOff ( 1 )</screen>
<simpara>The optional constant <literal>HPWM_FAST</literal> can be defined to enable the recalculation of the
timer prescaler when needed.  This will provide faster operation, but uses extra byte
of RAM and may cause problems if <literal>HPWM</literal> and <literal>PWMOn</literal> are used together in a program.
This will not cause any issue when using <literal>HPWM</literal> and <literal>PWMOff</literal> in the same program with <literal>HPWM_FAST</literal>.</simpara>
<simpara>The optional constant <literal>DisableCCPFixedModePWM</literal> can be defined to prevent Timer2 from being enabled.  This constant may be required when you need to use Timer2 for non-CCP/PWM support.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will alter the brightness of an LED using
    'CCP/PWM.

    'Select chip model and speed
    #chip 16F877A, 20

    'Set the CCP1 pin to output mode
    DIR PORTC.2 out

    'Main code
    do
        'Turn up brightness over the range
        For Bright = 1 to 255
            HPWM 1, 40, Bright
            wait 10 ms
        next
        'Turn down brightness over the range
        For Bright = 255 to 1 Step -1
            HPWM 1, 40, Bright
            wait 10 ms
        next
    loop</screen>
<section xml:id="_hpwmupdate_for_ccp_pwm_modules_s">
<title>HPWMUpdate for CCP/PWM Modules(s)</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWMUpdate ( channel, duty_cycle )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC microcontrollers with the CCP module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command updates the <emphasis role="strong">duty cycle only</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>You <emphasis role="strong">MUST</emphasis> have previously called the HPWM CCP command using the full command to set the channel specific settings for frequency and timer source.&#160;&#160;See the example below for the usage.</simpara>
</listitem>
<listitem>
<simpara>You <emphasis role="strong">MUST</emphasis> specify the constant #define <literal>HPWM_FAST</literal> to support HPWMUpdate when using CCP module.</simpara>
</listitem>
</itemizedlist>
<simpara>This command only supports the previously called HPWM CCP command, or, if you have set more than one HPWM CCP channel then to use the command you must have set the channel to the same frequency.</simpara>
<simpara>The command only supports the CCP module of the Microchip PIC microcontroller to generate
a PWM waveform at the previously defined frequency and timer source.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is 1, 2, 3, 4 or  5. These corresponds to the CCP1 through to CCP5 respectively.&#160;&#160;The channel <emphasis role="strong">MUST</emphasis> be supported by the microcontroller.&#160;&#160;&#160;Check the microcontroller specific datasheet for the available channel.</simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 255 where 255 is 100% duty cycle.</simpara>
<simpara><emphasis role="strong">Example for CCP PWM:</emphasis></simpara>
<screen>    'This program will alter the brightness of an LED using
    'hardware PWM.

    #chip 16F1938
    #option Explicit

    'Set the direction of the CCP/PWM port
    DIR portc.2 Out

    #define HPWM_FAST           'Required to support HPWMUpdate when using CCP module
    HPWM 1, 40, dutyvalue

    do
        'use for-loop to show the duty changing a 8bit value
        dim dutyvalue as byte
        for dutyvalue = 0 to 255
            HPWMUpdate 1, dutyvalue
            wait 10 ms
        next
        for dutyvalue = 254 to 1
            HPWMUpdate 1, dutyvalue
            wait 10 ms
        next
    loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmoff">PWMOff</link></simpara>
</section>
<section xml:id="_hpwmoff">
<title>HPWMOff</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWMOff ( channel )   'selectively turn off the CCP channel

    HPWMOff               'turn off CCP channel 1 only</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available on Microchip PIC microcontrollers with Capture&amp;Compare/PWM (CCP) modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will disable the output of the CCP1/PWM module on the Microchip PIC chip.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Select chip model and speed
    #chip 16F877A, 20

    'Set the CCP1 pin to output mode
    DIR PORTC.2 out

    'Main code
    do
        'Turn up brightness over 2.5 seconds
        For Bright = 1 to 255
            HPWM 1, 40, Bright
            wait 10 ms
        next

        wait 1 s
        HPWMOff ( 1 )' turn off the PWM channel

    loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_hpwmoff">HPWMOff</link></simpara>
</section>
</section>
<section xml:id="_hpwm_ccptimern">
<title>HPWM_CCPTimerN</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWM_CCPTimerN <emphasis>channel</emphasis>, <emphasis>frequency</emphasis>, <emphasis>duty cycle</emphasis> [, <emphasis>timer</emphasis> 2, 4 or 6 ]</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available on Microchip PIC microcontrollers with Capture/Compare/PWM (CCP)
module.</simpara>
<simpara>This command supports the CCP 8 bit support with selectable <emphasis role="strong">Timer 2, 4 or 6 only</emphasis> for CCP/PWM only.<?asciidoc-br?></simpara>
<simpara>For CCP/PWM support for timers 2 only see <link linkend="_hpwm_ccp">HPWM CCPTimer</link></simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle.<?asciidoc-br?></simpara>
<simpara>If you only need one particular frequency and duty cycle, you should use PWMOn and
the constants PWM_Freq and PWM_Duty instead.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is 1, 2, 3, 4 or 5, and corresponds to the pins CCP1, CCP2, CCP3, CCP4 and CCP5
respectively. On chips with only one CCP port, pin CCP or CCP1 is always
used, and <literal><emphasis>channel</emphasis></literal> is ignored. (It should be set to 1 anyway to allow
for future upgrades to more powerful microcontrollers.)</simpara>
<simpara><literal><emphasis>frequency</emphasis></literal> sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 255 KHz. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller (ie 40 Khz on
a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the best duty cycle
resolution possible.</simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 255 where 255 is 100% duty cycle.</simpara>
<simpara><literal>timer</literal> specifies the timer source. Timers 2, 4 and 6 are supported.</simpara>
<simpara>To stop the PWM signal use the <literal>HPWMOff</literal> method with the parameter of the channel.</simpara>
<screen>    'Stop the CCP/PWM signal
    HPWMOff ( 1 )</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 16F1825, 4

    DIR portc Out
    DIR porta Out

    initialisation:

    'Command as follows:
    ' HPWM_CCPTimerN   CCP_Channel, Frequency, Duty, Timer Source.  Timer source defaults to timer 2, so, the timersource is optional.

    HPWM_CCPTimerN  3, 30, 77 , 4         'CCP/PWM module 3 using timer 4
    HPWM_CCPTimerN  4, 40, 102, 6         'CCP/PWM module 4 using timer 6
    HPWM  1, 10, 26                       'CCP/PWM module 1 with no parameter therefore timer 2

    do
    loop</screen>
<section xml:id="_hpwmoff_2">
<title>HPWMOff</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWMOff ( channel )   'selectively turn off the CCP channel

    HPWMOff               'turn off CCP channel 1 only</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available on Microchip PIC microcontrollers with Capture&amp;Compare/PWM (CCP) modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will disable the output of the CCP1/PWM module on the Microchip PIC chip.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Select chip model and speed
    #chip 16F877A, 20

    'Set the CCP1 pin to output mode
    DIR PORTC.2 out

    'Main code
    do
        'Turn up brightness over 2.5 seconds
        For Bright = 1 to 255
            HPWM 1, 40, Bright
            wait 10 ms
        next

        wait 1 s
        HPWMOff ( 1 )' turn off the PWM channel

    loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_hpwmoff">HPWMOff</link></simpara>
</section>
</section>
<section xml:id="_hpwm_10_bit">
<title>HPWM 10 Bit</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWM <emphasis>channel, frequency, duty cycle, timer [, resolution]</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara><emphasis role="strong">Only</emphasis> available on Microchip PIC microcontrollers with the 10-bit PWM module.</simpara>
<simpara>For the Capture/Compare/PWM (CCP) module, see here <link linkend="_hpwm_ccp">HPWM CCP</link></simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle. Once this command
is called, the PWM will be emitted until PWMOff is called.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is 1, 2, 3, 4, 5, 6, 7 or 8. These corresponds to the HPWM1 through to HPWM8 respectively.<?asciidoc-br?>
The 10-bit PWM channel <emphasis role="strong">MUST</emphasis> be supported by the microcontroller.   Check the microcontroller specific datasheet for the available channel.</simpara>
<simpara><literal><emphasis>frequency</emphasis></literal> sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 255 KHz. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller (ie 40 Khz on
a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the best duty cycle
resolution possible.</simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 1023 where 1023 is 100% duty cycle.&#160;&#160;&#160; This should be a WORD value. &#160;&#160;&#160;Note: Byte values are supported as a Byte value is factorised to a Word value. To use a Byte value and to ensure the 10-bit resolution you should cast the parameter as a Word, [WORD]byte_value or  [WORD]constant_value</simpara>
<simpara><literal><emphasis>timer</emphasis></literal> specifies the desired timer to be used. These can be timer 2, 4 or 6.</simpara>
<simpara>Optional <literal><emphasis>resolution</emphasis></literal> specifies the desired resolution to be used. These can be either 255 or 1023.  The rational of this optional parameter is to support the duty cycle with a BYTE or a WORD range.  If you call the method with a WORD the resolution will be set to 1023.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Notes:</emphasis></simpara>
<simpara>PWM channels 1 and 2 are disable by default.&#160;&#160;You must enable using the constants USE_HPWMn where n is the PWM channel you want to enable.&#160;&#160;You can disable any PWM channel by setting the appropiatge change to FALSE.</simpara>
<simpara>On some microcontrollers you may need to set the port.pin as an output for PWM to operated as desired.
<?asciidoc-br?></simpara>
<screen>        #define USE_HPWM1 TRUE
        #define USE_HPWM2 TRUE</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F18855, 32

    'Generated by PIC PPS Tool for GCBASIC
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM6
            RA2PPS = 0x000E    'PWM6OUT &gt; RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    dim Bright as word

    'Main code
    do
        'Turn up brightness over the range
        For Bright = 0 to 1023
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
        'Turn down brightness over the range
        For Bright = 1023 to 0 Step -1
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
    loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F1705, 32

    'Generated by PIC PPS Tool for GCBASIC
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM3
            RA2PPS = 0x000E    'PWM3OUT &gt; RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    dim Bright as word

    'Main code
    do
        'Turn up brightness over the range
        For Bright = 0 to 1023
            HPWM 3, 40, Bright, 2
            wait 10 ms
        next
        'Turn down brightness over the range
        For Bright = 1023 to 0 Step -1
            HPWM 3, 40, Bright, 2
            wait 10 ms
        next
    loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmoff">PWMOff</link></simpara>
<section xml:id="_hpwmupdate_for_pwm_module_s">
<title>HPWMUpdate for PWM Module(s)</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWMUpdate ( channel, duty_cycle )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC microcontrollers with the PWM module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command updates the <emphasis role="strong">duty cycle only</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>You <emphasis role="strong">MUST</emphasis> have previously called the HPWM 10 Bit command using the full command (see <link linkend="_hpwm_10_bit">HPWM 10 Bit</link>) to set the channel specific settings for frequency and timer source.&#160;&#160;See the example below for the usage.</simpara>
</listitem>
<listitem>
<simpara>You <emphasis role="strong">MUST</emphasis> have previously called the HPWM 10 Bit command with the same type of variable, or, use casting to ensure the variable tpye is the same type.</simpara>
</listitem>
</itemizedlist>
<simpara>This command only supports the previously called HPWM 10 Bit command, or, if you have set more than one HPWM 10 Bit PWM channel then to use the command you must have set the channel to the same frequency.</simpara>
<simpara>The command only supports the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform at the previously defined frequency and timer source.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is 1, 2, 3, 4, 5, 6, 7 or 8. These corresponds to the HPWM1 through to HPWM8 respectively.&#160;&#160;The channel <emphasis role="strong">MUST</emphasis> be supported by the microcontroller.&#160;&#160;&#160;Check the microcontroller specific datasheet for the available channel.</simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 1023 where 1023 is 100% duty cycle.</simpara>
<simpara><emphasis role="strong">Example for Hardware PWM:</emphasis></simpara>
<screen>    'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F18855, 32

    'Generated by PIC PPS Tool for GCBASIC
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM6
            RA2PPS = 0x000E    'PWM6OUT &gt; RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    'Setup PWM - this is mandated as this specifies the frequency and the clock source.
    'Uses casting [word] to ensure the intialisation value of Zero (0) is a treated as a word.  The variable type MUST match the HPWMUpdate variable type.
    HPWM 6, 40, [word]0, 2
    'Main code
    do
        'Turn up brightness over 2.5 seconds
        For Bright = 0 to 1023
            HPWMUpdate 6, Bright
            wait 10 ms
        next
        'Turn down brightness over 2.5 seconds
        For Bright = 1023 to 0 Step -1
            HPWMUpdate 6, Bright
            wait 10 ms
        next
    loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmoff">PWMOff</link>, <link linkend="_hpwm_10_bit">HPWM 10 Bit</link></simpara>
</section>
<section xml:id="_hpwmoff_3">
<title>HPWMOff</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWMOff ( channel, PWMHardware )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available on Microchip PIC microcontrollers with PWM modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will disable the output of the PWM module on the Microchip PIC chip.<?asciidoc-br?></simpara>
<simpara><literal>PWMHardware</literal> is a GCBASIC defined constant not a user vaariable.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen> 'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F18855, 32

    'Generated by PIC PPS Tool for GCBASIC
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM6
            RA2PPS = 0x000E    'PWM6OUT &gt; RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    'Main code
    For ForLoop = 1 to 4
        'Turn up brightness over 2.5 seconds
        For Bright = 1 to 255
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
        'Turn down brightness over 2.5 seconds
        For Bright = 255 to 1 Step -1
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
    next

    HPWMOff 6, PWMHardware   'where PWMHardware is the defined constant or you can use TRUE</screen>
</section>
</section>
<section xml:id="_hpwm_16_bit">
<title>HPWM 16 Bit</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWM16 <emphasis>channel, frequency, duty cycle</emphasis>    'Enable a 16-bit PWM channel'

    HPWM16On <emphasis>channel</emphasis>                         'Enable a specific PWM channel using parameters set by the HPWM16 method'

    HPWM16Off <emphasis>channel</emphasis>                        'Disable a specific PWM channel'</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara><emphasis role="strong">Only</emphasis> available on Microchip PIC microcontrollers with the 16-bit PWM module.  16-bit PWM support includes both dynamic mode and fixed mode operations. See the examples below for usage.</simpara>
<simpara>The PIC microcontroller chip specific DAT file must contain <literal>CHIPPWM16TYPE = 1</literal>.&#160;&#160;
If the chip specific DAT does not contain <literal>CHIPPWM16TYPE = 1</literal> and the microcontroller does support PWM 16 Bit please report the omission to GCBASIC the support forum.&#160;&#160;</simpara>
<simpara>For the Capture/Compare/PWM (CCP) module or the 10-bit PWM module, see the other sections of the Help.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle. Once this command
is called, the PWM will be emitted until HPWM16Off method is called.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is 1, 2, 3.. 12. These corresponds to the 16-bit PWM channel respectively.<?asciidoc-br?>
The 16-bit PWM channel <emphasis role="strong">MUST</emphasis> be supported by the microcontroller.   Check the microcontroller specific datasheet for the available channel.</simpara>
<simpara><literal><emphasis>frequency</emphasis></literal> sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 0xFFFF. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller (ie 40 Khz on
a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the best duty cycle
resolution possible.</simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 0xFFFF where 0xFFFF is 100% duty cycle.&#160;&#160;&#160; This should be a WORD value.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    ' This program will enable dynamic mode PWM signals
    '
    ' All the 12 PWM16 channels can configured at separate dynamic frequencies  dynamic duty, the syntax is:
    '
    ' HPWM16(xx, frequency, duty )
    '
    ' xx can be 1 through 12, for this specific microcontroller there are three PWM16 channels.
    '
    ' To set the parameters of GCBASIC PWM fixed mode for the channels use the commands shown below::

        #chip 12F1572, 32
        #config mclr=on

        Dir PORTA Out

        HPWM16(1, 30, 16384)   '30 kHz, 25% duty cycle (16384/65535)
        HPWM16(2, 30, 16384)   '30 kHz, 25% duty cycle (16384/65535)
        HPWM16(3, 30, 16384)   '30 kHz, 25% duty cycle (16384/65535)


        do Forever
        loop


        #define USE_HPWM16_1 TRUE
        #define USE_HPWM16_2 TRUE
        #define USE_HPWM16_3 TRUE
        #define USE_HPWM16_4 FALSE
        #define USE_HPWM16_5 FALSE
        #define USE_HPWM16_6 FALSE
        #define USE_HPWM16_7 FALSE
        #define USE_HPWM16_8 FALSE
        #define USE_HPWM16_9 FALSE
        #define USE_HPWM16_10 FALSE
        #define USE_HPWM16_11 FALSE
        #define USE_HPWM16_12 FALSE</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The 16-bit library also supports fixed mode PWM operations.  The following two examples show the constants and the commands to control 16-bit PWM Fixed Mode operations.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    ' This program will enable fix mode PWM signals
    '
    ' All the 12 PWM16 channels can configured at separate fixed frequencies and fixed duty, the syntax is:
    '
    ' #define HPWM16_xx_Freq 38     'Set frequency in KHz on channel xx
    ' #define HPWM16_xx_Duty 50     'Set duty cycle to 50%  on channel xx
    '
    ' xx can be 1 through 12
    '
    ' To set the parameters of GCBASIC PWM fixed mode on channel 1 use the following:
    '
    '    #define HPWM16_1_Freq 0.1 to &gt; 1000         'Set the frequency, but, the clock speed must be low for low PWM frequency
    '    #define HPWM16_1_Duty 0.1 to 100            'Set duty cycle as percentage 0-100%, just change the number
    '


        #chip 12F1572, 32
        #config mclr=on

        Dir PORTA Out

        #define HPWM16_1_Freq 400         '800Hz to greater than 1mhz... greater than 1mhz at a clock speed of 32hz provides a clipped square wave.
        #define HPWM16_1_Duty 50
        HPWM16On ( 1 )

        do Forever
        loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 3:</emphasis></simpara>
<screen>    ' This program will enable fix mode PWM signals
    '
    ' All the 12 PWM16 channels can configured at separate fixed frequencies and fixed duty, the syntax is:
    '
    ' #define HPWM16_xx_Freq 38     'Set frequency in KHz on channel xx
    ' #define HPWM16_xx_Duty 50     'Set duty cycle to 50%  on channel xx
    '
    ' xx can be 1 through 12, for this specific microcontroller there are three PWM16 channels.
    '
    ' To set the parameters of GCBASIC PWM fixed mode for the three channels use the following:

        #chip 12F1572, 32
        #config mclr=on

        Dir PORTA Out

        #define HPWM16_1_Freq 100         '100khz
        #define HPWM16_1_Duty 40          '40% duty
        HPWM16On ( 1 )

        #define HPWM16_2_Freq 200         '200khz
        #define HPWM16_2_Duty 50          '50% duty
        HPWM16On ( 2 )

        #define HPWM16_3_Freq 300         '300khz
        #define HPWM16_3_Duty 60          '60% duty
        HPWM16On ( 3 )

        do Forever
        loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmoff">PWMOff</link></simpara>
</section>
<section xml:id="_hpwm_fixed_mode">
<title>HPWM Fixed Mode</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PWMOn               'only applies to CCP/PWM channel 1
    'or
    PWMOff

    PWMOn( channel )            'where the parameter can be any valid CCP/PWM channel, 1, 2, 3, 4 or 5
    'or
    PWMOff( channel )

    PWMOn( module_number , <literal>PWMModule</literal>)            'where the parameter can be any valid PWM channel 1 .. 9
    'or
    PWMOff( module_number , <literal>PWMModule</literal>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara><emphasis role="strong">Only</emphasis> available on Microchip PIC microcontrollers with a CCP/PWM or PWM module.</simpara>
<simpara>See here <link linkend="_hpwm_ccp">HPWM CCP</link> for the method to change PWM parameters dynamically or to use other CCP channels - this method support  CCP1/PWM, CCP2/PWM, CCP3/PWM, CCP4/PWM and CCP5/PWM.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle. &#160;&#160;Once this command
is called, the PWM will be emitted until PWMOff is called.</simpara>
<simpara>These constants are required to set the parameters for the PWM.  The frequency and the duty applies to all channels when using the method(s) or macro(s) shown above.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>PWM_Freq</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output frequency of the PWM module in KHz.</simpara></entry>
<entry align="left" valign="top"><simpara>38</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PWM_Duty</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the duty cycle of the PWM module output. Given as percentage.</simpara></entry>
<entry align="left" valign="top"><simpara>50</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
For CCP/PWM modules are also supported using a call to a method or a macro, as follows:
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Method/Macro</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>PWMOn</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter enables CCP1/PWM only</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PWMOff</simpara></entry>
<entry align="left" valign="top"><simpara>Disables CCP1/PWM only</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PWMOn( <literal>channel</literal> )</simpara></entry>
<entry align="left" valign="top"><simpara>Where the parameter is any valid CCP/PWM channel</simpara></entry>
<entry align="left" valign="top"><simpara><literal>channel</literal> can be 1, 2, 3, 4 or 5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PWMOff( <literal>channel</literal> )</simpara></entry>
<entry align="left" valign="top"><simpara>Where the parameter is any valid CCP/PWM channel</simpara></entry>
<entry align="left" valign="top"><simpara><literal>channel</literal> can be 1, 2, 3, 4 or 5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PWMOn( <literal>module</literal>, PWMMODULE )</simpara></entry>
<entry align="left" valign="top"><simpara>Where the parameter is any valid PWM module</simpara></entry>
<entry align="left" valign="top"><simpara><literal>module</literal> can be 1..9
<?asciidoc-br?>
 See the example below for the constants to control fixed mode PWM using PWM modules.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PWMOff( <literal>channel</literal>, PWMMODULE )</simpara></entry>
<entry align="left" valign="top"><simpara>Where the parameter is any valid CCP/PWM module</simpara></entry>
<entry align="left" valign="top"><simpara><literal>module</literal> can be 1..9</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Fixed Mode PWM for PWM Modules.</emphasis></simpara>
<simpara>To set the Fixed Mode PWM for PWM Modules you need to set a timer frequency, a PWM module cycle and the PWM model source clock.</simpara>
<simpara>The options for source clock are shown below.    These are the PWM timers supported by the PWM modules, where <literal>nn</literal> is the frequency.</simpara>
<screen>    PWM_Timer2_Freq `nn` or
    PWM_Timer4_Freq `nn` or
    PWM_Timer6_Freq `nn`.</screen>
<simpara>The PWM module duty is set using PWM_`yy`_Duty <literal>xx' where `yy</literal> is between 1 and 9 and is a valid PWM module, and, <literal>xx</literal> is the Duty cycle for specific channels</simpara>
<screen>    #define PWM_yy_Duty xx</screen>
<simpara>The PMW module clock source us PWM_`zz`_Clock_Source <literal>tt</literal>.  Where <literal>zz</literal> is channel and <literal>tt</literal> is the PWM clock source.</simpara>
<screen>    #define PMW_zz_Clock_Source tt</screen>
<simpara>You do not need to define all the timers and or all the channels, just define the constants you need.</simpara>
<simpara>The minimum is
    A timer with a frequency
    A PWM channel with a duty
    A PWM channel clock source</simpara>
<simpara>Example: For PWM channel 6 with a frequency of 38Khz with a duty of 50% with a clock source of timer 2, use</simpara>
<screen>        #define PWM_Timer2_Freq 38
        #define PWM_7_Duty 50
        #define PMW_7_Clock_Source 6</screen>
<simpara>Details of the constants with  example parameters.</simpara>
<literallayout class="monospaced">#define PWM_Timer2_Freq 20        'Set frequency in KHz, just change the number
#define PWM_Timer4_Freq 40        'Set frequency in KHz, just change the number
#define PWM_Timer6_Freq 60        'Set frequency in KHz, just change the number</literallayout>
<simpara>Supported PWM modules, with example parameters.</simpara>
<literallayout class="monospaced">#define PWM_1_Duty 10            'Set duty cycle as percentage 0-100%, just change the number
#define PMW_1_Clock_Source 2</literallayout>
<literallayout class="monospaced">#define PWM_2_Duty 20
#define PMW_2_Clock_Source 4</literallayout>
<literallayout class="monospaced">#define PWM_3_Duty 30
#define PMW_3_Clock_Source 6</literallayout>
<literallayout class="monospaced">#define PWM_4_Duty 40
#define PMW_4_Clock_Source 2</literallayout>
<literallayout class="monospaced">#define PWM_5_Duty 50
#define PMW_5_Clock_Source 6</literallayout>
<literallayout class="monospaced">#define PWM_6_Duty 60
#define PMW_6_Clock_Source 6</literallayout>
<literallayout class="monospaced">#define PWM_7_Duty 70
#define PMW_7_Clock_Source 4</literallayout>
<literallayout class="monospaced">#define PWM_8_Duty 80
#define PMW_8_Clock_Source 4</literallayout>
<literallayout class="monospaced">#define PWM_9_Duty 90
#define PMW_9_Clock_Source 6</literallayout>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example #1:</emphasis></simpara>
<simpara>Enable CCP1/PWM channel only.  This is the legacy command.</simpara>
<screen>    #chip 16f877a,20

    'Set the PWM pin to output mode
    DIR PORTC.2 out

    'Main code

    #define PWM_Freq 38      'Frequency of PWM in KHz
    #define PWM_Duty 50      'Duty cycle of PWM (%)

    PWMOn    'Will enable CCP1/PWM Only

    wait 10 s                'Wait 10 s

    PWMOff   'Will disable CCP1/PWM Only

    do
    loop</screen>
<simpara><?asciidoc-br?>
<emphasis role="strong">Example #2:</emphasis></simpara>
<simpara>Enable any CCP/PWM channel using a call to a method.</simpara>
<screen>    #chip 16f877a,20

    'Set the PWM pin to output mode
    DIR PORTC.2 out

    'Main code

    #define PWM_Freq 38      'Frequency of PWM in KHz
    #define PWM_Duty 50      'Duty cycle of PWM (%)

    PWMOn (2)    'Will enable any valid CCP/PWM channel

    wait 10 s                'Wait 10 s

    PWMOff (2)   'Will disable any valid CCP/PWM channel

    do
    loop</screen>
<simpara><?asciidoc-br?>
Example #3:*</simpara>
<simpara>Enable any PWM module using a PWM specific method.</simpara>
<screen>    'A real simple and easy PWM setup for 8 and 10 bit PWM channels
        #chip 18f25k42, 16

        #startup InitPPS, 85

        Sub InitPPS

                'Module: PWM5
                RA0PPS = 0x000D    'PWM5 &gt; RA0
                'Module: PWM6
                RA1PPS = 0x000E    'PWM6 &gt; RA1
                'Module: PWM7
                RA2PPS = 0x000F    'PWM7 &gt; RA2
                'Module: PWM8
                RA3PPS = 0x0010    'PWM8 &gt; RA3

        End Sub

        'Template comment at the end of the config file
        dir porta Out
        dir portb Out
        dir portc Out

    'This is the setup section for fixed mode PWM

        'The only options are PWM_Timer2_Freq nn|PWM_Timer4_Freq nn|PWM_Timer6_Freq nn. These are the PWM timers
        'The PWM_yy_Duty xx' where yy is between 1 and 9 and is a valid PWM module, and, xx is the Duty cycle for specific channels
        'The PMW_zz_Clock_Source tt.  Where zz is channel and tt is the PWM clock source.
        'You do not need to define all the timers and channels, just define the constants you need.
        'The minimum is
        '   A timer with a frequency
        '   A PWM channel with a duty
        '   A PWM channel clock source
        '   For PWM channel 2 with a frequency of 38Khz with a duty of 50% with a clock source of timer 2, use
        '     #define PWM_Timer2_Freq 38
        '     #define PWM_7_Duty 50
        '     #define PMW_7_Clock_Source 2

        #define PWM_Timer2_Freq 20        'Set frequency in KHz, just change the number
        #define PWM_Timer4_Freq 40        'Set frequency in KHz, just change the number
        #define PWM_Timer6_Freq 60        'Set frequency in KHz, just change the number


      '    Supported PWM module but not by this specific microcontroller
      '
      '    #define PWM_1_Duty 10            'Set duty cycle as percentage 0-100%, just change the number
      '    #define PMW_1_Clock_Source 2
      '
      '    #define PWM_2_Duty 20
      '    #define PMW_2_Clock_Source 4
      '
      '    #define PWM_3_Duty 30
      '    #define PMW_3_Clock_Source 6
      '
      '    #define PWM_4_Duty 40
      '    #define PMW_4_Clock_Source 2

        #define PWM_5_Duty 50
        #define PMW_5_Clock_Source 6

        #define PWM_6_Duty 60
        #define PMW_6_Clock_Source 6

        #define PWM_7_Duty 70
        #define PMW_7_Clock_Source 4

        #define PWM_8_Duty 80
        #define PMW_8_Clock_Source 4

        '    Supported PWM module but not by this specific microcontroller
        '
        '    #define PWM_9_Duty 90
        '    #define PMW_9_Clock_Source 6


        '   Enable module 7
        HPWMOn ( 7, PWMModule )
        wait 2 s
        '   Disable channel 7
        HPWMOff ( 7, PWMModule)
        '    wait 2 s

        '   Enable others module
        HPWMOn ( 5, PWMModule )
        HPWMOn ( 6, PWMModule )
        HPWMOn ( 7, PWMModule )
        HPWMOn ( 8, PWMModule )

        '  Enable CCP/PWM channel 1  - uses constants FREQ and DUTY
        PWMOn

        '  Enable CCP/PWM channel 2
        PWMOn ( 2 )
        do
        loop

    End</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmon">PWMOn</link> and <link linkend="_pwmoff">PWMOff</link> <emphasis role="strong">or, for AVR see</emphasis> <link linkend="_hpwm_fixed_mode_for_avr">Fixed Mode PWM for AVR</link></simpara>
<section xml:id="_pwmon">
<title>PWMOn</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PWMOn</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available on Microchip PIC microcontrollers with Capture/Compare/PWM
module CCP1.</simpara>
<simpara>This command does not operate on any other CCP channel.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<simpara>This command will enable the output of the CCP1/PWM module on the Microchip PIC microcontroller.</simpara>
<screen>    'This program will enable a 76 Khz PWM signal, with a duty cycle
    'of 80%. It will emit the signal for 10 seconds, then stop.
    #define PWM_Freq 76    'Set frequency in KHz
    #define PWM_Duty 80    'Set duty cycle to 80 %
    PWMOn                  'Turn on the PWM
    WAIT 10 s              'Wait 10 seconds
    PWMOff                 'Turn off the PWM</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<simpara>This command will enable the output of the CCP1/PWM module on the Microchip PIC microcontroller.</simpara>
<simpara>Note the chip frequency.</simpara>
<screen>    'This program will enable a 62Hz PWM signal, with a duty cycle
    'of 50%.


    #Chip 12F1840, 1

    dir porta.2 out
    #define PWM_Freq .0625    'Set frequency in Hz equates to 62Hz
    #define PWM_Duty 50       'Set duty cycle to 80 %
    PWMON

    Do
    loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 3:</emphasis></simpara>
<simpara>This command will enable the output of the CCP1/PWM module on the Microchip PIC microcontroller.</simpara>
<simpara>Note the chip frequency.</simpara>
<screen>    'This program will enable a 7.7Hz PWM signal, with a duty cycle
    'of 50%.


    #Chip 12F1840, 0.125

    dir porta.2 out
    #define PWM_Freq .0077   'Set frequency in Hz equates to 7.7Hz
    #define PWM_Duty 50       'Set duty cycle to 50 %
    PWMON

    Do
    loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, also see</emphasis> <link linkend="_pwmoff">PWMOff</link></simpara>
</section>
<section xml:id="_pwmoff">
<title>PWMOff</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PWMOff</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available on Microchip PIC microcontrollers with Capture/Compare/PWM
module CCP1.</simpara>
<simpara>This command does not operate on any other CCP channel.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will disable the output of the CCP1/PWM module on the Microchip PIC chip.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will enable a 76 Khz PWM signal, with a duty cycle
    'of 80%. It will emit the signal for 10 seconds, then stop.
    #define PWM_Freq 76    'Set frequency in KHz
    #define PWM_Duty 80    'Set duty cycle to 80 %
    PWMOn                  'Turn on the PWM
    WAIT 10 s              'Wait 10 seconds
    PWMOff                 'Turn off the PWM</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">For more help, also see</emphasis> <link linkend="_pwmon">PWMOn</link></simpara>
</section>
</section>
<section xml:id="_hardware_pwm_code_optimisation">
<title>Hardware PWM Code Optimisation</title>
<simpara><emphasis role="strong">About Hardware PWM Code Optimisation</emphasis></simpara>
<simpara>For compatibility all channels are supported by default.  This is maintains backward compatibility.<?asciidoc-br?></simpara>
<simpara>To mimise the code, use the following to disable support for a specific Capture/Compare/PWM (CCP) module, timers or the PWM module.<?asciidoc-br?></simpara>
<simpara>Setting a constant to <emphasis>FALSE</emphasis> will remove the support of the capability from the method and therefore will reduce the program size.</simpara>
<screen>    #define USE_HPWMCCP1 FALSE
    #define USE_HPWMCCP2 FALSE
    #define USE_HPWMCCP3 FALSE
    #define USE_HPWMCCP4 FALSE</screen>
<simpara>To further mimise the code, use the following to disable support for a specific PWM channels.  Only PWM channels 5, 6 and 7 are supported.</simpara>
<screen>    #define USE_HPWM3 FALSE
    #define USE_HPWM4 FALSE
    #define USE_HPWM5 FALSE
    #define USE_HPWM6 FALSE
    #define USE_HPWM7 FALSE</screen>
<simpara>To further mimise the code, use the following to disable support for a specific timers.</simpara>
<screen>    #define USE_HPWM_TIMER2 TRUE
    #define USE_HPWM_TIMER4 TRUE
    #define USE_HPWM_TIMER6 TRUE</screen>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<simpara>This will save 335 bytes of program memory by removing support for CCP1, CCP2 and CCP4.</simpara>
<screen>    #chip 16f18855,32
    #Config MCLRE_ON

    UNLOCKPPS
        RC2PPS = 0x0A       'RC2-&gt;CCP2:CCP2;
    LOCKPPS

    #define USE_HPWMCCP1 FALSE       ' This is not used so optimise
    #define USE_HPWMCCP2 TRUE        ' This is used so include in the compiled code
    #define USE_HPWMCCP3 FALSE       ' This is not used so optimise
    #define USE_HPWMCCP4 FALSE       ' This is not used so optimise


    'Setting the port an output is VERY important... LED will not work if you do not set as an output.
    dir portC.2 out    ; CCP2

    do forever
            For Bright = 1 to 255
                HPWM 2, 40, Bright
                wait 10 ms
            next

    loop</screen>
</section>
</section>
<section xml:id="_atmel_avr_pwm_overview">
<title>ATMEL AVR PWM Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>The methods described in this section allow the generation of Pulse
Width Modulation (PWM) signals. PWM signals enables the microcontroller to control
items like the speed of a motor, or the brightness of a LED or lamp.<?asciidoc-br?></simpara>
<simpara>The methods can also be used to generate the appropriate frequency signal to drive an
infrared LED for remote control applications.<?asciidoc-br?></simpara>
<simpara>GCBASIC support the methods described in this section.</simpara>
<simpara><emphasis role="strong">Hardware PWM using a Timer/Counter with a OCRnx module</emphasis></simpara>
<simpara>The AVR devices use a Timer/Counter and OCRnx module that has a variable period register.  The
Hardware PWM is available through the OCnx pin.</simpara>
<simpara>The method uses three parameters to setup the HPWM.</simpara>
<literallayout class="monospaced">'HPWM channel, frequency, duty cycle
HPWM  2, 100, 50</literallayout>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>A number of constants are used to control settings for PWM hardware module of the microcontroller.
To set them, place a line in the main program file that uses #define to assign a value to the particular constant.</simpara>
<simpara>&#160;<?asciidoc-br?>
&#160;<?asciidoc-br?>
&#160;<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">See</emphasis> <link linkend="_hpwm_avr_ocrnx">HPWM AVR OCRnx</link></simpara>
<section xml:id="_hpwm_avr_ocrnx">
<title>HPWM AVR OCRnx</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>     HPWM <emphasis>channel</emphasis>, <emphasis>frequency</emphasis>, <emphasis>duty cycle</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>The HPWM command is available on Atmel AVR microcontrollers with an OCnx pin, and is compatible with the PIC HPWM command method.  Due to the the unique way of AVR PWM implementation, and code efficiency, there are some notable differences in the HPWM initialization and its use.</simpara>
<simpara>This command supports the Fast PWM Mode and period registers for their respective devices.  Typically Timer0 and Timer2 do not have a period register and the "A" channel is sacrificed to provide that function.  Therefore, channel 1 and channel 6 will not be available, but are documented for possible future use.  Some device Timers do not have an adjustable period register, so this command is not feasible (consult the datasheet).</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The HPWM command sets up the hardware PWM module of the Atmel AVR microcontrollers to generate a PWM waveform of the given frequency and duty cycle.  Once this command is called, the PWM will be emitted until the duty cycle parameter is written to zero.</simpara>
<simpara>If the need is just one particular frequency and duty cycle, one should use PWMOn and the constants PWM_Freq and PWM_Duty instead.  PWMOn for the AVR is uniquely assigned to the OC0B pin, or channel 2. PWMOff will only shutdown  the AVR HPWM channel 2.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> described as 1, 2, 3,&#8230;&#8203;16 correspond to the pins OCR0A, OCR0B&#8230;&#8203;.OCR5C as detailed in the <emphasis>channel</emphasis> constant table.  Channel 1 and channel 6 are not available.</simpara>
<simpara><literal><emphasis>frequency</emphasis></literal> sets the frequency of the PWM output measured in Khz.  The maximum value allowed is 255 KHz. In situations that do not require a specific PWM frequency, the PWM frequency should equal approximately 4 times the clock speed (GCB chipMHz) of the microcontroller (ie 63 KHz on a 16 MHz chip, 32 KHz on 8 MHz, 4 Khz on 1 MHz).  This gives the best duty cycle resolution possible.  Alternate frequencies with good duty cycle resolution are 1Khz, and 4Khz with chipMhz values of 16 and 8 respectively.</simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the desired duty cycle of the PWM signal, and ranges from 0 to 255 where 255 is 100% duty cycle.  The AVR fast PWM mode has a small spike at the extreme setting of  0x00, on most devices, with each period register rollover.  By using the HPWM command, and writing 0x00 to the duty cycle parameter, the PWM signal will shutdown completely and avoid the spike.  The PWM signal can then be restarted again with a new HPWM command.</simpara>
<simpara>Note: Due to the AVR having a timer prescaler of just 1, 8, and 64; the AVR frequency and duty cycle resolution will be different from the PIC frequency and duty cycle resolution.   The AVR HPWM parameters will likely need adjusting ,when substituted into an existing PIC program, and where accuracy is required.</simpara>
<simpara><emphasis role="strong">HPWM Constants:</emphasis></simpara>
<simpara>The AVR HPWM timer constants for channel number control are shown in the table below.  Each timer constant needs to be defined for any one of the channels it controls.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16*"/>
<colspec colname="col_2" colwidth="66*"/>
<colspec colname="col_3" colwidth="16*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Timer</emphasis><?asciidoc-br?>
<emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AVRTC0</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR TC0 associated  with <emphasis>channel</emphasis> 1, and 2</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRTC1</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR TC1 associated  with <emphasis>channel</emphasis> 3, 4 and 5<?asciidoc-br?>
Channel 5 present on larger pinout devices</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRTC2</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR TC2 associated  with <emphasis>channel</emphasis> 6, and 7</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRTC3</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR TC3 associated  with <emphasis>channel</emphasis> 8, 9, and 10</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRTC4</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR TC4 associated  with <emphasis>channel</emphasis> 11,12, and 13</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRTC5</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR TC5 associated  with <emphasis>channel</emphasis> 14, 15, and 16</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC HPWM channel constants for output pin control are shown in the table below.  Each HPWM channel used needs to be defined.  The Port pin associated with each OCnx must be set to output.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16*"/>
<colspec colname="col_2" colwidth="66*"/>
<colspec colname="col_3" colwidth="16*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Channel</emphasis><?asciidoc-br?>
<emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN1</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 1 to the associated output pin OC0A<?asciidoc-br?>
OCR0A is used as period register and thus not available</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN2</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 2 to the associated output pin OC0B</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN3</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 3 to the associated output pin OC1A<?asciidoc-br?>
MUX&#8217;d  with OC0A pin on some ATTiny&#8217;s</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN4</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 4 to the associated output pin OC1B</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN5</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 5 to the associated output pin OC1C<?asciidoc-br?>
On some larger pinout devices and MUX&#8217;d with OC0A pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN6</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 6 to the associated output pin OC2A<?asciidoc-br?>
OCR2A is used as a period register and thus not available</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN7</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 7 to the associated output pin OC2B</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN8</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 8 to the associated output pin OC3A</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN9</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 9 to the associated output pin OC3B</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN10</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 9 to the associated output pin OC3C</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN11</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 11 to the associated output pin OC4A</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN12</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 12 to the associated output pin OC4B</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN13</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 13 to the associated output pin OC4C</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN14</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 14 to the associated output pin OC5A</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN15</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 15 to the associated output pin OC5B</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN16</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 16 to the associated output pin OC5C</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>        'Using HPWM command to alternate ramping leds with the UNO board
    #chip mega328,16

    '************pwm************************
    'Must define AVRTCx, AVRCHANx, and set OCnX pin dir to out

    #define AVRTC0    'Timer0
    #define AVRCHAN2
    dir PortD.5 Out   'OC0B, UNO pin 5

    #define AVRTC1    'Timer1
    #define AVRCHAN3
    #define AVRCHAN4
    dir PortB.1 out   'OC1A, UNO pin 9
    dir PortB.2 Out   'OC1B, UNO pin 10

    #define AVRTC2    'Timer2
    #define AVRCHAN7
    dir PortD.3 Out   'OC2B, UNO pin 3

    do

    '63khz works good with 16MHz
    '32khz with 8MHz intosc
    '4KHz with 8MHz intosc and ckDiv8 fuse
    freq = 63
      For PWMled1 = 0 to 255
        HPWM 2,freq,PWMled1
        PWMled2 = NOT PWMled1
        HPWM 3,freq,PWMled2
        HPWM 4,freq,PWMled2
        HPWM 7,freq,PWMled1
        wait 5 ms
      Next

      For PWMled1 = 255 to 0
        HPWM 2,freq,PWMled1
        PWMled2 = NOT PWMled1
        HPWM 3,freq,PWMled2
        HPWM 4,freq,PWMled2
        HPWM 7,freq,PWMled1
        wait 5 ms
      Next

    loop</screen>
</section>
<section xml:id="_hpwm_fixed_mode_for_avr">
<title>HPWM Fixed Mode for AVR</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PWMOn

    'or

    PWMOff</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>This command is only available on the Atmel AVR microcontrollers with a Timer/Counter0 OC0B register.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The PWMOn command will only enable the output of the OC0B/PWM module of the Atmel AVR microcontroller.</simpara>
<simpara>This command is not available for any other OCnx/PWM modules.</simpara>
<simpara>This command sets up the hardware PWM module of the Atmel AVR microcontroller to generate
a PWM waveform of the given frequency and duty cycle. &#160;&#160;Once PWMON method
is called, the PWM will be emitted until PWMOff is called.</simpara>
<simpara>These constants are required for PWMOn.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>PWM_Freq</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output frequency of the PWM module in KHz.</simpara></entry>
<entry align="left" valign="top"><simpara>38</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PWM_Duty</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the duty cycle of the PWM module output. Given as percentage.</simpara></entry>
<entry align="left" valign="top"><simpara>50</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program demonstrates the PWMOn and PWMOff commands
    'of the fixed mode HPWM on OC0B pin.

    #chip mega328p,16

    'activate appropriate PWM output pins
    dir PortD.5 Out     'OC0B

    'define PWM_Freq in kHz
    'define PWM_Duty in %

    #define PWM_Freq 40
    #define PWM_Duty 50

    do

      'turn on/off single channel 40 KHz PWM on OC0B pin
      PWMON
      wait 5 s
      PWMOFF
      wait 5 s

    loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmon_for_avr">PWMOn</link> and <link linkend="_pwmoff_for_avr">PWMOff</link> <emphasis role="strong">or, for Microchip microcontrollers see</emphasis> <link linkend="_hpwm_fixed_mode">Fixed Mode PWM for Microchip</link></simpara>
<section xml:id="_pwmon_for_avr">
<title>PWMOn for AVR</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  PWMOn</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>This command is only available on the Atmel AVR microcontrollers with a Timer/Counter0 OC0B register.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The PWMOn command will only enable the output of the OC0B/PWM module of the Atmel AVR microcontroller.</simpara>
<simpara>This command is not available for any other OCnx/PWM modules.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program demonstrates the PWMOn and PWMOff commands
    'of the fixed mode HPWM on OC0B pin.

    #chip mega328p,16

    'activate appropriate PWM output pins
    dir PortD.5 Out     'OC0B

    'define PWM_Freq in kHz
    'define PWM_Duty in %

    #define PWM_Freq 40
    #define PWM_Duty 50

    do

      'turn on/off single channel 40 KHz PWM on OC0B pin
      PWMON
      wait 5 s
      PWMOFF
      wait 5 s

    loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmoff_for_avr">PWMOff</link></simpara>
</section>
<section xml:id="_pwmoff_for_avr">
<title>PWMOff for AVR</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  PWMOff</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>This command is only available on the Atmel AVR microcontrollers with a Timer/Counter0 OC0B register.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The PWMOff command will only disable the output of the OC0B/PWM module of the Atmel AVR microcontrollers.</simpara>
<simpara>This command is not available for any other OCnx/PWM modules.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program demonstrates the PWMOn and PWMOff commands
    'of the fixed mode HPWM on OC0B pin.

    #chip mega328p,16

    'activate appropriate PWM output pins
    dir PortD.5 Out     'OC0B

    'define PWM_Freq in kHz
    'define PWM_Duty in %

    #define PWM_Freq 40
    #define PWM_Duty 50

    do

      'turn on/off single channel 40 KHz PWM on OC0B pin
      PWMON
      wait 5 s
      PWMOFF
      wait 5 s

    loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmon_for_avr">PWMOn</link></simpara>
</section>
</section>
</section>
</section>
<section xml:id="_random_numbers">
<title>Random Numbers</title>
<simpara>This is the Random Numbers section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_overview">
<title>Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>These routines allow GCBASIC to generate pseudo-random numbers.</simpara>
<simpara>The generator uses a 16 bit linear feedback shift register to produce
pseudo-random numbers.  The most significant 8 bits of the LFSR are used
to provide an 8 bit random number.</simpara>
<simpara>When compiling a program, GCBASIC will generate an initial seed for the
generator. However, this seed will be the same every time the program
runs, so the sequence of numbers produced by a given program will always
be the same. To work around this, there is a Randomize subroutine. It
can be provided with a new seed for the generator (which will cause the
generator to move to a different point in the sequence). Alternatively,
Randomize can be set to obtain a seed from some other source such as a
timer every time it is run.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the random number generation.
To set them, place a line in the main program file that uses
<literal>#define</literal> to assign a value to the particular constant.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>RANDOMIZE_SEED</simpara></entry>
<entry align="left" valign="top"><simpara>Source of the random seed if Randomize is called without a parameter</simpara></entry>
<entry align="left" valign="top"><simpara>Timer0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #define RANDOMIZE_SEED Timer2</screen>
</section>
<section xml:id="_random">
<title>Random</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    var = Random</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Random</literal> function will generate a pseudo-random number between 0 and 255 inclusive.</simpara>
<simpara>The numbers generated by <literal>Random</literal> will follow the same sequence every time, until <literal>Randomize</literal> is used.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip tiny2313, 1

    'Use randomize, with the value on PORTD as the seed
    Randomize PORTD

    'Generate random numbers, and output on PORTB
    Do
        PORTB = Random
        Wait 1 s
    Loop</screen>
</section>
<section xml:id="_randomize">
<title>Randomize</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Randomize
    Randomize <emphasis>seed</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Randomize is used to seed the pseudo random number generator, so that it
will produce a different sequence of numbers each time it is used.</simpara>
<simpara>The random number generator in GCBASIC is a 16 bit linear feedback shift register,
which is explained here: <link xlink:href="http://en.wikipedia.org/wiki/Linear_feedback_shift_register">http://en.wikipedia.org/wiki/Linear_feedback_shift_register</link></simpara>
<simpara>Generally, you will get the same sequence every time it is used.&#160;&#160;However, you can seed it so that it will start at a different point at the sequence using the Randomize command.</simpara>
<simpara>If you wanted to use an analog reading to seed the generator, this would work:</simpara>
<literallayout class="monospaced">Randomize ReadAD10(AN0)</literallayout>
<simpara>If no <emphasis>seed</emphasis> is specified, then the RANDOMIZE_SEED constant will be used
as the seed.&#160;&#160;If <emphasis>seed</emphasis> is specified, then it will be used to seed the
generator.</simpara>
<simpara>It is important that the seed is different every time that Randomize is
used. If the seed is always the same, then the sequence of numbers will
always be the same.&#160;&#160; It is best to use a running timer, an input port, or
the analog to digital converter as the source of the seed, since these
will normally provide a different value each time the program runs.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip tiny2313, 1

    'Use randomize, with the value on PORTD as the seed
    Randomize PORTD

    'Generate random numbers, and output on PORTB
    Do
        PORTB = Random
        Wait 1 s
    Loop</screen>
</section>
</section>
<section xml:id="_7_segment_displays">
<title>7-Segment Displays</title>
<simpara>This is the 7-Segment Displays section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_7_segment_displays_overview">
<title>7 Segment Displays Overview</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>The 7 Segment Displays module provide a cheap red, green, blue or white bright LED Display.&#160;&#160;
The Ebay modules can be had for $1 to $4 per piece, somtimes less.&#160;&#160;
They only need 2 pins to control: CLK and DIO for control 4 digit 7 segment LED Display.&#160;&#160;
They often have a  colon LED&#160;&#160;</simpara>
<simpara>The GCBASIC 7 segment display methods make it easier for GCBASIC programs to display numbers and letters on 7 segment LED displays.</simpara>
<simpara>There are two ways that the 7 segment display routines can be set up.</simpara>
<itemizedlist>
<listitem>
<simpara>A pre 2020 method <link linkend="_7_segment_displays_legacy">7 segment legacy method</link></simpara>
</listitem>
<listitem>
<simpara>A revised method for <link linkend="_7_segment_displays_tm1637_4_digits">TM1637 4 LEDs</link>, or, <link linkend="_7_segment_displays_tm1637_6_digits">TM1637 6 LEDs</link></simpara>
</listitem>
</itemizedlist>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<section xml:id="_7_segment_displays_legacy">
<title>7 Segment Displays - Legacy</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>The GCBASIC 7 segment display methods make it easier for GCBASIC programs to display numbers and letters on 7 segment LED displays.</simpara>
<simpara>The GCBASIC methods support up to four digit 7 segment display devices, common anode/cathode and inversion of the port logic to support driving the device(s) via a transistor.</simpara>
<simpara>There are three ways that the 7 segment display routines can be set up.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Method</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Connect the microcontroller to the 7 segment display (via suitable resistors) using  any eight output bits.
</simpara><simpara>Use <literal>DISP_SEG_x</literal> and <literal>DISP_SEL_x</literal> constants to specify the outpout ports and the select port(s) to be used.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>Connect the microcontroller to the 7 segment display (via suitable resistors) using whole port (8 bits) of the microcontroller.
</simpara><simpara>This implies the connections are consectutive in terms of the 8 output bits of the port.
</simpara><simpara>Use the <literal>DISPLAYPORTn</literal> and <literal>DISPSELECTn</literal> constants to specify the whole port and the select port(s) to be used.
</simpara><simpara>This method will generate the most efficient code.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>Connect the microcontroller to the 7 segment display (via suitable resistors) using whole port (8 bits) of the microcontroller.
</simpara><simpara>This implies the connections are consectutive in terms of the 8 output bits of the port.
</simpara><simpara>Use the <literal>DISPLAYPORTn</literal> and <literal>DISP_SEL_n</literal> constants to specify the whole port and the select port(s) to be used.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The GCBASIC methods  assume the 7 segment display(s) is to be connected to a common
parallel bus with a Common Cathode.   See the sections
<link linkend="_common_cathode">Common Cathode</link> and
<link linkend="_common_anode">Common Anode</link> for examples of using GCBASIC code to
control these different configurations</simpara>
<simpara>Shown below are the differing constants that must be set for the three connectivity options.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Index</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Method</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>DISP_SEG_x</literal> &amp; <literal>DISP_SEL_x</literal></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISP_SEG_x</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin (output bit) used to control a specific segment of the 7 segment display.
</simpara><simpara>There are seven constants that must be specified.
</simpara><simpara><literal>DISP_SEG_A</literal> through <literal>DISP_SEG_G</literal>. One
must be set for each segment.
</simpara><simpara>Typical commands are:
</simpara><simpara><literal>#define DISP_SEG_A portA.0</literal>
</simpara><simpara><literal>#define DISP_SEG_B portA.1</literal>
</simpara><simpara><literal>#define DISP_SEG_C portA.2</literal>
</simpara><simpara><literal>#define DISP_SEG_D portA.3</literal>
</simpara><simpara><literal>#define DISP_SEG_E portA.4</literal>
</simpara><simpara><literal>#define DISP_SEG_F portA.5</literal>
</simpara><simpara><literal>#define DISP_SEG_G portA.6</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Must be specified to use this connectivity option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISP_SEG_DOT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin (output bit) used to control the decimal point on the
7 segment display.
</simpara><simpara>Typical commands are:
</simpara><simpara><literal>#define DISP_SEG_DOT portA.7</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISP_SEL_x</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin (output bit) used to control a specific 7 segment display.
</simpara><simpara>These constants are used to control the specific 7 segment display being addresses.
</simpara><simpara>Typical commands are:
</simpara><simpara><literal>#define DISP_SEL_1 portA.0</literal>
</simpara><simpara><literal>#define DISP_SEL_2 portA.1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A valid output pin (output bit) must be specified.  Must be specified to use this connectivity option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>DISPLAYPORTn</literal> &amp; <literal>DISPSELECTn</literal></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISPLAYPORTn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output port used to control the 7 segment display.
</simpara><simpara>Port.bit &gt;&gt; Segment
</simpara><simpara>port.0      &gt;&gt;   A
</simpara><simpara>port.1     &gt;&gt;   B
</simpara><simpara>port.2     &gt;&gt;   C
</simpara><simpara>port.3     &gt;&gt;   D
</simpara><simpara>port.4     &gt;&gt;   E
</simpara><simpara>port.5     &gt;&gt;   F
</simpara><simpara>port.6     &gt;&gt;   G</simpara></entry>
<entry align="left" valign="top"><simpara>Can be <literal>DISPLAYPORTA</literal> and/or <literal>DISPLAYPORTB</literal> and/or <literal>DISPLAYPORTC</literal> and/or <literal>DISPLAYPORTD</literal>
</simpara><simpara>Where <literal>DISPLAYPORTn</literal> can be A, B, C or D which corresponding to displays 1, 2, 3 and 4, respectively.
</simpara><simpara>Must be specified to use this connectivity option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISPSELECTn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output command used to <emphasis role="strong">select</emphasis> a specific 7 segment display addressed by <literal>DISPLAYPORT_n</literal>.
</simpara><simpara>Used to control output pin (output bit) when several displays are multiplexed.
</simpara><simpara>Typical commands are:
    <literal>#define DispSelectA Set portA.0 on</literal>
</simpara><simpara>    <literal>#define DispSelectB Set portA.1 on</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Can be <literal>DISPSELECTA</literal> and/or <literal>DISPSELECTB</literal> and/or <literal>DISPSELECTC</literal> and/or <literal>DISPSELECTD</literal>
</simpara><simpara>Must be specified to use this connectivity option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISPDESELECTn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An optional command to specify the output command used to <emphasis role="strong">deselect</emphasis> a specific 7 segment display addressed by <literal>DISPLAYPORT_n</literal>.
</simpara><simpara>Used to control output pin (output bit) when several displays are multiplexed.
</simpara><simpara>Typical commands are:
</simpara><simpara>    <literal>#define DispDeSelectA Set portA.0 off</literal>
</simpara><simpara>    <literal>#define DispDeSelectB Set portA.1 off</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Can be <literal>DISPDESELECTA</literal> and/or <literal>DISPDESELECTB</literal> and/or <literal>DISPDESELECTC</literal> and/or <literal>DISPDESELECTD</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara><literal>DISPLAYPORTn</literal> &amp; <literal>DISP_SEL_n</literal></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISPLAYPORTn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output port used to control the 7 segment display.
</simpara><simpara>Port.bit &gt;&gt; Segment
</simpara><simpara>port.0      &gt;&gt;   A
</simpara><simpara>port.1     &gt;&gt;   B
</simpara><simpara>port.2     &gt;&gt;   C
</simpara><simpara>port.3     &gt;&gt;   D
</simpara><simpara>port.4     &gt;&gt;   E
</simpara><simpara>port.5     &gt;&gt;   F
</simpara><simpara>port.6     &gt;&gt;   G</simpara></entry>
<entry align="left" valign="top"><simpara>Can be <literal>DISPLAYPORTA</literal> and/or <literal>DISPLAYPORTB</literal> and/or <literal>DISPLAYPORTC</literal> and/or <literal>DISPLAYPORTD</literal>
</simpara><simpara>Where <literal>DISPLAYPORTn</literal> can be A, B, C or D which corresponding to displays 1, 2, 3 and 4, respectively.
</simpara><simpara>Must be specified to use this connectivity option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISP_SEL_n</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output command used to select a specific 7 segment display addressed by <literal>DISPLAYPORTn</literal>.
</simpara><simpara>Typical commands are:
</simpara><simpara>    <literal>#define DISP_SEL_1 portA.0</literal>
</simpara><simpara>    <literal>#define DISP_SEL_2 portA.1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Must be specified to use this connectivity option.
</simpara><simpara>Can be specified as <literal>DISP_SEL_1</literal> and/or <literal>DISP_SEL_2</literal> and/or <literal>DISP_SEL_3</literal> and/or <literal>DISP_SEL_4</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>        'A Common Cathode 7 Segment display  2 digit example
        #chip 16F886, 8

        'support for Common Anode
        '#DEFINE 7SEG_COMMONANODE

        'support for pfet or pnp high side drivers
        '#DEFINE 7SEG_HIGHSIDE

        ' ----- Constants
        'You need to specify the port settings
        'by one of the following three methods
        'The Directions of the ports are automaically set according to the defines

        'METHOD 1
        'Define individual port pins for segments and selects

        #DEFINE DISP_SEG_A PORTB.0
        #DEFINE DISP_SEG_B PORTB.1
        #DEFINE DISP_SEG_C PORTB.2
        #DEFINE DISP_SEG_D PORTB.3
        #DEFINE DISP_SEG_E PORTB.4
        #DEFINE DISP_SEG_F PORTB.5
        #DEFINE DISP_SEG_G PORTB.6
        #DEFINE DISP_SEG_DOT PORTB.7 '' available on some displays as dp or colon

        #DEFINE DISP_SEL_1 PORTC.5
        #DEFINE DISP_SEL_2 PORTC.4

        'METHOD 2  Define DISPLAYPORTA (B,C,D) for up to 4 digit display segments
        'Define DISPSELECTA (B,C,D) for up to 4 digit display selects

        '#DEFINE DISPLAYPORTA PORTB   ' same port name can be assigned
        '#DEFINE DISPLAYPORTB PORTB

        '#DEFINE DispSelectA Set portC.5 off
        '#DEFINE DispSelectB Set portC.4 off
        '#DEFINE DispDeSelectA Set portC.5 on
        '#DEFINE DispDeSelectB Set portC.4 on

        'METHOD 3  Define DISPLAYPORTA (B,C,D) for up to 4 digit display segments
        'Define port pins for the digit display  selects

        '#DEFINE DISPLAYPORTA PORTB
        '#DEFINE DISPLAYPORTB PORTB

        '#DEFINE DISP_SEL_1 PORTC.5
        '#DEFINE DISP_SEL_2 PORTC.4



        Dim Message As String
        Message = " HAPPY HOLIDAYS  "
        Do
            For Counter = 1 to len(Message)-1
            Repeat 50
                Displaychar 1, Message(Counter)
                wait 3 ms
                DisplayChar 2, Message(Counter+1)
                wait 3 ms

            End Repeat
            Wait 100 ms
            Next
        Loop</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/CC_4dig_7seg_16F886_Schem.jpg" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/CA_2Dig_7seg_16F886_schem.jpg" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Also, see</emphasis> <link linkend="_displaychar">DisplayChar</link>,
<link linkend="_displayvalue">DisplayValue</link></simpara>
<section xml:id="_common_cathode">
<title>Common Cathode</title>
<simpara>This is a Common Cathode 7 Segment display example.</simpara>
<simpara>No additional configuration is required when using Common Cathnode.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Comment</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>7Seg_CommonAnode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Inverts controls for Common Anode displays</simpara></entry>
<entry align="left" valign="top"><simpara>Required for Common Cathode displays</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>7Seg_HighSide</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Support PFET or PNP high side driving of the display</simpara></entry>
<entry align="left" valign="top"><simpara>Inverts Common Cathode addressing pin logic for multiplexed displays</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This is a Common Cathode 7 Segment display example.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Chip model
    #chip 16f1783,8

    'Output ports for the 7-segment device
    #define DISP_SEG_A PORTC.0
    #define DISP_SEG_B PORTC.1
    #define DISP_SEG_C PORTC.2
    #define DISP_SEG_D PORTC.3
    #define DISP_SEG_E PORTC.4
    #define DISP_SEG_F PORTC.5
    #define DISP_SEG_G PORTC.6

    ' This is the usage of the SEG_DOT for decimal point support
	' An optional third parameter of '1' will turn on the decimal point
	' of that digit when using DisplayValue command
    #define DISP_SEG_DOT PortC.7

    'Select ports for the 7-segment device
    #define Disp_Sel_1 PortA.1
    #define Disp_Sel_2 PortA.2
    #define Disp_Sel_3 PortA.3

    dim count as word
    dim number as word

    Do Forever
        For count = 0 to 999
            number = count
            Num2 = 0
            Num3 = 0
            If number &gt;= 100 Then
              Num3 = number / 100
              'SysCalcTempX is the remainder after a division has been completed
              number = SysCalcTempX
            End if
            If number &gt;= 10 Then
              Num2 = number / 10
              number = SysCalcTempX
            end if
            Num1 = number
            Repeat 10
              DisplayValue 1, Num1,1  'Optional third parameter turns on the dp dot on that digit
              wait 5 ms
              DisplayValue 2, Num2
              wait 5 ms
              DisplayValue 3, Num3
              wait 5 ms

            end Repeat
        Next
    Loop</screen>
<simpara><emphasis role="strong">Also, see</emphasis>
<link linkend="_7_segment_displays_overview">7 Degment Display Overview</link>,<link linkend="_displaychar">DisplayChar</link>, <link linkend="_displayvalue">DisplayValue</link></simpara>
</section>
<section xml:id="_common_anode">
<title>Common Anode</title>
<simpara>This is a Common Anode 7 Segment display example.</simpara>
<simpara>Additional configuration is required when using Common Anode.</simpara>
<simpara>When setting up the 7 segment Common Anode display you <emphasis role="strong">MUST</emphasis> use the
<literal>7Seg_CommonAnode</literal> constant. You can optionally use the <literal>7Seg_HighSide</literal>
constant to support PFET or PNP high side driving of the Common Anode
displays as follows:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Comment</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>7Seg_CommonAnode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Inverts controls for Common Anode displays</simpara></entry>
<entry align="left" valign="top"><simpara>Required for Common Cathode displays</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>7Seg_HighSide</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Support PFET or PNP high side driving of the display</simpara></entry>
<entry align="left" valign="top"><simpara>Inverts Common Cathode addressing pin logic for multiplexed displays</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'A Common Anode 7 Segment display example using bs250p pfets
    'Chip model
    #chip 16f1783,8

    'support for Common Cathode
    #define 7Seg_CommonAnode

    'support for pfet or pnp high side drivers
    #define 7Seg_HighSide

    #define DISP_SEG_A PORTC.0
    #define DISP_SEG_B PORTC.1
    #define DISP_SEG_C PORTC.2
    #define DISP_SEG_D PORTC.3
    #define DISP_SEG_E PORTC.4
    #define DISP_SEG_F PORTC.5
    #define DISP_SEG_G PORTC.6
	#define DISP_SEG_DOT PORTC.7

    #define Disp_Sel_1 PortA.1
    #define Disp_Sel_2 PortA.2
    #define Disp_Sel_3 PortA.3

    dim count as word
    dim number as word

    Do Forever
      For count = 0 to 999
          number = count
          Num2 = 0
          Num3 = 0
          If number &gt;= 100 Then
            Num3 = number / 100
            'SysCalcTempX is the remainder after a division has been completed
            number = SysCalcTempX
          End if
          If number &gt;= 10 Then
            Num2 = number / 10
            number = SysCalcTempX
          end if
          Num1 = number
          Repeat 10
            DisplayValue 1, Num1, 1 'Optional third parameter turns on the dp on that digit
            wait 5 ms
            DisplayValue 2, Num2
            wait 5 ms
            DisplayValue 3, Num3
            wait 5 ms
           end Repeat
      Next
    Loop</screen>
<simpara><emphasis role="strong">Also, see</emphasis>
<link linkend="_7_segment_displays_overview">7 Degment Display Overview</link>,
<link linkend="_displaychar">DisplayChar</link>, <link linkend="_displayvalue">DisplayValue</link></simpara>
</section>
<section xml:id="_displayvalue">
<title>DisplayValue</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    DisplayValue (<emphasis>display, data, dot</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will display the given value on a seven segment LED
display.</simpara>
<simpara><literal><emphasis>display</emphasis></literal> is the number of the display to use. Up to 4 digits.<?asciidoc-br?></simpara>
<simpara><literal><emphasis>data</emphasis></literal> is the value between 0 and F to be shown.</simpara>
<simpara><literal><emphasis>dot</emphasis></literal> is an optional parameter. When it is 1 then the decimal point for that digit  is turned on.</simpara>
<simpara>The command also support HEX characters in the range between 0x00 and
0x0F (0 to 15). See example two below for usage.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This program will count from 0 to 99 on two LED displays
    #chip 16F819, 8

  'See 7 Segment Display Overview for alternate ways of defining Ports
    #define DISP_SEG_A PORTB.0
    #define DISP_SEG_B PORTB.1
    #define DISP_SEG_C PORTB.2
    #define DISP_SEG_D PORTB.3
    #define DISP_SEG_E PORTB.4
    #define DISP_SEG_F PORTB.5
    #define DISP_SEG_G PORTB.6
  '#define DISP_SEG_DOT PORTB.7 ' Optional DP

    #define DISP_SEL_1 PORTA.0
    #define DISP_SEL_2 PORTA.1

    Do
        For Counter = 0 To 99

            'Get the 2 digits
            Number = Counter
            Num1 = 0
            If Number &gt;= 10 Then
                Num1 = Number / 10
                'SysCalcTempX stores remainder after division
                Number = SysCalcTempX
            End If
            Num2 = Number

            'Show the digits
            'Each DisplayValue will erase the other (multiplexing)
            'So they must be called often enough that the flickering
            'cannot be seen.
            Repeat 500
                DisplayValue 1, Num1
                Wait 1 ms
                DisplayValue 2, Num2
                Wait 1 ms
            End Repeat
        Next
    Loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    'This program will count from 0 to 0xff on two LED displays
    #chip 16F819, 8

    #define DISP_SEG_A PORTB.0
    #define DISP_SEG_B PORTB.1
    #define DISP_SEG_C PORTB.2
    #define DISP_SEG_D PORTB.3
    #define DISP_SEG_E PORTB.4
    #define DISP_SEG_F PORTB.5
    #define DISP_SEG_G PORTB.6

    #define DISP_SEL_1 PORTA.0
    #define DISP_SEL_2 PORTA.1
    #define DISP_SEL_4 PORTA.2
    #define DISP_SEL_3 PORTA.3

    Do
        For Counter = 0 To 0xff

            'Get the 2 digits
            Number = Counter
            Num1 = 0
            If Number &gt;= 0x10 Then
                Num1 = Number / 0x10
                'SysCalcTempX stores remainder after division
                Number = SysCalcTempX
            End If
            Num2 = Number

            'Show the digits
            'Each DisplayValue will erase the other (multiplexing)
            'So they must be called often enough that the flickering
            'cannot be seen.
            Repeat 500
                DisplayValue 1, Num1
                Wait 1 ms
                DisplayValue 2, Num2
                Wait 1 ms
            End Repeat
        Next
    Loop</screen>
<simpara><emphasis role="strong">Also, see</emphasis> <link linkend="_7_segment_displays_overview">7 Segment Display Overview</link>, <link linkend="_displaychar">DisplayChar</link>, <link linkend="_displaysegment">DisplaySegment</link></simpara>
</section>
<section xml:id="_displaychar">
<title>DisplayChar</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    DisplayChar (<emphasis>display, character, dot</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will display the given ASCII character on a seven segment
LED display.</simpara>
<simpara><literal><emphasis>display</emphasis></literal> is the number of the display to use. Up to 4 digits.<?asciidoc-br?></simpara>
<simpara><literal><emphasis>character</emphasis></literal> is the ASCII character to be shown.</simpara>
<simpara><literal><emphasis>dot</emphasis></literal> is an optional parameter. When it is 1 then the decimal point for that digit  is turned on.</simpara>
<simpara>This example below is a Common Cathode configuration.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>   'This program will show " Hello  " on a LED display
    'The display should be connected to PORTB and the Enable on PORTA.0

    #chip 16F877A, 20

    #define DISPLAYPORTA PORTB
    #define DISP_SEL_1 PORTA.0


    Dim Message As String
    Message = " Hello  "
  Do
    For Counter = 1 to len(Message)
      DisplayChar 1, Message(Counter)
      Wait 250 ms
    Next
  Loop</screen>
<simpara>This is a Common Anode example
There are three different methods for port specification
Note the ports are specified bit by bit in this case but
could be specified like Example 1
See Overview for further explanation.</simpara>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>  'This program will show amessage on a LED display
  'This is a Dual digit Common anode with driver transistors example
   #chip 16F886, 8

    'support for Common Anode
    #define 7Seg_CommonAnode

    'support for pfet or pnp high side drivers
    #define 7Seg_HighSide

  ' Constants
  ' You need to specify the port settings
    #define DISP_SEG_A PORTB.0
    #define DISP_SEG_B PORTB.1
    #define DISP_SEG_C PORTB.2
    #define DISP_SEG_D PORTB.3
    #define DISP_SEG_E PORTB.4
    #define DISP_SEG_F PORTB.5
    #define DISP_SEG_G PORTB.6

    #define DISP_SEL_1 PORTC.5
    #define DISP_SEL_2 PORTC.4

    Dim Message As String
    Message = " Happy Holidays  "
    Do
    For Counter = 1 to len(Message)-2
      Repeat 50
        Displaychar 1, Message(Counter)
        wait 3 ms
        DisplayChar 2, Message(Counter+1)
        wait 3 ms
        end Repeat
      Wait 100 ms
    Next
    Loop</screen>
<simpara><emphasis role="strong">Also, see</emphasis> <link linkend="_7_segment_displays_overview">7 Degment Display Overview</link>, <link linkend="_displayvalue">DisplayValue</link>, <link linkend="_displaysegment">DisplaySegment</link></simpara>
</section>
<section xml:id="_displaysegment">
<title>DisplaySegment</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    DisplayValue (<emphasis>display, data</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will display the given value on a seven segment LED
display.</simpara>
<simpara><literal><emphasis>display</emphasis></literal> is the number of the display to use. Up to 4 digits.<?asciidoc-br?></simpara>
<simpara><literal><emphasis>data</emphasis></literal> is the value between 0 and 255. Where <emphasis>data</emphasis> is the representation of the segments to be set.</simpara>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<screen>      'This program will count from 10 to 0 then fire the rocket!
      'The method DisplaySegment 1, smallTCharacter.  Sets the 7 segment to the value of 120, see the constant, 120 equates to a small t.
      ; ----- Configuration

        #chip 16F690, 4

      ; ----- Define Hardware settings
        Dir PORTC Out
        DIR PORTA.5 out
        DIR PORTA.4 out
        DIR PORTA.0 out
        DIR PORTA.1 out
        DIR PORTA.2 in
        DIR PORTB.7 out
      ; ----- Constants
        ; You need to specify the port settings
        #define DISP_SEG_A PORTC.0
        #define DISP_SEG_B PORTC.1
        #define DISP_SEG_C PORTC.2
        #define DISP_SEG_D PORTC.3
        #define DISP_SEG_E PORTC.4
        #define DISP_SEG_F PORTC.5
        #define DISP_SEG_G PORTC.6
        #define DECPNT     PORTC.7
        #define DISP_SEL_1 PORTA.5
        #define DISP_SEL_2 PORTA.4
        #define DISP_SEL_3 PORTA.1
        #define DISP_SEL_4 PORTA.0

        #define smallTCharacter 120 'raw character for 't' on 7 segment.

        #define sw1 PORTA.2

        #define firingPort PORTB.7

      ; ----- Variables
        CountDownValue = 10

      ; ----- Main body of program commences here.
      DECPNT = 1 'Decimal Point off

        Main:
          ' Push number to 7 Segment Display
        if sw1 = 0 then goto Countdown

         num2 = 1
         num3 = 0
         cnt = 5
         gosub display

      goto main

        Countdown:


          num2 = CountDownValue/10
          num3 = CountDownValue%10
          cnt = 60

          gosub display

          If sw1 = 0 then goto hld

          if CountDownValue = 0 then
              firingPort = 1
              cnt = 200
              gosub dispfire
              firingPort = 0
             CountDownValue = 10
             goto main
          end if

          CountDownValue = CountDownValue - 1

        goto Countdown


        display:
         Repeat cnt
                DisplaySegment 1, smallTCharacter
                wait 5 ms
                Displaychar 2, "-"
                DisplayValue 3, Num2
                wait 5 ms
                DisplayValue 4, Num3
                wait 5 ms
         end Repeat

         return

       hld:
        if sw1 = 0 then goto hld
        cnt = 5
        gosub Display
        if sw1 = 1 then goto hld
        goto countdown

       DispFire:
        Repeat cnt

                Displaychar 1, "F"
                wait 5 ms
                Displaychar 2, "i"
                wait 5 ms
                Displaychar 3, "r"
                wait 5 ms
                Displaychar 4, "E"
                wait 5 ms
        End Repeat
       return

      end</screen>
<simpara><emphasis role="strong">Also, see</emphasis> <link linkend="_7_segment_displays_overview">7 Segment Display Overview</link>, <link linkend="_displaychar">DisplayChar</link></simpara>
</section>
</section>
<section xml:id="_7_segment_displays_tm1637_4_digits">
<title>7 Segment Displays - TM1637 4 Digits</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>The TM1637 disaplay module is used for displaying numbers on a keyboard matrix.&#160;&#160;
The matrix of LEDs consists of four 7- segment displays working together.&#160;&#160;</simpara>
<simpara>The TM1637 specification is</simpara>
<itemizedlist>
<listitem>
<simpara>Two wire interface</simpara>
</listitem>
<listitem>
<simpara>Eight adjustable luminance levels</simpara>
</listitem>
<listitem>
<simpara>3.3V/5V interface</simpara>
</listitem>
<listitem>
<simpara>Supports Four alpha-numeric digits</simpara>
</listitem>
<listitem>
<simpara>Operating current consumption: 80mA
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Why to use TM1637 Display Module?</emphasis></simpara>
<simpara>The TM1637 can be interfaced to any system using only two ports.&#160;&#160;
This is the main reason the module is preferred over other module.</simpara>
<simpara>Another reason TM1637 display is preferred is because of its low cost. &#160;&#160;
Although there are other display modules present in the market they cost more.</simpara>
<simpara>The module design is robust so it can sustain in tough environments and still can perform its function for a long time.&#160;&#160;
The module consumes low power and can be installed in mobile applications.&#160;&#160;</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">How to use TM1637 Display Module?</emphasis></simpara>
<simpara>As mentioned earlier the module communication can only be done using the two pins DIO and CLK respectively.&#160;&#160;
The data is sent to the module or received from the module though these two pins.&#160;&#160;
So the characters to be displayed are sent in the form of serial data through this interface.
A typical circuit diagram of display module interface to a controller is shown below.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/Display-Module-Interface-with-Controller.png" contentdepth="70%" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The module can work on +5V regulated power and any higher voltage may lead to permanent damage.&#160;&#160;
The interface is established as shown in figure above.&#160;&#160;
All you need to do is connect DIO and CLK to any of GPIO (General Purpose Input Output) pins of controller and establish serial data exchange through programming.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">GCBASIC Support</emphasis></simpara>
<simpara>The GCBASIC 7 segment display methods make it easier for GCBASIC programs to display numbers and letters on 7 segment LED displays.</simpara>
<simpara>The GCBASIC methods support up to four digit 7 segment display devices, common anode/cathode and inversion of the port logic to support driving the device(s) via a transistor.</simpara>
<simpara>Brightness can be set: 8 is display on minimum bright , 15 is display on max bright. Less than 8  is display off.</simpara>
<simpara>The TM1637 chip supports the reading of the keyboard matrix however that is not supported in the library.</simpara>
<simpara><emphasis role="strong">DataSheets</emphasis></simpara>
<simpara>The datasheets can found here:</simpara>
<simpara>English -  <link xlink:href="http://gcbasic.sourceforge.net/library/TM1637/TM1637_V2.4_EN.pdf">here</link>.</simpara>
<simpara>Chinese - <link xlink:href="http://gcbasic.sourceforge.net/library/TM1637/TM1637_V2.4.pdf">here</link>.</simpara>
<simpara><emphasis role="strong">Usage</emphasis></simpara>
<simpara>The following will set the display.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>TM1637_CLK</simpara></entry>
<entry align="left" valign="top"><simpara>Must be a bi-directional port.&#160;&#160;
The direction/port setting is managed by the library.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TM1637_DIO</simpara></entry>
<entry align="left" valign="top"><simpara>Must be a bi-directional port.&#160;&#160;
The direction/port setting is managed by the library.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example program</emphasis></simpara>
<screen>  #chip mega328p,16
  #include &lt;TM1637a.h&gt;

  #define TM1637_CLK PortD.2      ' Arduino Digital_2
  #define TM1637_DIO PortD.3      ' Arduino Digital_3

  '---- main program --------

    TMWrite4Dig (17, 16, 17, 16, 0) 'clear display
      wait 2 s
    TMWrite4Dig (17, 16, 17, 16, 10,0) '- -
      wait 2 s
    TMchar_Bright = 10</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<section xml:id="_tmwrite4dig">
<title>TMWrite4Dig</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    TMWrite4Dig (dig1, dig2, dig3, dig4  [, Brightness ],  Colon ]  ] )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Command defines each digit (left to right) as 0 to 9  OR 0x00 to 0x0F  (15). Additionally  0x10  (16) is a blank, 0x11 (17) is a minus sign, 0x12 (18) is a degree sign,  0x13 (19) is a  bracket and 0x14 (20) is a question mark.</simpara>
<simpara><emphasis>Brightness</emphasis> set the brightness (8-15).
<emphasis>Colon</emphasis>  turns the colon (only on  digit 2) to off (0) or on (1).
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_tm_bright">
<title>TM_Bright</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    TM_Bright = Brightness</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><emphasis>Brightness</emphasis> sets the brightness for the display with a range of 8 to 15.&#160;&#160;
Default to 15.&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_tmdec">
<title>TMDec</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    TMDec  Value [, Options ]</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><emphasis>Value</emphasis> is a word value.&#160;&#160;
Only values from 0 to 9999 can be displayed, values greater than 9999 will be  displayed as ----.</simpara>
<simpara><emphasis>Options</emphasis> as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>0 or omitted, only decimal value will be displayed;</simpara>
</listitem>
<listitem>
<simpara>1 decimal valur with  the leading zeros;</simpara>
</listitem>
<listitem>
<simpara>2 decimal number with the colon on digit 2;</simpara>
</listitem>
<listitem>
<simpara>3 decimal number with the colon on digit 2 and the leading zeros.</simpara>
</listitem>
</itemizedlist>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_tmhex">
<title>TMHex</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    TMHex  Value</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><emphasis>Value</emphasis> is a word value.&#160;&#160;
Only values from from 0x0000 to 0xFFFF can be displayed. Non-hex values will be displayed as greater than 9999 will be  displayed ??.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_tmwritechar">
<title>TMWriteChar</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    TMWriteChar ( TMaddr, TMchar )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><emphasis>TMaddr</emphasis> is 0 , 1 , 2 , 3 (display left to right)
<emphasis>TMchar</emphasis> is a letter from A to Z (default alphabet) or from <literal>a</literal> to <literal>z</literal> Siekoo alphabet by Alexander Fakoo, more info at: <link xlink:href="http://en.fakoo.de/siekoo.html">http://en.fakoo.de/siekoo.html</link>. &#160;&#160;
You can insert the special characters (blank, -, ) and/or ?).
<?asciidoc-br?>
<?asciidoc-br?>
Character map:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/TM1657a.png" contentdepth="70%" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
</section>
<section xml:id="_7_segment_displays_tm1637_6_digits">
<title>7 Segment Displays - TM1637 6 Digits</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>The TM1637 display module is used for displaying numbers on a keyboard matrix.&#160;&#160;
The matrix of LEDs consists of six 7- segment displays working together.&#160;&#160;</simpara>
<simpara>The TM1637 specification is</simpara>
<itemizedlist>
<listitem>
<simpara>Two wire interface</simpara>
</listitem>
<listitem>
<simpara>Eight adjustable luminance levels</simpara>
</listitem>
<listitem>
<simpara>3.3V/5V interface</simpara>
</listitem>
<listitem>
<simpara>Supports six alpha-numeric digits</simpara>
</listitem>
<listitem>
<simpara>Operating current consumption: 80mA
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Using the TM1637 Display Module</emphasis></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/TM1637_6d.gif" contentdepth="40%" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Why to use TM1637 Display Module?</emphasis></simpara>
<simpara>The TM1637 can be interfaced to any system using only two ports.&#160;&#160;
This is the main reason the module is preferred over other module.</simpara>
<simpara>Another reason TM1637 display is preferred is because of its low cost. &#160;&#160;
Although there are other display modules present in the market they cost more.</simpara>
<simpara>The module design is robust so it can sustain in tough environments and still can perform its function for a long time.&#160;&#160;
The module consumes low power and can be installed in mobile applications.&#160;&#160;</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">How to use TM1637 Display Module?</emphasis></simpara>
<simpara>As mentioned earlier the module communication can only be done using the two pins DIO and CLK respectively.&#160;&#160;
The data is sent to the module or received from the module though these two pins.&#160;&#160;
So the characters to be displayed are sent in the form of serial data through this interface.
A typical circuit diagram of display module interface to a controller is shown below.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/Display-Module-Interface-with-Controller.png" contentdepth="70%" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The module can work on +5V regulated power and any higher voltage may lead to permanent damage.&#160;&#160;
The interface is established as shown in figure above.&#160;&#160;
All you need to do is connect DIO and CLK to any of GPIO (General Purpose Input Output) pins of controller and establish serial data exchange through programming.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">GCBASIC Support</emphasis></simpara>
<simpara>The GCBASIC 7 segment display methods make it easier for GCBASIC programs to display numbers and letters on 7 segment LED displays.</simpara>
<simpara>The GCBASIC methods supports six 7 segment display devices, common anode/cathode and inversion of the port logic to support driving the device(s) via a transistor.</simpara>
<simpara>Brightness can be set: 8 is display on minimum bright , 15 is display on max bright. Less than 8  is display off.</simpara>
<simpara>The TM1637 chip supports the reading of the keyboard matrix however that is not supported in the library.</simpara>
<simpara><emphasis role="strong">DataSheets</emphasis></simpara>
<simpara>The datasheets can found here:</simpara>
<simpara>English -  <link xlink:href="http://gcbasic.sourceforge.net/library/TM1637/TM1637_V2.4_EN.pdf">here</link>.</simpara>
<simpara>Chinese - <link xlink:href="http://gcbasic.sourceforge.net/library/TM1637/TM1637_V2.4.pdf">here</link>.</simpara>
<simpara><emphasis role="strong">Usage</emphasis></simpara>
<simpara>The following will set the display.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>TM1637_CLK</simpara></entry>
<entry align="left" valign="top"><simpara>Must be a bi-directional port.&#160;&#160;
The direction/port setting is managed by the library.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TM1637_DIO</simpara></entry>
<entry align="left" valign="top"><simpara>Must be a bi-directional port.&#160;&#160;
The direction/port setting is managed by the library.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example program</emphasis></simpara>
<screen>  #chip mega328p,16
  #include &lt;TM1637a.h&gt;

  #define TM1637_CLK PortD.2      ' Arduino Digital_2
  #define TM1637_DIO PortD.3      ' Arduino Digital_3

  '---- main program --------

    TMWrite6Dig (17, 16, 17, 16, 0) 'clear display
      wait 2 s
    TMWrite6Dig (17, 16, 17, 16, 10,0) '- -
      wait 2 s
    TMchar_Bright = 10</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<section xml:id="_tmwrite6dig">
<title>TMWrite6Dig</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    TMWrite6Dig (dig1, dig2, dig3, dig4, dig5, dig6, Brightness,  Point)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Command defines each digit (left to right) as 0 to 9  or 0x00 to 0x0F  (15). Additionally  0x10  (16) is a blank, 0x11 (17) is a minus sign, 0x12 (18) is a degree sign,  0x13 (19) is a  bracket and 0x14 (20) is a question mark.</simpara>
<simpara><emphasis>Brightness</emphasis> set the brightness (8-15).
<emphasis>Colon</emphasis>  turns the colon (only on  digit 2) to off (0) or on (1).
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_tm_bright_2">
<title>TM_Bright</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    TM_Bright = Brightness</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><emphasis>Brightness</emphasis> sets the brightness for the display with a range of 8 to 15.&#160;&#160;
Default to 15.&#160;&#160;</simpara>
<simpara>TM_Bright must be defined before the first use the commands: TMDec, TMHex or TMWriteChar, to set the brightness of the characters (8-15), without this, the display will be blank.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_tmdec_2">
<title>TMDec</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    TMDec  Value [, Options ]</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><emphasis>Value</emphasis> is a word value.&#160;&#160;
Only values from 0 to 9999 can be displayed, values greater than 9999 will be  displayed as ----.</simpara>
<simpara><emphasis>Options</emphasis> as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>0 or omitted, only decimal value will be displayed;</simpara>
</listitem>
<listitem>
<simpara>1 decimal valur with  the leading zeros;</simpara>
</listitem>
<listitem>
<simpara>2 decimal number with the colon on digit 2;</simpara>
</listitem>
<listitem>
<simpara>3 decimal number with the colon on digit 2 and the leading zeros.</simpara>
</listitem>
</itemizedlist>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_tmhex_2">
<title>TMHex</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    TMHex  Value</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><emphasis>Value</emphasis> is a word value.&#160;&#160;
Only values from from 0x0000 to 0xFFFF can be displayed. Non-hex values will be displayed as greater than 9999 will be  displayed ??.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_tmwritechar_2">
<title>TMWriteChar</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    TMWriteChar ( TMaddr, TMchar )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><emphasis>TMaddr</emphasis> is 0 , 1 , 2 , 3 4, 5 (display left to right)
<emphasis>TMchar</emphasis> is a letter from A to Z (default alphabet) or from <literal>a</literal> to <literal>z</literal> Siekoo alphabet by Alexander Fakoo, more info at: <link xlink:href="http://en.fakoo.de/siekoo.html">http://en.fakoo.de/siekoo.html</link>. &#160;&#160;
You can insert the special characters (blank, -, ) and/or ?).
<?asciidoc-br?>
<?asciidoc-br?>
Character map:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/TM1657a.png" contentdepth="70%" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_tm_point">
<title>TM_Point</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    TM_Point = (Point)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Must be defined before use the command TMDec to set the decimal point(s)</simpara>
<simpara>Rules for decimal points</simpara>
<simpara>You can use the TM_Point and TMWrite6dig commands to turn on one or more decimal points.&#160;&#160;
This is achieved with an 8-bit binary number, with the leftmost bit (MSB) representing the 1st decimal point, the next the 2nd, and so on.&#160;&#160;
The state of the last two bits is ignored because it is only 6 digits.&#160;&#160;</simpara>
<simpara>Examples:</simpara>
<simpara>• binary number 0B01010000 (decimal 80) switch on decimal point on digits 2 and 4.
• number 0 switch off all digital points
• 255 (0B11111111) switch all on.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
</section>
</section>
</section>
<section xml:id="_one_wire_devices">
<title>One Wire Devices</title>
<simpara>This is the One Wire Devices section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_ds18b20">
<title>DS18B20</title>
<simpara>The DS18B20 is a 1-Wire digital temperature sensor from Maxim IC.</simpara>
<simpara>The sensor reports degrees C with 9 to 12-bit precision from -55C to 125C (+/- 0.5C).</simpara>
<simpara>Each sensor has a unique 64-Bit Serial number etched into it. This allows for a number of sensors to be used on one data bus. This sensor is used in many data-logging and temperature control projects.</simpara>
<simpara>Reading the temperature from a DS18B20 takes up to 750ms(max).</simpara>
<simpara>To use the DS18B20 driver the following is required to added to the GCBASIC source file.</simpara>
<screen>    #include &lt;DS18B20.h&gt;</screen>
<simpara>Note the GCBASIC commands do not work with the older DS1820 or DS18S20 as they have a different internal resolution.</simpara>
<simpara>These commands are not designed to be used with parasitically powered DS18B20 sensors.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="10*"/>
<colspec colname="col_2" colwidth="60*"/>
<colspec colname="col_3" colwidth="30*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Usage</entry>
<entry align="left" valign="top">Returns</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ReadDigitalTemp</simpara></entry>
<entry align="left" valign="top"><simpara>Returns two global variables.&#160;&#160;As follows:
</simpara><simpara><emphasis role="strong"><literal>DSint</literal></emphasis> the integer value read from the sensors
<emphasis role="strong"><literal>DSdec</literal></emphasis> the string value read from the sensors</simpara></entry>
<entry align="left" valign="top"><simpara>Byte variables:
<emphasis role="strong"><literal>DSint</literal></emphasis>
</simpara><simpara>String variable: <emphasis role="strong"><literal>DSdec</literal></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ReadTemp</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><literal>ReadTemp</literal></emphasis> is a function that returns the raw value of the sensor.
</simpara><simpara>The temperature is read back in whole degree steps, and the sensor operates from -55 to + 125 degrees Celsius.;&#160;&amp;#160Note that bit 7 is 0 for positive temperature values and 1 for negative values (ie negative values will appear as 128 + numeric value).</simpara></entry>
<entry align="left" valign="top"><simpara>Word variable via the ReadTemp() function</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ReadTemp12</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><literal>ReadTemp</literal></emphasis> is a function that returns the raw 12bit value of the sensor.
</simpara><simpara>The temperature is read back as the raw 12 bit data into a word variable (0.0625 degree resolution).;&#160;&amp;#160The user must interpret the data through mathematical manipulation. See the DS18B20 datasheet for more information on the 12 bit temperature/data information construct.</simpara></entry>
<entry align="left" valign="top"><simpara>Word variable via the ReadTemp12() function</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_readdigitaltemp">ReadDigitalTemp</link>, <link linkend="_readtemp">ReadTemp</link> or <link linkend="_readtemp12">ReadTemp12</link></simpara>
</section>
<section xml:id="_readdigitaltemp">
<title>ReadDigitalTemp</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ReadDigitalTemp</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Return the value of the sensor in two global variables. The following two lines must be included in the GCBASIC source file.</simpara>
<screen>    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required</screen>
<simpara>This method returns whole part of the sensor value in the byte variable <literal>DSint</literal>, the method also returns decimal part of the sensor value in the byte variable <literal>DSdec</literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Chip Settings. Assumes the development board with with a 16F877A
    #chip 16F877A,1

    *#include &lt;DS18B20.h&gt;*

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

    ' DS18B20 port settings
    #define DQ PortC.3

    do forever

        ReadDigitalTemp

        ' Display the integer value of the sensor on the LCD
        cls
        print "Temp"
        locate 0,8
        print DSInt
        print "."
        print DSdec
        print chr(223)+"C"
        wait 2 s

    loop</screen>
</section>
<section xml:id="_readtemp">
<title>ReadTemp</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    byte_var = ReadTemp</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>ReadTemp</literal> is a  function that returns the raw value of the sensor. The following two lines must be included in the GCBASIC source file.</simpara>
<screen>    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required</screen>
<simpara><literal>ReadTemp</literal> reads the sensor and stores in output variable. The conversion takes up to 750ms. Readtemp carries out a full 12 bit conversion and then rounds the result to the nearest full degree Celsius.</simpara>
<simpara>To read the full 12 bit value of the sensor use the <literal>readtemp12</literal> command.</simpara>
<simpara>The temperature is read back in whole degree steps, and the sensor operates from -55 to + 125 degrees Celsius. Note that bit 7 is 0 for positive temperature values and 1 for negative values (ie negative values will appear as 128 + numeric value).</simpara>
<simpara>Note the <literal>Readtemp</literal> command does not work with the older DS1820 or DS18S20 as they have a different internal resolution. This command is not designed to be used with parasitically powered DS18B20 sensors, the 5V pin of the sensor must be connected.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Chip Settings. Assumes the development board with with a 16F877A
    #chip 16F877A,1

    #include &lt;DS18B20.h&gt;

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

    ' DS18B20 port settings
    #define DQ PortC.3

      ccount = 0
      CLS

    do forever
       ' The function readtemp returns the integer value of the sensor
       DSdata = readtemp

       ' Display the integer value of the sensor on the LCD
       locate 0,0
       print hex(ccount)
       print " Ceil"
       locate 0,8
       print DSdata
       print chr(223)+"C"

       wait 2 s
       ccount++

    loop</screen>
</section>
<section xml:id="_readtemp12">
<title>ReadTemp12</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    byte_var = ReadTemp12</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>ReadTemp12</literal> is a  function that returns the raw value of the sensor. The following two lines must be included in the GCBASIC source file.</simpara>
<screen>    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required</screen>
<simpara>Reads sensor and stores in output variable. The conversion takes up to 750ms. <literal>Readtemp12</literal> carries out a full 12 bit conversion.</simpara>
<simpara>This command is for advanced users only. For standard ‘whole degree’ data use the <literal>Readtemp</literal> command.</simpara>
<simpara>The temperature is read back as the raw 12 bit data into a word variable (0.0625 degree resolution). The user must interpret the data through mathematical manipulation. See the DS18B20 datasheet for more information on the 12 bit temperature/data information construct.</simpara>
<simpara>The function <literal>readtemp12</literal> does not work with the older DS1820 or DS18S20 as they have a different internal resolution. This command is not designed to be used with parasitically powered DS18B20 sensors, the 5V pin of the sensor must be connected.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Chip Settings. Assumes the development board with with a 16F877A
    #chip 16F877A,1

    <emphasis role="strong">#include &lt;DS18B20.h&gt;</emphasis>

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

; ----- DS18B20 port settings
    #define DQ PortC.3

; ----- Variables
    Dim TempC_100 as word   ' a variabler to handle the temperature calculations
    Dim CCOUNT, SIGNBIT, WHOLE, FRACT, DIG as Byte
    Dim TempC_100 as word   ' a variable to handle the temperature calculations

    ccount = 0
    CLS

    do forever

       'Display the integer and decimal value of the sensor on the LCD

       ' The function readtemp12 returns the raw value of the sensor.
       ' The sensor is read as a 12 bit value. Each unit equates to 0.0625 of a degree
       DSdata = readtemp12
       SignBit = DSdata / 256 / 128
       If SignBit = 0 Then goto Positive
       ' its negative!
       DSdata = ( DSdata # 0xffff ) + 1 ' take twos comp

    Positive:

       ' Convert value * 0.0625. Mulitple value by 6 then add result to multiplication of the value with 25 then divide result by 100.
       TempC_100 =  DSdata * 6
       DSdata = ( DSdata * 25 ) / 100
       TempC_100 = TempC_100 + DSdata

       Whole = TempC_100 / 100
       Fract = TempC_100 % 100
       If SignBit = 0 Then goto DisplayTemp
       Print "-"

    DisplayTemp:
       locate 1,0
       print hex(ccount)
       print " Real"
       locate 1,8
       print str(Whole)
       print "."
      ' To ensure the decimal part is two digits
       Dig = Fract / 10
       print Dig
       Dig = Fract % 10
       print Dig
       print chr(223)
       print "C"
       wait 2 s
       ccount++

    loop</screen>
</section>
<section xml:id="_ds18b20setresolution">
<title>DS18B20SetResolution</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara>For Single Channel/Device only. The method assumes a single DS18B20 device on the OneWire bus.</simpara>
<screen>    DS18B20SetResolution ( [DS18B20SetResolution_CONTSTANT] )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Set the DS18B20 operating resolution.&#160;&#160;
The configuration register of the DS18B20 allows the user to set the resolution of the temperature-to-digital conversion to 9, 10, 11, or 12 bits. &#160;&#160;
This method set the operating resolution to either 9, 10, 11, or 12 bits.&#160;&#160;</simpara>
<simpara>Calling the method with no parameter will set the operating resolution of the DS18B20 to 12 bits.&#160;&#160;
See example 3 below.</simpara>
<simpara><emphasis role="strong">Constants</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">CONSTANT</entry>
<entry align="left" valign="top">Operating resolution</entry>
<entry align="left" valign="top">Temprature resolution</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>DS18B20_TEMP_9_BIT</simpara></entry>
<entry align="left" valign="top"><simpara>9 bits</simpara></entry>
<entry align="left" valign="top"><simpara>0.5c</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS18B20_TEMP_10_BIT</simpara></entry>
<entry align="left" valign="top"><simpara>10 bits</simpara></entry>
<entry align="left" valign="top"><simpara>0.25c</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS18B20_TEMP_11_BIT</simpara></entry>
<entry align="left" valign="top"><simpara>11 bits</simpara></entry>
<entry align="left" valign="top"><simpara>0.125c</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS18B20_TEMP_12_BIT</simpara></entry>
<entry align="left" valign="top"><simpara>12 bits</simpara></entry>
<entry align="left" valign="top"><simpara>0.0625c</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<emphasis role="strong">Example Usage 1</emphasis></simpara>
<simpara>The follow example sets the operating resolution of the DS18B20 to 12 bits.</simpara>
<screen>    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required
    DS18B20SetResolution ( DS18B20_TEMP_12_BIT )</screen>
<simpara><emphasis role="strong">Example Usage 2</emphasis></simpara>
<simpara>The follow example sets the operating resolution of the DS18B20 to 9 bits.</simpara>
<screen>    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required
    DS18B20SetResolution ( DS18B20_TEMP_9_BIT )</screen>
<simpara><emphasis role="strong">Example Usage 3</emphasis></simpara>
<simpara>The follow example sets the operating resolution of the DS18B20 to the default value of 12 bits.</simpara>
<screen>    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required
    DS18B20SetResolution ( )</screen>
<simpara><emphasis role="strong">Working Example Program</emphasis></simpara>
<simpara>The following program will display the temperature on a serial attached LCD.&#160;&#160;
Change the <literal>DS18B20SetResolution ()</literal> method to set the resolution of a specific setting.</simpara>
<simpara>You may need to change the chip, edit/remove PPS, and/or the change LCD settings to make this program work with your configuration.&#160;&#160;</simpara>
<screen>#chip 16f18313
#config MCLR=ON
#option Explicit
#include &lt;ds18b20.h&gt;

    'Generated by PIC PPS Tool for GCBASIC
    'PPS Tool version: 0.0.6.1
    'PinManager data: v1.79.0
    'Generated for 16f18313
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85
    #define PPSToolPart 16f18313

    Sub InitPPS

            'Module: EUSART
            RA5PPS = 0x0014    'TX &gt; RA5

    End Sub
    'Template comment at the end of the config file

    'USART settings for USART1
    #define USART_BAUD_RATE 115200
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF

    #define LCD_IO 107   'K107
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width


    ; ----- Constants
    ' DS18B20 port settings
    #define DQ RA4

; ----- Variables
  dim TempC_100 as LONG   ' a variabler to handle the temperature calculations
  Dim DSdata,WHOLE, FRACT, DIG as word
  Dim CCOUNT, SIGNBIT as Byte


; ----- Main body of program commences here.

    ccount = 0
    CLS
    print "GCBasic 2021"
    locate 1,0
    print "DS18B20 Demo"
    wait 2 s
    CLS

    DS18B20SetResolution ( DS18B20_TEMP_12_BIT )

    do forever
       ' The function readtemp returns the integer value of the sensor
       DSdata = readtemp

       ' Display the integer value of the sensor on the LCD
       locate 0,0
       print hex(ccount)
       print " Ceil"
       locate 0,8
       print DSdata
       print chr(223)+"C"



       ' Display the integer and decimal value of the sensor on the LCD

       ' The function readtemp12 returns the raw value of the sensor.
       ' The sensor is read as a 12 bit value therefore each unit equates to 0.0625 of a degree
       DSdata = readtemp12


       SignBit = DSdata / 256 / 128
       If SignBit = 0 Then goto Positive
       ' its negative!
       DSdata = ( DSdata # 0xffff ) + 1 ' take twos comp


    Positive:
       ' Convert value * 0.0625 by factorisation
       TempC_100 =  DSdata *  625
       Whole = TempC_100 / 10000
       Fract = TempC_100 % 10000


       If SignBit = 0 Then goto DisplayTemp
       Print "-"

    DisplayTemp:
       Locate 3,0
       Print Whole
       Print "."
       Print leftpad( str(Fract),4,"0")

       wait 2 s
       ccount++

    loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
</section>
<section xml:id="_serial_communications">
<title>Serial Communications</title>
<simpara>This is the Serial Communications section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_rs232_software">
<title>RS232 (software)</title>
<simpara>This is the Software Serial Communications section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_rs232_software_overview">
<title>RS232 Software Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>These routines allow the microcontroller to send and receive RS232 data.</simpara>
<simpara>All functions are implemented using software, so no special hardware is
required on the microcontroller. However, if the microcontroller has a
hardware serial module (usually referred to as UART or USART), and the
serial data lines are connected to the appropriate pins, the hardware
routines should be used for smaller code, improved reliability and
higher baud rates.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the RS232 serial
communication routines. To set them, place a line in the main program
file that uses <literal>#define</literal> to assign a value to the particular constant.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name/s</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>SendALow</literal>, <literal>SendBLow</literal>, <literal>SendCLow</literal></simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define the commands used to send a low (0) bit on
serial channels A, B and C respectively.</simpara></entry>
<entry align="left" valign="top"><simpara>No Default<?asciidoc-br?>
<emphasis role="strong">Must be defined</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SendAHigh</literal>, <literal>SendBHigh</literal>, <literal>SendCHigh</literal></simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define the commands used to send a high (1) bit on
serial channels A, B and C respectively.</simpara></entry>
<entry align="left" valign="top"><simpara>No Default<?asciidoc-br?>
<emphasis role="strong">Must be defined</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>RecALow</literal>, <literal>RecBLow</literal>, <literal>RecCLow</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The condition that is true when a low bit is being received</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Sys232Temp.0 OFF</literal><?asciidoc-br?>
<emphasis role="strong">Must be defined</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>RecAHigh</literal>, <literal>RecBHigh</literal>, <literal>RecCHigh</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The condition that is true when a high bit is being received</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Sys232Temp.0 ON</literal><?asciidoc-br?>
<emphasis role="strong">Must be defined</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_initser">
<title>InitSer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>	<literal>InitSer</literal> <emphasis>channel, rate, start, data, stop, parity, invert</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will set up the serial communications. The parameters are
as follows:</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is 1, 2 or 3, and refers to the I/O ports that are used for
communication.</simpara>
<simpara><literal><emphasis>rate</emphasis></literal> is the bit rate, which is given by the letter r and then the
desiredrate in bps. Acceptable units are r300, r600, r1200, r2400,
r4800, r9600 and r19200.</simpara>
<simpara><literal><emphasis>start</emphasis></literal> gives the number of start bits, which is usually 1. To make
the microcontroller wait for the start bit before proceeding with the receive, add
128 to <literal><emphasis>start</emphasis></literal>. (Note: it may be desirable to use the <literal>WaitForStart</literal>
constant here.)</simpara>
<simpara><literal><emphasis>data</emphasis></literal> tells the program how many data bits are to be sent or received.
In most situations t his is 8, but it can range between 1 and 8,
inclusive.</simpara>
<simpara><literal><emphasis>stop</emphasis></literal> is the number of stop bits. If <emphasis>start</emphasis> bit 7 is on, then this
number will be ignored.</simpara>
<simpara><literal><emphasis>parity</emphasis></literal> refers to a system of error checking used by many devices. It
can be odd (in which there must always be an odd number of high bits),
even (where the number of high bits must always be even), or none (for
systems that do not use parity).</simpara>
<simpara><literal><emphasis>invert</emphasis></literal> can be either "normal" or "invert". If it in "invert", then
high bits will be changed to low, and low to high.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>Please refer to <link linkend="_sersend">SerSend</link> for an example of <literal>InitSer</literal></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_rs232_software_overview">RS232 Software Overview</link></simpara>
</section>
<section xml:id="_sersend">
<title>SerSend</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  SerSend <emphasis>channel</emphasis>, <emphasis>data</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will send a byte given by <literal><emphasis>data</emphasis></literal> using the RS232 channel
referred to as <literal><emphasis>channel</emphasis></literal> according to the rules set using <literal>InitSer</literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program will send a byte using PORTB.2, the value of which
  'depends on whether a button is pressed. This can be used with the example for SerReceive.

  #chip 16F819, 8

  #define RS232Out PORTB.2
  #define RS232In  PORTB.1

  Dir RS232Out Out
  Dir RS232In In

  'Config Software-UART
  #define SendAHigh Set RS232Out ON
  #define SendALow Set RS232Out OFF
  #define RecAHigh Set RS232In ON
  #define RecALow Set RS232In OFF

  Dir Button In

  InitSer 1, r9600, 1+WaitForStart, 8, 1, none, normal
  Do
    If Button = On Then Temp = 100
    If Button = Off Then Temp = 0
    SerSend 1, Temp
    Wait 100 ms
  Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_rs232_software_overview">RS232 Software Overview</link>,
<link linkend="_initser">InitSer</link></simpara>
</section>
<section xml:id="_serreceive">
<title>SerReceive</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  SerReceive <emphasis>channel</emphasis>, <emphasis>output</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will read a byte from the RS232 channel given by
<literal><emphasis>channel</emphasis></literal> according to the rules set using <literal>InitSer</literal>, and store the
received byte in the variable <literal><emphasis>output</emphasis></literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program will read a byte from PORTB.2, and set the LED on if
  'the byte is more than 50. This can be used with the SerSend
  'example program.

  #chip 16F88, 8

  #define RecAHigh PORTB.2 ON
  #define RecALow PORTB.2 OFF
  #define LED PORTB.0

  Dir PORTB.0 Out
  Dir PORTB.2 In

  InitSer 1, r9600, 1 + WaitForStart, 8, 1, none, normal
  Do
    SerReceive 1, Temp
    If Temp &lt;= 50 Then Set LED Off
    If Temp &gt; 50 Then Set LED On
  Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_rs232_software_overview">RS232 Software Overview</link>,
<link linkend="_initser">InitSer</link></simpara>
</section>
<section xml:id="_serprint">
<title>SerPrint</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  SerPrint <emphasis>channel, value</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>SerPrint</literal> is used to send a value over the serial connection. <literal><emphasis>value</emphasis></literal> can
be a string, integer, long, word or byte.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is the serial connection to send data through (1 | 2 |3 ).</simpara>
<simpara><literal>SerPrint</literal> will not send any new line characters. If the chip is sending
to a terminal, these commands should follow <literal>SerPrint</literal>.</simpara>
<screen>    SerSend channel, 13
    SerSend channel, 10</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will display any values received over the serial
    'connection. If "pot" is received, the value of the analog sensor
    'will be sent.

    'Chip settings
    #chip 18F2525, 8

    'LCD settings
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PORTC.7
    #define LCD_RW PORTC.6
    #define LCD_Enable PORTC.5
    #define LCD_DB4 PORTC.4
    #define LCD_DB5 PORTC.3
    #define LCD_DB6 PORTC.2
    #define LCD_DB7 PORTC.1

    'Serial settings
    #define RS232Out PORTB.0
    #define RS232In  PORTB.1

    'Set pin direction
    Dir RS232Out Out
    Dir RS232In In

    'Config Software-UART
    #define SendAHigh Set RS232Out ON
    #define SendALow Set RS232Out OFF
    #define RecAHigh Set RS232In ON
    #define RecALow Set RS232In OFF
    set RS232Out On

    Do
      'Potentiometer
      #define POT_PORT PORTA.0
      #define POT_AN AN0

      'Set pin direction
      Dir POT_PORT In

      'Create buffer variables to store received messages
      Dim Buffer As String
      Dim OldBuffer As String
      BufferSize = 0

      'Set up serial connection
      InitSer 1, r9600, 1 + WaitForStart, 8, 1, none, invert

      'Show test messages
      Print "Serial Tester"
      Wait 1 s
      SerPrint 1, "GCBASIC RS232 Test"
      SerSend 1, 13
      SerSend 1, 10
      Wait 1 s

      'Main loop
     'Get a byte from the terminal
      SerReceive 1, Temp

      'If Enter key was pressed, deal with buffer contents
      If Temp = 13 Then
        Buffer(0) = BufferSize

        'Try to execute commands in buffer
        If Not ExecCommand (Buffer) Then
          'Show message on bottom line, last message on top.
          CLS
          Print OldBuffer
          Locate 1, 0
          Print Buffer
          'Store the message for next time
          OldBuffer = Buffer
        End If

        BufferSize = 0
      End If
      'Backspace code, delete last character in buffer
      If Temp = 8 Then
        If BufferSize &gt; 0 Then BufferSize -= 1
      End If
      'Received ASCII code between 32 and 127, add to buffer
      If Temp &gt;= 32 And Temp &lt;= 127 Then
        BufferSize += 1
        Buffer(BufferSize) = Temp
      End If
    Loop

    'Takes a sensor reading and sends it to terminal
    Sub SendSensorReading
      SerPrint 1, "Sensor Reading: "
      SerPrint 1, ReadAD10(POT_AN)
      SerSend 1, 13
      SerSend 1, 10
    End Sub

    'Will check the buffer for a command
    'If command found, run it and return true
    'If not, return false
    Function ExecCommand (CmdIn As String)
      ExecCommand = False
      'If received command is "pot", show potentiometer value
      If CmdIn = "pot" Then
        SendSensorReading
        ExecCommand = True
      End If
    End Function</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_rs232_software_overview">RS232 Software Overview</link></simpara>
</section>
</section>
<section xml:id="_rs232_software_optimised">
<title>RS232 (software optimised)</title>
<simpara>This is the Software Serial Communications section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_rs232_software_overview_optimised">
<title>RS232 Software Overview - Optimised</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>These routines allow the microcontroller to send and receive RS232 data.</simpara>
<simpara>SoftSerial is a library for the GCBASIC compiler and works on AVR and PIC microcontrollers.
These routines allow the microcontroller to send and receive RS232 data.
All functions are implemented using software, so no special hardware is required on the microcontroller.
SoftSerial uses ASM routines for minimal overhead.
If the microcontroller has a hardware serial module (usually referred to as UART or USART) the hardware routines can be used too.</simpara>
<simpara><emphasis role="strong">Features</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>3 independent channels Ser1&#8230;&#8203; , Ser2&#8230;&#8203; , Ser3&#8230;&#8203;</simpara>
</listitem>
<listitem>
<simpara>I/O pins user configurable</simpara>
</listitem>
<listitem>
<simpara>polarity can be inverted</simpara>
</listitem>
<listitem>
<simpara>freely adjustable baud rate</simpara>
</listitem>
<listitem>
<simpara>maximum baudrate depends on MCU speed</simpara>
<itemizedlist>
<listitem>
<simpara>PIC@ 1Mhz    9600 baud</simpara>
</listitem>
<listitem>
<simpara>PIC@ 4Mhz   38400 baud</simpara>
</listitem>
<listitem>
<simpara>PIC@ 8Mhz   64000 baud</simpara>
</listitem>
<listitem>
<simpara>PIC@16Mhz  128000 baud</simpara>
</listitem>
<listitem>
<simpara>AVR@ 1Mhz   28800 baud</simpara>
</listitem>
<listitem>
<simpara>AVR@ 8Mhz  115200 baud</simpara>
</listitem>
<listitem>
<simpara>AVR@16Mhz  460800 baud</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 - 8  data bits</simpara>
</listitem>
<listitem>
<simpara>1 or 2 stop bits</simpara>
</listitem>
<listitem>
<simpara>parity bit not supported</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the RS232 serial
communication routines. To set them, place a line in the main program
file that uses <literal>#define</literal> to assign a value to the particular constant.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Constant Name/s</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Valid Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>SER1_TXPORT,
SER2_TXPORT,
SER3_TXPORT</simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define the port for sending on serial channels 1, 2 and 3 respectively. Note, that we also have to define a PortPin (see next line). It is not necessary to define this, if we want to receive only.
Sample:  #define SER1_TXPORT PortB</simpara></entry>
<entry align="left" valign="top"><simpara>PORTA - PORTx</simpara></entry>
<entry align="left" valign="top"><simpara>No default defined.
An appropiate constant must be defined.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SER1_TXPIN,
SER2_TXPIN,
SER3_TXPIN</simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define the pin (the corresponding bit) for sending on serial channels 1, 2 and 3 respectively.
Sample:  #define SER1_TXPIN 0</simpara></entry>
<entry align="left" valign="top"><simpara>0 - 7</simpara></entry>
<entry align="left" valign="top"><simpara>No default defined.
An appropiate constant must be defined to enable the TX port.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SER1_RXPORT,
SER2_RXPORT,
SER3_RXPORT</simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define the port for receiving on serial channels 1, 2 and 3 respectively. Note, that we also have to define a PortPin (see next line). It is not necessary to define this, if we want to receive only.
Sample:  #define SER1_RXPORT PortA</simpara></entry>
<entry align="left" valign="top"><simpara>PORTA - PORTx</simpara></entry>
<entry align="left" valign="top"><simpara>No default defined.
An appropiate constant must be defined to enable the TX port.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SER1_RXPIN,
SER2_RXPIN,
SER3_RXPIN</simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define the pin (the corresponding bit) for receiving on serial channels 1, 2 and 3 respectively. It is not necessary to define this, if we want to send only.
Sample:  #define SER1_RXPIN 5</simpara></entry>
<entry align="left" valign="top"><simpara>0 - 7</simpara></entry>
<entry align="left" valign="top"><simpara>No default defined.
An appropiate constant must be defined to enable the RX port.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SER1_BAUD,
SER2_BAUD,
SER3_BAUD</simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define the baudrate for sending and receiving on serial channels 1, 2 and 3 respectively. It is not necessary to define this, if we want to send only.
Sample:  #define SER1_BAUD 19200</simpara></entry>
<entry align="left" valign="top"><simpara>75 - 512000</simpara></entry>
<entry align="left" valign="top"><simpara>No default defined.
An appropiate constant must be defined to enable the RX port.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SER1_DATABITS,
SER2_DATABITS,
SER3_DATABITS</simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define the databits for sending and receiving on serial channels 1, 2 and 3 respectively.
Sample:  #define SER1_DATABITS 7</simpara></entry>
<entry align="left" valign="top"><simpara>5 - 8</simpara></entry>
<entry align="left" valign="top"><simpara>Optional
Default = 8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SER1_STOPBITS,
SER2_STOPBITS,
SER3_STOPBITS</simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define the stopbits for sending and receiving on serial channels 1, 2 and 3 respectively.
Sample:  #define SER1_STOPBITS 2</simpara></entry>
<entry align="left" valign="top"><simpara>1, 2</simpara></entry>
<entry align="left" valign="top"><simpara>Optional
Default = 1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SER1_INVERT,
SER2_INVERT,
SER3_INVERT</simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define the polarity for sending and receiving on serial channels 1, 2 and 3 respectively. If it is "On", then high bits will be changed to low, and low to high. This is useful for connection to a PCs native serial port or USB-serial converters with  MAX232.
Sample:  #define SER1_INVERT On</simpara></entry>
<entry align="left" valign="top"><simpara>On, Off</simpara></entry>
<entry align="left" valign="top"><simpara>Optional
Default = Off</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SER1_RXNOWAIT,
SER2_RXNOWAIT,
SER3_RXNOWAIT</simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define, if SerNReceive waits for the startbits when receiving on serial channels 1, 2 and 3 respectively. If it is "On", then SerNReceive does not wait for the startbits edge, but directly reads the serial data. Also the time for delaying the startbit is shortened. This is useful when calling SerNReceive from an Interrupt-Service-Routine.
Sample:  #define SER1_RXNOWAIT On</simpara></entry>
<entry align="left" valign="top"><simpara>On, Off</simpara></entry>
<entry align="left" valign="top"><simpara>Optional
Default = Off</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SER1_TXDELAY,
SER2_TXDELAY,
SER3_TXDELAY</simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define, if SerNSend waits for the defined milliseconds after sending a byte of serial data. This is useful when using SerNPrint or SerNSend to a serial device that needs processing time between bytes.</simpara></entry>
<entry align="left" valign="top"><simpara>1..255</simpara></entry>
<entry align="left" valign="top"><simpara>Optional
Default =0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SER1_TXDELAYms,
SER2_TXDELAYms,
SER3_TXDELAYms</simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define, if SerNSend waits for the defined milliseconds after sending a byte of serial data. This is useful when using SerNPrint or SerNSend to a serial device that needs processing time between bytes.  Same functionality as SERn_TXDELAY</simpara></entry>
<entry align="left" valign="top"><simpara>1..255</simpara></entry>
<entry align="left" valign="top"><simpara>Optional
Default =0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SER1_TXDELAYus,
SER2_TXDELAYus,
SER3_TXDELAYus</simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define, if SerNSend waits for the defined nanoseconds after sending a byte of serial data. This is useful when using SerNPrint or SerNSend to a serial device that needs processing time between bytes.</simpara></entry>
<entry align="left" valign="top"><simpara>1..255</simpara></entry>
<entry align="left" valign="top"><simpara>Optional
Default =0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_sernsend">
<title>SerNSend</title>
<simpara><emphasis role="strong">Ser1Send, Ser2Send, Ser3Send</emphasis></simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Ser1Send data
    Ser2Send data
    Ser3Send data</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will send a byte given by data using the channel referred to as Ser1.. , Ser2&#8230;&#8203; , Ser3&#8230;&#8203; according to the rules set by the related defines.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will send one byte using PORTA.5

    ; ----- Configuration
    #chip 12F1501, 1

    ; ----- Include library
    #include &lt;SoftSerial.h&gt;

    ; ----- Config Serial UART for sending:
    #define SER1_BAUD 9600     ; baudrate must be defined
    #define SER1_TXPORT PORTA  ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 5       ; portbit  must be defined

    ; ----- Main body of program commences here.
    Ser1Send 88   'send one byte (88 = X)</screen>
<simpara>Exposed in SoftSerial.h authored by Frank Steinberg</simpara>
</section>
<section xml:id="_sernprint">
<title>SerNPrint</title>
<simpara><emphasis role="strong">Ser1Print, Ser2Print, Ser3Print</emphasis></simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Ser1Print value
    Ser2Print value
    Ser3Print value</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will send a value using the channel referred to as Ser1.. , Ser2&#8230;&#8203; , Ser3&#8230;&#8203; according to the rules set by the related defines.
value can be a string, integer, long, word or byte.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will send text and an icrementing value using PORTB.1

    ; ----- Configuration
    #chip 16F886, 16
    #option Explicit

    ; ----- Include library
    #include &lt;SoftSerial.h&gt;

    ; ----- Config Serial UART :
    #define SER1_BAUD 115200   ; baudrate must be defined
    ; Config I/O ports for transmitting:
    #define SER1_TXPORT PORTB  ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 1       ; portbit  must be defined

    ; ----- Variables
    Dim xx As Word
    xx = 1000

    ; ----- Main body of program commences here.
    Do Forever
      Wait 1 s       'time to enjoy the result
      Ser1Send  13   'new line in Terminal
      Ser1Send  10
      Ser1Print "Software-UART: "  'send a text
      Ser1Print xx   'send the value of xx
      xx += 1
    Loop</screen>
<simpara>Exposed in SoftSerial.h authored by Frank Steinberg</simpara>
</section>
<section xml:id="_sernreceive">
<title>SerNReceive</title>
<simpara><emphasis role="strong">Ser1Receive, Ser2Receive, Ser3Receive</emphasis></simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    bytevar = Ser1Receive
    bytevar = Ser2Receive
    bytevar = Ser3Receive</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This function will read a byte using the channel referred to as Ser1.. , Ser2&#8230;&#8203; , Ser3&#8230;&#8203; according to the rules set by the related defines. The received byte is stored in the variable bytevar.
By default the function waits for the startbit impulse edge before executing the following commands. See the sample files how to realize timeout-functionality or interrupt-driven receiving.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will receive bytes on PORTB.0 and send back using PORTB.1

    ; ----- Configuration
    #chip 16F886, 16
    #option Explicit

    ; ----- Include library
    #include &lt;SoftSerial.h&gt;

    ; ----- Config Serial UART :
    #define SER1_BAUD 115200   ; baudrate must be defined
    #define SER1_DATABITS 7    ; databits optional (default = 8)
    #define SER1_STOPBITS 2    ; stopbits optional (default = 1)
    #define SER1_INVERT Off    ; inverted polarity optional (default = Off)
    ; Config I/O ports for transmitting:
    #define SER1_TXPORT PORTB  ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 1       ; portbit  must be defined
    ; Config I/O ports for receiving:
    #define SER1_RXPORT PORTB  ; I/O port (without .bit) must be defined
    #define SER1_RXPIN 0       ; portbit  must be defined
    #define SER1_RXNOWAIT Off  ; don't wait for stopbit optional (default = Off)

    ; ----- Variables
    Dim RecByte As Byte

    ; ----- Main body of program commences here.
     Wait 1 Ms     'delay to prevent garbage if sending too quick after init
     Ser1Send 10   'new line in Terminal
     Ser1Send 13   '
     Ser1Print "Please send a byte!"

     Do Forever
      RecByte = Ser1Receive   'receive one byte - wait until detecting startbit
      Ser1Send  13            'new line in Terminal
      Ser1Send  10            '
      Ser1Print "You sent: "  'send a text
      Ser1Send RecByte        'send the sign representing the byte
     Loop</screen>
<simpara>Exposed in SoftSerial.h authored by Frank Steinberg</simpara>
</section>
</section>
<section xml:id="_rs232_hardware">
<title>RS232 (hardware)</title>
<simpara>This is the RS232 (hardware) section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_rs232_hardware_overview">
<title>RS232 Hardware Overview</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>GCBASIC support programs to communicate easily using RS232.</simpara>
<simpara>GCBASIC included microcontroller hardware-based serial routines are intended for use on microcontrollers with built in serial communications modules - normally referred to in datasheets as USART or UART modules.  Check the microcontroller data sheet for the defined transmit and receive (TX/Rx) pins.  Make sure your program sets the Tx pin direction to Out and the Rx pin direction to In respectively.  If the RS232 lines are connected elsewhere, or the microcontroller has no USART module, then the GCBASIC software based RS232 routines must be used.</simpara>
<simpara>Initialization of the USART module is handled automatically from your program by defining the chip, speed, and the baudrate.  The baudrate generator values are calculated and set,  usart is set to asynchronous, usart is enabled , the receive and transmit  are enabled. See the table below.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  #chip mega328p, 16
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?>
Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara>The following table explains the methods that can be implemented when using the GCBASIC serial routines.</simpara>
<simpara><emphasis role="strong">Commands:</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Parameters</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Serially print numbers (byte, word, long) or  strings.</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number_constant or number_variable or string [,optional usart address]
</simpara><simpara>The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine prints a variable value to usart 1. No additional parameter for the usart number is used.
</simpara><simpara><literal>HSerprint</literal> ( mynum )
</simpara><simpara>To print a variable value to usart 2. Note the additional parameter for the usart address.
</simpara><simpara><literal>HSerprint</literal> ( mynum, 2 )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Serially receive ascii number characters and assign to a word variable.</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerGetNum</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number_variable [,optional usart address]
</simpara><simpara>The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine ensures that the characters received are numbers.  When a carriage return (CR or ASCII code 13) is received this signifies the end of the character stream. Defaults to usart1.
</simpara><simpara>To receive number characters use.
</simpara><simpara><literal>HSerGetNum</literal> ( mynum   )
</simpara><simpara>To receive number characters via usart2 use.
</simpara><simpara><literal>HSerGetNum</literal> ( mynum, 2 )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Serially receive characters as a string.</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerGetString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>User_string_variable [,optional usart address]
</simpara><simpara>The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine ensures that the characters treated as a string.  When a carriage return (CR or ASCII code 13) is received this signifies the end of the character stream. GCBASIC will determine the default buffering size for strings. See here for more help on string sizes. Defaults to usart1.
</simpara><simpara>To receive a string use.<?asciidoc-br?>
<literal>HserGetString</literal> ( mystring )
</simpara><simpara>To a string via usart2 use.<?asciidoc-br?>
<literal>HserGetString</literal> ( mystring, 2 )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Serially receive a character using a subroutine.</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerReceive</literal></simpara></entry>
<entry align="left" valign="top"><simpara>byte_variable</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine handles the incoming characters as raw ASCII values.
</simpara><simpara>The subroutine receives a single byte value in the range of 0 to 255.
</simpara><simpara>The subroutine can receive a byte from usart 1, 2, 3 or 4.
</simpara><simpara>The public variable comport  can be set before the use of this method to select the desired usart address.
</simpara><simpara>If ‘#define USART_BLOCKING’ is defined then this methods will wait until it a byte is received.
</simpara><simpara>If ‘#define USART_BLOCKING’ is NOT defined then the method will returns ASCII value received or the method will return the value of 255 to indicate not ASCII data was received.  You can change the value returned by setting redefining ‘#define DefaultUsartReturnValue = [0-255]’.  When ‘#define USART_BLOCKING’ is NOT defined  this method becomes a non- blocking method which allows for the testing and handling of incoming ASCII data within the user program.
</simpara><simpara>To receive an ASCII byte value in blocking mode use. Defaults to usart1
</simpara><simpara>#define USART_BLOCKING<?asciidoc-br?>
…<?asciidoc-br?>
…<?asciidoc-br?>
<literal>HSerReceive</literal> (user_byte_variable)
</simpara><simpara>To receive an ASCII byte value via usart 3 using blocking mode use
</simpara><simpara>#define USART_BLOCKING<?asciidoc-br?>
…<?asciidoc-br?>
…<?asciidoc-br?>
Comport = 3<?asciidoc-br?>
<literal>HSerReceive</literal> ( user_byte_variable)
</simpara><simpara>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined. This method fefaults to usart1
</simpara><simpara><literal>HSerReceive</literal> (user_byte_variable)
</simpara><simpara>To receive an ASCII byte value via usart 4 using non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.
</simpara><simpara>Comport = 4<?asciidoc-br?>
<literal>HSerReceive</literal> ( user_byte_variable )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Serially receive a character using a function specifically via usart1.</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerReceive1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>none</simpara></entry>
<entry align="left" valign="top"><simpara>This function handles the incoming characters as raw ASCII values.
</simpara><simpara>The function receives a single byte value in the range of 0 to 255.
</simpara><simpara>The function can return only a byte value from usart 1.
</simpara><simpara>The blocking and non-blocking mode and the methods are the same as shown in the previous method.
</simpara><simpara>To receive an ASCII byte value via usart 1 using blocking mode use
</simpara><simpara>#define USART_BLOCKING<?asciidoc-br?>
…<?asciidoc-br?>
…<?asciidoc-br?>
user_number_variable = <literal>HSerReceive1</literal>
</simpara><simpara>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.
</simpara><simpara>user_number_variable = <literal>HSerReceive1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Serially receive a character using a function specifically via usart2</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerReceive2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>none</simpara></entry>
<entry align="left" valign="top"><simpara>This function handles the incoming characters as raw ASCII values.
</simpara><simpara>The function receives a single byte value in the range of 0 to 255.
</simpara><simpara>The function can receive only a byte value from usart 2.
</simpara><simpara>The blocking and non-blocking mode and the methods are the same as shown in the previous method.
</simpara><simpara>To receive an ASCII byte value via usart 2 using blocking mode use
</simpara><simpara>#define USART_BLOCKING<?asciidoc-br?>
…<?asciidoc-br?>
…<?asciidoc-br?>
user_byte_variable = <literal>HSerReceive2</literal>
</simpara><simpara>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.
</simpara><simpara>user_byte_variable = <literal>HSerReceive2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Serially receive a character using a function from either usart ports using a parameter to select the usart.</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerReceiveFrom</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Usart_number,<?asciidoc-br?>
 Default is 1</simpara></entry>
<entry align="left" valign="top"><simpara>This function handles the incoming characters as raw ASCII values.
</simpara><simpara>The function return a single byte value in the range of 0 to 255.
</simpara><simpara>The function can receive only a byte value from usart 1 and usart 2
</simpara><simpara>The blocking and non-blocking mode and the methods are the same as shown in the previous method.
</simpara><simpara>To receive an ASCII byte value via usart 1 using blocking mode use
</simpara><simpara>#define USART_BLOCKING<?asciidoc-br?>
…<?asciidoc-br?>
…<?asciidoc-br?>
user_byte_variable = <literal>HSerReceiveFrom</literal>
</simpara><simpara>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.
</simpara><simpara>'Chosen_usart = 2<?asciidoc-br?>
user_byte_variable = <literal>HSerReceiveFrom</literal> (2)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Serially send a byte using any of the usart ports.</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerSend</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Byte or byte_variable   [,optional usart address]  + The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine sends a byte value to usart 1. No additional parameter for the usart number is used.
</simpara><simpara><literal>HSerSend</literal>( user_byte )
</simpara><simpara>To print a variable value to usart 2. Note the additional parameter for the usart address.
</simpara><simpara><literal>HSerSend</literal> ( user_byte, 2 )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Serially send a byte and a CR&amp;LF using any of the usart ports</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerPrintByteCRLF</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Byte or byte_variable +  [,optional usart address] The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine sends a byte value to usart 1.
</simpara><simpara><literal>HserPrintCRLF</literal> users_byte,2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Serially send  CR&amp;LF (can be multiple) using any of the usart ports</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerPrintCRLF</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number of CR&amp;LF to be sent + [,optional usart address] The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine sends a CR&amp;LF to port 2.
</simpara><simpara></simpara><simpara><literal>HserPrintCRLF</literal> 1,2    ' Will send a CR &amp; LF out of comport 2 to the terminal</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Constants</emphasis>
These constants affect the operation of the hardware RS232 routines:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>USART_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Baud rate (in bps) for the routines to operate at.</simpara></entry>
<entry align="left" valign="top"><simpara>No default, user must enter a baud. Doesn&#8217;t have to be a standard baud.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the USART routines to wait until data
can be sent or received.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART_TX_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART2_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Baud rate (in bps) for the routines to operate at.</simpara></entry>
<entry align="left" valign="top"><simpara>No default, user must enter a baud. Doesn&#8217;t have to be a standard baud.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART2_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the USART routines to wait until data
can be sent or received.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART2_TX_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART3_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Baud rate (in bps) for the routines to operate at.</simpara></entry>
<entry align="left" valign="top"><simpara>No default, user must enter a baud. Doesn&#8217;t have to be a standard baud.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART3_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the USART routines to wait until data
can be sent or received.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART3_TX_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART4_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Baud rate (in bps) for the routines to operate at.</simpara></entry>
<entry align="left" valign="top"><simpara>No default, user must enter a baud. Doesn&#8217;t have to be a standard baud.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART4_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the USART routines to wait until data
can be sent or received.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART4_TX_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.
<?asciidoc-br?>
<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART_DELAY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is the delay between characters.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1 ms</literal>
</simpara><simpara>To disable this delay between characters &#8230;&#8203;  Use #define  <literal>USART_DELAY  0 MS</literal>, or,
To disable this delay between characters &#8230;&#8203;  Use #define  <literal>USART_DELAY  OFF</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHECK_USART_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Instruct the compiler to show the real BPS to be used</simpara></entry>
<entry align="left" valign="top"><simpara>Not the default operation</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ISSUE_CHECK_USART_BAUD_RATE_WARNING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Instruct the compiler to show BPS calculation errors</simpara></entry>
<entry align="left" valign="top"><simpara>Not the default operation</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SerPrintCR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Causes a Carriage return to be sent after every HserPrint automatically.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. User “#defining” it implements the action</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SerPrintLF</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Causes a LineFeed to be sent after every HserPrint. Some communications require both CR and LF</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. User “#defining” it implements the action</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_hsergetnum">
<title>HSerGetNum</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <literal>HSerGetNum</literal> <emphasis>myNum</emphasis>    ‘Gets a multi digit number  from USART 1
  <literal>HSerGetNum</literal> <emphasis>myNum</emphasis>,1  ‘Get a multi digit number from USART 1
  <literal>HSerGetNum</literal> <emphasis>myNum</emphasis>,2  ‘Get a multi digit number from USART 2</screen>
<literallayout class="monospaced">When the variable type is a word the number range is 0 to 65535
When the variable type is a long the number range is 0 to 99999</literallayout>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?></simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Enabling Constants:</emphasis></simpara>
<simpara>To enable the use of the USART these are the enabling constants. &#160;&#160;These constants are required.&#160;&#160;You can change the <literal>USART_BAUD_RATE</literal> and to meet your needs.&#160;&#160;For addition USART ports use <literal>#define USART<emphasis role="strong">n</emphasis>_BAUD_RATE 9600</literal> where <literal><emphasis role="strong">n</emphasis>`</literal> is the required port number.</simpara>
<screen>    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will read a multi digit number received as ascii chars followed by a CR from an external serial source using a  hardware serial module.  The command checks that only numbers are input disregarding other characters while waiting for the ending &lt;CR&gt;.  It can be used only as a subroutine.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program receives a number and CR from a PC terminal and sends it back on both usarts
  #chip 18f26k22, 16

  'Set the pin directions
  #define USART_BAUD_RATE 9600
  #define USART_BLOCKING
  #define USART2_BAUD_RATE 9600
  #define USART2_BLOCKING

  'Init pins
  #define SerInPort PORTc.7    'usart1 in
  #define SerOutPort PORTc.6    'usart2 out
    'Set pin directions
    Dir SerOutPort Out
    Dir SerInPort In
    Dir PORTB.6 Out            'USART2 out
    Dir PORTB.7 In            'USArt2 in
    Dir PORTB.0 Out            'leds for testing
    Dir PORTB.1 Out            'leds for testing
    Wait 100 Ms

  'Variables
  Dim myNum as Word
  'Main body of program commences here.
  'Message after reset
  HSerPrint "18F26k22"
  HSerPrintCRLF

  'Main routine
  Do forever
    'wait for char from UART
    'HSerReceive InChar
    HSerGetNum myNum,2    'from usart 2
    HSerPrint myNum,1            ' send out usart 1
    HSerPrint myNum,2        'send out usart 2
    HSerPrintCRLF 1,2        'send one CRLF out usart 2
    HserPrintCRLF 1,1        ‘send one CRLF out usart 1
  loop</screen>
<simpara><emphasis role="strong">Example:</emphasis>
This program receives number on serial port 1 and displays.  This example shows using a Long as the input variable.</simpara>
<simpara>Therefore, the result is in the range of 0-99999.  The example also shows how to detect a buffer overrun by testing the HSerInByte variable.</simpara>
<screen>    #chip mega328p, 16

    #define USART_BAUD_RATE 9600
    #define USART_BLOCKING

    Dim myNum as Long  ' range 0 to 99999
    HSerPrint "Restarted"
    HSerPrintCRLF

    Do
      HSerGetNum myNum
      HSerPrint myNum

      if HSerInByte &lt;&gt; 13 then
          HSerSend 9
          HSerPrint "Error buffer overrun"  'You should handle error appropiately
      End if
      HSerPrintCRLF
    loop
    End</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_hserreceive">HSerReceive</link> and <link linkend="_hsergetstring">HSerGetString</link></simpara>
</section>
<section xml:id="_hsergetstring">
<title>HSerGetString</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HSerGetString <emphasis>myString</emphasis>      ‘Get a multi char string  from USART 1
    HSerGetString <emphasis>myString</emphasis>,1    ‘Get a multi char string  from USART 1
    HSerGetString <emphasis>myString</emphasis>,2    ‘Get a multi char string  from USART 2</screen>
<literallayout class="monospaced">Variable type is string and the  routine checks for numbers,letters, and puctuation.</literallayout>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?></simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Enabling Constants:</emphasis></simpara>
<simpara>To enable the use of the USART these are the enabling constants. &#160;&#160;These constants are required.&#160;&#160;You can change the <literal>USART_BAUD_RATE</literal> and to meet your needs.&#160;&#160;For addition USART ports use <literal>#define USART<emphasis role="strong">n</emphasis>_BAUD_RATE 9600</literal> where <literal><emphasis role="strong">n</emphasis>`</literal> is the required port number.</simpara>
<screen>    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will read a multi character string received as ascii input to the hardware serial module followed by a CR from an external serial source. It can be used only as a subroutine. Variable type is string and the  routine checks for numbers,letters, and puctuation.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program receives char string and CR from a PC terminal, sends back the string on the serial port, and turns Led’s on off by command

  #chip 18f26k22, 16

  'Set the pin directions
  #define USART_BAUD_RATE 9600
  #define USART_BLOCKING
  #define USART2_BAUD_RATE 9600
  #define USART2_BLOCKING

  'InitUSART
  #define SerInPort PORTc.7    'USART 1 Rx Pin
  #define SerOutPort PORTc.6    'USART 1 Tx Pin


  'Set pin directions
  Dir SerOutPort Out
  Dir SerInPort In

  Dir PORTB.6 Out        'second USART Tx Pin
  Dir PORTB.7 In        'second USART Rx Pin

  Dir PORTB.0 Out        ' LED hooked up for testing
  Dir PORTB.1 Out        ' LED hooked up for testing

  Wait 100 Ms

  ; ----- Variables
  ' All byte variables are defined upon use.
  Dim myNum as Word
  Dim MyString as String

  ; ----- Main body of program commences here.
  'Message after reset
  HSerPrint "18F26k22"
  HSerPrintCRLF

  'Main routine

  Do Forever

    HSerGetString MyString
    HSerPrint MyString
    HSerSend(13)
     If MyString = "LED1 ON" Then
       Set PORTB.0 Off
     End If
     If MyString = "LED1 OFF" Then
       Set PORTB.0 On
     End If
     If MyString = "LED2 ON" Then
       Set PORTB.1 Off
     End If
     If MyString = "LED2 OFF" Then
       Set PORTB.1 On
     End If

  Loop</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_hserreceive">HSerReceive</link> and <link linkend="_hsergetnum">HSerGetNum</link></simpara>
</section>
<section xml:id="_hserprint">
<title>HSerPrint</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HSerPrint <emphasis>user_value</emphasis> [,1|2|3|4]  'Choose comport with optional parameter
                                       'Default comport is 1

    'Send a series of ASCII characters using the buffer called SerialPacket
    Dim SerialPacket as Alloc
    SerialPacket = 66, 105, 108, 108, 38, 69, 118, 97, 110, 13, 10
    HserPrint ( SerialPacket, 1 )  ’explicit to comport 1
    SerialPacket = 66,44,73,44,82,13,10
    HserPrint ( SerialPacket )  ’defaults to comport 1</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?></simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Enabling Constants:</emphasis></simpara>
<simpara>To enable the use of the USART these are the enabling constants. &#160;&#160;These constants are required.&#160;&#160;You can change the <literal>USART_BAUD_RATE</literal> and to meet your needs.&#160;&#160;For addition USART ports use <literal>#define USART<emphasis role="strong">n</emphasis>_BAUD_RATE 9600</literal> where <literal><emphasis role="strong">n</emphasis>`</literal> is the required port number.</simpara>
<screen>    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>HSerPrint</literal> is used to send a value over the serial connection. <literal><emphasis>user_value</emphasis></literal>
can be a string, integer, long, word or byte. <literal>HSerPrint</literal> is very similar
to <literal>Print</literal>. The data will be sent out the hardware serial module.</simpara>
<simpara><literal>HSerPrint</literal> will not send any new line characters. If the chip is sending
to a terminal, these commands should follow every <literal>HSerPrint</literal> :</simpara>
<screen>  HSerPrint 13
  HSerPrint 10</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program will display any values received over the serial
  'connection. If "pot" is received, the value of the analog sensor
  'will be sent.
  'Note: This has been adapted from the SerPrint example.

  'Chip settings
  #chip 18F2525, 8

  'LCD settings
  #define LCD_IO 4
  #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
  #define LCD_RS PORTC.7
  #define LCD_RW PORTC.6
  #define LCD_Enable PORTC.5
  #define LCD_DB4 PORTC.4
  #define LCD_DB5 PORTC.3
  #define LCD_DB6 PORTC.2
  #define LCD_DB7 PORTC.1

  'USART settings
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING
  #define USART_DELAY OFF

  'Potentiometer
  #define POT_PORT PORTA.0
  #define POT_AN AN0

  'Set pin directions
  Dir POT_PORT In

  'Create buffer variables to store received messages
  Dim Buffer As String
  Dim OldBuffer As String
  BufferSize = 0

  'Show test messages
  Print "Serial Tester"
  Wait 1 s
  HSerPrint "GCBASIC RS232 Test"
  HSerSend 13
  HSerSend 10
  Wait 1 s

  'Main loop
  Do
    'Get a byte from the terminal
    HSerReceive Temp

    'If Enter key was pressed, deal with buffer contents
    If Temp = 13 Then
      Buffer(0) = BufferSize

      'Try to execute commands in buffer
      If Not ExecCommand (Buffer) Then
        'Show message on bottom line, last message on top.
        CLS
        Print OldBuffer
        Locate 1, 0
        Print Buffer
        'Store the message for next time
        OldBuffer = Buffer
      End If

      BufferSize = 0
    End If
    'Backspace code, delete last character in buffer
    If Temp = 8 Then
      If BufferSize &gt; 0 Then BufferSize -= 1
    End If
    'Received ASCII code between 32 and 127, add to buffer
    If Temp &gt;= 32 And Temp &lt;= 127 Then
      BufferSize += 1
      Buffer(BufferSize) = Temp
    End If
  Loop

  'Takes a sensor reading and sends it to terminal
  Sub SendSensorReading
    HSerPrint "Sensor Reading: "
    HSerPrint ReadAD10(POT_AN)
    HSerSend 13
    HSerSend 10
  End Sub

  'Will check the buffer for a command
  'If command found, run it and return true
  'If not, return false
  Function ExecCommand (CmdIn As String)
    ExecCommand = False
    'If received command is "pot", show potentiometer value
    If CmdIn = "pot" Then
      SendSensorReading
      ExecCommand = True
    End If
  End Function</screen>
<simpara><emphasis role="strong">For more help, see also</emphasis>
<link linkend="_hserprintbytecrlf">HserPrintByteCRLF</link>, <link linkend="_hserprintstringcrlf">HserPrintStringCRLF</link>
<emphasis role="strong">and</emphasis> <link linkend="_hserprintcrlf">HserPrintCRLF</link></simpara>
</section>
<section xml:id="_hserprintstringcrlf">
<title>HSerPrintStringCRLF</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HSerPrintStringCRLF <emphasis>user_string</emphasis> [,1|2|3|4]  'Choose comport with optional parameter
                                                'Default comport is 1</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?></simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Enabling Constants:</emphasis></simpara>
<simpara>To enable the use of the USART these are the enabling constants. &#160;&#160;These constants are required.&#160;&#160;You can change the <literal>USART_BAUD_RATE</literal> and to meet your needs.&#160;&#160;For addition USART ports use <literal>#define USART<emphasis role="strong">n</emphasis>_BAUD_RATE 9600</literal> where <literal><emphasis role="strong">n</emphasis>`</literal> is the required port number.</simpara>
<screen>    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>HSerPrintStringCRLF</literal> is used to send a string over the serial connection. The parameter can only
 be a string. <literal>HSerPrintStringCRLF</literal> is very similar to <literal>HserPrint</literal> but <literal>HserPrint</literal> can handle all types of variables.</simpara>
<simpara>The data will be sent out the hardware serial module.</simpara>
<simpara><literal>HSerPrintStringCRLF</literal> will send new line characters:</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program will display string over the serial connection.

  'Chip settings
  #chip 18F2525, 8

  'USART settings
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING

  'Show string message
  HSerPrintStringCRLF "GCBASIC RS232 Test"
  Wait 1 s</screen>
<simpara><emphasis role="strong">For more help, see also</emphasis>
<link linkend="_hserprint">HserPrint</link>, <link linkend="_hserprintbytecrlf">HserPrintByteCRLF</link> <emphasis role="strong">and</emphasis> <link linkend="_hserprintcrlf">HserPrintCRLF</link></simpara>
</section>
<section xml:id="_hserreceive">
<title>HSerReceive</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara><emphasis role="strong"><emphasis>Used as subroutine:</emphasis></emphasis></simpara>
<screen>    HSerReceive (<emphasis>user_byte_variable</emphasis>)</screen>
<simpara>or, if other multiple comports are in use, set the comport before using HSerReceive.</simpara>
<screen>    comport = 1   '(1|2|3|4|5)Not needed unless using multiple comports in use
    HSerReceive (_user_byte_variable_)</screen>
<simpara>or, used as function.</simpara>
<screen>  <emphasis>user_byte_variable</emphasis> = <literal>HSerReceive</literal>  'Supports only USART1
  <emphasis>user_byte_variable</emphasis> = <literal>HSerReceive1</literal> 'Supports only USART1
  <emphasis>user_byte_variable</emphasis> = <literal>HSerReceive2</literal> 'Supports only USART2</screen>
<simpara>or, used to support assigning of received byte to word (or other multi-byte variables).&#160;&#160;Note the use of casting to ensure the <literal>HSerReceive</literal> uses byte addressing.</simpara>
<screen>  Dim dbAdr as Word

  HSerReceive [byte]dbAdr_H
  HSerReceive [byte]dbAdr</screen>
<simpara>For other comports use Function <literal>HSerReceiveFrom</literal></simpara>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.</simpara>
<simpara>Microchip PIC supports USART1,2,3,4 and 5.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Enabling Constants:</emphasis></simpara>
<simpara>To enable the use of the USART these are the enabling constants. &#160;&#160;These constants are required.&#160;&#160;You can change the <literal>USART_BAUD_RATE</literal> and to meet your needs.&#160;&#160;For addition USART ports use <literal>#define USART<emphasis role="strong">n</emphasis>_BAUD_RATE 9600</literal> where <literal><emphasis role="strong">n</emphasis>`</literal> is the required port number.</simpara>
<screen>    'USART settings for USART1
    #define USART_BAUD_RATE 9600       'Set the baud rate
    #define USART_TX_BLOCKING          'Ensure the transmit buffer is empty
    #define USART_BLOCKING             'Ensures a data byte is in the receive buffer
    #define USART_DELAY OFF	       'Disables USART delays</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will read a byte from the hardware RS232 module. It can be
used either as a subroutine or as a function. If used as a subroutine, a
variable must be supplied to store the received value in. If used as a
function, it will return the received value.</simpara>
<simpara>The subroutine HSerReceive can get a byte from any comport but must set the comport number immediately before the call.  If ”#define USART_BLOCKING” is defined then the HserReceive waits in a loop until it receives a byte.   If” #define USART_BLOCKING” is NOT defined then HserReceive returns the new byte that was received OR returns 255 because of “DefaultUsartReturnValue = 255”  was defined.  This is good because it don’t hold up your program from executing other  commands and your can check it for new data priodically.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program will read a value from the USART, and send it to PORTB.

  #chip 16F877A, 20

  'USART settings
  #define USART_BAUD_RATE 9600  'sets up comport 1 for 9600 baud

  'Set PORTB to output
  Dir PORTB Out
  'Set USART receive pin to input
  Dir PORTC.7 In

  'Main loop
  Do
    'Get serial data and output value to PortB as 8 bit binary
    HSerReceive(InChar)  'Receive data as Subroutine from comport 1
    'InChar = HSerReceive  'Could also be written as Function
    If InChar &lt;&gt; 255 Then   'If value is 255 then it is old data
      PortB = InChar    'If new data then it goes to PortB
    End If
  Loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>  'If you choose no “Blocking” and comment both of them out.
  'USART settings
  #define USART_BAUD_RATE 9600
  '#define USART_BLOCKING        ' just none OR one of the blocking
  '#define USART_TX_BLOCKING    ' statements should be defined

  'Main loop
  Do
    'Get and display value
    'If there is no new data, HSerReceive will return default value.
    comport = 1
    HSerReceive tempvalue
    If tempvalue &lt;&gt; 255    Then    ‘ don’t change PortB if it is default
      PortB = tempvalue
    End If

  Loop</screen>
<simpara><emphasis role="strong">Example 3:</emphasis></simpara>
<screen>  'If you choose no “Blocking” and comment both of them out.
  #chip mega328p, 16

  #define USART_BAUD_RATE 9600
  '#define USART_BLOCKING
  '#define USART_TX_BLOCKING

  'Don't forget to Set usart pin directions
  Dir PortD.1 Out    'com1   USART0
  Dir PortD.0 In

  Wait 1 s

  'Message after reset
  HSerPrint "ATmega328P  com test"
  HSerPrintCRLF

  'Main routine  hook up FTDI232 usb to serial and use terminal program to check
  Start:
    comport = 1
    HSerReceive(InChar)    'Subroutine needs the comport set
    'InChar = HSerReceive    ' This function will get from comport 1
      If InChar &lt;&gt; 255 Then    ' check if for received byte
                  'return 255 if old data
        HSerSend InChar    'send back char to UART
      End If
  Goto Start</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_rs232_hardware_overview">RS232 Hardware Overview</link></simpara>
</section>
<section xml:id="_hserreceivefrom">
<title>HSerReceiveFrom</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <emphasis>user_byte</emphasis> = HSerReceiveFrom [,1 | 2 | 3 | 4]
  <emphasis>user_byte</emphasis> = HSerReceiveFrom         'Defaults to USART1

  'other Receive functions
  <emphasis>user_byte</emphasis> = HSerReceive1    'from USART1
  <emphasis>user_byte</emphasis> = HSerReceive2    'from USART2</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?></simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Enabling Constants:</emphasis></simpara>
<simpara>To enable the use of the USART these are the enabling constants. &#160;&#160;These constants are required.&#160;&#160;You can change the <literal>USART_BAUD_RATE</literal> and to meet your needs.&#160;&#160;For addition USART ports use <literal>#define USART<emphasis role="strong">n</emphasis>_BAUD_RATE 9600</literal> where <literal><emphasis role="strong">n</emphasis>`</literal> is the required port number.</simpara>
<screen>    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will read a byte from the hardware RS232 module. It can be only be used as a function. It will return the received value.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program will read a value from the USART, and display it on PORTB.

  #chip 16F877A, 20

  'USART settings
  #define USART_BAUD_RATE 9600
  #define USART_BLOCKING
  #define USART_TX_BLOCKING


  'Set PORTB to input
  Dir PORTB Out
  'Set USART receive pin to input
  Dir PORTC.7 In

  'Main loop
  Do
    'Get byte value
    bytein = HSerReceiveFrom (2)
    'do something useful
  Loop</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_hserreceive">HSerReceive</link></simpara>
</section>
<section xml:id="_hsersend">
<title>HSerSend</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HSerSend <emphasis>user_byte</emphasis> [,1|2|3|4]   'Choose comport with optional parameter
                                      'Default comport is 1</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.</simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Enabling Constants:</emphasis></simpara>
<simpara>To enable the use of the USART these are the enabling constants. &#160;&#160;These constants are required.&#160;&#160;You can change the <literal>USART_BAUD_RATE</literal> and to meet your needs.&#160;&#160;For addition USART ports use <literal>#define USART<emphasis role="strong">n</emphasis>_BAUD_RATE 9600</literal> where <literal><emphasis role="strong">n</emphasis>`</literal> is the required port number.</simpara>
<screen>    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will send a byte given by <emphasis>user_byte</emphasis> using the hardware RS232
module.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program will send the status of PORTB through the hardware
  'serial module.

  #chip 16F877A, 20

  'USART settings
  #define USART_BAUD_RATE 9600  'Initializes USART port with 9600 baud
  '#define USART_BLOCKING   ' Both of these blocking statements will
  #define USART_TX_BLOCKING ' wait for tx register to be empty
                ' use only one of the two constants
  #define USART_DELAY OFF

  'Set PORTB to input
  Dir PORTB In
  'Set USART transmit pin to output
  Dir PORTC.6 Out

  'Main loop
  Do
    'Send PORTB value through USART
    HSerSend PORTB
    HSerSend(13)    ' sends a CR
    'Short delay for receiver to process message
    Wait 10 ms      'probably not necessary with blocking statement
  Loop</screen>
</section>
<section xml:id="_hserprintbytecrlf">
<title>HserPrintByteCRLF</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <literal>HserPrintByteCRLF</literal>  <emphasis>user_data</emphasis> [, 1 | 2  | 3 | 4 ]</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.</simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Enabling Constants:</emphasis></simpara>
<simpara>To enable the use of the USART these are the enabling constants. &#160;&#160;These constants are required.&#160;&#160;You can change the <literal>USART_BAUD_RATE</literal> and to meet your needs.&#160;&#160;For addition USART ports use <literal>#define USART<emphasis role="strong">n</emphasis>_BAUD_RATE 9600</literal> where <literal><emphasis role="strong">n</emphasis>`</literal> is the required port number.</simpara>
<screen>    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will send a byte given by <emphasis>user_data</emphasis> using the hardware USART
module and then send the ASCII codes 13 and 10. ASCII codes 13 and 10
equate to a carriage return and line feed.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program will send the status of PORTB through the hardware serial module.

  HserPrintByteCRLF 65    ' Will print a single A on the terminal
  HserPrintByteCRLF "A"   ' Will print a single A on the terminal</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_hserprintcrlf">HserPrintCRLF</link></simpara>
</section>
<section xml:id="_hserprintcrlf">
<title>HserPrintCRLF</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HserPrintCRLF [optional BYTE] [, 1 | 2  | 3 | 4 ]</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?></simpara>
<simpara>Microchip PIC supports USART1 and 2.+
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Enabling Constants:</emphasis></simpara>
<simpara>To enable the use of the USART these are the enabling constants. &#160;&#160;These constants are required.&#160;&#160;You can change the <literal>USART_BAUD_RATE</literal> and to meet your needs.&#160;&#160;For addition USART ports use <literal>#define USART<emphasis role="strong">n</emphasis>_BAUD_RATE 9600</literal> where <literal><emphasis role="strong">n</emphasis>`</literal> is the required port number.</simpara>
<screen>    'USART settings for USART1
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_DELAY OFF</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will send ASCII codes 13 and 10 only using the hardware
RS232 module. ASCII codes 13 and 10 equate to a carriage return and line
feed.</simpara>
<simpara>Optionally, you can add a parameter. The number will determine the
number of ASCII codes 13 and 10 set to the hardware RS232 module.</simpara>
<simpara>Also you can choose the comport with second optional parameter if it is not the default comport 1. If there is no first optional parameter then you must have atleast acomma before it  to indicate this is the second parameter.</simpara>
<simpara><emphasis role="strong">Examples:</emphasis></simpara>
<screen>  'This Line will send 1  CR and LF
  HserPrintCRLF    ' Will send a CR &amp; LF to the terminal

  'This Line will send 2  times (CR and LF)
  HserPrintCRLF 2    ' Will send 2 times (CR &amp; LF) to the terminal
            'out of comport 1

  'This Line will send 1  CR and LF
  HserPrintCRLF 1,2    ' Will send a CR &amp; LF out of
            'comport 2 to the terminal</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_hserprintbytecrlf">HserPrintByteCRLF</link></simpara>
</section>
</section>
</section>
<section xml:id="_ps_2">
<title>PS/2</title>
<simpara>This is the PS/2 section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_ps_2_overview">
<title>PS/2 Overview</title>
<simpara><emphasis role="strong">PS2 Overview</emphasis></simpara>
<simpara>These routines make it easier to communicate with a PS/2 device,
particularly an external keyboard.</simpara>
<simpara><emphasis role="strong">Relevant Constants</emphasis></simpara>
<simpara>These constants affect the operation of the PS/2 routines:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>PS2Data</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pin connected to PS/2 data line</simpara></entry>
<entry align="left" valign="top"><simpara>Must be specified</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PS2Clock</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pin connected to PS/2 clock line.</simpara></entry>
<entry align="left" valign="top"><simpara>Must be specified</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PS2_DELAY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This constant can be set to a delay, such as 10 ms. If set, a delay will
be added at the end of every byte sent or received.</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Connections between the Keyboard and the Microcontroller</emphasis>
The following diagram show a typical connection between the keyboard and the microcontroller.  The value of R1 and R2 is typically 4.7k for a 5v system.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/overview_ps21.PNG" align="center"/>
</imageobject>
<textobject><phrase>[graphic</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_inkey">
<title>InKey</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    output = InKey</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>InKey</literal> function will read the last pressed key from a PS/2 keyboard,
and return an ASCII value corresponding to the key. If no key is
pressed, then <literal>InKey</literal> will return 0.</simpara>
<simpara>It will also monitor Caps Lock, Num Lock and Scroll Lock keys, and
update the status LEDs as appropriate.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	'A program to accept messages from a standard PS/2 keyboard
	'Any keys pressed will be shown on an LCD screen.

	'Hardware settings
	#chip 18F4620, 20

	'LCD connection settings
	#define LCD_IO 4
	#define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
	#define LCD_DB4 PORTD.4
	#define LCD_DB5 PORTD.5
	#define LCD_DB6 PORTD.6
	#define LCD_DB7 PORTD.7
	#define LCD_RS PORTD.0
	#define LCD_RW PORTD.1
	#define LCD_Enable PORTD.2

	'PS/2 connection settings
	#define PS2Clock PORTC.1
	#define PS2Data PORTC.0
	#define PS2_DELAY 10 ms

	'Set up key log
	Dim KeyLog(32)
	DataCount = 0
	KeyLog(1) = 32

	Main:
		'Read the last pressed key
		KeyIn = INKEY
		'If no key pressed, try reading again
		If KeyIn = 0 Then Goto Main

		'Escape pressed - clear message
		If KeyIn = 27 Then
			DataCount = 0
			For DataPos = 1 to 32
				KeyLog(DataPos) = 32
			Next
			Goto DisplayData
		End If

		'Backspace pressed - delete last character
		If KeyIn = 8 Then
			If DataCount = 0 Then Goto Main
			KeyLog(DataCount) = 32
			DataCount = DataCount - 1
			Goto DisplayData
		End If

		'Otherwise, add the character to the buffer
		If KeyIn &gt;= 31 And KeyIn &lt;= 127 Then
			DataCount = DataCount + 1
			KeyLog(DataCount) = KeyIn
		End If

	DisplayData:
		'Display key buffer
		'LCDWriteChar is used instead of Print for greater control
		CLS
		For DataPos = 1 to DataCount
			If DataPos = 17 then Locate 1, 0
			LCDWriteChar KeyLog(DataPos)
		Next

	Goto Main</screen>
</section>
<section xml:id="_ps2setkbleds">
<title>PS2SetKBLeds</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PS2SetKBLeds (<emphasis>LedStatus</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This routine will turn the status LEDs on a keyboard on or off.
<literal><emphasis>LedStatus</emphasis></literal> is a variable, of which the lower 3 bits correspond to the 3
LEDs. Bit 0 is for Scroll Lock, bit 1 controls Num Lock and bit 2
controls Caps Lock.</simpara>
<simpara>Note that this routine does not alter the status variables within the
INKEY routine - so even if the Caps Lock LED is turned on, Caps Lock
will stay off.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	'A spinning LED program for a keyboard
	'Will flash Num Lock, then Caps Lock, then Scroll Lock.

	'Hardware settings
	#chip 16F88, 8

	#define PS2Clock PORTB.2
	#define PS2Data PORTB.3
	#define PS2_DELAY 10 ms

	'Main Loop
	Do

		'Turn on only Num Lock (bit 1)
		PS2SetKBLeds b'00000010'
		Wait 250 ms

		'Turn on only Caps Lock (bit 2)
		PS2SetKBLeds b'00000100'
		Wait 250 ms

		'Turn on only Scroll Lock (bit 0)
		PS2SetKBLeds b'00000001'
		Wait 250 ms

	Loop</screen>
</section>
<section xml:id="_ps2readbyte">
<title>PS2ReadByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    output = PS2ReadByte</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>PS2ReadByte</literal> will read a byte from the PS/2 bus. It will return the byte,
or 0 if no data was returned by the PS/2 device.</simpara>
<simpara>The PS/2 bus will normally be held in the inhibit state. <literal>PS2ReadByte</literal>
will uninhibit the bus for 25 ms. If a response is received, it will be
read. Then, the bus will be placed back in the inhibit state.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>For an example, please refer to the <literal>InKey</literal> function.
<link linkend="_inkey">PS2 Inkey</link></simpara>
</section>
<section xml:id="_ps2writebyte">
<title>PS2WriteByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PS2WriteByte <emphasis>user_data</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>PS2WriteByte</literal> will send a byte to a PS/2 device. Once the byte has been
written, the PS/2 bus will be placed in the inhibit state.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>For an example, please refer to the <literal>PS2SetKBLeds</literal> function.<?asciidoc-br?>
<link linkend="_ps2setkbleds">PS2 Set Keyboard Leds</link></simpara>
</section>
</section>
<section xml:id="_spi">
<title>SPI</title>
<simpara>This is the Serial Peripheral Interface section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_spi_overview">
<title>SPI Overview</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara>The SPI interface allows for the transmission and receiption of data simultaneously on two lines (MOSI and MISO).</simpara>
<simpara>The Clock polarity (CPOL) and clock phase (CPHA) are the main parameters that define a clock format to be used by the SPI bus. Depending on CPOL parameter, SPI clock may be inverted or non-inverted. CPHA parameter is used to shift the sampling phase. If CPHA=0 the data are sampled on the leading (first) clock edge. If CPHA=1 the data are sampled on the trailing (second) clock edge, regardless of whether that clock edge is rising or falling.</simpara>
<simpara>CPOL=0, CPHA=0</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/spi-cpol-0-cpha-0.png" align="center"/>
</imageobject>
<textobject><phrase>[graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The data must be available before the first clock signal rising.  The clock idle state is zero.  The data on MISO and MOSI lines must be stable while the clock is high and can be changed when the clock is low. The data is captured on the clock&#8217;s low-to-high transition and propagated on high-to-low clock transition.</simpara>
<simpara>CPOL=0, CPHA=1</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/spi-cpol-0-cpha-1.png" align="center"/>
</imageobject>
<textobject><phrase>[graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The first clock signal rising can be used to prepare the data. The clock idle state is zero. The data on MISO and MOSI lines must be stable while the clock is low and can be changed when the clock is high. The data is captured on the clock&#8217;s high-to-low transition and propagated on low-to-high clock transition.</simpara>
<simpara>CPOL=1, CPHA=0</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/spi-cpol-1-cpha-0.png" align="center"/>
</imageobject>
<textobject><phrase>[graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The data must be available before the first clock signal falling. The clock idle state is one. The data on MISO and MOSI lines must be stable while the clock is low and can be changed when the clock is high. The data is captured on the clock&#8217;s high-to-low transition and propagated on low-to-high clock transition.</simpara>
<simpara>CPOL=1, CPHA=1</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/spi-cpol-1-cpha-1.png" align="center"/>
</imageobject>
<textobject><phrase>[graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The first clock signal falling can be used to prepare the data. The clock idle state is one. The data on MISO and MOSI lines must be stable while the clock is high and can be changed when the clock is low. The data is captured on the clock&#8217;s low-to-high transition and propagated on high-to-low clock transition.</simpara>
<simpara><emphasis role="strong">Key Commands</emphasis></simpara>
<screen>    SPIMode  ( _Mode_ [, SPIClockMode])

    SPITransfer (  _OutByte_, _InByte_ )

    FastHWSPITransfer( _OutByte_ )

    #define HWSPIMode MASTERULTRAFAST       'MASTERSLOW | MASTER | MASTERFAST | MASTERULTRAFAST for specific AVRs only | MasterSSPADDMode for specific PICs SSPADD support
                                            'Defaults to MASTERFAST when microcontroller frequency less or equal to 32 mhz
                                            'Defaults to MASTER when microcontroller frequency more than 32 mhz.</screen>
<simpara>The GCBASIC used the microcontrollers hardware module for SPI.  The example below shows an implementation of Hardware and Software SPI.  Software SPI allows for a greater choice of ports to be used to control the SPI operations.</simpara>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<simpara>This example demonstrates the SPI capabilities for the mega328p.  The process is similar of any microcontroller..</simpara>
<simpara>This example show using the hardware SPI option and a sofware SPI option.</simpara>
<simpara>Using hardware SPI mode - make sure the <literal>#define SPI_HardwareSPI</literal> is not commented out.
Using software SPI mode - comment out <literal>#define SPI_HardwareSPI</literal>. The example code will then use software SPI.</simpara>
<simpara><emphasis role="strong">Setting the SPI Mode</emphasis></simpara>
<simpara>Hardware SPI mode the Data Out, Data In and Clock (DO/DI and SCK) cannot be moved but the optional Data Command, Chip Select and Reset are all moveable.</simpara>
<simpara>Software SPI mode the Data Out, Data In and Clock (DO/DI and SCK), Data Command, Chip Select and Reset are all moveable.</simpara>
<simpara>Use the constant <literal>HWSPIMode</literal> to set the SPI frequency when using GCBASIC libraries.</simpara>
<screen>    #define HWSPIMode MASTERULTRAFAST</screen>
<simpara>GCBASIC libraries will default to to MASTERFAST when microcontroller frequency less or equal to 32 mhz and default to MASTER when microcontroller frequency more than 32 mhz.</simpara>
<simpara>The options for <literal>HWSPIMode</literal> are:</simpara>
<simpara><literal>MASTERSLOW</literal>, or, <literal>MASTER</literal> or <literal>MASTERFAST</literal> or <literal>MASTERULTRAFAST</literal> for specific AVRs only or <literal>MasterSSPADDMode</literal> for specific PICs SSPADD support</simpara>
<simpara>This constant sets the library to the desire SPI fequency, therefore enable adaption of the SPI frequency without have to change the library.</simpara>
<simpara>The SPI frequnecy must be the same for all the used devices.&#160;&#160; In particular, it must be set equal to the one dictated by the slowest SPI device to be used.</simpara>
<simpara>More freedom is available when more than an hardware SPI is available as well as when the user want to use hardware SPI for a device and software SPI for a second one.</simpara>
<simpara><emphasis role="strong">Using multiple SPI devices</emphasis></simpara>
<simpara>There will be use cases were you need to use more than one SPI target device at a time.&#160;&#160;In such cases the device defined for SPI must be inserted in your program for each device.</simpara>
<simpara>As an example using e-Paper and SRAM at the same time, with an hardware SPI would require <literal>#define SPISRAM_HARDWARESPI</literal> and <literal>#define EPD_HardwareSPI</literal>.&#160;&#160;</simpara>
<simpara>Obviously, when all SPI devices use the same SPI lines, you must  select one device at a time by setting SPI Chip Select line to <literal>OFF</literal> for the specific target SPI device, and you must set <literal>ON</literal> the SPI Chip Select line for any other SPI device&#160;&#160;-&#160;&#160;this is a normal convention of SPI usage. &#160;&#160; This is not specific to GCBASIC..</simpara>
<simpara><emphasis role="strong">Code overview</emphasis></simpara>
<literallayout class="monospaced">InitSPIMode calls SPIMode. if needed, when hardware mode, and set the port firections.
The sub SendByteviaSPI is called to handle whether to call the Hardware or use Software (bit-banging) SPI.</literallayout>
<screen>        #chip mega328p, 16
        #option explicit
        #include &lt;UNO_mega328p.h &gt;

        #define SPI_HardwareSPI  'comment this out to make into Software SPI but, you may have to change clock lines

        'Pin mappings for SPI - this SPI driver supports Hardware SPI
        #define SPI_DC       DIGITAL_8          ' Data command line
        #define SPI_CS       DIGITAL_4          ' Chip select line
        #define SPI_RESET    DIGITAL_9          ' Reset line

        #define SPI_DI       DIGITAL_12          ' Data in | MISO
        #define SPI_DO       DIGITAL_11          ' Data out | MOSI
        #define SPI_SCK      DIGITAL_13          ' Clock Line

        dir SPI_DC    out
        dir SPI_CS    out
        dir SPI_RESET out
        dir SPI_DO    Out
        dir SPI_DI    In
        dir SPI_SCK   Out

        'If DIGITAL_10 is NOT used as the SPI_CS (sometimes called SS) the port must and output or set as input/pulled high with a 10k resistor.
        'As follows:
        'If CS is configured as an input, it must be held high to ensure Master SPI operation.
        'If the CS pin is driven low by peripheral circuitry when the SPI is configured as a Master with the SS pin defined as an input, the
        'SPI system interprets this as another master selecting the SPI as a slave and starting to send data to it!
        'If CS is an output SPI communications will commence with no flow control.
        dir DIGITAL_10 Out

        DIM byte1 As byte
        DIM byte2 As byte
        DIM byte3 As byte

        byte1 = 100 ' temp values (will come from potentiometer later)
        byte2 = 150
        byte3 = 200

        InitSPIMode


        do forever
            set SPI_CS OFF;
            set SPI_DC OFF;
            SendByteviaSPI (byte1)
            set SPI_CS ON;
            set SPI_DC ON

            set SPI_CS OFF;
            set SPI_DC OFF;
            SendByteviaSPI (byte2)
            set SPI_CS ON;
            set SPI_DC ON

            set SPI_CS OFF;
            set SPI_DC OFF;
            SendByteviaSPI (byte3)
            set SPI_CS ON;
            set SPI_DC ON

            wait 10 ms
        loop



    sub InitSPIMode

          #ifdef SPI_HardwareSPI
              SPIMode ( MasterFast, SPI_CPOL_0 + SPI_CPHA_0 )
          #endif

          set SPI_DO OFF;
          set SPI_CS ON;   therefore CPOL=0
          set SPI_DC ON;   deselect

    End sub

    sub  SendByteviaSPI( in SPISendByte as byte )

      set SPI_CS OFF
      set SPI_DC OFF;

      #ifdef SPI_HardwareSPI
         FastHWSPITransfer  SPISendByte
         set SPI_CS ON;
         exit sub
      #endif

      #ifndef SPI_HardwareSPI
      repeat 8

        if SPISendByte.7 = ON  then
          set SPI_DO ON;
        else
          set SPI_DO OFF;
        end if
        SET SPI_SCK On;           ; therefore CPOL=0 ==ON, and, where CPOL=1==ON
        rotate SPISendByte left
        set SPI_SCK Off;          ; therefore CPOL=0  =OFF, and, where CPOL=1==OFF

      end repeat
      set SPI_CS ON;
      set SPI_DO OFF;
      #endif

    end Sub</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_spimode">SPIMode</link>,<link linkend="_spitransfer">SPITransfer</link>,<link linkend="_fasthwspitransfer">FastHWSPITransfer</link></simpara>
</section>
<section xml:id="_spimode">
<title>SPIMode</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SPIMode ( <emphasis>Mode</emphasis> [, SPIClockMode])</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC microcontrollers with Hardware SPI modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><emphasis>Mode</emphasis> sets the mode of the SPI module within the microcontroller. These are
the possible SPI Modes:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Mode Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>MasterSlow</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Master mode, SPI clock is 1/64 of the frequency of the microcontroller.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Master</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Master mode, SPI clock is 1/16 of the frequency of the microcontroller.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MasterFast</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Master mode, SPI clock is 1/4 of the frequency of the microcontroller.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Slave</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Slave mode</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SlaveSS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Slave mode, with the Slave Select pin enabled.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>SPIClockMode</emphasis> is an optional parameter to set the mode of the SPI clock mode. This optional parameter sets both the clock polarity and clock edge.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">SPIClockMode</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>SPI_CPOL = 0 &amp; SPI_CPHA = 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>SPI_CPOL = 0 &amp; SPI_CPHA = 1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>SPI_CPOL = 1 &amp; SPI_CPHA = 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>SPI_CPOL = 1 &amp; SPI_CPHA = 1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>You can alternatively use constants to set the SPIClockMode as follows:</simpara>
<screen>    SPIMode ( MasterFast, SPI_CPOL_n + SPI_CPHA_n )</screen>
<simpara>Where the following parameters can be used as a calculation to set the SPIClockMode.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Mode Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>SPI_CPOL_0</simpara></entry>
<entry align="left" valign="top"><simpara>CPOL = 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPI_CPOL_1</simpara></entry>
<entry align="left" valign="top"><simpara>CPOL = 1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPI_CPHA_0</simpara></entry>
<entry align="left" valign="top"><simpara>CPHA = 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPI_CPHA_1</simpara></entry>
<entry align="left" valign="top"><simpara>CPHA = 1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Summary:</emphasis></simpara>
<simpara>When using SPI setting the clock frequency is completed using SPIMode, and the master must also configure the clock polarity and phase with respect to the data. Using the two options as CPOL and CPHA.</simpara>
<simpara>The timing diagram is shown below. The timing is further described and applies to both the master and the slave device.</simpara>
<simpara>When CPOL=0 the base value of the clock is zero, i.e. the active state is 1 and idle state is 0.</simpara>
<itemizedlist>
<listitem>
<simpara>For CPHA=0, data are captured on the clock&#8217;s rising edge (low→high transition) and data is output on a falling edge (high→low clock transition).</simpara>
</listitem>
<listitem>
<simpara>For CPHA=1, data are captured on the clock&#8217;s falling edge and data is output on a rising edge.</simpara>
</listitem>
</itemizedlist>
<simpara>When CPOL=1 the base value of the clock is one (inversion of CPOL=0), i.e. the active state is 0 and idle state is 1.</simpara>
<itemizedlist>
<listitem>
<simpara>For CPHA=0, data are captured on clock&#8217;s falling edge and data is output on a rising edge.</simpara>
</listitem>
<listitem>
<simpara>For CPHA=1, data are captured on clock&#8217;s rising edge and data is output on a falling edge.</simpara>
</listitem>
</itemizedlist>
<simpara>When CPHA=0 means sampling on the first clock edge and , while CPHA=1 means sampling on the second clock edge, regardless of whether that clock edge is rising or falling.  Note that with CPHA=0, the data must be stable for a half cycle before the first clock cycle.</simpara>
<simpara>In other words, CPHA=0 means transmitting data on the active to idle state and CPHA=1 means that data is transmitted on the idle to active state edge. Note that if transmission happens on a particular edge, then capturing will happen on the opposite edge(i.e. if transmission happens on falling, then reception happens on rising and vice versa). The MOSI and MISO signals are usually stable (at their reception points) for the half cycle until the next clock transition. SPI master and slave devices may well sample data at different points in that half cycle.</simpara>
<simpara>This adds more flexibility to the communication channel between the master and slave.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/spimode1.PNG" align="center"/>
</imageobject>
<textobject><phrase>[graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<simpara>This example demonstrates the SPI capabilities for the mega328p.  The process is similar of any microcontroller..</simpara>
<simpara>You must set the data line as inputs and outputs.</simpara>
<screen>        #chip mega328p, 16
        #option explicit
        #include &lt;UNO_mega328p.h &gt;

        #define SPI_HardwareSPI  'comment this out to make into Software SPI but, you may have to change clock lines

        'Pin mappings for SPI - this SPI driver supports Hardware SPI
        #define SPI_DC       DIGITAL_8          ' Data command line
        #define SPI_CS       DIGITAL_4          ' Chip select line
        #define SPI_RESET    DIGITAL_9          ' Reset line

        #define SPI_DI       DIGITAL_12          ' Data in | MISO
        #define SPI_DO       DIGITAL_11          ' Data out | MOSI
        #define SPI_SCK      DIGITAL_13          ' Clock Line

        dir SPI_DC    out
        dir SPI_CS    out
        dir SPI_RESET out
        dir SPI_DO    Out
        dir SPI_DI    In
        dir SPI_SCK   Out

        'If DIGITAL_10 is NOT used as the SPI_CS (sometimes called SS) the port must and output or set as input/pulled high with a 10k resistor.
        'As follows:
        'If CS is configured as an input, it must be held high to ensure Master SPI operation.
        'If the CS pin is driven low by peripheral circuitry when the SPI is configured as a Master with the SS pin defined as an input, the
        'SPI system interprets this as another master selecting the SPI as a slave and starting to send data to it!
        'If CS is an output SPI communications will commence with no flow control.
        dir DIGITAL_10 Out


        dim outbyte, inbyte as byte

        SPIMode ( MasterFast, SPI_CPOL_0 + SPI_CPHA_0 )


       do
        set SPI_CS OFF;  Select line
        set SPI_DC OFF;  Send Data if off, or, Data if On
        SPITransfer ( outbyte, inbyte )
        set SPI_CS ON;   Deselect Line
        set SPI_DC ON
        wait 10 ms
       loop</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_spitransfer">SPITransfer</link>,<link linkend="_fasthwspitransfer">FastHWSPITransfer</link></simpara>
</section>
<section xml:id="_spitransfer">
<title>SPITransfer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <literal>SPITransfer</literal> <emphasis>tx</emphasis>, <emphasis>rx</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC microcontrollers with Hardware SPI modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command simultaneously sends and receives a byte of data using the
SPI protocol. It behaves differently depending on whether the microcontroller has
been set to act as a master or a slave.
When operating as a master, <literal>SPITransfer</literal> will initiate a transfer. The
data in <literal><emphasis>tx</emphasis></literal> will be sent to the slave, whilst the byte that is buffered
in the slave will be read into <literal><emphasis>rx</emphasis></literal>.
In slave mode, the <literal>SPITransfer</literal> command will pause the program until a
transfer is initiated by the master. At this point, it will send the
data in <literal><emphasis>tx</emphasis></literal> whilst reading the transmission from the master into the
<literal><emphasis>rx</emphasis></literal> variable.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>There are two example programs for this command - one to run on the
slave microcontroller , and one on the master. A reading is taken from a sensor on
the slave, and sent across to the master which shows the data on its LCD
screen.</simpara>
<simpara><emphasis role="strong">Slave Program:</emphasis></simpara>
<screen>  'Select chip model and configuration
  #chip 16F88, 20
  #config MCLR_OFF

  'Set directions of SPI pins
  dir PORTB.2 out
  dir PORTB.1 in
  dir PORTB.4 in
  'Set direction of analogue pin
  dir PORTA.0 in

  'Set SPI mode to slave
  SPIMode Slave

  'Allow other microcontroller to initialise LCD
  Wait 1 sec

  'Main loop - takes a reading, and then waits to send it across.
  do
  'Note that rx is 0 - this is because no data is to be received.
  SPITransfer ReadAD(AN0), 0
  loop</screen>
<simpara><emphasis role="strong">Master Program:</emphasis></simpara>
<screen>  'General hardware configuration
  #chip 16F877A, 20

  'LCD connection settings
  #define LCD_IO 8
  #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
  #define LCD_DATA_PORT PORTC
  #define LCD_RS PORTD.0
  #define LCD_RW PORTD.1
  #define LCD_Enable PORTD.2

  'Set SPI pin directions
  dir PORTC.5 out
  dir PORTC.4 in
  dir PORTC.3 out

  'Set SPI Mode to master, with fast clock
  SPIMode MasterFast

  'Main Loop
  do
  'Read a byte from the slave
  'No data to send, so tx is 0
  SPITransfer 0, Temp

  'Display data
  if Temp &gt; 0 then
    CLS
    Print "Light: "
    LCDInt Temp
    Temp = 0
  end if

  'Wait to allow time for the LCD to show the given value
  wait 100 ms
  loop</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_spimode">SPIMode</link>,<link linkend="_fasthwspitransfer">FastHWSPITransfer</link></simpara>
</section>
<section xml:id="_fasthwspitransfer">
<title>FastHWSPITransfer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <literal>FastHWSPITransfer</literal> <emphasis>tx</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC microcontrollers with Hardware SPI modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command only sends a byte of data using the
SPI protocol. This command only supports master mode.</simpara>
<simpara>As a master, <literal>FastHWSPITransfer</literal> will initiate a transfer. The
data in <literal><emphasis>tx</emphasis></literal> will be sent to the slave.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This is an example for this command.</simpara>
<simpara><emphasis role="strong">Master Program:</emphasis></simpara>
<screen>  'General hardware configuration
  #chip 16F877A, 20

  'Set SPI pin directions
  dir PORTC.5 out
  dir PORTC.4 in
  dir PORTC.3 out

  'Set SPI Mode to master, with fast clock
  SPIMode MasterFast

  'Main Loop
  do

      'Send the value of 0x55
      FastHWSPITransfer 0x55

  loop</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_spitransfer">SPITransfer</link>,<link linkend="_spimode">SPIMode</link></simpara>
</section>
</section>
<section xml:id="_i2c_software">
<title>I2C Software</title>
<simpara>This is the I2C Software section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_i2c_overview">
<title>I2C Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>These software routines allow GCBASIC programs to send and receive I2C
messages. They can be configured to act as master or slave, and the
speed can also be altered.</simpara>
<simpara>No hardware I2C module is required for these routines - all
communication is handled in software. However, these routines will not
work on 12-bit instruction Microchip PIC microcontrollers (10F, 12F5xx and 16F5xx chips).</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants control the setup of the software I2C routines:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>I2C_MODE</simpara></entry>
<entry align="left" valign="top"><simpara>Mode of I2C routines (Master or Slave)</simpara></entry>
<entry align="left" valign="top"><simpara>Master</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_DATA</simpara></entry>
<entry align="left" valign="top"><simpara>Pin on microcontroller connected to I2C data</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_CLOCK</simpara></entry>
<entry align="left" valign="top"><simpara>Pin on microcontroller connected to I2C clock</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_BIT_DELAY</simpara></entry>
<entry align="left" valign="top"><simpara>Time for a bit (used for acknowledge detection)</simpara></entry>
<entry align="left" valign="top"><simpara>2 us</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_CLOCK_DELAY</simpara></entry>
<entry align="left" valign="top"><simpara>Time for clock pulse to remain high</simpara></entry>
<entry align="left" valign="top"><simpara>1 us</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_END_DELAY</simpara></entry>
<entry align="left" valign="top"><simpara>Time between clock pulses</simpara></entry>
<entry align="left" valign="top"><simpara>1 us</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_USE_TIMEOUT</simpara></entry>
<entry align="left" valign="top"><simpara>Set to true if the I2C routines should stop waiting for the
I2c bus - the routine will exit if a timeout occurs.
Should be used when you need to prevent system lockups on the I2C bus.
</simpara><simpara>Supports both software I2C master and slave mode.
</simpara><simpara>Will return the variable <literal>I2CAck = FALSE</literal> when a timeout has occurred.</simpara></entry>
<entry align="left" valign="top"><simpara>Not Set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_DISABLE_INTERRUPTS</simpara></entry>
<entry align="left" valign="top"><simpara>Disable interrupts during I2C routines. Important when an i2C clock is
part of your solution</simpara></entry>
<entry align="left" valign="top"><simpara>Not defined.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis>
This example examines the IC2 devices and displays on a terminal.
This code will require adaption but the code shows an approach to discover the IC2 devices.</simpara>
<screen>  ' I2C Overview - using the ChipIno board, see here for information
  #chip 16F886, 8
  #config MCLRE_ON

  ' Define I2C settings
  #define I2C_MODE Master
  #define I2C_DATA PORTC.4
  #define I2C_CLOCK PORTC.3
  #define I2C_DISABLE_INTERRUPTS ON

  'USART/SERIAL PORT via a MAX232 TO PC Terminal
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING

  Dir PORTc.6 Out
  #define USART_DELAY 0 ms

  HSerPrintCRLF 2
  HSerPrint "I2C Discover using the ChipIno"
  HSerPrintCRLF 2

  HSerPrint "Started: "
  HSerPrint "Searching I2C address space: v0.85"
  HSerPrintCRLF

  wait 100 ms
  dim DeviceID as byte
  for DeviceID = 0 to 255
    I2CStart
    I2CSend ( deviceID )
    I2CSend ( 0 )
    I2CSend ( 0 )
    i2cstop

    if I2CSendState = True  then

      HSerPrint   "__"
      HSerPrint   "ID: 0x"
      HSerPrint   hex(deviceID)
      HSerPrint   " (d"
      HSerPrint   Str(deviceID)
      HSerPrint   ")"
      HSerPrintCRLF
    end if
  next
  HSerPrint   "End of Device Search": HSerPrintCRLF 2
  End</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2cackpollstate">
<title>I2CAckPollState</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>	&lt;test condition&gt; I2CAckPollState</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Should only be used when I2C routines are operating in Master mode, this
command will return the last state of the acknowledge response from a
specific I2C device on the I2C bus.</simpara>
<simpara><literal>I2CACKPOLL</literal> sets the state of variable <literal>I2CAckPollState</literal>. <literal>I2CAckPollState</literal>
can only read - it cannot be set.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	 ...
	' ACK polling removes the need to for the 24xxxxx device to have a 5ms
	write time
	I2CACKPOLL( eeprom_device )
	' You check the exit state,
	' Use I2CAckPollState to check the state of a target device
	 ...</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2cackpoll">
<title>I2CAckpoll</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>	I2CAckpoll ( <emphasis>I2C_device_address</emphasis> )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Should only be used when I2C routines are operating in Master mode, this
command will look for a specific I2C device on the I2C bus.</simpara>
<simpara>This sets a global variable <literal>I2CAckPollState</literal> that can be inspected in
your calling routine.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	 ...
	' ACK polling removes the need to for the 24xxxxx device to have a 5ms write time
	I2CACKPOLL( eeprom_device )
	' You check the exit state, use I2CAckPollState to check the state of
	' the acknowledge from the target device
	 ...</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2creceive">
<title>I2CReceive</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  I2CReceive <emphasis>data</emphasis>
  I2CReceive <emphasis>data</emphasis>, <emphasis>ack</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The I2CReceive command will send <literal><emphasis>data</emphasis></literal> through the I2C connection. If
<literal><emphasis>ack</emphasis></literal> is TRUE, or no value is given for <literal><emphasis>ack</emphasis></literal>, then <literal>I2CReceive</literal> will send
an ack.</simpara>
<simpara>If in master mode, <literal>I2CReceive</literal> will read the data immediately.</simpara>
<simpara>If in slave mode, <literal>I2CReceive</literal> will wait for the master to send the data
before reading. When the method <literal>I2CReceive</literal> is used in Slave mode the
global variable <literal>I2CMatch</literal> will be set to true when the received value is
equal to the constant <literal>I2C_ADDRESS</literal>.</simpara>
<simpara><emphasis role="strong">Example 1 - Master Mode:</emphasis></simpara>
<screen>  ' I2C Receive - using the ChipIno board, see here for information. ' This program reads an I2C register and LED is set to on if the value  is over 100.
  ' This program will read from address 83, register 1.

  #chip 16F886, 8
  #config MCLRE_ON

  'I2C settings
  #define I2C_MODE Master
  #define I2C_DATA PORTC.4
  #define I2C_CLOCK PORTC.3

  'Misc settings
  #define LED PORTB.5
  dir LED Out

  'Main loop
  Do
    'Send start
    I2CStart

    'Request value
    I2CSend 83
    I2CSend 1

    'Read value
    I2CReceive ValueIn

    'Send stop
    I2CStop

    'Turn on LED if received value &gt; 100
    Set LED Off
    If ValueIn &gt; 100 Then Set LED On

    'Delay
    Wait 20 ms

  Loop</screen>
<simpara><emphasis role="strong">Example 2 - Slave Mode:</emphasis></simpara>
<simpara>See the <link linkend="_i2c_overview">I2C Overview</link> for the
Master mode device to control this Slave mode device.</simpara>
<screen>  ' I2CReceive_Slave.gcb - using a 16F88.
  ' This program receives commands from a GCB Master. This Slave has three LEDs attached.

  ;----- Configuration

  #chip 16F88, 8
  #config MCLR_OFF


  #define I2C_MODE    Slave     ;this is a slave device now
  #define I2C_CLOCK   portb.4    ;SCL on pin 10
  #define I2C_DATA    portb.1    ;SDA on pin 7
  #define I2C_ADDRESS 0x60      ;address of the slave device

  ;----- Variables

  dim addr, reg, value as byte

  ;----- Program
  #define LED0  porta.2          ;pin 1
  #define LED1  porta.3          ;pin 2
  #define LED2  porta.4          ;pin 3

  dir LED0 out                  ;0, 1 and 2 are outputs (LEDs)
  dir LED1 out                  ;0, 1 and 2 are outputs (LEDs)
  dir LED2 out                  ;0, 1 and 2 are outputs (LEDs)

  do
    I2CStart                 ;wait for Start signal
    I2CReceive( addr )         ;then wait for an address

    if I2CMatch  = true then    ;if it matches, proceed

    I2CReceive(regval, ACK)   ;get the register number
    I2CReceive(value, ACK)    ;and its value
    I2CStop                   ;release the bus from this end

    select case regval        ;now turn proper LED on or off
      case 0:
      if value then
        set LED0 on
      else
        set LED0 off
      end if

      case 1:
      if value then
        set LED1 on
      else
        set LED1 off
      end if

      case 2:
      if value then
        set LED2 on
      else
        set LED2 off
      end if
      case else
           ;other register numbers are ignored
    end select
    else
     I2CStop           ;release bus in any event
    end if

  loop</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2creset">
<title>I2CReset</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    I2CReset</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This will attempt a reset of the I2C by changing the state of the I2C
bus.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen> ...
	I2CReset
 ...</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2crestart">
<title>I2CRestart</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    I2CRestart</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>If the I2C routines are operating in Master mode, this command will send
a start and restart condition in a single command.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen> ...
	I2CRESTART
 ....</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2csend">
<title>I2CSend</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>	I2CSend <emphasis>data</emphasis>
	I2CSend <emphasis>data</emphasis>, <emphasis>ack</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The I2CSend command will send <emphasis>data</emphasis> through the I2C connection. If
<literal><emphasis>ack</emphasis></literal> is TRUE, or no value is given for <literal><emphasis>ack</emphasis></literal>, then <literal>I2CSend</literal> will wait
for an Ack from the receiver before continuing.
If in master mode, <literal>I2CSend</literal> will send the data immediately. If in slave
mode, <literal>I2CSend</literal> will wait for the master to request the data before
sending.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>	' I2CSend - using the ChipIno board, see here for information.
	' This program send commands to a GCB Slave with three LEDs attached.

	#chip 16F886, 8
	#config MCLRE_ON

	'I2C settings
	#define I2C_MODE Master
	#define I2C_DATA PORTC.4
	#define I2C_CLOCK PORTC.3
	#define I2C_BIT_DELAY 20 us
	#define I2C_CLOCK_DELAY 30 us


	#define I2C_ADDRESS 0x60      ;address of the slave device
	;----- Variables

	dim reg as byte

	;----- Program

	do

	  for reg = 0 to 2            ;three LEDs to control
		I2CStart                  ;take control of the bus
		I2CSend I2C_ADDRESS       ;address the device
		if I2CSendState = ACK then
		  I2CSend reg               ;address the particular register
		  I2CSend ON                ;command to turn on LED
		end if
		I2CStop                   ;relinquish the bus
		wait  100 ms
	  next reg
	  wait 1 S                  ;pause to show results

	  for reg = 0 to 2            ;similarly, turn them off
		I2CStart                  ;take control of the bus
		I2CSend I2C_ADDRESS       ;address the device
		if I2CSendState = ACK then
		  I2CSend reg               ;address the particular register
		  I2CSend OFF               ;command to turn off LED
		end if
		I2CStop                   ;relinquish the bus
		wait  100 ms
	  next reg
	  wait 1 S                  ;pause to show results

	loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>	'This program will act as an I2C analog to digital converter
	'When data is requested from address 83, registers 0 through
	'3, it will return the value of AN0 through AN3.

	'Chip model
	#chip 16F88, 8

	'I2C settings
	#define I2C_MODE Slave
	#define I2C_CLOCK PORTB.0
	#define I2C_DATA PORTB.1

	#define I2C_DISABLE_INTERRUPTS ON

	'Main loop
	Do
		'Wait for start condition
		I2CStart

		'Get address
		I2CReceive Address
		If Address = 83 Then
			'If address was this device's address, respond
			I2CReceive Register

			OutValue = ReadAD(Register)
			I2CSend OutValue
		End If

		I2CStop

		Wait 5 ms
	Loop</screen>
<simpara><emphasis role="strong">Specific control of I2CSend</emphasis></simpara>
<simpara>The I2CSend method can be controller with command(s) the change the behaviour of method.&#160;&#160;The behaviour can be changed as a Prefix or Suffix therefore the start or end of the method.</simpara>
<simpara>The two macros ( defined constants) are I2CPreSendMacro and I2CPostSendMacro.&#160;&#160;The macros must be a single line, with colon delimiters are permitted.</simpara>
<simpara><emphasis>Examples</emphasis></simpara>
<simpara>The following defined macros change the start and end behaviour.</simpara>
<screen>		#define I2CPreSendMacro if LabI2CState &lt;&gt; True then exit Sub  'I2CPreSendMacro to ensure GLCD operations only operate within specfic lab
		#define I2CPostSendMacro if LabI2CState = True then MSSP =1   'I2CPostSendMacro to ensure GLCD operations only operate within specfic lab setting a specific variable.</screen>
<simpara>The following defined macro changes- the start  behaviour to call an alternative I2CSend method.</simpara>
<screen>		#define I2CPreSendMacro     myI2CSend: exit sub


        sub myI2CSend
            // your i2C handler
        end sub</screen>
<simpara>The following defined macros changes- the start  behaviour to call an alternative I2CSend method, then jump to the I2CPostSendMacroLabel which is at the end of I2CSend method.</simpara>
<screen>		#define I2CPreSendMacro         myI2CSend: goto I2CPostSendMacroLabel
        #define I2CPostSendMacro        NOP

        sub myI2CSend
            // your i2C handler
        end sub</screen>
<simpara>This will generate the following ASM.&#160;&#160;The I2CPreSendMacro calls the MYI2CSEND() methhod, then BRAnches to the label I2CPOSTSENDMACROLABEL as the end of the method.</simpara>
<screen>		;Source: i2c.h (339)
		I2CSEND
		;I2CPreSendMacro
			rcall	MYI2CSEND
			bra	I2CPOSTSENDMACROLABEL
		;I2C_CLOCK_LOW                 'begin with SCL=0
			bcf	TRISC,3,ACCESS
			bcf	LATC,3,ACCESS
		...
		lots of ASM
		...
		;wait I2C_BIT_DELAY            'wait the usual bit length
			nop
			nop
		I2CPOSTSENDMACROLABEL
		;I2CPostSendMacro
			nop
			return</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2cstart">
<title>I2CStart</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    I2CStart</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>If the I2C routines are operating in Master mode, this command will send
a start condition. If routines are in Slave mode, it will pause the
program until a start condition is sent by the master. It should be
placed at the start of every I2C transmission.</simpara>
<simpara>If interrupt handling is enabled, this command will disable it.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>Please see <link linkend="_i2csend">I2CSend</link> and <link linkend="_i2creceive">I2CReceive</link>
for an example.</simpara>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2cstartoccurred">
<title>I2CStartoccurred</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    I2CStartoccurred</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>If the I2C routine IS operating in Slave mode, this function will check if a start condition has occurred since the last run of this function.
	'Only used in slave mode</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>Please see <link linkend="_i2csend">I2CSend</link> and <link linkend="_i2creceive">I2CReceive</link>
for an example.</simpara>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2cstop">
<title>I2CStop</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    I2CStop</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>When in Master mode, this command will send an I2C stop condition, and
re-enable interrupts if <literal>I2CStart</literal> disabled them. In Slave mode, it will
re- enable interrupts.</simpara>
<simpara><literal>I2CStop</literal> should be called at the end of every I2C transmission.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>Please see <link linkend="_i2csend">I2CSend</link> and <link linkend="_i2creceive">I2CReceive</link>
for an example.</simpara>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
</section>
<section xml:id="_i2c_twi_hardware_module">
<title>I2C/TWI Hardware Module</title>
<simpara>This is the I2C/TWI section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_hi2c_overview">
<title>HI2C Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>These methods allow GCBASIC programs to send and receive Inter- Integrated Circuit (I2C™) messages via:</simpara>
<itemizedlist>
<listitem>
<simpara>Master Synchronous Serial Port (MSSP) module of the microcontroller for the Microchip PIC architecture, or</simpara>
</listitem>
<listitem>
<simpara>ATMEL 2-wire Serial Interface (TWI) for the Atmel AVR microcontroller architecture.</simpara>
</listitem>
</itemizedlist>
<simpara>These methods are serial interfaces that are useful for communicating with other peripheral or microcontroller devices.
These peripheral devices may be serial EEPROMs, shift registers, display drivers, A/D converters, etc.</simpara>
<simpara>This method can operate in one of two operational modes:</simpara>
<itemizedlist>
<listitem>
<simpara>Master Mode, or</simpara>
</listitem>
<listitem>
<simpara>Slave mode (with general address call)</simpara>
</listitem>
</itemizedlist>
<simpara>These methods fully implement all the I2C master and slave functions (including general call support) and
supports interrupts on start and stop bits in hardware to determine a free bus (multi-master function).</simpara>
<simpara>These methods implement the standard mode specifications as well as 7-bit and 10-bit addressing.
A “glitch” filter is built into the SCL and SDA pins when the pin is an input.  This filter operates in both
the 100 KHz and 400 KHz modes. In the 100 KHz mode, when these pins are an output, there
is a slew rate control of the pin that is independent of device frequency.</simpara>
<simpara>A hardware I2C/TWI module within the microcontroller is required for these methods.</simpara>
<simpara>The driver supports two hardware I2C ports.  The second port is addressed by the suffix HI2C2.  All HI2C commands are applicable to the second HI2C2 port.</simpara>
<simpara>For the Microchip I2C modules Specific for the 18F class including the K42, K83 and Q10, see the later section regarding clock sources and I2C frequencies.</simpara>
<simpara>The method supports the following frequencies:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Frequency</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Support</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Up to 400 kbits/s</simpara></entry>
<entry align="left" valign="top"><simpara>I2C/TWI <literal>fast mode</literal>: Defined as transfer rates up to 400 kbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>Supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Up to 100 kbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>I2C/TWI <literal>standard mode</literal>:  Defined as transfer rates up to 100 kbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>Supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Up to 1 Mbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>I2C <literal>fast-mode plus</literal>: Allowing up to 1 Mbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>Supported on I2C Module Only
</simpara><simpara>Requires alternative clock source to be set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Up to 3.4 Mbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>I2C <literal>high speed</literal>: Allowing up to 3.4 Mbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>Supported on I2C Module Only
</simpara><simpara>Requires alternative clock source to be set.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants control the setup of the hardware I2C methods:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Usage</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Master</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operational mode of the microcontroller</simpara></entry>
<entry align="left" valign="top"><simpara><literal>HI2CMode ( <emphasis>Master</emphasis> )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Slave</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operational mode of the microcontroller</simpara></entry>
<entry align="left" valign="top"><simpara><literal>HI2CMode ( <emphasis>Slave</emphasis> )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HI2C_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operational speed of the microcontroller. Defaults to 100 kbit/s</simpara></entry>
<entry align="left" valign="top"><simpara>For Microchip SSP or MSSP modules and AVR microcontrollers:
</simpara><simpara><literal>#define HI2C_BAUD_RATE 400</literal>   or <?asciidoc-br?>
<literal>#define HI2C_BAUD_RATE 100.</literal><?asciidoc-br?>
Where  <literal>#define HI2C_BAUD_RATE 100</literal> is the default value and therefore does need to be specified.
</simpara><simpara>For Microchip I2C module:
</simpara><simpara>'define HI2C_BAUD_RATE 125' is the default KHz.  You can override this value if you set up an alternative clock source.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HI2CITSCLWaitPeriod</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the TSCL period to Zero as the Stop condition must be held for TSCL after Stop transition.
Default to 70, some solutions can use this set to 0. The clock source and clock method must be reviewed before changing this setting.</simpara></entry>
<entry align="left" valign="top"><simpara>#define HI2CITSCLWaitPeriod 70</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Port Settings:</emphasis></simpara>
<simpara>The settings of the pin direction is critical to the operation of these
methods.
<?asciidoc-br?>
For the Microchip SSP/MSSP modules both ports <emphasis role="strong">must</emphasis> be set as <emphasis role="strong">input</emphasis>.
<?asciidoc-br?>
For the  Microchip I2C module both ports <emphasis role="strong">must</emphasis> be set as <emphasis role="strong">output</emphasis>.  And, configure the pins as open-drain and set the I2C levels - see example below for usage.
<?asciidoc-br?>
In all case the data and clock line *must * be pulled up with an
appropriate resistor (typically 4.k @ 5.0v for 100Mkz transmissions).
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>HI2C_DATA</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pin on microcontroller connected to I2C data</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HI2C_CLOCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pin on microcontroller connected to I2C clock)</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<emphasis role="strong">Microchip I2C modules Specific Support - 18F class including the K42, k47, K83, Q43, Q40/Q41, Q83/Q84, and Q71</emphasis></simpara>
<simpara>Clock Sources: The Microchip I2C can select one of ten clocks sources as shown in the table below.  I2C1Clock_MFINTOSC is the default which supports 125KHz.
<?asciidoc-br?>
<?asciidoc-br?>
It is important to change the clock source from the default of 125KHz if you want faster I2C communications.   Change the following constant to change the clock source.
Obviously, you setup the clock source correctly for I2C to operate:
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>        #define I2C1CLOCKSOURCE  I2C1CLOCK_MFINTOSC</screen>
<simpara>Clock Constants that can be I2C clock sources are</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Clock Source</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>I2C1CLOCK_SMT1</simpara></entry>
<entry align="left" valign="top"><simpara>SMT</simpara></entry>
<entry align="left" valign="top"><simpara>0x09+
</simpara><simpara>You MUST setup the SMT clock source.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1CLOCK_TIMER6PSO</simpara></entry>
<entry align="left" valign="top"><simpara>Timer 6 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>0x08+
</simpara><simpara>You MUST setup the timer6 clock source.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1CLOCK_TIMER4PSO</simpara></entry>
<entry align="left" valign="top"><simpara>Timer 4 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>0x07+
</simpara><simpara>You MUST setup the timer4 clock source.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1CLOCK_TIMER2PSO</simpara></entry>
<entry align="left" valign="top"><simpara>Timer 2 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>0x06+
</simpara><simpara>You MUST setup the timer3 clock source.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1CLOCK_TIMER0OVERFLOW</simpara></entry>
<entry align="left" valign="top"><simpara>Timer 0 Overflow</simpara></entry>
<entry align="left" valign="top"><simpara>0x05+
</simpara><simpara>You MUST setup the timer0 clock source.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1CLOCK_REFERENCEOUT</simpara></entry>
<entry align="left" valign="top"><simpara>Reference clock out</simpara></entry>
<entry align="left" valign="top"><simpara>0x04+
</simpara><simpara>You MUST ensure the clock source generates a within specification clock source.  Check the datasheet for more details.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1CLOCK_MFINTOSC</simpara></entry>
<entry align="left" valign="top"><simpara>MFINTOSC</simpara></entry>
<entry align="left" valign="top"><simpara>0x03 (default)+
</simpara><simpara>This is the default and will set the I2C clock to 125KHz</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1CLOCK_HFINTOSC</simpara></entry>
<entry align="left" valign="top"><simpara>HFINTOSC</simpara></entry>
<entry align="left" valign="top"><simpara>0x02+
</simpara><simpara>You MUST ensure the clock source generates a within specification clock source.  Check the datasheet for more details.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1CLOCK_FOSC</simpara></entry>
<entry align="left" valign="top"><simpara>FOSC</simpara></entry>
<entry align="left" valign="top"><simpara>0x01+
</simpara><simpara>You MUST ensure the clock source generates a within specification clock source.  Check the datasheet for more details.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1CLOCK_FOSC4</simpara></entry>
<entry align="left" valign="top"><simpara>FOSC/4</simpara></entry>
<entry align="left" valign="top"><simpara>0x00+
</simpara><simpara>You MUST ensure the clock source generates a within specification clock source.  Check the datasheet for more details.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
This an example of using a Clock Source.  This example uses the SMTClock source as the clock source, the following methods implement the SMT as the clock source.  The defintion of the constant, the include, setting of the SMT period, initialisation and starting of the clock source are ALL required.
<?asciidoc-br?></simpara>
<screen>    'Set the clock source constant
    #define I2C1CLOCKSOURCE I2C1CLOCK_SMT1

    'include the SMT capability
    #Include &lt;SMT_Timers.h&gt;

    'Setup the SMT
    '400 KHz @ 64MHZ
    Setsmt1Period ( 39 )
      ' 100 KHz @ 64MHZ
      ' Setsmt1Period ( 158 )
    'Initialise and start the SMT
    InitSMT1(SMT_FOSC,SMTPres_1)
    StartSMT1</screen>
<simpara>For other clock sources refer to the appropriate datasheet.
<?asciidoc-br?>
<?asciidoc-br?>
Error Codes: This module has extensive error reporting. For the standard error report refer to the appropriate datasheet.  GCBASIC also exposes the following error messages to enable the user code to handle the errors appropriately.  These are exposed via the variable <literal>HI2C1lastError</literal> - the bits of the <literal>HI2C1lastError</literal> are set as in the table shown below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Error Value/Bit</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>I2C1_GOOD</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1_FAIL_TIMEOUT</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1_TXBE_TIMEOUT</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1_START_TIMEOUT</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1_RESTART_TIMEOUT</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1_RXBF_TIMEOUT</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1_ACK_TIMEOUT</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1_MDR_TIMEOUT</simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C1_STOP_TIMEOUT</simpara></entry>
<entry align="left" valign="top"><simpara>128</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
Shown below are two examples of using Hardware I2C with GCBASIC.</simpara>
<simpara><?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis>
<?asciidoc-br?>
This example examines the IC2 modules using the Microchip SSP/MSSP module and the AVR microcontrollers.  This will display the result on a serial terminal.
This code will require adaption but the code shows an approach to
discover the IC2 devices.</simpara>
<screen>    #chip mega328p, 16
    #config MCLRE_ON

    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA PORTC.5
    #define HI2C_CLOCK PORTC.4
    'I2C pins need to be input for SSP module when used on Microchip PIC device
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in

    'MASTER MODE
    HI2CMode Master

    'USART/SERIAL PORT WORKS WITH max232 THEN TO PC Terminal
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    Dir PORTc.6 Out
    #define USART_DELAY 0 ms

    HSerPrintCRLF 2
    HSerPrint "Hardware I2C Discover using the "
    HSerPrint CHipNameStr
    HSerPrintCRLF 2

    for deviceID = 0 to 255
      HI2CStart
      HI2CSend ( deviceID )

      if HI2CAckPollState = false then

         if (( deviceID &amp; 1 ) = 0 ) then
         HSerPrint "W"
        else
         HSerPrint "R"
        end if
        HSerSend 9
        HSerPrint   "ID: 0x"
        HSerPrint   hex(deviceID)
        HSerSend 9
        HSerPrint "(d)"+str(deviceID)
        HSerPrintCRLF
        HI2CSend ( 0 )

      end if

      HI2CStop
    next
    HSerPrintCRLF
    HSerPrint   "End of Device Search"
    HSerPrintCRLF 2</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
This example examines the IC2 devices and displays on a serial terminal for the I2C module only.
<?asciidoc-br?>
This code will require adaption but the code shows an approach to discover the IC2 devices.
<?asciidoc-br?>
This code will only operate on the Microchip I2C module.
<?asciidoc-br?></simpara>
<screen>    #chip 18f25k42, 16
    #option Explicit
    #config MCLRE_ON

    #startup InitPPS, 85

    Sub InitPPS

          RC4PPS =      0x22   'RC4-&gt;I2C1:SDA1
          RC3PPS =      0x21   'RC3-&gt;I2C1:SCL1
          I2C1SCLPPS =  0x13   'RC3-&gt;I2C1:SCL1
          I2C1SDAPPS =  0x14   'RC4-&gt;I2C1:SDA1

          'Module: UART1
          RC6PPS = 0x0013     'TX1 &gt; RC6
          U1RXPPS = 0x0017    'RC7 &gt; RX1

    End Sub

    'Template comment at the end of the config file

    'Setup Serial port
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    ' Define I2C settings
    #define HI2C_BAUD_RATE 125
    #define HI2C_DATA PORTC.4
    #define HI2C_CLOCK PORTC.3
    'Initialise I2C - note for the I2C module the ports need to be set to Output.
    Dir HI2C_DATA out
    Dir HI2C_CLOCK out
    RC3I2C.TH0=1   'Port specific controls may be required - see the datasheet
    RC4I2C.TH0=1   'Port specific controls may be required - see the datasheet

    'For this solution we can set the TSCL period to Zero as the Stop condition must be held for TSCL after Stop transition
    #define HI2CITSCLWaitPeriod 0

    '*****************************************************************************************************
    'Main program commences here.. everything before this is setup for the board.

    dim DeviceID as byte
    Dim DISPLAYNEWLINE as Byte

     do

        HSerPrintCRLF
        HSerPrint "Hardware I2C "
        HSerPrintCRLF 2

          ' Now assumes Serial Terminal is operational
          HSerPrintCRLF
          HSerPrint "   "
          'Create a horizontal row of numbers
          for DeviceID = 0 to 15
            HSerPrint hex(deviceID)
            HSerPrint " "
          next

          'Create a vertical column of numbers
          for DeviceID = 0 to 255
            DisplayNewLine = DeviceID % 16
            if DisplayNewLine = 0 Then
              HSerPrintCRLF
              HserPrint hex(DeviceID)
              if DisplayNewLine &gt; 0 then
                HSerPrint " "
              end if
            end if
            HSerPrint " "

            'Do an initial Start
            HI2CStart
            if HI2CWaitMSSPTimeout &lt;&gt; True then

              'Send to address to device
              HI2CSend ( deviceID )

              'Did device fail to respond?
              if HI2CAckPollState = false then
                HI2CSend ( 0 )
                HSerPrint   hex(deviceID)
              Else
                HSerPrint "--"
              end if
              'Do a stop.
              HI2CStop

            Else
              HSerPrint "! "
            end if

          next

          HSerPrintCRLF 2
          HSerPrint   "End of Search"
          HSerPrintCRLF 2
          wait 1 s
          wait while SwitchIn = On
      loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cackpollstate">
<title>HI2CAckPollState</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    &lt;test condition[s]&gt; HI2CAckPollState</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Should only be used when I2C routines are operating in Master mode, this
command will return the last state of the acknowledge response from a
specific I2C device on the I2C bus.</simpara>
<simpara><literal>HI2CSend</literal> sets the state of variable <literal>HI2CAckPollState</literal>.<?asciidoc-br?>
<literal>HI2CAckPollState</literal> can only read - it cannot be set.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    &lt;test condition[s]&gt; HI2C2AckPollState</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example code would display the devices on the I2C bus.</simpara>
<screen>     ...
    for deviceID = 0 to 255
      HI2CStart
      HI2CSend ( deviceID )

      if <literal>HI2CAckPollState</literal> = false then
      HSerPrint "ID: 0x"
      HSerPrint hex(deviceID)
      HSerSend 9
      end if
    next
     ...</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2creceive">
<title>HI2CReceive</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CReceive <emphasis>data</emphasis>

    HI2CReceive <emphasis>data</emphasis>, ACK
    HI2CReceive <emphasis>data</emphasis>, NACK</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The HI2CReceive command will send <emphasis>data</emphasis> through the I2C connection. If
<literal><emphasis>ack</emphasis></literal> is TRUE, or no value is given for <literal><emphasis>ack</emphasis></literal>, then <literal>HI2CReceive</literal> will send
an ack to the I2C bus.</simpara>
<simpara>If in master mode, <literal>HI2CReceive</literal> will read the data immediately. If in
slave mode, <literal>HI2CReceive</literal> will wait for the master to send the data before
reading.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Receive  _data_

    HI2C2Receive _data_, ACK
    HI2C2Receive _data_, NACK</screen>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This program reads an I2C register and sets an LED if it is over 100.

    'It will read from I2C device with an address of 83, register 1.
    ' Change the processor
    #chip 16F1937, 32
    #config MCLRE_ON


    ' Define I2C settings
    #define HI2C_BAUD_RATE 400

    #define HI2C_DATA PORTC.4
      #define HI2C_CLOCK PORTC.3

    'I2C pins need to be input for SSP module
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in

    'MASTER I2C Device
    HI2CMode Master

    'Misc settings
    #define LED PORTB.0

    'Main loop
    Do
      'Send start
      HI2CStart

      'Request value
      HI2CSend 83
      HI2CSend 1

      'Read value
      HI2CReceive ValueIn

      'Send stop
      HI2CStop

      'Turn on LED if received value &gt; 100
      Set LED Off
      If ValueIn &gt; 100 Then Set LED On

      'Delay
      Wait 20 ms

    Loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<simpara>See the <link linkend="_i2c_overview">I2C Overview</link> for the Master mode
device to control this Slave mode device.</simpara>
<screen>    ' I2CHardwareReceive_Slave.gcb - using a 16F88.
    ' This program receives commands from a GCB Master. This Slave has three LEDs attached.

    ; This Slave device responds to address 0x60 and may only be written to.
    ; Within it, there are three registers, 0,1 and 2 corresponding to the three LEDs. Writing a zero
    ; turns the respective LED off. Writing anything else turns it on.


    #chip 16F88, 4
    #config  MCLR_Off

    #define I2C_MODE    Slave     ;this is a slave device now
    #define I2C_CLOCK   portb.4   ;SCL on pin 10
    #define I2C_DATA    portb.1   ;SDA on pin 7
    #define I2C_ADDRESS 0x60      ;address of the slave device

    #define I2C_BIT_DELAY 20 us
    #define I2C_CLOCK_DELAY 10 us
    #define I2C_END_DELAY 10 us


    'Serial settings
    #define SerInPort PORTB.6
    #define SerOutPort PORTB.7

    #define SendAHigh Set SerOutPort OFF
    #define SendALow Set SerOutPort On
    'Set pin directions
    Dir SerOutPort Out
    Dir SerInPort In

    'Set up serial connection
    InitSer 1, r2400, 1 + WaitForStart, 8, 1, none, INVERT
    wait 1 s

    #define LED0  porta.2          ;pin 1
    #define LED1  porta.3          ;pin 2
    #define LED2  porta.4          ;pin 3

    ;----- Variables

    dim addr, reg, value,location as byte
    addr = 255
    reg = 255
    value = 255
    location = 0
    mempointer = 255

    ;----- Program

    dir LED0 out                  ;0, 1 and 2 are outputs (LEDs)
    dir LED1 out                  ;0, 1 and 2 are outputs (LEDs)
    dir LED2 out                  ;0, 1 and 2 are outputs (LEDs)

    set LED0 off
    set LED1 off
    set LED2 off

    #define SerialControlPort portb.3
    dir SerialControlPort in

    'Set up interrupt to process I2C

       dir I2C_CLOCK in           ; required to input for MSSP module
       dir I2C_DATA in            ; required to input for MSSP module
       SSPADD=I2C_ADDRESS         ; Slave address
       SSPSTAT=b'00000000'        ; configuration
       SSPCON=b'00110110'         ; configuration
       PIE1.SSPIE=1               ; enable interrupt


    repeat 3                      ;flash LEDs
      set LED0 on
      set LED1 on
      set LED2 on
      wait 50 ms
      set LED0 off
      set LED1 off
      set LED2 off
      wait  100 ms
    end Repeat

    oldvalue = 255                ; old value, set up value only
    oldreg = 255                  ; old value, set up value only

    UpdateLEDS                    ; call method to set LEDs
                    ; set up interrupt
    On Interrupt SSP1Ready call I2C_Interrupt

    do forever
       if reg &lt;&gt; oldreg then      ; only process when the reg is a new value
        oldreg = reg            ; retain old value
        show = 1                ; its time to show the LEDS!
        if  value &lt;&gt; oldvalue then    ; logic for tracking old values. You only want to update terminal once per change
          oldvalue = value
          show = 1
        end if
       end if

       UpdateLEDS                  ; Update date LEDs

                     ; update serial terminal
       if show = 1  and SerialControlPort = 1 then

        SerPrint 1, "0x"+hex(addr)
        SerSend 1,9

        SerPrint 1, STR(reg)
        SerSend 1,9

        SerPrint 1, STR(value)
        SerSend 1,10
        SerSend 1,13

        show = 0
       end if
    loop


    Sub I2C_Interrupt
      ' handle interrupt
      IF SSPIF=1 THEN                   ; its a valid interrupt

         IF SSPSTAT.D_A=0 THEN          ; its an address coming in!
          addr=SSPBUF
          IF addr=I2C_ADDRESS THEN    ; its our address

           mempointer = 0           ; set the memory pointer. This code emulates an EEPROM!

          end if
          IF addr = ( I2C_ADDRESS | 1 ) THEN    ; its our write address
           CKP = 0                            ; acknowledge command
                            ; If the SDA line was low (ACK), the transmit data must be loaded into
                            ; the SSPBUF register which also loads the SSPSR
                            ; register. Then, pin RB4/SCK/SCL should be enabled
                            ; by setting bit CKP.

           mempointer = 10                    ; set a pointer to track incoming write reqests
           if I2C_DATA = 0 then
            SSPBUF = 0x22
            CKP = 1
            readpointer = 0x55
           end if
          end if

         else

         if  SSPSTAT.P = 1 then             ' Stop bit has been detected - out of sequence
           ' handle event
         end if

         IF  SSPSTAT.S = 1 THEN             ' Start bit has been detected - out of sequence
           ' handle event
         END IF

         IF SSPSTAT.R_W = 0 THEN            ' Write operations requested

          SELECT CASE mempointer
               CASE 0
                reg = SSPBUF         ' incoming value
                mempointer++         ' increment our counter
               CASE 1
                value = SSPBUF       ' incoming value
                mempointer++         ' increment our counter
               CASE ELSE
                dummy = SSPBUF       ' incoming value
          END SELECT

         ELSE                                ' Read operations
          SSPBUF = readpointer             ' incoming value
          readpointer++                    ' increment our counter

         END IF
         END IF
         CKP = 1                               ' acknowledge command
         SSPOV = 0                             ' acknowledge command
      END IF
      SSPIF=0
    END SUB



    sub UpdateLEDS

      select case reg           ;now turn proper LED on or off
        case 0
        if value = 1 then
          set LED0 on
        else
          set LED0 off
        end if

        case 1
        if value = 1 then
          set LED1 on
        else
          set LED1 off
        end if

        case 2
        if value = 1 then
          set LED2 on
        else
          set LED2 off
        end if

      end select

    End Sub</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2crestart">
<title>HI2CRestart</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CRestart</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>If the HI2C routines are operating in Master mode, this command will
send a start and restart condition in a single command.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Restart</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    do
        HI2CReStart                           ;generate a start signal
        HI2CSend(eepDev)                      ;inidcate a write
    loop While HI2CAckPollState

    HI2CSend(eepAddr_H)                   ;as two bytes
    HI2CSend(eepAddr)
    HI2CReStart
    HI2CSend(eepDev + 1)                  ;indicate a read

    eep_i = 0                             ;loop consecutively
    do while (eep_i &lt; eepLen)             ;these many bytes
        eep_j = eep_i + 1                   ;arrays begin at 1 not 0
        if (eep_i  &lt; (eepLen - 1)) then
        HI2CReceive(eepArray(eep_j), ACK)  ;more data to get
        else
        HI2CReceive(eepArray(eep_j), NACK ) ;send NACK on last byte
        end if
        eep_i++                             ;get set for next
    loop
    HI2CStop</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
<literallayout class="monospaced">==== HI2CSend</literallayout>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CSend <emphasis>data</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The HI2CSend command will send <literal><emphasis>data</emphasis></literal> through the I2C connection.
If in master mode, HI2CSend will send the data immediately. If in slave
mode, HI2CSend will wait for the master to request the data before
sending.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Send  data</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example code retrieves multiple bytes from an EEPROM memory device.</simpara>
<screen>	do
	  HI2CReStart                         ;generate a start signal
	  HI2CSend(eepDev)                    ;indicate a write
	loop While HI2CAckPollState

	HI2CSend(eepAddr_H)                   ;as two bytes
	HI2CSend(eepAddr)
	HI2CReStart
	HI2CSend(eepDev + 1)                  ;indicate a read

	eep_i = 0                             ;loop consecutively
	do while (eep_i &lt; eepLen)             ;these many bytes
	  eep_j = eep_i + 1                   ;arrays begin at 1 not 0
	  if (eep_i  &lt; (eepLen - 1)) then
		HI2CReceive(eepArray(eep_j), ACK)  ;more data to get
	  else
		HI2CReceive(eepArray(eep_j), NACK ) ;send NACK on last byte
	  end if
	  eep_i++                             ;get set for next
	loop
	HI2CStop</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cstart">
<title>HI2CStart</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CStart</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>If the HI2C routines are operating in Master mode, this command will
send a start condition. If routines are in Slave mode, it will pause the
program until a start condition is sent by the master. It should be
placed at the start of every I2C transmission.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Start</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>Please see <link linkend="_hi2csend">HI2CSend</link> and <link linkend="_hi2creceive">HI2CReceive</link> for
examples.</simpara>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cstartoccurred">
<title>HI2CStartOccurred</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CStartOccurred</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Check if a start condition has occurred since the last run of this
function</simpara>
<simpara>Only used in slave mode.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2StartOccurred</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cmode">
<title>HI2CMode</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CMode Master | Slave</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Sets the microcontroller to either a Master device or a Slave device.</simpara>
<simpara>Only used in slave mode</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Mode Master | Slave</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2csetaddress">
<title>HI2CSetAddress</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CSetAddress address_number</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Sets the microcontroller address number in Slave mode.</simpara>
<simpara>Only used in slave mode.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2SetAddress address_number</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cstop">
<title>HI2CStop</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CStop</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>HI2CStop</literal> should be called at the end of every I2C transmission.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Stop</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>Please see <link linkend="_hi2csend">HI2CSend</link> and <link linkend="_hi2creceive">HI2CReceive</link> for an
example.</simpara>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cstopped">
<title>HI2CStopped</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CStopped</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>In Slave mode only. Check if start condition received since last used of
HI2CStopped.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Stopped</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cwaitmssp">
<title>HI2CWaitMSSP</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CWaitMSSP</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The methods sets the global byte variable <emphasis>HI2CWaitMSSPTimeout</emphasis> to 255 ( or True ) if the MSSP module has timeout during operations.</simpara>
<simpara><emphasis>HI2CWaitMSSPTimeout</emphasis> can tested for the status of the I2C bus.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2WaitMSSP</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
</section>
<section xml:id="_sound">
<title>Sound</title>
<simpara>This is the Sound section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_sound_overview">
<title>Sound Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>These GCBASIC methods generate tones of a given frequency and duration.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Method</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Tone</simpara></entry>
<entry align="left" valign="top"><simpara>Generate a specified tone for a specified duration in terms of a frequency of a specified Mhz and units of 10ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ShortTone</simpara></entry>
<entry align="left" valign="top"><simpara>Generate a specified tone for a specified duration in terms of a frequency of a 10Mhz and units of 1ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Play</simpara></entry>
<entry align="left" valign="top"><simpara>Play a tune string.  The format of the string is the QBASIC play command.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PlayRTTTL</simpara></entry>
<entry align="left" valign="top"><simpara>Play a tune string.  The format of the string is the Nokia cell phone RTTTL format.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the tone generation routines. To set them, place a line in the main program file that uses <literal>#define</literal> to assign a value to the particular constant.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>SoundOut</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The output pin to produce sound on</simpara></entry>
<entry align="left" valign="top"><simpara>N/A - <emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong"><emphasis>Note:</emphasis></emphasis> If an exact frequency is required, or a smaller program is needed, these routines should not be used. Instead, you should use code like this:</simpara>
<screen>    Repeat <emphasis>count</emphasis>
    PulseOut SoundOut, <emphasis>period</emphasis> us
    Wait <emphasis>period</emphasis> us
    End Repeat</screen>
<simpara>Set <literal><emphasis>count</emphasis></literal> and <literal><emphasis>period</emphasis></literal> to the appropriate values as follows:</simpara>
<simpara><literal><emphasis>period</emphasis></literal> to 1000000 / desired frequency / 2<?asciidoc-br?>
<literal><emphasis>count</emphasis></literal> to desired duration / <emphasis>period</emphasis>.</simpara>
</section>
<section xml:id="_tone">
<title>Tone</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Tone <emphasis>Frequency, Duration</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will produce the specified tone for the specified duration.
<literal><emphasis>Frequency</emphasis></literal> is measured in Hz, and <literal><emphasis>Duration</emphasis></literal> is in 10 ms units.</simpara>
<simpara>Please note that this command may not produce the exact frequency
specified. While it is accurate enough for error beeps and small pieces
of monophonic music, it should not be used for anything that requires a
highly precise frequency.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>'Sample program to produce a constant A note (440 Hz)
'on PORTB bit 1.
#chip 16F877A, 20
#define SoundOut PORTB.1

Do
    Tone 440, 1000
Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_sound_overview">Sound Overview</link></simpara>
</section>
<section xml:id="_shorttone">
<title>ShortTone</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ShortTone Frequency, Duration</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will produce the specified tone for the specified duration.
Frequency is measured in units of 10 Hz, and Duration is in 1 ms units.
Please note that this command may not produce the exact frequency
specified. While it is accurate enough for error beeps and small pieces
of monophonic music, it should not be used for anything that requires a
highly precise frequency.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Sample program to produce a tone on PORTB bit 1, based on the
    'reading of an LDR on AN0 (usually PORTA bit 0).

    #chip 16F88, 20
    #define SoundOut PORTB.1

    Dir PORTA.0 In

    Do
        ShortTone ReadAD(AN0), 100
    Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_sound_overview">Sound Overview</link></simpara>
</section>
<section xml:id="_play">
<title>Play</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Play SoundPlayDataString</screen>
<simpara>You must specify the following include and the port of the sound device.</simpara>
<screen>    #include &lt;songplay.h&gt;
    #define SOUNDOUT PORTN.N</screen>
<simpara><emphasis role="strong">Command Availability::</emphasis>
Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
This command will plays a QBASIC sequence of notes. The SoundPlayDataString is a string representing a musical note or notes to play where Notes are A to G.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>A - G</simpara></entry>
<entry align="left" valign="top"><simpara>May be followed by length: 2 = half note, 4 = quarter, also may be followed by # or + (sharp) or - (flat).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>On</simpara></entry>
<entry align="left" valign="top"><simpara>Sets current octave. n is octave from 0 to 6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Pn</simpara></entry>
<entry align="left" valign="top"><simpara>Pause playing. n is length of rest</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ln:</simpara></entry>
<entry align="left" valign="top"><simpara>Set default note length. n = 1 to 8.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>&lt; or &gt;</simpara></entry>
<entry align="left" valign="top"><simpara>Change down or up an octave</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Tn:</simpara></entry>
<entry align="left" valign="top"><simpara>Sets tempo in L4s/minute. n = 32 to 255, default 120.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Nn</simpara></entry>
<entry align="left" valign="top"><simpara>Play note n. n = 0 to 84, 0 = rest.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Unsupported QBASIC commands are</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>M</simpara></entry>
<entry align="left" valign="top"><simpara>Play mode</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>.</simpara></entry>
<entry align="left" valign="top"><simpara>Changes note length</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For more information on the QBASIC PLAY command set, see <link xlink:href="https://en.wikibooks.org/wiki/QBasic/Appendix">https://en.wikibooks.org/wiki/QBasic/Appendix</link></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Sample program to play a string
    'on PORTB bit 1.
    #chip 16F877A, 20
    #include &lt;songplay.h&gt;
    #define SoundOut PORTB.1


    play "C C# C C#"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_sound_overview">Sound Overview</link></simpara>
</section>
<section xml:id="_play_rtttl">
<title>Play RTTTL</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PlayRTTTL SoundPlayRTTTLDataString</screen>
<simpara>You must specify the following include and the port of the sound device.</simpara>
<screen>    #include &lt;songplay.h&gt;
    #define SOUNDOUT PORTN.N</screen>
<simpara><emphasis role="strong">Command Availability::</emphasis>
Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
This command will play a sequence of notes in the Nokia RTTTL string format.</simpara>
<simpara>The SoundPlayRTTTLDataString is a string representing a musical note or notes to play where Notes are A to G. This format and information below is credited to WikiPedia, see here.
To be recognized by ringtone programs, an RTTTL/Nokring format ringtone must contain three specific elements: name, settings, and notes.   For example, here is the RTTTL ringtone for Haunted House:</simpara>
<simpara>HauntHouse: d=4,o=5,b=108: 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4, 1p, 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4</simpara>
<simpara>The three parts are separated by a colon.</simpara>
<itemizedlist>
<listitem>
<simpara>Part 1: name of the ringtone (here: "HauntHouse"), a string of characters represents the name of the ringtone</simpara>
</listitem>
<listitem>
<simpara>Part 2: settings (here: d=4,o=5,b=108), where "d=" is the default duration of a note. In this case, the "4" means that each note with no duration specifier (see below) is by default considered a quarter note. "8" would mean an eighth note, and so on. Accordingly, "o=" is the default octave. There are four octaves in the Nokring/RTTTL format. And "b=" is the tempo, in "beats per minute".</simpara>
</listitem>
<listitem>
<simpara>Part 3: the notes. Each note is separated by a comma and includes, in sequence: a duration specifier, a standard music note, either a, b, c, d, e, f or g, and an octave specifier. If no duration or octave specifier are present, the default applies.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    #chip 16f877a
    #include &lt;songplay.h&gt;


    #define SOUNDOUT PORTA.4
    PlayRTTTL "HauntHouse: d=4,o=5,b=108: 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4, 1p, 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4"</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>		#chip 16f877a
    #include &lt;songplay.h&gt;

    'Defines
    #define SoundOut PORTC.0


    Dir SoundOut Out
    Dim SoundPlayRTTTLDataString as String


    wait 1 s
    SoundPlayRTTTLDataString = "Thegood,:d=4,o=6,b=63:32c,32f,32c,32f,c,8g_5,8a_5,f5,8p,32c,32f,32c,32f,c,8g_5,8a_5,d_"
    PlayRTTTL(SoundPlayRTTTLDataString)


    wait 1 s
    SoundPlayRTTTLDataString ="LedZeppel:d=4,o=6,b=80:8g,16p,8f_,16p,8f,16p,8e,16p,8d,8a5,8c,16p,8b5,16p,a_5,8a5,16f5,16e5,16d5,8p,16p,16a_5,16a_5,16a_5,8p,16p,16b5,16b5,16b5,8p,16p,16b5,16b5,16b5,8p,16p,16c,16c,16c,8p,16p,16c,16c,16c"
    PlayRTTTL(SoundPlayRTTTLDataString)


    Do Forever
    Loop
    End</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_sound_overview">Sound Overview</link></simpara>
</section>
</section>
<section xml:id="_timers">
<title>Timers</title>
<simpara>This is the Timers section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_timer_overview">
<title>Timer Overview</title>
<simpara>GCBASIC supports methods to set, clear, read, start and stop the microcontroller timers.</simpara>
<simpara>GCBASIC supports the following timers.</simpara>
<screen>    Timer 0
    Timer 1
    Timer 2
    Timer 3
    Timer 4
    Timer 5
    Timer 6
    Timer 7
    Timer 8
    Timer 10
    Timer 12</screen>
<simpara>Not all of these timers available on all microcontrollers. For example,
if a microcontroller has three timers, then typically only <literal>Timer0</literal>,
<literal>Timer1</literal> and <literal>Timer2</literal> will be available.</simpara>
<simpara>Please refer to the datasheet for your microcontroller to determine the supported
timers and if a specific timer is 8-bit or 16-bit.</simpara>
<simpara><emphasis role="strong">Calculating a Timer Prescaler:</emphasis></simpara>
<simpara>To initialise and change the timers you may have to change the Prescaler.</simpara>
<simpara>A Prescaler is an electronic counting circuit used to reduce a high frequency electrical signal to a lower frequency by integer division.
The prescaler takes the basic timer clock frequency and divides it by some value before being processed by the timer, according to how the Prescaler register(s) are configured.
The prescaler values that may be configured might be limited to a few fixed values, see the timer specfic page in this Help file or refer to the datasheet.</simpara>
<simpara>To use a Prescaler some simple integer maths is required, however, when calculating the Prescaler there is often be a tradeoff between resolution, where a high resolution requires a high clock frequency and range where a high clock frequency willl cause the timer to overflow more quickly.
For example, achieving 1 us resolution and a 1 sec maximum period using a 16-bit timer may require some clever thinking when using 8-bit timers.
Please ask for advice via the GCBASIC forum, or, search for some of the many great resources on the internet to calculate a Prescaler value.</simpara>
<simpara><emphasis role="strong">Common Langauge:</emphasis></simpara>
<simpara>Using timers has the following terms /common langauge.  This following paragraph is intended to explain the common language.</simpara>
<simpara>The Oscillator (OSC) is the system clock, this can be sourced from an internal or external source, OSC is same the as microcontroller Mhz.
This is called the the Frequency of the OSCillator (FOSC) or the System Clock.</simpara>
<simpara>On a Microchip PIC microcontroller, one machine code instruction is executed for every four system clock pulses.<?asciidoc-br?>
This means that instructions are executed at a frequency of FOSC/4.<?asciidoc-br?>
The Microchip PIC datasheets call this FOSC/4 or FOSC4.<?asciidoc-br?>
All Microchip PIC timer prescales are based on the FOSC/4, not the FOSC or the System Clock.<?asciidoc-br?>
As Prescale are based upon FOSC/4,  you must use FOSC/4 in your timer calculations to get the results you expect.<?asciidoc-br?>
All Prescale and Postscale values are integer numbers.</simpara>
<simpara>On Atmel AVR microcontroller, most machine code instructions will execute in a single clock pulse.</simpara>
<simpara><emphasis role="strong">Timer differences between Microchip PIC and Atmel AVR microcontrollers:</emphasis></simpara>
<simpara>Initialising a timer for a Microchip PIC microcontroller may not operate as expected when using the same code for an Atmel AVR microcontroller by simply changing the <literal>#chip</literal> definition.
You <emphasis role="strong">must</emphasis> recalculate the Prescaler of a timer when moving timer parameters between Microchip PIC and Atmel AVR microcontrollers.
And, of course, the same when moving timer parameters between Atmel AVR and Microchip PIC microcontrollers.</simpara>
<simpara><emphasis role="strong">Timer Best Practices:</emphasis></simpara>
<simpara>Initialising microcontrollers with very limited RAM using GCBASIC needs carefull consideration.
RAM may be need to be optimised by using ASM to control the timers.
You can use GCBASIC to create the timer related GCBASIC ASM code then manually edit the GCBASIC ASM to optmise RAM usage.
Add your revised and optimised ASM back into your program and then remove the no longer required calls the the GCBASIC methods.
If you need advice on this subject please ask for advice via the GCBASIC forum.</simpara>
<simpara><emphasis role="strong">Using Timers 2/4/6/8 on Microchip PIC microcontrollers.</emphasis></simpara>
<simpara>A Microchip PIC microcontroller can have one of two types of 8-bit timer 2/4/6/8.</simpara>
<simpara>The first type has only one clock source and that clock is the FOSC/4 source.</simpara>
<simpara>The second type is much more flexible and can have many different clock sources and supports more prescale values.</simpara>
<simpara>The timer type for a Microchip PIC microcontroller can be determined by checking for the existence of a T2CLKCON register, either in the Datasheet or in the GCBASIC "dat file" for the specific microcontroller.</simpara>
<simpara>If the microcontroller DOES NOT have a T2CLKCON register then ALL Timer 2/4/6/8 timers on that chip are the first type, and are configured using:</simpara>
<screen>    _InitTimer2 (PreScale, PostScale)_   'Timer2 is example for timer 2/4/6 or 8</screen>
<simpara>If the microcontroller DOES have a T2CLKCON register then ALL Timer 2/4/6/8 timers on that chip are the second type and are configured using:</simpara>
<screen>    _InitTimer2 (Source, PreScale, PostScale)_   'Timer2 is example for timer 2/4/6 or 8</screen>
<simpara>The possible <emphasis>Source</emphasis>, <emphasis>PreScale</emphasis> and <emphasis>PostScale</emphasis> constants for each type are shown in the GCBASIC Help file.  See each timer for the constants.</simpara>
<simpara>The "Period" of these timers is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&#160;&#160;&#160;The timer period registers are PR2, PR4, PR6 or PR8 for timer2, timer4, timer6 and timer8 respectively.  These registers are also called PRx and TMRx where the <emphasis role="strong"><literal>x</literal></emphasis> refers to specific timer number.</simpara>
<simpara>When a specific timer is enabled/started the TMRx timer register will increment until the TMRx register matches the value in the PRx register.&#160;&#160;&#160;At this time the TMRx register is cleared to 0 and the timer continues to increment until the next match of the PRx register, and so on until the timer is stopped.&#160;&#160;&#160;The lower the value of the PRx register, the shorter the timer period will be.&#160;&#160;&#160;The default value for the PRX register at power up is 255.</simpara>
<simpara>The timer interrupt flag (TMRxIF) is set based upon the number of match conditions as determine by the postscaler.&#160;&#160;&#160;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_cleartimer">
<title>ClearTimer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ClearTimer <emphasis>TimerNo</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC and Atmel AVR microcontrollers with built in timer modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>ClearTimer</literal> is used to clear the specified timer to a value of 0.</simpara>
<simpara><literal>Cleartimer</literal> can be used on-the-fly if desired, so there is no requirement to
stop the timer first.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    .....
    'Clear timer 1
    ClearTimer 1
    .....</screen>
<simpara><emphasis role="strong">See also, <link linkend="_inittimer1">InitTimer1</link></emphasis> article for an example.</simpara>
</section>
<section xml:id="_inittimer0">
<title>InitTimer0</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    InitTimer0 source, prescaler</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 0 module.</simpara>
<simpara>See also  see: <link linkend="_inittimer0_8bit_16bit">InitTimer0 8bit/16bit</link> for support for microcontrollers with a 8 bit/16 bit Timer 0 module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>InitTimer0</literal> will set up timer 0.</simpara>
<simpara>Parameters are required as detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal> or <literal>Ext</literal> where`Osc` is an internal oscillator and <literal>Ext</literal> is an external oscillator.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>Osc</literal> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&#160;&#160;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</simpara><simpara><literal>Ext</literal> - Selects the clock source attached to a specific exernal interrupt input port.&#160;&#160;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When the timer overflows from 255 to 0, a  <literal>Timer0Overflow</literal> interrupt will
be generated. This can be used in conjunction with <literal>On Interrupt</literal> to run a
section of code when the overflow occurs.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Microchip PIC microcontrollers:</emphasis></simpara>
<simpara>On Microchip PIC microcontrollers where the <literal><emphasis>prescaler</emphasis></literal> rate select bits are in the range of 2 to 256  you should use one of the following constants.  If the <literal><emphasis>prescaler</emphasis></literal> rate select bits are in the range of 1 to 32768 then see the subsequent table.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:2 and 1:256 of the oscillator
speed where the oscillator speed is (FOSC/4). The prescaler applies to
both the internal oscillator or the external clock.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Atmel AVR microcontrollers:</emphasis></simpara>
<simpara>On Atmel AVR microcontrollers <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<simpara>The prescaler will only apply when the timer is driven from the <literal>Osc</literal> the
internal oscillator - the prescaler has no effect when the external clock
source is specified.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1 for 8-bit timer 0:</emphasis></simpara>
<simpara>This code uses Timer 0 and On Interrupt to generate a Pulse Width Modulation
signal, that will allow the speed of a motor to be easily controlled.</simpara>
<screen>    #chip 16F88, 8

    #define MOTOR PORTB.0

    'Call the initialisation routine
    InitMotorControl

    'Main routine
    Do
        'Increase speed to full over 2.5 seconds
        For Speed = 0 to 100
            MotorSpeed = Speed
            Wait 25 ms
        Next
        'Hold speed
        Wait 1 s
        'Decrease speed to zero over 2.5 seconds
        For Speed = 100 to 0
            MotorSpeed = Speed
            Wait 25 ms
        Next
        'Hold speed
        Wait 1 s
    Loop

    'Setup routine
    Sub InitMotorControl
        'Clear variables
        MotorSpeed = 0
        PWMCounter = 0

        'Add a handler for the interrupt
        On Interrupt Timer0Overflow Call PWMHandler

        'Set up the timer using the internal oscillator with a prescaler of 1/2 (Equates to 0)
        'Timer 0 starts automatically on a Microchip PIC microcontroller, therefore, StartTimer is not required.
        InitTimer0 Osc, PS0_2

    End Sub

    'PWM sub
    'This will be called when Timer 0 overflows
    Sub PWMHandler
        If MotorSpeed &gt; PWMCounter Then
            Set MOTOR On
        Else
            Set MOTOR Off
        End If
        PWMCounter += 1
        If PWMCounter = 100 Then PWMCounter = 0
    End Sub</screen>
<simpara><emphasis role="strong">Example 1 for 18-bit timer 0 operating an 8-bit timer:</emphasis></simpara>
<simpara>The same example for a 16-bit timer 0 operating as an 8-bit timer.</simpara>
<screen>#chip 16f18855,32
#option Explicit
'timer test Program

dim speed, MotorSpeed, PWMCounter as byte

#define MOTOR PORTb.0
dir MOTOR out

'Call the initialisation routine
InitMotorControl

'Main routine
Do
    'Increase speed to full over 2.5 seconds
    For Speed = 0 to 100
        MotorSpeed = Speed
        Wait 25 ms
    Next
    'Hold speed
    Wait 1 s
    'Decrease speed to zero over 2.5 seconds
    For Speed = 100 to 0
        MotorSpeed = Speed
        Wait 25 ms
    Next
    'Hold speed
    Wait 1 s
Loop

'Setup routine
Sub InitMotorControl
    'Clear variables
    MotorSpeed = 0
    PWMCounter = 0

    'Add a handler for the interrupt
    On Interrupt Timer0Overflow Call PWMHandler

    InitTimer0(Osc, TMR0_FOSC4 + PRE0_1 , POST0_1)
    StartTimer 0

End Sub

'PWM sub
'This will be called when Timer 0 overflows
Sub PWMHandler

    If MotorSpeed &gt; PWMCounter Then
        Set MOTOR On
    Else
        Set MOTOR Off
    End If
    PWMCounter += 1
    If PWMCounter = 100 Then PWMCounter = 0

End Sub</screen>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
<section xml:id="_inittimer0_8bit_16bit">
<title>InitTimer0 8bit/16bit</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    InitTimer0 source, prescaler + clocksource, postscaler</screen>
<simpara>Timer are useful as timers can generate interrupts.
Timers can be used in conjunction with <literal>On Interrupt</literal> to run a section of code when a specific timer event occurs.
Example events are when the timer matches a specific value, or, the timer resets to a zero value.
For more details on timer events see <literal>On Interrupt</literal>.</simpara>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on microcontrollers with a Timer 0 where the timer has the capability of operating as an 8 bit or 16 bit timer.&#160;&#160;
This type of Timer 0 can be found on Microchip PIC 18(L)F, as well as small number of 18C and 16(L)F microcontrollers.&#160;&#160;
These timers can be configured for either 8-bit or 16-bit operation.</simpara>
<simpara>You may need to refer to the datasheet for your microcontroller to determine if it supports both 8-bit and 16-bit operations.</simpara>
<simpara><emphasis role="strong">Explanation for 8-bit timer:</emphasis></simpara>
<simpara>The default operation is as an 8-bit timer.&#160;&#160;
<literal>InitTimer0</literal> will set up timer 0.</simpara>
<simpara>Parameters are required as shown in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal> or <literal>Ext</literal> where`Osc` is an internal oscillator and <literal>Ext</literal> is an external oscillator.
</simpara><simpara><?asciidoc-br?>
<?asciidoc-br?>
<literal>Osc</literal> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&#160;&#160;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</simpara><simpara><literal>Ext</literal> - Selects the clock source attached to a specific exernal interrupt input port.&#160;&#160;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer, <emphasis role="strong">and</emphasis>, the clocksource
</simpara><simpara>See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.
</simpara><simpara>See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>8 bit Example:</emphasis></simpara>
<simpara>The example show in the <literal>osc</literal> as an internal source, a <literal>prescaler</literal> value of 256 witht the HFINTOSC <literal>clocksource</literal> and a <literal>postscaler</literal> value of 2</simpara>
<screen>    InitTimer0 Osc, PRE0_256 + TMR0_HFINTOSC ,  POST0_2
    'also, note when in 8-bit mode you MUST set the 8bit timer value to the upper byte of a WORD, when setting the `SetTimer`
    SetTimer 0, 0x5800   'Setting the HIGH byte!!!</screen>
<simpara><emphasis>16 bit Example:</emphasis></simpara>
<simpara>To use the 16 bit timer you need to add the constant <literal>#define TMR0_16bit</literal>.</simpara>
<simpara>The example show in the <literal>osc</literal> as an internal source, a <literal>prescaler</literal> value of 256 witht the HFINTOSC <literal>clocksource</literal> and a <literal>postscaler</literal> value of 2</simpara>
<screen>    #define TMR0_16bit
    InitTimer0 Osc, PRE0_256 + TMR0_HFINTOSC ,  POST0_2</screen>
<simpara><emphasis role="strong">Differences in Timer0 Operations</emphasis></simpara>
<simpara>The section refers to chips with a 8/16-bit Timer0.</simpara>
<simpara>When these chips are operating in 8-bit mode, Timer0 behaves much like Timers2/4/6. In 8-bit mode the TMR0H register does not increment. It instead becomes the Period or Match register and is aliased as "PR0"  (Period Register 0).</simpara>
<simpara>In 8-bit mode, Timer0 does not technically overflow. Instead when TMR0L increments and matches the value in the PR0 register, TMR0L is reset to 0. The interrupt flag bit (TMR0IF) bit is then set (based upon Postscaler).</simpara>
<simpara>The default value in the PR0 "match register" is 255.  This value can be set/changed in the user program to set/change the timer period. This can be used to fine tune the timer period.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Timer 0 mandated constants:</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal> or <literal>Ext</literal> where <literal>Osc</literal> is an internal oscillator and <literal>Ext</literal> is an external oscillator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.
You may also be required to specify one of the following clock sources.<?asciidoc-br?>
<?asciidoc-br?>
<literal>TMR0_CLC1</literal><?asciidoc-br?>
<literal>TMR0_SOSC</literal><?asciidoc-br?>
<literal>TMR0_LFINTOSC</literal><?asciidoc-br?>
<literal>TMR0_HFINTOSC</literal><?asciidoc-br?>
<literal>TMR0_FOSC4</literal><?asciidoc-br?>
<literal>TMR0_T0CKIPPS_Inverted</literal><?asciidoc-br?>
<literal>TMR0_T0CKIPPS_True</literal><?asciidoc-br?>
<?asciidoc-br?>
</simpara><simpara>You should use a simple addition to concatenate the prescaler with a specific clock source. For example.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>PRE0_16</literal> + <literal>TMR0_HFINTOSC</literal>
<?asciidoc-br?>
 <?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>See the tables below for permitted values for Microchip.<?asciidoc-br?>
Also, refer to the specific datasheet <literal><emphasis>postcaler</emphasis></literal> values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
Microchip PIC microcontrollers where the <literal><emphasis>prescaler</emphasis></literal> rate select bits are in the range of 1 to 32768  you should use one of the following constants.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:512</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_512</literal></simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2048</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_2048</literal></simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4096</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_4096</literal></simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8192</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_8192</literal></simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16384</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_16384</literal></simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32768</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_32768</literal></simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:1 and 1:32768 of the oscillator
speed where the oscillator speed is (FOSC/4). The prescaler applies to
both the internal oscillator or the external clock.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>On Microchip PIC microcontrollers where the <literal><emphasis>prescaler</emphasis></literal> rate select bits are in the range of 2 to 256  you should use one of the following constants.  If the <literal><emphasis>prescaler</emphasis></literal> rate select bits are in the range of 1 to 32768 then see the subsequent table.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:2 and 1:256 of the oscillator
speed where the oscillator speed is (FOSC/4). The prescaler applies to
both the internal oscillator or the external clock.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>On Microchip PIC microcontroller that require <literal><emphasis>postscaler</emphasis></literal> is can be one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Use Numeric Constant</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:3</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_3</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:5</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_5</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:6</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_6</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:7</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_7</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:9</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_9</literal></simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:10</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_10</literal></simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:11</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_11</literal></simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:12</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_12</literal></simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:13</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_13</literal></simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:14</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_14</literal></simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:15</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_15</literal></simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This code uses Timer 0 and On Interrupt to flash an LED.</simpara>
<screen>/*

Remember four things to setup a timer.

1.  InitTimer0 source, prescaler + clocksource, postscaler

2.  SetTimer (byte_value, value ), or
    SetTimer (word_value [where the High byte sets the timer], value )

3.  StartTimer 0

    and, optionally use

4.  ClearTimer 0

*/

    'Chip Settings.
    #CHIP 16f18313, 32

    Dir porta.1 Out

    'Setup the timer.
    '          Source, Prescaler  + Clock Source    , Postscaler
    InitTimer0 Osc,    PRE0_16384 + TMR0_HFINTOSC   , POST0_11

    ' Set the Timer start value.  Use the HIGH byte of the word when using an 8/16bit timer in 8 bit mode
    SetTimer ( 0, 0x5800 )

    ' Start the Timer by writing to TMR0ON bit
    StartTimer 0


    Do
        Wait While TMR0IF = 0
        ' Clearing timer flag
        TMR0IF = 0
        porta.1 = ! porta.1

    Loop</screen>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
<simpara>See also  see: <link linkend="_inittimer0">InitTimer0</link> for microcontroller with only an 8 bit Timer 0 module.</simpara>
</section>
</section>
<section xml:id="_inittimer1">
<title>InitTimer1</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    InitTimer1 <emphasis>source, prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 1 module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>InitTimer1</literal> will set up timer 1.</simpara>
<simpara>Parameters are required as detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal>, <literal>Ext</literal> or <literal>ExtOsc</literal> where:<?asciidoc-br?>
<literal>Osc</literal> is an internal oscillator.<?asciidoc-br?>
<literal>Ext</literal> is an external oscillator.<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<literal>Osc</literal> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&#160;&#160;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</simpara><simpara><literal>Ext</literal> - Selects the clock source attached to a specific exernal interrupt input port.&#160;&#160;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.
<?asciidoc-br?>
<?asciidoc-br?>
</simpara><simpara><literal>ExtOsc</literal> is an external oscillator and only available on a Microchip PIC microcontroller.
</simpara><simpara></simpara><simpara></simpara><simpara>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources.  This includes, but limited to,  the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller  series.  On these devices the clock source can be one of the following:
</simpara><simpara><literal>Osc</literal> is an internal oscillator which is the same source as <literal>FOSC4</literal>.<?asciidoc-br?>
<literal>Ext</literal>  is an external oscillator which is the same source as <literal>TxXKIPPS</literal>.<?asciidoc-br?>
<literal>ExtOsc</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>FOSC</literal> is an internal oscillator which is the Frequency of the OSCillator.<?asciidoc-br?>
<literal>FOSC4</literal> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<?asciidoc-br?>
<literal>SOSC</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>MFINTOSC</literal> is an internal 500KHz internal clock oscillator.<?asciidoc-br?>
<literal>LFINTOSC</literal>  is an internal 31Khz internal clock oscillator.<?asciidoc-br?>
<literal>HFINTOSC</literal> is an oscillator as specified within the datasheet for each specific microcontroller.<?asciidoc-br?>
<literal>TxCKIPPS</literal> is an oscillator input on TxCKIPPS Pin.<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When the timer overflows an interrupt event will be generated.
This interrupt event can be used in conjunction with <literal>On Interrupt</literal> to run a section of code when the interrupt event occurs.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Microchip PIC microcontrollers:</emphasis></simpara>
<simpara>On Microchip PIC microcontrollers <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS1_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS1_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS1_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS1_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>48</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:2 and 1:8 of the oscillator (FOSC/4)
speed. The prescaler will apply to either the oscillator or the external
clock input.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Atmel AVR microcontrollers:</emphasis></simpara>
<simpara>On the majority of Atmel AVR microcontrollers  <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<simpara>The prescaler will only apply when the timer is driven from the <literal>Osc</literal> the internal oscillator - the prescaler has no effect when the external clock source is specified.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:0</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_0</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS1_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>On Atmel AVR ATtiny15/25/45/85/216/461/861 microcontrollers <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<simpara>The prescaler will only apply when the timer is driven from the <literal>Osc</literal> the internal oscillator - the prescaler has no effect when the external clock source is specified.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:0</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_0</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:512</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_512</literal></simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2048</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_2048</literal></simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4096</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_4096</literal></simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8192</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_8192</literal></simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16384</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_16384</literal></simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1 (Microchip):</emphasis></simpara>
<simpara>This example will measure that time that a switch is depressed (or on) and will write the results to the EEPROM.</simpara>
<screen>    #chip 16F819, 20
    #define Switch PORTA.0

    Dir Switch In
    DataCount = 0

    'Initilise Timer 1
    InitTimer1 Osc, PS1_8

    Dim TimerValue As Word

    Do
        ClearTimer 1
        Wait Until Switch = On
        StartTimer 1
        Wait Until Switch = Off
        StopTimer 1

        'Read the timer
        TimerValue = Timer1

        'Log the timer value
        EPWrite(DataCount, TimerValue_H)
        EPWrite(DataCount + 1, TimerValue)
        DataCount += 2
    Loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2 (Atmel AVR):</emphasis></simpara>
<simpara>This example will flash the yellow LED on an Arduino Uno (R3) once every second.</simpara>
<literallayout class="monospaced">#Chip mega328p, 16  'Using Arduino Uno R3</literallayout>
<literallayout class="monospaced">#define LED PORTB.5
Dir LED OUT</literallayout>
<literallayout class="monospaced">Inittimer1  OSC, PS_256
Starttimer 1
Settimer 1, 3200  ;Preload Timer</literallayout>
<literallayout class="monospaced">On Interrupt Timer1Overflow Call Flash_LED</literallayout>
<literallayout class="monospaced">Do
    'Wait for interrupt
loop</literallayout>
<literallayout class="monospaced">Sub Flash_LED
   Settimer 1, 3200   'Preload timer
   pulseout LED, 100 ms
End Sub</literallayout>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_inittimer2">
<title>InitTimer2</title>
<simpara><emphasis role="strong">Syntax: (MicroChip PIC)</emphasis></simpara>
<screen>    InitTimer2 <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis>

or, where you required to state the clock source, use the following

    InitTimer2 <emphasis>clocksource</emphasis>, <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis></screen>
<simpara><emphasis role="strong">Syntax: (Atmel AVR)</emphasis></simpara>
<screen>    InitTimer2 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 2 module.&#160;&#160;As shown above a Microchip microcontroller can potentially support two types of methods for initialisation.
<?asciidoc-br?>
<?asciidoc-br?>
The first method is:
<?asciidoc-br?></simpara>
<screen>    InitTimer2 prescaler, postscaler</screen>
<simpara>This the most common method to initialise a Microchip microcontroller timer.&#160;&#160;With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
The second method is much more flexible in term of the clock source.&#160;&#160;Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values.&#160;&#160;The method is shown below:
<?asciidoc-br?></simpara>
<screen>    InitTimer2 clocksource, prescaler, postscaler</screen>
<simpara><emphasis role="strong">How do you determine which method to use for your specific Microchip microcontroller ?</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The timer type for a Microchip microcontroller can be determined by checking for the existance of a T2CLKCON register, either in the Datasheet or in the GCBASIC  "dat file" for the specific device.
<?asciidoc-br?>
<?asciidoc-br?>
If the Microchip microcontroller <emphasis role="strong">DOES NOT</emphasis> have a T2CLKCON register then timers 2/4/6/8 for that specific microcontroller chip use the first method, and are configured using:
<?asciidoc-br?></simpara>
<screen>    InitTimer2 (PreScale, PostScale)</screen>
<simpara>If the microcontroller <emphasis role="strong">DOES</emphasis> have a T2CLKCON register then ALL timers 2/4/6/8 for that specific microcontroller chip use the second method, and are configured using:</simpara>
<screen>    InitTimer2 (Source,PreScale,PostScale)</screen>
<simpara>The possible Source, Prescale and Postscale constants for each type are shown in the tables below.&#160;&#160;These table are summary tables from the Microchip datasheets.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Period of the Timers</emphasis></simpara>
<simpara>The Period of the timer is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&#160;&#160;The timer period for timer 2 is held in register PR2.&#160;&#160;
<?asciidoc-br?></simpara>
<simpara>When the timer is enabled, by starting the timer, it will increment until the TMR2 register matches the value in the PR2 register.&#160;&#160;At this time the TMR2 register is cleared to 0 and the timer continues to increment until the next match, and so on.
<?asciidoc-br?></simpara>
<simpara>The lower the value of the PR2 register, the shorter the timer period will be.&#160;&#160;The default value for the PR2 register at power up is 255.
<?asciidoc-br?></simpara>
<simpara>The timer interrupt flag (TMR2IF) is set based upon the number of match conditions as determine by the postscaler.&#160;&#160;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Timer constants for the MicroChip microcontrollers</emphasis></simpara>
<simpara>Parameters for this timer are detailed in the tables below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>clocksource</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is an optional parameter.  Please review the datasheet for specific usage.<?asciidoc-br?>
&#160;<?asciidoc-br?>
Source can be one of the following numeric values:<?asciidoc-br?>
&#160;<?asciidoc-br?>
         1 equates to OSC (FOSC/4). &#160;&#160;&#160;The default clock source<?asciidoc-br?>
        <?asciidoc-br?>
         6 equates to EXTOSC same as SOSC<?asciidoc-br?>
         5 equates to MFINTOSC<?asciidoc-br?>
         4 equates to LFINTOSC<?asciidoc-br?>
         3 equates to HFINTOSC<?asciidoc-br?>
         2 equates to FOSC<?asciidoc-br?>
         1 equates to FOSC/4 same as OSC<?asciidoc-br?>
         0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<?asciidoc-br?>
</simpara><simpara>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 1 shown above</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> can be one of the following settings, if you MicroChip microcontroller has the T2CKPS4 bit then refer to table 3:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 2 shown above</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 3 shown above</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal><emphasis>postscaler</emphasis></literal> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</simpara>
<simpara>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Eqautes to</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1:1 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:2 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_2</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:3 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_3</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:4 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_4</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:5 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_5</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:6 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_6</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:7 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_7</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:8 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_8</simpara></entry>
<entry align="left" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:9 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_9</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:10 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_10</simpara></entry>
<entry align="left" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:11 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_11</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:12 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_12</simpara></entry>
<entry align="left" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:13 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_13</simpara></entry>
<entry align="left" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:14 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_14</simpara></entry>
<entry align="left" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:15 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_15</simpara></entry>
<entry align="left" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:16 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_16</simpara></entry>
<entry align="left" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 4 shown above</emphasis></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Explanation:(Atmel AVR)</emphasis></simpara>
<simpara><literal>InitTimer2</literal> will set up timer 2, according to the settings given.</simpara>
<simpara><literal>source</literal> can be one of the following settings:
Parameters for this timer are detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal> or <literal>Ext</literal> where`Osc` is an internal oscillator and <literal>Ext</literal> is an external oscillator.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 5 shown above</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> for Atmel AVR Timer 2 is chip specific and can be selected from one of the two
tables shown below.  Please refer to the datasheet determine which table to use and which
prescales within that table are supported by a specific Atmel AVR microcontroller.</simpara>
<simpara>Table1: Prescaler Rate Select bits are in the range of 1 to 1024</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:0</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_0</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 6 shown above</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>Prescaler Rate Select bits are in the range of 1 to 16384</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_16</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_32</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_128</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:512</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_512</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2048</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_2048</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4096</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_4096</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8192</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_8192</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16384</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_16384</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 7 shown above</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example:</emphasis></simpara>
<simpara>This code uses Timer 2 and On Interrupt to flash an LED every 200 timer ticks.</simpara>
<screen>    #chip 16F1788, 8

    #DEFINE LED PORTA.1
    DIR LED OUT

    #Define Match_Val PR2 'PR2 is the timer 2 match register
    Match_Val = 200       'Interrupt afer 200 timer ticks

    On interrupt timer2Match call FlashLED  'Interrupt on match
    Inittimer2 PS2_64, 15 'Prescale 1:64 /Postscale 1:16 (15)
    Starttimer 2

    Do
      ' Wating for interrupt on match val of 100
    Loop

    'This sub will be called when Timer 2 matches "Match_Val" (PR2)
    SUB FlashLED
        pulseout LED, 5 ms
    END SUB</screen>
</section>
<section xml:id="_inittimer3">
<title>InitTimer3</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>InitTimer3 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 3 module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>InitTimer3</literal> will set up timer 3.</simpara>
<simpara>Parameters are required as detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal>, <literal>Ext</literal> or <literal>ExtOsc</literal> where:<?asciidoc-br?>
<literal>Osc</literal> is an internal oscillator.<?asciidoc-br?>
<literal>Ext</literal> is an external oscillator.<?asciidoc-br?>
</simpara><simpara><?asciidoc-br?>
<?asciidoc-br?>
<literal>Osc</literal> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&#160;&#160;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</simpara><simpara><literal>Ext</literal> - Selects the clock source attached to a specific exernal interrupt input port.&#160;&#160;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.
<?asciidoc-br?>
<?asciidoc-br?>
</simpara><simpara><literal>ExtOsc</literal> is an external oscillator and only available on a Microchip PIC microcontroller.
</simpara><simpara>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources.  This includes, but limited to,  the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller  series On these devices the clock source can be one of the following:
</simpara><simpara><literal>Osc</literal> is an internal oscillator which is the same source as <literal>FOSC4</literal>.<?asciidoc-br?>
<literal>Ext</literal>  is an external oscillator which is the same source as <literal>TxXKIPPS</literal>.<?asciidoc-br?>
<literal>ExtOsc</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>FOSC</literal> is an internal oscillator which is the Frequency of the OSCillator.<?asciidoc-br?>
<literal>FOSC4</literal> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<?asciidoc-br?>
<literal>SOSC</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>MFINTOSC</literal> is an internal 500KHz internal clock oscillator.<?asciidoc-br?>
<literal>LFINTOSC</literal>  is an internal 31Khz internal clock oscillator.<?asciidoc-br?>
<literal>HFINTOSC</literal> is an oscillator as specified within the datasheet for each specific microcontroller.<?asciidoc-br?>
<literal>TxCKIPPS</literal> is an oscillator input on TxCKIPPS Pin.<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When the timer overflows an interrupt event will be generated.
This interrupt event can be used in conjunction with <literal>On Interrupt</literal> to run a section of code when the interrupt event occurs.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Microchip PIC microcontrollers:</emphasis></simpara>
<simpara>On Microchip PIC microcontrollers <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS3_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS3_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS3_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS3_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>48</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:2 and 1:8 of the oscillator (FOSC/4)
speed. The prescaler will apply to either the oscillator or the external
clock input.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Atmel AVR microcontrollers:</emphasis></simpara>
<simpara>On the majority of Atmel AVR microcontrollers  <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<simpara>The prescaler will only apply when the timer is driven from the <literal>Osc</literal> the internal oscillator - the prescaler has no effect when the external clock source is specified.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:0</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_3_0</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_3_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_3_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_3_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_3_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_3_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_inittimer4">
<title>InitTimer4</title>
<simpara><emphasis role="strong">Syntax: (MicroChip PIC)</emphasis></simpara>
<screen>    InitTimer4 <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis>

or, where you required to state the clock source, use the following

    InitTimer4 <emphasis>clocksource</emphasis>, <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis></screen>
<simpara><emphasis role="strong">Syntax: (Atmel AVR)</emphasis></simpara>
<screen>    InitTimer4 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 4 module.&#160;&#160;As shown above a Microchip microcontroller can potentially support two types of methods for initialisation.
<?asciidoc-br?>
<?asciidoc-br?>
The first method is:
<?asciidoc-br?></simpara>
<screen>    InitTimer4 prescaler, postscaler</screen>
<simpara>This the most common method to initialise a Microchip microcontroller timer.&#160;&#160;With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
The second method is much more flexible in term of the clock source.&#160;&#160;Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values.&#160;&#160;The method is shown below:
<?asciidoc-br?></simpara>
<screen>    InitTimer4 clocksource, prescaler, postscaler</screen>
<simpara><emphasis role="strong">How do you determine which method to use for your specific Microchip microcontroller ?</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The timer type for a Microchip microcontroller can be determined by checking for the existance of a T2CLKCON register, either in the Datasheet or in the GCBASIC  "dat file" for the specific device.
<?asciidoc-br?>
<?asciidoc-br?>
If the Microchip microcontroller <emphasis role="strong">DOES NOT</emphasis> have a T4CLKCON register then timers 2/4/6/8 for that specific microcontroller chip use the first method, and are configured using:
<?asciidoc-br?></simpara>
<screen>    InitTimer4 (PreScale, PostScale)</screen>
<simpara>If the microcontroller <emphasis role="strong">DOES</emphasis> have a T2CLKCON register then ALL timers 2/4/6/8 for that specific microcontroller chip use the second method, and are configured using:</simpara>
<screen>    InitTimer4 (Source,PreScale,PostScale)</screen>
<simpara>The possible Source, Prescale and Postscale constants for each type are shown in the tables below.&#160;&#160;These table are summary tables from the Microchip datasheets.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Period of the Timers</emphasis></simpara>
<simpara>The Period of the timer is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&#160;&#160;The timer period for timer 4 is held in register PR4.&#160;&#160;
<?asciidoc-br?></simpara>
<simpara>When the timer is enabled, by starting the timer, it will increment until the TMR4 register matches the value in the PR4 register.&#160;&#160;At this time the TMR4 register is cleared to 0 and the timer continues to increment until the next match, and so on.
<?asciidoc-br?></simpara>
<simpara>The lower the value of the PR4 register, the shorter the timer period will be.&#160;&#160;The default value for the PR4 register at power up is 255.
<?asciidoc-br?></simpara>
<simpara>The timer interrupt flag (TMR4IF) is set based upon the number of match conditions as determine by the postscaler.&#160;&#160;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Timer constants for the MicroChip microcontrollers</emphasis></simpara>
<simpara>Parameters for this timer are detailed in the tables below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>clocksource</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>If required by method select.
&#160;<?asciidoc-br?>
Source can be one of the following numeric values:<?asciidoc-br?>
&#160;<?asciidoc-br?>
         1 equates to OSC (FOSC/4). &#160;&#160;&#160;The default clock source<?asciidoc-br?>
        <?asciidoc-br?>
         6 equates to EXTOSC same as SOSC<?asciidoc-br?>
         5 equates to MFINTOSC<?asciidoc-br?>
         4 equates to LFINTOSC<?asciidoc-br?>
         3 equates to HFINTOSC<?asciidoc-br?>
         2 equates to FOSC<?asciidoc-br?>
         1 equates to FOSC/4 same as OSC<?asciidoc-br?>
         0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<?asciidoc-br?>
</simpara><simpara>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 1 shown above</emphasis></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> can be one of the following settings, if you MicroChip microcontroller has the T4CKPS4 bit then refer to table 2:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 2</emphasis></simpara>
<simpara>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 3</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal><emphasis>postscaler</emphasis></literal> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</simpara>
<simpara>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Use Numeric Constant</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:3 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:5 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:6 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:7 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:9 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:10 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:11 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:12 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:13 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:14 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:15 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Explanation:(Atmel AVR)</emphasis></simpara>
<simpara><literal>InitTimer4</literal> will set up timer 4, according to the settings given.</simpara>
<simpara><literal>source</literal> can be one of the following settings:
Parameters for this timer are detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal> or <literal>Ext</literal> where`Osc` is an internal oscillator and <literal>Ext</literal> is an external oscillator.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> for Atmel AVR Timer 4 can be selected from the table below.</simpara>
<simpara>Prescaler Rate Select bits are in the range of 1 to 1024</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:0</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_4_0</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_4_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_4_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_4_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_4_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This code uses Timer 4 and On Interrupt to generate a 1ms pulse 20 ms.</simpara>
<screen>    #chip 18F25K80, 8

    #DEFINE PIN3 PORTA.1
    DIR PIN3 OUT

    #Define Match_Val PR4  'PR4 is the timer 2 match register
    Match_Val = 154        'Interrupt afer 154 Timer ticks (~20ms)

    On interrupt timer4Match call PulsePin3  'Interrupt on match
    Inittimer4 PS4_16, 15 'Prescale 1:64 /Postscale 1:16 (15)
    Starttimer 4

    Do
       'Waiting for interrupt on match val of 154
    Loop

    Sub PulsePin3
       pulseout Pin3, 1 ms
    End Sub</screen>
</section>
<section xml:id="_inittimer5">
<title>InitTimer5</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>InitTimer5 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 5 module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>InitTimer5</literal> will set up timer 5.</simpara>
<simpara>Parameters are required as detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal>, <literal>Ext</literal> or <literal>ExtOsc</literal> where:<?asciidoc-br?>
<literal>Osc</literal> is an internal oscillator.<?asciidoc-br?>
<literal>Ext</literal> is an external oscillator.<?asciidoc-br?>
</simpara><simpara><?asciidoc-br?>
<?asciidoc-br?>
<literal>Osc</literal> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&#160;&#160;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</simpara><simpara><literal>Ext</literal> - Selects the clock source attached to a specific exernal interrupt input port.&#160;&#160;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.
<?asciidoc-br?>
<?asciidoc-br?>
</simpara><simpara><literal>ExtOsc</literal> is an external oscillator and only available on a Microchip PIC microcontroller.
</simpara><simpara>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources.  This includes, but limited to,  the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller  series  On these devices the clock source can be one of the following:
</simpara><simpara><literal>Osc</literal> is an internal oscillator which is the same source as <literal>FOSC4</literal>.<?asciidoc-br?>
<literal>Ext</literal>  is an external oscillator which is the same source as <literal>TxXKIPPS</literal>.<?asciidoc-br?>
<literal>ExtOsc</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>FOSC</literal> is an internal oscillator which is the Frequency of the OSCillator.<?asciidoc-br?>
<literal>FOSC4</literal> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<?asciidoc-br?>
<literal>SOSC</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>MFINTOSC</literal> is an internal 500KHz internal clock oscillator.<?asciidoc-br?>
<literal>LFINTOSC</literal>  is an internal 31Khz internal clock oscillator.<?asciidoc-br?>
<literal>HFINTOSC</literal> is an oscillator as specified within the datasheet for each specific microcontroller.<?asciidoc-br?>
<literal>TxCKIPPS</literal> is an oscillator input on TxCKIPPS Pin.<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When the timer overflows an interrupt event will be generated.
This interrupt event can be used in conjunction with <literal>On Interrupt</literal> to run a section of code when the interrupt event occurs.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Microchip PIC microcontrollers:</emphasis></simpara>
<simpara>On Microchip PIC microcontrollers <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS5_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS5_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS5_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS5_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>48</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:2 and 1:8 of the oscillator (FOSC/4)
speed. The prescaler will apply to either the oscillator or the external
clock input.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Atmel AVR microcontrollers:</emphasis></simpara>
<simpara>On the majority of Atmel AVR microcontrollers  <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<simpara>The prescaler will only apply when the timer is driven from the <literal>Osc</literal> the internal oscillator - the prescaler has no effect when the external clock source is specified.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:0</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_5_0</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_5_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_5_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_5_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_5_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_5_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_inittimer6">
<title>InitTimer6</title>
<simpara><emphasis role="strong">Syntax: (MicroChip PIC)</emphasis></simpara>
<screen>    InitTimer6 <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis>

or, where you required to state the clock source, use the following

    InitTimer6 <emphasis>clocksource</emphasis>, <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis></screen>
<simpara><emphasis role="strong">Syntax: (Atmel AVR)</emphasis></simpara>
<screen>    InitTimer6 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 6 module.&#160;&#160;As shown above a Microchip microcontroller can potentially support two types of methods for initialisation.
<?asciidoc-br?>
<?asciidoc-br?>
The first method is:
<?asciidoc-br?></simpara>
<screen>    InitTimer6 prescaler, postscaler</screen>
<simpara>This the most common method to initialise a Microchip microcontroller timer.&#160;&#160;With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
The second method is much more flexible in term of the clock source.&#160;&#160;Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values.&#160;&#160;The method is shown below:
<?asciidoc-br?></simpara>
<screen>    InitTimer6 clocksource, prescaler, postscaler</screen>
<simpara><emphasis role="strong">How do you determine which method to use for your specific Microchip microcontroller ?</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The timer type for a Microchip microcontroller can be determined by checking for the existance of a T2CLKCON register, either in the Datasheet or in the GCBASIC  "dat file" for the specific device.
<?asciidoc-br?>
<?asciidoc-br?>
If the Microchip microcontroller <emphasis role="strong">DOES NOT</emphasis> have a T2CLKCON register then timers 2/4/6/8 for that specific microcontroller chip use the first method, and are configured using:
<?asciidoc-br?></simpara>
<screen>    InitTimer6 (PreScale, PostScale)</screen>
<simpara>If the microcontroller <emphasis role="strong">DOES</emphasis> have a T2CLKCON register then ALL timers 2/4/6/8 for that specific microcontroller chip use the second method, and are configured using:</simpara>
<screen>    InitTimer6 (Source,PreScale,PostScale)</screen>
<simpara>The possible Source, Prescale and Postscale constants for each type are shown in the tables below.&#160;&#160;These table are summary tables from the Microchip datasheets.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Period of the Timers</emphasis></simpara>
<simpara>The Period of the timer is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&#160;&#160;The timer period for timer 6 is held in register PR6.&#160;&#160;
<?asciidoc-br?></simpara>
<simpara>When the timer is enabled, by starting the timer, it will increment until the TMR6 register matches the value in the PR6 register.&#160;&#160;At this time the TMR6 register is cleared to 0 and the timer continues to increment until the next match, and so on.
<?asciidoc-br?></simpara>
<simpara>The lower the value of the PR6 register, the shorter the timer period will be.&#160;&#160;The default value for the PR6 register at power up is 255.
<?asciidoc-br?></simpara>
<simpara>The timer interrupt flag (TMR6IF) is set based upon the number of match conditions as determine by the postscaler.&#160;&#160;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Timer constants for the MicroChip microcontrollers</emphasis></simpara>
<simpara>Parameters for this timer are detailed in the tables below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>clocksource</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is an optional parameter.  Please review the datasheet for specific usage.<?asciidoc-br?>
&#160;<?asciidoc-br?>
Source can be one of the following numeric values:<?asciidoc-br?>
&#160;<?asciidoc-br?>
         1 equates to OSC (FOSC/4). &#160;&#160;&#160;The default clock source<?asciidoc-br?>
        <?asciidoc-br?>
         6 equates to EXTOSC same as SOSC<?asciidoc-br?>
         5 equates to MFINTOSC<?asciidoc-br?>
         4 equates to LFINTOSC<?asciidoc-br?>
         3 equates to HFINTOSC<?asciidoc-br?>
         2 equates to FOSC<?asciidoc-br?>
         1 equates to FOSC/4 same as OSC<?asciidoc-br?>
         0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<?asciidoc-br?>
</simpara><simpara>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 1 shown above</emphasis></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> can be one of the following settings, if you MicroChip microcontroller has the T6CKPS4 bit then refer to table 3:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 2</emphasis></simpara>
<simpara>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 3</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal><emphasis>postscaler</emphasis></literal> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</simpara>
<simpara>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Use Numeric Constant</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:3 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:5 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:6 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:7 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:9 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:10 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:11 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:12 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:13 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:14 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:15 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_inittimer7">
<title>InitTimer7</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>InitTimer7 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on  Microchip microcontrollers with a Timer 7 module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>InitTimer7</literal> will set up timer 7.</simpara>
<simpara>Parameters are required as detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal>, <literal>Ext</literal> or <literal>ExtOsc</literal> where:<?asciidoc-br?>
<literal>Osc</literal> is an internal oscillator.<?asciidoc-br?>
<literal>Ext</literal> is an external oscillator.<?asciidoc-br?>
</simpara><simpara><?asciidoc-br?>
<?asciidoc-br?>
<literal>Osc</literal> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&#160;&#160;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</simpara><simpara><literal>Ext</literal> - Selects the clock source attached to a specific exernal interrupt input port.&#160;&#160;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.
<?asciidoc-br?>
<?asciidoc-br?>
</simpara><simpara><literal>ExtOsc</literal> is an external oscillator and only available on a Microchip PIC microcontroller.
</simpara><simpara>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources.  This includes, but limited to,  the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller  series.  On these devices the clock source can be one of the following:
</simpara><simpara><literal>Osc</literal> is an internal oscillator which is the same source as <literal>FOSC4</literal>.<?asciidoc-br?>
<literal>Ext</literal>  is an external oscillator which is the same source as <literal>TxXKIPPS</literal>.<?asciidoc-br?>
<literal>ExtOsc</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>FOSC</literal> is an internal oscillator which is the Frequency of the OSCillator.<?asciidoc-br?>
<literal>FOSC4</literal> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<?asciidoc-br?>
<literal>SOSC</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>MFINTOSC</literal> is an internal 500KHz internal clock oscillator.<?asciidoc-br?>
<literal>LFINTOSC</literal>  is an internal 31Khz internal clock oscillator.<?asciidoc-br?>
<literal>HFINTOSC</literal> is an oscillator as specified within the datasheet for each specific microcontroller.<?asciidoc-br?>
<literal>TxCKIPPS</literal> is an oscillator input on TxCKIPPS Pin.<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When the timer overflows an interrupt event will be generated.
This interrupt event can be used in conjunction with <literal>On Interrupt</literal> to run a section of code when the interrupt event occurs.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Microchip PIC microcontrollers:</emphasis></simpara>
<simpara>On Microchip PIC microcontrollers <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS7_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS7_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS7_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS7_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>48</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:2 and 1:8 of the oscillator (FOSC/4)
speed. The prescaler will apply to either the oscillator or the external
clock input.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_inittimer8">
<title>InitTimer8</title>
<simpara><emphasis role="strong">Syntax: (MicroChip PIC)</emphasis></simpara>
<screen>    InitTimer8 <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis>

or, where you required to state the clock source, use the following

    InitTimer8 <emphasis>clocksource</emphasis>, <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis></screen>
<simpara><emphasis role="strong">Syntax: (Atmel AVR)</emphasis></simpara>
<screen>    InitTimer8 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 8 module.&#160;&#160;As shown above a Microchip microcontroller can potentially support two types of methods for initialisation.
<?asciidoc-br?>
<?asciidoc-br?>
The first method is:
<?asciidoc-br?></simpara>
<screen>    InitTimer8 prescaler, postscaler</screen>
<simpara>This the most common method to initialise a Microchip microcontroller timer.&#160;&#160;With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
The second method is much more flexible in term of the clock source.&#160;&#160;Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values.&#160;&#160;The method is shown below:
<?asciidoc-br?></simpara>
<screen>    InitTimer8 clocksource, prescaler, postscaler</screen>
<simpara><emphasis role="strong">How do you determine which method to use for your specific Microchip microcontroller ?</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The timer type for a Microchip microcontroller can be determined by checking for the existance of a T2CLKCON register, either in the Datasheet or in the GCBASIC  "dat file" for the specific device.
<?asciidoc-br?>
<?asciidoc-br?>
If the Microchip microcontroller <emphasis role="strong">DOES NOT</emphasis> have a T2CLKCON register then timers 2/4/6/8 for that specific microcontroller chip use the first method, and are configured using:
<?asciidoc-br?></simpara>
<screen>    InitTimer8 (PreScale, PostScale)</screen>
<simpara>If the microcontroller <emphasis role="strong">DOES</emphasis> have a T2CLKCON register then ALL timers 2/4/6/8 for that specific microcontroller chip use the second method, and are configured using:</simpara>
<screen>    InitTimer8 (Source,PreScale,PostScale)</screen>
<simpara>The possible Source, Prescale and Postscale constants for each type are shown in the tables below.&#160;&#160;These table are summary tables from the Microchip datasheets.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Period of the Timers</emphasis></simpara>
<simpara>The Period of the timer is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&#160;&#160;The timer period for timer 8 is held in register PR8.&#160;&#160;
<?asciidoc-br?></simpara>
<simpara>When the timer is enabled, by starting the timer, it will increment until the TMR8 register matches the value in the PR8 register.&#160;&#160;At this time the TMR8 register is cleared to 0 and the timer continues to increment until the next match, and so on.
<?asciidoc-br?></simpara>
<simpara>The lower the value of the PR8 register, the shorter the timer period will be.&#160;&#160;The default value for the PR8 register at power up is 255.
<?asciidoc-br?></simpara>
<simpara>The timer interrupt flag (TMR8IF) is set based upon the number of match conditions as determine by the postscaler.&#160;&#160;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Timer constants for the MicroChip microcontrollers</emphasis></simpara>
<simpara>Parameters for this timer are detailed in the tables below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>clocksource</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is an optional parameter.  Please review the datasheet for specific usage.<?asciidoc-br?>
&#160;<?asciidoc-br?>
Source can be one of the following numeric values:<?asciidoc-br?>
&#160;<?asciidoc-br?>
         1 equates to OSC (FOSC/4). &#160;&#160;&#160;The default clock source<?asciidoc-br?>
        <?asciidoc-br?>
         6 equates to EXTOSC same as SOSC<?asciidoc-br?>
         5 equates to MFINTOSC<?asciidoc-br?>
         4 equates to LFINTOSC<?asciidoc-br?>
         3 equates to HFINTOSC<?asciidoc-br?>
         2 equates to FOSC<?asciidoc-br?>
         1 equates to FOSC/4 same as OSC<?asciidoc-br?>
         0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<?asciidoc-br?>
</simpara><simpara>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 1 shown above</emphasis></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> can be one of the following settings:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS8_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS8_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS8_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS8_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal><emphasis>postscaler</emphasis></literal> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</simpara>
<simpara>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Use Numeric Constant</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:3 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:5 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:6 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:7 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:9 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:10 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:11 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:12 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:13 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:14 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:15 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_inittimer10">
<title>InitTimer10</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>InitTimer10 <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip microcontrollers with a Timer 10 module.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Parameters for this timer are detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> can be one of the following settings:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS10_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS10_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS10_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS10_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal><emphasis>postscaler</emphasis></literal> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</simpara>
<simpara>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Use Numeric Constant</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:3 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:5 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:6 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:7 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:9 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:10 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:11 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:12 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:13 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:14 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:15 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_inittimer12">
<title>InitTimer12</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>InitTimer12 <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip microcontrollers with a Timer 12 module.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Parameters for this timer are detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> can be one of the following settings:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS12_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS12_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS12_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS12_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal><emphasis>postscaler</emphasis></literal> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</simpara>
<simpara>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Use Numeric Constant</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:3 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:5 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:6 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:7 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:9 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:10 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:11 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:12 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:13 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:14 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:15 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_settimer">
<title>Settimer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Settimer <emphasis>timernumber</emphasis>, <emphasis>byte_value</emphasis>

    Settimer <emphasis>timernumber</emphasis>, <emphasis>word_value</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>Settimer</literal> will set the value of the specified timer with either byte value or a word value.
8-bit timers use a byte value. 16-bit timers use a word value.</simpara>
<simpara><literal>Settimer</literal> can be used on-the-fly, so there is no requirement to stop the timer first.</simpara>
<simpara>Refer to the datasheet for timer specific information.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example shows the operation of setting two timers - is not intended as a meaningful solution.</simpara>
<screen>    #chip 16f877a, 4
    On Interrupt Timer1Overflow call Overflowed
    Set PORTB.0 On

    InitTimer1 Osc, PS1_8
    SetTimer 1, 1
    StartTimer 1

    InitTimer2 PS2_16, PS2_16
    SetTimer 2, 255
    StartTimer 2

    'Manually set Timer2Overflow to create a second event
    'this will event will be handled by the Interrupt sub routine
    TMR2IE = 1
    end

    Sub Interrupt
      Set PORTB.2 On
      TMR2IF = 0
    End Sub

    Sub Overflowed
      Set PORTB.1 On
      TMR1IF = 0
    End Sub</screen>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_starttimer">
<title>StartTimer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    StartTimer <emphasis>TimerNo</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>StartTimer</literal> is used to start the specified timer.</simpara>
<simpara><emphasis role="strong">Timer 0:</emphasis></simpara>
<simpara>Please refer to the datasheet to determine if Timer 0 on specific Microchip PIC microcontroller
can be started and stopped with <literal>starttimer</literal> and <literal>stoptimer</literal>. If the Microchip PIC microcontroller
has a register named "T0CON"  then it supports <literal>stoptimer</literal> and <literal>starttimer</literal>.</simpara>
<simpara>On Microchip PIC 18(L)Fxxx microcontrollers Timer 0 can be started  with <literal>starttimer</literal>.<?asciidoc-br?>
On Microchip PIC baseline and midrange microcontrollers <literal>starttimer</literal> (and <literal>stoptimer</literal>) has no effect upon Timer 0.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example will measure that time that a switch is depressed (or on) and will write the results to the EEPROM.</simpara>
<screen>    #chip 16F819, 20
    #define Switch PORTA.0

    Dir Switch In
    DataCount = 0

    'Initilise Timer 1
    InitTimer1 Osc, PS1_8

    Dim TimerValue As Word

    Do
        ClearTimer 1
        Wait Until Switch = On
        StartTimer 1
        Wait Until Switch = Off
        StopTimer 1

        'Read the timer
        TimerValue = Timer1

        'Log the timer value
        EPWrite(DataCount, TimerValue_H)
        EPWrite(DataCount + 1, TimerValue)
        DataCount += 2
    Loop</screen>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_stoptimer">
<title>StopTimer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    StopTimer <emphasis>TimerNo</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer modules.
<emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>On the Microchip PIC 18(L)Fxxx microcontrollers Timer 0 can be stopped  with <literal>stopttimer</literal>.<?asciidoc-br?>
With respect to Timer 0 on the Microchip PIC baseline and midrage range of microcontrollers <literal>stoptimer</literal> (and <literal>starttimer</literal>) has no effect as Timer 0.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example will measure that time that a switch is depressed (or on) and will write the results to the EEPROM. <?asciidoc-br?>
The example shows how to stop a timer when not in use.</simpara>
<screen>    #chip 16F819, 20
    #define Switch PORTA.0

    Dir Switch In
    DataCount = 0

    'Initilise Timer 1
    InitTimer1 Osc, PS1_8

    Dim TimerValue As Word

    Do
        ClearTimer 1
        Wait Until Switch = On
        StartTimer 1
        Wait Until Switch = Off
        StopTimer 1

        'Read the timer
        TimerValue = Timer1

        'Log the timer value
        EPWrite(DataCount, TimerValue_H)
        EPWrite(DataCount + 1, TimerValue)
        DataCount += 2
    Loop</screen>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_reading_timers">
<title>Reading Timers</title>
<simpara>GCBASIC has the following functions to read the current timer value. They
are:</simpara>
<screen>    Timer0()
    Timer1()
    Timer2()
    Timer3()
    Timer4()
    Timer5()
    Timer6()
    Timer7()
    Timer8()
    Timer10()
    Timer12()</screen>
<simpara>Note that these functions should only be used to read the timer value.  To write the timer value, <literal>settimer</literal> should be used.</simpara>
<simpara>Not all of these functions are available on all microcontrollers. For example, if a microcontrollers has three timers, then typically only <literal>Timer0</literal>, <literal>Timer1</literal> and <literal>Timer2</literal> will be available.</simpara>
<simpara>Please refer to the datasheet for your microcontroller to determine the supported timer numbers, and if a specific timer is 8-bit or 16-bit.</simpara>
</section>
<section xml:id="_smt_timers">
<title>SMT Timers</title>
<simpara>The Signal Measurement Timer (SMT) capability is a 24-bit counter with advanced clocking and gating logic, which can be configured for measuring a variety of digital signal parameters such as pulse width, frequency and duty cycle, and the time difference between edges on two signals.&#160;&#160;</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SETSMT1PERIOD ( 4045000 )        ' 1.000s period
                                     ' a perfect internal clock would be 4000000

    SETSMT2PERIOD ( 9322401 )        ' 4.600s period

    InitSMT1(SMT_FOSC,SMTPres_1)
    InitSMT2(SMT_FOSC4,SMTPres_8)

    On Interrupt SMT1Overflow Call yourSMT1InterruptHandler
    On interrupt SMT2Overflow Call yourSMT1InterruptHandler

    StartSMT1
    StartSMT2</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip microcontrollers with the SMT timer module.</simpara>
<simpara>This command set supports the use of the SMT as a 24-bit timer only.</simpara>
<simpara>Microchip PIC Microcontrollers have either 1 or 2 Signal Measurement Timers (SMT).&#160;&#160; A 24-bit timer allows for very long timer periods/high resolution and can be quite useful for certain applications.
&#160;&#160;SMT timers support multiple clock sources and prescales.&#160;&#160; Interrupt on overflow/match is also supported.</simpara>
<simpara>SMT timers will "overflow" when the 24-bit timer value "matches"  the 24-bit period registers.</simpara>
<simpara>The timer period can be precisely adjusted/set by writing a period value to the respective period register for eact timer.</simpara>
<simpara>The maximum period is achieved by a period register value of 16,777,215.&#160;&#160;  16,777,215 is the default value at POR. &#160;&#160;The timer period is also affected by the ChipMhz, TimerSource and Timer Prescale.</simpara>
<simpara>The library supports "normal" timer operation of SMT1/SMT2.&#160;&#160; The library does not support the advanced signal measurement features.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Commands are detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Example
&#160;</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>InitSMT1( Source,Presscaler )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Source can be one of the below:<?asciidoc-br?>
<literal>SMT_AT1_perclk</literal> &#160;&#160;equates to     6<?asciidoc-br?>
<literal>SMT_MFINTOSC</literal> &#160;&#160;&#160;&#160;&#160;&#160;equates to        5         (500KHz)<?asciidoc-br?>
<literal>SMT_MFINTOSC_16</literal> equates to     4         (500Khz / 16)<?asciidoc-br?>
<literal>SMT_LFINTOSC</literal> &#160;&#160;&#160;&#160;&#160;&#160;equates to        3         (32Khz)<?asciidoc-br?>
<literal>SMT_HFINTOSC</literal>  &#160;&#160;&#160;&#160;&#160;equates to       2<?asciidoc-br?>
<literal>SMT_FOSC4</literal> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;equates to           1         (FOSC/4)<?asciidoc-br?>
<literal>SMT_FOSC</literal> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;equates to            0<?asciidoc-br?>
<?asciidoc-br?>
Prescaler can be one of the following:<?asciidoc-br?>
<literal>SMTPres_1</literal> equates to      1:1<?asciidoc-br?>
<literal>SMTPres_2</literal> equates to      1:2<?asciidoc-br?>
<literal>SMTPres_4</literal> equates to      1:4<?asciidoc-br?>
<literal>SMTPres_8</literal> equates to      1:8<?asciidoc-br?>
<?asciidoc-br?></simpara></entry>
<entry align="left" valign="top"><simpara><literal>InitSMT1(SMT_FOSC,SMTPres_1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InitSMT2( Source,Presscaler )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Source can be one of the below:<?asciidoc-br?>
<literal>SMT_AT1_perclk</literal> &#160;&#160;equates to     6<?asciidoc-br?>
<literal>SMT_MFINTOSC</literal> &#160;&#160;&#160;&#160;&#160;&#160;equates to        5         (500KHz)<?asciidoc-br?>
<literal>SMT_MFINTOSC_16</literal> equates to     4         (500Khz / 16)<?asciidoc-br?>
<literal>SMT_LFINTOSC</literal> &#160;&#160;&#160;&#160;&#160;&#160;equates to        3         (32Khz)<?asciidoc-br?>
<literal>SMT_HFINTOSC</literal>  &#160;&#160;&#160;&#160;&#160;equates to       2<?asciidoc-br?>
<literal>SMT_FOSC4</literal> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;equates to           1         (FOSC/4)<?asciidoc-br?>
<literal>SMT_FOSC</literal> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;equates to            0<?asciidoc-br?>
<?asciidoc-br?>
Prescaler can be one of the following:<?asciidoc-br?>
<literal>SMTPres_1</literal> equates to      1:1<?asciidoc-br?>
<literal>SMTPres_2</literal> equates to      1:2<?asciidoc-br?>
<literal>SMTPres_4</literal> equates to      1:4<?asciidoc-br?>
<literal>SMTPres_8</literal> equates to      1:8<?asciidoc-br?>
</simpara><simpara><?asciidoc-br?></simpara></entry>
<entry align="left" valign="top"><simpara><literal>InitSMT2(SMT_FOSC4,SMTPres_8)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ClearSMT1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clears the timer.  No parameter required.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ClearSMT1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ClearSMT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clears the timer.  No parameter required.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ClearSMT2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetSMT1( TimerValue )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the timer to the specific value.  The value can be 1 to 16777215</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SETSMT1(4045000)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetSMT2( TimerValue )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the timer to the specific value.  The value can be 1 to 16777215</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SETSMT2(4045000)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StopSMT1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Stops the timer.  No parameter required.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>StopSMT2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StopSMT2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Stops the timer.  No parameter required.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StartSMT1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Starts the timer.  No parameter required.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>StartSMT1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StartSMT2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Starts the timer.  No parameter required.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>StartSMT2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetSMT1Period ( PeriodValue )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the timer period to the specific value.  The value can be 1 to 16777215</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SETSMT1PERIOD(4045000)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetSMT2Period ( PeriodValue )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the timer period to the specific value.  The value can be 1 to 16777215</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SETSMT1PERIOD(9322401)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1 (Microchip Only):</emphasis></simpara>
<simpara>This example will ..</simpara>
<screen>    #Chip 16F18855, 32

    #option explicit
    #Include &lt;SMT_Timers.h&gt;
    #config CLKOUTEN_ON


      '' -------------------LATA-----------------
      '' Bit#:  -7---6---5---4---3---2---1---0---
      '' LED:   ---------------|D5 |D4 |D3 |D1 |-
      ''-----------------------------------------
      ''
      #define LEDD2 PORTA.0
      #define LEDD3 PORTA.1
      #define LEDD4 PORTA.2
      #define LEDD5 PORTA.3
      #define Potentiometer   PORTA.4

      Dir     LEDD2 OUT
      Dir     LEDD3 OUT
      Dir     LEDD4 OUT
      Dir     LEDD5 OUT
      DIR     Potentiometer In


     SETSMT1PERIOD ( 4045000 )        ' 1.000s periodwith the parameters of SMT_FOSC and SMTPres_1 within the clock variance of the interclock
                                      ' a perfect internal clock would be 4000000

     SETSMT1PERIOD ( 9322401 )        ' 4.600s period with the parameters of SMT_FOSC4 and SMTPres_8

     InitSMT1(SMT_FOSC,SMTPres_1)
     InitSMT2(SMT_FOSC4,SMTPres_8)


     On Interrupt SMT1Overflow Call BlinkLEDD2
     On interrupt SMT2Overflow Call BlinkLEDD3

     StartSMT1
     StartSMT2


     Do
       '// Waiting for interrupts

     LOOP


    Sub BlinkLEDD2
      LEDD2 = !LEDD2
    End SUB



    Sub BlinkLEDD3
      LEDD3 = !LEDD3
    End SUB</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Supported in &lt;SMT_Timers.h&gt;</emphasis></simpara>
</section>
</section>
<section xml:id="_variables_operations">
<title>Variables Operations</title>
<simpara>This is the Variables Operations section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_using_variables">
<title>Using Variables</title>
<simpara><emphasis role="strong">Explaination</emphasis></simpara>
<simpara>Using and accessing bytes within word and long numbers etc may be required when you are creating your solution. This can be done with some ease.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<simpara>You can access the bytes within word and longs variables using the following as a guide using the Suffixes <literal>_H</literal>, <literal>_U</literal> and <literal>_E</literal>
<?asciidoc-br?></simpara>
<screen>    Dim workvariable as word
    workvariable = 21845
    Dim lowb as byte
    Dim highb as byte
    Dim upperb as byte
    Dim lastb as byte

    lowb = workvariable
    highb = workvariable_H
    upperb = workvariable_U
    lastb = workvariable_E</screen>
<simpara><?asciidoc-br?>
To further explain, where
<?asciidoc-br?></simpara>
<screen>    Dim rB as Byte
    Dim sW as Word</screen>
<simpara><?asciidoc-br?>
To extract the bytes from a WORD of 16 bits use the Suffix <literal>_H</literal>
<?asciidoc-br?></simpara>
<screen>    'To use the bits 7-0 [lower byte] in the Word variable sW
    rB = sW

    'For bits 15-8 [upper byte] in the Word variable sW, use sw_H
    rB = sW_H</screen>
<simpara><?asciidoc-br?>
To extract the bytes from a LONG of 32 bits use the Suffixes <literal>_H</literal>, <literal>_U</literal> and
<literal>_E</literal>, where
<?asciidoc-br?></simpara>
<screen>    Dim rB as Byte
    Dim tL as Long

    ‘ For bits 7-0 [lowest byte #0] in Long variable tL
    rB = tL

    ‘ For bits 15-8 [lower middle byte #1] in Long variable tL
    rB = tL_H

    ‘ For bits 23-16 [upper middle byte #2] in Long variable tL
    rB = tL_U

    ‘ For bits 31-24 [highest byte #3] in Long variable tL
    rB = tL_E</screen>
<simpara><?asciidoc-br?>
To extract nibbles from the variable <literal>rB</literal>
<?asciidoc-br?></simpara>
<screen>    lower_nibble = rB &amp; 0x0F
    upper_nibble = (rB &amp; 0xF0) / 16</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2:</emphasis></simpara>
<simpara>Assigning values to Word and Long variables via the the Byte variable (the Least Significant Byte [.lsb]) of the same Word and Long variable.</simpara>
<simpara>Because a Long (or Word) variable and the Least Significant Byte, of the variable, have the same variable assignments to specific byte elements (_e, _u and _h) assignment must be appropriate to the element.</simpara>
<simpara>The code below uses a Long variable but the same principle is used for a Word.</simpara>
<simpara>Assigning two values, a byte and a word constant value, to the variable tL to compare resulting impact on Long variable.</simpara>
<screen>    Dim tL as Long

    tL = 255  'All bits of the value 255 will reside in the lowest byte of the Long variable tL
    tL = 286   'This assignment will flow into tL_H where tL_H =1 and tl=30.</screen>
<simpara>Assigning values to specific elements of a Long variable.</simpara>
<screen>    'Assign value to specific elements
    tL_E = 0xF7
    tL_U = 0xC5
    tL_H = 0xE3

    'is same as the following assignment, we show the use of casting for clarification only.
    [Long] tL = 0xF7C5E300   The lower byte (tL) is empty (zero).

    'or, treat the Long as a byte and assign a byte.
    [byte]tL = [byte]0xA4</screen>
<simpara>Assigning values to the byte element of a long variable.</simpara>
<screen>    'This will assign the lowest byte with 0xA4 but this assignment will also clear the upper 3 byte elements of the long variable.
    tL = 0xA4

    'To assign the lowest byte
    tL = ( tL and 0xffffff00 ) + 0xA4  'Wwill preserve the upper bytes and ensure the lowest byte is assigned correctly.</screen>
<simpara>A method to check a variable is assigned as expected is to use HserPrint and HserPrint hex(), as follows:</simpara>
<screen>    ' HserPrint hex() only prints one byte so we need to handle the four elements
    HserPrint " Print tL _E, tL_U, tL_H &amp; tL as hex"
    HserPrint hex (tL_E)
    HserPrint hex (tL_U)
    HserPrint hex (tL_H)
    HserPrint hex (tL)
    HserPrintCRLF
    HserPrint "Variable tL = "
    HserPrint tL</screen>
<simpara>The user code above will result in an output as follows:</simpara>
<screen>    Print tL _E, tL_U, tL_H &amp; tL as hexF7C5E3A4
    Variable tL = 4156941220</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_more_on_setting_variables_and_constants">
<title>More on setting Variables and Constants</title>
<simpara><emphasis role="strong">Explanation</emphasis></simpara>
<simpara>Within GCBASIC you can use regular variable assignments. But, you can also use C like maths assignments.</simpara>
<simpara>The following methods are also supported.</simpara>
<screen>    GLCDPrintLoc += 6
    CharCode -= 15
    CharCode++
    CharCode---</screen>
<simpara>Within GCBASIC you can define binary, hexidecimal and decimal constants, see <link linkend="_constants">Constants</link>. Please note what is and what is not support with respect to assigning numbers to constants. An example program examines what is supported.</simpara>
<screen>    #chip 16F88, 4
    #config Osc = MCLRE_OFF

    ' All these work
    #define Test1 0b11111111
    #define Test2 0B11111111
    #define Test3 255
    #define Test4 0xFF
    #define Test5 0xff
    #define Test6 0Xff

    # Proof - select each option one in turn
    dir porta Out

    porta = test1
    porta = test2
    porta = test3
    porta = test4
    porta = test5
    porta = test6</screen>
<simpara>You can assigned values/numbers with all the methods shown above (for constants and variables) but please be aware that you must Use '0' not '00'. One zero equates to zero and two zeros will give you an unassigned variable.</simpara>
<simpara><emphasis role="strong">Constants:</emphasis></simpara>
<simpara>A few critical constants are defined within GCBASIC , you can re-use these constants. They include:</simpara>
<screen>    #define ON 1       ' These are defined in System.h
    #define OFF 0
    #define TRUE 255
    #define FALSE 0

    #define OSC = 1    ' These are defined in TIMER.H
    #define EXT = 2    ' and, are used by InitTimer0 command
    #define EXTOSC = 3</screen>
</section>
<section xml:id="_setting_variables">
<title>Setting Variables</title>
<simpara><?asciidoc-br?>
<emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>Variable</emphasis> = <emphasis>data</emphasis></screen>
<simpara><?asciidoc-br?>
<emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<literal><emphasis>Variable</emphasis></literal> will be set to <literal><emphasis>data</emphasis></literal>.<?asciidoc-br?>
<literal><emphasis>data</emphasis></literal> can be either a fixed value (such as 157), another variable, or a sum.
<?asciidoc-br?>
All unknown byte variables are assigned Zero. A variable with the name of <emphasis role="strong">Forever</emphasis> is not defined by GCBASIC and therefore defaults to the value of zero.
<?asciidoc-br?>
If <literal><emphasis>data</emphasis></literal> is a fixed value, it must be an integer between 0 and 255 inclusive.
<?asciidoc-br?>
If <literal><emphasis>data</emphasis></literal> is a calculation, then it may have any of the following operands:</simpara>
<simpara><?asciidoc-br?></simpara>
<screen>    + (add)
    - (subtract, or negate if there is no value before it)
    * (multiply)
    / (divide)
    % (modulo)
    &amp; (and)
    | (or)
    # (xor)
    ! (not)
    = (equal)
    &lt;&gt; (not equal)
    &lt; (less than)
    &gt; (greater than)
    &lt;= (less than or equal)
    &gt;= (more than or equal)</screen>
<simpara><?asciidoc-br?>
The final six operands are for checking conditions.  They will return FALSE (0) if the condition is false, or TRUE (255) if the condition is true.
<?asciidoc-br?>
The <literal>And</literal>, <literal>Or</literal>, <literal>Xor</literal> and <literal>Not</literal> operators function both as bitwise and logical operators.
<?asciidoc-br?>
GCBASIC understands order of operations. If multiple operands are present, they will be processed in this order:
<?asciidoc-br?></simpara>
<screen>    Brackets
    Unary operations (not and negate)
    Multiply/Divide/Modulo
    Add/Subtract
    Conditional operators
    And/Or/Xor</screen>
<simpara><?asciidoc-br?>
There are several modes in which variables can be set. GCBASIC will automatically use a different mode for each calculation, depending on the type of variable being set. If a byte variable is being set, byte mode will be used; if a word variable is being set, word mode will be used. If a byte is being set but the calculation involves numbers larger than 255, word mode can be used by adding [WORD] to the start of one of the values in the calculation. This is known as casting - refer to the Variables article for more information.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">And with other operations</emphasis></simpara>
<simpara>The order of operations, comparison operations have a higher precedence than boolean operations.&#160;&#160;GCBASIC behaves the same way as most other languages.&#160;&#160;Source code like this (randomly taken from glcd_ili9326.h) works.</simpara>
<screen>if GLCDfntDefaultSize = 2 and CurrCharRow = 7 then</screen>
<simpara>It is an easy mistake to compare values and get the precendent incorrect.&#160;&#160;Generally, if you can use an individual bit check, that is generally the best way to go. These are a lot simpler for the compiler to deal with and result in much nicer assembly.</simpara>
<simpara>This works using the correct order of precendence.</simpara>
<screen>    if (H_Byte &amp; 0x10) = 0x10 Then ...

    'or, using the individual bit check to do the same
    if H_Byte.4 Then</screen>
<simpara>This will fail as the order of precendence as shown below.</simpara>
<screen>    if H_Byte &amp; 0x10 = 0x10 Then ...

    'the code above equates. This is not achieve the testing of the H_byte.4
    if H_Byte &amp; ( 0x10 = 0x10 ) Then ...</screen>
<simpara><emphasis role="strong">Divide or division</emphasis></simpara>
<simpara>GCBASIC support division.</simpara>
<simpara>When using division you will get accurate results, within the limitations of integer numbers, by completing any multiplication first and the division last. &#160;&#160;But, you may have issues with variables overflowing - ensure your variable type are correct for the calculation type.</simpara>
<simpara>If you that calculation a division, the compiler will use the long division routine, if the value may overflow, and then  fit the result into a word. &#160;&#160;This code provides the correct result, again within the limitations of integer numbers:</simpara>
<screen>    dim L1s as word
    dim L1p as word
    L1s = 6547200 / L1p</screen>
<simpara>Division also sets the global system variable SysCalcTempX to the remainder of the division.&#160;&#160;However the following simple rules apply.
<?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>If both of the parameters of the division are constants, the compiler will do the calculation itself and use the result rather than making the microcontroller work out the same thing every time.  So, if there are two constants used, the microcontroller division routine does not get used, and SysCalcTempX does not get set.</simpara>
</listitem>
<listitem>
<simpara>If either of the parameters of the division are variables, the compiler will ensure the microcontroller does the calculation as the result could be different every time.  So, in the this case the microcontroller division routine does get used, and SysCalcTempX is set.
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
<simpara>If you prefer, you can add <literal>Let</literal> to the start of the line. &#160;&#160;It will not alter the execution of the program, but is included for those who are used to including it in other BASIC dialects.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program is to illustrate the setting of variables.
    Chipmunk = 46        'Sets the variable Chipmunk to 46
    Animal = Chipmunk    'Sets the variable Animal to the value of the variable Chipmunk
    Bear = 2 + 3 * 5     'Sets the variable Bear to the result of 2 + 3 * 5, 17.
    Sheep = (2 + 3) * 5  'Sets the variable Sheep to the result of (2 + 3) * 5, 25.
    Animal = 2 * Bear    'Sets the variable Animal to twice the value of Bear.

    LargeVar = 321       'LargeVar must be set as a word - see DIM.
    Temp = LargeVar / [WORD]5 'Note the use of [WORD] to ensure that the calculation is performed correctly</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Setting Explicit Bits of a Variable/Register:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
GCBASIC supports the method setting a specific bit of a variable or register.  Use the following method:
<?asciidoc-br?></simpara>
<screen>    'variable.bit method
    myByteVariable.0 = 1   'will set bit 0 to 1
    myByteVariable.1 = 0   'will set bit 1 to 0
    myByteVariable.2 = 1   'will set bit 2 to 1</screen>
<simpara><?asciidoc-br?></simpara>
<simpara>To set more than one bit in one command GCBASIC supports the bits method.
<?asciidoc-br?></simpara>
<simpara>GCBASIC also supports setting specific bits of a variable or register.  Use the following method:
<?asciidoc-br?></simpara>
<screen>    'variable.bitS method
    SPLLEN, IRCF3, IRCF2, IRCF1, IRCF0 = b'01111'
    ' would generate ASM [for your specific microcontroller like the following.
    ' bcf OSCTUNE,PLLEN,ACCESS
    ' bsf OSCCON,IRCF2,ACCESS
    ' bsf OSCCON,IRCF1,ACCESS
    ' bsf OSCCON,IRCF0,ACCESS</screen>
<simpara><?asciidoc-br?>
This method is limited to literal values.  You cannot use value from another variable as the setting value (at v0.98.00).
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Setting Explicit Bits of a Variable/Register with Error Handling</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
To set more than one bit in one command GCBASIC supports the bits method.
<?asciidoc-br?></simpara>
<simpara>GCBASIC also supports setting specific bits of a variable or register with error handling.  Use this method to prevent errors when a specified bit does not exist.
<?asciidoc-br?></simpara>
<simpara>The <literal>[canskip]</literal> prefix will handle the error condition when a specific bit or specific bits do not exist.  The following example shows the usage.
<?asciidoc-br?></simpara>
<screen>    [canskip] SPLLEN, IRCF3, IRCF2, IRCF1, IRCF0 = b'01111'</screen>
<simpara><?asciidoc-br?>
This method is limited to literal values.  You cannot use value from another variable as the setting value (at v0.98.00).
<?asciidoc-br?>
<?asciidoc-br?>
This example shows how the error handler compares to not have the <literal>[canskip]</literal> prefix
<?asciidoc-br?></simpara>
<screen>      ' Of these two lines, only the first compiles:
      [canskip] SPLLEN, IRCF3, IRCF2, IRCF1, IRCF0 = b'01111'    'first line with error handler
      SPLLEN, IRCF3, IRCF2, IRCF1, IRCF0 = b'01111'              'second line with no error handler

      'Second line produces this message:
      'samevar.gcb (16): Error: Bit IRCF3 is not a valid bit and cannot be set</screen>
<simpara><?asciidoc-br?>
<emphasis role="strong">Setting a String - set a string with Escape characters</emphasis></simpara>
<simpara>An example showing how to set a string to an escape sequence for an ANSI terminal.&#160;&#160;You can `Dim`ension a string and then assign the elements similar to setting array elements.</simpara>
<screen>    dim line2 as string
    line2 =  27, "[", "2", "H", 27, "[","K"
    HSerPrint line2</screen>
<simpara>Will send the following to the terminal.
&lt;esc&gt;[2H&lt;esc&gt;[K</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see:</emphasis> <link linkend="_variables">Variables</link></simpara>
</section>
<section xml:id="_variable_lifecycle">
<title>Variable Lifecycle</title>
<simpara><emphasis role="strong">Explanation</emphasis></simpara>
<simpara>Within GCBASIC you can use variables. This section details the Variable Lifecycle when using variables.</simpara>
<simpara><emphasis role="strong">Variable rules - with #Option Explicit</emphasis></simpara>
<simpara>As shown below in the rule without #Option Explicit but ALL variables MUST be defined including bytes variables.</simpara>
<simpara><emphasis role="strong">Variable rules - without #Option Explicit</emphasis></simpara>
<simpara>Scope - every variable is global from an addressing/usage point of view.</simpara>
<simpara>Once a variable is defined, and then the variable it is used the variable persists.</simpara>
<simpara>Aliasing - You can reduce memory usage by Aliasing.  Remember all variables are global so you must be careful.</simpara>
<simpara>If there are two variables with the same name, they will be placed in the same memory location. You can reuse the same variable name in two subs/functions, and you can make the variables different types, but writing to the variable in one sub will overwrite the value from the other sub, see the example below.</simpara>
<simpara>As a general guide define any shared variables near the start of the program for easier readability.</simpara>
<simpara>All variables should be initialised with a desired initialisation value.  Do not assume the initialisation value is Zero.</simpara>
<simpara>Variables local to particular subroutines are not implemented.</simpara>
<simpara><emphasis role="strong">Specific rules to spefic variable types</emphasis></simpara>
<simpara>All variables are global.  Bit variables defined in subs/function are global.</simpara>
<simpara>Byte variables do not need to be defined using the DIM statement.  See #Option Explicit above.  Just to clarify byte is default type, this means:</simpara>
<screen>    Dim MainVar As Byte is unnecessary.
    MainVar = 128    automatic defines the MainVar variable</screen>
<simpara>Bit, Word, Longs, Integers and Strings variables must be defined.</simpara>
<simpara>All variables are global, but, if they are defined inside a particular subroutine then their type is not, see the example below:</simpara>
<simpara>Example code:</simpara>
<screen>    Dim MainVar As Byte
    Dim OtherVar As Word

    MainVar = 128
    OtherVar = 514

    DemoSub
    'At this point:
    'MainVar is a byte, value 128
    'OtherVar is a word, value 514
    'Counter is a byte, value 2
    '(Byte is default type, but location shared with that of Counter in DemoSub. High byte ignored)

    Sub DemoSub
        Dim Counter As Word
        Counter = 2050
        'At this point:
        'MainVar and OtherVar as byte and word, as in main routine
        'Counter is a word, value 2050
    End Sub</screen>
<simpara>In DemoSub, Counter is a word. But anywhere else in the program it is a byte unless otherwise specified.   If the variable is used/read in the main routine, it will be treated as a byte, and only the low 8 bits will be returned. In this example the low 8 bits of 2050 are 2.</simpara>
<simpara>The main reason for keeping the type inside the subroutine was for the following scenario:
A subroutine uses a temporary variable of type byte, and relies on it overflowing.</simpara>
<simpara>Another subroutine uses a temporary variable of the same name, but of word type.</simpara>
<simpara>If the first subroutine is already in the program, and then the second one is added, the behaviour of the first one will not change at all due to the addition of the second one.</simpara>
<simpara>The handling of variable types using this method minimises the size of the generated assembly code.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="__option_explicit">Option Explicit</link></simpara>
</section>
<section xml:id="_dim">
<title>Dim</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis role="strong"><emphasis>For Variables &gt; 1 byte:</emphasis></emphasis>
    Dim <emphasis>variable</emphasis>[, <emphasis>variable2</emphasis> [, <emphasis>variable3</emphasis>]] [As <emphasis>type</emphasis>] [Alias <emphasis>othervar</emphasis> [, <emphasis>othervar2</emphasis>]]

    'or

    Dim <emphasis>variable</emphasis>[, <emphasis>variable2</emphasis> [, <emphasis>variable3</emphasis>]] [As <emphasis>type</emphasis>] [At <emphasis>location</emphasis>]


    <emphasis role="strong"><emphasis>For Arrays:</emphasis></emphasis>
    Dim <emphasis>array</emphasis>(<emphasis>size</emphasis>) [As <emphasis>type</emphasis>] [At <emphasis>location</emphasis>]

    <emphasis role="strong"><emphasis>For String:</emphasis></emphasis>
    Dim <emphasis>string [* _size</emphasis>] [At <emphasis>location</emphasis>]</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Dim has two uses:&#160;&#160;It can be used to define 1) variables of many types and 2) arrays.</simpara>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara>The <literal>Dim</literal> variable command is used to instruct GCBASIC to allocate variables or to create alternate names for existing  variables (using Alias) or to create variables at a specific memory location (using At).</simpara>
<simpara>The <literal>Dim array</literal> command also sets up array variables. The maximum array size is determined by the parameter <literal><emphasis>size</emphasis></literal> is dynamically allocated by the compiler and depends on the specific chip used, as well as the complexity of the program.</simpara>
<simpara>The limit on array size varies dependent on the chip type.  See the <emphasis role="strong">Maximum Array Size</emphasis> section in <link linkend="_array">Arrays</link> for more information.</simpara>
<simpara><literal><emphasis>type</emphasis></literal> specifies the type of variable that is to be created. Different variable types can hold values over different ranges, and use different amounts of RAM. See the <link linkend="_variable_types">Variables Types</link> article for more information.</simpara>
<simpara>When multiple variables are included on the one line, GCBASIC will set them all to the type that is specified at the end of the line. If there is no type specified, then GCBASIC will make the variable a byte.</simpara>
<simpara><literal>Alias</literal> creates a variable using the same memory location as one or more other variables. &#160;&#160;It is mainly used internally in GCBASIC to treat system variables as a word.&#160;&#160; For example, this command is used to create a word variable, made up from the two memory locations used to store the result of an A/D conversion.&#160;&#160;`Alias` is mutually exclusive to <literal>At</literal> and therefore <literal>Alias</literal> and <literal>At</literal> on the same declaration line will cause an compiler error.</simpara>
<simpara><literal>AT</literal> a variable can be placed at a specific location in the data memory of the chip using the At option. &#160;&#160;`<emphasis>location</emphasis>` will be used whether it is a valid location or not, but a warning will be generated if GCBASIC has already allocated the memory, or if the memory does not appear to be valid. &#160;&#160;This can be used for peripherals that have multi byte buffers in RAM.&#160;&#160;`At` is mutually exclusive to <literal>Alias</literal> and therefore <literal>At</literal> and <literal>Alias</literal> on the same declaration line will cause an compiler error.</simpara>
<simpara>A String declared with a fixed size (numeric constant that can be evaluated at compile time) is a fixed length string. It has no descriptor and it is not resized to fit its contents. If data overflows the size of the string, the memory may be overwrtten.
Fixed length strings are not NULL terminated, and they use size + 1 bytes of space.
String variable names need not end in a dollar sign $ as in other dialects of BASIC.</simpara>
<screen>    Dim ADResult As Word Alias ADRESH, ADRESL</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will set up a array of ten bytes and a word variable

    dim DataList(10)
    dim Reading as word

    Reading = 21978
    DataList(1) = 15

    dim stringvariable as string</screen>
<simpara><emphasis role="strong">For more help, see:&#160;&#160;</emphasis><link linkend="_serprint">SerPrint</link> articles as these articales show how to use Dim to create string variables and <link linkend="_variables">Variables</link> for more details in creating and managing strings lengths.</simpara>
</section>
<section xml:id="_alloc">
<title>Alloc</title>
<simpara><emphasis role="strong">About Alloc</emphasis></simpara>
<simpara>Alloc creates a special type of variable - an array variant. &#160;&#160;This array variant can store values.&#160;&#160;  The values stored in this array variant must be of the same type.</simpara>
<simpara>Essentially, ALLOCate will reserve a memory range as described by the given layout that can be used as a RAM buffer or as an array variant.</simpara>
<simpara>Layout:</simpara>
<screen>  Dim variable_name as ALLOC * memory_size at memory_location</screen>
<simpara>The allocated block of memory will not be initialized.</simpara>
<simpara>Example Usage:</simpara>
<screen>  Dim my256bytebuffer as alloc * 256 at 0x2400</screen>
<simpara>There is a pointer to allocated memory.  Use @variable_name.</simpara>
<simpara>Example Pointer</simpara>
<screen>    HSerPrint @my256bytebuffer</screen>
<simpara><emphasis role="strong">Extents</emphasis></simpara>
<simpara>This method can be unsafe because undefined behaviour can result if the caller does not ensure that buffer extents are not maintained. &#160;&#160; Buffer extents are 0 (zero) to the memory_size - 1</simpara>
<simpara>Example Extents:</simpara>
<screen>    my256bytebuffer(0)    = some_variable.  Will address location 0x2400
    my256bytebuffer(255)  = some_variable.  Will address location 0x24FF ' the 256th byte of the allocated memory</screen>
<simpara>Implementers of ALLOC must ensure memory constraints remain true.</simpara>
<simpara><emphasis role="strong">Safety</emphasis></simpara>
<simpara>This method is unsafe because undefined behaviour can result if the caller does not ensure that buffer extents are not maintained. &#160;&#160;   If buffer extents are exceeded the program may address areas of memory that have adverse impact on the operation of the microcontroller.</simpara>
<simpara>Examples of unsafe usage:</simpara>
<screen>    my256bytebuffer(256) = some_variable.  Will address location 0x2500  ' this is the first byte of BUFFER RAM on the 18FxxQ43 chips... bad things may happen
    my256bytebuffer(65535) = some_variable.  Will address location 0x123FF  ' this is the beyond the memory limit and the operation will write an SFR.</screen>
<simpara><emphasis role="strong">Example Program</emphasis></simpara>
<simpara>The following example program shows the ALLOCation of a 256 byte buffer at a specific address.&#160;&#160;
The array variant is then populated with data and then shown on a serial terminal.</simpara>
<screen>        ' Chip Settings and preamble
        #CHIP  18F27Q43
        #OPTION EXPLICIT


        'Generated by PIC PPS Tool for GCBASIC - this explicit to a specific chip
        #startup InitPPS, 85
        #define PPSToolPart 18f27q43

        Sub InitPPS

                'Module: UART pin directions
                Dir PORTC.6 Out    ' Make TX1 pin an output
                'Module: UART1
                RC6PPS = 0x0020    'TX1 &gt; RC6

        End Sub
        'Template comment at the end of the config file

        ' USART settings for USART1
        #DEFINE USART_BAUD_RATE 9600
        #DEFINE USART_TX_BLOCKING
        #DEFINE USART_DELAY 0

        '---------------------------
        ' Main Program

        #DEFINE BUFFERSIZE 256  ' gives range of 0 to 255

        'DIMension an ArrayVariant using ALLOC to create an ArrayVariant with the size of BUFFERSIZE.
        'This array is created at memory location 0x2400.
        'This memory location is specific to this chip ( you must ensure other microcontrollers address are valid).

        Dim mybuffer1 as ALLOC * BUFFERSIZE at 0x2400

        'A data table
        Table myDataTable
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
        End Table

        Dim iLoop, tableDataValue, memoryDataValue as byte

        'These varaibles are ONLY used to demonstrate the showing of the allocated memory address
        Dim mybuffer1startaddress, mybuffer1endaddress as word

        mybuffer1startaddress = @mybuffer1
        mybuffer1endaddress = mybuffer1startaddress + BUFFERSIZE - 1


        HSerPrintCRLF 2
        HSerPrint "Buffer test - 256 bytes "
        HSerPrint " at address: 0x"
        HSerPrint hex( mybuffer1startaddress_h )
        HSerPrint hex( mybuffer1startaddress )
        HSerPrint " to 0x"
        HSerPrint hex( mybuffer1endaddress_h )
        HSerPrint hex( mybuffer1endaddress )
        HSerPrintCRLF 2

        'Load buffer with table data
        for iLoop = 0 to 255
            ReadTable myDataTable, [word]iLoop+1, tableDataValue
            mybuffer1( iLoop ) = tableDataValue
        next

        wait 100 ms

        HserPrint "Print dataDump array to serial terminal"
        HSerPrintCRLF
        for iLoop = 0 to 255
            HSerPrint leftpad(str( myBuffer1(iLoop)),3)
            If iLoop % 16 = 15 Then HSerPrintCRLF
        next

        Wait 100 ms
        HSerPrintCRLF
        HserPrint "Print memory to serial terminal using PEEK to get the memory location byte value"
        HSerPrintCRLF
        for iLoop = 0 to 255
            memoryDataValue = PEEK ( @myBuffer1+iLoop )
            HSerPrint leftpad(str( memoryDataValue ) ,3)
            If iLoop % 16 = 15 Then HSerPrintCRLF
        next
        HSerPrintCRLF
        Wait 100 ms</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_dim">Declaring arrays with DIM</link></simpara>
</section>
<section xml:id="_bcdtodec_gcb">
<title>BcdToDec_GCB</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    BcdToDec_GCB ( ByteVariable )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara>Support Bytes only.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Converts numbers from Binary Coded Decimal format to decimal.</simpara>
<simpara>You can add this function. Just add this to your GCBASIC program and then call it when you need it.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    Function BcdToDec(va) as byte
        BcdToDec=(va/16)*10+va%16
    End Function</screen>
<simpara><emphasis role="strong">Also see</emphasis> <link linkend="_dectobcd_gcb">DecToBcd_GCB</link></simpara>
</section>
<section xml:id="_dectobcd_gcb">
<title>DecToBcd_GCB</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen> DectoBcd( ByteVariable )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Converts numbers from Decimal to Binary Coded Decimal format. Support Bytes only.</simpara>
<simpara>You can add this function. Just add this to your GCBASIC program and then call it when you need it.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    Function DecToBcd(va) as Byte
       DecToBcd=(va/10)*16+va%10
    End Function</screen>
<simpara><emphasis role="strong">Also see</emphasis> <link linkend="_bcdtodec_gcb">BcdToDec_GCB</link></simpara>
</section>
<section xml:id="_rotate">
<title>Rotate</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Rotate <emphasis>variable</emphasis> {Left | Right} [Simple]</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Rotate</literal> command will rotate <literal><emphasis>variable</emphasis></literal> one bit in a specified direction. The bit shifted will be placed in the Carry bit of the Status register (<literal>STATUS.C</literal>). <literal>STATUS.C</literal> acts as a ninth bit of the variable that is being rotated.</simpara>
<simpara><literal><emphasis>variable</emphasis></literal> supports Bytes, Word and Long variables.</simpara>
<simpara>When a variable is <emphasis role="strong">rotated right</emphasis>, the bit in the <literal>STATUS.C</literal> location is placed into the MSB of the variable being rotated, and the LSB of the variable is placed into STATUS.C location.</simpara>
<simpara>When <emphasis role="strong">rotated left</emphasis> the opposite occurs. The MSB of the variable is shifted to the <literal>STATUS.C</literal> bit and the LSB of the variable will contain what was previously in the <literal>STATUS.C</literal> bit location.</simpara>
<simpara>This table shows the operation of the <literal>Rotate Left</literal> command</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong"><emphasis>variable</emphasis></emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">STATUS.C</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Values at start:</simpara></entry>
<entry align="left" valign="top"><simpara>b'01110011'</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate Left</simpara></entry>
<entry align="left" valign="top"><simpara>b'11100110'</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate Left again</simpara></entry>
<entry align="left" valign="top"><simpara>b'11001100'</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate Left third time</simpara></entry>
<entry align="left" valign="top"><simpara>b'10011001'</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>As you may notice the STATUS.C bit added a 0 to the rotation. So this will take 9 shifts left to get back to the original value.</simpara>
<simpara><emphasis role="strong">Simple option</emphasis></simpara>
<simpara>Many times you want to rotate the variable around like the STATUS.C bit wasn’t there so the MSB of the variable fills the LSB of the variable on Rotate Left or the LSB fills the MSB on Rotate Right. That is where the SIMPLE option comes in. It adds a hidden step that shifts the STATUS.C bit twice so the bit moves from one end of the variable to the other.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong"><emphasis>variable</emphasis></emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">STATUS.C</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Values at start:</simpara></entry>
<entry align="left" valign="top"><simpara>b'01110011'</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate Left</simpara></entry>
<entry align="left" valign="top"><simpara>b'11100110'</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate Left again</simpara></entry>
<entry align="left" valign="top"><simpara>b'11001101'</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate Left third time</simpara></entry>
<entry align="left" valign="top"><simpara>b'10011011'</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Notes:
The carry is also called SREG bit C, or simply C flag on AVR.</simpara>
<simpara>In some cases the Status.C or C flag may already be set because of prior operations in your program.
Therefore, it may be necessary to clear the C flag before using <literal>Rotate</literal>.
Use <literal>Set C Off</literal> before using the <literal>Rotate</literal> command to clear the flag.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will use Rotate to show a chasing LED.
    '8 LEDs should be connected to PORTB, one on each pin.

    #chip 16F819, 8

    'Set port direction
    Dir PORTB Out

    'Set initial state of port (bits 0 and 4 on)
    PORTB = b'00010001'

    'Chase
    C = 0
    Do
        Rotate PORTB Right Simple
        Wait 250 ms
    Loop</screen>
</section>
<section xml:id="_set">
<title>Set</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Set <emphasis>variable.bit</emphasis> {On | Off}</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The purpose of the Set command is to turn individuals bits on and off.</simpara>
<simpara>The Set command is most useful for controlling output ports, but can also be used to set variables.</simpara>
<simpara>Often when controlling output ports, Set is used in conjunction with constants. This makes it easier to adapt the program for a new circuit later.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Blink LED sample program for GCBASIC
    'Controls an LED on PORTB bit 0.

    'Set chip model and config options
    #chip 16F84A, 20

    'Set a constant to represent the output port
    #define LED PORTB.0

    'Set pin direction
    Dir LED Out

    'Main routine
    Do
        Set LED On
        Wait 1 sec
        Set LED OFF
        Wait 1 sec
    Loop</screen>
</section>
<section xml:id="_swap4">
<title>SWAP4</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SWAP4( VariableA)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara>Support Bytes only.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>A function that swaps (or exchanges) nibbles (or the 8 bits of a byte in nibbles).</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    dim ByteVariable as Byte

    ' Set variable to  0x12
    ByteVariable = 0x12

    ByteVariable = Swap4( ByteVariable )

    HSerPrint hex(ByteVariable)

    ' Would return 0x21</screen>
</section>
<section xml:id="_swap">
<title>SWAP</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SWAP( VariableA, VariableB)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara>Support Bytes and Words only.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>A function that swaps (or exchanges) one byte or word for another. SWAP support the use of byte and word variables.</simpara>
</section>
</section>
<section xml:id="_string_manipulation">
<title>String Manipulation</title>
<simpara>This is the String Manipulation section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_asc">
<title>Asc</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    byte<emphasis>var</emphasis>= ASC(string, [position] )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Returns the character code of the character at the specified position in a string.</simpara>
<simpara><literal>ASC</literal> returns the character code of a particular character in the string.  If the string is an ANSI string, the returned value will be in the range of 0 to 255. This function DOES NOT support UNICODE.</simpara>
<simpara>The optional position parameter determines which character is to be checked. The first character is one, the second two, etc. If the position parameter is missing, the first character is presumed.</simpara>
<simpara><literal>CHR</literal> is the natural complement of <literal>ASC</literal>. <literal>CHR</literal> produces a one-character string corresponding to its ASCII.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>If the string passed is null (zero-length) or the position is zero or greater than the length of the string the returned value will be 0.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    charpos = ASC( "ABCD" )     ' Returns 65

    charpos = ASC( "ABCD", 2 )  ' Returns 66</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_chr">Chr</link></simpara>
</section>
<section xml:id="_bytetobin">
<title>ByteToBin</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = ByteToBin(<emphasis>bytevar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>ByteToBin</literal> function creates a string of a ANSI (8-byte) characters.
The function converts a number to a string consisting of ones and zeros that represents the binary value.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
Supports BYTE variables only.  For WORD variables use <literal>WordToBin</literal></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    string = ByteToBin( 1 )   ' Returns "00000001"

    string = ByteToBin( 254 ) ' Returns "11111110"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_wordtobin">WordToBin</link></simpara>
</section>
<section xml:id="_bytetohex">
<title>ByteToHex</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = ByteToHex(<emphasis>number</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Hex</literal> function will convert a byte number into hexadecimal format. The input <literal><emphasis>number</emphasis></literal> should be a byte variable, or a fixed number between 0 and 255 inclusive. After running the function, the string variable <literal><emphasis>stringvar</emphasis></literal> will contain a 2 digit hexadecimal number.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Send EEPROM data over serial connection
    'Uses Hex to display as hexadecimal
    For CurrentLocation = 0 to 255
        'Send location
        HSerPrint ByteToHex(CurrentLocation)
        HSerPrint ":"
        'Read byte and send
        EPRead CurrentLocation, CurrByte
        HSerPrint Hex(CurrByte)
        'Send carriage return/line feed
        HSerPrintCRLF
    Next</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_wordtohex">WordToHex</link>,<link linkend="_longtohex_">LongToHex</link>, <link linkend="_integertohex">IntegerToHex</link>, <link linkend="_singletohex">SingleToHex</link></simpara>
</section>
<section xml:id="_bytetostring">
<title>ByteToString</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = ByteToString(<emphasis>byte_variable</emphasis>)     'supports byte.</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>ByteToString</literal> function will convert a number into a string. <literal><emphasis>number</emphasis></literal> can be any byte variable, or a fixed number constant between 0 and 255 inclusive.&#160;&#160;For Word number use <literal>WordToString()</literal>, Long numbers use <literal>LongToString()</literal>, for Integer numbers use <literal>IntegerToString()</literal> and for Single numbers use <literal>SingleToString()</literal></simpara>
<simpara>The string variable <literal><emphasis>stringvar</emphasis></literal> will contain the same number, represented as a string.&#160;&#160;The length of the string returned is 5 characters.</simpara>
<simpara>This function is especially useful if a number needs to added to the end of a string, or if a custom data sending routine has been created but only supports the output of string variables.
<?asciidoc-br?>
<?asciidoc-br?>
These methods will not support  conversion of hexadecimal number strings.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example1:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    Dim SensorReading as Byte

    'Take an A/D reading
    SensorReading = ReadAD(AN0)

    'Create a string variable
    Dim OutVar As String

    'Fill string with sensor reading
    OutVar = ByteToString(SensorReading)

    'Send
    HSerPrint OutVar
    HSerPrintCRLF

    When using the functions ByteToString() do not leave space between the function
    call and the left brace. You will get a compiler error that is
    meaningless.

    ' use this, note this is no space between the ByteToString() and the left brace!
    ByteToString(number_variable)
    ' do not use, note the space!
    ByteToString (number_variable)</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example2:</emphasis></simpara>
<screen>    '''
    '''
    '''
    '''
    '''************************************************************************
    '''
    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCode
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: June 2021
    '''
    ' ----- Configuration
      'Chip Settings.
      #chip 16f18855,32
      #Config CLRE_ON
      #option Explicit

    ; ----- Define Hardware settings

      'Set the PPS of the RS232 ports.
      UNLOCKPPS
        RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
      LOCKPPS

    ; ----- Constants
      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

    ; ----- Variables
    dim bytevar as Byte

    ; ----- Main body of program commences here.
    bytevar = 0xff

    do
       wait 100 ms

       HSerPrint ByteToString( bytevar )
       HSerPrintCRLF
       wait 1 s
    loop
    end

; ----- Support methods.  Subroutines and Functions</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">See Also</emphasis> <link linkend="_wordtohex">WordToString</link>, <link linkend="_longtohex">LongToString</link>, <link linkend="_integertohex">IntegerToString</link>, <link linkend="_singletohex">SingleToString</link>, <link linkend="_bytetohex">ByteToHex</link></simpara>
</section>
<section xml:id="_chr">
<title>Chr</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = CHR(<emphasis>bytevar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>CHR</literal> function creates a string of a ANSI (1-byte) character.</simpara>
<simpara><literal>ASC</literal> is the natural complement of <literal>CHR</literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    <emphasis>string</emphasis> = CHR( 65 )   ' Returns "A"

    <emphasis>string</emphasis> = CHR( 66 )   ' Returns "B"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_asc">Asc</link></simpara>
</section>
<section xml:id="_fill">
<title>Fill</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> =  Fill ( byte_value_of_the_new_length , pad_character )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The Fill function is used to create string to a specific length that is of a specific character.</simpara>
<simpara>The length of the string is specified by the first parameter.
The character used to pad the string is specified by the second parameter, this parameter is optional as the " "(space) character is assumed.</simpara>
<simpara>A typical use is to fill a string to be displayed on an LCD or serial terminal.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F886


    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
   #define USART_TX_BLOCKING



    HserPrint Fill ( 16, "<emphasis role="strong">" ) ;will print a string of '<emphasis role="strong"></emphasis></emphasis><emphasis role="strong"><emphasis role="strong"></emphasis><emphasis role="strong"></emphasis></emphasis>*'
    HSerPrintCRLF</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_asc">Asc</link></simpara>
</section>
<section xml:id="_integertobin">
<title>IntegerToBin</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = IntegerToBin(<emphasis>integervar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>IntegerToBin</literal> function creates a string of a ANSI (signed 15 digit string ) characters.
The function converts a number to a string consisting of ones and zeros that represents the binary value.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
Supports Integer variables only.  For BYTE variables use <literal>VarToBin</literal>, for Word variables use <literal>WordToBin</literal> and for LONG variables use <literal>LongToBin</literal></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    string = IntegerToBin( 1 )   ' Returns "+000000000000001"
    string = IntegerToBin( -1 )  ' Returns "-000000000000001"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_bytetobin">ByteToBin</link>, <link linkend="_wordtobin">WordToBin</link>, <link linkend="_longtobin">LongToBin</link></simpara>
</section>
<section xml:id="_integertohex">
<title>IntegerToHex</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = IntegerToHex(<emphasis>number</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Hex</literal> function will convert a Integer number into hexadecimal format. The input <literal><emphasis>number</emphasis></literal> should be a Integer variable, or a fixed number between -32767 and -32767 inclusive. After running the function, the string variable <literal><emphasis>stringvar</emphasis></literal> will contain an 4 digit hexadecimal number.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Send EEPROM data over serial connection
    'Uses Hex to display as hexadecimal
    For CurrentLocation = 0 to 65535
        'Send location
        HSerPrint IntegerToHex(CurrentLocation)
        HSerPrint ":"
        'Read Integer and send
        EPRead CurrentLocation, CurrInteger
        HSerPrint Hex(CurrInteger)
        'Send carriage return/line feed
        HSerPrintCRLF
    Next</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_bytetohex">ByteToHex</link>,<link linkend="_wordtohex_">WordToHex</link>, <link linkend="_longtohex">LongToHex</link>, <link linkend="_singletohex">SingleToHex</link></simpara>
</section>
<section xml:id="_integertostring">
<title>IntegerToString</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = IntegerToString(<emphasis>Integer_variable</emphasis>)     'supports Integer.</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>IntegerToString</literal> function will convert a number into a string. <literal><emphasis>number</emphasis></literal> can be any Integer variable, or a fixed number constant between 0 and 4294967295 inclusive.&#160;&#160;For Byte number use <literal>ByteToString()</literal>, Word numbers use <literal>WordToString()</literal>, for Integer numbers use <literal>IntegerToString()</literal> and for Single numbers use <literal>SingleToString()</literal></simpara>
<simpara>The string variable <literal><emphasis>stringvar</emphasis></literal> will contain the same number, represented as a string.&#160;&#160;The length of the string returned is 9 characters.</simpara>
<simpara>This function is especially useful if a number needs to added to the end of a string, or if a custom data sending routine has been created but only supports the output of string variables.
<?asciidoc-br?>
<?asciidoc-br?>
These methods will not support  conversion of hexadecimal number strings.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example1:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    Dim SensorReading as Integer

    'Take an A/D reading
    SensorReading = ReadAD10(AN0)

    'Create a string variable
    Dim OutVar As String

    'Fill string with sensor reading
    OutVar = IntegerToString(SensorReading)

    'Send
    HSerPrint OutVar
    HSerPrintCRLF

    When using the functions IntegerToString() do not leave space between the function
    call and the left brace. You will get a compiler error that is
    meaningless.

    ' use this, note this is no space between the IntegerToString() and the left brace!
    IntegerToString(number_variable)
    ' do not use, note the space!
    IntegerToString (number_variable)</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example2:</emphasis></simpara>
<screen>    '''
    '''
    '''
    '''
    '''************************************************************************
    '''
    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCode
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: June 2021
    '''
    ' ----- Configuration
      'Chip Settings.
      #chip 16f18855,32
      #Config CLRE_ON
      #option Explicit

    ; ----- Define Hardware settings

      'Set the PPS of the RS232 ports.
      UNLOCKPPS
        RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
      LOCKPPS

    ; ----- Constants
      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

    ; ----- Variables
    dim Integervar as Integer

    ; ----- Main body of program commences here.
    Integervar = -10

    do
       wait 100 ms

       HSerPrint IntegerToString( Integervar )
       HSerPrintCRLF
       wait 1 s
    loop
    end

; ----- Support methods.  Subroutines and Functions</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">See Also</emphasis> <link linkend="_bytetohex">ByteToString</link>, <link linkend="_wordtohex">WordToString</link>, <link linkend="_longtohex">LongToString</link>, <link linkend="_singletohex">SingleToString</link>, <link linkend="_bytetohex">ByteToHex</link></simpara>
</section>
<section xml:id="_instr">
<title>Instr</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>location</emphasis> = Instr(<emphasis>source</emphasis>, <emphasis>find</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Instr</literal> function will search one string to find the location of another string within it. <literal><emphasis>source</emphasis></literal> is the string to search inside, and <literal><emphasis>find</emphasis></literal> is the string to find. The function will return the location of <literal><emphasis>find</emphasis></literal> within <literal><emphasis>source</emphasis></literal>, or 0 if <literal><emphasis>source</emphasis></literal> does not contain <literal><emphasis>find</emphasis></literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the location of "world" within the string
    'Will return 8, because "w" in world is the 8th character
    'of "Hello, world!"
    HSerPrint Instr(TestData, "world")
    HSerPrintCRLF

    'Display the location of "planet" within the string
    'Will display 0, because "planet" does not occur inside
    'the string "Hello, world!"
    HSerPrint Instr(TestData, "planet")
    HSerPrintCRLF</screen>
</section>
<section xml:id="_lcase">
<title>LCase</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>output</emphasis> = LCase(<emphasis>source</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>LCase</literal> function will convert all of the letters in the string <literal><emphasis>source</emphasis></literal> to lower case, and return the result.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the string in lower case
    'Will display "hello, world!"
    HSerPrint LCase(TestData)
    HSerPrintCRLF</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_ucase">UCase</link></simpara>
</section>
<section xml:id="_left">
<title>Left</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>output</emphasis> = Left(<emphasis>source</emphasis>, <emphasis>count</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Left</literal> function will extract the leftmost <literal><emphasis>count</emphasis></literal> characters from the input string <literal><emphasis>source</emphasis></literal>, and return them in a new string.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the leftmost 5 characters
    'Will display "Hello"
    HSerPrint Left(TestData, 5)
    HSerPrintCRLF</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_mid">Mid</link>, <link linkend="_right">Right</link></simpara>
</section>
<section xml:id="_leftpad">
<title>LeftPad</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LeftPad(<emphasis>string_variable</emphasis>,<emphasis>byte_value_of_the_new_length</emphasis>,<emphasis>pad_character</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The LeftPad function is used to create string to a specific length that is extended with a specific character to the left hand side of the string.</simpara>
<simpara>The length of the string is specified by the second parameter.</simpara>
<simpara>The character used to pad the string is specified by the third parameter.</simpara>
<simpara>A typical use is to pad a string to be displayed on a serial terminal or LCD.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
 'Set chip model
    #chip 16f877a


    DIR PORTA 0x03


    ' make port C as output
    Dir PortC 0x0


    'Defines (Constants)
    #define LCD_SPEED slow
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_NO_RW
    #define LCD_Enable PORTc.0
    #define LCD_RS PORTc.1
    #define LCD_DB4 PORTa.5
    #define LCD_DB5 PORTa.4
    #define LCD_DB6 PORTa.3
    #define LCD_DB7 PORTa.2
    '''--------------------------------------------
    '''-------End of board-specific settings-------
    '''--------------------------------------------


    '''DEMO for padding strings left with
    '''1st character of a given string.
    '''if no string is given, blanks are used


    ; ---- variables
    DIM inString as string * 5
    DIM outString1 as String
    DIM outString2 as String

    ; ---- main body of program begins here

    inString = "12345"

    outString1 = leftpad(inString, 9, "*")
    outString2 = leftpad(inString, 9)

    'show results on LCD-Display
    cls

    print instring
    print " "
    print outstring1
    locate 1,0
    print instring
    print " "
    print outstring2

    end</screen>
</section>
<section xml:id="_len">
<title>Len</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>output</emphasis>= Len( string )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Len</literal> function returns an byte value which is the length of a phrase or a sentence, including the empty spaces. The format is:</simpara>
<screen>    target_byte_variable = Len("Phrase")</screen>
<simpara>or another example. This code will loop through the for-next loop 12 times as determined by the length of the string:<?asciidoc-br?></simpara>
<screen>    ' create a test string of 12 characters
    dim teststring as string * 12

    teststring = "0123456789AB"
    for loopthrustring = 1 to len(teststring)
       hserprint mid(teststring, loopthrustring , 1)
    next</screen>
</section>
<section xml:id="_longtobin">
<title>LongToBin</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = LongToBin(<emphasis>longvar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>LongToBin</literal> function creates a string of a ANSI (32) characters.
The function converts a number to a string consisting of ones and zeros that represents the binary value.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
Supports LONG variables only.  For BYTE variables use <literal>VarToBin</literal>, for WORD variables use <literal>VarWToBinand</literal> for INTEGER variables use <literal>VarIntegerToBin</literal></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    string = LongToBin( 1 )   ' Returns "0000000000000001"

    string = LongToBin( 254 ) ' Returns "0000000011111110"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_vartobin">VarToBin</link>, <link linkend="_varWtobin">VarWToBin</link>, <link linkend="_varintegertobin">VarIntegerToBin</link></simpara>
</section>
<section xml:id="_longtohex">
<title>LongToHex</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = LongToHex(<emphasis>number</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Hex</literal> function will convert a Long number into hexadecimal format. The input <literal><emphasis>number</emphasis></literal> should be a Long variable, or a fixed number between 0 and 4294967295 inclusive. After running the function, the string variable <literal><emphasis>stringvar</emphasis></literal> will contain an 8 digit hexadecimal number.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Send EEPROM data over serial connection
    'Uses Hex to display as hexadecimal
    For CurrentLocation = 0 to 65535
        'Send location
        HSerPrint LongToHex(CurrentLocation)
        HSerPrint ":"
        'Read Long and send
        EPRead CurrentLocation, CurrLong
        HSerPrint Hex(CurrLong)
        'Send carriage return/line feed
        HSerPrintCRLF
    Next</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_bytetohex">ByteToHex</link>,<link linkend="_wordtohex_">WordToHex</link>, <link linkend="_integertohex">IntegerToHex</link>, <link linkend="_singletohex">SingleToHex</link></simpara>
</section>
<section xml:id="_longtostring">
<title>LongToString</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = LongToString(<emphasis>Long_variable</emphasis>)     'supports Long.</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>LongToString</literal> function will convert a number into a string. <literal><emphasis>number</emphasis></literal> can be any Long variable, or a fixed number constant between 0 and 4294967295 inclusive.&#160;&#160;For Byte number use <literal>ByteToString()</literal>, Word numbers use <literal>WordToString()</literal>, for Integer numbers use <literal>IntegerToString()</literal> and for Single numbers use <literal>SingleToString()</literal></simpara>
<simpara>The string variable <literal><emphasis>stringvar</emphasis></literal> will contain the same number, represented as a string.&#160;&#160;The length of the string returned is 10 characters.</simpara>
<simpara>This function is especially useful if a number needs to added to the end of a string, or if a custom data sending routine has been created but only supports the output of string variables.
<?asciidoc-br?>
<?asciidoc-br?>
These methods will not support  conversion of hexadecimal number strings.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example1:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    Dim SensorReading as Long

    'Take an A/D reading
    SensorReading = ReadAD12(AN0)

    'Create a string variable
    Dim OutVar As String

    'Fill string with sensor reading
    OutVar = LongToString(SensorReading)

    'Send
    HSerPrint OutVar
    HSerPrintCRLF

    When using the functions LongToString() do not leave space between the function
    call and the left brace. You will get a compiler error that is
    meaningless.

    ' use this, note this is no space between the LongToString() and the left brace!
    LongToString(number_variable)
    ' do not use, note the space!
    LongToString (number_variable)</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example2:</emphasis></simpara>
<screen>    '''
    '''
    '''
    '''
    '''************************************************************************
    '''
    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCode
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: June 2021
    '''
    ' ----- Configuration
      'Chip Settings.
      #chip 16f18855,32
      #Config CLRE_ON
      #option Explicit

    ; ----- Define Hardware settings

      'Set the PPS of the RS232 ports.
      UNLOCKPPS
        RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
      LOCKPPS

    ; ----- Constants
      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

    ; ----- Variables
    dim Longvar as Long

    ; ----- Main body of program commences here.
    Longvar = 0xffffffff

    do
       wait 100 ms

       HSerPrint LongToString( Longvar )
       HSerPrintCRLF
       wait 1 s
    loop
    end

; ----- Support methods.  Subroutines and Functions</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">See Also</emphasis> <link linkend="_bytetohex">ByteToString</link>, <link linkend="_wordtohex">WordToString</link>, <link linkend="_integertohex">IntegerToString</link>, <link linkend="_singletohex">SingleToString</link>, <link linkend="_bytetohex">ByteToHex</link></simpara>
</section>
<section xml:id="_ltrim">
<title>Ltrim</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = LTRIM(<emphasis>stringvar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Ltrim</literal> function will trim the 7-bit ASCII space character (value 32) from the LEFT hand side of a string.</simpara>
<simpara>Use <literal>Ltrim</literal> on text that you have received from another source that may have irregular spacing at the left hand end of the string.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_trim">Trim</link>, <link linkend="_rtrim">Rtrim</link></simpara>
</section>
<section xml:id="_mid">
<title>Mid</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>output</emphasis> = Mid(<emphasis>source</emphasis>, <emphasis>start</emphasis>[, <emphasis>count</emphasis>])</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Mid</literal> function returns a string variable containing a specified number of characters from a source string.</simpara>
<simpara><literal><emphasis>source</emphasis></literal> is the variable to extract from.  If <literal><emphasis>source</emphasis></literal> is a zero length string - a zero length string is returned equating to "".
<?asciidoc-br?>
<literal><emphasis>start</emphasis></literal> is the position of the first character to extract. If <literal><emphasis>start</emphasis></literal> is greater than the number of characters in string, Mid returns a zero-length string equating to "".
<?asciidoc-br?>
<literal><emphasis>count</emphasis></literal> is the number of characters to extract. If <literal><emphasis>count</emphasis></literal> is not specified, all characters from <literal><emphasis>start</emphasis></literal> to the end of the source string will be returned.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "The cat sat on the mat"

    'Extract "cat". The c is at position 5, and 3 letters are needed
    HSerPrint "The animal is a "
    HSerPrint Mid(TestData, 5, 3)

    'Extract the action. "sat" starts at position 9.
    HSerPrint "The animal "
    HSerPrint Mid(TestData, 9)
    HSerPrintCRLF</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_left">Left</link>, <link linkend="_right">Right</link></simpara>
</section>
<section xml:id="_pad">
<title>Pad</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    out_string = Pad( <emphasis>string_variable</emphasis>, <emphasis>byte_value_of_the_new_length</emphasis>, <emphasis>pad_character</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Pad</literal> function is used to create string to a specific length that is extended with a specific character.</simpara>
<simpara>The length of the string is specified by the second parameter.  The character used to pad the string is specified by the third parameter.</simpara>
<simpara>A typical use is to pad a string to be displayed on a LCD display.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen> 'Set chip model
    #chip 16f877a


    DIR PORTA 0x03


    ' make port C as output
    Dir PortC 0x0


    'Defines (Constants)
    #define LCD_SPEED slow
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_NO_RW
    #define LCD_Enable PORTc.0
    #define LCD_RS PORTc.1
    #define LCD_DB4 PORTa.5
    #define LCD_DB5 PORTa.4
    #define LCD_DB6 PORTa.3
    #define LCD_DB7 PORTa.2
    '''--------------------------------------------
    '''-------End of board-specific settings-------
    '''--------------------------------------------


    '''DEMO for pad strings to a length
    '''1st character of a given string.
    '''if no string is given, blanks are used


    ; ---- variables
    'Define the string
    Dim TestData As String * 16
    TestData = "Location"

    'show results on LCD-Display
    cls
    Print Pad ( TestData, 16, "*" )
    Locate 1,0
    Print Pad ( TestData, 16, )


    end</screen>
</section>
<section xml:id="_right">
<title>Right</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>output</emphasis> = Right(<emphasis>source</emphasis>, <emphasis>count</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Right</literal> function will extract the rightmost <literal><emphasis>count</emphasis></literal> characters from the input string <literal><emphasis>source</emphasis></literal>, and return them in a new string.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_BLOCKING

    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the rightmost 6 characters
    'Will display "world!"
    HSerPrint Right(TestData, 6)
    HSerPrintCRLF</screen>
</section>
<section xml:id="_rtrim">
<title>Rtrim</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = Rtrim(<emphasis>stringvar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Rtrim</literal> function will trim the 7-bit ASCII space character (value 32) from the RIGHT hand side of a string.</simpara>
<simpara>Use <literal>Rtrim</literal> on text that you have received from another source that may have irregular spacing at the right hand end of the string.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_trim">Trim</link>, <link linkend="_ltrim">Ltrim</link></simpara>
</section>
<section xml:id="_trim">
<title>Trim</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <emphasis>stringvar</emphasis> = Trim(<emphasis>stringvar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Trim</literal> function will trim the 7-bit ASCII space character (value 32) from text.</simpara>
<simpara><literal>Trim</literal> removes all spaces from text except for single spaces between words. Use <literal>Trim</literal> on text that you have received from another source that may have irregular spacing at the left or right hand ends of the string.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_ltrim">Ltrim</link>, <link linkend="_rtrim">Rtrim</link></simpara>
</section>
<section xml:id="_ucase">
<title>UCase</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <emphasis>output</emphasis> = UCase(<emphasis>source</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>UCase</literal> function will convert all of the letters in the string <literal><emphasis>source</emphasis></literal> to upper case, and return the result.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the string in upper case
    'Will display "HELLO, WORLD!"
    HSerPrint UCase(TestData)
    HSerPrintCRLF</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_lcase">LCase</link></simpara>
</section>
<section xml:id="_singletobin">
<title>SingleToBin</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = SingleToBin(<emphasis>Singlevar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>SingleToBin</literal> function creates a string of a ANSI (32) characters.
The function converts a number to a string consisting of ones and zeros that represents the binary value.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
Supports Single variables only.  For BYTE variables use <literal>VarToBin</literal>, for WORD variables use <literal>VarWToBinand</literal> for INTEGER variables use <literal>VarIntegerToBin</literal></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    string = SingleToBin( 1 )   ' Returns "00000000000000000000000000000001"

    string = SingleToBin( 254 ) ' Returns "00000000000000000000000011111110"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_vartobin">ByteToBin</link>, <link linkend="_varWtobin">WordToBin</link>, <link linkend="_varintegertobin">IntegerToBin</link></simpara>
</section>
<section xml:id="_singletohex">
<title>SingleToHex</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = SingleToHex(<emphasis>number</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Hex</literal> function will convert a Single number into hexadecimal format. The input <literal><emphasis>number</emphasis></literal> should be a Single variable, or a fixed number between -3.4x10 ^ 38 and +3.4x10 ^ 38 inclusive. After running the function, the string variable <literal><emphasis>stringvar</emphasis></literal> will contain an 4 digit hexadecimal number.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Send EEPROM data over serial connection
    'Uses Hex to display as hexadecimal
    For CurrentLocation = 0 to 9999999
        'Send location
        HSerPrint SingleToHex(CurrentLocation)
        HSerPrint ":"
        'Read Single and send
        EPRead CurrentLocation, CurrSingle
        HSerPrint Hex(CurrSingle)
        'Send carriage return/line feed
        HSerPrintCRLF
    Next</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_bytetohex">ByteToHex</link>,<link linkend="_wordtohex_">WordToHex</link>, <link linkend="_longtohex">LongToHex</link>, <link linkend="_integertohex">IntegerToHex</link></simpara>
</section>
<section xml:id="_singletostring">
<title>SingleToString</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = SingleToString(<emphasis>Single_variable</emphasis>)     'supports Single.</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>SingleToString</literal> function will convert a number into a string. <literal><emphasis>number</emphasis></literal> can be any Single variable.&#160;&#160;For Byte numbers use <literal>ByteToString()</literal>, Word numbers use <literal>WordToString()</literal>, for Integer numbers use <literal>IntegerToString()</literal> and for Long numbers use <literal>LongToString()</literal></simpara>
<simpara>The string variable <literal><emphasis>stringvar</emphasis></literal> will contain the ACSII representation of the input number.&#160;&#160;The length of the string is variable length dependent on the input variable value.</simpara>
<simpara>This function is especially useful if a number needs to added to the end of a string, or if a custom data sending routine has been created but only supports the output of string variables.
<?asciidoc-br?>
<?asciidoc-br?>
These methods will not support  conversion of hexadecimal number strings.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Operational Returned Controls</emphasis></simpara>
<simpara>The function returns either the number string or the message "Error ".&#160;&#160;The reasons for "Error " are:</simpara>
<itemizedlist>
<listitem>
<simpara>Very small number that actaully compute as 0.0</simpara>
</listitem>
<listitem>
<simpara>The input values is too large</simpara>
</listitem>
<listitem>
<simpara>Too many chars-out of range</simpara>
</listitem>
</itemizedlist>
<simpara>There is a public variable available after using this function.&#160;&#160;`SysByte_STS_Err` - this variable returns the following:</simpara>
<simpara>&#160;&#160;&#160;&#160;SysByte_STS_Err   where 1 or 9 equates to no error.</simpara>
<simpara>&#160;&#160;&#160;&#160;1 equates to a properly formatted number string.</simpara>
<simpara>&#160;&#160;&#160;&#160;8 equateq to a properly formatted integer number string.</simpara>
<simpara><emphasis>Bitwise returned details</emphasis></simpara>
<literallayout class="monospaced">SysByte_STS_Err.0 :  1 = good, or, 0 = bad
SysByte_STS_Err.1 :  1 = decimals places to many chars, or, 0 = ok
SysByte_STS_Err.2 :  1 = integer places to many chars-out of range, or, 0 = ok
SysByte_STS_Err.3 :  1 = no decimal point, info only
SysByte_STS_Err.4 :  1 = non numeric chars found</literallayout>
<simpara><emphasis role="strong">Example Usage 1:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    Dim SensorReading as Single

    'Take an A/D reading
    SensorReading = ReadAD(AN0)

    'Create a string variable
    Dim OutVar As String

    'Fill string with sensor reading
    OutVar = SingleToString(SensorReading)

    'Send
    HSerPrint OutVar
    HSerPrintCRLF

    When using the functions SingleToString() do not leave space between the function
    call and the left brace. You will get a compiler error that is
    meaningless.

    ' use this, note this is no space between the SingleToString() and the left brace!
    SingleToString(number_variable)
    ' do not use, note the space!
    SingleToString (number_variable)

    Do
    Loop

    End</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example Usage 2:</emphasis></simpara>
<screen>    '''
    '''
    '''
    '''
    '''************************************************************************
    '''
    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCode
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: June 2021
    '''
    ' ----- Configuration
      'Chip Settings.
      #chip 16f18855,32
      #Config CLRE_ON
      #option Explicit

    ; ----- Define Hardware settings

      'Set the PPS of the RS232 ports.
      UNLOCKPPS
        RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
      LOCKPPS

    ; ----- Constants
      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

    ; ----- Variables
    dim Singlevar as Single

    ; ----- Main body of program commences here.
    Singlevar = -10

    do
       wait 100 ms

       HSerPrint SingleToString( Singlevar )
       HSerPrintCRLF
       wait 1 s
    loop

    end</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">See Also</emphasis> <link linkend="_bytetohex">ByteToString</link>, <link linkend="_wordtohex">WordToString</link>, <link linkend="_longtohex">LongToString</link>, <link linkend="_singletohex">SingleToString</link>, <link linkend="_bytetohex">ByteToHex</link></simpara>
</section>
<section xml:id="_stringtobyte">
<title>StringToByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    var = StringToByte(<emphasis>string</emphasis>)   'Supports decimal byte range strings only.</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>StringToByte</literal> function will extract a number from a string variable, and store it in a byte variable. One potential use is reading numbers that are sent in ASCII format over a serial connection.
<?asciidoc-br?>
<?asciidoc-br?>
The <literal>StringToByte</literal> function will not extract a StringToByte from a hexadecimal string.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example1:</emphasis></simpara>
<screen>    ' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #Config MCLRE_ON

    ; ----- Define Hardware settings

    '' -------------------LATA-----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' LED:   ---------------|D5 |D4 |D3 |D2 |-
    ''-----------------------------------------
    ''

    'Set the PPS of the RS232 ports.
    UNLOCKPPS
      RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
      RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
    LOCKPPS

    ; ----- Constants
    #define USART_BAUD_RATE 19200
    #define USART_TX_BLOCKING

    #define LEDD2 PORTA.0
    #define LEDD3 PORTA.1
    #define LEDD4 PORTA.2
    #define LEDD5 PORTA.3
    Dir     LEDD2 OUT
    Dir     LEDD3 OUT
    Dir     LEDD4 OUT
    Dir     LEDD5 OUT


    #define Potentiometer       PORTA.4
    DIR     Potentiometer In

    #define SWITCH_DOWN         0
    #define SWITCH_UP           1
    #define SWITCH              PORTA.5
    Dir SWITCH                  In

    ; ----- Variables
    dim bytevar as Byte
    dim wordvar as Word
    dim longvar as long

    bytevar = 0
    wordvar = 0
    longvar = 0



    ; ----- Main body of program commences here.

     #option Explicit

     do
         wait 100 ms

         bytevar = StringToByte( "255" )
         HSerPrint bytevar
         HSerPrintCRLF

         wait 1 s
      loop
    end

  ; ----- Support methods.  Subroutines and Functions</screen>
</section>
<section xml:id="_stringtolong">
<title>StringToLong</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    var = StringToLong(<emphasis>string</emphasis>)   'Supports decimal Long range strings only.</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>StringToLong</literal> function will extract a number from a string variable, and store it in a Long variable. One potential use is reading numbers that are sent in ASCII format over a serial connection.
<?asciidoc-br?>
<?asciidoc-br?>
The <literal>StringToLong</literal> function will not extract a StringToLong from a hexadecimal string.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example1:</emphasis></simpara>
<screen>    ' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #Config MCLRE_ON

    ; ----- Define Hardware settings

    '' -------------------LATA-----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' LED:   ---------------|D5 |D4 |D3 |D2 |-
    ''-----------------------------------------
    ''

    'Set the PPS of the RS232 ports.
    UNLOCKPPS
      RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
      RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
    LOCKPPS

    ; ----- Constants
    #define USART_BAUD_RATE 19200
    #define USART_TX_BLOCKING

    #define LEDD2 PORTA.0
    #define LEDD3 PORTA.1
    #define LEDD4 PORTA.2
    #define LEDD5 PORTA.3
    Dir     LEDD2 OUT
    Dir     LEDD3 OUT
    Dir     LEDD4 OUT
    Dir     LEDD5 OUT


    #define Potentiometer       PORTA.4
    DIR     Potentiometer In

    #define SWITCH_DOWN         0
    #define SWITCH_UP           1
    #define SWITCH              PORTA.5
    Dir SWITCH                  In

    ; ----- Variables
    dim bytevar as Byte
    dim wordvar as Word
    dim longvar as long

    bytevar = 0
    wordvar = 0
    longvar = 0



    ; ----- Main body of program commences here.

     #option Explicit

     do
         wait 100 ms

         Longvar = StringToLong( "255" )
         HSerPrint Longvar
         HSerPrintCRLF

         wait 1 s
      loop
    end

  ; ----- Support methods.  Subroutines and Functions</screen>
</section>
<section xml:id="_stringtosingle">
<title>StringToSingle</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    var = StringToSingle(<emphasis>string</emphasis>)   'Supports decimal Single range strings only.</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>StringToSingle</literal> function will extract a number from a string variable, and store it in a Single variable.&#160;&#160;One potential use is formatting a serial number recieve via a serial connection.
<?asciidoc-br?>
<?asciidoc-br?>
The <literal>StringToSingle</literal> function will not extract a StringToSingle from a hexadecimal string.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The function supports two messages to support usage.</simpara>
<literallayout class="monospaced">'   SysByte_STS_Err = 0 if no error
'   SysByte_STS_Err.0 = 1 good - 0 - bad
'   SysByte_STS_Err.1 = 1 decimals places to many chars,  0 = ok
'   SysByte_STS_Err.2 = 1 integer places to many chars-out of range,   0 = ok
'   SysByte_STS_Err.3 = 1 no decimal point, info only
'   SysByte_STS_Err.4 = non numeric chars found</literallayout>
<simpara><emphasis role="strong">Example Usage 1:</emphasis></simpara>
<screen>    ' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #Config MCLRE_ON

    'Set the PPS of the RS232 ports.
    UNLOCKPPS
      RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
      RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
    LOCKPPS

    ; ----- Constants
    #define USART_BAUD_RATE 19200
    #define USART_TX_BLOCKING

    ; ----- Variables
    dim bytevar as Byte
    dim wordvar as Word
    dim Singlevar as Single

    bytevar = 0
    wordvar = 0
    Singlevar = 0



    ; ----- Main body of program commences here.

     #option Explicit

     do
         wait 100 ms

         Singlevar = StringToSingle( "255" )
         HSerPrint SingltoString(Singlevar)
         HSerPrintCRLF

         wait 1 s
      loop
    end

  ; ----- Support methods.  Subroutines and Functions</screen>
</section>
<section xml:id="_stringtoword">
<title>StringToWord</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    var = StringToWord(<emphasis>string</emphasis>)   'Supports decimal Word range strings only.</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>StringToWord</literal> function will extract a number from a string variable, and store it in a Word variable. One potential use is reading numbers that are sent in ASCII format over a serial connection.
<?asciidoc-br?>
<?asciidoc-br?>
The <literal>StringToWord</literal> function will not extract a StringToWord from a hexadecimal string.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example1:</emphasis></simpara>
<screen>    ' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #Config MCLRE_ON

    ; ----- Define Hardware settings

    '' -------------------LATA-----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' LED:   ---------------|D5 |D4 |D3 |D2 |-
    ''-----------------------------------------
    ''

    'Set the PPS of the RS232 ports.
    UNLOCKPPS
      RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
      RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
    LOCKPPS

    ; ----- Constants
    #define USART_BAUD_RATE 19200
    #define USART_TX_BLOCKING

    #define LEDD2 PORTA.0
    #define LEDD3 PORTA.1
    #define LEDD4 PORTA.2
    #define LEDD5 PORTA.3
    Dir     LEDD2 OUT
    Dir     LEDD3 OUT
    Dir     LEDD4 OUT
    Dir     LEDD5 OUT


    #define Potentiometer       PORTA.4
    DIR     Potentiometer In

    #define SWITCH_DOWN         0
    #define SWITCH_UP           1
    #define SWITCH              PORTA.5
    Dir SWITCH                  In

    ; ----- Variables
    dim bytevar as Byte
    dim wordvar as Word
    dim longvar as long

    bytevar = 0
    wordvar = 0
    longvar = 0



    ; ----- Main body of program commences here.

     #option Explicit

     do
         wait 100 ms

         Wordvar = StringToWord( "65535" )
         HSerPrint WordVar
         HSerPrintCRLF

         wait 1 s
      loop
    end

  ; ----- Support methods.  Subroutines and Functions</screen>
</section>
<section xml:id="_ulonginttobin">
<title>ULongIntToBin</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = ULongIntToBin(<emphasis>ULongIntvar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>ULongIntToBin</literal> function creates a string of a ANSI (32) characters.
The function converts a number to a string consisting of ones and zeros that represents the binary value.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
Supports ULongInt variables only.  For BYTE variables use <literal>VarToBin</literal>, for WORD variables use <literal>VarWToBinand</literal> for INTEGER variables use <literal>VarIntegerToBin</literal></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    string = ULongIntToBin( 1 )   ' Returns "00000000000000000000000000000001"

    string = ULongIntToBin( 254 ) ' Returns "00000000000000000000000011111110"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_vartobin">ByteToBin</link>, <link linkend="_varWtobin">WordToBin</link>, <link linkend="_varintegertobin">IntegerToBin</link></simpara>
</section>
<section xml:id="_wordtobin">
<title>WordToBin</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <emphasis>stringvar</emphasis> = WordToBin(<emphasis>bytevar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis>
Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>WordToBin</literal> function creates a string of a ANSI (8-byte) characters.
The function converts a number to a string consisting of ones and zeros that represents the binary value.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    <emphasis>string</emphasis> = WordToBin(1)       ' Returns "0000000000000001"

    <emphasis>string</emphasis> = WordToBin(37654)   ' Returns "1001001100010110"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_bytetobin">ByteToBin</link></simpara>
</section>
<section xml:id="_wordtohex">
<title>WordToHex</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = WordToHex(<emphasis>number</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Hex</literal> function will convert a Word number into hexadecimal format. The input <literal><emphasis>number</emphasis></literal> should be a Word variable, or a fixed number between 0 and 65525 inclusive. After running the function, the string variable <literal><emphasis>stringvar</emphasis></literal> will contain a 4 digit hexadecimal number.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Send EEPROM data over serial connection
    'Uses Hex to display as hexadecimal
    For CurrentLocation = 0 to 65535
        'Send location
        HSerPrint WordToHex(CurrentLocation)
        HSerPrint ":"
        'Read Word and send
        EPRead CurrentLocation, CurrWord
        HSerPrint Hex(CurrWord)
        'Send carriage return/line feed
        HSerPrintCRLF
    Next</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_bytetohex">ByteToHex</link>,<link linkend="_longtohex_">LongToHex</link>, <link linkend="_integertohex">IntegerToHex</link>, <link linkend="_singletohex">SingleToHex</link></simpara>
</section>
<section xml:id="_wordtostring">
<title>WordToString</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = WordToString(<emphasis>Word_variable</emphasis>)     'supports Word.</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>WordToString</literal> function will convert a number into a string. <literal><emphasis>number</emphasis></literal> can be any Word variable, or a fixed number constant between 0 and 65535 inclusive.&#160;&#160;For Word number use <literal>WordToString()</literal>, Long numbers use <literal>LongToString()</literal>, for Integer numbers use <literal>IntegerToString()</literal> and for Single numbers use <literal>SingleToString()</literal></simpara>
<simpara>The string variable <literal><emphasis>stringvar</emphasis></literal> will contain the same number, represented as a string.&#160;&#160;The length of the string returned is 5 characters.</simpara>
<simpara>This function is especially useful if a number needs to added to the end of a string, or if a custom data sending routine has been created but only supports the output of string variables.
<?asciidoc-br?>
<?asciidoc-br?>
These methods will not support  conversion of hexadecimal number strings.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example1:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    Dim SensorReading as Word

    'Take an A/D reading
    SensorReading = ReadAD10(AN0)

    'Create a string variable
    Dim OutVar As String

    'Fill string with sensor reading
    OutVar = WordToString(SensorReading)

    'Send
    HSerPrint OutVar
    HSerPrintCRLF

    When using the functions WordToString() do not leave space between the function
    call and the left brace. You will get a compiler error that is
    meaningless.

    ' use this, note this is no space between the WordToString() and the left brace!
    WordToString(number_variable)
    ' do not use, note the space!
    WordToString (number_variable)</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example2:</emphasis></simpara>
<screen>    '''
    '''
    '''
    '''
    '''************************************************************************
    '''
    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCode
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: June 2021
    '''
    ' ----- Configuration
      'Chip Settings.
      #chip 16f18855,32
      #Config CLRE_ON
      #option Explicit

    ; ----- Define Hardware settings

      'Set the PPS of the RS232 ports.
      UNLOCKPPS
        RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
      LOCKPPS

    ; ----- Constants
      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

    ; ----- Variables
    dim Wordvar as Word

    ; ----- Main body of program commences here.
    Wordvar = 0xffff

    do
       wait 100 ms

       HSerPrint WordToString( Wordvar )
       HSerPrintCRLF
       wait 1 s
    loop
    end

; ----- Support methods.  Subroutines and Functions</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">See Also</emphasis> <link linkend="_bytetohex">ByteToString</link>, <link linkend="_longtohex">LongToString</link>, <link linkend="_integertohex">IntegerToString</link>, <link linkend="_singletohex">SingleToString</link>, <link linkend="_bytetohex">ByteToHex</link></simpara>
</section>
<section xml:id="_concatenation">
<title>Concatenation</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = variable1 + variable2</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The method joins two variables into another variable.</simpara>
<simpara>This method does not change the existing strings, but returns a <emphasis role="strong">new</emphasis> string containing the text of the joined variables, see Concatenated String Constraint below.</simpara>
<simpara>Concatenation joins the elements of a specified values using the specified separator between each variable.</simpara>
<warning>
<simpara>Using concatenation as a parameter with commands like HSerPrint or Print the compiler will create a system string variable.&#160;&#160;  An examples of concatenating two strings constants like HSerPrint ("123"+"456") may yield incorrect results.&#160;&#160;Use the constant SYSDEFAULTCONCATSTRING to resolve.&#160;&#160;Without using SYSDEFAULTCONCATSTRING there is a risk that the compiler does not allocate sufficient RAM to hold the concatenated string.&#160;&#160;
The resulting string may be corrupted as the size of the system string variable is not sufficient.&#160;&#160;Use SYSDEFAULTCONCATSTRING within the source program to resolve.</simpara>
</warning>
<simpara><emphasis role="strong">Set a specific size of compiler created system string variable</emphasis></simpara>
<simpara>Use the following to set the size of the system string variable used during concatenation.&#160;&#160;</simpara>
<simpara>The compiler will create system string variables when you concatenate on a commands line like <literal>HSerPrint</literal>, <literal>Print</literal> and many others commands.&#160;&#160;
Using concatenate with a command is bad practice, using a lot of RAM and may create a number of system string variables.&#160;&#160;
It is recommended to define a string (of a known length), concatenate using an assignment then use the string.&#160;&#160;</simpara>
<simpara>To control the size of system string variable use the following.&#160;&#160;
Also, use this constant to set the size when the compiler does not create a system string variable.&#160;&#160;</simpara>
<screen>    'Define the constant to control the size of system created string variables called SYSSTRINGPARAM1, SYSSTRINGPARAM2 etc.
    Use #DEFINE  SYSDEFAULTCONCATSTRING  4

    'Then, use
    HSerPrint "A"+"123"   'will print A123. Without the SYSDEFAULTCONCATSTRING constant some microcontrollers may corrupt the result of the concatenation.</screen>
<simpara>This concatenation constraint does not apply using concatenation as an assignment.&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    timevariable = 999
    <emphasis>stringvar</emphasis> = "Time = " + str(timevariable) ' Convert the <emphasis>timevariable</emphasis> to a String.  This operation returns <emphasis role="strong">Time = 999</emphasis></screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<simpara>An example showing how to set a string to an escape sequence for an ANSI terminal.&#160;&#160;You can `Dim`ension a string and then assign the elements like an array.
{empty} +
{empty} +</simpara>
<screen>    dim line2 as string
    line2 =  27, "[", "2", "H", 27, "[","K"
    HSerPrint line2</screen>
<simpara>Will send the following to the terminal.
&lt;esc&gt;[2H&lt;esc&gt;[K
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 3: Assigning concatenated string to same string</emphasis></simpara>
<simpara>For reliable coding you must not assign a string concatenation to same source variable.&#160;&#160;You must assign the result of string concatenation to another string. &#160;&#160;To resolve see below:</simpara>
<screen>    Dim outstring, tmpstring as string * 16
    Dim outnumber as byte

    outnumber = 24
    outstring = "Result = "
    'This concatenation may yield an incorrect string on 10f, 12f or 16f chips
    outstring = outstring + str(outnumber)
    HserPrintCRLF 2
    HSerPrint outstring
    HserPrintCRLF 2

    outstring = "Result = "
    'This concatenation will yield an the correct string. With tmpstring1 containing the correct concatenated string
    tmpstring = outstring +str(outnumber)
    HSerPrint tmpstring
    HserPrintCRLF 2
    end</screen>
<simpara><?asciidoc-br?>
To resolve the constraint simply assign the source string to another string.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_deprecated_string_functions">
<title>Deprecated string functions.</title>
<simpara>Use the alternative updated functions.</simpara>
<section xml:id="_hex">
<title>Hex</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = Hex(<emphasis>number</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Hex</literal> function will convert a number into hexadecimal format. The input <literal><emphasis>number</emphasis></literal> should be a byte variable, or a fixed number between 0 and 255 inclusive. After running the function, the string variable <literal><emphasis>stringvar</emphasis></literal> will contain a 2 digit hexadecimal number.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Send EEPROM data over serial connection
    'Uses Hex to display as hexadecimal
    For CurrentLocation = 0 to 255
        'Send location
        HSerPrint Hex(CurrentLocation)
        HSerPrint ":"
        'Read byte and send
        EPRead CurrentLocation, CurrByte
        HSerPrint Hex(CurrByte)
        'Send carriage return/line feed
        HSerPrintCRLF
    Next</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_str">Str</link>, <link linkend="_val">Val</link></simpara>
</section>
<section xml:id="_str">
<title>Str</title>
<simpara><emphasis role="strong">Syntax: Deprecated use ByteToString()</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = Str(<emphasis>number</emphasis>)     'supports decimal byte and word strings only.

    'Use the following to support decimal long number strings.
    <emphasis>stringvar</emphasis> = Str32(<emphasis>long number</emphasis>)     'supports  decimal long number strings.

    'Use the following to support decimal integer number strings.
    <emphasis>stringvar</emphasis> = StrInteger(<emphasis>integer number</emphasis>)     ' decimal integer number strings.</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Str</literal> function will convert a number into a string. <literal><emphasis>number</emphasis></literal> can be any byte or word variable, or a fixed number between 0 and 65535 inclusive.&#160;&#160;For Long numbers use <literal>Str32</literal> and for Integer numbers use <literal>StrInteger</literal>.</simpara>
<simpara>The string variable <literal><emphasis>stringvar</emphasis></literal> will contain the same number, represented as a string.&#160;&#160;The length of the string returned is 5, 10 or 6 characters for Byte &amp; Word, Long and Integer respectively.</simpara>
<simpara>This function is especially useful if a number needs to added to the end of a string, or if a custom data sending routine has been created but only supports the output of string variables.
<?asciidoc-br?>
<?asciidoc-br?>
These methods will not support  conversion of hexadecimal number strings.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example1:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Take an A/D reading
    SensorReading = ReadAD(AN0)

    'Create a string variable
    Dim OutVar As String

    'Fill string with sensor reading
    OutVar = Str(SensorReading)

    'Send
    HSerPrint OutVar
    HSerPrintCRLF

    When using the functions STR() do not leave space between the function
    call and the left brace. You will get a compiler error that is
    meaningless.

    ' use this, note this is no space between the STR and the left brace!
    STR(number_variable)
    ' do not use, note the space!
    STR (number_variable)</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example2:</emphasis></simpara>
<screen>    '''
    '''
    '''
    '''
    '''************************************************************************
    '''
    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCode
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: June 2021
    '''
    ' ----- Configuration
      'Chip Settings.
      #chip 16f18855,32
      #Config CLRE_ON
      #option Explicit

    ; ----- Define Hardware settings

      '' -------------------LATA-----------------
      '' Bit#:  -7---6---5---4---3---2---1---0---
      '' LED:   ---------------|D5 |D4 |D3 |D2 |-
      ''-----------------------------------------
      ''

      'Set the PPS of the RS232 ports.
      UNLOCKPPS
        RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
      LOCKPPS

    ; ----- Constants
      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

      #define LEDD2 PORTA.0
      #define LEDD3 PORTA.1
      #define LEDD4 PORTA.2
      #define LEDD5 PORTA.3
      Dir     LEDD2 OUT
      Dir     LEDD3 OUT
      Dir     LEDD4 OUT
      Dir     LEDD5 OUT


      #define Potentiometer       PORTA.4
      DIR     Potentiometer In

      #define SWITCH_DOWN         0
      #define SWITCH_UP           1
      #define SWITCH              PORTA.5
      Dir SWITCH                  In

    ; ----- Variables
    dim bytevar as Byte
    dim wordvar as Word
    dim longvar as long
    dim integervarP, integervarN,integervar as Integer

    ; ----- Main body of program commences here.
    bytevar = 0xff
    wordvar = 0xffff
    longvar = 0xffffffff
    integervarP = 127
    integervarN = -127
    integervar = 0

    do
       wait 100 ms

       HSerPrint str( bytevar )
       HSerPrintCRLF
       HSerPrint str( wordvar )
       HSerPrintCRLF
       HSerPrint str32( longvar )
       HSerPrintCRLF
       HSerPrint StrInteger( integervarP )
       HSerPrintCRLF
       HSerPrint StrInteger( integervarN )
       HSerPrintCRLF
       HSerPrint StrInteger( integervar )
       HSerPrintCRLF
       wait 100 ms
       HSerPrintCRLF

       wait 1 s
    loop
    end

; ----- Support methods.  Subroutines and Functions</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">See Also</emphasis> <link linkend="_hex">Hex</link>, <link linkend="_val">Val</link></simpara>
</section>
<section xml:id="_val">
<title>Val</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    var = Val(<emphasis>string</emphasis>)   'Supports decimal byte and word strings only.

    'use the following for strings that represent Long numbers
    var = Val32(<emphasis>string</emphasis>)   'Supports decimal long number strings only.</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Val</literal> function will extract a number from a string variable, and store it in a word variable. One potential use is reading numbers that are sent in ASCII format over a serial connection.
<?asciidoc-br?>
<?asciidoc-br?>
The <literal>Val32</literal> function will extract a long number from a string variable, and store it in a long variable.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The <literal>Val</literal> function will not extract a value from a hexadecimal string.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example1:</emphasis></simpara>
<screen>    'Program for an RS232 controlled dimmer
    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Set pin directions for USART and PWM

    'Variable for output level
    Dim OutputLevel As Word

    'Variables for received bytes
    Dim DataIn As String
    DataInCount = 0

    'Main Loop
    Do
        'Get serial byte
        Wait Until USARTHasData
        HSerReceive InByte

        'Process latest byte
        'Enter key?
        If InByte = 13 Then
            'Convert output level to numeric variable
            OutputLevel = Val(DataIn)

            'Output
            HPWM 1, 32, OutputLevel

            'Clear output buffer for next command
            DataIn = ""
            DataInCount = 0
        End If

        'Number?
        If InByte &gt;= 48 and InByte &lt;= 57 Then
            'Add to end of DataIn string
            DataInCount += 1
            DataIn(DataInCount) = InByte
            DataIn(0) = DataInCount
        End If
    Loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example2:</emphasis></simpara>
<screen>    ' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #Config MCLRE_ON

    ; ----- Define Hardware settings

    '' -------------------LATA-----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' LED:   ---------------|D5 |D4 |D3 |D2 |-
    ''-----------------------------------------
    ''

    'Set the PPS of the RS232 ports.
    UNLOCKPPS
      RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
      RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
    LOCKPPS

    ; ----- Constants
    #define USART_BAUD_RATE 19200
    #define USART_TX_BLOCKING

    #define LEDD2 PORTA.0
    #define LEDD3 PORTA.1
    #define LEDD4 PORTA.2
    #define LEDD5 PORTA.3
    Dir     LEDD2 OUT
    Dir     LEDD3 OUT
    Dir     LEDD4 OUT
    Dir     LEDD5 OUT


    #define Potentiometer       PORTA.4
    DIR     Potentiometer In

    #define SWITCH_DOWN         0
    #define SWITCH_UP           1
    #define SWITCH              PORTA.5
    Dir SWITCH                  In

    ; ----- Variables
    dim bytevar as Byte
    dim wordvar as Word
    dim longvar as long

    bytevar = 0
    wordvar = 0
    longvar = 0



    ; ----- Main body of program commences here.

     #option Explicit

     do
         wait 100 ms

         bytevar = Val( "255" )
         HSerPrint bytevar
         HSerPrintCRLF

         wordvar = Val( "65535" )
         HSerPrint wordvar
         HSerPrintCRLF

         longvar = Val32( "65536" )
         HSerPrint longvar
         HSerPrintCRLF 2

         wait 1 s
      loop
    end

  ; ----- Support methods.  Subroutines and Functions</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_hex">Hex</link>, <link linkend="_str">Str</link></simpara>
</section>
</section>
</section>
<section xml:id="_miscellaneous_commands">
<title>Miscellaneous Commands</title>
<simpara>This is the Miscellaneous Commands section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_dir">
<title>Dir</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Dir <emphasis>port.bit</emphasis> {In | Out}               <emphasis role="strong"><emphasis>(Individual Form)</emphasis></emphasis>
    Dir <emphasis>port</emphasis> {In | Out | <emphasis>DirectionByte</emphasis>}  <emphasis role="strong"><emphasis>(Entire Port Form)</emphasis></emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Dir</literal> command is used to set the direction of the ports of the microcontroller chip. The individual form sets the direction of one pin at a time, whereas the entire port form will set all bits in a port.</simpara>
<simpara>In the individual form, specify the port and bit (ie. <literal>PORTB.4</literal>), then the direction, which is either In or Out.</simpara>
<simpara>The entire port form is similiar to the <literal>TRIS</literal> instruction offered by some Microchip PIC microcontrollers. To use it, give the name of the port (<emphasis>i.e.</emphasis> <literal>PORTA</literal>), and then a byte is to be written into the <literal>TRIS</literal> variable. This form of the command is for those who are familiar with the Microchip PIC microcontrollers internal architecture.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
Entire port form will work differently on Atmel AVR microcontrollers when a value other than IN or OUT is used. Atmel AVR microcontrollers use 0 to indicate in and 1 to indicate out, whereas Microchip PIC microcontrollers use 0 for out and 1 for in. When IN and OUT are used there are no compatibility issues.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program sets PORTA bits 0 and 1 to in, and the rest to out.
    'It also sets all of PORTB to output, except for B1.
    'Individual form is used for PORTA:
    DIR PORTA.0 IN
    DIR PORTA.1 IN
    DIR PORTA.2 OUT
    DIR PORTA.3 OUT
    DIR PORTA.4 OUT
    DIR PORTA.5 OUT
    DIR PORTA.6 OUT
    DIR PORTA.7 OUT
    'Entire port form used for B:
    DIR PORTB b'00000010'

    'Entire port form used for C:
    DIR PORTC IN</screen>
<simpara><emphasis role="strong">Automatic DIRection setting by the compiler</emphasis></simpara>
<simpara>The compiler will set the automatic pin DIRection using the following logic.</simpara>
<simpara>Any time that the user program reads a pin or port, the compiler records that.   Any time that the user program writes to a pin or entire port, the compiler also records that.</simpara>
<simpara>Once all input code has been compiled, the compiler examinies the list of reads and writes.</simpara>
<simpara>If a pin is only ever written to, the compiler makes it an output.</simpara>
<simpara>If a pin is only ever read, the compiler does not know if the intent is to read the latch or an input value, so it sets that pin to be an input.</simpara>
<simpara>If the compiler sees a pin being read and written to, the compiler does not know if you are using a pin for some sort of bidirectional communication, or if you are just reading the latch. To avoid making incorrect assumptions, the compiler will expect you to set the pin direction manually.</simpara>
<simpara>If you use "portA.2 = 1", you&#8217;ve only written to the pin, so the compiler knows it must be an output.</simpara>
<simpara>If you use "portA.2 = not portA.2", the compiler sees that you are reading and writing to the pin, and will expect the user program set the direction instead of trying to guess what you are doing.</simpara>
<simpara>The compiler also records any use of the Dir command, and will not do any automatic direction setting on a pin if Dir has been used on that pin anywhere in the user program..</simpara>
</section>
<section xml:id="_getuserid">
<title>GetUserID</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip microcontrollers that support UserIDs.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Reads the memory location and returns the ID for a specific microcontroller.</simpara>
<simpara>If the microcontroller does not support GetUSerID then the following message will be issued during compilation <literal>Warning: GetUserID not supported by this microcontroller</literal>.</simpara>
<simpara>The method reads the memory location 0x8000 + Index and returns it as a Word value, where the Index 0x00 to 0x0B as follows:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Address</entry>
<entry align="left" valign="top">Function</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>8000h-8003h</simpara></entry>
<entry align="left" valign="top"><simpara>User IDs</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8006h/8005h</simpara></entry>
<entry align="left" valign="top"><simpara>Device ID/Revision ID</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8007h-800Bh</simpara></entry>
<entry align="left" valign="top"><simpara>Configuration Words 1 through 5</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Refer to your particular Device Datasheet to confirm the address table</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>      #chip 16F1455
      #Config MCLRE_ON

      #include &lt;GetUserID.h&gt;

      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

      'Implement ANSI escaope code for serial terminal NOT using a LCD!
      #define ESC   chr(27)
      #define CLS   HSerPrint(ESC+"[2J")
      #define HOME  HSerPrint(ESC+"[H")
      #define Print HSerPrint

      CLS
      HOME

      dim UserIDRegister as word

      For Index = 0 to 0xF
        UserIDRegister  = GetUserID(Index)
        HserPrint "80" + hex(NVIndex)
        HserPrint " : "
        HserPrint hex( UserIDRegister_H )
        HserPrint hex( UserIDRegister    )
      Next Index

    End</screen>
</section>
<section xml:id="_pot">
<title>Pot</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Pot <emphasis>pin, output</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>Pot</literal> makes it possible to measure an analog resistance with a digital port, with the addition of a small capacitor. This is the required circuit:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/potb1.JPG"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</inlinemediaobject></simpara>
<simpara>The command works by using the microcontroller pin to discharge the capacitor, then measuring the time taken for the capacitor to charge again through the resistor.</simpara>
<simpara>The value for the capacitor must be adjusted depending on the size of the variable resistor. The charging time needs to be approximately 2.5 ms when the resistor is at its maximum value. For a typical 50 k potentiometer or LDR, a 50 nf capacitor is required.</simpara>
<simpara>This command should be used carefully. Each time it is inserted, 20 words of program memory are used on the chip, which as a rough guide is more than 15 times the size of the Set command.</simpara>
<simpara><literal><emphasis>pin</emphasis></literal> is the port connected to the circuit. The direction of the pin will be dealt with by the <literal>Pot</literal> command.</simpara>
<simpara><literal><emphasis>output</emphasis></literal> is the name of the variable that will receive the value.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This program will beep whenever a shadow is detected
    'A potentiometer is used to adjust the threshold

    #chip 16F628A, 4

    #define ADJUST PORTB.0
    #define LDR PORTB.1
    #define SoundOut PORTB.2

    Dir SoundOut Out

    Do
        Pot ADJUST, Threshold
        Pot LDR, LightLevel
        If LightLevel &gt; Threshold Then
            Tone 1000, 100
        End If
    Loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<simpara>This program is an implementation of the capacitor and resistor principle using the chips internal capacitor and the internal pullup resistor.</simpara>
<simpara>The will test the state of the GPIO.3 port by using these internal components, and, after the charge state has been complete the LED PWM will represent the detected value of signal on the GPIO.3 port.</simpara>
<simpara>It should be note that GCBASIC will set the DIRection of GPIO.2 and GPIO.3 automatically.  And, this solution is specific to the 12F509 and therefore the 12F509 register called <literal>NOT_GPPU</literal> may be different on another chip.</simpara>
<screen>    #chip 12F509
    #option Explicit

      ;Defines (Constants)
      #define PWM_Out1 GPIO.2

      ;Variables
      Dim TimeCount As byte
      Dim OPTION_REG as byte

      Do Forever

          NOT_GPPU = Off
          Wait 1 ms
          NOT_GPPU = On
          TimeCount = 0

          'Do while held high by the internal capacitance
          Do While GPIO.3 = 1

            TimeCount = TimeCount + 1
            If TimeCount = 255 Then
                Exit Do
            End If

          Loop

          PWMout 1, TimeCount, 5

      Loop</screen>
<simpara><emphasis role="strong">See also</emphasis>  <link xlink:href="http://ladyada.net/library/rccalc.html">ladyada.net/library/rccalc.html</link> or <link xlink:href="http://web.archive.org/web/20100818230450/http://www.cvs1.uklinux.net/cgi-bin/calculators/time_const.cgi">cvs1.uklinux.net/cgi-bin/calculators/time_const.cgi</link>
for calculating capacitor value. These sites are not associated with GCBASIC.</simpara>
</section>
<section xml:id="_pulseout">
<title>PulseOut</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PulseOut <emphasis>pin</emphasis>, <emphasis>time units</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>PulseOut</literal> command will set the specified pin high, wait for the specified amount of time, and then set the pin low again. The pin is specified in the same way as it is for the Set command, and the time is the same as for the <literal>Wait</literal> command.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program flashes an LED on GPIO.0 using PulseOut
    #chip 12F629, 4

    'The DIRection of the port is set to show the command.  It is not required to set the DIRection when using the PulseOut command.
    Dir GPIO.0 Out
    Do
        PulseOut GPIO.0, 1 sec 'Turn LED on for 1 sec
        Wait 1 sec             'Wait 1 sec with LED off
    Loop</screen>
</section>
<section xml:id="_pulseoutinv">
<title>PulseOutInv</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PulseOutInv <emphasis>pin,</emphasis> <emphasis>time units</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>PulseOutInv</literal> command will set the specified pin low, wait for the specified amount of time, and then set the pin high. The pin is specified in the same way as it is for the <literal>Set</literal> command, and the time is the same as for the <literal>Wait</literal> command.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program flashes an LED on GPIO.0 using PulseOutInv
    #chip 12F629, 4

    Dir GPIO.0 Out
    Do
        PulseOutInv GPIO.0, 1 sec     'Turn LED off for 1 sec
        Wait 1 sec                    'Wait 1 sec with LED on
    Loop</screen>
</section>
<section xml:id="_pulsein">
<title>PulseIn</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PulseIn <emphasis>pin</emphasis>, <emphasis>user_variable</emphasis>, <emphasis>time units</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>PulseIn</literal> command will monitor the specified pin when the pin is high, and then measure the high time. It will store the time in the user variable.
The user variable must be a WORD if returned units are expected to be &gt; 255  (Example: Pulse is 500 ms)</simpara>
<simpara>PulseIn is not recommended for accurate measurement of microsecond pulses</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 12F629, 4

    Dir GPIO.0 In
    Dim TimeResult as WORD

    Do while GPIO.0 = Off        'Wait for next positive edge to start measuring
    Loop

    Pulsein GPIO.0, TimeResult, ms</screen>
</section>
<section xml:id="_pulseininv">
<title>PulseInInv</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PulseInInv <emphasis>pin</emphasis>, <emphasis>user_variable</emphasis>, <emphasis>time units</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>PulseIn</literal> command will monitor the specified pin when the pin is low, and then measure the low time. It will store the time in the user variable.
The user variable must be a WORD if returned units are expected to be &gt; 255  (Example: Pulse is 500 ms)</simpara>
<simpara>PulseInInv is not recommended for accurate measurement of microsecond pulses.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 12F629, 4

    Dir GPIO.0 In
    Dim TimeResult as WORD

    Do while GPIO.0 = On        'Wait for next negative edge to start measuring
    Loop

    PulseinInv GPIO.0, TimeResult, ms</screen>
</section>
<section xml:id="_peek">
<title>Peek</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>OutputVariable</emphasis> = Peek (<emphasis>location</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Peek</literal> function is used to read information from the on-chip RAM of the microcontroller.</simpara>
<simpara><literal><emphasis>location</emphasis></literal> is a word variable that gives the address to read. The exact range of valid values varies from chip to chip.</simpara>
<simpara>This command should not normally be used, as it will make the porting of code to another chip very difficult.</simpara>
<simpara><emphasis role="strong">Example #1 :</emphasis></simpara>
<screen>    'This program will read and check a value from PORTA
    'This specific peek will only work on some microcontrollers
    Temp = Peek(5)
    IF Temp.2 ON THEN SET green ON
IF Temp.2 OFF THEN SET red ON</screen>
<simpara><emphasis role="strong">Example #2</emphasis></simpara>
<screen>    ' This subroutine will toggle the pin state.
    ' You must change the parameters for your specific chip.
    ' Usage as show in examples below.
    '
    '      Toggle @PORTE, 2 ' equates to RE1.
    '      Wait 100  ms
    '      Toggle @PORTE, 2
    '      Wait 100 ms


    ' Port , Pin address in Binary
    ' Pin0 = 1
    ' Pin1 = 2
    ' Pin2 = 4
    ' Pin3 = 8
    '
    ' You can toggle any number of pins.
    ' Toggle @PORTE, 0x55
    Sub Toggle ( In DestPort As word, In DestBit )
          Poke DestPort, Peek(DestPort) xor DestBit
    End sub</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_poke">Poke</link></simpara>
</section>
<section xml:id="_poke">
<title>Poke</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Poke(<emphasis>location</emphasis>, <emphasis>value</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Poke</literal> command is used to write information to the on-chip RAM of the microcontroller.</simpara>
<simpara><literal><emphasis>location</emphasis></literal> is a word variable that gives the address to write. The exact range of valid values varies from chip to chip.
<literal><emphasis>value</emphasis></literal> is the data to write to the location.</simpara>
<simpara>This command should not normally be used, as it will make the porting of code to another chip very difficult.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This program will set all of the PORTB pins high
    POKE (6, 255)</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F88

    Dir PORTB out

    Do Forever
        FlashPin @PORTB, 8
        Wait 1 s
    Loop

    Sub FlashPin (In DestVar As word, In DestBit)
        Poke DestVar, Peek(DestVar) Or DestBit
        Wait 1 s
        Poke DestVar, Peek(DestVar) And Not DestBit
    End Sub</screen>
<simpara>Using @ before the name of a variable (including a special function register) will give you the address of that variable, which can then be stored in a word variable and used by <literal>Peek</literal> and <literal>Poke</literal> to indirectly access the location.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_peek">Peek</link></simpara>
</section>
<section xml:id="_weak_pullups">
<title>Weak Pullups</title>
<simpara><literal>Weak pullups</literal> provide a method within many microcontrollers such as the Atmel AVR and Microchip PIC microcontrollers to support internal/selectable pull-ups for convenience and reduced parts count.</simpara>
<simpara>If you require <literal>Weak pullups</literal> these internal pullups can provide a simple solution. For example, you can use them to ground input pins with a switch closure - with the pullup enabled, the pin is held in a high state until the input line pulls it to ground. Be aware of possible EMI interference and also make sure to use a debounce routine.</simpara>
<simpara>If you need your weak pullups to exactly control current (rare for most microcontroller applications), then you should consider 10k resistors (5V/10K = 500uA)  Why? If you review in the microcontroller data sheet, there is no resistance given for the weak pullups. That is because they are not weak pull-resistors they are weak pullups consisting of what appear to be high-resistance channel pFETs.  Their channel resistance will vary with temperature and between parts; not easy to characterize.</simpara>
<simpara>The data sheet gives a current range for the internals as 50-400uA (at 5V).</simpara>
<simpara>PORTs can have an individually controlled weak internal pullup. When set, each bit of the appropriate Microchip PIC register enables the corresponding pin pullup. There is a master bit within a specific register bit that enables pullups on all pins which also have their corresponding weak pull bit set.   Also when set, there is a weak pull register bit to disable all weak pullups.</simpara>
<simpara>The weak pullup is automatically turned off when the port pin is configured as an output.  The pullups are disabled on a Power-on Reset.</simpara>
<simpara>Each specific microcontroller has different registers/bits for this functionality.</simpara>
<simpara>You should review the datasheet for the method for a specific microcontroller.</simpara>
<simpara>The following code demonstrates how to set the weak pullups available on port B of an 18F25K20.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'A program to show the use of weak pullups on portb.
    'Set chip model
    #chip 18F25k20,16 'at 16 MHz
    #config MCLR = Off

    Set RBPU = 0 'enabling Port B pullups in general.
    SET WPUB1 = 1 'portb.1 pulled up
    Set WPUB2 = 1 'portb.2
    Set WPUB3 = 1 'portb.3
    Set WPUB4 = 1 'portb.4

    Dir Portb in
    Dir Portc out

    do
        portc.1 = portb.1 'in pin 22, out pin 12
        portc.2 = portb.2 'in pin 23, out pin 13
        portc.3 = portb.3 'in pin 24, out pin 14
        portc.4 = portb.4 'in pin 25, out pin 15

    loop 'jump back to the start of the program

    'main line ends here
    end</screen>
<simpara>Also, see I2C Slave Hardware for an example using a 16F microcontroller.</simpara>
</section>
</section>
<section xml:id="_maths">
<title>Maths</title>
<simpara>This is the Maths section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_abs">
<title>Abs</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    integer_variable = Abs( integer_variable )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Abs</literal> function will compute the absolute value of a integer number therefore in the range of −32767 to +32767.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    absolute_value = Abs( -127 )  ' Will return 127
    absolute_value = Abs( 127 )   ' Will return 127 also. :-)</screen>
</section>
<section xml:id="_average">
<title>Average</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    integer_variable = Average(<emphasis>byte_variable1</emphasis> , <emphasis>byte_variable2</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>A function that returns the average of two numbers. This only supports byte variables.</simpara>
<simpara>Provides a very fast way to calculate the average of two 8 bit numbers.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen> average_value = Average(8,4)   ' Will return 6</screen>
</section>
<section xml:id="_difference">
<title>Difference</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <literal>Difference ( word_variable1 , word_variable2 )</literal> or
    <literal>Difference ( byte_variable1 , byte_variable2 )</literal></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>A function that returns the difference between of two numbers. This only supports byte or word variables.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    Difference( 8 ,4 ) ' Will return 4
    Difference( 0xff01 , 0xfffa ) ' Will return 0xf9 or 249d</screen>
</section>
<section xml:id="_int">
<title>Int</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    integer_variable = Int( single_variable )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Int</literal> function will compute the integer value of an integer number therefore will return the range of single variable.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    integer_value = Int(  _singlevariable_ )  ' Will return  the range of single variable.</screen>
</section>
<section xml:id="_logarithms">
<title>Logarithms</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>GCBASIC support logarithmic functions through the include file &lt;maths.h&gt;.</simpara>
<simpara>These functions compute base 2, base e and base 10 logarithms accurate to 2 decimal places, +/- 0.01.</simpara>
<simpara>The values returned are fixed-point numbers, with two decimal places assumed on the right. Or if you prefer, think of the values as being scaled up by 100.</simpara>
<simpara>The input arguments are word-sized integers, 1 to 65535. Remember, logarithms are not defined for non-positive numbers. It is the calling program&#8217;s responsibility to avoid these. Output values are also word-sized.</simpara>
<simpara>Local variables consume 9 bytes, while the function parameters consume another 4 bytes, for a grand total of 13 bytes of RAM used. The lookup table takes 35 words of program memory.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_log10">Log10</link>, <link linkend="_log2">Log2</link>, <link linkend="_loge">Loge</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;MATHS.H&gt;</emphasis></simpara>
<section xml:id="_log2">
<title>Log2</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    returned_word_variable = Log2 ( <emphasis>word_value</emphasis> )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Log2</literal> command will return the base-2 logarithm, to 2 decimal places.</simpara>
<simpara>The values returned are fixed-point numbers, with two decimal places assumed on the right. or if you prefer, think of the values as being scaled up by 100.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    dim log_value as word
    log_value = log2 ( 10 )   'return 3321 equate to 3.321</screen>
<simpara><emphasis role="strong">Supported in &lt;MATHS.H&gt;</emphasis></simpara>
</section>
<section xml:id="_loge">
<title>Loge</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    returned_word_variable = Loge ( <emphasis>word_value</emphasis> )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Loge</literal> command will return the base-e logarithm, to 2 decimal places.</simpara>
<simpara>The values returned are fixed-point numbers, with two decimal places assumed on the right. or if you prefer, think of the values as being scaled up by 100.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    dim log_value as word
    log_value = loge ( 10 )</screen>
<simpara><emphasis role="strong">Supported in &lt;MATHS.H&gt;</emphasis></simpara>
</section>
<section xml:id="_log10">
<title>Log10</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    returned_word_variable = Log10 (<emphasis>word_value</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Log10</literal> command will return the base-10 logarithm, to 2 decimal places.</simpara>
<simpara>The values returned are fixed-point numbers, with two decimal places assumed on the right. or if you prefer, think of the values as being scaled up by 100.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    dim log_value as word
    log_value = log10 ( 10 )      'return 230 equate to 2.30</screen>
<simpara><emphasis role="strong">Supported in &lt;MATHS.H&gt;</emphasis></simpara>
</section>
</section>
<section xml:id="_power">
<title>Power</title>
<simpara><emphasis role="strong">Syntax</emphasis>:</simpara>
<screen>    power( base, exponent )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This function raises a base to an exponent, i.e, <literal>power(base,exponent)</literal>. Calculation powers will become large, in terms of long numbers, you must ensure the program manage numbers remain within range of the defined variables.</simpara>
<simpara>The <literal>base</literal> and <literal>exponent</literal> are Byte sized numbers in this method.<?asciidoc-br?>
The returned result is a Long.<?asciidoc-br?>
Non-negative numbers are assumed throughout.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
0 raised to 0 is meaningless and should be avoided, but, any other non-zero base raised to 0 is handled correctly.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Thomas Henry -- 5/2/2014

    ;----- Configuration

    #chip 16F88, 8              ;PIC16F88 running at 8 MHz
    #config mclr=off            ;reset handled internally

    #include &lt;maths.h&gt;          ;required maths.h

    ;----- Constants

    #define LCD_IO 4            ;4-bit mode
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS PortB.2      ;pin 8 is LCD Register Select
    #define LCD_Enable PortB.3  ;pin 9 is LCD Enable
    #define LCD_DB4 PortB.4     ;DB4 on pin 10
    #define LCD_DB5 PortB.5     ;DB5 on pin 11
    #define LCD_DB6 PortB.6     ;DB6 on pin 12
    #define LCD_DB7 PortB.7     ;DB7 on pin 13
    #define LCD_NO_RW 1         ;Ground the RW line on LCD

    ;----- Variables

    dim i, j as byte

    ;----- Program

    dir PortB out               ;all outputs to the LCD
    for i = 1 to 10             ;do all the way from
      for j = 0 to 9            ;1^0 on up to 10^9
        cls
        print i
        print "^"
        print j
        print "="
        locate 1,0
        print power(i,j)        ;here's the invocation
        wait 1 S
      next j
    next i</screen>
<simpara><emphasis role="strong">Supported in &lt;MATHS.H&gt;</emphasis></simpara>
</section>
<section xml:id="_roundsingle">
<title>RoundSingle</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    rounded_single_value = RoundSingle( single_variable )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>RoundSingle</literal> function will return a floating point number that is a rounded version of the specified number.</simpara>
<simpara>This operates the same as Microsoft floor().</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    rounded_single_value = RoundSingle(  _singlevariable_ )  ' Will return  the range of single variable.</screen>
</section>
<section xml:id="_scale">
<title>Scale</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    integer_variable = Scale (value_word , fromLow_integer , fromHigh_integer , toLow_integer , toHigh_integer [, calibration_integer] )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.&#160;&#160;&#160;The parameters are:</simpara>
<simpara><literal>value</literal>: the number to scale. A value between 0 and 0xFFFFF - all values passed will be treated as Word variables.</simpara>
<simpara><literal>fromLow</literal>: the lower bound of the value’s current range. An Integer value between -32767 and 32767.</simpara>
<simpara><literal>fromHigh</literal>: the upper bound of the value’s current range. An Integer value between -32767 and 32767.</simpara>
<simpara><literal>toLow</literal>: the lower bound of the value’s target range. An Integer value between -32767 and 32767.</simpara>
<simpara><literal>toHigh</literal>: the upper bound of the value’s target range. An Integer value between -32767 and 32767.</simpara>
<simpara><literal>calibration</literal>: optional calibration offset value. An Integer value between -32767 and 32767.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>This is also an overloaded method.  You can also use word variables to provide a returned result of 0-65535.
<?asciidoc-br?></simpara>
<screen>    word_variable = Scale (value_word , fromLow_word , fromHigh_word , toLow_wordr , toHigh_word [, calibration_integer] )</screen>
<simpara>Available on all microcontrollers.&#160;&#160;&#160;The parameters are:</simpara>
<simpara><literal>value</literal>: the number to scale. A value between 0 and 0xFFFFF - all values passed will be treated as Word variables.</simpara>
<simpara><literal>fromLow</literal>: the lower bound of the value’s current range. A word value.</simpara>
<simpara><literal>fromHigh</literal>: the upper bound of the value’s current range. A word value.</simpara>
<simpara><literal>toLow</literal>: the lower bound of the value’s target range.  A word value.</simpara>
<simpara><literal>toHigh</literal>: the upper bound of the value’s target range.  A word value.</simpara>
<simpara><literal>calibration</literal>: optional calibration offset value. An Integer value between -32767 and 32767.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Scales, re-maps, a number from one range to another.&#160;&#160;&#160;That is, a value of fromLow would gets scaled to toLow, a value of fromHigh to toHigh, values in-between to values in-between, etc.</simpara>
<simpara>The method does not constrain values to within the integer range returned, because out-of-range values are sometimes intended and useful.</simpara>
<simpara>Note that the "lower bounds" of either range may be larger or smaller than the "upper bounds" so the scale() method may be used to reverse a range of numbers, for example:</simpara>
<screen>    my_newvalue  = scale ( ReadAD10(An0) , 0, 1023, 135, 270)</screen>
<simpara>The method also handles negative integer numbers well, so that this example:</simpara>
<screen>    my_newvalue = scale(ReadAD(An0), 0, 255, 50, -100);</screen>
<simpara>This method is similar to the Ardunio Map() function.</simpara>
</section>
<section xml:id="_sqrt">
<title>Sqrt</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    word_variable = sqrt ( <emphasis>word</emphasis> )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>A square root routine for GCBASIC. The function only involves bit shifting, addition and subtraction, which makes it fast and efficient.</simpara>
<simpara>This method required a word variable as the input and a word variable as the output. The method will handle arguments of up to 4294.</simpara>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers, required MATHS.H include file.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Demo: Show the first 100 square roots to 2 decimal places.
    ;This uses the maths.h include file.

    ;----- Configuration

    #chip 16F88, 8                  ;PIC16F88 running at 8 MHz
    #config mclr=off                ;reset handled internally

    #include &lt;maths.h&gt;              ;required maths.h

    ;----- Constants

    #define LCD_IO      4           ;4-bit mode
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS      PortB.2     ;pin 8 is LCD Register Select
    #define LCD_Enable  PortB.3     ;pin 9 is LCD Enable
    #define LCD_DB4     PortB.4     ;DB4 on pin 10
    #define LCD_DB5     PortB.5     ;DB5 on pin 11
    #define LCD_DB6     PortB.6     ;DB6 on pin 12
    #define LCD_DB7     PortB.7     ;DB7 on pin 13
    #define LCD_NO_RW   1           ;ground the RW line on LCD

    ;----- Variables

    dim length as byte
    dim i as word
    dim valStr, outStr as string

    ;----- Program

    dir PortB out       ;all outputs to the LCD

    for i = 0 to 100   ;print first 100 square roots
      cls
      print "sqrt("
      print i
      print ")="

      valStr = str(sqrt(i))         ;format decimal nicely
      length = len(valStr)

      select case length
       case 1:
          outStr = "0.00"           ;zero case
       case 3:
          outStr = left(valStr,1)+ "."+right(valStr,2)
        case 4:
          outStr = left(valStr,2)+ "."+right(valStr,2)
        case 5:
          outStr = left(valStr,3)+ "."+right(valStr,2)
      end select

      print outStr                  ;display results
      wait 2 S
    next i</screen>
<simpara><emphasis role="strong">Supported in &lt;MATHS.H&gt;</emphasis></simpara>
</section>
<section xml:id="_trigonometry_sine_cosine_and_tangent">
<title>Trigonometry Sine, Cosine and Tangent</title>
<simpara><emphasis role="strong">Syntax</emphasis>:</simpara>
<screen>    integer_variable = sin( <emphasis>integer_variable</emphasis> )

    integer_variable = cos( <emphasis>integer_variable</emphasis> )

    integer_variable = tan( <emphasis>integer_variable</emphasis> )</screen>
<simpara><emphasis role="strong">Explanation</emphasis>:</simpara>
<simpara>GCBASIC supports Three Primary Trigonometric Functions</simpara>
<simpara>GCBASIC supports the following functions, sin(x), cos(x), tan(x), where x is a signed integer representing an angle measured in a whole number of degrees.&#160;&#160;
The output values are also integers, represented as fixed point decimal fractions.</simpara>
<simpara><emphasis role="strong">Details:</emphasis></simpara>
<simpara>The sine, cosine and tangent functions are available for your programs simply by including the header file offering the precision you need.</simpara>
<screen>    #INCLUDE &lt;TRIG2PLACES.H&gt; gives two decimal places
    #INCLUDE &lt;TRIG3PLACES.H&gt; gives three decimal places
    #INCLUDE &lt;TRIG4PLACES.H&gt; gives four decimal places</screen>
<simpara>In fixed point representation, the decimal point is assumed.&#160;&#160;For example, with two places of accuracy, sin(60) returns 87, which you would interpret as 0.87.&#160;&#160;With three places, 866 is returned, to be interpreted as 0.866, and so on.&#160;&#160;Another way of thinking of this is to consider the two-place values as scaled up by 100, the three-place values scaled up by 1000 and the four-place values scaled up by 10,000.</simpara>
<simpara>Sine and Cosine are always defined, but remember that tangent fails to exist at 90 degrees, 270 degrees and all their coterminal angles.&#160;&#160;It is the responsibility of the calling program to avoid these special values.</simpara>
<simpara>Note that the tangent function is not available to four decimal places, since its value grows so rapidly, exceeding what the Integer data type can represent.</simpara>
<simpara>These routines are completely general. The input argument may be positive, negative or zero, with no restriction on the size.&#160;&#160;Further observe that lookup tables are used, so the routines are very fast, efficient and accurate.</simpara>
<simpara><emphasis role="strong">Example: Show the trigonometric values to three decimal places.</emphasis></simpara>
<screen>    ;----- Configuration
    #CHIP 16F88, 8                  ;PIC16F88 RUNNING AT 8 MHZ
    #CONFIG MCLR=OFF                ;RESET HANDLED INTERNALLY

    #INCLUDE &lt;TRIG3PLACES.H&gt;

    ;----- Constants

    #define LCD_IO      4           ;4-bit mode
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS      PortB.2     ;pin 8 is LCD Register Select
    #define LCD_Enable  PortB.3     ;pin 9 is LCD Enable
    #define LCD_DB4     PortB.4     ;DB4 on pin 10
    #define LCD_DB5     PortB.5     ;DB5 on pin 11
    #define LCD_DB6     PortB.6     ;DB6a on pin 12
    #define LCD_DB7     PortB.7     ;DB7 on pin 13
    #define LCD_NO_RW   1           ;ground the RW line on LCD

    ;----- Variables

    dim ii as integer
    dim outStr, valStr as string

    ;----- Program

    dir PortB out                   ;all outputs to the LCD

    for ii = -720 to 720             ;arguments from -720 to 720
    cls
    print "sin("                  ;print the label
    print ii                      ;and the argument
    print ")="                    ;and closing parenthesis
    locate 1,0
    printTrig(sin(ii))             ;print value of the sine
    wait 500 mS                   ;pause to view

    cls                           ;do likewise for cosine
    print "cos("
    print ii
    print ")="
    locate 1,0
    printTrig(cos(ii))
    wait 500 mS                   ;pause to view
    cls                           ;do likewise for tangent
    print "tan("
    print ii
    print ")="
    locate 1,0
    printTrig(tan(ii))
    wait 500 mS                   ;pause to view
    next i

    sub printTrig(in value as integer)
        ;print decently formatted trig results

        outStr = ""                   ;assume positive (no sign)

        if value &lt; 0 then             ;handle negatives
            outStr = "-"                ;prefix a minus sign
            value = -1 * value          ;but work with positives
        end if

        valStr = str(value)
        length = len(valStr)
        select case length
            case 1:
            outStr = outStr + "0.00" + valStr
            case 2:
            outStr = outStr + "0.0" + valStr
            case 3:
            outStr = outStr + "0." + valStr
            case 4:
            outStr = outStr + left(valStr,1) + "." + right(valStr,3)
            case 5:
            outStr = outStr + left(valStr,2) + "." + right(valStr,3)
        end select
        print outStr
    end sub</screen>
</section>
<section xml:id="_trigonometry_atan">
<title>Trigonometry ATAN</title>
<simpara><emphasis role="strong">Syntax</emphasis>:</simpara>
<screen>    #include &lt;maths.h&gt;

    integer_variable = ATan (_x_vector_,_y_vector_)</screen>
<simpara><emphasis role="strong">Explanation</emphasis>:</simpara>
<simpara>GCBASIC supports the trigonometric function for ATan.&#160;&#160;</simpara>
<simpara><emphasis role="strong">Details:</emphasis></simpara>
<simpara>GCBASIC supports the following functions ATan( x, y) where x and y are the vectors.  The function returns an Integer result representing the angle measured in a whole number of degrees.</simpara>
<simpara>The function also returns a global byte variable NegFlag with returns the quadrant of the angle.</simpara>
<literallayout class="monospaced">Quadrant 1 = 0 to 89
Quadrant 2 = 90 to 179
Quadrant 3 = 180 to 269
Quadrant 4 = 270 to 359</literallayout>
<simpara>This ATan function is a fast XY vector to integer degree algorithm developed in Jan 2011, see www.RomanBlack.com and see <link xlink:href="http://www.romanblack.com/integer_degree.htm">http://www.romanblack.com/integer_degree.htm</link></simpara>
<simpara>The function converts any XY vectors including 0 to a degree value that should be within +/- 1 degree of the accurate value without needing large slow trig functions like ArcTan() or ArcCos().</simpara>
<simpara>At least one of the X or Y values must be non-zero.&#160;&#160;
This is the full version, for all 4 quadrants and will generate the angle in integer degrees from 0-360.&#160;&#160;
Any values of X and Y are usable including negative values provided they are between -1456 and 1456 so the 16bit multiply does not overflow.</simpara>
</section>
</section>
<section xml:id="_peripheral_pin_select">
<title>Peripheral Pin Select</title>
<simpara>This is the Peripheral Pin Select section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_peripheral_pin_select_for_microchip_microcontrollers">
<title>Peripheral Pin Select for Microchip microcontrollers.</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>Peripheral Pin Select (PPS) enables the digital peripheral I/O pins to be changed to support mapping of external pins to different pins.</simpara>
<simpara>In older 8-bit Microchip devices, a peripheral was hard-wired to a specific pin (example: PWM1 output on pin RC5).</simpara>
<simpara>PPS allows you to choose from a number of output and input pins to connect to the digital peripheral.</simpara>
<simpara>This can be extremely useful for routing circuit boards.</simpara>
<simpara>There are cases where a change of I/O position can make a circuit board easier to route Sometimes mistakes are found too late to fix so having the option to change a pinout mapping in software rather than creating a new printed circuit board can be very helpful.</simpara>
<simpara>You <emphasis role="strong">must</emphasis> use the command <literal>UnLockPPS</literal> to enable setting of the PPS if the PPS have been previously locked, and, you can, optionally,  use <literal>LockPPS</literal> to prevent unintentional change to PPS settings.</simpara>
<simpara>GCBASIC includes these two macros to ensure this process is handled correctly.</simpara>
<simpara>Also, see <link xlink:href="http://microchip.wikidot.com/8bit:pps">http://microchip.wikidot.com/8bit:pps</link> for more information.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Please check configuration before using on an alternative microcontroller.

    #chip 16f18855,32
    #option explicit

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      LOCKPPS
        RC0PPS = 0x0010       'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011       'RC1-&gt;EUSART:RX;

        SSP1CLKPPS = 0x14     'RC3-&gt;MSSP1:SCL1;
        SSP1DATPPS = 0x13     'RC4-&gt;MSSP1:SDA1;
        RC3PPS = 0x15         'RC3-&gt;MSSP1:SCL1;
        RC4PPS = 0x14         'RC4-&gt;MSSP1:SDA1;
      UnLockPPS
    End Sub</screen>
<simpara><emphasis role="strong">For more help, see: <link linkend="_unlockpps">UnlockPPS</link> and <link linkend="_lockpps">LockPPS</link>.</emphasis></simpara>
</section>
<section xml:id="_unlockpps">
<title>UnLockPPS</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    UNLOCKPPS</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Peripheral Pin Select (PPS) has an operation mode in which all input and output selections can be prevented to stop  inadvertent changes.</simpara>
<simpara>PPS selections are unlocked by setting by the use of the <literal>UnLockPPS</literal> command.</simpara>
<simpara>Using this command will ensure the special sequence of Microchip assembler is handled correctly.</simpara>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip microcontrollers only.</simpara>
<screen>    #chip 16f18855,32
    #option explicit

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      UNLOCKPPS
        RC0PPS = 0x0010       'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011       'RC1-&gt;EUSART:RX;

        SSP1CLKPPS = 0x14     'RC3-&gt;MSSP1:SCL1;
        SSP1DATPPS = 0x13     'RC4-&gt;MSSP1:SDA1;
        RC3PPS = 0x15         'RC3-&gt;MSSP1:SCL1;
        RC4PPS = 0x14         'RC4-&gt;MSSP1:SDA1;
      LockPPS
    End Sub</screen>
<simpara><emphasis role="strong">For more help, see: <link linkend="_lockpps">LockPPS</link></emphasis>.</simpara>
</section>
<section xml:id="_lockpps">
<title>LockPPS</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LOCKPSS</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Peripheral Pin Select (PPS) has an operation mode in which all input and output selections can be prevented to stop  inadvertent changes.</simpara>
<simpara>PPS selections are locked by setting by the use of the <literal>LockPPS</literal> command.</simpara>
<simpara>Using this command will ensure the special sequence of Microchip assembler is handled correctly.</simpara>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip microcontrollers only.</simpara>
<screen>    #chip 16f18855,32
    #option explicit

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      UNLOCKPPS
        RC0PPS = 0x0010       'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011       'RC1-&gt;EUSART:RX;

        SSP1CLKPPS = 0x14     'RC3-&gt;MSSP1:SCL1;
        SSP1DATPPS = 0x13     'RC4-&gt;MSSP1:SDA1;
        RC3PPS = 0x15         'RC3-&gt;MSSP1:SCL1;
        RC4PPS = 0x14         'RC4-&gt;MSSP1:SDA1;
      LOCKPPS
    End Sub</screen>
<simpara><emphasis role="strong">For more help, see: <link linkend="_unlockpps">UnlockPPS</link>.</emphasis></simpara>
</section>
</section>
</section>
<section xml:id="_compiler_directives">
<title>Compiler Directives</title>
<simpara>This is the Compiler Directives section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="__asmraw">
<title>#asmraw</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #asmraw [label]
    #asmraw [Mnemonics | Directives | Macros] [Operands] ['comments]</screen>
<simpara>for ASM blocks use</simpara>
<screen>    #asmraw[
        [label]
        [Mnemonics | Directives | Macros] [Operands] ['comments]
    #asmraw]</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#asmraw</literal> directive is used to specify the assembly that GCBASIC will use.&#160;&#160;&#160;</simpara>
<simpara>Anything following this directive will be inserted into ASM source file with no changes other than trimming spaces - no replacement of constants.&#160;&#160;&#160;</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
Assembly is a programming language you may use to develop the source code for your application.&#160;&#160;&#160;
The directive must conform to the following basic guidelines.&#160;&#160;&#160;
Each line of the source file may contain up to four types of information:&#160;&#160;&#160;</simpara>
<simpara>• Labels</simpara>
<simpara>• Mnemonics, Directives and Macros</simpara>
<simpara>• Operands</simpara>
<simpara>• Comments</simpara>
<simpara>The order and position of these are important. For ease of debugging, it is recommended that labels start in column one and mnemonics start in column two or
beyond.&#160;&#160;&#160;
Operands follow the mnemonic.&#160;&#160;&#160;</simpara>
<simpara>Comments may follow the operands, mnemonics or labels, and can start in any column. The maximum column width is 255 characters.&#160;&#160;&#160;</simpara>
<simpara>White space or a colon must separate the label and the mnemonic, and white space must separate the mnemonic and the operand(s).&#160;&#160;&#160;
Multiple operands must be separated by commas.&#160;&#160;&#160;</simpara>
<simpara>White space is one or more spaces or tabs. White space is used to separate pieces of a source line.&#160;&#160;&#160;
White space should be used to make your code easier for people to read.&#160;&#160;&#160;</simpara>
<simpara><?asciidoc-br?>
<emphasis role="strong">Example 1</emphasis></simpara>
<screen>        #asmraw lds SysValueCopy,TCCR0B
        #asmraw andi SysValueCopy, 0xf8
        #asmraw inc SysValueCopy
        #asmraw sts TCCR0B, SysValueCopy</screen>
<simpara><emphasis role="strong">Example 2</emphasis></simpara>
<screen>        #asmraw[
            lds SysValueCopy,TCCR0B
            andi SysValueCopy, 0xf8
            inc SysValueCopy
            sts TCCR0B, SysValueCopy
        #asmraw]</screen>
<simpara><?asciidoc-br?>
This example will generate the following in the ASM source file.</simpara>
<screen>        lds SysValueCopy,TCCR0B
        andi  SysValueCopy, 0xf8
        inc SysValueCopy
        sts TCCR0B, SysValueCopy</screen>
</section>
<section xml:id="__chip">
<title>#chip</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #chip <emphasis>model</emphasis>, <emphasis>frequency</emphasis>

    #chip <emphasis>model</emphasis>, <emphasis>frequency</emphasis> / <emphasis>numeric constant</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#chip</literal> directive is used to specify the chip model and frequency that GCBASIC will use.</simpara>
<simpara>The <literal><emphasis>model</emphasis></literal> is the specific microcontroller  - examples are "16F819".</simpara>
<simpara>The <literal><emphasis>frequency</emphasis></literal> is the frequency of the chip in MHz, and is required for the delay and PWM routines.
The following constants simplify setting specific frequencies.
<literal>31k</literal>,  <literal>32.768K</literal>, <literal>125k</literal>, <literal>250k</literal> or <literal>500k</literal>.  Any of these constant can be used. As shown in the example below.</simpara>
<simpara>If <literal>frequency</literal> is not present the compiler will select a frequency default frequency that should work for the microcontroller.</simpara>
<simpara>If <literal>numeric constant</literal> is specified then the compiler will complete a simple math calculation to determine the frequency.&#160;&#160;The only supported math instruction is divide.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>If the chip has an internal oscillator, the compiler will use that and pick the highest frequency it supports.</simpara>
</listitem>
<listitem>
<simpara>If the chip does not have an internal oscillator, then GCBASIC will assume that the chip is being run at its maximum possible clock frequency using an external crystal.</simpara>
</listitem>
<listitem>
<simpara>If you are using an external crystal then you must specify a chip frequency.</simpara>
</listitem>
</orderedlist>
<simpara>When using an AVR:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>There is no need to specify "AT" before the name.</simpara>
</listitem>
<listitem>
<simpara>Only AVRDX chips support setting the internal frequency using the <literal>frequency</literal> statement.</simpara>
</listitem>
<listitem>
<simpara>megaAVR assumes an external oscillator, and, therefore the <literal>frequency</literal> must match the external oscillator frequency.&#160;&#160;For Arduino products this is typically 16Mhz</simpara>
</listitem>
</orderedlist>
<simpara>When using a LGT:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Only LGT support setting the internal frequency using the <literal>frequency</literal> statement.</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">Examples:</emphasis></simpara>
<screen>    #chip 12F509, 4
    #chip 18F4550, 48
    #chip 16F88, 0.125
    #chip tiny2313, 1
    #chip mega8, 16
    #chip 12f1840, 31k
    #chip 12f1840, 500k
    #chip 12f1840, 250k
    #chip 12f1840, 125k

    #chip lgt8x328p, 4
    #chip tiny3127, 16 / 48

    'Select the internal low frequency oscillator. The microcontroller must have a low frequency oscillator option.  The internal oscillator is automatically selected on PIC.
    #chip 16f18326, 31k

    'Select the external SOSC clock source.
    #chip 16f18855, 32.768k
    #config osc=SOSC</screen>
<simpara><emphasis role="strong">Setting Other Clock frequencies:</emphasis>
Some alternative compilers allow value of the clock frequency to be set with the numerical value in Hertz (<emphasis>i.e.</emphasis> 24576000). This can be useful when using the clock frequencies other than standard frequencies.</simpara>
<simpara>GCBASIC requires clock frequencys to be specified in MHz, but will accept decimal points. For example, if you wanted to run a 16F1827 at 24576000 Hz, you would write the following:</simpara>
<screen>    #chip 16F1827, 24.576</screen>
<simpara><emphasis role="strong">GCBASIC support for microcontrollers:</emphasis></simpara>
<simpara>Each microcontroller has a microcontroller data file.  This file is located in \GCBasic\chipdata\ folder when installed.</simpara>
<simpara>An example is 12F1840.dat</simpara>
<simpara>The there are two sections in the microcontroller data file that control the "chip frequency", they are:</simpara>
<literallayout class="monospaced">*[ChipData]* and *[ConfigOps]*</literallayout>
<simpara><emphasis role="strong">ChipData section</emphasis></simpara>
<simpara>The ChipData section for 12F1840 microcontroller. The 12F1840 is used an example</simpara>
<screen>    [ChipData]
    Prog=4096
    EEPROM=256
    RAM=256
    I/O=6
    ADC=4
    MaxMHz=32
    IntOsc=32, 16, 8, 4, 2, 1, 0.5, 0.25, 0.125
    31kSupport=INTOSC,OSCCON,2
    Pins=8
    Family=15
    ConfigWords=2
    PSP=0
    MaxAddress=4095</screen>
<simpara>The IntOsc line specifies the supported internal clock frequencies -  The 12F1840 microcontroller supports nine internal frequencies (ChipMHz). #Chip is used as follows:
The 31kSupport line specifies the chip supports 31k for internal clock frequency.</simpara>
<screen>    #chip 12F1840, 32</screen>
<simpara>A ChipMHz of 32 does two things.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>When using the internal oscillator,  it tells the compiler to set the chip clock frequency (FOSC) to 32MHz</simpara>
</listitem>
<listitem>
<simpara>It tells the compiler to calculate all delays (wait times) based upon FOSC of 32 MHz.
Unlike Picaxe Basic (and other compilers) GCBASIC delays ("wait") are correct regardless of the setting of FOSC.
If you set the internal oscillator to 4 MHz a "wait 1 ms" will still be 1 ms.</simpara>
</listitem>
</orderedlist>
<simpara>If you set chipMHz to something other than the valid options in the [ChipData] IntOsc section of the microcontroller specific dat file, then, the compiler assumes that you are using an external oscillator and will calculate the delays according to the value you use. The wait times will be incorrect if you are not using an external oscillator at the same frequency as ChipMhz.</simpara>
<screen>    Example:  #chip 12F1840, 12</screen>
<simpara>Since "12" is not a valid internal osc frequency, the microcontroller FOSC will default to 8 MHz because there is no external crystal installed. However, the wait times will be incorrect as they will be calculated by the compiler based upon a 12 Mhz clock.</simpara>
<simpara><emphasis role="strong">ConfigOps section</emphasis></simpara>
<simpara>The [ConfigOps] section of 12F1840.dat is towards the end of the chip data file. For the 12F1840 is looks like this</simpara>
<screen>    [ConfigOps]
    OSC=LP,XT,HS,EXTRC,INTOSC,ECL,ECM,ECH
    WDTE=OFF,SWDTEN,NSLEEP,ON
    PWRTE=ON,OFF
    MCLRE=OFF,ON
    CP=ON,OFF
    CPD=ON,OFF
    BOREN=OFF,SBODEN,NSLEEP,ON
    CLKOUTEN=ON,OFF
    IESO=OFF,ON
    FCMEN=OFF,ON
    WRT=ALL,HALF,BOOT,OFF
    PLLEN=OFF,ON
    STVREN=OFF,ON
    BORV=HI,LO,19
    LVP=OFF,ON</screen>
<simpara><literal>OSC</literal> specifies which oscillator options are available for the specific microcontroller.
<literal>INTOSC</literal> is the internal oscillator. All others are some form of external clock source.
<literal>PLLEN</literal> sets the internal Phase Lock Loop either on or off. With this chip the default clock frequency is 8 Mhz. The PLL multiplies this by 4. So to get 32 Mhz the basic internal oscillator will be 8 Mhz then multiplied by 4. For 16 MHz it wil be 4 multiplied by 2.</simpara>
<simpara>GCB sets the PLL automatically, so this option should generally be left alone. IF PLLEN is set to ON, then GCB may not be able to set the correct frewuency of the internal oscillator. Only set PLL = ON if you know what you are doing.</simpara>
<simpara>It is a good practice to set the oscillator source in #config at the beginning of your code when you are not using the internal oscillator.  This prevents potential errors. Example:</simpara>
<screen>    #Chip 12F1840, 16
    #Config OSC = INTOSC   'This is normally not required as the internal oscillator is the default oscillator.</screen>
<simpara>In  this example above, GCBASIC will automatically set the necessary OSC bits for the microcontroller. Frequency bits will be set to 4 MHz and the PLL will be turned on and wait times will be calculated on an FOSC of 16.</simpara>
<simpara>You can set the clock to other frequencies but you have to put the PIC into <literal>EC</literal> or <literal>External Clock</literal> mode and then supply that specific clock frequency to the OSC1 pin.</simpara>
<simpara>There are three EC modes on the PIC12F1840:</simpara>
<screen>    ECL - 0 MHz - 0.5 MHz
    ECM - 0.5 MHz - 4 MHz
    ECH = 4 MHz - 32MHz</screen>
<simpara>Example: For a 2.1 MHz clock you would need to set the #config and the clock frequency, and, provide the OSC1 pin with a 2.1 MHz signal.</simpara>
<screen>    #chip 12f1840,2.1
    #config OSC = ECM</screen>
<simpara><emphasis role="strong">Notes</emphasis></simpara>
<simpara>When "#config osc=" is not specified in the source code, most microcontrollers will default to an external oscillator source. This means at runtime the chip is expecting an external clock signal.  If the external clock signal is not present, the chip detects a "failure" of the external clock and will  "falls back" to the default internal oscillator setting.</simpara>
<simpara>The PLLEN bit defaults to OFF. The PLL is enabled depending upon the ChipMhz in #Chip xxxxxx, ChipMhz.</simpara>
<simpara>The GCBASIC defaults - This is how the bits are set if there is no #config in the source code, GCBASIC does set certain bits.  To examine what bits are set on a particular chip you can omit #config in the source code, thenm compile the code and then use "Open ASM" in the GCBASIC IDE. The bits that are set will be in the config section. All other bits ( those not specifically set) with #Config will be at the POR setting as described below, The <literal>POR</literal> settings are shown in the datasheet for each microcontroller.</simpara>
<simpara>Currently GCBASIC sets the <literal>LVP</literal> bit <literal>OFF</literal> by default on many chips. This does not affect normal HV programming like a with a PicKit3.   The default of LVP = OFF  will prevent the microcontroller from being programmed with Low Voltage Programmer. This means that if a PIC microcontroller has previously been programmed with with "LVP =  OFF",  then it must be erased or reprogrammed with LVP = ON using a HVP programmer prior to using certain programming devices e.g. Curiosity development boards, or "NS"  programmers as these  required that LVP = ON.</simpara>
<simpara>When LVP = ON, the MCLR pin is automatically set to EXTERNAL MCLR.  This means that the MCLRE pin CANNOT be sue for general purpose I/O functions.</simpara>
<simpara>The native <literal>POR</literal> (Power On Reset) defaults. This is the state of the config bits after Power on if the ASM code has no configuration entries or on a blank factory chip. The only way to power up in this state with GCB code is to use " #option NoConfig" in the GCBASIC source code.</simpara>
</section>
<section xml:id="__config">
<title>#config</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #config <emphasis>option1</emphasis>, <emphasis>option2</emphasis>, ... , <emphasis>optionN</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#config</literal> directive is used to specify configuration options for the chip. There is a detailed explanation of <literal>#config</literal> in the Configuration section of help.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_configuration">Configuration</link></simpara>
</section>
<section xml:id="__define">
<title>#DEFINE</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #DEFINE SYMBOL <emphasis>body</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
<literal>#DEFINE</literal> allows to declare text-based preprocessor symbols.&#160;&#160;</simpara>
<simpara>Once the compiler has seen a #DEFINE, it will start replacing further occurrences of symbol with body. &#160;&#160;
Body may be empty.&#160;&#160;
The expansion is done recursively, until there is nothing more to expand and the compiler can continue analyzing the resulting code.</simpara>
<simpara>#UNDEFINE can be used to make the compiler forget about a #DEFINE.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The compiler replaces a SYMBOL with the value, it then searches the line for constants again and will make any more replacements needed.&#160;&#160;
It will do this up to 100 times on a line, then it will stop replacing and show an error. &#160;&#160;The limitation of 100 iteractions is to prevent something like "#DEFINE Const_A Const_B" and then "#DEFINE Const_B Const_A" from causing an infinite loop in the compiler.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_constants">DEFINEs</link></simpara>
</section>
<section xml:id="__undefine">
<title>#UNDEFINE</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #UNDEFINE <emphasis>existing-symbol</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
<literal>#UNDEFINE</literal> Undefines a symbol previously defined with #DEFINE.</simpara>
<simpara>Can be used to ensure that a symbol has a limited lifespan and does not conflict with a similar macro definition that may be defined later in the source code.</simpara>
<simpara>(Note: #UNDEFINE should not be used to undefine variable or function names used in the current program. The names are needed internally by the compiler and removing them can cause strange and unexpected results.)
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_constants">Defines</link></simpara>
</section>
<section xml:id="__if">
<title>#if</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #if <emphasis>Condition</emphasis>
      ...
    [#else]
      ...
    #endif</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#if</literal> directive is used to prevent a section of code from compiling unless <literal><emphasis>Condition</emphasis></literal> is true.</simpara>
<simpara><literal><emphasis>Condition</emphasis></literal> has the same syntax as the condition in a normal GCBASIC if command. The only difference is that it uses constants instead of variables and does not use "then".</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will pulse an adjustable number of pins on PORTB
    'The number of pins is controlled by the FlashPins constant
    #chip 16F88, 8

    'The number of pins to flash
    #define FlashPins 2

    'Initialise
    Dir PORTB Out

    'Main loop
    Do
        #if FlashPins &gt;= 1
            PulseOut PORTB.0, 250 ms
        #endif
        #if FlashPins &gt;= 2
            PulseOut PORTB.1, 250 ms
        #endif
        #if FlashPins &gt;= 3
            PulseOut PORTB.2, 250 ms
        #endif
        #if FlashPins &gt;= 4
            PulseOut PORTB.3, 250 ms
        #endif
    Loop</screen>
</section>
<section xml:id="__ifnot">
<title>#ifnot</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #ifnot <emphasis>Condition</emphasis>
      ...
    [#else]
      ...
    #endif</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#ifnot</literal> directive is used to prevent a section of code from compiling unless <literal><emphasis>Condition</emphasis></literal> is false.</simpara>
<simpara><literal><emphasis>Condition</emphasis></literal> has the same syntax as the condition in a normal GCBASIC if command. The only difference is that it uses constants instead of variables and does not use "then".</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will set the constant to true only if NOT a PIC family
    #chip 16F88, 8

    #ifnot ChipFamily = 14

      #define myConstant True

    #endif</screen>
</section>
<section xml:id="__ifdef">
<title>#ifdef</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #ifdef <emphasis>Constant</emphasis> | <emphasis>Constant Value</emphasis> | Var(<emphasis>VariableName</emphasis>)
      ...
    [#else]
      ...
    #endif</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#ifdef</literal> directive is used to selectively enable sections of code.</simpara>
<simpara>There are several ways in which it can be used:</simpara>
<itemizedlist>
<listitem>
<simpara>Checking if a constant is defined<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>Checking if a constant is defined and has a particular value<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>Checking if a system variable exists<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>Checking if a system bit has been defined</simpara>
</listitem>
</itemizedlist>
<simpara>The advantage of using <literal>#ifdef</literal> rather than an equivalent series of <literal>IF</literal> statements is the amount of code that is downloaded to the chip. <literal>#ifdef</literal> controls what code is compiled and downloaded, <literal>IF</literal> controls what is run once on the chip. <literal>#ifdef</literal> should be used whenever the value of a constant is to be checked.</simpara>
<simpara>GCBASIC also supports the <literal>#ifndef</literal> directive - this is the opposite of the <literal>#ifdef</literal> directive - it will remove code that <literal>#ifdef</literal> leaves, and vice versa.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
The code in the following sections will not compile, as it is missing <literal>#chip</literal> directives and <literal>Dir</literal> commands. It is intended to act as an example only.</simpara>
<simpara><emphasis role="strong">Example 1: <emphasis>Enabling code if a constant is defined</emphasis></emphasis></simpara>
<screen>    #define Blink1

    #ifdef Blink1
        PulseOut PORTB.0, 1 sec
        Wait 1 sec
    #endif
    #ifdef Blink2
        PulseOut PORTB.1, 1 sec
        Wait 1 sec
    #endif</screen>
<simpara>This code will pulse <literal>PORTB.0</literal>, but not <literal>PORTB.1</literal>. This is because <literal>Blink1</literal> has been defined, but <literal>Blink2</literal> has not. If the line was added at the start of the program, then both pins would be pulsed.</simpara>
<screen>    #define Blink2</screen>
<simpara>The value of the constant defined is not important and can be left off of the <literal>#define</literal>.</simpara>
<simpara><emphasis role="strong">Example 2: <emphasis>Enabling code if a constant is defined and has a given value</emphasis></emphasis></simpara>
<screen>    #define PinsToFlash 2

    #ifdef PinsToFlash 1,2,3
      PulseOut PORTB.0, 1 sec
    #endif
    #ifdef PinsToFlash 2,3
      PulseOut PORTB.1, 1 sec
    #endif
    #ifdef PinsToFlash 3
      PulseOut PORTB.2, 1 sec
    #endif</screen>
<simpara>This program uses a constant called PinsToFlash that controls how many lights are pulsed. <literal>PORTB.0</literal> is pulsed when <literal>PinsToFlash</literal> is equal to 1, 2 or 3, <literal>PORTB.1</literal> is pulsed when <literal>PinsToFlash</literal> equals 2 or 3, and <literal>PORTB.2</literal> is flashed when <literal>PinsToFlash</literal> is 3.</simpara>
<simpara><emphasis role="strong">Example 3: <emphasis>Enabling code if a system variable is defined</emphasis></emphasis></simpara>
<screen>    #ifdef NoVar(ANSEL)
      SET ADCON1.PCFG3 OFF
      SET ADCON1.PCFG2 ON
      SET ADCON1.PCFG1 ON
      SET ADCON1.PCFG0 OFF
    #endif
    #ifdef Var(ANSEL)
      ANSEL = 0
    #endif</screen>
<simpara>The above section of code has been copied directly from a-d.h. It is used to disable the A/D function of pins, so that they can be used as standard digital I/O ports. If <literal>ANSEL</literal> is not declared as a system variable for a particular chip, then the program uses <literal>ADCON1</literal> to control the port modes. If <literal>ANSEL</literal> is defined, then the chip is newer and its ports can be set to digital by clearing <literal>ANSEL</literal>.</simpara>
<simpara><emphasis role="strong">Example 4: <emphasis>Enabling code if a system bit is defined</emphasis></emphasis></simpara>
<simpara>Similar to above, except with <literal>Bit</literal> and <literal>NoBit</literal> in the place of <literal>Var</literal> and <literal>NoVar</literal> respectively.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_constants">Defines</link>, <link linkend="__define">#define</link></simpara>
</section>
<section xml:id="__ifndef">
<title>#ifndef</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #ifndef <emphasis>Constant</emphasis> | <emphasis>Constant Value</emphasis> | Var(<emphasis>VariableName</emphasis>)
      ...
    [#else]
      ...
    #endif</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#ifndef</literal> directive is used to selectively enable sections of code. It is the opposite of the <literal>#ifdef</literal> directive - it will delete code in cases where <literal>#ifdef</literal> would leave it, and will leave code where <literal>#ifdef</literal> would delete it.</simpara>
<simpara><emphasis role="strong">See</emphasis> the <link linkend="__ifdef">#ifdef</link> article for more information.</simpara>
</section>
<section xml:id="__include">
<title>#include</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #include <emphasis>filename</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>#include</literal> tells GCBASIC to open up another file, read all of the subroutines and constants from it, and then copy them into the current program.</simpara>
<simpara>There are two forms of include; absolute and relative.</simpara>
<simpara>Absolute is used to refer to files in the <literal>..\GCBASIC\include</literal>  directory. The name of the file is specified in between &lt; and &gt; symbols. For instance, to include the file <literal>srf04.h</literal>, the directive is:</simpara>
<screen>    #include &lt;srf04.h&gt;</screen>
<simpara>Relative is used to read files in the same folder as the currently selected program. Filenames are given enclosed in quotation marks, such as where <literal>mycode.h</literal> is the name of the file that is to be read.</simpara>
<screen>    #include "mycode.h"</screen>
<simpara><emphasis role="strong">NOTES:</emphasis>
It is not essential that the include file name ends in .h - the important thing is that the name given to GCBASIC is the exact name of the file to be included.</simpara>
<simpara>Those who are familiar with <literal>#include</literal> in assembly or C should bear in mind that <literal>#include</literal> in GCBASIC works differently to <literal>#include</literal> in most other languages - code is not inserted at the location of the <literal>#include</literal>, but rather at the end of the current program.</simpara>
</section>
<section xml:id="__insert">
<title>#insert</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #insert <emphasis>filename</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>#insert</literal> tells GCBASIC to open up another file, read all of the subroutines and constants from it, and then copy them into the current program at the specific line where the #insert directive is located.</simpara>
<simpara>There are two forms of include; absolute and relative.</simpara>
<simpara>Absolute is used to refer to files in the <literal>..\GCBASIC\include</literal>  directory. The name of the file is specified in between &lt; and &gt; symbols. For instance, to include the file <literal>toolchain.il</literal>, the directive is:</simpara>
<screen>    #insert &lt;"toolchain.il"&gt;</screen>
<simpara>Relative is used to read files in the same folder as the currently selected program. Filenames are given enclosed in quotation marks, such as where <literal>mycode.h</literal> is the name of the file that is to be read.</simpara>
<screen>    #insert "toolchain.il"</screen>
<simpara><emphasis role="strong">Difference from #include:</emphasis></simpara>
<simpara>This is very different from #include.&#160;&#160;
With #include you can organize constant, method and macro definitions and then use #include directive to add them to any source file.&#160;&#160;
Include files are also useful for incorporating declarations of external variables and complex data types. The types may be defined and named only once in an include file created for that purpose. The compiler will optimise the include files to determine the best order/location in your program.</simpara>
<simpara>Using #insert you are determining the location of the code segment.&#160;&#160;
It will be inserted exactly where you specify.&#160;&#160;
The optimisation will only be applied to any methods that you insert but the rest of the code essentially exits at the point of insertion.</simpara>
<simpara><emphasis role="strong">#Insert does not support Conversion:</emphasis></simpara>
<simpara>There is no conversion of the inserted file.&#160;&#160;For conversion use #Include.&#160;&#160;</simpara>
<simpara>If you need to convert a file from an external source then see the Converters section of the Help.</simpara>
<simpara><emphasis role="strong">Usage Notes:</emphasis></simpara>
<simpara>The file must exist. An error message is issued if not found.&#160;&#160;
When an error is encountered in the inserted file the error line number is in the format of xxxxyyyy.&#160;&#160;
Where xxxx is the code line number in the user program and the yyyy is the the line number in the inserted file.</simpara>
<simpara>An example error message.&#160;&#160;Where the source insert instruction is on line 6 and the error in the inserted file is on line 4.</simpara>
<screen>    An error has been found:
     insertexample.gcb (60004): Error: Syntax Error
    The message has been logged to the file Errors.txt.</screen>
</section>
<section xml:id="__script">
<title>#script</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #script
    [<emphasis>scriptcommand1</emphasis>]
    [<emphasis>scriptcommand2</emphasis>]
     ...
    [<emphasis>scriptcommandn</emphasis>]
    #endscript</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#script</literal> block is used to create small sections of code which GCBASIC runs during compilation.
A detail explanation and example are included in the Scripts article.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_scripts">Scripts</link></simpara>
</section>
<section xml:id="__startup">
<title>#startup</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #startup <emphasis>SubName</emphasis>  [<emphasis>priority</emphasis>]</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>#startup</literal> is used in include files to automatically insert initialization routines. If a define or subroutine from the file is used in the program, then the specified subroutine will be called.</simpara>
<simpara>The <literal>priority</literal> to #startup support the setting of the priority of the subroutines for all the libraries in a project.</simpara>
<simpara>Subroutines will be called in order from smallest to largest priority number.</simpara>
<literallayout class="monospaced">InitSys has priority 80, lowlevel communication routines have the priority of 90
All other subroutines defaults to 100.</literallayout>
<simpara><emphasis role="strong">Notes:</emphasis>
Limitations on this directive are:</simpara>
<simpara><literal>startup</literal> may only occur once within a source file.</simpara>
<simpara>No parameters can be passed the the subroutine that is specificed.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<simpara>This example from the hardware I2C library set the subroutine with the priority of 90.</simpara>
<screen>    #startup HIC2Init, 90</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<simpara>This example from would be included in user code to ensure the PPS setting are set prior to use of the MSSP or USART.</simpara>
<screen>    #chip 16f18855,32
    #option explicit

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      RC0PPS = 0x0010       'RC0-&gt;EUSART:TX;
      RXPPS  = 0x0011       'RC1-&gt;EUSART:RX;

      SSP1CLKPPS = 0x14     'RC3-&gt;MSSP1:SCL1;
      SSP1DATPPS = 0x13     'RC4-&gt;MSSP1:SDA1;
      RC3PPS = 0x15         'RC3-&gt;MSSP1:SCL1;
      RC4PPS = 0x14         'RC4-&gt;MSSP1:SDA1;
    End Sub</screen>
</section>
<section xml:id="__mem">
<title>#mem</title>
<simpara><emphasis role="strong">This directive is obsolete</emphasis>.</simpara>
<simpara>GCBASIC determines the amount of memory on a chip automatically, and will ignore the <literal>#mem</literal> directive.</simpara>
<simpara>It is recommended that this directive is removed from all programs.</simpara>
</section>
<section xml:id="_other_directives">
<title>Other directives</title>
<simpara>The built-in <literal>#defines</literal> are used to support the <literal>#IFDEF</literal> command set are as follows. The table also shows which <literal>#defines</literal> are supported as string in HSerPrint, SerPrint and other string related commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Type</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Usage</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Decription</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPADC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation  or output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The number of A/D inputs on the current chip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPASSEMBLER</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation  or output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The select assemble GCASM/MPASM/PICAS etc</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPEEPROM</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation  or output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The number of Bytes in EEPROM memmory</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPIO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation  or output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The number of general purpose IO pins</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPMHZ</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation  or output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The microcontroller clock speed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPNAME</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation only</simpara></entry>
<entry align="left" valign="top"><simpara>The microcontroller type</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPNAMESTR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation  or output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The microcontroller name</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPPINS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation  or output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The number of microcontroller pins.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPRESERVEHIGHPROG</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Scripts, Conditional compilation, and  output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The value of the words reserved</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPOSC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Scripts, Conditional compilation, and  output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The frequency selected</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPUSINGINTOSC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Scripts, Conditional compilation, and  output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The constant exists if the compiler has deternined the program is using the internal oscillator</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPPROGRAMMERNAMESTR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>String constant</simpara></entry>
<entry align="left" valign="top"><simpara>Name of the chip type to be used by a programmer</simpara></entry>
<entry align="left" valign="top"><simpara>The psuedo microcontroller type</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPRAM</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation  or output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The RAM size</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPSHAREDRAM</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation  or output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The first RAM location</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPFAMILY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation  or output commands</simpara></entry>
<entry align="left" valign="top"><simpara>See the table below</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CHIPWORDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation  or output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The number of WORDS in Flash memmory</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SOURCEFILE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Constant string</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation  or output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The name of the source GCB file</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Function</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Type</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Usage</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Description</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Var()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation only</simpara></entry>
<entry align="left" valign="top"><simpara>True if a register is declared (or false if not declared) in the currently specficied microcontroller&#8217;s .dat file.
</simpara><simpara>Var(register_name)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NoVar()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation only</simpara></entry>
<entry align="left" valign="top"><simpara>True if a register is NOT declared (or false if declared) in the currently specficied microcontroller&#8217;s .dat file.
</simpara><simpara>NoVar(register_name)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Bit()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation only</simpara></entry>
<entry align="left" valign="top"><simpara>True if a bit is declared (or false if not declared) in the currently specficied microcontroller&#8217;s .dat file.
</simpara><simpara>Bit(bit_name)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NoBit()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation only</simpara></entry>
<entry align="left" valign="top"><simpara>True if a bit is NOT declared (or false if declared) in the currently specficied microcontroller&#8217;s .dat file.
</simpara><simpara>NoBit(bit_name)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Allof()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation only</simpara></entry>
<entry align="left" valign="top"><simpara>True if all defines are declared:
</simpara><simpara><literal>AllOf(define1, define2, …)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OneOf()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional compilation only</simpara></entry>
<entry align="left" valign="top"><simpara>True if one of the defines is declared:
</simpara><simpara><literal>OneOf(define1, define2, …)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The table below shows two special directives that support the mapping for one variable or bit to anoher variable or bit.  This is useful when creating portable code or libraries to ensure GCBASIC
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="100%"?>
<?dbfo table-width="100%"?>
<?dblatex table-width="100%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="43*"/>
<colspec colname="col_2" colwidth="191*"/>
<colspec colname="col_3" colwidth="191*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Directive</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Explanation</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Usage</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>#samebit</simpara></entry>
<entry align="left" valign="top"><simpara>The compiler checks each item in the list to see which ones are implemented on the current microcontroller.
<?asciidoc-br?>
If any of the bits do not exist, the compiler will create a constant mapping to the  name of the first parameter in the list of parameters that does exist.
 + If none of the bits exist the no constant is created.</simpara></entry>
<entry align="left" valign="top"><simpara>&#160;&#160;#samebit PLLEN, SPLLEN, SPLLMULT
<?asciidoc-br?>
&#160;&#160;&#160;&#160;Set SPLLEN On
<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>#samevar</simpara></entry>
<entry align="left" valign="top"><simpara>The compiler checks each item in the list to see which ones are implemented on the current microcontroller.
<?asciidoc-br?>
If any of the variables do not exist, the compiler will create a constant mapping to the  name of the first parameter in the list of parameters that does exist.
 + If none of the variables exist the no constant is created.</simpara></entry>
<entry align="left" valign="top"><simpara>&#160;&#160;#samevar CMCON, CMCON0, CMCONbob<?asciidoc-br?>
&#160;&#160;#ifdef Var(CMCONbob)<?asciidoc-br?>
&#160;&#160;&#160;&#160;&#160;&#160;CMCONbob = 7<?asciidoc-br?>
&#160;&#160;#endif<?asciidoc-br?>
<?asciidoc-br?>
&#160;&#160;Compiles to:<?asciidoc-br?>
&#160;&#160;;CMCONbob = 7<?asciidoc-br?>
&#160;&#160;movlw 7<?asciidoc-br?>
&#160;&#160;movwf CMCON,ACCESS<?asciidoc-br?>
<?asciidoc-br?></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>This table shows the ChipFamily constants mapped to the microcontroller architecture.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">ChipFamily Value</emphasis></entry>
<entry align="left" valign="top"></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">AVR</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Microcontroller Characteristics</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>AVR core version V0E class microcontrollers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>110</simpara></entry>
<entry align="left" valign="top"><simpara>AVR core version V1E class microcontrollers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>120</simpara></entry>
<entry align="left" valign="top"><simpara>AVR core version V2E class microcontrollers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>-120 Subtype: 121</simpara></entry>
<entry align="left" valign="top"><simpara>AVR core version AVR8L, also called AVRrc, reduced core class microcontrollers.  ATTiny4-5-9-10 and ATTiny102-104 with only 16 GPR&#8217;s from r16-r31 and only 54 instructions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>-120 Subtype: 122</simpara></entry>
<entry align="left" valign="top"><simpara>LGT microcontrollers.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>-120 Subtype: 123</simpara></entry>
<entry align="left" valign="top"><simpara>AVR core version V2E class microcontrollers with one USART like the mega32u4, mega16u4 - they have different registers for the usart.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>121</simpara></entry>
<entry align="left" valign="top"><simpara>Tiny4-5-9-10 and tiny102-104. Only 16 GPR&#8217;s from r16-r31 and only 54 instructions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>130</simpara></entry>
<entry align="left" valign="top"><simpara>AVR core version V3E class microcontrollers but essentially the mega32u6 only</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>140</simpara></entry>
<entry align="left" valign="top"><simpara>AVRDX microcontrollers. Series 0, series1, series2, DA series and DB series.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">PIC</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Microcontroller Characteristics</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>Baseline devices. 12 Bit instruction set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>15</simpara></entry>
<entry align="left" valign="top"><simpara>Mid-range core devices. 14 Bit instruction set with enhanced instruction set class</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>15 plus familyVariant=1</simpara></entry>
<entry align="left" valign="top"><simpara>Mid-range core devices. 14 Bit instruction set with enhanced instruction set  and with large memory capability class</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>High end core devices. 16 Bit instruction set, memory addressing architecture and an extended instruction set.
</simpara><simpara>Chip family 16 also have a sub chip family Constant.&#160;&#160; These constants are shown below:
</simpara><simpara>    &#160;&#160;&#160;&#160;ChipFamily18FxxQ10 = 16100
</simpara><simpara>    &#160;&#160;&#160;&#160;ChipFamily18FxxQ43 = 16101
</simpara><simpara>    &#160;&#160;&#160;&#160;ChipFamily18FxxQ41 = 16102
</simpara><simpara>    &#160;&#160;&#160;&#160;ChipFamily18FxxK42 = 16103
</simpara><simpara>    &#160;&#160;&#160;&#160;ChipFamily18FxxK40 = 16104
</simpara><simpara>    &#160;&#160;&#160;&#160;ChipFamily18FxxQ40 = 16105
</simpara><simpara>    &#160;&#160;&#160;&#160;ChipFamily18FxxQ84 = 16106
</simpara><simpara>    &#160;&#160;&#160;&#160;ChipFamily18FxxK83 = 16107
</simpara><simpara>    &#160;&#160;&#160;&#160;ChipFamily18FxxQ83 = 16108
</simpara><simpara>    &#160;&#160;&#160;&#160;ChipFamily18FxxQ71 = 16109
</simpara><simpara>    &#160;&#160;&#160;&#160;ChipFamily18FxxQ20 = 16110
</simpara><simpara>    &#160;&#160;&#160;&#160;ChipFamily18FxxQ24 = 16111</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
</section>
<section xml:id="_compiler_options">
<title>Compiler Options</title>
<simpara>This is the Compiler Options section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="__option_explicit">
<title>#Option Explicit</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option explicit</screen>
<simpara>This option ensures that all variables are dimensioned in the user program.  The scope is the user code only and no other code space like .h or include files.</simpara>
<simpara><literal>#option explicit</literal> requires all variables,including bytes, in the user program to be defined.</simpara>
<simpara>Variables can be defined and not used within your user program.  Unused variables will not allocate memory.</simpara>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16f877a

    'Example command
    #option explicit

    dim myuserflag as byte

    myuserflag = true</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_variable_lifecycle">Variable Lifecycle</link></simpara>
</section>
<section xml:id="__option_noconfig">
<title>#Option NoConfig</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option NoConfig</screen>
<simpara>This option will prevent the generated assembler from generating _Config items.</simpara>
<simpara><literal>#option NoConfig</literal> is used when using a bootloader.</simpara>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16f877a

    'Example command
    #option NoConfig

    'User Code......</screen>
</section>
<section xml:id="__option_bootloader">
<title>#Option Bootloader</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option bootloader <emphasis>address</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>#option bootloader</literal> prevents the overwriting of any pre-loaded bootloader code, vectors, etc. below the specified address. The GCBASIC code will start at specified <literal><emphasis>address</emphasis></literal>.</simpara>
<simpara>A bootloader is a program that stays in the microcontroller and communicates with the PC, typically through the serial interface. The bootloader receives a user program from the PC and writes it in the flash memory, then launches this program in execution. Bootloaders can only be used with those microcontrollers that can write their flash memory through software.</simpara>
<simpara>The bootloader itself must be written into the flash memory with an external programmer.</simpara>
<simpara>In order for the bootloader to be launched after each reset, a <literal>goto bootloader</literal> instruction must exist somewhere in the first 4 instructions; There are two types of bootloaders, some that require that the user reallocate the code and others that by themselves reallocate the first 4 instructions of the user program to another location and execute them when the bootloader exits.</simpara>
<simpara>The diagram below shows the architecture of a bootloader. The left hand is the operation of the instructions without a bootloader. The right hand shows the initial instruction of goto the bootoader, then, when the bootloader has initialised the execution of the start code.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/optionbootloaderb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>See <link xlink:href="https://sourceforge.net/projects/tinypicbootload/files/">example bootload software.</link></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #option bootloader 0x800</screen>
</section>
<section xml:id="__option_nocontextsave">
<title>#Option NoContextSave</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option NoContextSave</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Interrupts can occur at almost any time, and may interrupt another command as it runs. To ensure that the interrupted command can continue properly after the interrupt, some temporary variables (the context) must be saved.
Normally GCBASIC will do this automatically, but in some cases it may be necessary to prevent this. If porting some existing assembly code to GCBASIC, or creating a bootloader using GCBASIC that will call another program,</simpara>
<simpara><literal>NoContextSave</literal> can be used to prevent the context saving code from being added automatically.</simpara>
<simpara>Be very careful using this option - it is very easy to cause random corruption of variables. If creating your own context saving code, you may need to save several variables. These are:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>For Microchip PIC microcontrollers 12F/16F: W, STATUS, PCLATH</simpara>
</listitem>
<listitem>
<simpara>For Microchip PIC microcontrollers 12F1/16F1/18F: W, STATUS, PCLATH, PCLATU, BSR</simpara>
</listitem>
<listitem>
<simpara>For Atmel AVR microcontrollers: All 32 registers</simpara>
</listitem>
</orderedlist>
<simpara>Other variables may also need to be saved, depending on what commands are used inside the interrupt handler.   Everything that is saved will also need to be restored manually when the interrupt handler finishes.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ' This shows an example that could be used by a bootloader to call some application code.

    ' The application code must deal with context save and restore
    ' Suppose that application code starts at location 0x100, with interrupt vector at 0x108

    'Chip model
    #chip 18F2620

    'Do not save context automatically
    #option NoContextSave

    'Main bootloader routine
    Set PORTB.0 On
    'Do other stuff to make this an actual bootloader and not a trivial example
    'Transfer control to application code
    goto 0x100

    'Interrupt routine - this will be placed at the interrupt vector
    Sub Interrupt
        'If any interrupt occurs, jump straight to application interrupt vector
        goto 0x108
    End Sub</screen>
</section>
<section xml:id="__option_nolatch">
<title>#Option NoLatch</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option nolatch</screen>
<simpara>This option disables PORTx to LATx redirection.</simpara>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>The GCBASIC compiler will  redirect all I/O pin writes from PORTx to LATx registers on 16F1/18F Microchip PIC microcontrollers.</simpara>
<simpara>The Microchip PIC mid-range microcontrollers use a sequence known as <emphasis role="strong">Read-Modify-Write</emphasis> (RMW) when changing an output state  (1 or 0) on a pin.  This can cause unexpected behavior under certain circumstances.</simpara>
<simpara>When your program changes the state on a specific pin, for example RB0 in PORTB, the microcontroller first <emphasis role="strong">READs</emphasis> all 8 bits of the PORTB register which represents the states of all 8 pins in PORTB (RB7-RB0).</simpara>
<simpara>The microcontroller then stores this data in the MCU. The bit associated with RB that you&#8217;ve commanded to <emphasis role="strong">MODIFY</emphasis>  is changed, and then the microcontrollers <emphasis role="strong">WRITEs</emphasis> all 8 bits (RB7- RB0) back to the PORTB register.</simpara>
<simpara>During the first reading of the PORT register, you will be reading the actual state of the physical pin.  The problem arises when an output pin is loaded in such a way that its logic state is affected by the load. Instances of such loads are LEDs without current-limiting resistors or loads with high capacitance or inductance.</simpara>
<simpara>For example, if a capacitor is attached between pin and ground, it will take a short while to charge when the pin is set to 1.  On the other hand, if the capacitor is discharged, it acts like a short circuit, forcing the pin to '0' state,  and, therefore, a read of the PORT register will return 0, even though we wrote a 1 to it.</simpara>
<simpara>GCBASIC resolves this issue using the LATx register when writing to ports, rather than using PORTx registers.  Writing to a LATx register is equivalent to writing to a PORTx register, but readings from LATx registers return
the data value held in the port latch, regardless of the state of the actual pin. So, for reading use PORTx.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>You can use the <literal>#option nolatch</literal> if problems occur with compiler redirection.</simpara>
</section>
<section xml:id="__option_required">
<title>#Option Required</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option REQUIRED PIC|AVR CONSTANT %message.dat entry%
    #option REQUIRED PIC|AVR CONSTANT "Message string"</screen>
<simpara>This option ensure that the specific CONSTANT exists within a library to ensure a specific capability is available with the microcontroller.</simpara>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>This is for developers only.</simpara>
<simpara>This will cause the compiler check the CONSTANT is a non zero value.&#160;&#160;If the CONSTANT does not exist it will be treated as a zero value.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example tests the CONSTANT <literal>CHIPUSART</literal> for both the PIC and AVR microcontrollers.&#160;&#160;If the CONSTANT is zero or does not exist then the string will be displayed as an error message.</simpara>
<screen>    #option REQUIRED PIC CHIPUSART "Hardware Serial operations. Remove USART commands to resolve errors."
    #option REQUIRED AVR CHIPUSART "Hardware Serial operations. Remove USART commands to resolve errors."</screen>
</section>
<section xml:id="__option_volatile">
<title>#Option Volatile</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option volatile `bit`</screen>
<simpara>This option ensure port setting are glitch-free.</simpara>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>#option volatile bit where bit is an IO bit, like PORTB.0 appended.</simpara>
<simpara>This will cause the compiler to set the bit without any glitches when copying a value from another variable, but will increase code size slightly.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16f877a

    'Example command
    #option volatile portb.0

    dir portb.0 out

    do forever

      portb.0 = !portb.0

    loop</screen>
</section>
<section xml:id="__option_reservehighprog">
<title>#Option ReserveHighProg</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option ReserveHighProg [words]</screen>
<simpara>This option reserves program memory to be kept free at the top end of memory.&#160;&#160;This useful for HEF/SAF or bootloaders.</simpara>
<simpara>The option provided a reservation for the memory region that is normally assumed to be available to
the compiler for the application code storage. In order to avoid any possible conflict (overlapping code
and data usage), it is important to reserve the devices pecific memory range by using the compiler option (shown above)
in the project configuration.</simpara>
<simpara>Using the <literal>#option ReserveHighProg [words] exposes the constant `ChipReserveHighProg</literal> in the user program.</simpara>
<simpara><emphasis role="strong">Defined constants</emphasis></simpara>
<simpara>The compiler has constants that can be used as an alternative to the parameter <literal>[words]</literal>.&#160;&#160;</simpara>
<simpara>The compiler constants are:  OPTIBOOT, OPTIBOOTUSB, ARDUINONANO, ARDUINOMEGA2560 or TINYBOOTLOADER.</simpara>
<simpara>Where these constants equate to:</simpara>
<screen>    OPTIBOOT        = 1024
    OPTIBOOTUSB     = 2048
    ARDUINONANO     = 1024
    ARDUINOMEGA2560 = 1024
    TINYBOOTLOADER  = 128
    TINYBOOTLOADER128  = 128
    TINYBOOTLOADER125  = 256</screen>
<simpara><emphasis role="strong">Examples 1</emphasis></simpara>
<simpara>In the example below the region 0x1F80 to 0x1FFF (flash block for a
PIC16F1509 microcontroller) has been removed from the default space available for code storage using the compiler option.</simpara>
<screen>    'Set chip model
    #chip 16F1509

    'Directive
    #option ReserveHighProg 128</screen>
<simpara><emphasis role="strong">Examples 2</emphasis></simpara>
<simpara>In the example below the bootloader area of Program Memory is protected.</simpara>
<simpara>This will ensure the program size does not overwrite the OptiBoot bootloader.</simpara>
<screen>    'Set chip model
    #chip MEGA328P

    'Directive
    #option ReserveHighProg OPTIBOOT</screen>
</section>
</section>
<section xml:id="_using_assembler">
<title>Using Assembler</title>
<simpara>This is the Using Assembler section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_assembler_overview">
<title>Assembler Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>You can use microcontroller assembler code within your GCBASIC code.</simpara>
<simpara>You can put the assembler code inline in with your source code. The assembler code will be passed through to the assembly file associated with your project.</simpara>
<simpara>GCBASIC should recognise all of the commands in the microcontroller datasheet.</simpara>
<simpara>The commands should be in lower case, this is good practice, and have a space or tab in front of the command.</simpara>
<simpara>Even if the mnemonics are not being formatted properly, <literal>gputils/MPASM</literal> should still be capable of assembling the source code.</simpara>
<simpara>Format commands as follows:</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  btfsc STATUS,Z
  bsf PORTB,1</screen>
</section>
</section>
<section xml:id="_macros">
<title>Macros</title>
<simpara>This is the Macros section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_macros_overview">
<title>Macros Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>You can use macros within your GCBASIC code.</simpara>
<simpara>Macros are similar to subroutines. But during compilation, everything is inserted inline. This may increase the code size slightly, but it also reduces stack usage.</simpara>
<simpara>Parameters are handled in a similar way to how constants are handled, so there is a lot more freedom when passing things in to a macro. (Unlike subs or functions, where everything must be stored in a variable.)</simpara>
<simpara>For example, for <literal>PulseOut</literal> one parameter is a pin, and the other is a time length like "500 ms". Neither of those parameters could be stored in a variable, but passing them in as macro parameters is possible.</simpara>
<simpara><emphasis role="strong">Demonstration Program:</emphasis></simpara>
<screen>    'PulseOut Macro
    macro Pulseout (Pin, Time)
        Set Pin On
        Wait Time
        Set Pin Off
    end macro</screen>
</section>
<section xml:id="_example_macros">
<title>Example Macros</title>
<simpara>This is the Example Macros section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_measuring_a_pulse_width">
<title>Measuring a Pulse Width</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>The demonstration shows how a macro can be used to optimised code by compiling code inline.</simpara>
<simpara>When the measurement of a pulse width to sub-microsecond resolution is required for instance measuring the high or low pulse width of an incoming analog signal a comparator can be combined with a timer to provide the pulse width.</simpara>
<simpara>Microchip PIC has published a "Compiled Tips 'N Tricks Guide" that explains how to do certain tasks with Microchip PIC 8-bit microcontrollers.</simpara>
<simpara>This guide provides the steps that need to be taken to perform the task of measuring a pulse width.  The guide provides guidance on measuring a pulse width using Timer 1 and the CCP module.  This guidance was used as the basis for the GCBASIC port the shown below.  The guidance was generic and in this example polling the CCP flag bit was more convenient than using an interrupt.</simpara>
<simpara>In this demonstration shown below, a 16F1829 microcontroller operating at 32 Mhz uses the internal oscillator. The demonstration code is based on a macro that uses Timer1 and CCP4. However, any of the four CCP modules could be used, the 16F1829 microcontroller has four CCP module.</simpara>
<simpara>The timer resolution of this method uses a timer Prescaler of 1:8 and a microcontroller frequency of 32 MHz giving a pulse width resolution is 1ms.  With the timer Prescaler of 1:2 and the microcontroller frequency of 32MHz the resolution is 250 ns.</simpara>
<simpara>The accuracy is dependent upon the accuracy of the system clock, but oscilliscope measurements have show an accuracy of +- 1us from 3us to 1000us.</simpara>
<simpara>In this demonstration the following was implemented</simpara>
<itemizedlist>
<listitem>
<simpara>Using GCBASIC a macro to ensure the generated assembler is inline to ensure the timing is consistent and no sub routines are called.</simpara>
</listitem>
<listitem>
<simpara>Another microcontroller was used to generate the pulses to be measured</simpara>
</listitem>
<listitem>
<simpara>A TEK THS730A oscilliscope was used to measure/verify pulse widths</simpara>
</listitem>
<listitem>
<simpara>A 4x20 LDC module with an I2C Backpack was used to display the results. However, as an alternative, a serial output<?asciidoc-br?>
to a terminal program to view the data could be used</simpara>
</listitem>
</itemizedlist>
<simpara>This demonstration could be improved by adding code to poll the TIMER1 overflow flag. If the timer overflows, then either no
pulse was detected or the pulse was longer than allowed by the prescaler/OSC settings. In this case, return a value of zero for pulse width.</simpara>
<simpara><emphasis role="strong">Usage:</emphasis></simpara>
<simpara>To get positive pulse width use:</simpara>
<screen>    PULSE_IN</screen>
<simpara><literal>PULSE_IN</literal> returns a global word variable Pulse_Width</simpara>
<simpara><emphasis role="strong">Demonstration Program:</emphasis></simpara>
<screen>    #Chip 16F1829, 32
    #CONFIG MCLRE = OFF

    'Setup Software I2C
    #define I2C_MODE Master
    #define I2C_DATA PORTA.2
    #define I2C_CLOCK PORTC.0
    #define I2C_DISABLE_INTERRUPTS ON

    'Set up LCD
    #define LCD_IO 10
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_SPEED FAST
    #define LCD_Backlight_On_State  1
    #define LCD_Backlight_Off_State 0

    'Note: This example can be improved by adding code to poll the 'TIMER1 overflow flag. IF the timer overflows, then either no 'pulse was detected or the pulse was longer than allowed by the 'prescaler/OSC settings. In this case, return a value of zero 'for pulse width.

    CLS
    PRINT "Pulse Width Test"
    DIM PULSE_WIDTH AS WORD
    DIR PORTC.6 IN

    'Setup timer
    'Set timer1 using PS1_2 gives 250ns resolution
    InitTimer1 OSC, PS1_8
    wait 1 s
    CLS

    'MAIN PROGRAM LOOP
    DO
      PULSE_IN    'Call the Macro to get positive pulse width.
      Locate 0,0
      PRINT Pulse_Width
      PRINT "    "
      wait 1 s
    Loop

    MACRO PULSE_IN  'Measure Pulse Width
      'Configure CCP4  to Capture rising edge
       CCP4CON = 5   'Set to 00000101
       StartTimer 1
       CCP4IF = 0

       do while CCP4IF = 0    'Wait for rising edge
       loop

       TMR1H = 0: TMR1L = 0   'Clear timer to zero
       CCP4IF = 0             'Clear flag


       'Configure CCP4 to Capture Falling Edge
       CCP4CON = 4  '00000100'

       do while CCP4IF = 0   'Wait for falling edge
       loop

       StopTimer 1            'Stop the time
       Pulse_Width = TIMER1   'Save the timer value
       CCP4IF = 0             'Clear the CCP4 flag
    End MACRO</screen>
<simpara>Also see <link linkend="_macros_overview">Macros Overview</link></simpara>
</section>
<section xml:id="_implementing_a_method_with_a_pin_name_as_a_parameter">
<title>Implementing a method with a Pin name as a parameter</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>A constant such as a Pin name cannot be passed to a sub routine or a function.  This is a constraint of GCBASIC.</simpara>
<simpara>A macro can be used to implement a method of passing a constant to reusable code section.</simpara>
<simpara>The example shown below implements a button press routine and takes an input port constant and prints the result on an LCD display.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
A macro will use more program memory as the macro will be compiled as inline code. Therefore, for every use of the macro will use additional program memory - the same amount of program memory for each call to the macro.</simpara>
<simpara><emphasis role="strong">Demonstration Program:</emphasis></simpara>
<screen>    #chip 16F877a, 16
    #define Button PORTC.1    ' Switch on PIN 14 via 10K pullup resistor
    DIR Button In
    wait 1 sec

    'USART settings
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    ;======== MAIN PROGRAM LOOP ================
    HSerPrint "Button Test"
    HSerPrintCRLF 2
    Do
       Test_button ( button )
    Loop
    ;==========================================

    Macro Test_button (Button)
       if Button = ON then
          wait 10 ms          'debounce
          ButtonCount = 0


           Do While Button = On
               Wait 10 ms
               ButtonCount += 1
           Loop


           if ButtonCount &gt; 5  then
               if ButtonCount &gt; 50 then   'Long push
                   hserprint "Long push"
               else                       'Short push
                   hserprint "Short push"
               end if
               HSerPrintCRLF
           end if
           wait 1 s
       end if
    End Macro</screen>
<simpara>Also see <link linkend="_macros_overview">Macros Overview</link></simpara>
</section>
</section>
</section>
<section xml:id="_example_programs">
<title>Example Programs</title>
<section xml:id="_flashing_leds_and_an_interrupt">
<title>Flashing LEDs and an Interrupt</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This code implements four flashing LEDs. This is based on the Microchip PIC Low Pin Count Demo Board.</simpara>
<simpara>The example program will blink the four red lights in succession. Press the Push Button Switch, labeled <emphasis role="strong">SW1</emphasis>, and the sequence of the lights will reverse. Rotate the potentiometer, labeled <emphasis role="strong">RP1</emphasis>, and the light sequence will blink at a different rate.</simpara>
<simpara>This implements an interrupt for the switch press, reads the analog port and set the LEDs.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    #chip 18F14K22, 32
    #config MCLRE_OFF

    'Works with the low count demo board

    'Set the input pin direction
        #define SwitchIn1 PORTa.3
        Dir SwitchIn1 In

    #define LedPort PORTc
        DIR PORTC OUT

    'Setup the ADC  pin direction
        Dir PORTA.0 In
        dim ADCreading as word


    'Setup the input pin direction
        #define IntPortA PORTA.1
        Dir IntPortA In

    'Variable and constants
        #define intstate as byte
        intstate = 0
        #define minwait 1

        dim ccount as byte
        dim leddir as byte

        ccount = 8
        leddir = 0

        SET PORTC = 15
        WAIT 1 S

        SET PORTC = 0

    'Setup the Interrupt
        Set IOCA.3 on
        Dir porta.3 in
        On Interrupt PORTABCHANGE Call Setir

    'Set initial LED direction
        setLedDirection

    DO FOREVER


        INTON
        ADCreading = ReadAD10(AN0)
        if ADCreading &lt; minwait then ADCreading = minwait

        'Set LEDs
        Set PortC = ccount
        wait ADCreading ms

        if leddir = 0 then
          rotate ccount left simple
          'Restart LED position
          if ccount = 16 then
              ccount = 128
          end if

        end if

        if leddir = 1 then
          rotate ccount Right simple
          'Restart LED position
          if ccount = 128 then
            ccount = 8
          end if

        end if
        'Reset interrupt - this may be been reset so set to zero so interrupt can operate.
        intstate = 0

    Loop


    'Interrupt routine.
    sub Setir

        if IntPortA  = 0 and intstate = 0 then
          intstate = 1
          wait while SwitchIn1 = 0
          setLedDirection
        end if


    end sub

    sub setLedDirection

      'Set LED values
      select case leddir

        case 0
          leddir = 1
          ccount  = 8

        case 1
          leddir = 0
          ccount = 1

        end select

    End Sub</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_interrupts">Interrupts</link>, <link linkend="_readad10">ReadAD10</link></simpara>
</section>
<section xml:id="_flashing_led_with_timing_parameters">
<title>Flashing LED with timing parameters</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This is an example of how to define a subroutine.</simpara>
<simpara>When called, this subroutine will blink an LED for the number of times and duration as determined by the input parameters.</simpara>
<simpara>The syntax of the subroutine is:</simpara>
<screen>    ' Flash_LED (numtimes, OnTime, (optional) OffTime)
    ' Where numtimes is from 1 - 255 and OnTime/OffTime is
    ' from 0 - 65535 ms. If OffTime is not entered, then
    ' OffTime = OnTime.

    Sub Flash_LED (in numtimes, in OnTime as WORD, Optional OffTime as WORD = OnTime)
        repeat numtimes
            set LED on
            wait OnTime ms
            set LED OFF
            wait OffTime ms
        end repeat
    End Sub</screen>
<simpara>Shown below is a working example program using a Microchip PIC 18F25K22.</simpara>
<simpara>Change Settings/PORTS as needed for other Chips.</simpara>
<simpara>Connect an LED to the LED pin via a 1K series resistor.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    #chip 18F25K22, 16
    #define LED PORTC.1       'Led on PIN 14 via 1K resistor
    DIR LED OUT
    wait 1 sec

    ;======== MAIN PROGRAM LOOP ================
    Do
       Flash_LED ( 3,250 )        '3 Flashes 250 ms equal on/off time
       Wait 2 Sec
       Flash_LED ( 5,250,500 )    '5 flashes On 250 ms / off 500 ms
       Wait 2 Sec
       Flash_LED ( 10,100 )       '10 rapid flashes
       Wait 2 Sec
    Loop
    ;==========================================

    Sub Flash_LED (in numtimes, in OnTime as WORD, optional OffTime as word = OnTime)
        repeat numtimes
            set LED on
            wait OnTime ms
            set LED OFF
            wait OffTime ms
        end repeat
    End Sub</screen>
</section>
<section xml:id="_generate_accurate_pulses">
<title>Generate Accurate Pulses</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>PulseOut</literal> Command is a reliable method for generating pulses if accuracy is not critical,
the <literal>PulseOut</literal> command uses a calculation of the clock to speed for the timing .</simpara>
<simpara>If you need better accuracy and resolution then an alternative approach is required.</simpara>
<simpara>To generate pulses in the 100 us to 2500 us range with an accuracy of +- 1us over this range is practical using the approach shown in this example.</simpara>
<simpara>This example code works on a midrange PIC16F690 operating at 8Mhz.
However, it should work on any Microchip PIC microcontroller, but may need some minor modifications.</simpara>
<simpara><emphasis role="strong">Usage:</emphasis></simpara>
<screen>    Pulse_Out_us ( word_value )</screen>
<simpara><emphasis role="strong">How It Works:</emphasis></simpara>
<simpara><literal>Timer1</literal> is loaded with a preset value based upon the variable passed to the sub routine.
The timer (<literal>Timer1</literal>) is started and the pulse pin (the output pin) is set high.
When <literal>Timer1</literal> overflows the Timer1 interrupt flag bit (<literal>TMR1IF</literal>) is set.  This causes the program to
exit a polling loop and set the pulse Pin off. Then, <literal>Timer1</literal> is stopped and <literal>TMRIF</literal> flag is cleared and the sub routine exits.</simpara>
<simpara>This method supports delays between 5 us and 65535 us and uses Timer1.</simpara>
<simpara><emphasis role="strong">Test Results:</emphasis></simpara>
<simpara>These tests were completed using a Saleae Logic Analyzer.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Pulse setting</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Time Results</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Pulse_Out_us (2500)</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>2501.375 us</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Pulse_Out_us (1000)</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>1000.750 us</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Pulse_Out_us (100)</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>100. 125 us</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Pulse_Out_us (10)</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>10.125 us</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Pulse_Out_us with less then 4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Unreliable results</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    ;**************************************
    ; Code:  Output an accurate pulse
    ; Author: William Roth 03/13/2021
    ;**************************************

    #chip 16F690,8

    ; ---- Define Hardware settings
    ; ---- Define I2C settings - CHANGE PORTS AS REQUIRED
    #define I2C_MODE Master
    #define I2C_DATA PORTB.4
    #define I2C_CLOCK PORTB.6
    #define I2C_DISABLE_INTERRUPTS ON

    ; ---- Set up LCD - Using I2C LCD Backpack
    #define LCD_IO 10
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_I2C_Address_1 0x4e ; default to 0x4E
    ; ----  May need to use SLOW or MEDIUM if your LCD is a slower device.
    #define LCD_SPEED Medium
    #define LCD_Backlight_On_State  1
    #define LCD_Backlight_Off_State 0

    CLS
    ; ---- USART settings
    #define USART_BAUD_RATE 38400
    #define USART_TX_BLOCKING
    DIR PORTB.7 OUT

    ; ---- Setup Pulse parameters
    #define PulsePin PORTC.4
    Dim Time_us As WORD
    Dir PulsePin Out     'Pulsout pin
    Set PulsePin off

    ; ---- Setup Timer
    InitTimer1 Osc, PS1_2  'For 8Mhz Chip
    'InitTimer1 Osc, PS1_4, 'For 16 Mhz Chip
    TMR1H = 0: TMR1L = 0   'Clear timer1
    TMR1IF = 0  'Clear timer1 int flag
    TMR1IE = on 'Enable timer1 Interrupt (Flag only)

    ' **** This is the MAIN loop *****
    Do
        PULSE_OUT_US (2500)  'Measured as 2501.375 us
        wait 19 ms
        Pulse_Out_US (1000)  'Measured as 1000.750 us
        wait 19 ms
        Pulse_Out_US (100)   'Measured as 100.125 us
        wait 19 ms
        Pulse_Out_US (10)    'Measured as 10.125 us
        Wait 19 ms
    loop

    SUB PULSE_OUT_US (IN Variable as WORD)
    TMR1H = 65535 - Variable_H      'Timer 1 Preset High
    TMR1L = (65535 - Variable) + 4  'Timer 1 Preset Low
    Set TMR1ON ON                'Start timer1
    Set PulsePin ON               'Set Pin high
    Do While TMR1IF = 0      'Wait  for Timer1 overflow
        Loop
    Set PulsePin off          ' Pin Low
    Set TMR1ON OFF            ' Stop timer 1
    TMR1IF = 0             'Clear the Int flag
    END SUB</screen>
<simpara>Also see <link linkend="_pulseout">PulseOut</link></simpara>
</section>
<section xml:id="_graphical_lcd_demonstration">
<title>Graphical LCD Demonstration</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This demonstration code shows the set of commands supported by GCBASIC.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F877a,16

    #include &lt;glcd.h&gt;

    'Setup the GLCD
    #Define glcd_rw PORTD.3       'RW pin on LCD
    #Define glcd_reset PORTD.4    'Reset pin on LCD
    #Define glcd_cs1 PORTD.1      'CS1, CS2 can be reversed
    #Define glcd_cs2 PORTD.2      'CS1, CS2 are be reversed
    #Define glcd_rs PORTD.5       'D/I pin on LCD
    #Define glcd_enable PORTD.4   'E pin on LCD
    #Define glcd_db0 PORTB.0  'D0
    #Define glcd_db1 PORTB.1  'D1
    #Define glcd_db2 PORTB.2  'D2
    #Define glcd_db3 PORTB.3  'D3
    #Define glcd_db4 PORTB.4  'D4
    #Define glcd_db5 PORTB.5  'D5
    #Define glcd_db6 PORTB.6  'D6
    #Define glcd_db7 PORTB.7  'D7 on LCD

    'Specify the type of GLCD
    #define GLCD_TYPE GLCD_TYPE_KS0108
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 64
    #define GLCD_PROTECTOVERRUN

    wait 1 s
    GLCDCLS
    GLCDPrint 0, 1, "GCBASIC "
    wait 1 s
    GLCDCLS

    rrun = 0
    dim msg1 as string * 16

    do forever

      GLCDCLS
      Box 18,30,28,40
      Line 0,0,127,63
      Line 0,63,127,0
      wait 1 s

      FilledBox 18,30,28,40
      wait 1 s

      GLCDCLS

        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        Circle(10,10,10,1)              'upper left
        Circle(117,10,10,1)             'upper right
        Circle(63,31,10,1)              'center
        Circle(63,31,20,1)              'center
        Circle(10,53,10,1)              'lower left
        Circle(117,53,10,1)             'lower right
        wait 1 s

        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        FilledCircle(10,10,10,1)         'upper left
        FilledCircle(117,10,10,1)        'upper right
        FilledCircle(63,31,10,1)         'center
        FilledCircle(63,31,20,1)         'center
        FilledCircle(10,53,10,1)         'lower left
        FilledCircle(117,53,10,1)        'lower right
        wait 1 s

        GLCDCLS
        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        Circle(10,0,10,1)                 'upper left
        Circle(117,0,10,1)                'upper right
        Circle(63,31,10,1)                'center
        Circle(63,31,20,1)                'center
        Circle(10,63,10,1)                'lower left
        Circle(117,63,10,1)               'lower right
        wait 1 s

        GLCDCLS
        GLCDDrawString 0,10,"Hello" 'Print Hello
        wait 1 s
        GLCDDrawString 0,10, "ASCII #:"    'Print ASCII #:
        Box 18,30,28,40                    'Draw Box Around ASCII Character
        for char = 0x30 to 0x39            'Print 0 through 9
          GLCDDrawString 16, 20 , Str(char)+"  "
          GLCDdrawCHAR 20, 30, char
          wait 250 ms
        next
        line 0,50,127,50                    'Draw Line using line command
        for xvar = 0 to 80                  'Draw line using Pset command
            pset xvar,63,on
        next
        FilledBox 18,30,28,40               'Draw Box Around ASCII Character '
        wait 1 s
        GLCDCLS
        GLCDDrawString 0,10,"End  "
        wait 1 s
        GLCDCLS

        workingGLCDDrawChar:
        dim gtext as string
        gtext = "KS0108"

            for xchar = 1 to gtext(0)      'Print 0 through 9
              xxpos = (1+(xchar*6)-6)
              GLCDDrawChar xxpos , 0 , gtext(xchar)
           next

        GLCDDrawString  1, 9, "GCBASIC @2021"
        GLCDDrawString  1, 18,"GLCD 128*64"
        GLCDDrawString  1, 27,"Using GLCD.H from GCB"
        GLCDDrawString  1, 37,"Using GLCD.H GCB@2021"
        GLCDDrawString  1, 45,"GLCDDrawChar method"
        GLCDDrawString  1, 54,"Test Routines"

        wait 1 s
        GLCDCLS

        msg1 = "Run = " +str(rrun)
        rrun++
        GLCDPrint 0, 3, msg1
        wait 1 s
        GLCDCLS

    loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_graphical_lcd_demonstration">Graphical LCD Demonstration</link>,
<link linkend="_glcdcls">GLCDCLS</link>,
<link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>,
<link linkend="_glcdreadbyte">GLCDReadByte</link>,
<link linkend="_glcdwritebyte">GLCDWriteByte</link>, <link linkend="_pset">Pset</link></simpara>
</section>
<section xml:id="_infrared_remote">
<title>InfraRed Remote</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>GCBASIC support interfacing with IR remote controls. The header file contains explanations, for both hardware and software.</simpara>
<simpara>This has been tested on many different IR sensors, and different remote controls.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<simpara>The example is expected to work with most any IR sensor running at a 38 kHz carrier frequency.</simpara>
<screen>    ;This demo prints the device number and key number sent by
    ;a Sony compatible IR remote control unit to an LCD

    ;Thomas Henry --- 4/23/2014

    #chip 16F88, 8                    ;PIC16F88 running at 8 MHz
    #config mclr=off                  ;reset handled internally
    #include &lt;SonyRemote.h&gt;           ;include the header file

    ;----- Constants

    #define LCD_IO      4             ;4-bit mode
    #define LCD_WIDTH 20              ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RS      PortB.2       ;pin 8 is Register Select
    #define LCD_Enable  PortB.3       ;pin 9 is Enable
    #define LCD_DB4     PortB.4       ;DB4 on pin 10
    #define LCD_DB5     PortB.5       ;DB5 on pin 11
    #define LCD_DB6     PortB.6       ;DB6 on pin 12
    #define LCD_DB7     PortB.7       ;DB7 on pin 13
    #define LCD_NO_RW   1             ;ground RW line on LCD

    #define IR_DATA_PIN PortA.0       ;sensor on pin 17

    ;----- Variables

    dim device, button as byte

    ;----- Program

    dir PortA in                      ;A.0 is IR input
    dir PortB out                     ;B.2 - B.6 for LCD

    do
      readIR_Remote(device, button)   ;wait for button press

      cls                             ;show device code
      print "Device: "
      print device

      locate 1,0
      print "Button: "                ;show button code
      print button

      wait 10 mS                      ;ignore any repeats
    loop                              ;repeat forever</screen>
<simpara><emphasis role="strong">See also <link linkend="_sonyremote_h">SonyRemote.h</link></emphasis>.</simpara>
<section xml:id="_sonyremote_h">
<title>SonyRemote.h</title>
<simpara><emphasis role="strong">Explanation:</emphasis>
Sony IR Remote Control Library for GCBASIC</simpara>
<simpara>This include file will let you easily read and use the infrared signals from a Sony compatible television remote control. In particular, the remote control transmits a pulse modulated signal, the sensor detects this, and the subroutine in this header file decodes the signal, returning two numbers: one representing the device (television, VCR, DVD, tuner, etc.), while the the other returns the key which has been depressed (VOL+, MUTE, channel numbers 0 through 9, etc.).</simpara>
<simpara>This has been tested and confirmed with a fixed remote control purchased surplus for $2.00 from All Electronics, as well as an universal remote control, set to Sony mode.</simpara>
<simpara>Moreover it has also been tested with a Panasonic IR sensor and a Vishay sensor, both purchased surplus for about fifty cents.</simpara>
<simpara>Every combination performed well, and it is probably the case that most any garden variety 38 kHz IR sensor will work. The only tricky bit is making sure you get the pinout for your sensor correct, search out the datasheet for whichever device you use.</simpara>
<simpara>There are only three pins: Ground Vcc Data</simpara>
<simpara>It is essential to filter the power applied to the Vcc pin. Do this by connecting a 100 ohm resistor from the +5V power supply to the Vcc pin, and bridge the pin to ground with a 4.7uF electrolytic capacitor.</simpara>
<simpara>The Data pin requires a 4.7k pullup resistor.</simpara>
<simpara>There is only one constant required of the calling program. It indicates which port line the IR sensor is connected to. For example,</simpara>
<screen>    #DEFINE IR_DATA_PIN PORTA.0</screen>
<simpara>There is one subroutine:</simpara>
<screen>    readIR_Remote(IR_rem_dev, IR_rem_key)</screen>
<simpara>The values returned are, respectively, the device number mentioned earlier and the key that is currently pressed. Both are byte values.</simpara>
<simpara>Seventeen local bytes are consumed, and two bytes are used for the output parameters. That&#8217;s a grand total of nineteen bytes required when invoking this subroutine.</simpara>
<simpara><emphasis role="strong">Header File</emphasis></simpara>
<screen>    sub readIR_Remote(out IR_rem_dev as byte, out IR_rem_key as byte)
      dim IR_rem_count, IR_rem_i as byte
      dim IR_rem_width(12) as byte            ;pulse width array

      do
        IR_rem_count = 0                      ;wait for start bit
        do while IR_DATA_PIN = 0              ;measure width (active low)
          wait 100 uS                         ;24 X 100 uS = 2.4 mS
          IR_rem_count++
        loop
      loop while IR_rem_count &lt; 20            ;less than this so wait

      for IR_rem_i = 1 to 12                  ;read/store the 12 pulses
        do
          IR_rem_count = 0
          do while IR_DATA_PIN = 0            ;zero = 6 units = 0.6 mS
            wait 100 uS                       ;one = 12 units = 1.2 mS
            IR_rem_count++
          loop
        loop while IR_rem_count &lt; 4           ;too small to be legit

        IR_rem_width(IR_rem_i) = IR_rem_count ;else store pulse width
      next IR_rem_i

      IR_rem_key = 0                          ;command built up here
      for IR_rem_i = 1 to 7                   ;1st 7 bits are the key
        IR_rem_key = IR_rem_key / 2           ;shift into place
        if IR_rem_width(IR_rem_i) &gt; 10 then   ;longer than 10 mS
           IR_rem_key = IR_rem_key + 64       ;so call it a one
        end if
      next

      IR_rem_dev = 0                          ;device number built up here
      for IR_rem_i = 8 to 12                  ;next 5 bits are device number
        IR_rem_dev = IR_rem_dev / 2
        if IR_rem_width( IR_rem_i ) &gt; 10 then
           IR_rem_dev = IR_rem_dev + 16
        end if
      next
    end sub</screen>
</section>
</section>
<section xml:id="_midpoint_circle_algorithm">
<title>Midpoint Circle Algorithm</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>GCBASIC can draw circles using the midpoint circle algorithm. The midpoint circle algorithm determines the points needed for drawing a circle.
The algorithm is a variant of <link xlink:href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham&#8217;s line algorithm</link>, and is thus sometimes known as Bresenham&#8217;s circle algorithm, although not actually invented by <link xlink:href="https://en.wikipedia.org/wiki/Jack_Elton_Bresenham">Jack E. Bresenham</link>.</simpara>
<simpara>The example program below show the midpoint circle algorithm within GCBASIC.</simpara>
<simpara><emphasis role="strong">Example Output on GLCD Device:</emphasis></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/midpointcirclealgorithmb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<screen>    'Midpoint Circle algorithm
    'Chip model
    #chip 16F886, 8             ;PIC16F88 running at 8 MHz
    #config mclr=off            ;reset handled internally

    #include &lt;glcd.h&gt;

    ;----- Constants

    ;Pinout is shown for the LCM12864H-FSB-FBW
    ;graphical LCD available from Amazon.

    ;       +5V                 ;LCD pin 1
    ;       ground              ;LCD pin 2
    ;       Vo = wiper of pot   ;LCD pin 3
    #define GLCD_DB0 PORTB.0    ;LCD pin 4
    #define GLCD_DB1 PORTB.1    ;LCD pin 5
    #define GLCD_DB2 PORTB.2    ;LCD pin 6
    #define GLCD_DB3 PORTB.3    ;LCD pin 7
    #define GLCD_DB4 PORTB.4    ;LCD pin 8
    #define GLCD_DB5 PORTB.5    ;LCD pin 9
    #define GLCD_DB6 PORTB.6    ;LCD pin 10
    #define GLCD_DB7 PORTB.7    ;LCD pin 11
    #define GLCD_CS2 PORTA.0    ;LCD pin 12
    #define GLCD_CS1 PORTA.1    ;LCD pin 13
    #define GLCD_RESET PORTA.2  ;LCD pin 14
    #define GLCD_RW PORTA.3     ;LCD pin 15
    #define GLCD_RS PORTA.4     ;LCD pin 16
    #define GLCD_ENABLE PORTA.6 ;LCD pin 17
    ;       Vee = pot low side  ;LCD pin 18
    ;       backlight anode     ;LCD pin 19
    ;       backlight cathode   ;LCD pin 20

    #define GLCD_TYPE GLCD_TYPE_KS0108
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 64

    ;----- Program

    Do forever

        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        Circle(10,10,10,0)            ;upper left
        Circle(117,10,10,0)           ;upper right
        Circle(63,31,10,0)            ;center
        Circle(63,31,20,0)            ;center
        Circle(10,53,10,0)            ;lower left
        Circle(117,53,10,0)           ;lower right
        GLCDDrawString 30,54,"PIC16F886"

    loop</screen>
</section>
<section xml:id="_i2c_master_hardware">
<title>I2C Master Hardware</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This program demonstrates how to read and write data from an EEPROM device using the serial protocal called I2C.<?asciidoc-br?></simpara>
<simpara>This program uses the hardware I2C module within the microcontroller.  If your microcontroller does not have a hardware I2C module then please use the software I2C GCBASIC ibrary.</simpara>
<simpara>This program has three sections.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Read a single byte from the EEPROM</simpara>
</listitem>
<listitem>
<simpara>Write and read a page of 64 bytes to and from the EEPROM, and</simpara>
</listitem>
<listitem>
<simpara>Finally display the contents of the EEPROM.</simpara>
</listitem>
</orderedlist>
<simpara>This program has an interrupt driven serial handler to capture and manage input from a serial terminal.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    'Change the microcontroller, frequency and config to suit your needs.
    #chip 16F1937, 32
    #config MCLRE_ON

    'Required Library to read and write to an EEPROM
    #include &lt;I2CEEPROM.h&gt;

    ' Define I2C settings - CHANGE PORTS
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA PORTC.4
    #define HI2C_CLOCK PORTC.3
    'I2C pins need to be input for SSP module for Microchip PIC devices.
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in
    'I2C MASTER MODE
    HI2CMode Master

    ' THIS CONFIG OF THE SERIAL PORT WORKS WITH max232 THEN TO PC
    ' USART settings
    #define USART_BAUD_RATE 9600
    Dir PORTc.6 Out
    Dir PORTc.7 In
    #define USART_DELAY OFF
    #define USART_TX_BLOCKING
    wait 500 ms

    'Create a Serial Interrupt Handler
    On Interrupt UsartRX1Ready Call readUSART

    ' Constants etc required for the serial Buffer Ring
    #define BUFFER_SIZE 32
    #define bkbhit (next_in &lt;&gt; next_out)
    ' Required Variables for the serial Buffer Ring
    Dim buffer(BUFFER_SIZE)
    Dim next_in as byte: next_in = 1
    Dim next_out as byte: next_out = 1


    Dim syncbyte as Byte
    wait 125 ms

    ' Read ONE byte from the EEPROM
    dim DeviceID as byte
    dim EepromAddress, syscounter as word
    #define EEpromDevice 0xA0

    'Master Main Loop
    location = 0
    'Define our array
    dim outarray(64), inarray(64)

    do
        HSerPrintCRLF 2
        HSerPrint "Commence Array Write and Read"
        'Populate the array
        for tt = 1 to 64
            outarray(tt) = tt
        next

        'Library write call is: eeprom_wr_array(device_number, page_size, address, array_name, number_of_bytes)
        eeprom_wr_array(EEpromDevice, 64, location, outarray, 64)


        'Library read call is: eeprom_rd_array(device_number, address, array_name, number_of_bytes)
        eeprom_rd_array(EEpromDevice, location, inarray, 64)

        'Show results of the read of the I2C EEPROM
        HSerPrintCRLF 2
        for tt = 1 to 64

            if outarray(tt) &lt;&gt; inarray(tt) then
               Hserprint "!"
               HSerPrint inarray(tt)
            else
               HSerPrint inarray(tt)
            end if
            HSerPrint ","
        next

        HSerPrintCRLF 2
        HSerPrint "Commence Write and Read a single byte":HSerPrintCRLF
        HSerPrint "Read value should be "
        HSerPrint  str(location):HSerPrintCRLF
        HSerPrint "Read = "
        'Use library to write and read from the I2C EEPROM
        eeprom_wr_byte (EEpromDevice, location, location)
        eeprom_rd_byte (EEpromDevice, location, bbyte )

        HSerPrint bbyte
        location++
        HSerPrintCRLF 2

        'Show the connnected I2C devices on the Serial terminal.
        HI2CDeviceSearch
        HSerPrint "Commence Dump of the EEPROM"
        validateEEPROM
    Loop
    End


    'Show the attached I2C devices
    sub HI2CDeviceSearch
        'Assumes serial is operational
        HSerPrintCRLF
        HSerPrint "I2C Device Search"
        HSerPrintCRLF 2
        for deviceID = 0 to 255
        HI2CStart
        HI2CSend ( deviceID )
        if HI2CAckPollState = false then
            HSerPrint   "ID: 0x"
            HSerPrint   hex(deviceID)
            HSerSend 9
            testid = deviceID | 1
            select case testid
                 case 49
                      Hserprint "DS2482_1Channel_1Wire Master"
                 case 65
                      Hserprint "Serial_Expander_Device"
                 Case 73
                       Hserprint "Serial_Expander_Device"
                 case 161
                      Hserprint "EEProm_Device_Device"
                 case 163
                      Hserprint "EEProm_Device_Device"
                 case 165
                      Hserprint "EEProm_Device_Device"
                 case 167
                      Hserprint "EEProm_Device_Device"
                 case 169
                      Hserprint "EEProm_Device_Device"
                 case 171
                      Hserprint "EEProm_Device_Device"
                 case 173
                      Hserprint "EEProm_Device_Device"
                 case 175
                      Hserprint "EEProm_Device_Device"
                 case 209
                      Hserprint "DS1307_RTC_Device"
                 case 249
                      Hserprint "FRAM_Device"
                 case else
                      Hserprint "Unknown_Device"
            end select
            HI2CSend ( 0 )
            HSerPrintCRLF
        end if
        HI2CStop
        next
        HSerPrint   "End of Device Search"
        HSerPrintCRLF 2
    end sub

    'Validation EEPROOM code
    sub validateEEPROM
        EepromAddress = 0
        HSerPrintCRLF 2
        HSerPrint "Hx"
        HSerPrint hex(EepromAddress_h)
        HSerPrint hex(EepromAddress)
        HSerPrint " "

        for EepromAddress = 0 to 0xffff
            'Read from EEPROM using a library function
            eeprom_rd_byte EEPromDevice, EepromAddress, objType

            HSerPrint hex(objType)+" "
            if ((EepromAddress+1) % 8 ) = 0 then
                HSerPrintCRLF
                HSerPrint "Hx"
                syscounter = EepromAddress + 1
                HSerPrint hex(syscounter_h)
                HSerPrint hex(syscounter)
                HSerPrint " "
            end if
            'Has serial data been received
            if bkbhit then
                syschar = bgetc
                select case syschar
                    case 32
                        do while bgetc = 32
                        loop
                    case else
                        HSerPrintCRLF
                        HSerPrint "Done"
                        exit sub
                end select
            end if
        next
        HSerPrintCRLF
        HSerPrint "Done"
    end Sub


    ' Start of Serial Support functions
    ' Required to read the serial port
    ' Assumes serial port has been initialised
    Sub readUSART
        buffer(next_in) = HSerReceive
        temppnt = next_in
        next_in = ( next_in + 1 ) % BUFFER_SIZE
        if ( next_in = next_out ) then  ' buffer is full!!
            next_in = temppnt
        end if
    End Sub

    ' Serial Support functions
    ' Get characters from the serial port
    function bgetc
        wait while !(bkbhit)
        bgetc = buffer(next_out)
        next_out=(next_out+1) % BUFFER_SIZE
    end Function</screen>
</section>
<section xml:id="_i2c_slave_hardware">
<title>I2C Slave Hardware</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This program demonstrates how to control and display using a LCD the code for the keypad.</simpara>
<simpara>This program can be adapted. This program uses the hardware I2C module within the microcontroller.  If your microcontroller does not have a hardware I2C module then please use the software I2C GCBASIC library for most microcontrollers.</simpara>
<simpara>This program also has an interrupt driven I2C handler to manage the I2C from the Start event.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    'Code for the keypad and LCD Microchip PIC microcontroller on the Microlab board v2
    'microcontroller is responsible for:
    ' - Reading keypad
    ' - Displaying data on LCD
    ' - communication with main Microchip PIC microcontroller via I2C
    ' - providing 5 keypad lines to main Microchip PIC microcontroller (for compatibility)
    ' - receiving remote control signals for button and keypad

    'This code has support for two keypad layouts. This is one possible layout:
    '0123
    '4567
    '89AB
    'CDEF
    'And this is the other possible layout:
    '123A
    '456E
    '789D
    'A0BC
    'Select the keypad layout by uncommenting one of these lines:
    '#define KEYPAD_KEYMAP KeypadMap0123
    #define KEYPAD_KEYMAP KeypadMap123F

    'Chip and config
    #chip 16F882, 8

    'Ports connected to keypad
    'Column ports need pullups, hence columns are on PORTB for built in weak pullups
    #define KEYPAD_COL_1 PORTB.4
    #define KEYPAD_COL_2 PORTB.5
    #define KEYPAD_COL_3 PORTB.6
    #define KEYPAD_COL_4 PORTB.7
    #define KEYPAD_ROW_1 PORTA.4
    #define KEYPAD_ROW_2 PORTA.3
    #define KEYPAD_ROW_3 PORTA.2
    #define KEYPAD_ROW_4 PORTA.1

    'Ports connected to LCD
    #define LCD_IO 4
    #define LCD_WIDTH 20                ;specified lcd width for clarity only.  20 is the default width
    #define LCD_RW PORTA.7
    #define LCD_RS PORTA.6
    #define LCD_Enable PORTA.5
    #define LCD_DB4 PORTA.4
    #define LCD_DB5 PORTA.3
    #define LCD_DB6 PORTA.2
    #define LCD_DB7 PORTA.1
    #define BACKLIGHT PORTA.0

    'Button port (for remote control)
    #define BUTTON PORTB.0

    'Keypad ports connected to main Microchip PIC microcontroller
    'These are disabled when KeyoutDisabled = true
    #define KEYOUT_A PORTC.5
    #define KEYOUT_B PORTC.2
    #define KEYOUT_C PORTC.1
    #define KEYOUT_D PORTC.0
    #define KEYOUT_DA PORTB.1

    'I2C ports
    #define I2C_DATA PORTC.4
    #define I2C_CLOCK PORTC.3

    'RS232/USART settings
    'To do if/when remote support needed

    'Initialise
    Dir KEYOUT_A Out
    Dir KEYOUT_B Out
    Dir KEYOUT_C Out
    Dir KEYOUT_D Out
    Dir KEYOUT_DA Out

    Dir BACKLIGHT Out
    Dir BUTTON In 'Is an output, turn off by switching pin to Hi-Z

    'Initialise I2C Slave
    'I2C pins need to be input for SSP module
    Dir I2C_DATA In
    Dir I2C_CLOCK In
    HI2CMode Slave
    HI2CSetAddress 128

    'Buffer for incoming I2C messages
    'Each message takes 4 bytes
    Dim I2CBuffer(10)
    BufferSize = 0
    OldBufferSize = 0

    'Set up interrupt to process I2C
    On Interrupt SSP1Ready Call I2CHandler

    'Enable weak pullups on B4-7 (keypad col pins)
    NOT_RBPU = 0
    WPUB = b'11110000'

    'Key buffers
    '255 indicates no key, other value gives currently pressed key
    RemoteKey = 255
    OutKey = 255
    KeyoutDisabled = False 'False if KEYOUT lines used to send key

    'Main loop
    Do

        'Read keypad, send value
        CheckPressedKeys
        SendKeys

        'Check for I2C messages
        ProcessI2C

    Loop

    'This keymap table is for this arrangement:
    '0123
    '4567
    '89AB
    'CDEF
    Table KeypadMap0123
        3
        7
        11
        15
        2
        6
        10
        14
        1
        5
        9
        13
        0
        4
        8
        12
    End Table

    'This keymap table is for this arrangement:
    '123F
    '456E
    '789D
    'A0BC
    Table KeypadMap123F
        15
        14
        13
        12
        3
        6
        9
        11
        2
        5
        8
        0
        1
        4
        7
        10
    End Table

    Sub CheckPressedKeys
        'Subroutine to:
        ' - Read keypad
        ' - Check remote keypress
        ' - Decide which key to output

        'Read keypad
        If RemoteKey &lt;&gt; 255 Then
            OutKey = RemoteKey
        Else
            EnableKeypad
            OutKey = KeypadData

        End If

    End Sub

    Sub EnableKeypad
        'Disable LCD so that keypad can be activated
        Set LCD_RW Off 'Write mode, don't let LCD write

        'Re-init keypad
        InitKeypad

    End Sub

    Sub I2CHandler
        'Handle I2C interrupt
        'SSPIF doesn't trigger for stop condition, only start!

        'If buffer full flag set, read

        Do While HI2CHasData
            HI2CReceive DataIn

            'Sending code
            If BufferSize = 0 Then
                LastI2CWasRead = False
                'Detect read address
                If DataIn = 129 Then
                    LastI2CWasRead = True

                    HI2CSend OutKey

                    KeyoutDisabled = True
                    Dir KEYOUT_A In
                    Dir KEYOUT_B In
                    Dir KEYOUT_C In
                    Dir KEYOUT_D In
                    Dir KEYOUT_DA In

                    Exit Sub
                End If
            End If

            If BufferSize &lt; 10 Then I2CBuffer(BufferSize) = DataIn
            BufferSize += 1
        Loop

    End Sub

    Sub SendKeys

        'Don't run if not using KEYOUT lines
        If KeyoutDisabled Then Exit Sub

        'Send pressed keys
        If OutKey &lt;&gt; 255 Then
            'If there is a key pressed, set output lines
            If OutKey.0 Then
                KEYOUT_A = 1
            Else
                KEYOUT_A = 0
            End If
            If OutKey.1 Then
                KEYOUT_B = 1
            Else
                KEYOUT_B = 0
            End If
            If OutKey.2 Then
                KEYOUT_C = 1
            Else
                KEYOUT_C = 0
            End If
            If OutKey.3 Then
                KEYOUT_D = 1
            Else
                KEYOUT_D = 0
            End If

            KEYOUT_DA = 1
        Else
            'If no key pressed, clear data available line to main Microchip PIC microcontroller
            KEYOUT_DA = 0
        End If

    End Sub

    Sub ProcessI2C

        If HI2CStopped Then
            IntOff

            If LastI2CWasRead Then BufferSize = 0

            If BufferSize &lt;&gt; 0 Then
                OldBufferSize = BufferSize
                BufferSize = 0
            End If
            IntOn
        End If

        If OldBufferSize &lt;&gt; 0 Then

            CmdControl = I2CBuffer(1)

            'Set backlight
            If CmdControl.6 = On Then
                Set BACKLIGHT On
            Else
                Set BACKLIGHT Off
            End If

            'Set R/S bit
            LCD_RS = CmdControl.4

            'Send bytes to LCD
            LCDDataBytes = CmdControl And 0x0F
            If LCDDataBytes &gt; 0 Then
                For CurrSendByte = 1 To LCDDataBytes
                    LCDWriteByte I2CBuffer(LCDDataBytes + 1)
                Next
            End If
            'LCDWriteByte I2CBuffer(2)

            OldBufferSize = 0
        End If

    End Sub</screen>
</section>
<section xml:id="_rgb_led_control">
<title>RGB LED Control</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This program demonstrates how to drive an RGB LED to create 4096 different colors. Each of the three elements (red, green and blue) responds to 16 different levels. A value of 0 means the element never turns on, while a value of 15 means the element never shuts off. Values in between these two extremes vary the pulse width.</simpara>
<simpara>This program is an interrupt driven three channel PWM implementation.</simpara>
<simpara>The basic carrier frequency depends upon the microcontroller clock speed. For example, with an 8 MHz clock, the LED elements are modulated at about 260 Hz. The interrupts are generated by Timer 0. With an 8 MHz clock they occur about every 256 uS. The interrupt routine consumes about 20 uS.</simpara>
<simpara>Do not forget the current limiting resistors to the LED elements. A value of around 470 ohms is typical, but you may want to adjust the individual values, to balance the color response.</simpara>
<simpara>In this demonstration, three potentiometers are used to set the color levels using the slalom technique.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    ;----- Configuration
    #chip 16F88, 8                ;PIC16F88 running at 8 MHz
    #config mclr=off              ;reset handled internally

    ;----- Constants
    #define LED_R PortB.0         ;pin to red element
    #define LED_G PortB.1         ;pin to green element
    #define LED_B PortB.2         ;pin to blue element
    ;----- Variables
    dim redValue, greenValue, blueValue, ticks as byte
    ;----- Program
    dir PortA in                  ;three pots for inputs
    dir PortB out                 ;the LED outputs
    on interrupt Timer0Overflow call update
    initTimer0 Osc, PS0_1/2
    do
      redValue = readAD(AN0)/16   ;red -- 0 to 15
      greenValue = readAD(AN1)/16 ;green -- 0 to 15
      blueValue = readAD(AN2)/16  ;blue -- 0 to 15
    loop

    Sub update                    ;interrupt routine
      ticks++                     ;increment master timekeeper
      if ticks = 15 then          ;start of the count
        ticks = 0
        if redValue &lt;&gt; 0 then     ;only turn on if nonzero
          set LED_R on
        end if
        if greenValue &lt;&gt; 0 then
          set LED_G on
        end if
        if blueValue &lt;&gt; 0 then
          set LED_B on
        end if
      end if
      if ticks = redValue then    ;time to turn off red?
        set LED_R off
      end if
      if ticks = greenValue then  ;time to turn off green?
        set LED_G off
      end if
      if ticks = blueValue then   ;time to turn off blue?
        set LED_B off
      end if
    end sub</screen>
</section>
<section xml:id="_serial_rs232_buffer_ring">
<title>Serial/RS232 Buffer Ring</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This program demonstrates how to create a serial input buffer ring.</simpara>
<simpara>The program receives a character into the buffer and sends back.  Try sending large volumes of characters&#8230;&#8203;..</simpara>
<simpara>This program program uses an interrupt event to capture the incoming byte value and place in the buffer ring. When a byte is received the buffer ring is incremented to ensuer the next byte is handled correctly.</simpara>
<simpara>Testing <literal>bkbhit</literal> will set to True when a byte has been received. Reading the function <literal>bgetc</literal> will return the last byte received.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<simpara>This demonstration program will support up to 256 bytes. For a larger buffer change the variables to words.</simpara>
<screen>    #chip 16F1937


    ' Add PPS if appropiate for your chip
    ' [change to your config] This is the config for a serial terminal

    ' assumes USART1
    ' turn on the RS232 and terminal port.
    ' Define the USART settings
    #DEFINE USART_BAUD_RATE 9600

    'This assumes you are using an ANSI compatible terminal.  Use PUTTY.EXE it is very easy to use.

    '   Main program

    'Wait for terminal to settle
    wait 3 s

    'Create the supporting variables
    Dim next_in As Byte
    Dim next_out As Byte
    Dim syncbyte As Byte
    Dim temppnt As Byte

    ' Constants etc required for Buffer Ring
    #DEFINE BUFFER_SIZE 8
    #DEFINE bkbhit (next_in &lt;&gt; next_out)

    'Define the Buffer
    Dim buffer( BUFFER_SIZE - 1 ) 'we will use element 0 in the array as part of out buffer

    'Call init the buffer
    InitBufferRing

    HSerSend 10
    HSerSend 13
    HSerSend 10
    HSerSend 13
    HSerPrint "Started: Serial between two devices"
    HSerSend 10
    HSerSend 13


    'Get character(s) and send back
    Do

        ' Do we have data in the buffer?
        if bkbhit then

            'Send the next character in the buffer, exposed via the function `bgetc` back the terminal
            HSerSend bgetc

        end if

    Loop

    'Supporting subroutines

    Sub readUSART

        buffer(next_in) = HSerReceive
        temppnt = next_in
        next_in = ( next_in + 1 ) % BUFFER_SIZE
        If ( next_in = next_out ) Then  ' buffer is full!!
            next_in = temppnt
        End If

    End Sub

    Function bgetc
        Dim local_next_out as Byte    'maintain a local copy of the next_out variable to ensure it does not change when an Interrupt happens
        local_next_out = next_out
        bgetc = buffer(local_next_out)
        local_next_out=(local_next_out+1) % BUFFER_SIZE
        INTOFF
        next_out = local_next_out
        INTON
    End Function




    Sub InitBufferRing

        'Set the buffer to the first address
        next_in = 0
        next_out = 0
        'Interrupt Handler - some have RCIE and some have U1RXIE, so handle
        #IFDEF BIT( RCIE )
            On Interrupt UsartRX1Ready Call readUSART
        #ENDIF
        #IFDEF BIT( U1RXIE )
            On Interrupt UART1ReceiveInterrupt Call readUSART
        #ENDIF
        #IFDEF AVR
            On Interrupt UsartRX1Ready Call readUSART
        #ENDIF

    End Sub</screen>
</section>
<section xml:id="_trigonometry_circle">
<title>Trigonometry Circle</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>GCBASIC can draw circles on a Graphical LCD device using GCBASIC library functions.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/trigonometrycirclesb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    ;Circle and filled circle commands on a graphic LCD.
    ;This uses the 2-place trigonometric routines found in the include file.

    ;----- Configuration
    #CHIP 16F88, 8              ;PIC16F88 RUNNING AT 8 MHZ
    #CONFIG MCLR=OFF            ;RESET HANDLED INTERNALLY
    #OPTION EXPLICIT
    #DEFINE USELEGACYFORNEXT    ;WILL ENSURE THE OLD FOR-NEXT Loop is used just to save some memory as this is a very simple FOR-NEXT loop

    #INCLUDE &lt;GLCD.H&gt;
    #INCLUDE &lt;TRIG2PLACES.H&gt;

    ;----- Constants

    ;Pinout is shown for the LCM12864H-FSB-FBW
    ;graphical LCD available from Amazon.

    ;       +5V                 ;LCD pin 1
    ;       ground              ;LCD pin 2
    ;       Vo = wiper of pot   ;LCD pin 3
    #define GLCD_DB0 PORTB.0    ;LCD pin 4
    #define GLCD_DB1 PORTB.1    ;LCD pin 5
    #define GLCD_DB2 PORTB.2    ;LCD pin 6
    #define GLCD_DB3 PORTB.3    ;LCD pin 7
    #define GLCD_DB4 PORTB.4    ;LCD pin 8
    #define GLCD_DB5 PORTB.5    ;LCD pin 9
    #define GLCD_DB6 PORTB.6    ;LCD pin 10
    #define GLCD_DB7 PORTB.7    ;LCD pin 11
    #define GLCD_CS2 PORTA.0    ;LCD pin 12
    #define GLCD_CS1 PORTA.1    ;LCD pin 13
    #define GLCD_RESET PORTA.2  ;LCD pin 14
    #define GLCD_RW PORTA.3     ;LCD pin 15
    #define GLCD_RS PORTA.4     ;LCD pin 16
    #define GLCD_ENABLE PORTA.6 ;LCD pin 17
    ;       Vee = pot low side  ;LCD pin 18
    ;       backlight anode     ;LCD pin 19
    ;       backlight cathode   ;LCD pin 20

    #define GLCD_TYPE GLCD_TYPE_KS0108
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 64


    ;----- Variables

    dim cx, cy, edge, jj as byte
    dim ii as word

    ;----- Program

    myCircle(10,10,10)
    ;upper left
    myCircle(117,10,10)                 ;upper right
    myCircleFilled(63,31,10)            ;center
    myCircle(63,31,20)                  ;center
    myCircleFilled(10,53,10)            ;lower left
    myCircleFilled(117,53,10)           ;lower right

    ;----- Subroutines

    sub myCircle(cenX, cenY, rad)
        ;Center of circle = (cenX,cenY), radius = rad

        for ii = 0 to 358 step 2                 ;every two degrees
            cx = cenX -((10*rad*cos(ii))/100+5)/10  ;properly rounded x value
            cy = cenY -((10*rad*sin(ii))/100+5)/10  ;properly rounded y value

            ;the following ignores the pixel if off the screen
            if (cx&gt;=0 and cx&lt;=GLCD_WIDTH and cy&gt;=0 and cy&lt;=GLCD_HEIGHT) then
            Pset(cx, cy, on)
            end if
        next ii
    end sub

    sub myCircleFilled(cenX, cenY, rad)
        ;Center of circle = (cenX,cenY), radius = rad

        for ii = 0 to 358 step 2
            cx = cenX -((10*rad*cos(ii))/100+5)/10
            cy = cenY -((10*rad*sin(ii))/100+5)/10
            edge = 2 * cenX - cx                  ;compute right edge

            for jj = cx to edge                    ;fill entire line, uses legacy for next permitting CX to be less than edge
                if (jj&gt;=0 and jj&lt;=GLCD_WIDTH and cy&gt;=0 and cy&lt;=GLCD_HEIGHT) then
                    Pset(jj,cy,on)
                end if
            next jj
        next ii
    end sub</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_trigonometry_sine_cosine_and_tangent">Trigonometry</link>, <link linkend="_circle">Circle</link>, <link linkend="_filledcircle">FilledCircle</link>,</simpara>
</section>
</section>
<section xml:id="_graphical_gcbasic">
<title>Graphical GCBASIC</title>
<simpara>This is the Graphical GCBASIC section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_code_documentation">
<title>Code Documentation</title>
<simpara>Documenting GCBASIC is key for ease of use. This section is intended for developers only.</simpara>
<simpara>Documenting is the ability to read some extra information from comments in libraries.</simpara>
<simpara>Some comments that start with ''' have a special meaning, and will be displayed as tooltips or as information to the user. These tooltips helps inexperienced users to use extra libraries.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>GCBASIC uses ; (a semicolon) to show comments that it has placed automatically, and // or ' to indicate ones that the user has placed.  When loading a program, it will not load any that start with a ; (semi-colon).  The use of comments do not impact the users  but it worthy of note.</simpara>
</listitem>
<listitem>
<simpara>As for code documentation comments, GCBASIC will load information about subroutines/functions and any hardware settings that need to be set.</simpara>
</listitem>
<listitem>
<simpara>For subroutines, a line before the Sub or Function line that starts with ''' will be used as a tooltip when the user hovers over the icon. A line that starts with '''@ will be interpreted differently, depending on what comes after the @. '''@param ParamName Parameter Description will add a description for the parameter. For a subroutine, this will show in the Icon Settings panel under the parameter when the user has selected that icon.</simpara>
</listitem>
<listitem>
<simpara>For functions, it will show at the appropriate time in the Parameter Editor wizard. '''@return Returned value applies to functions only. It will be displayed in the Parameter Editor wizard when the user is asked to choose a function.  An example of all this is given in srf04.h:</simpara>
</listitem>
</orderedlist>
<screen>    '''Read the distance to the nearest object
    '''@param US_Sensor Sensor to read (1 to 4)
    '''@return Distance in cm
    Function USDistance(US_Sensor) As Word</screen>
<orderedlist numeration="arabic" startingnumber="5">
<listitem>
<simpara>If a subroutine or command is used internally in the library, but GCBASIC users should not see it, it can be hidden by placing '''@hide before the Sub or Function line. Another example from srf04.h:</simpara>
</listitem>
</orderedlist>
<screen>    '''@hide
    Sub InitUSSensor</screen>
<simpara>These should hopefully be pretty easy to add. It is also possible to add Hardware Settings. A particular setting can be defined anywhere in the file, using this syntax:</simpara>
<screen>    '''@hardware condition, display name, constant, value type</screen>
<simpara>These comments informs GCBASIC when to show the setting. Normally, this is All, but sometimes it can include a constant, a space and then a comma separated list of values. display name is a friendly name for the setting to display. constant is the constant that must be set, and valuetype is the type that will be accepted for that constant&#8217;s value. To allow for multiple value types, enter a list of types with a | between them.</simpara>
<orderedlist numeration="arabic" startingnumber="6">
<listitem>
<simpara>Allowed types are:</simpara>
</listitem>
</orderedlist>
<screen>    free - Allows anything
    label - Allows any label
    condition - Allows a condition
    table - Allows a data table
    bit - Allows any bit from variable, or bit variable
    io_pin - Allows an IO pin
    io_port - Allows an entire IO port
    number - Allows any fixed number or variable
    rangex:y - Allows any number between x and y
    var - Allows any variable
    var_byte - Allows any byte variable
    var_word - Allows any word variable
    var_integer - Allows any integer variable
    var_string - Allows any string variable
    const - Allows any fixed number
    const_byte - Allows any byte sized fixed number
    const_word - Allows any word sized fixed number
    const_integer - Allows any integer sized fixed number
    const_string - Allows any fixed string
    byte - Allows any byte (fixed number or variable)
    word - Allows any word
    integer - Allows any integer
    string - Allows any string
    array - Allows any array</screen>
<orderedlist numeration="arabic" startingnumber="7">
<listitem>
<simpara>When the library is added the program, GCBASIC will show a new device with the name of the library file on the Hardware Settings window. The user can then set the relevant constants without necessarily needing to see any code.  Adding a GCBASIC library to GCBASIC will not result in any changes to the library. GCBASIC uses the information it reads to help edit the user&#8217;s program, but then the user&#8217;s program is passed to the compiler along with the unchanged library.</simpara>
</listitem>
<listitem>
<simpara>Hardware Settings are a bit more involved to add, but hopefully the bit of extra documentation for subroutines will be straight forward.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_windows_net_support">
<title>Windows .NET Support</title>
<simpara>From Graphical GCBASIC version 0.941 supports use on newer Windows versions without having the pre-requisite of .NET 3.5.</simpara>
</section>
</section>
<section xml:id="_gcbasic_for_linux">
<title>GCBASIC for Linux</title>
<simpara>This is the GCBASIC for Linux section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_overview_linux_operating_system">
<title>Overview - Linux Operating System</title>
<simpara><emphasis role="strong">Introduction:</emphasis>
GCBASIC can be used when using the Linux Operating System.</simpara>
<simpara>This instructions are not distribution specific, but are for Linux only (not Windows).</simpara>
<simpara><emphasis role="strong">Instructions:</emphasis>
Complete the following steps to compile and install GCBASIC for Linux:</simpara>
<orderedlist numeration="arabic" startingnumber="1">
<listitem>
<simpara>Install FreeBasic from your distributions repository or <link xlink:href="http://www.freebasic.net/wiki/CompilerInstalling">http://www.freebasic.net/wiki/CompilerInstalling</link></simpara>
</listitem>
<listitem>
<simpara>Download the "GCBASIC - Linux Distribution" from SourceForge at <link xlink:href="https://sourceforge.net/projects/gcbasic/files/">https://sourceforge.net/projects/gcbasic/files/</link></simpara>
</listitem>
<listitem>
<simpara>Unrar/unpack GCBASIC.rar to a location of your choice within your home directory (eg. within Downloads) with either a file manager or from a console.</simpara>
</listitem>
<listitem>
<simpara>From a console, change to the GCBASIC Sources in the unpacked directory:</simpara>
</listitem>
</orderedlist>
<screen>   eg. cd ~/Downloads/sources/linuxbuild/</screen>
<orderedlist numeration="arabic" startingnumber="5">
<listitem>
<simpara>Make sure that <literal>install.sh</literal> is set as executable (ie. <literal>chmod +x install.sh</literal>), and then execute: ./install.sh build</simpara>
</listitem>
<listitem>
<simpara>You will need root privileges for this step. You can switch user (su) to root, or optionally use <literal>sudo</literal>.</simpara>
</listitem>
</orderedlist>
<screen>   Execute: [sudo] ./install.sh install</screen>
<orderedlist numeration="arabic" startingnumber="7">
<listitem>
<simpara>If you su&#8217;d to root, use <literal>exit</literal> to drop back to your normal user. Then, be sure to follow the instructions given by the script for updating your path.</simpara>
</listitem>
<listitem>
<simpara>Confirm proper execution, and the version, of GCBASIC by executing: gcbasic /version</simpara>
</listitem>
</orderedlist>
<simpara>Now you can create and compile GCBASIC source files.</simpara>
<simpara><emphasis role="strong">Programming microcontrollers:</emphasis></simpara>
<simpara>To program your microcontroller with your GCBASIC created hex file, you will need additional programming and programmer software.</simpara>
<simpara>For Microchip PIC microcontroller programming, you might find what you need at: www.pickitplus.co.uk  The PICKitPlus Team provide programmers and Linux software.</simpara>
<simpara>For Atmel AVR microcontroller programming, you will need <literal>avrdude</literal>. It should be available in your distributions repository. If not, check here: <link xlink:href="http://www.nongnu.org/avrdude/">http://www.nongnu.org/avrdude/</link></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_make_asm_make_hex_and_programming_operations_using_the_provided_linux_scripts">
<title>Make ASM, Make HEX and Programming Operations using the provided Linux scripts</title>
<simpara>The scripts provided are intended to assist in the creation of the ASM file ( from a GCBASIC source file ), creation of the HEX file ( also from a GCBASIC source file ) and to support programming operations ( often called `FLASH`ing the microcontroller ).</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Script</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Usage</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>makeasm.sh</literal></simpara></entry>
<entry align="left" valign="top"><simpara>To compile the GCBASIC source program to create the ASM.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>makeasm.sh sourcefile.gcb</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>makehex.sh</literal></simpara></entry>
<entry align="left" valign="top"><simpara>To compile and asseble the GCBASIC source program to create the ASM and a microcontroller specific HEX file.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>makehex.sh sourcefile.gcb</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>flash.sh</literal></simpara></entry>
<entry align="left" valign="top"><simpara>To compile,asseble the GCBASIC source program to create the ASM and a microcontroller specific HEX file, and, then to program the microcontroller</simpara></entry>
<entry align="left" valign="top"><simpara><literal>flash.sh sourcefile.gcb</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Examples</emphasis></simpara>
<simpara>There are multiple constructs to run multiple programs on a single command line.&#160;&#160;The most common are ';' and '&amp;&amp;'</simpara>
<simpara>To run another command immadiately after running makehex.sh.&#160;&#160;Use the following:</simpara>
<screen>   makehex.sh sourcefile.gcb; anothercommand</screen>
<simpara>To run another command only if makehex.sh does not exit with an error such as a compiler error.&#160;&#160;Use the following:</simpara>
<screen>   makehex.sh sourcefile.gcb &amp;&amp; anothercommand</screen>
</section>
</section>
<section xml:id="_gcbasic_for_arm_pi">
<title>GCBASIC for ARM &amp; Pi</title>
<simpara>This is the GCBASIC for Pi section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_overview_raspberry_pi">
<title>Overview - Raspberry Pi</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>GCBASIC can be used when using the Raspberry Pi.</simpara>
<simpara>You can install the command-line version of GCBASIC on a Raspberry Pi (and similar single-board computers) and use it to compile your GCBASIC programs.</simpara>
<simpara>You can also program most PICs and AVRs using only the Pi&#8217;s GPIO pins (see <xref linkend="Programming"/>), as well as communicate with your device over the Pi&#8217;s serial port.  This makes it easy to program, modify, and communicate with a PIC or AVR using just a Pi and an SSH connection.</simpara>
<simpara>GCBASIC is not published for ARM-based computers, there is currently no pre-compiled version for ARM-based computers, so you will have to compile it from source.  The GCBASIC compiler is written in <link xlink:href="https://www.freebasic.net/">FreeBASIC</link> (an open-source version of BASIC), so you will need to first install the FreeBASIC compiler on your Pi, then use it to compile the GCBASIC compiler from its source code.  This is relatively simple.</simpara>
<simpara>FreeBASIC is not included in any of the major Linux repositories, but there is a customized version for ARMv7 boards like the Raspberry Pi on their <link xlink:href="https://users.freebasic-portal.de/stw/builds/linux-armv7a-hf-debian/">web site</link>.</simpara>
<simpara>The following procedure will work with any ARMv7 single-board computer running a Debian derivative like <link xlink:href="https://www.raspberrypi.org/downloads/raspberry-pi-os/">Raspberry Pi OS </link> or <link xlink:href="https://www.armbian.com/">Armbian</link>.  This includes the Raspberry Pi 2 and 3, and all single board computers with an Allwinner H2+ or H3 microprocessor (Orange Pi PC, Orange Pi Zero, Nano Pi R1, etc).  It has not been tested with a Raspberry Pi 4.</simpara>
<simpara><emphasis role="strong">Instructions:</emphasis></simpara>
<simpara>All commands should be performed on your Pi board, either through a remote SSH terminal or using a keyboard and monitor connected to your Pi.</simpara>
<simpara><emphasis>Installing FreeBASIC</emphasis></simpara>
<orderedlist numeration="arabic" startingnumber="1">
<listitem>
<simpara>Install FreeBASIC dependencies</simpara>
</listitem>
</orderedlist>
<screen>    $ sudo apt-get install libx11-dev libxext-dev libxpm-dev libxrandr-dev libncurses5 libncurses5-dev</screen>
<orderedlist numeration="arabic" startingnumber="2">
<listitem>
<simpara>Download the latest version FreeBASIC for ARMv7 from <link xlink:href="https://users.freebasic-portal.de/stw/builds/linux-armv7a-hf-debian/">https://users.freebasic-portal.de/stw/builds/linux-armv7a-hf-debian/</link> :</simpara>
</listitem>
</orderedlist>
<screen>    $ cd ~
    $ wget https://users.freebasic-portal.de/stw/builds/linux-armv7a-hf-debian/fbc_linux_armv7a_hf_debian_0376_2020-09-17.zip
    $ unzip fbc_linux_armv7a_hf_debian_0376_2020-09-17.zip</screen>
<orderedlist numeration="arabic" startingnumber="3">
<listitem>
<simpara>Install FreeBASIC</simpara>
</listitem>
</orderedlist>
<screen>  $ cd fbc_linux_armv7a_hf_debian/
  $ chmod +x install.sh
  $ sudo ./install.sh -i</screen>
<simpara><emphasis>Installing GCBASIC</emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Download and extract the GCBASIC sources:</simpara>
</listitem>
</orderedlist>
<screen>    $ wget "https://downloads.sourceforge.net/project/gcbasic/GCBasic%20-%20Linux%20Distribution/GCB%40Syn.rar"
    $ sudo apt install unar
    # the password when requested in the next step is "GCB"
    $ unar GCBASIC.rar
    $ cd GCBASIC/sources/linuxbuild/</screen>
<orderedlist numeration="arabic" startingnumber="2">
<listitem>
<simpara>Build and install the compiler:</simpara>
</listitem>
</orderedlist>
<screen>    $ chmod +x install.sh
    $ ./install.sh build
    $ sudo ./install.sh install</screen>
<orderedlist numeration="arabic" startingnumber="3">
<listitem>
<simpara>Verify the compiler is properly installed and view the full list of compiler options</simpara>
</listitem>
</orderedlist>
<screen>    $ gcbasic</screen>
<simpara>Now you can create and compile GCBASIC source files. For example, to compile a program you created named <literal>myprogram.bas</literal> into <literal>myprogram.hex</literal>, you could run:</simpara>
<screen>    $ gcbasic -A:GCASM -R:none -K:A -WX -V myprogram.bas</screen>
<simpara>This will:</simpara>
<itemizedlist>
<listitem>
<simpara>use GCBASIC&#8217;s internal assembler,</simpara>
</listitem>
<listitem>
<simpara>turn off report creation,</simpara>
</listitem>
<listitem>
<simpara>preserve all code in the assembly file output (useful for debugging)</simpara>
</listitem>
<listitem>
<simpara>treat warnings as errors, and</simpara>
</listitem>
<listitem>
<simpara>print compiler messages in verbose mode</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Programming</emphasis></simpara>
<simpara>To transfer your compiled .hex program files from your Pi to your microcontroller, you will need additional software.</simpara>
<simpara>For most PIC microcontrollers, you should use <link xlink:href="https://pickitplus.co.uk/Typesetter/index.php/PKCMD-Pi-Application">PICkitPlus for Pi</link>.  PICKitPlus support the widest range of PICs including the latest PICs. It is fully supported application.</simpara>
<simpara>For AVR microcontrollers, you will need <literal>avrdude</literal>. It should be available in your distribution&#8217;s repository. If not, check here: <link xlink:href="http://www.nongnu.org/avrdude/">http://www.nongnu.org/avrdude/</link> .  Instructions on how to use it can be found <link xlink:href="https://learn.adafruit.com/program-an-avr-or-arduino-using-raspberry-pi-gpio-pins/overview">here</link>.</simpara>
</section>
</section>
<section xml:id="_gcbasic_for_apple_macos">
<title>GCBASIC for Apple macOS</title>
<simpara>This is the GCBASIC for Apple macOS section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_overview_apple_macos_gcbasic">
<title>Overview - Apple macOS GCBASIC</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>The GCBASIC compiler can be used with the Apple macOS operating system. It should run on any version from Snow Leopard 10.6 and above. It is guaranteed to run on both High Sierra 10.13 and Mojave 10.14 which have been extensively tested.</simpara>
<simpara>You have a choice to make. You can either:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>download a macOS installer which will install a precompiled 64 bit binary for the GCBASIC compiler along with support files and some optional components; or</simpara>
</listitem>
<listitem>
<simpara>download, compile and install the GCBASIC compiler from the source files.</simpara>
</listitem>
</orderedlist>
<simpara>There are instructions below for both choices. If I was you, I would use the macOS GCBASIC Installer and save valuable programming time :-)</simpara>
<simpara><emphasis role="strong">Instructions for using the GCBASIC Installer</emphasis></simpara>
<orderedlist numeration="arabic" startingnumber="1">
<listitem>
<simpara>Download the GCBASIC - macOS Installer disk image (.dmg) file from <link xlink:href="https://sourceforge.net/projects/gcbasic/files/GCBasic-macOS-Installer.dmg/download">https://sourceforge.net/projects/gcbasic/files/GCBasic-macOS-Installer.dmg/download</link></simpara>
</listitem>
<listitem>
<simpara>Double click the .dmg file to mount it on your Desktop and a window will open which contains the Installer.</simpara>
</listitem>
<listitem>
<simpara>Double click the REAME_FIRST.txt file and read it for any important information you may need before proceeding.</simpara>
</listitem>
<listitem>
<simpara>Double click the GCBASIC icon and follow the installer prompts.</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">Instructions for building your own GCBASIC binary</emphasis></simpara>
<simpara>Complete the following steps to compile and install the GCBASIC compiler:</simpara>
<orderedlist numeration="arabic" startingnumber="1">
<listitem>
<simpara>Download the FreeBASIC 1.06 macOS binary compilation from: <link xlink:href="http://tmc.castleparadox.com/temp/fbc-1.06-darwin-wip20160505.tar.bz2">http://tmc.castleparadox.com/temp/fbc-1.06-darwin-wip20160505.tar.bz2</link></simpara>
</listitem>
<listitem>
<simpara>Download the GCBASIC UNIX Source Distribution from SourceForge at <link xlink:href="http://gcbasic.sourceforge.net/Typesetter/index.php/Download">http://gcbasic.sourceforge.net/Typesetter/index.php/Download</link></simpara>
</listitem>
<listitem>
<simpara>Note: the following instructions assume the distribution file is named GCBASIC-UNIX-v0_98_05.rar however the version number (v0_98_05) may change before these instructions are updated, so you may have to adjust the filename to match the version you have downloaded.</simpara>
</listitem>
<listitem>
<simpara>Unfortunately Apple replaced the gcc compiler with the clang compiler and FreeBASIC needs the real gcc due to a certain use of goto&#8230;&#8203; so, you can compile your own version of gcc following the instructions at <link xlink:href="https://solarianprogrammer.com/2017/05/21/compiling-gcc-macos/">https://solarianprogrammer.com/2017/05/21/compiling-gcc-macos/</link> or you can take the low road and just download the pre-compiled binary version from <link xlink:href="https://github.com/sol-prog/macos-gcc-binary/releases/download/v8.3/gcc-8.3.macos.tar.bz2">https://github.com/sol-prog/macos-gcc-binary/releases/download/v8.3/gcc-8.3.macos.tar.bz2</link></simpara>
</listitem>
<listitem>
<simpara>Open a Terminal window (Terminal can be found in Applications &gt; Utilities).</simpara>
</listitem>
<listitem>
<simpara>Move gcc-8.3.tar.bz2 from your Downloads directory to your Home directory by typing the following command in your Terminal window:</simpara>
</listitem>
</orderedlist>
<screen>   mv ~/Downloads/gcc-8.3.tar.bz2 ~/</screen>
<orderedlist numeration="arabic" startingnumber="6">
<listitem>
<simpara>Unpack the gcc-8.3.tar.bz2 compressed tar file by typing the following command into your Terminal window:</simpara>
</listitem>
</orderedlist>
<screen>   gzcat gcc-8.3.tar.bz2 | tar xvf -</screen>
<simpara>This will produce a new directory called gcc-8.3.</simpara>
<orderedlist numeration="arabic" startingnumber="7">
<listitem>
<simpara>You now need to link the binary gcc-8.3 to just gcc by typing the following commands into your Terminal window:</simpara>
</listitem>
</orderedlist>
<screen>   cd gcc-8.3
   ln -s gcc-8.3 gcc
   cd ..</screen>
<orderedlist numeration="arabic" startingnumber="8">
<listitem>
<simpara>Move the gcc-8.3 directory to the /usr/local/ directory by typing the following commands into your Terminal window:</simpara>
</listitem>
</orderedlist>
<screen>   sudo mv gcc-8.3 /usr/local</screen>
<simpara>Note: You will be asked for your password to execute the above command.</simpara>
<orderedlist numeration="arabic" startingnumber="9">
<listitem>
<simpara>Ensure that the Apple Developer Xcode app is installed. Xcode can be downloaded and installed from the App Store for free.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic" startingnumber="10">
<listitem>
<simpara>Ensure that the Xcode command line tools are installed by typing the following command in your Terminal window:</simpara>
</listitem>
</orderedlist>
<screen>   xcode-select --install.</screen>
<orderedlist numeration="arabic" startingnumber="11">
<listitem>
<simpara>Move the FreeBASIC compressed tar file from your Downloads directory to your home directory by typing the following command in your Terminal window:</simpara>
</listitem>
</orderedlist>
<screen>   mv ~/Downloads/fbc-1.06-darwin-wip20160505.tar.bz2 ~/</screen>
<orderedlist numeration="arabic" startingnumber="12">
<listitem>
<simpara>Unpack the FreeBASIC compressed tar file by typing these commands in your Terminal window:</simpara>
</listitem>
</orderedlist>
<screen>   gzcat fbc-1.06-darwin-wip20160505.tar.bz2 | tar xvf -</screen>
<simpara>This will produce a new directory called fbc-1.06.</simpara>
<orderedlist numeration="arabic" startingnumber="13">
<listitem>
<simpara>Move the GCBASIC compressed tar file from your Downloads directory to your home directory by typing the following command in your Terminal window:</simpara>
</listitem>
</orderedlist>
<screen>   mv ~/Downloads/GCBASIC-UNIX-v0_98_05.rar ~/</screen>
<orderedlist numeration="arabic" startingnumber="14">
<listitem>
<simpara>Unpack the GCBASIC compressed tar file by typing these commands in your Terminal window:</simpara>
</listitem>
</orderedlist>
<screen>   unrar x GCBASIC-UNIX-v0_98_05.rar</screen>
<simpara>This will produce a new directory called GCBASIC. <emphasis role="strong">Note:</emphasis> If you do not currently have the unrar program which can extract rar file archives you can download and install it for free from the App Store.</simpara>
<orderedlist numeration="arabic" startingnumber="15">
<listitem>
<simpara>Change to the GCBASIC/Sources directory by typing this command in your Terminal window:</simpara>
</listitem>
</orderedlist>
<screen>   cd ~/GCBASIC/Sources</screen>
<orderedlist numeration="arabic" startingnumber="16">
<listitem>
<simpara>Compile the GCBASIC binary (gcbasic) by typing the following command into your Terminal window:</simpara>
</listitem>
</orderedlist>
<screen>  sh DarwinBuild/build.sh</screen>
<simpara>Note 1: If you did not install the various files with the same names as in the instructions above into your Home directory, you will need to edit the build.sh script file and change the file paths and filenames to the appropriate values.</simpara>
<simpara>Note 2: You may need to alter the library and include paths in the build.sh script depending on your version of macOS (it is currently setup for the Xcode High Sierra 10.13 and Mojave 10.14 versions of macOS).</simpara>
<orderedlist numeration="arabic" startingnumber="17">
<listitem>
<simpara>Confirm the proper execution, and the version, of GCBASIC by typing the following command in the Terminal window:</simpara>
</listitem>
</orderedlist>
<screen>   gcbasic</screen>
<simpara>Now you should be able create GCB source files with your favourite editor and compile those files with the gcbasic compiler.</simpara>
<simpara><emphasis role="strong">Programming microcontrollers</emphasis></simpara>
<simpara>To program your microcontroller with your GCBASIC-created hex file, you will need additional hardware and software.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>For Microchip PIC microcontroller programming, you might find what you need at: <link xlink:href="https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120">https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120</link> and the macOS version of the <literal>pk2cmd</literal> v1.2 command line programming software.</simpara>
</listitem>
<listitem>
<simpara>For Atmel AVR microcontroller programming, you will need the <literal>avrdude</literal> programming software. Check here: <link xlink:href="http://www.nongnu.org/avrdude/">http://www.nongnu.org/avrdude/</link> for it.</simpara>
</listitem>
</orderedlist>
<simpara>Alternatively, if you use Virtual Machine software such as <emphasis>Parallels</emphasis> or <emphasis>VMWare Fusion</emphasis> to run Windows programs, you can use Windows GUI programming software.</simpara>
<itemizedlist>
<listitem>
<simpara>For Microchip, the PICKit 2 and PICkit 3 standalone GUI software or even better the PICkitPlus software (<link xlink:href="https://sourceforge.net/projects/pickit3plus/">https://sourceforge.net/projects/pickit3plus/</link>) for both the PICkit 2 (<link xlink:href="https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120">https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120</link>) and PICkit 3 (<link xlink:href="https://www.microchip.com/Developmenttools/ProductDetails/PG164130">https://www.microchip.com/Developmenttools/ProductDetails/PG164130</link>) which has fixed various bugs in those programs and been updated to program the latest Microchip 8 bit microcontrollers.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Help</emphasis></simpara>
<simpara>GCBASIC Help documentation is installed in the Documentation subdirectory in your GCBASIC directory.</simpara>
<simpara>If at any time you encounter an issue and need help, you will find it over at the friendly GCBASIC discussion forums at <link xlink:href="https://sourceforge.net/p/gcbasic/discussion/">https://sourceforge.net/p/gcbasic/discussion/</link></simpara>
</section>
</section>
<section xml:id="_gcbasic_for_freebsd">
<title>GCBASIC for FreeBSD</title>
<simpara>This is the GCBASIC for FreeBSD OS section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_overview_freebsd_gcbasic">
<title>Overview - FreeBSD GCBASIC</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>The GCBASIC compiler can be used with the FreeBSD operating system.</simpara>
<simpara><emphasis role="strong">Instructions for using the GCBASIC install.sh script</emphasis></simpara>
<simpara>Complete the following steps to compile and install the GCBASIC compiler for FreeBSD:</simpara>
<orderedlist numeration="arabic" startingnumber="1">
<listitem>
<simpara>Download one of the nightly builds of FreeBASIC 1.06 for the FreeBSD 32 bit or 64 bit binary compilation from: <link xlink:href="http://users.freebasic-portal.de/stw/builds/freebsd32/">http://users.freebasic-portal.de/stw/builds/freebsd32/</link> (32 bit) or <link xlink:href="http://users.freebasic-portal.de/stw/builds/freebsd64/">http://users.freebasic-portal.de/stw/builds/freebsd64/</link> (64 bit) The filenames are in the format fbc_freebsd[32|64]_[BuildNumber]_[Date].zip.</simpara>
</listitem>
<listitem>
<simpara>Download the GCBASIC UNIX Source Distribution from SourceForge at <link xlink:href="https://gcbasic.sourceforge.net/Typesetter/index.php/Download">https://gcbasic.sourceforge.net/Typesetter/index.php/Download</link></simpara>
</listitem>
<listitem>
<simpara>Move the FreeBASIC ZIP file from your download directory to your home directory.</simpara>
</listitem>
<listitem>
<simpara>Unzip the FreeBASIC ZIP file which will produce a new directory called <literal>fbc_freebsd[32|64]</literal>. The FreeBASIC compiler <literal>fbc</literal> is in the <literal>bin</literal> subdirectory. You should add the path to <literal>fbc</literal> to your path so that the installation script can find it.</simpara>
</listitem>
<listitem>
<simpara>Move the GCBASIC compressed tar file from your download directory to your home directory.</simpara>
</listitem>
<listitem>
<simpara>Unpack the GCBASIC compressed tar file by typing the command below. <emphasis role="strong">Note</emphasis>: the version number (v0_98_05) in the filename may change before these instructions are updated - adjust depending on the version number of the file you downloaded.</simpara>
</listitem>
</orderedlist>
<screen>   unrar x GCBASIC-UNIX-v0_98_05.rar</screen>
<simpara>This will produce a new directory called GCBASIC. <emphasis role="strong">Note:</emphasis> If you do not already have the unrar program installed you can either compile it from the ports collection or use the pkg command to install the binary and any required dependancies.</simpara>
<orderedlist numeration="arabic" startingnumber="7">
<listitem>
<simpara>Change to the <literal>GCBASIC/Sources</literal> directory.</simpara>
</listitem>
<listitem>
<simpara>Execute the FreeBSDBuild/install.sh shell script from the Sources directory.</simpara>
</listitem>
</orderedlist>
<screen>  sh FreeBSDBuild/install.sh [all | build | install]</screen>
<simpara>The build script arguments are:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>all</emphasis> - will compile <emphasis role="strong">and</emphasis> install the GCBASIC compiler and its support files.</simpara>
</listitem>
<listitem>
<simpara><emphasis>build</emphasis> - will just compile the binary for the GCBASIC compiler.</simpara>
</listitem>
<listitem>
<simpara><emphasis>install</emphasis> - will install the GCBASIC compiler and its support files.</simpara>
</listitem>
</itemizedlist>
<simpara>When choosing <emphasis>all</emphasis> or <emphasis>install</emphasis> you will be prompted for an installation directory. The default is <literal>/usr/local/gcb-[version]</literal> for which you will need to run the installation script as root. Alternatively, you can choose to install in your home directory (eg <literal>`~/bin/gcb</literal>). The installation script will automatically append the GCBASIC version so that directory would become <literal>~/bin/gcb-[version]</literal></simpara>
<orderedlist numeration="arabic" startingnumber="9">
<listitem>
<simpara>Add the directory where you installed <literal>gcbasic</literal> to your path, or use the full path to the <literal>gcbasic</literal> installation directory and confirm the proper execution, and the version, of GCBASIC by executing <literal>gcbasic</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>Now you should be able create GCB source files with your favourite editor and compile those files with the GCBASIC compiler.</simpara>
<simpara><emphasis role="strong">Programming microcontrollers</emphasis></simpara>
<simpara>To program your microcontroller with your GCBASIC-created hex file, you will need additional hardware and software.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>For Microchip PIC microcontroller programming, you might find what you need at: <link xlink:href="https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120">https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120</link> and the FreeBSD version of the <literal>pk2cmd</literal> v1.2 command line programming software.</simpara>
</listitem>
<listitem>
<simpara>For Atmel AVR microcontroller programming, you will need the <literal>avrdude</literal> programming software. avrdude can be compiled and installed from the FreeBSD ports directory or the precompiled binary and any missing dependancies can be installed using <literal>pkg install avrdude</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>Alternatively, if you use Virtual Machine software such as <emphasis>Virtual Box</emphasis> to run Windows programs, you may be able to use Windows GUI programming software.</simpara>
<itemizedlist>
<listitem>
<simpara>For Microchip, the PICKit 2 and PICkit 3 standalone GUI software or even better the PICkitPlus software (<link xlink:href="https://sourceforge.net/projects/pickit3plus/">https://sourceforge.net/projects/pickit3plus/</link>) for both the PICkit 2 (<link xlink:href="https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120">https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120</link>) and PICkit 3 (<link xlink:href="https://www.microchip.com/Developmenttools/ProductDetails/PG164130">https://www.microchip.com/Developmenttools/ProductDetails/PG164130</link>) which has fixed various bugs in those programs and been updated to program the latest Microchip 8 bit microcontrollers.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Help</emphasis></simpara>
<simpara>GCBASIC Help documentation is installed in the Documentation subdirectory in your GCBASIC directory.</simpara>
<simpara>If at any time you encounter an issue and need help, you will find it over at the friendly GCBASIC discussion forums at <link xlink:href="https://sourceforge.net/p/gcbasic/discussion/">https://sourceforge.net/p/gcbasic/discussion/</link></simpara>
</section>
</section>
<section xml:id="_gcbasic_maintenance_and_development">
<title>GCBASIC Maintenance and Development</title>
<simpara>This is the GCBASIC maintenance section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_gcbasic_maintenance">
<title>GCBASIC Maintenance</title>
<simpara><emphasis role="strong">Introduction:</emphasis>
GCBASIC maintenance covers the key processes that the developers use to maintain and build the solution.</simpara>
<simpara>These insights are not distribution specific.</simpara>
<simpara><emphasis role="strong">Solution Architecture:</emphasis>
These components are key for a complete solution:</simpara>
<orderedlist numeration="arabic" startingnumber="1">
<listitem>
<simpara>GCBASIC installer</simpara>
</listitem>
<listitem>
<simpara>GCBASIC chip specific .DAT files</simpara>
</listitem>
<listitem>
<simpara>GCBASIC Help</simpara>
</listitem>
<listitem>
<simpara>GCBASIC IDE</simpara>
</listitem>
</orderedlist>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">GCBASIC installers:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The Windows GCBASIC installer uses the <emphasis>InnoSoft</emphasis> installer with packaging completed using R2Build.<?asciidoc-br?></simpara>
<simpara>The process uses a Gold build structure.  The R2Build software creates four packages for Windows and one package for the Linux distribution.  The process is automated with automatic versioning and configuration.</simpara>
<simpara>The macOS GCBASIC installer uses the <emphasis>Packages</emphasis> installer (<link xlink:href="http://s.sudre.free.fr/Software/Packages/about.html">http://s.sudre.free.fr/Software/Packages/about.html</link>) with packaging completed using the Bourne shell script <literal>pkg2dmg.sh</literal> to create a compressed disk image file containing the installer.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">GCBASIC chip specific .DAT files:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
What are the .DAT files?</simpara>
<simpara>The DAT files are the GCBASIC representation of the capabilities of a specific microcontroller.&#160;&#160;The DAT is based upon a number of vendor sources and corrections/omissions added by the GCBASIC development team.&#160;&#160;The DAT file is exposed to the user program as a set of registers and register bits that can used to configure the program in terms of the microcontroller specifics.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The process to create the .DAT file for microcontrollers is as follows:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Step</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Obtain the MPASM *.INC or the AVR *.XML files to be used. These files determine the scope of registers and register bits.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>For Microchip only.  Place the source INC files in the ..DAT\incfiles\OrgFiles.
</simpara><simpara>Process the file using 'Preprocess.bat'. &#160;&#160; This is an AWK text processor - you will need AWK.EXE in the executing folder.
</simpara><simpara>This preprocessing will examine all the INC files in the ..DAT\incfiles\OrgFiles folder.&#160;&#160;The resulting files will be placed in the ..DAT\incfiles folder.&#160;&#160;The resulting files will have the 'BITS' section sorted in port priority - this priority ensures the bits are assigned in the target DAT in the same order every time.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>Update the database of support microcontrollers.&#160;&#160;This database contains the microcontroller configuration that GCBASIC requires as the core information for the DAT files.
</simpara><simpara>The database is called <literal>chipdata.csv</literal> or <literal>avr_chipdata.csv</literal> for Microchip and AVR respectively.
- These files are comma delimited.&#160;&#160;The first row of data specifies the field name - these field names control the chip conversion program, see later notes.&#160;&#160;
</simpara><simpara>The database fields are controlled by the GCBASIC development team and the specification of the database may change between releases to support new capabilities.
</simpara><simpara>Database fields will have the suffix of <literal>Variant</literal> such as PWMTimerVariant and SMTClockSourceVariant and are microcontroller specific configuration settings to support the various microcontroller settings.&#160;&#160;The values of these <literal>variants</literal> are determined by the examination of the microcontroller datasheets as this information is NOT specified in the source files.&#160;&#160;Variants are exposed in the user program with the prefix of Chip.&#160;&#160;If the variant is called <literal>PWMTimerVariant</literal> a constant called <literal>ChipPWMTimerVariant</literal> will be exposed in the user program.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>Update the <literal>CriticalChanges.txt</literal> file, if required.&#160;&#160;The <literal>CriticalChanges.txt</literal> file contains changes to the INC file during processing that are corrections or additions to the source files.
</simpara><simpara>The format of each line is the <literal>filename</literal> , <literal>Append (new line) or Replace</literal>, <literal>find</literal>, <literal>replace</literal>.
</simpara><simpara>Each line is comma delimited and spaces are NOT critical.  &#160;&#160;Essentially, the processing with find a partial line and replace or append the whole line.
</simpara><simpara>example:  p16lf1615.inc,R,OSCFIE          EQU  H'0007',OSFIE           EQU  H'0007'&#160;&#160;&#160;&#160;
- so, when processing p16lf1615.inc find the line OSCFIE          EQU  H'0007' and replace with OSFIE           EQU  H'0007'.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>If required.  &#160;&#160;This is not normally edited. &#160;&#160; Update the <literal>18FDefaultASMConfig.txt</literal> to set the 18f configuration defaults.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>Maintain the conversion program.&#160;&#160;The conversion program may require maintenance. &#160;&#160;The programs are written in FreeBASIC and therefore require compilation.
</simpara><simpara>An example of maintenance is a new variant field is required.&#160;&#160;The source program will need to be updated to support the new variant - simply edit the source, compile and publish.&#160;&#160;Another example is the addition of a new Interrupt - follow the same process to edit, compile and publish.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>Execute the program to convert the source files to the DAT files for Microchip or AVR.&#160;&#160;There are two programs for each architecture.
</simpara><simpara>Executing the conversion program without a parameter will process ALL the entries in the database (the csv file), passing a single parameter to the conversion program will only convert the single microcontroller.
</simpara><simpara>The conversion program will process as follows:
</simpara><simpara>a) Read the database for the chip specifics
</simpara><simpara>b) If a .DEV file or .INFO file is not present a routine called GuessDefaultConfig is invoked.  This method sets the bit(s).
</simpara><simpara>In all cases the default mask is sometimes specified for a particular config option and that is used for ASMConfig
</simpara><simpara>See the section below for the processing of a .DEV file.
</simpara><simpara>c) For all microcontrollers read the <literal>CriticalChanges.txt</literal> file and process.
</simpara><simpara>d) For 18f microcontrollers read the <literal>18FDefaultASMConfig.txt</literal>.  This simply overwrites all options stated in 18FDefaultASMConfig.TXT  and marks this in the output DAT file.
</simpara><simpara>e) Create the output DAT file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>Test and publish the DAT file(s) to the distribution as required.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">An example the processing of a .DEV</emphasis>.</simpara>
<simpara>This is the 18F25K20 example.   For this microcontroller <literal>Disabled</literal> is default:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/xml2.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara role="text-left"><?asciidoc-br?>
<?asciidoc-br?>
Where the default is selected from the Info_Type.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Prog = .  An explanation of the parameter</emphasis>.
The Prog value is measured in words. It is the same in the device specific.dat files.
<?asciidoc-br?></simpara>
<simpara>Microchip in the past have used words, but then they started using bytes on the website instead to make their chips appear to have larger capacity.
<?asciidoc-br?></simpara>
<simpara>An example: If a device has 8192 words, which is 8192 * 14 = 114688 bits, or 14336 bytes.&#160;&#160;It is an odd measurement because dividing 14336 by 14/8 to see how many instructions you can use is extra maths work within the compiler.
<?asciidoc-br?></simpara>
<simpara>The GCBASIC PROGram memory analysis are in words.
<?asciidoc-br?></simpara>
<simpara><?asciidoc-br?></simpara>
</section>
<section xml:id="_development_guide">
<title>Development Guide</title>
<simpara>There are lots of ways to contribute to the GCBASIC project: coding, testing, improving the build process and tools, or contributing to the documentation.
This guide provides information that will not only help you get started as a GCBASIC contributor,
but that you wiil find useful to refer to EVEN if you are already an experienced contributor.</simpara>
<simpara><emphasis role="strong">Need Help?</emphasis></simpara>
<simpara>The GCBASIC community prides itself on being an open, accessible, and friendly community for new participants.
If you have any difficulties getting involved or finding answers to your questions, please bring those questions to the forum via the discussion boards, where we can help you get started.</simpara>
<simpara>We know EVEN before you start contributing that getting set up to work on GCBASIC and finding a bug that is a good fit for your skills can be a challenge.
We are always looking for ways to improve this process: making GCBASIC more open, accessible, and easier to participate with.
If you are having any trouble following this documentation, or hit a barrier you cannot get around, please contact use via the discussion forum.
We will solve hurdles for new contributors and make GCBASIC better.</simpara>
<simpara>This section addresses developing libraries but this guide is appropriate to any GCBASIC development.</simpara>
<simpara>The section covers the recommended programming style, Constants, Variables, Script syntax (gotchas) and tab usage.</simpara>
<simpara><?asciidoc-hr?></simpara>
<simpara><emphasis role="strong">PROGRAMMING STYLES</emphasis></simpara>
<simpara>Indenting is standardized.</simpara>
<simpara>All scripts within a specific library should be the first major section the library.   Scripts within methods should not be used.</simpara>
<simpara>Some #defines may need to be placed before the script to provide clarity to the structure of the library.</simpara>
<screen>        #startup  startupsub

        #Define I2C_ADDRESS_1  0x4E    'The default address if user does not specify in the user program

        #SCRIPT
                ... code script
                ... code script
                ... code script
       #ENDSCRIPT</screen>
<simpara>Scripts support structures like IF &lt;CONDITION&gt; THEN &lt;ACTION&gt; END iF.
Scripts supports the &lt;condition&gt; argument that must generate a TRUE result, meaning that at a literal level, your conditional formatting rule is an If - THEN statement along the lines of “If this condition is TRUE, THEN process the &lt;ACTION&gt;.  the condition must use   logical "AND" and "OR" to test two conditions.
Using "AND" or "OR" reduces the script size, however, it is essential the the conditional test(s) are valid.  If a test fails then  you may not get the results you expect.</simpara>
<screen>        IF .. THEN

        END IF</screen>
<simpara><?asciidoc-hr?></simpara>
<simpara><emphasis role="strong">CONSTANTS</emphasis></simpara>
<simpara>A constant is a value that cannot be altered by the program during normal execution.&#160;&#160;
Within GCBASIC there are two ways to create constants.&#160; &#160;
1. with the <literal>#DEFINE</literal> instruction, or,
2. via `#SCRIPT .. #ENDSCRIPT'. ;&#160;&#160; Within a script constants can be created and changed.  A script is process that is executed  prior to the GCBASIC source program is processing the main user program.</simpara>
<simpara>An example of using <literal>#DEFINE</literal> is</simpara>
<screen>        #DEFINE TIME_DELAY_VALUE    10</screen>
<simpara>The script construct is</simpara>
<screen>        #SCRIPT
              'Create a constant
              TIME_REPEAT_VALUE  =  10
        #ENDSCRIPT</screen>
<simpara><emphasis role="strong"><emphasis>Guide for constants</emphasis></emphasis></simpara>
<simpara>The following rules are recommended.</simpara>
<simpara>1 - All CONSTANTS are capitalized</simpara>
<simpara>2 - Do not define a constant in a library unless required</simpara>
<simpara>3 - Create all library constants within a script ( see example below <emphasis role="strong">Constrain a Constant Example</emphasis> on how to constrain a constant)</simpara>
<simpara>2 - Underscores are permitted in constant names within Scripts **</simpara>
<simpara>3 - No prefix is required when a CONSTANT is PUBLIC.  A PUBLIC constant is one that the user sets or the user can use.</simpara>
<simpara>4 - Prefix CONSTANTS with SCRIPT_  when the CONSTANT is used outside of the library specific script section AND ARE NOT EXPOSED AS PUBLIC Constants.</simpara>
<simpara>5 - Prefix CONSTANTS with __ (two underscores)  when the CONSTANT is ONLY used inside the library specific script section</simpara>
<simpara>6 - For PUBLIC prefix CONSTANTS with the capability name, _ (one underscore)  and then a meaningful title, as follows
            GLCD_HEIGHT
            SPISRAM_TYPE</simpara>
<simpara>7 - All scripts within a specific library should be the first major section the library.   Scripts within methods  ( Sub, Functions) should not be used.</simpara>
<simpara>8 - All scripts within a specific library should be the first major section the library.   Scripts within methods  ( Sub, Functions) should not be used.</simpara>
<simpara>9 - Other naming recommendations.   Do not use underscores in subroutine, function or variable names</simpara>
<simpara><emphasis role="strong"><emphasis>Example script within a library</emphasis></emphasis></simpara>
<screen>          #startup  startupsub
          #DEFINE I2C_ADDRESS_1  0x4E    'Default address if user omits
          #SCRIPT
                'script code
                'script code
                'script code
          #ENDSCRIPT</screen>
<simpara><emphasis role="strong"><emphasis>Simple Example</emphasis></emphasis></simpara>
<screen>     #SCRIPT  'Calculate Delay Time
             __LCD_DELAY  = ( __LCD_TIMEPERIOD - __LCD_DELAYS) - (INT((4/ChipMHZ) * __LCD_INSTRUCTIONS))
            SCRIPT_LCD_POSTWRITEDELAY = __LCD_DELAY
            SCRIPT_LCD_CHECKBUSYFLAG = TRUE
     #ENDSCRIPT

     'usage within user code or code outside of script
     #IF SCRIPT_LCD_CHECKBUSYFLAG = TRUE
           WaitForReady    'Call subroutine to poll busy flag
           set LCD_RW OFF  'Write mode
     #ENDIF
     WAIT SCRIPT_LCDPOSTWRITEDELAY us</screen>
<simpara><emphasis role="strong"><emphasis>Create Constant Example</emphasis></emphasis></simpara>
<simpara>Background:&#160;&#160;All constants are always processed, regardless of where they are placed in the user code or library.&#160;&#160;
This includes any constant defined anywhere in user code or any library - the constant will be processed and the constant will be defined.&#160;&#160;
The only method to constrain a constant is via a script.&#160;&#160;</simpara>
<simpara>The following code segment will not constrain the constant.&#160;&#160;
The constant <literal>MYCONSTANT</literal> will be created.&#160;&#160;The <literal>#IFDEF PIC</literal> will not constrain even if an AVR or LGT chip.</simpara>
<screen>    #IFDEF PIC
          #DEFINE MYCONSTANT 255
    #ENDIF</screen>
<simpara>The recommended method follows.  The constant will only be created when a PIC.</simpara>
<screen>    #SCRIPT
      IF PIC then
          MYCONSTANT  = 255
       End IF
    #ENDSCRIPT</screen>
<simpara><emphasis role="strong"><emphasis>Constrain a Constant Example</emphasis></emphasis></simpara>
<simpara>An example to constrain a constant is to test if a user constant is define in the user source program.&#160;&#160;
In this example the constant <literal>SENDALOW</literal> is defined in user source program.&#160;&#160;</simpara>
<itemizedlist>
<listitem>
<simpara>If yes, then define the library specific constants.&#160;&#160;</simpara>
</listitem>
<listitem>
<simpara>If no, then do not define the library specific constants.&#160;&#160;</simpara>
</listitem>
</itemizedlist>
<simpara>Using the method below defines constants only when the user requires the constants assuming they have defined <literal>SENDALOW</literal> in the user source program.</simpara>
<screen>    #SCRIPT
         IF SENDALOW then
                NONE = 0 : ODD = 1 : EVEN = 2 : NORMAL = 0 : INVERT = 1
                WAITFORSTART = 128 : SERIALINITDELAY = 5
         END IF

         IF SENDALOW then
                NONE = 0 : ODD = 1 : EVEN = 2 : NORMAL = 0 : INVERT = 1
                WAITFORSTART = 128 : SERIALINITDELAY = 5
         END IF

         IF SENDALOW then
                NONE = 0 : ODD = 1 : EVEN = 2 : NORMAL = 0 : INVERT = 1
                WAITFORSTART = 128 : SERIALINITDELAY = 5
         END IF
    #ENDSCRIPT</screen>
<simpara><?asciidoc-hr?></simpara>
<simpara><emphasis role="strong">SCRIPTS VARIABLES</emphasis></simpara>
<simpara>Scripting has the concept of variable that can be used within the script.&#160;&#160;
The variables are NOT available as variables to a user program or a library beyond the scope of the script.&#160;&#160;
The variables are available  to a user program as constants.&#160;&#160;
The variables will be integer values, if accessed in a user program.&#160;&#160;</simpara>
<simpara><emphasis role="strong">SCRIPT SYNTAX</emphasis></simpara>
<simpara>Scripting support the preprocessing of the program to create specific constants.&#160;&#160;
Scripting has a basic syntax and this is detailed in the HELP.&#160;&#160;
However, this guide is intended to provide insights into the gotchas and best practices.</simpara>
<simpara><emphasis role="strong"><emphasis>Script Insights</emphasis></emphasis></simpara>
<simpara>Scripting handles the creation of specific constants that can be used within the library.&#160;&#160;
Many libraries have script to create constants to support PWM, Serial, HEFSAF etc.&#160;&#160;</simpara>
<simpara>You can use the limited script language to complete calculations using real numbers but you MUST ensure the resulting constant is an integer value.&#160;&#160;
Use the IN() method to ensure an integer is assigned.</simpara>
<simpara>You can use IF-THEN-ENDIF but if your IF condtional test uses a chip regiseter or a user define constant then you must ensure the register or constant exists.&#160;&#160;
If you do not check the registrer or constant exists the script will fail to operate as expected.&#160;&#160;</simpara>
<simpara>There is limted syntax checking.
You must ensure the quality of the script by extensive testing.</simpara>
<screen>    int( register +1s))  'Will not create an error, but, simple give an unexpected result.</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><?asciidoc-hr?></simpara>
<simpara><emphasis role="strong">TAB USAGE AND INDENTING</emphasis></simpara>
<simpara>Four spaces are to be used. A tab is not permitted</simpara>
<simpara>Example follows where the indents are all four spaces.</simpara>
<screen>sub  ExampleSub (In VariableName)
    select case VariableName
        case 1
            Do This
        case 2
            Do That
    end select
end sub</screen>
<simpara>Not like this:</simpara>
<screen>    SUB  ExampleSub (In VariableName)
            Select Case VariableName
                  Case 1
                                   Do This
                  Case 2
                                    Do That
             End Select
End SUB</screen>
<simpara>and, not like this</simpara>
<screen>    Sub  ExampleSub (In VariableName)
    Select Case VariableName
    Case 1
    Do This
    Case 2
    Do That
    End Select
    End Sub</screen>
<simpara><?asciidoc-hr?></simpara>
<simpara><emphasis role="strong">OPTION REQUIRED</emphasis></simpara>
<simpara><literal>#Option Required</literal> supports ensuring the microcontroller has the mandated capabilities, such as EEPROM, HEF, SAF, USART.</simpara>
<simpara>Syntax:</simpara>
<screen>    #option REQUIRED PIC|AVR CONSTANT %message.dat entry%
    #option REQUIRED PIC|AVR CONSTANT "Message string"</screen>
<simpara>This option ensure that the specific CONSTANT exists within a library to ensure a specific capability is available with the microcontroller.</simpara>
<simpara>This will cause the compiler check the CONSTANT is a non zero value.  If the CONSTANT does not exist it will be treated as a zero value.</simpara>
<simpara>Example:</simpara>
<simpara>This example tests the CONSTANT CHIPUSART for both the PIC and AVR microcontrollers.  If the CONSTANT is zero or does not exist then the string will be displayed as an error message.</simpara>
<screen>    #option REQUIRED PIC CHIPUSART "Hardware Serial operations. Remove USART commands to resolve errors."
    #option REQUIRED AVR CHIPUSART "Hardware Serial operations. Remove USART commands to resolve errors."</screen>
<simpara><emphasis role="strong">RAISING COMPILER ERROR CONDITIONS</emphasis></simpara>
<simpara>From build 1131 the compiler now supports raising a compiler error message.</simpara>
<simpara>The method uses the `RaiseCompilerError  ""&lt;string&gt;""|%string%" ` method to pass an error message to the compilation process.</simpara>
<simpara>An example from USART.H/INITUSART subroutine is shown below.&#160;&#160;This example tests for the existence of one of the three supported baud rate constants.&#160;&#160;If none of the constants exist and the constant (in this example) <literal>STOPCOMPILERERRORHANDLER</literal> does not exist the <literal>RaiseCompilerError</literal> with the string will be passed to the assembler for error processing.&#160;&#160;
This permits the inspect of the user program with appropriate messages to inform the user.</simpara>
<screen>  ....
  #IFNDEF ONEOF(USART_BAUD_RATE,USART1_BAUD_RATE,USART2_BAUD_RATE) THEN
    'Look for one of the baud rates CONSTANTS
    #IFNDEF STOPCOMPILERERRORHANDLER
      'Use one of the following - the string MUST be start and end with a double quote

        ' Use the message.dat file
        ' RaiseCompilerError "%USART_NO_BAUD_RATE%"

        ' Use hard code text
        ' RaiseCompilerError "USART not setup correctly. No baud rate specified - please correct USART setup"

        RaiseCompilerError "%USART_NO_BAUD_RATE%"

    #ENDIF
  #ENDIF
  ....</screen>
<simpara>The <literal>RaiseCompilerError</literal> handler can be stopped using the constant STOPCOMPILERERRORHANDLER as shown above.
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">LCD ERROR HANDLING</emphasis></simpara>
<simpara>The setup of an LCD is inspected and an appropriate error message is displayed.&#160;&#160;
The Compiler now controls error messages when LCD is not setup up correctly.&#160;&#160;
This the text displayed is held in the messages.dat file - LCD_Not_Setup entry.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_development_guide_for_gcbasic_exe_compiler">
<title>Development Guide for GCBASIC.EXE compiler</title>
<simpara>There are lots of ways to contribute to the GCBASIC project: coding, testing, improving the build process and tools, or contributing to the documentation.
This guide provides information that will not only help you get started as a GCBASIC contributor, but that you will inform you as an experienced contributor wanting to help.</simpara>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Need Help?</emphasis></simpara>
<simpara>The GCBASIC community prides itself on being an open, accessible, and friendly community for new participants.&#160;&#160;
If you have difficulties getting involved or finding answers to your questions, please bring those questions to the forum via the discussion boards, where we can help you get started.</simpara>
<simpara>We know EVEN before you start contributing that getting can be a challenge.&#160;&#160;
This guide is intended to help.&#160;&#160;
We are always looking for ways to improve the software: making GCBASIC more open, accessible, and easier to participate with.&#160;&#160;
If you are having any trouble following this guide, or hit a barrier you cannot get around, please contact us via the discussion forum.&#160;&#160;
We will solve hurdles for new contributors and make GCBASIC better.&#160;&#160;</simpara>
<simpara>This addresses the changes and updates to the GCBASIC compiler.&#160;&#160;</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">BACKGROUND</emphasis></simpara>
<simpara>The compiler was created by Dr. Hugh Considine when he was 12 years old.&#160;&#160;That was in 2005.&#160;&#160;Hugh came up with the idea for a new compiler - of the then available compilers - they were hard to use and not free. &#160;&#160;And, he had some spare time.</simpara>
<simpara>Hugh believes that GCBASIC should be free to all - forever.&#160;&#160;</simpara>
<simpara>The original software was called Great Cow BASIC, but, he had some resistance in getting high schools in Australia to use and agree to the use of text based programming.&#160;&#160;
Graphical GCBASIC was created to address the need for a graphical user interface.&#160;&#160;Graphical GCBASIC acts like a set of training wheels. &#160;&#160;
The concept of Graphical GCBASIC is that the icons make it less scary, and since they all share names with the BASIC commands it is then easy to remember what command corresponds to each icon..&#160;&#160;
Using Graphical GCBASIC users can then switch to text mode whenever they want to, go backwards and forwards a few times if they want, and finally end up using just the text programming.&#160;&#160;
It is a journey from a graphical user interface to text based programming.&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
Those who already have programming experience can go straight to GCBASIC, while those who would prefer a lighter learning curve can take the Graphical GCBASIC option. &#160;&#160;
The two approaches targets two different sets of users who ultimately want to do the same thing.
<?asciidoc-br?>
<?asciidoc-br?>
As for the <emphasis role="strong">name</emphasis>, it was about the fourth name Hugh tried. &#160;&#160;First name was BASPIC, but it did not seem memorable enough.&#160;&#160;
Then, he considered some animal names - first thought was Chipmunk BASIC, but someone already used that!&#160;&#160;
Then, Bear BASIC, but decided against it on finding out the slang meaning of bear.&#160;&#160;
Final  name was GCBASIC, which is named after something his sister and he came up with (when aged 12 and 15!!).&#160;&#160;
No-one else had that name, it had no meanings that could offend, and it was something odd enough to be memorable, so Great CoW CBASIC it was.</simpara>
<simpara>In 2013 Evan Venn joined the team as a compiler developer, with others joining in Bernd Dau, Trevor Roydhouse, Pete Everett, Theo Loermans, Giuseppe D&#8217;Elia, Derek Gore,  Ian Smith, Bernd Dau, Theo Loermans, Urs Hopp, Kent Schafer, and Frank Steinberg.&#160;&#160;
Some those that joined in drove changes to the compiler, some changed the source code, some built tools and some built libraries.&#160;&#160;
They all had one thing in common - improvements to the GCBASIC compiler.</simpara>
<simpara>In 2021 we are still having new developers join the project like ToniG adding a new capability for handling Tables.</simpara>
<simpara>In 2023 we renamed to GCBASIC.&#160;&#160;The Cow is now deadbeef &#8230;&#8203; a hex number .. :-).</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">THE COMPILER</emphasis></simpara>
<simpara>The compiler executable is called GCBASIC.EXE. &#160;&#160;
The compiler source is written in FreeBASIC.&#160;&#160;
FreeBASIC is a multiplatform, free/open source (GPL) BASIC programming language and a compiler for Microsoft Windows, protected-mode MS-DOS (DOS extender), Linux and FreeBSD.
&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
The official website is <link xlink:href="https://www.freebasic.net/">https://www.freebasic.net/</link>
<?asciidoc-br?>
<?asciidoc-br?>
FreeBASIC provides syntax compatibility with programs originally written in Microsoft QuickBASIC (QB).&#160;&#160;
FreeBASIC is a command line only compiler, unless users manually install an external integrated development environment (IDE) of their choice.&#160;&#160;
IDEs specifically made for FreeBASIC include FBide and FbEdit, while more graphical options include WinFBE Suite and VisualFBEditor.&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
The source code is Open Source.&#160;&#160;
And, has a GNU GENERAL PUBLIC LICENSE.&#160;&#160;
<?asciidoc-br?>
<?asciidoc-br?>
The source code for the compiler can be found on <link xlink:href="https://sourceforge.net/p/gcbasic/code/HEAD/tree/GCBASIC/trunk/">SourceForge</link>
<?asciidoc-br?>
<?asciidoc-br?>
Use SVN to UPDATE and COMMIT code changes.&#160;&#160;
You require developer access to SourceForge but if you have got this far then you already know this.&#160;&#160;
You are therefore  required to use SVN for source code management.</simpara>
<simpara>When COMMITting you MUST update the change log, then, when you commit an update use the change log with the SourceForge commit number.&#160;&#160;
Then, add the new change at the end of the change log.&#160;&#160;
The COMMIT message should be the same as the description in the change log.&#160;&#160;
Add the [<emphasis>COMMIT NUMBER]</emphasis> to the description in the change log to show the COMMIT number.&#160;&#160;</simpara>
<simpara>You will find the changelog <link xlink:href="https://onedrive.live.com/Edit.aspx?resid=2F87FFE77F3DBEC7!67634&amp;wd=cpe&amp;authkey=!ADmkT3exl5l4Pkc">here</link>.&#160;&#160;
The change log is an EXCEL spreadsheet.&#160;&#160;</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">COMPILER ARCHITECTURE</emphasis></simpara>
<simpara>The compiler is relatively simple in terms of the architecture.&#160;&#160;
There is a main source program with a set of header files that contain other methods or declarations.&#160;&#160;
The GCBASIC header files are the following:</simpara>
<screen>    1. preprocessor.bi -  methods, statements, defines, declarations, prototypes, constants, enumerations, or similar types of statements
    2. utils.bi - methods that are shared across the architecture
    3. variables.bi - methods that control the creation and management of variables
    4. assembly.bi - methods specific to the generation of GCAssembler (GCASM)
    5. file.bi - the FreeBASIC files library
    6. string.bi - the FreeBASIC string library</screen>
<simpara>The supporting files are:</simpara>
<screen>    1. messages.dat - the English messages source file.  All user messages from the compiler are sourced from this file.
    2. reservedwords.dat - the list of system reserved words</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The compiler process is simple.&#160;&#160;
The process, shown below, generates the ASM source and the HEX file from the user source program.</simpara>
<screen>    1. Create the indexes
    2. Declare the methods, arrays and variables
    3. Process the user source programs using PreProcessor method. This includes
        i.     Loading of all source files including including files
        ii.    Translate files, if needed
        iii.   Examine source for comments, tables, asm, rawasm, functions;subs;macros, set origin of valid code
                    Origin = ";?F" + Str(RF) + "L" + Str(LC) + "S" + Str(SBC) + "?"
                    RF = File number
                    L  = Line number in source file
                    S  = Sub Routine number
        iv.    Find compiler directives, except SCRIPT, ENDSCRIPT, IFDEF and ENDIF - including all the #DEFINEs outside of condiontal statements
        v.     If GLCD_TYPE in user source program is found, then, determine the library and load that library with all dependent libraries. This method improves compiler performance by only loading the required libraries
        vi.    ReadChipData
        vii.   CheckClockSpeed
        viii.  ReadOptions
        ix.    PreparePageData
        x.     PrepareBuiltIn.  Initialise built-in data, and prepare built-in subs.
        xi.    RunScripts
        xii.   BuildMemoryMap
        xiii.  Process samevar and samebit
        xiv.   RemIfDefs.  Remove any #IFDEFs that do not apply to the program.
        xv.    Prepare programmer, need to know chip model and need to do this before checking config
        xvi.   Replace Constants
        xvii.  Replace table value.  Replace constants and calculations in tables with actual values
    4. Compile the program using the CompileProgram method
         i.    Compile calls to other subroutines, insert macros
         ii.   Compile DIMs again, in case any come through from macros
         iii.  Compile FOR commands
         iv.   Process arrays
         v.    Add system variable(s) and bit(s)
         vi.   Compile Tables
         vii.  Compile Pot
         viii. Compile Do
         ix.   Compile Dir
         x.    Compile Wait
         xi.   Compile On Interrupt
         xii.  Compile Set(s)
         xiii. Compile Rotate
         xiv.  Compile Repeat
         xv.   Compile Select
         xvi.  Compile Return
         xvii. Compile If(s)
         xviii Compile Exit Sub
         xix.  Compile Goto(s)
    5. Allocate RAM using the AllocateRAM method
    6. Optimise the generated code using the TidyProgram method
    7. Combine and locate the subroutines and functions for the selected chip using the MergeSubroutines method
    8. Complete the final optimisation using the FinalOptimise method
    9. Write the assembly using the WriteAssembly method
    10. Assemble and generate the hex file using GCASM, MPASM, PICAS or some other define Assembler
    11. Optionally, pass programming operations to the programmer
    12. Write compilation report using the WriteCompilationReport method
    13. If needed, write the error and warning log using the WriteErrorLog method
    14. Exit, setting the ERRORLEVEL</screen>
<simpara>Note #1:  Constants are can be created in many places and the order is critical when trying to understant the process.</simpara>
<simpara>Step 3.iv; Step 3.xi, 3.xiv and xvi. These are Find compiler directives; Runscripts, process IFDEFs and replace Constants values respectively.&#160;&#160;
This means constants that are not created by the Find compiler directives step are clearly not available in the RunScripts step, and the same applies to the process IFDEFs step.&#160;&#160;So, please consider the order of constant creation in terms of these steps.&#160;&#160;Always think about the precendence of constant creation.&#160;&#160;</simpara>
<simpara>Note #2:  When using IFDEFs Conditional statements you should #UNDEFINE all constants prior to #DEFINE.&#160;&#160;Whilst the will be cases where the constant does not exist, or where the Preprocessor can determine the outcome of the Conditional statements there will be cases, specifically nested IFDEFs Conditional statements, where you will be required to use #UNDEFINE to remove all warnings.</simpara>
<simpara>Note #3:  Good practice is NOT to create constants in a library where the user can overwrite the value of the same constant.&#160;&#160;You must determine if the user has created the constant and then create a default value if the user has not defined a value.&#160;&#160;  An example:</simpara>
<screen>  IF NODEF(AD_DELAY) THEN
     'Acquisition time. Can be reduced in some circumstances - see PIC manual for details
     AD_DELAY = 2 10US
  END IF</screen>
<simpara>This will create the constant AD_DELAY only when the user program does not define a value.
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">FreeBASIC COMPILATION OF GCBASIC SOURCE CODE</emphasis></simpara>
<simpara>The compiler is relatively simple in terms of the compilation.&#160;&#160;</simpara>
<simpara>Use the following versions of the FreeBASIC compiler to compile the GCBASIC source code.</simpara>
<simpara>For Windows 32 bit</simpara>
<screen>    FreeBASIC Compiler - Version 1.07.1 (2019-09-27), built for win32 (32bit)
    Copyright (C) 2004-2019 The FreeBASIC development team.</screen>
<simpara>For Windows 64 bit</simpara>
<screen>    FreeBASIC Compiler - Version 1.07.1 (2019-09-27), built for win64 (64bit)
    Copyright (C) 2004-2019 The FreeBASIC development team.</screen>
<simpara>Using other version of Windows FREEBASIC compiler are NOT tested and may fail.&#160;&#160;
Use the specific versions shown above.</simpara>
<simpara>The compile use the following command lines.
Where "%ProgramFiles% is the root location of the FreeBASIC installation, and
$SF is the location of the source files and the destination of the compiled executable.</simpara>
<simpara>For Windows 32 bit</simpara>
<screen>    "%ProgramFiles%\FreeBASIC\win32\fbc.exe"  $SF\gcbasic.bas   -exx -arch 586 -x $SF\gcbasic32.exe</screen>
<simpara>For Windows 64 bit</simpara>
<screen>    "%ProgramFiles%\FreeBASIC\win64\fbc.exe"  $SF\gcbasic.bas   -x $SF\gcbasic64.exe -ex</screen>
<simpara>Linux, FreeBSD and Pi OS are also supported.&#160;&#160;
Please see <link xlink:href="http://gcbasic.sourceforge.net/help/">Online Help</link> and search for the specific operating system.&#160;&#160;</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">FreeBASIC COMPILER TOOLCHAIN</emphasis></simpara>
<simpara>To simplify the establishment of  development enviroment download a complete installation from <link xlink:href="https://sourceforge.net/projects/gcbasic/files/Support%20Files/GCBASICWindowsToolchain/FreeBASIC.zip/download">here</link>.&#160;&#160;
This includes the correct version of FreeBASIC and the libraries - all ready for use.&#160;&#160;
Simply unzip the ZIP to a folder and the toolchain is ready for use.&#160;&#160;
For an IDE please see the information above.&#160;&#160;</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">BUILDING THE GCBASIC EXECUTABLE USING THE FBEDIT IDE</emphasis></simpara>
<simpara>To build GCBASIC from the source files.&#160;&#160;
The list shows the installation of the FBEdit IDE.</simpara>
<simpara>Complete the following:</simpara>
<screen>        1. Download and install FreeBASIC from  url shown above.
        2. Download and install fbedit from https://sourceforge.net/projects/fbedit/?source=dlp
        3. Download the GCBASIC source using SVN into a gcbasic source folder.
        4. Run fbedit (installed at step #2).  Load project  GCBASIC.fbp  from GBASIC source folder.
        5. Hit &lt;f5&gt; to compile.</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">CODING STYLES</emphasis></simpara>
<simpara>Remember, Hugh was 12 when he started this project.&#160;&#160;
You must forgive him for being a genius, but, he did not implement many programming styles and conventions that are common place today.&#160;&#160;</simpara>
<simpara>There is a general lack of documentation.&#160;&#160;
We are adding documentation as we progress.&#160;&#160;
This can make the source frustrating initially but can find the code segments as they are clearly within method blocks.&#160;&#160;</simpara>
<simpara>The following rules are recommended.</simpara>
<screen>    1. All CONSTANTS are capitalized
    2. Do not use TAB - use two spaces
    3. You can rename a variable to a meaningful name.  Hugh used a lot of single character variables many years ago.  This should be avoided in new code.
    4. Document as you progress.
    5. Ask for help.</screen>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">COMPILER SOURCE INSIGHTS</emphasis></simpara>
<simpara><emphasis>There are many very useful methods</emphasis>, a lot of methods, look at existing code before adding any new method.&#160;&#160;
The compiler is mature from a functionality standpoint.&#160;&#160;
Just immature in terms of documentation.&#160;&#160;</simpara>
<simpara><emphasis role="strong">COMPILER DEBUGGING</emphasis></simpara>
<simpara><emphasis>To debug or isolate a specific issue</emphasis> use lots of messages using PRINT or HSERPRINT&#160;&#160;Both of these methods are easy to setup and use.</simpara>
<simpara><emphasis>Specific to #SCRIPT</emphasis> you can use WARNING messages to display results of calculations or assignments.</simpara>
<simpara><emphasis>Specific to CONDITIONAL Compilation</emphasis> use <literal>conditionaldebugfile</literal> (se above) to display conditional statement debug for the specified file. &#160;&#160; Options are any valid source file or nothing. &#160;&#160;
Nested conditions are evaluated sequentially, therefor the first, second, third etc etc.  &#160;&#160;
The compiler does not at this point rationalised the hierarchy of nested conditions.&#160;&#160;  It simply finds a condition and then matches to an #ENDIF.&#160;&#160;
So, the compiler walks through the nested conditions as the outer nested, then the next nest, the next nest etc. etc.&#160;&#160;
This compiler is completing the following actions:&#160;&#160;</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>If the conditional is not valid.&#160;&#160;  Remove the code segment include the #IF and the #ENDIF</simpara>
</listitem>
<listitem>
<simpara>If the conditional is valid.&#160;&#160;  Remove the just the #IF and the #ENDIF</simpara>
</listitem>
</orderedlist>
<simpara>So, is this context the compiler walks the code many time (as these are lists not arrrays this is blindly fast) removing code segments.&#160;&#160;</simpara>
<simpara>The following program shows the impact of nested conditions..&#160;&#160;Each nest is evaluated until all conditions have been assessed..&#160;&#160;See the comment section of the listing to see the output from the debugging.</simpara>
<screen>        #CHIP 18F16Q41
        #OPTION EXPLICIT

        ; -----  Add the following line to USE.ini ------------------
        ;
        ;        conditionaldebugfile = IFDEF_TEST.gcb
        ;
        ; -----------------------------------------------------------

        #IFDEF PIC
            #IFDEF ONEOF(CHIP_18F15Q41, CHIP_18F16Q41)
                #IF CHIPRAM = 2048  'TRUE
                    #IF CHIPWORDS = 32768 ' TRUE
                        #IFDEF VAR(NVMLOCK) 'TRUE
                            #IFDEF VAR(OSCCON2)  'TRUE
                                #IFDEF  VAR(NVMCON0)  'TRUE    set var1 to 1
                                    DIM _VAR1
                                    _VAR1 = 1
                                #ENDIF
                            #ENDIF
                        #ENDIF
                    #ENDIF
                #ENDIF

                #IF CHIPRAM = 4096  'TRUE
                    #IF CHIPWORDS = 32768 ' TRUE
                        #IFDEF VAR(NVMLOCK) 'TRUE
                            #IFDEF VAR(OSCCON2)  'TRUE
                                #IFDEF  VAR(NVMCON0)  'TRUE   = set var1 to 0
                                    DIM _VAR1
                                    _VAR1 = 0
                                #ENDIF
                            #ENDIF
                        #ENDIF
                    #ENDIF
                #ENDIF
            #ENDIF
        #ENDIF

        Do
        Loop

        // ===============================================
        // ***  Below is debugger output for this file ***
        // ===============================================

        // GCBASIC (0.99.02 2022-07-21 (Windows 32 bit) : Build 1143)

        // Compiling c:\Users\admin\Downloads\IFDEF_TEST.gcb

        //               13: #IFDEF PIC
        //               15: #IFDEF ONEOF(CHIP_18F15Q41, CHIP_18F16Q41)
        //               17: #IF CHIPRAM = 2048
        //               19: #IF CHIPWORDS = 32768
        //               21: #IFDEF VAR(NVMLOCK)
        //               23: #IFDEF VAR(OSCCON2)
        //               25: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               27: DIM _VAR1
        //               ;_VAR1 = 1
        //               28: _VAR1 = 1

        //               15: #IFDEF ONEOF(CHIP_18F15Q41, CHIP_18F16Q41)
        //               17: #IF CHIPRAM = 2048
        //               19: #IF CHIPWORDS = 32768
        //               21: #IFDEF VAR(NVMLOCK)
        //               23: #IFDEF VAR(OSCCON2)
        //               25: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               27: DIM _VAR1
        //               ;_VAR1 = 1
        //               28: _VAR1 = 1

        //               39: #IF CHIPRAM = 4096
        //               41: #IF CHIPWORDS = 32768
        //               43: #IFDEF VAR(NVMLOCK)
        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               41: #IF CHIPWORDS = 32768
        //               43: #IFDEF VAR(NVMLOCK)
        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               43: #IFDEF VAR(NVMLOCK)
        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        // Program compiled successfully (Compile time: 1 seconds)

        // Assembling program using GCASM
        // Program assembled successfully (Assembly time: 0.125 seconds)
        // Done</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The resulting ASM from the about code is as expected.&#160;&#160;The assignment of <literal>VAR1 = 0</literal>.&#160;&#160;</simpara>
<screen>        ;DIM _VAR1
        ;_VAR1 = 0
            clrf	_VAR1,ACCESS
        ;Do
        SysDoLoop_S1
        ;Loop
            bra	SysDoLoop_S1
        SysDoLoop_E1</screen>
<simpara><?asciidoc-br?></simpara>
</section>
<section xml:id="_about_glcd_library_support">
<title>ABOUT GLCD Library Support</title>
<simpara>The GLCD capability supports over 40 GLCDs.&#160;&#160;GCBASIC loads automatically the specific library required.&#160;&#160;The loading of the specific library(ies) by the compiler improves performance and significantly reduces the compilation time.</simpara>
<simpara>The GLCD libraries, that are automatically loaded, are controlled by the use of an incude statement in the use program <literal>#include &lt;glcd.h&gt;</literal> with a constant to define the specific GLCD driver to be loaded <literal>#define GLCD_TYPE GLCD_TYPE_SSD1289</literal>.</simpara>
<simpara>The process the compiler uses the file <literal>include\glcd.dat</literal>.&#160;&#160;The <literal>glcd.dat</literal> has a strict format where the row index has parameters as shown below.</simpara>
<screen>    Format. This is strict.

    Usea comma delimiter; single quote to a comment line; amperand to group libraries. No other format controls permitted.

    For each row.

        Index, glcd type, library[[&amp;library]&amp;library]

        Index =   the reference number from GLCD.H. There is a unique reference number per type of glcd.
        Type  =   the type. per type of glcd. must match those definition in GLCD.H
                    this is use as the search/match in the constant `GLCD_TYPE` in user source program
                    this is not case sensitive
        Library = library to be loaded, or, group of dependent libraries
                    delimiter must be '&amp;'</screen>
<simpara><?asciidoc-br?></simpara>
</section>
<section xml:id="_development_guide_for_gcbasic_preferences_editor">
<title>Development Guide for GCBASIC Preferences Editor</title>
<simpara>This section deals with the GCBASIC Preferences Editor (Pref Editor).&#160;&#160;
The Prefs Editor is the software enables the user to select programmers, select the options when compiling, select the assembler and other settings.&#160;&#160;
The Prefs Editor uses an ini to read and store the compiler settings.&#160;&#160;
The INI structure is explained the first section, then, the Prefs Editor in detail.</simpara>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">ABOUT THE INI FILES</emphasis></simpara>
<simpara>You can provide the compiler an INI file with a number of settings and programmers.&#160;&#160;</simpara>
<simpara>The following section provide details of the specifics within an example INI file.&#160;&#160;
The comments are NOT part of an INI file.&#160;&#160;</simpara>
<simpara>The settings are in the INI section called [gcbasic].&#160;&#160;</simpara>
<screen>    [gcbasic]
    programmer = arduinouno, pickitpluscmd1, lgt8f328p-1, xpress, pickit2cmdline, nsprog            - the currently selected available programmers
    showprogresscounters = n                                                                        - show percent values as compiler runs. requires Verbose = y
    verbose = y                                                                                     - show verbose compiler information
    preserve = n                                                                                    - preservice source program in ASM
    warningsaserrors = n                                                                            - treat Warnings from scripts as errors. Errors will cause the compiler to cease on an Error(s)
    pauseaftercompile = n                                                                           - pause after compiler. Do not do this with IDEs
    flashonly = n                                                                                   - Flash the chip is source older that hex file
    assembler = GCASM                                                                               - currently selected Assembler
    hexappendgcbmessage = n                                                                         - appends a message in the HEX file
    laxsyntax = n                                                                                   - use lax syntax when Y, the compiler will not check that reserved words are being used
    mutebanners = n                                                                                 - mutes the post compilation messages
    evbs = n                                                                                        - show extra verbose compiler information, requires Verbose = y
    nosummary = n                                                                                   - mutes almost all messages psot compilation
    extendedverbosemessages = n                                                                     - show even more verbose compiler information, requires Verbose = y
    conditionaldebugfile =                                                                          - creates CDF file
    columnwidth = 180                                                                               - ASM width before wrapping
    picasdebug = n                                                                                  - adds PIC-AS preprocessor message to .S file
    datfileinspection = y                                                                           - inspects DAT for memory validation
    methodstructuredebug  = n                                                                       - show method structure start &amp; end for validation
    floatcapability =  1                                                                            - 1 = singles
                                                                                                    - 2 = doubles
                                                                                                    - 4 = longint
                                                                                                    - 8 = uLongINT
    compilerdebug =  0                                                                              - 1 = COMPILECALCADD
                                                                                                    - 2 = VAR SET
                                                                                                    - 4 = CALCOPS
                                                                                                    - 8 = COMPILECALCMULT</screen>
<simpara>The section shows an example [tool] assembler section.&#160;&#160;</simpara>
<screen>    [tool=pic-as]
    'An assember
    type = assembler
    'Location of the assember using a parameter substitution.
    command = %picaslocation%\pic-as.exe
    'Parameters
    params = -mcpu=%ChipModel%  "%Fn_NoExt%.S" -msummary=-mem,+psect,-class,-hex,-file,-sha1,-sha256,-xml,-xmlfull  -Wl -mcallgraph=std -mno-download-hex -o"%Fn_NoExt%.hex"  -Wl,-Map="%Fn_NoExt%.map" -Wa,-a

    [tool=mpasm]
    'An assember
    type = assembler
    'Location of the assember using a parameter substitution.
    command = %mpasmlocation%\mpasmx.exe
    'Paramters
    params = /c- /o- /q+ /l+ /x- /w1 "%FileName%"</screen>
<simpara>The section shows an example [patch] section.</simpara>
<simpara>This section shows and explicit set of patches applied to PIC-AS assembler.</simpara>
<screen>    [patch=asm2picas]
    desc = PICAS correction entries.  Format is STRICT as follows:  Must have quotes and the equal sign as the delimeter. PartName +COLON+"BadConfig"="GoodConfig"    Where BadConfig is from .s file and GoodConfig is from .cfgmap file
    16f88x:"intoscio = "="FOSC=INTRC_NOCLKOUT"
    16f8x:"intrc = IO"="FOSC=INTOSCIO"
    12f67x:"intrc = OSC_NOCLKOUT"="FOSC=INTRCIO"</screen>
<simpara>The section shows an example [programmer] section.&#160;&#160;</simpara>
<screen>    [tool = pk4_pic_ipecmd_program_release_from_reset]
    'Description
    desc = MPLAB-IPE PK4 CLI for PIC 5v0
    'A programmer
    type = programmer
    'Command line using a parameter substitution.
    command = %mplabxipedirectory%\ipecmd.exe
    'Parameters using a parameter substitution.
    params = -TPPK4 -P%chipmodel%  -F"%filename%" -M  -E -OL -W5
    'Worting direcroty using a parameter substitution.
    workingdir = %mplabxipedirectory%
    'Useif constraints - this shows none
    useif =
    'Mandated programming config constraints - this shows none
    progconfig =</screen>
<simpara><emphasis role="strong">ABOUT THE PREFS EDITOR</emphasis></simpara>
<simpara>This is a utility for editing GCBASIC ini files.&#160;&#160;
It is derived from the Graphical GCBASIC utilities, and requires some files from Graphical GCBASIC to compile.&#160;&#160;</simpara>
<simpara>The software is developed using Sharp Develop v.3.2.1 ( not Visual Studio ).&#160;&#160;</simpara>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">COMPILING</emphasis></simpara>
<simpara>Ensure that the "Programmer Editor" folder is in the same folder as a "Graphical GCBASIC" folder.&#160;&#160;
The "Graphical GCBASIC" folder must contain the following files from GCGB:
 - Preferences.vb
 - PreferencesWindow.vb
 - ProgrammerEditor.vb
 - Translator.vb
 - ProgrammerEditor.resources</simpara>
<simpara>Once these files are in place, it should be possible to compile the Programmer Editor using SharpDevelop 3.2 (or similar).</simpara>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">USING PREFS EDITOR</emphasis></simpara>
<simpara>If run without any parameters, this program will create an ini file in whatever directory it is located in.&#160;&#160;
If it is given the name of an ini file as a command line parameter, it will use that file.&#160;&#160;</simpara>
<simpara>As well as the ini file it is told to load, this program will also read any files that are included from that file..&#160;&#160;
This makes it possible to keep the settings file in the Application Data folder if GCBASIC is installed in the Program Files directory..&#160;&#160;
To put the settings file into the Application Data folder, create a small ini file containing the following 3 lines and place it in the same directory as this program:</simpara>
<screen>    include %appdata%\gcgb.ini
    [gcgb]
    useappdata = true</screen>
<simpara>The include line tells the program (and GCBASIC) to read from the Application Data folder.&#160;&#160;
The useappdata=true line in the [gcgb] section will cause this program to write any output to a file in Application Data called gcgb.ini.&#160;&#160;
The hard coding of GCGB is required this program is based on GCGB.&#160;&#160;
It will result in programmer definitions being shared between GCGB and any other environment using this editor, which may be a positive side effect.</simpara>
<simpara><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">BUILDING THE PROGRAMMER EDITOR EXECUTABLE USING SHARP DEVELOP</emphasis></simpara>
<simpara>To build Prefs Editor from the source files.&#160;&#160;
The list shows the installation of the Sharp Develop IDE.</simpara>
<simpara>Complete the following:</simpara>
<screen>        1. Download and install Sharp Develop from  https://sourceforge.net/projects/sharpdevelop/files/SharpDevelop%203.x/3.2/[SourceForge]
        2. Download the Prefs Editor source using SVN into a source folder.  This is the folder ..\utils\Programmer Editor
        4. Run Sharp Develop (installed at step #1).  Load project  "Programmer Editor.sln"  from source source folder.
        5. Hit &lt;f8&gt; to compile.</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
</section>
<section xml:id="_gcbasic_with_the_avrisp_or_mkii_programmer">
<title>GCBASIC with the AVRISP or MKII Programmer</title>
<simpara>This is the GCBASIC section of the Help file that explains how to use an AVRISP MKII or USBtinyISP for ATTINY10 chip under Windows 10</simpara>
<section xml:id="_setup_an_avrisp_mkii_or_usbtinyisp_for_attiny10_chip_under_windows">
<title>Setup an AVRISP MKII or USBtinyISP for ATTINY10 chip under Windows</title>
<simpara><emphasis role="strong">AVRISP MKII Windows Driver Validation/Changing</emphasis></simpara>
<simpara>Windows 10 and 11 tested.</simpara>
<simpara>When using the AVRDUDE, which is used as part of the GCBASIC toolchain, you need to ensure these programmers are operating with the correct Windows device driver.&#160;&#160;
The Windows driver must be <literal>libusbK</literal> not <literal>libusb or libusb-win32</literal> Windows driver.</simpara>
<simpara>You must ensure the Windows driver is <literal>libusbK</literal>.&#160;&#160;Using the utility Zadig enables changing the Windows device driver to <literal>libusbK</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara>Download and install Zadig Driver Utility software <link xlink:href="https://zadig.akeo.ie/">https://zadig.akeo.ie/</link></simpara>
</listitem>
<listitem>
<simpara>Connect the USB cable from the AVRISP MKII to your PC.</simpara>
</listitem>
<listitem>
<simpara>Open Zadig and from the menu select Options / List All Devices.</simpara>
</listitem>
<listitem>
<simpara>From the device list select AVRISP MKII.</simpara>
</listitem>
<listitem>
<simpara>Select the target driver libusbK and click (Install / Replace Driver) button.</simpara>
</listitem>
</itemizedlist>
<simpara>After the installation is completed, open Windows Device Manager and verify the driver installation.</simpara>
<simpara>Close Zadig</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/1%20%20-%20AVRISP%20MKII%20Zadig%20Setup.png"/>
</imageobject>
<textobject><phrase>Setup</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>If you use ATMEL Studio you must ensure the Windows device driver is <literal>libusb or libusb-win32</literal>.</simpara>
</note>
<note>
<simpara>If you use AVRDUDE then uou must ensure the Windows device driver is <literal>libusbK</literal>.</simpara>
</note>
<simpara>Next in the process is to upgrade the firmware of the AVRISP MKII.</simpara>
<simpara><emphasis role="strong">Option 1:</emphasis></simpara>
<simpara>This process shows the installation of Atmel Studio 7, however, you may have to use Atmel Studio 6 because of operation system constraint.</simpara>
<simpara>Download and Install Atmel Studio 7 from the GCBASIC file store <link xlink:href="https://sourceforge.net/projects/gcbasic/files/Support%20Files/ATMELCompilers/">here</link></simpara>
<simpara>After the installation open ATMEL STUDIO 7</simpara>
<itemizedlist>
<listitem>
<simpara>Select Tools / Device Programming</simpara>
</listitem>
<listitem>
<simpara>Make sure the AVRISP MKII is selected</simpara>
</listitem>
<listitem>
<simpara>At this point ATMEL STUDIO will notified to upgrade the firmware to version 1.8</simpara>
</listitem>
<listitem>
<simpara>Click the Upgrade  button</simpara>
</listitem>
<listitem>
<simpara>Once the firmware is upgraded, close ATMEL STUDIO 7</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/2%20%20-%20ATMEL%20STUDIO.png"/>
</imageobject>
<textobject><phrase>Studio</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Option 2:</emphasis></simpara>
<simpara>To update the firmware please, follow the steps listed below.</simpara>
<itemizedlist>
<listitem>
<simpara>Connect the programmer to the USB and with a sharp object (needle or pin) press the upgrade pin - it is in a small hole at the back of the board (this will start the bootloader and will turn off the LED, it will also probably show a new unrecognized device in the device manager for which we will install drivers in step 3)</simpara>
</listitem>
<listitem>
<simpara>Download and install the latest version of "Atmel Flip" software (it can be downloaded from the Atmel&#8217;s web-site, or from the GCBASIC file store <link xlink:href="https://sourceforge.net/projects/gcbasic/files/Support%20Files/ATMELCompilers/AVRISPMk2/">here</link> )</simpara>
</listitem>
<listitem>
<simpara>Open its install folder and update the software of the unrecognized device (usually under the "Other devices" tab) with the drivers from folder named "usb"; the device should now be recognized as AT90USB162 under "libusb-win32" tab</simpara>
</listitem>
<listitem>
<simpara>Start "Atmel FLIP" and click "Select a target device" &#8594; choose AT90USB162</simpara>
</listitem>
<listitem>
<simpara>Click "Select a Communication Medium" and then USB medium</simpara>
</listitem>
<listitem>
<simpara>Download the firware and unpack <link xlink:href="https://www.olimex.com/Products/AVR/Programmers/AVR-ISP-MK2/resources/AVR456-studio-AVRISP-MKII.zip">Olimex website</link> or the GCBASIC files store <link xlink:href="https://sourceforge.net/projects/gcbasic/files/Support%20Files/ATMELCompilers/AVRISPMk2/">here</link></simpara>
</listitem>
<listitem>
<simpara>From "File &#8594; load HEX file" choose the latest HEX and click "RUN" in the "Operations Flow" section</simpara>
</listitem>
<listitem>
<simpara>Disconnect the AVR-ISP-MK2 from the USB and connect it again</simpara>
</listitem>
</itemizedlist>
<simpara>For more information about AVR-ISP-MK2 see this guide <link xlink:href="http://gcbasic.sourceforge.net/library/AVR-ISP-MK2-OpenSourceHardwareBoard.pdf">here</link></simpara>
<simpara><emphasis role="strong">AVRISP MKII to ATTINY10 Connections:</emphasis></simpara>
<simpara>Connect the AVRISP MKII to the ATTINY10 as show in the Diagram.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/3%20%20-%20AVRISP%20MKII%20Connections.png"/>
</imageobject>
<textobject><phrase>Connections</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">GCStudio Programmer Setup:</emphasis></simpara>
<simpara>Open GCStudio and set the Programmers to use as show below</simpara>
<simpara>For AVRISP MKII use the AVR ISP XPII [KANDA] and drag it to the top of the list and click OK.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/4%20%20-%20GCStudio%20AVRISP%20MKII%20use%20the%20AVR%20ISP%20XPII%20%5BKANDA%5D.png"/>
</imageobject>
<textobject><phrase>4%20%20 %20GCStudio%20AVRISP%20MKII%20use%20the%20AVR%20ISP%20XPII%20%5BKANDA%5D</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>Now you’re ready to upload your first program to an ATTINY10.</simpara>
<simpara><emphasis role="strong">USBtinyISP Setup:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>From Zadig select USBtinyISP in the device list.</simpara>
</listitem>
<listitem>
<simpara>Select the target driver libusb-win32 and click (Install / Replace Driver) button.</simpara>
</listitem>
<listitem>
<simpara>After the installation, open Windows Device Manager and verify the driver installation.</simpara>
</listitem>
<listitem>
<simpara>Close ZADIG</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/5%20%20-%20USBtinyISP%20Zadig%20setup.png"/>
</imageobject>
<textobject><phrase>5%20%20 %20USBtinyISP%20Zadig%20setup</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">USBtinyISP to ATTINY10 Connections:</emphasis></simpara>
<simpara>Connect the USBtinyISP to the ATTINY10 as show in the Diagram.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/6%20%20-%20USBtinyISP%20Copnections.png"/>
</imageobject>
<textobject><phrase>6%20%20 %20USBtinyISP%20Copnections</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">GCStudio Programmer Setup:</emphasis></simpara>
<simpara>Open GCStudio and set the Programmers to use as show below</simpara>
<simpara>Select and Drag  the Avrdude (USBtinyISP) programmer to the top of the list.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/7%20%20-%20GCStudio%20Avrdude%20%28USBtinyISP%29.png"/>
</imageobject>
<textobject><phrase>7%20%20 %20GCStudio%20Avrdude%20%28USBtinyISP%29</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>Now you are ready to upload your first program to an ATTINY10</simpara>
<simpara>For more information programming review these resources:</simpara>
<literallayout class="monospaced">A guide http://gcbasic.sourceforge.net/library/Programming_an_Attiny10_with_AVRISP_mkII_and_AVR_Studio_5.pdf[here]</literallayout>
<literallayout class="monospaced">A blog http://gcbasic.sourceforge.net/library/Technoblogy_Programming_the_ATtiny10.pdf[here]</literallayout>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
</section>
</article>