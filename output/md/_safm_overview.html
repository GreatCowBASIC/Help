<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SAFM Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_safm.html" title="SAFM"><link rel="prev" href="_safm.html" title="SAFM"><link rel="next" href="_safread.html" title="SAFRead"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_safm_overview"></a>SAFM Overview</h5></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>Some Advanced (18F) and some Enhanced Mid-Range (16F) Microchip PIC devices support Storage Area Flash (SAF) memory. These devices also include EEPROM memory.&nbsp;&nbsp;&nbsp;
SAF memory is not High Endurance, meaning it does not have an endurance of 100K write cyces.&nbsp;&nbsp;&nbsp;
SAF has the same endurance as regular flash memmory, usually specified as 10K write cycles.&nbsp;&nbsp;&nbsp;
<br>
<br>
SAF memory appears at the top of program memory space and can be used for any purpose, like regular flash program memory.&nbsp;&nbsp;&nbsp;
Storage Area Flash is intended to be used to store data, such a device calibration data, RF device register settings, and other data. SAFEM can be Read as frequently as necessary.&nbsp;&nbsp;&nbsp; However,  it is not intended to be written frequently like EEPROM. If non-volatile memory need to be written frequenily, it is best to use the EEPROM on these devices.
<br>
<br>
As with all flash memory, data must be erased before it can be written and writing this memory will stall the device for a few ms. &nbsp;&nbsp;&nbsp;
Methods to read, write and erase the SAF memory are included in GCBASIC and they are described in this introduction.
<br>
<br>
The <code class="literal">hefsaf.h</code> library supports SAF operations for GCBASIC.
<br>
<br>
Note:  By default, GCBASIC will use SAF memory for regular executable code unless it is told otherwise.&nbsp;&nbsp;&nbsp;
If you wish to store data here, you should reserve the SAF memory by using the compiler option, as shown below to reserve 128 Words of SAF memory:&nbsp;&nbsp;&nbsp;This equates to 256 bytes on PIC 18F microcontrollers and 128 Bytes on PIC 16F microcontrollers</p><pre class="screen">    #option ReserveHighProg 128</pre><p>SAF memory is a block of memory locations found at the top of the Flash program memory.&nbsp;&nbsp;&nbsp;
Each memory location can be used to hold a variable value, either a byte or a word dependent on the specific device.&nbsp;&nbsp;&nbsp;
The main difference between SAF memory and EEPROM is that EEPROM allows byte-by-byte erase whereas the SAF memory does not.&nbsp;&nbsp;&nbsp;
With SAF memory data must be erased before a write and the erase can only be performed in blocks of memory.&nbsp;&nbsp;&nbsp;
The blocks, also called rows, are a fixed size associated with the specific device.&nbsp;&nbsp;&nbsp;
<br>
<br>
GCBASIC handles the erase operation automatically.&nbsp;&nbsp;&nbsp;
When a write operation is used by a user the GCBASIC library reads to a buffer, update the buffer, erase the block and finally write the buffer back to SAFM.&nbsp;&nbsp;&nbsp;
The complexity of using SAF memory is reduced with the automatically handling of these operations.&nbsp;&nbsp;&nbsp;
<br>
<br>
The library provides a set of methods to support use of SAF memory.
<br>
<br></p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top"><p>Method</p></td><td align="left" valign="top"><p>Parameters</p></td><td align="left" valign="top"><p>Usage</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFWrite</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: location, byte value</p></td><td align="left" valign="top"><p>SAFWrite ( location, byte_variable )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFWriteWord</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: location, word_value</p></td><td align="left" valign="top"><p>SAFWriteWord ( location, word_variable  )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFRead</code></p></td><td align="left" valign="top"><p>a function with the parameters: location returns a byte value</p></td><td align="left" valign="top"><p>byte_variable = SAFRead ( location  )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFRead</code></p></td><td align="left" valign="top"><p>a subroutine with the paramers: location, byte_value</p></td><td align="left" valign="top"><p>SAFRead ( location , out_byte_variable )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFReadWord</code></p></td><td align="left" valign="top"><p>a function with the parameters: location returns a word value</p></td><td align="left" valign="top"><p>word_variable = SAFRead ( location  )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFReadWord</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: location, word_value</p></td><td align="left" valign="top"><p>SAFRead ( location , word_variable )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFEraseBlock</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: block_number</p></td><td align="left" valign="top"><p>SAFEraseBlock ( 0 )
<br>
<br>
A value of 0,1,2,3 etc.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFWriteBlock</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: block_number, buffer() [,num_blocks ]</p></td><td align="left" valign="top"><p>SAFWriteBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String
<br>
<br>
The Array or a String will contain the values to be wrttin to the SAFM.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAFReadBlock</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: block_number, buffer() [, num_blocks ]</p></td><td align="left" valign="top"><p>SAFReadBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String.
<br>
<br>
The Array or a String will contain the values from the SAFM.</p></td></tr></tbody></table></div><p><br>
<br>
The library also defines a set constants that are specific to the device.&nbsp;&nbsp;&nbsp;
These may be useful in the user program.&nbsp;&nbsp;&nbsp;
These constants are used by the library.&nbsp;&nbsp;&nbsp;
A user may use these public constants.
<br>
<br></p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Type</p></td><td align="left" valign="top"><p>Usage</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAF_ROWSIZE_BYTES</code></p></td><td align="left" valign="top"><p>Byte</p></td><td align="left" valign="top"><p>Size of an SAFM block in bytes</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAF_WORDS</code> and <code class="literal">SAF_BYTES</code></p></td><td align="left" valign="top"><p>Word or a Byte</p></td><td align="left" valign="top"><p>ChipSAFMemWords parameter from the device .dat file</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAF_START_ADDR</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Starting address of SAFM</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">SAF_NUM_BLOCKS</code></p></td><td align="left" valign="top"><p>Byte</p></td><td align="left" valign="top"><p>Number of block of SAFM</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPWORDS</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Device specific constant for the total flash size</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPSAFMEMWORDS</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Device specific constant for the number of SAFM words available</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPERASEROWSIZEWORDS</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Device specific constant for the number of SAFM in an erase row</p></td></tr></tbody></table></div><p><br>
<span class="strong"><strong>Warning</strong></span>
<br>
<br>
Whenever you update the hex file of your Microchip PIC micro-controller with your programmer you MAY erase the data that are stored in SAF memory.&nbsp;&nbsp;&nbsp;
If you want to avoid that you will have to flash your Microchip PIC micro-controller with software that allows memory exclusion when flashing.&nbsp;&nbsp;&nbsp;
This is the case with Microchip PIC MPLAB IPE (Go to <code class="literal">Advanced Mode/Enter password/Select Memory/Tick &#8220;Preserve Flash on Program&#8221;/
Enter Start and End address</code> of your SAFM).&nbsp;&nbsp;&nbsp;Or, simply use the PICkitPlus suite of software to preserve SAF memory during programming.
<br>
<br>
See also
<a class="link" href="_safread.html" title="SAFRead">SAFRead</a>,
<a class="link" href="_safreadword.html" title="SAFReadWord">SAFReadWord</a>,
<a class="link" href="_safwrite.html" title="SAFWrite">SAFWrite</a>,
<a class="link" href="_safwriteword.html" title="SAFWriteWord">SAFWriteWord</a>,
<a class="link" href="_safreadblock.html" title="SAFReadBlock">SAFReadBlock</a>,
<a class="link" href="_safwriteblock.html" title="SAFWriteBlock">SAFWriteBlock</a>,
<a class="link" href="_saferaseblock.html" title="SAFEraseBlock">SAFEraseBlock</a></p></div></body></html>