<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Timer Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_timers.html" title="Timers"><link rel="prev" href="_timers.html" title="Timers"><link rel="next" href="_cleartimer.html" title="ClearTimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_timer_overview"></a>Timer Overview</h4></div></div></div><p>GCBASIC supports methods to set, clear, read, start and stop the microcontroller timers.</p><p>GCBASIC supports the following timers.</p><pre class="screen">    Timer 0
    Timer 1
    Timer 2
    Timer 3
    Timer 4
    Timer 5
    Timer 6
    Timer 7
    Timer 8
    Timer 10
    Timer 12</pre><p>Not all of these timers available on all microcontrollers. For example,
if a microcontroller has three timers, then typically only <code class="literal">Timer0</code>,
<code class="literal">Timer1</code> and <code class="literal">Timer2</code> will be available.</p><p>Please refer to the datasheet for your microcontroller to determine the supported
timers and if a specific timer is 8-bit or 16-bit.</p><p><span class="strong"><strong>Calculating a Timer Prescaler:</strong></span></p><p>To initialise and change the timers you may have to change the Prescaler.</p><p>A Prescaler is an electronic counting circuit used to reduce a high frequency electrical signal to a lower frequency by integer division.
The prescaler takes the basic timer clock frequency and divides it by some value before being processed by the timer, according to how the Prescaler register(s) are configured.
The prescaler values that may be configured might be limited to a few fixed values, see the timer specfic page in this Help file or refer to the datasheet.</p><p>To use a Prescaler some simple integer maths is required, however, when calculating the Prescaler there is often be a tradeoff between resolution, where a high resolution requires a high clock frequency and range where a high clock frequency willl cause the timer to overflow more quickly.
For example, achieving 1 us resolution and a 1 sec maximum period using a 16-bit timer may require some clever thinking when using 8-bit timers.
Please ask for advice via the GCBASIC forum, or, search for some of the many great resources on the internet to calculate a Prescaler value.</p><p><span class="strong"><strong>Common Langauge:</strong></span></p><p>Using timers has the following terms /common langauge.  This following paragraph is intended to explain the common language.</p><p>The Oscillator (OSC) is the system clock, this can be sourced from an internal or external source, OSC is same the as microcontroller Mhz.
This is called the the Frequency of the OSCillator (FOSC) or the System Clock.</p><p>On a Microchip PIC microcontroller, one machine code instruction is executed for every four system clock pulses.<br>
This means that instructions are executed at a frequency of FOSC/4.<br>
The Microchip PIC datasheets call this FOSC/4 or FOSC4.<br>
All Microchip PIC timer prescales are based on the FOSC/4, not the FOSC or the System Clock.<br>
As Prescale are based upon FOSC/4,  you must use FOSC/4 in your timer calculations to get the results you expect.<br>
All Prescale and Postscale values are integer numbers.</p><p>On Atmel AVR microcontroller, most machine code instructions will execute in a single clock pulse.</p><p><span class="strong"><strong>Timer differences between Microchip PIC and Atmel AVR microcontrollers:</strong></span></p><p>Initialising a timer for a Microchip PIC microcontroller may not operate as expected when using the same code for an Atmel AVR microcontroller by simply changing the <code class="literal">#chip</code> definition.
You <span class="strong"><strong>must</strong></span> recalculate the Prescaler of a timer when moving timer parameters between Microchip PIC and Atmel AVR microcontrollers.
And, of course, the same when moving timer parameters between Atmel AVR and Microchip PIC microcontrollers.</p><p><span class="strong"><strong>Timer Best Practices:</strong></span></p><p>Initialising microcontrollers with very limited RAM using GCBASIC needs carefull consideration.
RAM may be need to be optimised by using ASM to control the timers.
You can use GCBASIC to create the timer related GCBASIC ASM code then manually edit the GCBASIC ASM to optmise RAM usage.
Add your revised and optimised ASM back into your program and then remove the no longer required calls the the GCBASIC methods.
If you need advice on this subject please ask for advice via the GCBASIC forum.</p><p><span class="strong"><strong>Using Timers 2/4/6/8 on Microchip PIC microcontrollers.</strong></span></p><p>A Microchip PIC microcontroller can have one of two types of 8-bit timer 2/4/6/8.</p><p>The first type has only one clock source and that clock is the FOSC/4 source.</p><p>The second type is much more flexible and can have many different clock sources and supports more prescale values.</p><p>The timer type for a Microchip PIC microcontroller can be determined by checking for the existence of a T2CLKCON register, either in the Datasheet or in the GCBASIC "dat file" for the specific microcontroller.</p><p>If the microcontroller DOES NOT have a T2CLKCON register then ALL Timer 2/4/6/8 timers on that chip are the first type, and are configured using:</p><pre class="screen">    _InitTimer2 (PreScale, PostScale)_   'Timer2 is example for timer 2/4/6 or 8</pre><p>If the microcontroller DOES have a T2CLKCON register then ALL Timer 2/4/6/8 timers on that chip are the second type and are configured using:</p><pre class="screen">    _InitTimer2 (Source, PreScale, PostScale)_   'Timer2 is example for timer 2/4/6 or 8</pre><p>The possible <span class="emphasis"><em>Source</em></span>, <span class="emphasis"><em>PreScale</em></span> and <span class="emphasis"><em>PostScale</em></span> constants for each type are shown in the GCBASIC Help file.  See each timer for the constants.</p><p>The "Period" of these timers is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&nbsp;&nbsp;&nbsp;The timer period registers are PR2, PR4, PR6 or PR8 for timer2, timer4, timer6 and timer8 respectively.  These registers are also called PRx and TMRx where the <span class="strong"><strong><code class="literal">x</code></strong></span> refers to specific timer number.</p><p>When a specific timer is enabled/started the TMRx timer register will increment until the TMRx register matches the value in the PRx register.&nbsp;&nbsp;&nbsp;At this time the TMRx register is cleared to 0 and the timer continues to increment until the next match of the PRx register, and so on until the timer is stopped.&nbsp;&nbsp;&nbsp;The lower the value of the PRx register, the shorter the timer period will be.&nbsp;&nbsp;&nbsp;The default value for the PRX register at power up is 255.</p><p>The timer interrupt flag (TMRxIF) is set based upon the number of match conditions as determine by the postscaler.&nbsp;&nbsp;&nbsp;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.</p><p><br>
<br>
<br>
<br></p></div></body></html>