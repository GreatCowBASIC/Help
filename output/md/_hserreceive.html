<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HSerReceive</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_rs232_hardware.html" title="RS232 (hardware)"><link rel="prev" href="_hserprintstringcrlf.html" title="HSerPrintStringCRLF"><link rel="next" href="_hserreceivefrom.html" title="HSerReceiveFrom"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hserreceive"></a>HSerReceive</h5></div></div></div><p><span class="strong"><strong>Syntax:</strong></span></p><p><span class="strong"><strong><span class="emphasis"><em>Used as subroutine:</em></span></strong></span></p><pre class="screen">    HSerReceive (<span class="emphasis"><em>user_byte_variable</em></span>)</pre><p>or, if other multiple comports are in use, set the comport before using HSerReceive.</p><pre class="screen">    comport = 1   '(1|2|3|4|5)Not needed unless using multiple comports in use
    HSerReceive (_user_byte_variable_)</pre><p>or, used as function.</p><pre class="screen">  <span class="emphasis"><em>user_byte_variable</em></span> = <code class="literal">HSerReceive</code>  'Supports only USART1
  <span class="emphasis"><em>user_byte_variable</em></span> = <code class="literal">HSerReceive1</code> 'Supports only USART1
  <span class="emphasis"><em>user_byte_variable</em></span> = <code class="literal">HSerReceive2</code> 'Supports only USART2</pre><p>or, used to support assigning of received byte to word (or other multi-byte variables).&nbsp;&nbsp;Note the use of casting to ensure the <code class="literal">HSerReceive</code> uses byte addressing.</p><pre class="screen">  Dim dbAdr as Word

  HSerReceive [byte]dbAdr_H
  HSerReceive [byte]dbAdr</pre><p>For other comports use Function <code class="literal">HSerReceiveFrom</code></p><p><span class="strong"><strong>Command Availability:</strong></span></p><p>Available on all microcontrollers with a USART or UART module.</p><p>Microchip PIC supports USART1,2,3,4 and 5.<br>
Atmel AVR supports USART 1,2,3 and 4.</p><p><span class="strong"><strong>Enabling Constants:</strong></span></p><p>To enable the use of the USART these are the enabling constants. &nbsp;&nbsp;These constants are required.&nbsp;&nbsp;You can change the <code class="literal">USART_BAUD_RATE</code> and to meet your needs.&nbsp;&nbsp;For addition USART ports use <code class="literal">#define USART<span class="strong"><strong>n</strong></span>_BAUD_RATE 9600</code> where <code class="literal"><span class="strong"><strong>n</strong></span>`</code> is the required port number.</p><pre class="screen">    'USART settings for USART1
    #define USART_BAUD_RATE 9600       'Set the baud rate
    #define USART_TX_BLOCKING          'Ensure the transmit buffer is empty
    #define USART_BLOCKING             'Ensures a data byte is in the receive buffer
    #define USART_DELAY OFF	       'Disables USART delays</pre><p><span class="strong"><strong>Explanation:</strong></span></p><p>This command will read a byte from the hardware RS232 module. It can be
used either as a subroutine or as a function. If used as a subroutine, a
variable must be supplied to store the received value in. If used as a
function, it will return the received value.</p><p>The subroutine HSerReceive can get a byte from any comport but must set the comport number immediately before the call.  If &#8221;#define USART_BLOCKING&#8221; is defined then the HserReceive waits in a loop until it receives a byte.   If&#8221; #define USART_BLOCKING&#8221; is NOT defined then HserReceive returns the new byte that was received OR returns 255 because of &#8220;DefaultUsartReturnValue = 255&#8221;  was defined.  This is good because it don&#8217;t hold up your program from executing other  commands and your can check it for new data priodically.</p><p><span class="strong"><strong>Example:</strong></span></p><pre class="screen">  'This program will read a value from the USART, and send it to PORTB.

  #chip 16F877A, 20

  'USART settings
  #define USART_BAUD_RATE 9600  'sets up comport 1 for 9600 baud

  'Set PORTB to output
  Dir PORTB Out
  'Set USART receive pin to input
  Dir PORTC.7 In

  'Main loop
  Do
    'Get serial data and output value to PortB as 8 bit binary
    HSerReceive(InChar)  'Receive data as Subroutine from comport 1
    'InChar = HSerReceive  'Could also be written as Function
    If InChar &lt;&gt; 255 Then   'If value is 255 then it is old data
      PortB = InChar    'If new data then it goes to PortB
    End If
  Loop</pre><p><span class="strong"><strong>Example 2:</strong></span></p><pre class="screen">  'If you choose no &#8220;Blocking&#8221; and comment both of them out.
  'USART settings
  #define USART_BAUD_RATE 9600
  '#define USART_BLOCKING        ' just none OR one of the blocking
  '#define USART_TX_BLOCKING    ' statements should be defined

  'Main loop
  Do
    'Get and display value
    'If there is no new data, HSerReceive will return default value.
    comport = 1
    HSerReceive tempvalue
    If tempvalue &lt;&gt; 255    Then    &#8216; don&#8217;t change PortB if it is default
      PortB = tempvalue
    End If

  Loop</pre><p><span class="strong"><strong>Example 3:</strong></span></p><pre class="screen">  'If you choose no &#8220;Blocking&#8221; and comment both of them out.
  #chip mega328p, 16

  #define USART_BAUD_RATE 9600
  '#define USART_BLOCKING
  '#define USART_TX_BLOCKING

  'Don't forget to Set usart pin directions
  Dir PortD.1 Out    'com1   USART0
  Dir PortD.0 In

  Wait 1 s

  'Message after reset
  HSerPrint "ATmega328P  com test"
  HSerPrintCRLF

  'Main routine  hook up FTDI232 usb to serial and use terminal program to check
  Start:
    comport = 1
    HSerReceive(InChar)    'Subroutine needs the comport set
    'InChar = HSerReceive    ' This function will get from comport 1
      If InChar &lt;&gt; 255 Then    ' check if for received byte
                  'return 255 if old data
        HSerSend InChar    'send back char to UART
      End If
  Goto Start</pre><p><span class="strong"><strong>See also</strong></span> <a class="link" href="_rs232_hardware_overview.html" title="RS232 Hardware Overview">RS232 Hardware Overview</a></p></div></body></html>