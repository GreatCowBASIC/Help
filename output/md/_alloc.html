<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Alloc</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables_operations.html" title="Variables Operations"><link rel="prev" href="_dim.html" title="Dim"><link rel="next" href="_bcdtodec_gcb.html" title="BcdToDec_GCB"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_alloc"></a>Alloc</h4></div></div></div><p><span class="strong"><strong>About Alloc</strong></span></p><p>Alloc creates a special type of variable - an array variant. &nbsp;&nbsp;This array variant can store values.&nbsp;&nbsp;  The values stored in this array variant must be of the same type.</p><p>Essentially, ALLOCate will reserve a memory range as described by the given layout that can be used as a RAM buffer or as an array variant.</p><p>Layout:</p><pre class="screen">  Dim variable_name as ALLOC * memory_size at memory_location</pre><p>The allocated block of memory will not be initialized.</p><p>Example Usage:</p><pre class="screen">  Dim my256bytebuffer as alloc * 256 at 0x2400</pre><p>There is a pointer to allocated memory.  Use @variable_name.</p><p>Example Pointer</p><pre class="screen">    HSerPrint @my256bytebuffer</pre><p><span class="strong"><strong>Extents</strong></span></p><p>This method can be unsafe because undefined behaviour can result if the caller does not ensure that buffer extents are not maintained. &nbsp;&nbsp; Buffer extents are 0 (zero) to the memory_size - 1</p><p>Example Extents:</p><pre class="screen">    my256bytebuffer(0)    = some_variable.  Will address location 0x2400
    my256bytebuffer(255)  = some_variable.  Will address location 0x24FF ' the 256th byte of the allocated memory</pre><p>Implementers of ALLOC must ensure memory constraints remain true.</p><p><span class="strong"><strong>Safety</strong></span></p><p>This method is unsafe because undefined behaviour can result if the caller does not ensure that buffer extents are not maintained. &nbsp;&nbsp;   If buffer extents are exceeded the program may address areas of memory that have adverse impact on the operation of the microcontroller.</p><p>Examples of unsafe usage:</p><pre class="screen">    my256bytebuffer(256) = some_variable.  Will address location 0x2500  ' this is the first byte of BUFFER RAM on the 18FxxQ43 chips... bad things may happen
    my256bytebuffer(65535) = some_variable.  Will address location 0x123FF  ' this is the beyond the memory limit and the operation will write an SFR.</pre><p><span class="strong"><strong>Example Program</strong></span></p><p>The following example program shows the ALLOCation of a 256 byte buffer at a specific address.&nbsp;&nbsp;
The array variant is then populated with data and then shown on a serial terminal.</p><pre class="screen">        ' Chip Settings and preamble
        #CHIP  18F27Q43
        #OPTION EXPLICIT


        'Generated by PIC PPS Tool for GCBASIC - this explicit to a specific chip
        #startup InitPPS, 85
        #define PPSToolPart 18f27q43

        Sub InitPPS

                'Module: UART pin directions
                Dir PORTC.6 Out    ' Make TX1 pin an output
                'Module: UART1
                RC6PPS = 0x0020    'TX1 &gt; RC6

        End Sub
        'Template comment at the end of the config file

        ' USART settings for USART1
        #DEFINE USART_BAUD_RATE 9600
        #DEFINE USART_TX_BLOCKING
        #DEFINE USART_DELAY 0

        '---------------------------
        ' Main Program

        #DEFINE BUFFERSIZE 256  ' gives range of 0 to 255

        'DIMension an ArrayVariant using ALLOC to create an ArrayVariant with the size of BUFFERSIZE.
        'This array is created at memory location 0x2400.
        'This memory location is specific to this chip ( you must ensure other microcontrollers address are valid).

        Dim mybuffer1 as ALLOC * BUFFERSIZE at 0x2400

        'A data table
        Table myDataTable
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
            0,1,2,3,4,5,6,7,8,9,0x0A,0X0B,0X0C,0X0D,0X0E,0X0F
        End Table

        Dim iLoop, tableDataValue, memoryDataValue as byte

        'These varaibles are ONLY used to demonstrate the showing of the allocated memory address
        Dim mybuffer1startaddress, mybuffer1endaddress as word

        mybuffer1startaddress = @mybuffer1
        mybuffer1endaddress = mybuffer1startaddress + BUFFERSIZE - 1


        HSerPrintCRLF 2
        HSerPrint "Buffer test - 256 bytes "
        HSerPrint " at address: 0x"
        HSerPrint hex( mybuffer1startaddress_h )
        HSerPrint hex( mybuffer1startaddress )
        HSerPrint " to 0x"
        HSerPrint hex( mybuffer1endaddress_h )
        HSerPrint hex( mybuffer1endaddress )
        HSerPrintCRLF 2

        'Load buffer with table data
        for iLoop = 0 to 255
            ReadTable myDataTable, [word]iLoop+1, tableDataValue
            mybuffer1( iLoop ) = tableDataValue
        next

        wait 100 ms

        HserPrint "Print dataDump array to serial terminal"
        HSerPrintCRLF
        for iLoop = 0 to 255
            HSerPrint leftpad(str( myBuffer1(iLoop)),3)
            If iLoop % 16 = 15 Then HSerPrintCRLF
        next

        Wait 100 ms
        HSerPrintCRLF
        HserPrint "Print memory to serial terminal using PEEK to get the memory location byte value"
        HSerPrintCRLF
        for iLoop = 0 to 255
            memoryDataValue = PEEK ( @myBuffer1+iLoop )
            HSerPrint leftpad(str( memoryDataValue ) ,3)
            If iLoop % 16 = 15 Then HSerPrintCRLF
        next
        HSerPrintCRLF
        Wait 100 ms</pre><p><span class="strong"><strong>For more help, see</strong></span> <a class="link" href="_dim.html" title="Dim">Declaring arrays with DIM</a></p></div></body></html>