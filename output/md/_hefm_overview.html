<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HEFM Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_hefm_pfm.html" title="HEFM ( PFM )"><link rel="prev" href="_hefm_pfm.html" title="HEFM ( PFM )"><link rel="next" href="_hefread.html" title="HEFRead"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_hefm_overview"></a>HEFM Overview</h5></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>Some enhanced mid-range Microchip PIC devices support High-Endurance Flash (HEF) memory. These devices lack the data EEPROM found on other devices.&nbsp;&nbsp;&nbsp;
Instead, they implement an equivalent amount of special flash memory, called HEF memory, that can provide an endurance comparable to that of a traditional data EEPROM.&nbsp;&nbsp;&nbsp;
HEF memory can be erased and written 100,000 times.&nbsp;&nbsp;&nbsp;
HEF memory appears in the regular program memory space and can be used for any purpose, like regular flash program memory.&nbsp;&nbsp;&nbsp;
<br>
<br>
As with all flash memory, data must be erased before it can be written and writing this memory will stall the device.&nbsp;&nbsp;&nbsp;
Methods to read, write and erase the HEF memory are included in GCBASIC and they are described in this introduction.&nbsp;&nbsp;&nbsp;Also see Microchip application note AN1673, Using the PIC16F1XXX High-Endurance Flash (HEF) Block.
<br>
<br>
The <code class="literal">hefsaf.h</code> library supports HEF operations for GCBASIC.
<br>
<br>
Note:  By default, GCBASIC will use HEF memory for regular executable code unless it is told otherwise.&nbsp;&nbsp;&nbsp;
If you wish to store data here, you should reserve the HEF memory by using the compiler option, as shown below to reserve 128 words of HEF memory:</p><pre class="screen">    #option ReserveHighProg 128</pre><p>HEF memory is a block of memory locations found at the top of the flash program memory.    &nbsp;&nbsp;&nbsp;
Each memory location can be used to hold a 8-bit byte value.    &nbsp;&nbsp;&nbsp;
To further explain, the PIC 16F Enhanced Midrange Sevices memory architecture is 14-bits wide. &nbsp;&nbsp;&nbsp;   Therefore, for a single 14-bit memory location it is only practical to store an 8-bit byte value, and two 14-bit memory locations to hold one 16-bit word value.    &nbsp;&nbsp;&nbsp;
This is because the memory architecture only allows the use of the the lower 8-bits  of each 14-bit flash memory location for HEF usage
<br>
<br>
The main difference between HEF memory and EEPROM is that EEPROM allows byte-by-byte erase whereas the HEF memory does not.&nbsp;&nbsp;&nbsp;
With HEF memory, data must be erased before a write and the erase can only be performed in blocks of memory.&nbsp;&nbsp;&nbsp;
The blocks, also called rows, are a fixed size associated with the specific device.&nbsp;&nbsp;&nbsp;
<br>
<br>
GCBASIC handles the erase operation automatically.&nbsp;&nbsp;&nbsp;
When a write operation is used by a user the GCBASIC library reads to a cache, updates the cache, erase the block and finally write the caches.&nbsp;&nbsp;&nbsp;
The complexity of using HEF memory is reduced with the automatically handling of these operations.&nbsp;&nbsp;&nbsp;</p><p><br>
<br>
The <code class="literal">hefsaf.h</code> library provides a set of methods to support the use of HEF memory.
<br>
<br></p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top"><p>Method</p></td><td align="left" valign="top"><p>Parameters</p></td><td align="left" valign="top"><p>Usage</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFWrite</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: location, byte value</p></td><td align="left" valign="top"><p>HEFWrite ( location, byte_variable )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFWriteWord</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: location, word_value</p></td><td align="left" valign="top"><p>HEFWriteWord ( location, word_variable  )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFRead</code></p></td><td align="left" valign="top"><p>a function with the parameters: location returns a byte value</p></td><td align="left" valign="top"><p>byte_variable = HEFRead ( location  )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFRead</code></p></td><td align="left" valign="top"><p>a subroutine with the paramers: location, byte_value</p></td><td align="left" valign="top"><p>HEFRead ( location , out_byte_variable )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFReadWord</code></p></td><td align="left" valign="top"><p>a function with the parameters: location returns a word value</p></td><td align="left" valign="top"><p>word_variable = HEFRead ( location  )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFReadWord</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: location, word_value</p></td><td align="left" valign="top"><p>HEFRead ( location , out_word_variable )</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFEraseBlock</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: block_number</p></td><td align="left" valign="top"><p>HEFEraseBlock ( 0 )
<br>
<br>
A value of 0,1,2,3 etc.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFWriteBlock</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: block_number, buffer() [, HEF_ROWSIZE_BYTES ]</p></td><td align="left" valign="top"><p>HEFWriteBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String
<br>
<br>
The Array or a String will contain the values to be wrttin to the HEFM.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEFReadBlock</code></p></td><td align="left" valign="top"><p>a subroutine with the parameters: block_number, buffer() [, HEF_ROWSIZE_BYTES ]</p></td><td align="left" valign="top"><p>HEFReadBlock( 0, myMemoryBuffer ) 'where myMemoryBuffer is an Array or a String.
<br>
<br>
The Array or a String will contain the values from the HEFM.</p></td></tr></tbody></table></div><p><br>
<br>
The library also defines a set constants that are specific to the device.&nbsp;&nbsp;&nbsp;
These may be useful in the user program.&nbsp;&nbsp;&nbsp;
These constants are used by the library.&nbsp;&nbsp;&nbsp;
A user may use these public constants.
<br>
<br></p><div class="informaltable"><table border="1" width="80%"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top"><p>Constant</p></td><td align="left" valign="top"><p>Type</p></td><td align="left" valign="top"><p>Usage</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEF_ROWSIZE_BYTES</code></p></td><td align="left" valign="top"><p>Byte</p></td><td align="left" valign="top"><p>Size of an HEFM block in words</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEF_WORDS</code> and <code class="literal">HEF_BYTES</code></p></td><td align="left" valign="top"><p>Word or a Byte</p></td><td align="left" valign="top"><p>ChipHEFMemWords parameter from the device .dat file</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEF_START_ADDR</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Starting address of HEFM</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">HEF_NUM_BLOCKS</code></p></td><td align="left" valign="top"><p>Byte</p></td><td align="left" valign="top"><p>Number of blocks of HEFM</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPWORDS</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Device specific constant for the total flash size</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPHEFMEMWORDS</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Device specific constant for the number of HEFM words available</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CHIPERASEROWSIZEWORDS</code></p></td><td align="left" valign="top"><p>Word</p></td><td align="left" valign="top"><p>Device specific constant for the number of HEFM in an erase row</p></td></tr></tbody></table></div><p><br>
<br></p><p><br>
<br></p><p><span class="strong"><strong>Warning</strong></span></p><p>Whenever you update the hex file of your Microchip PIC micro-controller with your programmer you MAY erase the data that are stored in HEF memory.&nbsp;&nbsp;&nbsp;
If you want to avoid that you will have to flash your Microchip PIC micro-controller with software that allows memory exclusion when flashing.&nbsp;&nbsp;&nbsp;
This is the case with Microchip PIC MPLAB IPE (Go to <code class="literal">Advanced Mode/Enter password/Select Memory/Tick &#8220;Preserve Flash on Program&#8221;/
Enter Start and End address</code> of your HEFM).&nbsp;&nbsp;&nbsp;Or, simply use the PICkitPlus suite of software to preserve HEF memory during programming.
<br>
<br>
See also
<a class="link" href="_hefread.html" title="HEFRead">HEFRead</a>,
<a class="link" href="_hefreadword.html" title="HEFReadWord">HEFReadWord</a>,
<a class="link" href="_hefwrite.html" title="HEFWrite">HEFWrite</a>,
<a class="link" href="_hefwriteword.html" title="HEFWriteWord">HEFWriteWord</a>,
<a class="link" href="_hefreadblock.html" title="HEFReadBlock">HEFReadBlock</a>,
<a class="link" href="_hefwriteblock.html" title="HEFWriteBlock">HEFWriteBlock</a>,
<a class="link" href="_heferaseblock.html" title="HEFEraseBlock">HEFEraseBlock</a></p></div></body></html>