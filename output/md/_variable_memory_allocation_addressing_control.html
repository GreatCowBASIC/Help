<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Variable Memory Allocation, Addressing &amp; Control</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_variables.html" title="Variables"><link rel="prev" href="_advanced_variabletypes.html" title="Advanced VariableTypes"><link rel="next" href="_reference_data.html" title="Reference Data"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_variable_memory_allocation_addressing_control"></a>Variable Memory Allocation, Addressing &amp; Control</h3></div></div></div><p>This section discusses the allocation of variables to RAM ( GPR, SRAM or other TLA).</p><p>Variables in GCBASIC can be bits, bytes, words, integers, longs, arrays or reals. &nbsp;&nbsp;This section will NOT address reals as these are developmental variables only.</p><p>Variables can also be defined as Aliases - this is discussed later in this section.</p><p><span class="strong"><strong>Basic variable allocation</strong></span></p><p>Variables of  type <span class="emphasis"><em>byte</em></span>, <span class="emphasis"><em>word</em></span>, <span class="emphasis"><em>integer</em></span>, <span class="emphasis"><em>longs</em></span> are placed in RAM using the following simple rules.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">A RAM memory location  is automatically assigned starting at the first available memory location.</li><li class="listitem">The first memory location is first RAM location as defined in the chip datasheet.</li><li class="listitem">Once a variable is allocated the RAM location is marked as used and this specific location can be reviewed in the ASM source.</li><li class="listitem">Bytes use a single  RAM location, words two  RAM locations, integer and longs four  RAM locations.</li><li class="listitem">Subsequent variables of type byte, word, integer, longs are placed in RAM at the next available RAM location.</li></ol></div><p>Variables of  <span class="emphasis"><em>array</em></span> and <span class="emphasis"><em>strings</em></span> type are placed in RAM using the following simple rules.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">A RAM memory location is automatically assigned from the end of RAM less the ( size of the array + 1 byte ).</li><li class="listitem">The last memory location is last RAM location as defined in the chip datasheet.</li><li class="listitem">Once an array is allocated the RAM location is marked as used and the start of the array RAM location can be reviewed in the ASM source.</li><li class="listitem">Subsequent variables of type array in RAM at the next available RAM location subtracted from the start the of previous RAM location minus the size of this next array.</li></ol></div><p>Variables of <span class="emphasis"><em>bit</em></span> type are placed in RAM using the following simple rules.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Bit memory location is automatically assigned to the first bit with the creation of a BYTE variable at a RAM memory location that is automatically assigned starting at the first available memory location. &nbsp;&nbsp; This byte can handle 8 bits.</li><li class="listitem">Once a bit is allocated the byte is marked as used and this specific location can be reviewed in the ASM source.</li><li class="listitem">Subsequent bits are allocation either to an existing byte variable, or when 8 bits are allocated to an existing byte variable another byte variable will be created.</li></ol></div><p><span class="strong"><strong>Addressing Variables</strong></span></p><p>Addressing a variable memory address can be achieved by using the @ prefix. &nbsp;&nbsp; This will return the address of the variable ( @ applies to table data and any data block).</p><p>The following example shows registers DMAnSSAU, DMAnSSAH, DMAnSSAL being loaded with the address of the array WaveArray.</p><pre class="screen">    ' Source start address
    Dim addressdummy as byte
    Dim DMAnSS as long ALIAS addressdummy, DMAnSSAU, DMAnSSAH, DMAnSSAL
    DMAnSS = @WaveArray</pre><p><br></p><p><span class="strong"><strong>AT allocation</strong></span></p><p>The Dim variable command can be used to instruct GCBASIC to allocate variables  at a specific memory location using the parameter AT.</p><p>The compiler will inspect the provided AT memory location and if the memory location is already used ( by an existing variable), lower than the minimum memory location or greater than the maximum memory location an error will be issued.</p><p><br>
<span class="strong"><strong>Variable Aliases</strong></span></p><p>Variable can be defined as  aliases. &nbsp;&nbsp; Aliases  are used to refer to existing memory locations SFR or RAM and aliases can be used to construct other variables.&nbsp;&nbsp;  Constructed variables can be a mix  ( or not ) of SFR or RAM.  &nbsp;&nbsp; These are useful for joining predefined byte variables together to form a word/long variable.</p><p>Aliases are not like pointers in many languages - they must always refer to an existing variable or variables and cannot be changed.</p><p>When setting a register/variable bit ( i.e  my_variable.my_bit_address_variable ) and using a alias for the variable then you must ensure the bytes that construct the variable are consecutive.</p><p>Aliases are shown in the ASM source in the ;ALIAS VARIABLES section.</p><p>The coding approach should be to DIMension the variable (word, integer, or long) first, then create the byte aliases:</p><pre class="screen">    Dim my_variable as LONG
    Dim ByteOne   as Byte alias my_variable_E
    Dim ByteTwo   as Byte alias my_variable_U
    Dim ByteThree as Byte alias my_variable_H
    Dim ByteFour  as Byte alias my_variable

    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    'then, use the four byte variables as you need to.</pre><p>To set a series of registers that are not consecutive, it is recommended to use a mask variable then apply it to the registers:</p><pre class="screen">    Dim my_variable as LONG
    Dim my_bit_address_variable as Byte
    my_bit_address_variable = 23

    'set the bit in the variable
    my_variable.my_bit_address_variable = 1

    porta =  my_variable_E
    portb =  my_variable_E
    portc =  my_variable_E
    portd =  my_variable_E</pre><p><span class="strong"><strong>Memory Specification</strong></span></p><p>All memory specifics like RAM size, lower and upper RAM addresses are specified in the chip specific dat file.</p><p>The dat file details should be reviewed in PICINFO application.   See the PICINFO/CHIPDATA tab for RAM and MaxAddress etc.</p><p>A simple calculation is MaxAddress - RAM +1 = the 'first memory address'.  And, 'first memory address' + RAM -1 = 'the last memory address.</p><p>This can be confirmed by review the DAT file. See the section [FreeRAM] for the start and end of RAM.</p><p>The dat file also has a [NoBankRAM].  NoBankRAM is somewhat misnamed - it is used for the defintion of (any) access bank locations.&nbsp;&nbsp; If a memory location is defined in both NoBankRAM and FreeRAM, then the compiler knows that it is access bank RAM.&nbsp;&nbsp;If an SFR location is in one of the NoBankRAM ranges, then the compiler knows not to do any bank selection when accessing that register.</p><p>The [NoBankRAM] section includes two ranges, one for access bank RAM, one for access bank SFRs.
The first range MUST be the ACCESS RAM range
The first range is the FAST SFR range</p><p>If there are no ranges defined in NoBankRAM, the compiler will try to guess them.&nbsp;&nbsp;
On 18Fs, it will guess based on where the lowest SFR is, and from what the total RAM on the chip is.&nbsp;&nbsp; If there&#8217;s only one range defined. &nbsp;&nbsp; in the NoBankRAM locations, the compiler will assume that is the range for the RAM, and then will guess where the range for the access bank SFRs is.</p><pre class="screen">    'GCBASIC/GCGB Chip Data File
    'Chip: 18F27Q43

    [ChipData]

    .... many other data rows

    'This constant is exposed as ChipRAM
    RAM=8192             'Dec values

    .... many other data rows

    'This constant is exposed as ChipMaxAddress
    MaxAddress=9471      'Dec values

    .... many other data rows

    [FreeRAM]
    500:24FF             'Hex value

    [NoBankRAM]
    500:55F              'Hex value
    460:4FF              'Hex value

    .... many other data rows</pre><p><br></p><p>In the example shown above the following can be extracted.
<br></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">RAM size:              RAM = 8192d</li><li class="listitem">Minimum RAM address:   FREERAM = 0x500</li><li class="listitem">Maximum RAM address:   FREERAM = 0x24FF</li><li class="listitem">Maximum RAM address:   MAXADDRESS=9471d or 0x24FF</li><li class="listitem">ACCESS RAM:            NOBANKRAM = 0x500-0x55F</li><li class="listitem">BANKED SFR:            NOBANKRAM = 0x460-0x4FF</li></ol></div><p><br>
<br></p></div></body></html>