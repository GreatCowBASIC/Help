<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>I2C Overview</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_i2c_software.html" title="I2C Software"><link rel="prev" href="_i2c_software.html" title="I2C Software"><link rel="next" href="_i2cackpollstate.html" title="I2CAckPollState"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_i2c_overview"></a>I2C Overview</h4></div></div></div><p><span class="strong"><strong>Introduction:</strong></span></p><p>These software routines allow GCBASIC programs to send and receive I2C
messages. They can be configured to act as master or slave, and the
speed can also be altered.</p><p>No hardware I2C module is required for these routines - all
communication is handled in software. However, these routines will not
work on 12-bit instruction Microchip PIC microcontrollers (10F, 12F5xx and 16F5xx chips).</p><p><span class="strong"><strong>Relevant Constants:</strong></span></p><p>These constants control the setup of the software I2C routines:</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top"><span class="strong"><strong>Constant</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Controls</strong></span></th><th align="left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top"><p>I2C_MODE</p></td><td align="left" valign="top"><p>Mode of I2C routines (Master or Slave)</p></td><td align="left" valign="top"><p>Master</p></td></tr><tr><td align="left" valign="top"><p>I2C_DATA</p></td><td align="left" valign="top"><p>Pin on microcontroller connected to I2C data</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p>I2C_CLOCK</p></td><td align="left" valign="top"><p>Pin on microcontroller connected to I2C clock</p></td><td align="left" valign="top"><p>N/A</p></td></tr><tr><td align="left" valign="top"><p>I2C_BIT_DELAY</p></td><td align="left" valign="top"><p>Time for a bit (used for acknowledge detection)</p></td><td align="left" valign="top"><p>2 us</p></td></tr><tr><td align="left" valign="top"><p>I2C_CLOCK_DELAY</p></td><td align="left" valign="top"><p>Time for clock pulse to remain high</p></td><td align="left" valign="top"><p>1 us</p></td></tr><tr><td align="left" valign="top"><p>I2C_END_DELAY</p></td><td align="left" valign="top"><p>Time between clock pulses</p></td><td align="left" valign="top"><p>1 us</p></td></tr><tr><td align="left" valign="top"><p>I2C_USE_TIMEOUT</p></td><td align="left" valign="top"><p>Set to true if the I2C routines should stop waiting for the
I2c bus - the routine will exit if a timeout occurs.
Should be used when you need to prevent system lockups on the I2C bus.
</p><p>Supports both software I2C master and slave mode.
</p><p>Will return the variable <code class="literal">I2CAck = FALSE</code> when a timeout has occurred.</p></td><td align="left" valign="top"><p>Not Set</p></td></tr><tr><td align="left" valign="top"><p>I2C_DISABLE_INTERRUPTS</p></td><td align="left" valign="top"><p>Disable interrupts during I2C routines. Important when an i2C clock is
part of your solution</p></td><td align="left" valign="top"><p>Not defined.</p></td></tr></tbody></table></div><p><span class="strong"><strong>Example:</strong></span>
This example examines the IC2 devices and displays on a terminal.
This code will require adaption but the code shows an approach to discover the IC2 devices.</p><pre class="screen">  ' I2C Overview - using the ChipIno board, see here for information
  #chip 16F886, 8
  #config MCLRE_ON

  ' Define I2C settings
  #define I2C_MODE Master
  #define I2C_DATA PORTC.4
  #define I2C_CLOCK PORTC.3
  #define I2C_DISABLE_INTERRUPTS ON

  'USART/SERIAL PORT via a MAX232 TO PC Terminal
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING

  Dir PORTc.6 Out
  #define USART_DELAY 0 ms

  HSerPrintCRLF 2
  HSerPrint "I2C Discover using the ChipIno"
  HSerPrintCRLF 2

  HSerPrint "Started: "
  HSerPrint "Searching I2C address space: v0.85"
  HSerPrintCRLF

  wait 100 ms
  dim DeviceID as byte
  for DeviceID = 0 to 255
    I2CStart
    I2CSend ( deviceID )
    I2CSend ( 0 )
    I2CSend ( 0 )
    i2cstop

    if I2CSendState = True  then

      HSerPrint   "__"
      HSerPrint   "ID: 0x"
      HSerPrint   hex(deviceID)
      HSerPrint   " (d"
      HSerPrint   Str(deviceID)
      HSerPrint   ")"
      HSerPrintCRLF
    end if
  next
  HSerPrint   "End of Device Search": HSerPrintCRLF 2
  End</pre><p>Supported in &lt;I2C.H&gt;</p></div></body></html>