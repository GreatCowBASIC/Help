<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>COMPILER SOURCE INSIGHTS</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_gcbasic_maintenance_and_development.html" title="GCBASIC Maintenance and Development"><link rel="prev" href="_development_guide_for_gcbasic_exe_compiler.html" title="Development Guide for GCBASIC.EXE compiler"><link rel="next" href="_about_glcd_library_support.html" title="ABOUT GLCD Library Support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_compiler_source_insights"></a>COMPILER SOURCE INSIGHTS</h3></div></div></div><p><span class="emphasis"><em>There are many very useful methods</em></span>, a lot of methods, look at existing code before adding any new method.&nbsp;&nbsp;
The compiler is mature from a functionality standpoint.&nbsp;&nbsp;
Just immature in terms of documentation.&nbsp;&nbsp;</p><p><span class="strong"><strong>COMPILER DEBUGGING</strong></span></p><p><span class="emphasis"><em>To debug or isolate a specific issue</em></span> use lots of messages using PRINT or HSERPRINT&nbsp;&nbsp;Both of these methods are easy to setup and use.</p><p><span class="emphasis"><em>Specific to #SCRIPT</em></span> you can use WARNING messages to display results of calculations or assignments.</p><p><span class="emphasis"><em>Specific to CONDITIONAL Compilation</em></span> use <code class="literal">conditionaldebugfile</code> (se above) to display conditional statement debug for the specified file. &nbsp;&nbsp; Options are any valid source file or nothing. &nbsp;&nbsp;
Nested conditions are evaluated sequentially, therefor the first, second, third etc etc.  &nbsp;&nbsp;
The compiler does not at this point rationalised the hierarchy of nested conditions.&nbsp;&nbsp;  It simply finds a condition and then matches to an #ENDIF.&nbsp;&nbsp;
So, the compiler walks through the nested conditions as the outer nested, then the next nest, the next nest etc. etc.&nbsp;&nbsp;
This compiler is completing the following actions:&nbsp;&nbsp;</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">If the conditional is not valid.&nbsp;&nbsp;  Remove the code segment include the #IF and the #ENDIF</li><li class="listitem">If the conditional is valid.&nbsp;&nbsp;  Remove the just the #IF and the #ENDIF</li></ol></div><p>So, is this context the compiler walks the code many time (as these are lists not arrrays this is blindly fast) removing code segments.&nbsp;&nbsp;</p><p>The following program shows the impact of nested conditions..&nbsp;&nbsp;Each nest is evaluated until all conditions have been assessed..&nbsp;&nbsp;See the comment section of the listing to see the output from the debugging.</p><pre class="screen">        #CHIP 18F16Q41
        #OPTION EXPLICIT

        ; -----  Add the following line to USE.ini ------------------
        ;
        ;        conditionaldebugfile = IFDEF_TEST.gcb
        ;
        ; -----------------------------------------------------------

        #IFDEF PIC
            #IFDEF ONEOF(CHIP_18F15Q41, CHIP_18F16Q41)
                #IF CHIPRAM = 2048  'TRUE
                    #IF CHIPWORDS = 32768 ' TRUE
                        #IFDEF VAR(NVMLOCK) 'TRUE
                            #IFDEF VAR(OSCCON2)  'TRUE
                                #IFDEF  VAR(NVMCON0)  'TRUE    set var1 to 1
                                    DIM _VAR1
                                    _VAR1 = 1
                                #ENDIF
                            #ENDIF
                        #ENDIF
                    #ENDIF
                #ENDIF

                #IF CHIPRAM = 4096  'TRUE
                    #IF CHIPWORDS = 32768 ' TRUE
                        #IFDEF VAR(NVMLOCK) 'TRUE
                            #IFDEF VAR(OSCCON2)  'TRUE
                                #IFDEF  VAR(NVMCON0)  'TRUE   = set var1 to 0
                                    DIM _VAR1
                                    _VAR1 = 0
                                #ENDIF
                            #ENDIF
                        #ENDIF
                    #ENDIF
                #ENDIF
            #ENDIF
        #ENDIF

        Do
        Loop

        // ===============================================
        // ***  Below is debugger output for this file ***
        // ===============================================

        // GCBASIC (0.99.02 2022-07-21 (Windows 32 bit) : Build 1143)

        // Compiling c:\Users\admin\Downloads\IFDEF_TEST.gcb

        //               13: #IFDEF PIC
        //               15: #IFDEF ONEOF(CHIP_18F15Q41, CHIP_18F16Q41)
        //               17: #IF CHIPRAM = 2048
        //               19: #IF CHIPWORDS = 32768
        //               21: #IFDEF VAR(NVMLOCK)
        //               23: #IFDEF VAR(OSCCON2)
        //               25: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               27: DIM _VAR1
        //               ;_VAR1 = 1
        //               28: _VAR1 = 1

        //               15: #IFDEF ONEOF(CHIP_18F15Q41, CHIP_18F16Q41)
        //               17: #IF CHIPRAM = 2048
        //               19: #IF CHIPWORDS = 32768
        //               21: #IFDEF VAR(NVMLOCK)
        //               23: #IFDEF VAR(OSCCON2)
        //               25: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               27: DIM _VAR1
        //               ;_VAR1 = 1
        //               28: _VAR1 = 1

        //               39: #IF CHIPRAM = 4096
        //               41: #IF CHIPWORDS = 32768
        //               43: #IFDEF VAR(NVMLOCK)
        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               41: #IF CHIPWORDS = 32768
        //               43: #IFDEF VAR(NVMLOCK)
        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               43: #IFDEF VAR(NVMLOCK)
        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               45: #IFDEF VAR(OSCCON2)
        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        //               47: #IFDEF VAR(NVMCON0)
        //               ;DIM _VAR1
        //               49: DIM _VAR1
        //               ;_VAR1 = 0
        //               50: _VAR1 = 0

        // Program compiled successfully (Compile time: 1 seconds)

        // Assembling program using GCASM
        // Program assembled successfully (Assembly time: 0.125 seconds)
        // Done</pre><p><br>
<br></p><p>The resulting ASM from the about code is as expected.&nbsp;&nbsp;The assignment of <code class="literal">VAR1 = 0</code>.&nbsp;&nbsp;</p><pre class="screen">        ;DIM _VAR1
        ;_VAR1 = 0
            clrf	_VAR1,ACCESS
        ;Do
        SysDoLoop_S1
        ;Loop
            bra	SysDoLoop_S1
        SysDoLoop_E1</pre><p><br></p><p><span class="strong"><strong>COMPILERDEBUG</strong></span></p><p>The COMPILERDEBUG setting in the USE.INI file for GCBASIC is used to enable or disable debugging features for the compiler.&nbsp;&nbsp;When the bits of the setting COMPILERDEBUG are set to 1, it activates additional debug information during compilation, which can be helpful for developers to diagnose and fix issues.</p><p>To see the permissible bits for COMPILERDEBUG first opening and closing the PREFERENCES editor ( this does imply that the PREFERENCES EDITOR is maintained to show the Header in the USE.INI), and then edit USE.INI.&nbsp;&nbsp;The help section will display the following:</p><pre class="screen">    'Preferences file for GCBASIC Preferences 3.14

    ... lots of help, then

    '   compilerdebug =  0  - 1 = COMPILECALCADD
    '                       - 2 = VAR SET
    '                       - 4 = CALCOPS
    '                       - 8 = COMPILECALCMULT
    '                       - 16 = AUTOPINDIR
    '                       - 32 = ADRDX
    '                       - 64 = GCASM
    '                       - 128 = COMPILESUBCALLS
    '                       - 256 = COMPILEUPDATESUBMAP</pre><p>To see the debug add or edit the [gcbasic] section of USE.INI.</p><pre class="screen">    [gcbasic]
    'change to a bitwise value
    compilerdebug = 0</pre><p>As previously stated.  This setting can be helpful for developers to diagnose and fix issues within the compiler.</p></div></body></html>