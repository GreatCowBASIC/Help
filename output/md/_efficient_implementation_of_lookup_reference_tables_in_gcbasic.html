<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Efficient Implementation of Lookup Reference Tables in GCBASIC</title><link rel="stylesheet" type="text/css" href="gcbdoc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="GCBASIC documentation"><link rel="up" href="_reference_data.html" title="Reference Data"><link rel="prev" href="_reference_data.html" title="Reference Data"><link rel="next" href="_syntax.html" title="Syntax"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_efficient_implementation_of_lookup_reference_tables_in_gcbasic"></a>Efficient Implementation of Lookup Reference Tables in GCBASIC</h3></div></div></div><p><span class="strong"><strong>Introduction</strong></span></p><p>This section explores the efficient implementation of lookup reference tables in embedded systems, specificially GCBASIC, focusing on the use of PROGMEM memory to store fixed data sets. It addresses common misconceptions about data storage and initialization, compares different methods of data handling, and provides advanced techniques for optimizing memory usage.</p><p>Lookup reference tables are essential in embedded systems for storing fixed data sets that can be accessed during runtime. This section aims to clarify the correct implementation of these tables, debunking common myths and providing practical solutions for efficient data management.</p><p><span class="strong"><strong>Conventional Misconceptions</strong></span></p><p>A common misconception is that the data required by a fixed lookup table is defined by its content and declared in a Dim statement, with its data filled at runtime. This implies that an array ( in RAM memory ) is empty initially and populated during initialization, leading to data duplication and wasted memory resources.</p><p><span class="strong"><strong>Correct Implementation</strong></span></p><p>A fixed lookup table is a set of data (bytes, words, etc.) stored in the PROGMEM memory. The correct implementation involves using the TABLE and READTABLE commands:
* Definition: <code class="literal">TABLE tablename&#8230;&#8203; data&#8230;&#8203; END TABLE</code>
* Reading: <code class="literal">READTABLE</code>
There is no DIM in the definition process, and the data is part of the hex file, not filled at runtime.</p><p><span class="strong"><strong>Memory Efficiency</strong></span></p><p>Storing data in PROGMEM ensures that there is only one copy of the data, avoiding duplication. Copying data to an array is redundant as reading the table can replace the array.</p><p><span class="strong"><strong>Practical Solutions</strong></span></p><p>Using <code class="literal">TABLE - END TABLE</code> is the simplest way to handle data. For data sets smaller than the EEPROM in the chip, load the table directly to EEPROM and use <code class="literal">READTABLE</code> to read the data.</p><p><span class="strong"><strong>Advanced Techniques</strong></span></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">PROGMEM Page Size Constraint: On the 16F, <code class="literal">TABLE-END TABLE</code> is constrained by PROGMEM page size (2048 items).</li><li class="listitem">EEPROM Storage: Use <code class="literal">EEPROM .. END EEPROM</code> and a direct method like <code class="literal">PROGREAD</code>. Data is stored in EEPROM, constrained by its size and typically byte values.</li><li class="listitem">Direct PROGMEM Storage: Use <code class="literal">DATA .. END DATA</code> and <code class="literal">PROGREAD</code>. Data is stored in PROGMEM, constrained by unused PROGMEM size and typically word values (max 0x3FFF for 16F chips).</li></ol></div><p><span class="strong"><strong>Arrays in Embedded Systems</strong></span></p><p>An array is a special type of variable that can store multiple values, addressed individually using an index. Arrays can be bytes, longs, integers, or words, and are held in RAM. Loading an array can be done element by element or all at once.</p><p><span class="strong"><strong>Comparison of Methods</strong></span></p><p>Using arrays can be costly in terms of RAM and PROGMEM. The following examples illustrate the difference:</p><p><span class="strong"><strong>Using an Array</strong></span></p><p>64 words Progmem / 13 bytes RAM</p><pre class="screen">        #CHIP 18F2550
        #option Explicit

        Dim myResult, myIndex as Byte

        // Using an array 64 words Progmem / 13 bytes RAM
        Dim myArray(10)
            myArray = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
        For myIndex = 1 to 10
            myResult =  myArray(myIndex)
        Next</pre><p><span class="strong"><strong>Using a Table</strong></span></p><p>56 words Progmem / 2 bytes RAM</p><pre class="screen">        #CHIP 18F2550
        #option Explicit

        Dim myResult, myIndex as Byte

        // Using a table 56 words Progmem / 2 bytes RAM
        For myIndex = 1 to 10
            ReadTable myTable, myIndex, myResult
        Next

        Table myTable
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10
        End Table</pre><p><span class="strong"><strong>Usage</strong></span></p><p>The <code class="literal">ReadTable</code> method provides data set capabilities to chips with limited RAM, using fewer resources and offering faster performance. Advanced techniques and proper understanding of memory usage can significantly optimize embedded system performance.</p><p><span class="strong"><strong>Notes</strong></span></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">A byte array is handled similarly to a string, which can be resource-intensive.</li></ul></div><p>By following these guidelines, developers can efficiently implement lookup reference tables in embedded systems, optimizing memory usage and performance.</p></div></body></html>